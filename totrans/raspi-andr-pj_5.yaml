- en: Chapter 5. Missed Calls with Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement a much more programming-oriented project
    and dive into Bluetooth Smart or **Bluetooth Low Energy** (**BLE**) programming.
    We will make the Pi and Android phones communicate through Bluetooth, and control
    the Pi using this channel. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the necessary components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a sensor service to Bluetooth Low Energy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting from an Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the reboot command from your Android phone to the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending more commands from your Android phone to the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the necessary components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardware component needed for this project is a BLE-enabled Bluetooth USB
    dongle. It is important that this hardware supports BLE as we will specifically
    make use of this part of the Bluetooth stack. We will use one by **Plugable**,
    which is available on Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the necessary components](img/image00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Bluetooth dongle by Plugable
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspbian distribution that we have downloaded already contains support
    for Bluetooth, but we need to update Bluetooth packages for better LE support.
    You can build and install a more modern of the Bluetooth package version using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `make` step will compile the necessary packages needed for the Pi and will
    take about 15 minutes to complete. However, you'll need to be patient as it will
    lead to something cool and useful at the end. Note that the latest version of
    BlueZ is 5.33 at the time of writing this book, and you can instead replace it
    with the latest version by checking the list of all available versions at [https://www.kernel.org/pub/linux/bluetooth/](https://www.kernel.org/pub/linux/bluetooth/).
    Note here that we have disabled the `systemd` support using the `--disable-systemd`
    option, which causes build errors, otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding commands have also installed some command-line tools to let us
    configure and scan for Bluetooth devices. The following command lists all the
    attached components on the USB ports of the Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Bluetooth adapter is named `Broadcom` in my case. To get more details on
    a specific device, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, note that `0a5c` is the first part of the address of the Bluetooth dongle
    that I am reusing to get more information on only this device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hciconfig` tool will show you which devices support Bluetooth. This command
    outputs the following information on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen here, the device is marked as `DOWN`. We will keep it this way as the
    next tool we install requires it to be down initially.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are useful Bluetooth LE commands that you can use to check for other BLE
    devices. We will not use these commands yet, but it is a good practice to play
    with them to check if your BLE devices are working or accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same `hciconfig` tool that we''ve used previously helps us bring the Bluetooth
    device up. However, do not do this if you want to proceed with the rest of the
    chapter as the next tool requires it to be down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is a good idea to put this command in crontab, as discussed previously, using
    crontab with the `–e` option in order to let you use nano as the editor and install
    new crontab automatically. Add `@reboot sudo hciconfig hci0 up` inside the file
    at the end, and save and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other commands we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the BLE devices. Now let''s take a look at the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And this command tests the Bluetooth connection to the device. Note that the
    address provided to the latter command was returned by the former.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will even need a programming support for Bluetooth. We will use **Go** as
    the language and the **Gatt** package for Go that gives support for Bluetooth
    LE in the Go language. The **Generic Attribute** **Profile** (**Gatt**) is a general
    specification to send and receive small amounts of data, known as attributes,
    over a BLE link. Let''s run the following commands to install the `go` language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You might want to go and grab a cup of coffee here, as the last command will
    take about 40 minutes to complete. At the end of the output, you will see that
    the `go` installer asks you to add a binary directory to your path for easy access.
    The following commands can accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea to put these commands in the `/etc/profile` file in order
    to execute them for each session that you start in the future. Be sure to add
    them at the end of the file, though. Also, do not forget to actually execute them
    even though you have put them in the `profile` file if you want to continue without
    rebooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, use the following command to download the Gatt package source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will start a simple BLE server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After completing this chapter, you might want to put the server startup command
    inside `crontab` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This way the BLE server will start each time you reboot the Pi. Add the following
    line at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now time to find our Raspberry Pi, which behaves like a BLE device from
    Android. We will use the **BLE Scanner** app by **BluePixel Technologies** and
    is available on the Play Store. When you start it, you will see a list of BLE
    devices available around you along with their addresses. The address of the Bluetooth
    adapter on the Pi can be seen using the `hciconfig` command. The default implementation
    of the Gatt server names the device as **Gopher**. The following screenshot illustrates
    the BLE Scanner app, showing the Pi as a BLE device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the necessary components](img/image00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The BLE Scanner app showing the Pi as a BLE device
  prefs: []
  type: TYPE_NORMAL
- en: 'The BLE stack is designed in a way that a device supports some number of services
    that users can connect to, and each service can provide read/write or notification
    characteristics, which is mainly data that you can write to, read, or get notifications
    from. Click on the device in the app and you will connect to the Pi''s newly started
    BLE server. You will be presented with four services. The one we are interested
    in is called **UNKNOWN SERVICE**, which is unnamed because it is not a standard
    service and it is implemented to only demonstrate the Gatt example server. Click
    on this service and you will see three characteristics provided by this service:
    **READ**, **WRIT**E, and **Notification**. You can recognize the type of characteristic
    by looking at which one of the three buttons on BLE Scanner app is enabled. The
    following screenshot illustrates the READ characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the necessary components](img/image00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The READ characteristic
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sensor service to Bluetooth Low Energy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add a new service to the already existing example from Gatt. This new
    service will publish two new characteristics to begin with: one for humidity and
    the other for temperature measurements. We will read the measurements the same
    way using the techniques we''ve discussed in [Chapter 2](part0021.xhtml#aid-K0RQ1
    "Chapter 2. Server Management with Pi"), *Server Management with Pi*. To read
    these measurements, we will create two new files with content similar to the `sense.py`
    file that we discussed [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Server
    Management with Pi"), *Server Management with Pi*. Let''s create two files under
    the `home` directory, and name them `humidity.py` and `temperature.py`. The `temperature.py`
    file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `humidity.py` file has similar content. The only difference is that it
    prints out the humidity part of the measurement instead of the temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the file access mode to executable as well using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can test sensor measurements using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to publish these readings via the Bluetooth channel. We will
    create a new service inside the existing Gatt server example. For this purpose,
    you can start editing the server.go `source file` for the server example in the
    `/home/pi/gopath/src/github.com/paypal/gatt/examples` path. You only need to add
    three lines of code in the function definition for `onStateChanged` in between
    other service definitions. In the following content, note that the count service
    and battery service already exist. We only need to add the sensor service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, in the same file, change the line where new services are advertised
    to the following code in order to advertise the new service as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the definition for the new service also. The following code
    should be placed in a file, named `sensor.go`, under the `service` directory of
    the Gatt examples at the same level as other service definition files, such as
    `count.go` and `battery.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to build and rerun our server code using `go`. The following commands
    that we used earlier will help us do this. Note that you should be in the /`home/pi/gopath/src/github.com/paypal/gatt`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the BLE Scanner app on Android again to connect to this new service
    and read the temperature and humidity sensor values. The following screenshot
    illustrates the Gopher services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After connecting to the Gopher device, you should see the newly added service
    with the `19fc95c0-c111-11e3-9904-0002a5d5c51b` ID, and new characteristics for
    that service as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Newly added characteristics: one for temperature and the other for humidity
    measurements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the characteristic details for temperature
    measurement after pressing the the **Read** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a sensor service to Bluetooth Low Energy](img/image00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Characteristics for temperature measurement showing a current value of 27 degrees
  prefs: []
  type: TYPE_NORMAL
- en: Connecting from an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used an existing app to connect to the BLE service that we implemented
    on Raspberry Pi. This app, called BLE Scanner, is very general purpose and would
    work for any kind of BLE device. However, we need a more specialized app that
    only reads measurements and abstracts away details of the BLE protocol, such as
    device scan, services, and service characteristics. In this section, we will implement
    an Android app to connect to the Raspberry Pi BLE. We need to install the Android
    Studio for this purpose. Android studio is specifically designed for Android app
    development by Google. You can read more about it by visiting [http://developer.android.com/tools/studio/](http://developer.android.com/tools/studio/).
    You can find instructions for installation at [http://developer.android.com/sdk/](http://developer.android.com/sdk/).
    We will use a real device to test our app and not the built-in emulator. For this
    purpose, you may need to install device drivers specific to your Android phone
    and make configuration changes to the Android Studio installation. The [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)
    link will help you carry out these actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, start the Android Studio and choose a new project to create. I will name
    the application `BLEPi` and the domain `example.com`. You should choose **Phone
    and Tablet** as the form factor, and at least **Android 5.0** as the minimum SDK
    as better BLE support is introduced with this SDK to the Android system. The core
    BLE support is actually added to Android 4.3, and the code files distributed on
    the book's website as well as the GitHub repository of the book will work for
    Android 4.3 as well as Android 5.0\. However, for the sake of simplicity and ease,
    the upcoming code is for Android 5.0 only. Note that you should have downloaded
    Android 5.0 SDK during the Android Studio installation in order to be able to
    choose it in the create project wizard. Take a look at the links we've just mentioned
    in this section for further details on this. Then, choose to add a blank activity
    to the app and do not change the name of the activity in the next step; we will
    keep it as `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin our implementation by adding Bluetooth permissions to the `AndroidManifest.xml`
    file inside the `manifest` and before the `application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll begin making changes to the `MainActivity.java` file. Start by
    making the following class variable definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `bluetoothAdapter` definition represents the local device's Bluetooth adapter
    and lets you perform fundamental Bluetooth tasks, such as discovering other devices
    and getting the properties of the discovered devices. `bleScanner` provides methods
    to perform scan-related operations specific to Bluetooth LE devices and `bleGatt`
    provides the Bluetooth GATT functionality to enable communication with Bluetooth
    Smart devices. The UUIDs we have defined here are the same as the ones we have
    used in the `sensor.go` file that we saved on the Pi previously for the identification
    of the new service and its two new characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Android Studio, you can use the *Alt*+*Enter* shortcut key to automatically
    import missing packages. The cursor should be located on the class for which the
    import is missing in the java file. Or, alternatively, place the cursor on the
    class, keep the mouse pointer on it, and you will see a light bulb menu. In this
    menu, you can select the import class option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `onCreate` method, which is called by the Android system when the
    app starts for the first time, we can initialize `bluetoothAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We need to define the `startScan` method that will be called whenever we want
    to initiate a scan of BLE devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check if Bluetooth is enabled on the device first. If not, we''ll
    present a message box to let the user enable Bluetooth. If it is enabled, we''ll
    get an instance of `bleScanner`, which is used to start a scan using the `startScan`
    method. We can give a callback implementation name, such as `scanCallback`, which
    will be called whenever a scan returns some results. Now, we need to define this
    callback variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ScanCallback` implementation overrides one important method, `onScanResult`,
    which is called whenever there is any new device to report. We then check if the
    device name is the same as the one that was defined in the `server.go` file on
    the Pi. If so, we can save the device properties and connection information to
    the `bleGatt` variable. We can even connect to the device using the `connectGatt`
    method, and provide another callback implementation, `bleGattCallback`, which
    will be called whenever an Android system establishes a connection to the device.
    We stop the scan if we have found the device we are looking for. Here is the definition
    for this callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this callback implementation, we override three important methods called
    from the Android system on different times. The `onConnectionStateChange` method
    is called whenever a connection is established to the remote device through Bluetooth.
    In this case, we can initiate the service discovery of the device using the `discoverServices`
    method. The `onServicesDiscovered` method is then called when services are discovered
    on the device. In such a case, we''ll read, to begin with, the temperature characteristics
    for the sensor service that we''ve defined on the Pi using the `readCharacteristic`
    method. Whenever the value of the characteristic reading operation has succeeded
    the third overridden method, `onCharacteristicRead` is called where we read the
    next characteristic which is humidity, and then wait for this operation to succeed
    in the same method. Then, we take turns to read the humidity and temperature values
    using the `readNextCharacteristic` method that we''ll define in the same callback
    implementation. This is because the BLE protocol does not let us read both characteristics
    at the same time. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the respective read operation succeeds, we get the value of the measurement
    using the `getStringValue` method of the returned `characteristic` object, and
    then show it in the UI elements that we will define in the `activity_main.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the code to be complete, we need to define the following methods as well
    in the `MainActivity.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `onActivityResult` method is called whenever a user enables Bluetooth, and
    we need to start scanning in this case as well as every time the user starts an
    app where `onResume` is called. If the user closes the app, the Bluetooth connection
    can be stopped through the `onPause` method.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great opportunity to test our the first version of our app that we
    have implemented so far and verify that it works. Select **Run app** in the **Run**
    menu in the Android Studio, and you will be given an option to select the location
    to install the app. You will then see the Android device that you have attached
    to your computer in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the reboot command from your Android phone to the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have been receiving data from the Pi through BLE. Now, we will
    send commands to it using the same channel. We will implement a new write characteristic
    in the same service as our temperature and humidity read characteristics are,
    which were defined on the Pi. Using these new characteristics, we will send the
    reboot command to the Pi. Let''s begin by editing the **sensor.go** file again
    and put the following code at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and restart the BLE server using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, test the characteristics mentioned previously using the BLE Scanner app.
    Whenever you write something to these characteristics, the Pi will reboot.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to implement this new reboot function in the Android app that
    we have been building.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the UUID of the this new write characteristics we have just defined
    and a variable to control the operation sequences, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The boolean variable, `isSendReboot`, will be used to initiate the write characteristic
    operation and orchestrate it together with the read operations previously defined.
    The BLE stack cannot handle read/write operations that are too close to each other,
    and we want to avoid performing one operation before the previous one is completed.
    Then, in the `onCharacteristicRead` function of `bleGattCallback`, change the
    line where we call `readNextCharacteristic` with the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will write a value, `reboot`, to the reboot characteristic if the
    control variable is set, by clicking a button that we will soon implement. We
    can override another method in `bleGattCallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method is called whenever the write characteristic operation succeeds when
    we reset our control variable and continue with the read operations. Those of
    you who are observant might see a minor problem with this code, namely that we
    are sending a reboot command to the Pi, but at the same time, we're also trying
    to read characteristics from the Bluetooth device located on the same device that
    we are trying to reboot. These readings will not work when the Pi reboots, and
    our app will not be able to reconnect if we do not close and reopen it after the
    reboot has been completed successfully. The solution to this issue will be left
    as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the implementation is to add a button for the command to our
    user interface and connect this button to a method in the `MainAcitivity.java`
    file which will be executed whenever the button is pressed. Add the following
    lines to the `activity_main.xml` file inside the `RelativeLayout` tag to begin
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `sendRebootCommand` method in the `MainActivity.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The only thing this function does when the **Reboot** button is clicked on is
    set the control variable that we have defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add the following code in the `onScanResult` method of the `ScanCallback`
    class instance after the call to the `device.connectGatt` method to enable the
    button when we connect to Raspberry Pi via Bluetooth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is a good place to test the app again and see if you can successfully restart
    the Pi through an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Sending more commands from your Android phone to the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have sent the reboot command from Android to the
    Pi. In this section, we will send two new commands. One to light up a LED that
    we will connect to the Pi, and another to play sound on the Pi. These commands
    will be reused in the forthcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting the LEDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll begin by connecting a LED light to the GPIO ports of the Pi. The LEDs
    usually come with a short and long leg. Connect a resistor to the short leg of
    the LED, and connect a female/female jumper to the other side of the resistor.
    This jumper should then be connected to one of the ground pins of the Pi. Take
    a look at the schema in [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Server
    Management with Pi"), *Server Management with Pi*, to identify the pins. Note
    that we already used one of the ground pins when we connected our temperature-humidity
    sensor to the Pi. However, there are plenty of ground pins available. The long
    leg of the LED should be connected to one of the GPIO pins. We will choose number
    `17`. You can take a look the GPIO port mappings diagram in [Chapter 2](part0021.xhtml#aid-K0RQ1
    "Chapter 2. Server Management with Pi"), *Server Management with Pi*, to identify
    port `17`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea to choose a resistor in the span of 270Ω to 470Ω. This resistor
    to protects the LED lamp from unexpected voltage changes. If you choose a resistor
    with lower ohm values, then the LED will be brighter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will access the GPIO and LED lamp using a software utility called **wiringPi**.
    We can download and install it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands have helped us to install a command-line tool called `gpio`,
    which you can now use to light the LED lamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn it off using the following comand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add two new characteristics to our BLE server implementation: the
    first to turn the light on, and the second to turn it off. Add the following lines
    to the end of the `sensor.go` file, and note that we have new UUIDs for each new
    characteristic that we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, build and restart the BLE server again. If you have added the BLE server
    command inside the crontab, you might need to reboot the Pi. Next, connect to
    the Pi using the BLE Scanner app again and use the **Write** button on characteristics
    section in the app to write values to these characteristics. You will need to
    provide some text to write to, otherwise, the BLE Scanner app will not send commands.
    Once you do this, you will be able to turn the LED on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to check the new characteristics you've added in BLE
    Scanner app before you try to access it with the app that we are building. This
    way, we can be sure that we have added the characteristics correctly on the Pi
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement this new function in our app. We can begin by
    introducing two new buttons in the `activity_main.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity.java`, define the new UUID and control variables for the new
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onScanResult` method of `scanCallback`, add the following code in the
    if-statement to enable these two buttons just after enabling the reboot button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCharacteristicRead` method of `bleGattCallback`, add new else-if
    statements to the existing check of the control variable for `isSendReboot`. The
    new code will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCharacteristicWrite` method, add the following code snippet to reset
    the control variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add new functions that can be called on click events for the new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting the LEDs](img/image00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The final version of the app
  prefs: []
  type: TYPE_NORMAL
- en: Be patient to see the effects of the new buttons after clicking on them as it
    will take a few seconds for the messages to arrive in the Pi, and for the the
    LED lamp to be turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds on your Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to play sounds on the Pi, sound modules should be loaded on reboot.
    To do this, we need to add sound module specifications to the `/etc/modules` file.
    Add `snd-bcm2835` in this file if it does not already exist there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `lsmod` command-line tool to see which modules are loaded at
    the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This command loads the sound module without rebooting for the contents of the
    `/etc/modules` file to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We even need to find an audio file to play, which we can download using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now play this sound using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that that the audio channel might default due to HDMI output and you may
    not hear anything on your 3.5mm jack. In this case, you can run the following
    command to set the default audio player to the 3.5mm jack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the new write characteristic to the `sensor.go` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to build and restart the Pi using the `go` `build` `examples/server.go`
    command. Next, define a new button in the `activity_main.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a new event handler for the `onClick` event in the `MainActivity.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add new the UUID and control variables to the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the new button in the `onScanResult` method of the `scanCallback` instance
    variable inside the if-statement for the `bleGatt` null check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code in the new else-if statement in the `onCharacteristicRead`
    handler for the `bleGattCallback` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new statement to reset the control variable in the `onCharacteristicWrite`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now the whistle command is ready to be tested from our app.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the commands and being informed on incoming calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this last section, we will combine the whistle and LED light up commands
    and initiate this new command whenever our phone rings. By now, we are used to
    creating new characteristics. Here is a new one to be added to `sensor.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine these two commands to save ourselves from the development details
    of sending two separate commands as a single transaction. We need a new permission
    in the `AndroidManifest.xml` file to get an incoming call state from the Android
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need new instance variables in `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to get an instance of a system phone service and attach our own
    listener to it. Add these two lines of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a local `PhoneListener` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, whenever we get a state change on the phone, we check if this is a `CALL_STATE_RINGING`
    state. If it is, we can set the control variable for the newly created command
    in the same way as the button click event handlers did for previously defined
    commands. Then, we can add this additional else-if statement in the `onCharacteristic`
    read method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll reset the control variable in the `onCharacteristicWrite` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will be able to see the LED lamp turned on and hear the whistle sound
    on the Pi as soon as your phone rings. Note that our app needs to be started and
    visible for this to work. This is caused by one of the two main issues with the
    code we have. All the communication with the Pi through BLE should actually be
    done in side an Android service, and phone events need to be handled inside `BroadcastReceiver`
    instead of in an **activity**. Both of these implementations, that is, Pi communication
    and phone state interception, should actually be separated from the **activity**.
    An activity should actually be a UI component and nothing more. However, our intention
    here was to show you only the fun parts and be quick and dirty. These further
    improvements on the Android code will be left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of content, ranging from BLE implementations
    on the Pi to details of the Android BLE code. We had great fun with the Pi and
    came up with a useful project that can be developed further.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more ways to make use of BLE equipment on
    the Pi and use our phones not just as Android devices, but also as access points
    for the Pi.
  prefs: []
  type: TYPE_NORMAL
