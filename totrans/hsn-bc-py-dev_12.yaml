- en: Creating Token in Ethereum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn how to create a token on top of Ethereum.
    Tokens have a variety of uses; it may be for local currency in a local community,
    it may represent a physical good, it may be virtual money in a game, or it may
    be loyalty points. With this token, you can build a new cryptocurrency. While
    Ethereum is a cryptocurrency itself, you can build a new cryptocurrency on top
    of it. Ethereum makes it far easier to create a new token, and this fueled the
    creation of many new cryptocurrencies in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a simple token smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERC 20 (Ethereum token standard)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sell your token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize your token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a token on top of Ethereum with Vyper is easy. Let's follow the initial
    steps to prepare our development environment before we build a token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by ensuring that you have geth installed and that the `geth` program
    is in the `$PATH` environment variable (meaning that you can call `geth` without
    its full path):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add Vyper support to `project.json` by changing the value of the `compilation`
    key to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of Vyper is 0.1.0b6 and it breaks Populus. The developer
    needs some time to fix this problem. If the bug has still not been fixed by the
    time you are reading this book, you can patch Populus yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check whether the bug has been fixed by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you are still in the same directory (`token-venv/src/populus`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `token_project` directory, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize the private chain using the `init_chain.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Edit `chains/localblock/run_chain.sh`and change the value of `--ipcpath` to
    `/tmp/geth.ipc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `project.json` file. `chains` has one object that has four keys:
    `tester`, `temp`, `ropsten`, and `mainnet`. Add one key named `localblock` with
    its value to this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Mist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](8932df34-bbc2-47b9-99f1-18ea76844f44.xhtml), *Smart Contract
    Fundamentals*, and [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*, you used the Truffle console to interact with the
    smart contract. Now, we are going to use another software to interact with the
    smart contract. The software we will use is `Mist`, an Ethereum wallet.
  prefs: []
  type: TYPE_NORMAL
- en: For this, go to [https://github.com/ethereum/mist/releases](https://github.com/ethereum/mist/releases).
    If you use Linux Ubuntu, download the `Mist-linux64-0-11-1.deb` file.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that `geth` is already installed and that the path of `geth` is in the `$PATH`
    environment variable, so that you can call `geth` from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then install Mist, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `--rpc /tmp/geth.ipc` flag. We use this flag because we run the private
    blockchain with the socket file defined in `/tmp/geth.ipc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see this screen after you run the application. You can create an Ethereum
    blokchain account by clicking the ADD ACCOUNT button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f26bd6d-89a2-4f50-b54c-cc85f63bb210.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just as you did in the `geth` console, you need to supply a password to create
    a new account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b2ce2a62-f078-42ba-9974-f9f075a14c59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once your wallet account has been created, you can send some money from the
    first account to this new account by clicking the SEND tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c21dc65e-899b-4cb8-8ecf-c5e66309fccc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can insert your new account''s address in the TO field. Don''t forget
    to include the amount of ether you want to send, and then click the SEND button
    at the bottom of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3c9af6dc-e952-4ae9-a94c-323f9aea1e9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You must fill in the password to create a transaction. The password of the
    default account can be found in the `chains/localblock/password` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b34ad24f-6084-454a-a6d1-463093fd3681.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Soon, your transaction will be confirmed in the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2326f84c-1b29-4c50-bb8a-ed5db93f48f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a simple token smart contract inside the `token_project/contracts`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This smart contract digitally creates 10,000 coins of the token and gives all
    of them to the owner of the smart contract. Then, the owner can forward the coins
    to other accounts using the `transfer` method.
  prefs: []
  type: TYPE_NORMAL
- en: This simple smart contract is special in comparison to creating a simple token
    traditional web application because, once this smart contract is deployed, the
    owner cannot change the token amount, no matter how desperate they are. If the
    owner has just executed the `transfer` method to transfer some coins to another
    account's address, they cannot take it back again. Other people can verify the
    rule of the play in the smart contract before interacting with it.
  prefs: []
  type: TYPE_NORMAL
- en: Compare this with the simple token we created in the traditional web application.
    Once you create 10,000 coins here, you can change the number of tokens by updating
    the number of coins in the database. You can change the rule as you like, which
    places other people who want to interact with this application at a disadvantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add a method to increase the number of token coins in the smart
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Look at the `mint` method. This can be used to increase the token coins in the
    owner's balance.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that you cannot change the rule of the game after you deploy
    the smart contract. If you deploy this version of the smart contract, people could
    ask for the source and the compiler's version to verify the code. If you don't
    give the source code, people could turn away from your smart contract. If you
    do give the source code, people can check and see that you have a method that
    can increase your coins any time you like. Whether they accept this rule is up
    to them, but at least with a smart contract, there is transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the test for this simple token smart contract;
    this test is not exhaustive, but it gives you a good start. The importance of
    a test for a token smart contract is paramount. To begin with, name the test `test_simple_token.py`
    and put it inside the `token_project/tests` directory. Refer to the code file
    in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_simple_token.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's deploy our simple token smart contract (the first one, without the `mint`
    function) to the blockchain using Mist.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, click on the CONTRACTS tab, and then click on the DEPLOY NEW CONTRACT
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fc98058-6cd6-4a8a-8bd3-e38db31d79bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Deploy contract screen, choose the account you want to deploy from,
    and then click on the CONTRACT BYTE CODE tab. Insert our simple token smart contract''s
    bytecode there. You can get our simple token''s bytecode from `token_project/build/contracts.json`
    after compiling the smart contract''s source code first, of course. Find the value
    with the `bytecode` key and copy the value without the double quote, pasting it
    into the CONTRACT BYTE CODE tab. After doing this, click the DEPLOY button (not
    visible in the following screenshot; you will have to scroll down) and fill in
    the password as usual in a password dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb0d402c-51fb-4197-b844-32bbf3293abf.png)'
  prefs: []
  type: TYPE_IMG
- en: Soon, your smart contract creation will be confirmed in the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to interact with the smart contract, click the CONTRACTS tab, followed
    by the WATCH CONTRACT button. A dialog will then appear. Fill in the address of
    the smart contract and then the name of the smart contract itself. You can apply
    any name you like here. Next, fill in the `json` interface of the smart contract
    inside the JSON INTERFACE field. You can get the `json` interface from `token_project/build/contracts.json` (in
    the `contracts.json` file, locate the value of the `abi` key). The form for watching
    a smart contract looks like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/860121e9-d162-4b21-9a27-ef489e88e880.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, your simple token smart contract will appear on the screen. Click the SIMPLE
    TOKEN label to get into this smart contract''s screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/434e57a5-8819-4796-baf0-5b0e740f086b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can read the balance of the owner of the smart contract using the `Balances`
    method (Mist likes to capitalize methods). Insert the address of the owner's account
    in the Arg 0 - address field and press Enter. From this, you will get 10,000 as
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s transfer some token coins. Pick a function. Right now, there is
    only one function: `Transfer` (the capitalized version of the `transfer` method).
    Choose Account 1 in the Execute from field, choose the Account 2 address in to, and
    insert 20 in the amount field. Finally, click the EXECUTE button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67c0f501-e87d-439b-a08c-ba613e2a9852.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wait for confirmation before checking the balance of the destination account.
    Type the destination address into the Balance field and then press Enter. This
    will give you `20` as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e730caab-063a-469e-a2c8-2b357269b3d6.png)'
  prefs: []
  type: TYPE_IMG
- en: ERC20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More than likely, you will have heard of ERC20\. When a new cryptocurrency is
    out, the first question that usually arises is—is it an ERC20 token? People assume
    incorrectly regarding the ERC20 token; they think it is a cryptocurrency based
    on Ethereum. Well, technically speaking, this is true, but it does not tell the
    whole story. ERC20 is a standard in Ethereum for creating a token. The simple
    token that we have just created does not fulfill the ERC20 standard. Yes, it is
    a digital token smart contract, but it is not an ERC20 token. ERC20 is one of
    many reasons why we have seen an increase in the number of new cryptocurrencies
    in 2017\. However, ERC20 is not a requirement for creating a token on top of Ethereum.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an ERC20 token, you must implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods use Solidity syntax. There are optional methods, given in the
    following code block, that you can implement too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So what is so special about this ERC20 token? Is this an obligation when creating
    a token smart contract? Why can't we create a digital token without fulfilling
    the ERC20 standard?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, you don't have to follow this standard; there is no law that forces
    you to create an ERC20 token. For example, the ERC20 standard expects you to tell
    users the overall amount of tokens in the `totalSupply` method. However, you could
    create a method named `taylorSwiftIsTheBest` to return the total supply of the
    token, and then you could create a document to explain this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some advantages if you follow the ERC20 token standard:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it makes it easier for users to audit your smart contract.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, your ERC20 token would be recognized automatically by an Ethereum wallet,
    such as `Mist` (the one we used just now) and Metamask (the Ethereum wallet is
    a `Firefox/Opera/Chrome` plugin).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, it is easier for cryptocurrency exchange to list your token. Basically,
    it makes everyone's lives easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, you should treat the ERC20 standard as guidance, and not strict law.
    You don''t have to follow the ERC20 standard to 100%. Not all popular tokens built
    on top of Ethereum are 100% ERC20-compliant. One such example is the Golem token
    smart contract. This does not implement the `approve` method, among other things.
    You can read the source code of the Golem token smart contract at the following
    link: [https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract](https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d#readContract).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, let''s create an ERC20 token. This code has been modified
    from the official example included in the Vyper project ([https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy](https://github.com/ethereum/vyper/blob/master/examples/tokens/ERC20.vy)).
    Refer to the code file in the following GitLab link for the full modified code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/ERC20Token.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s describe this smart contract line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You must define two kinds of events, `Transfer` and `Approval`. You can define
    more events if you wish. A `Transfer` event is used when the transfer of coins
    occurs, so users of the smart contract can subscribe to this event. An `Approval`
    event is used when you approve of an amount to spend for an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are six variables. The first variable is the name of the token. I used `bytes[10]`
    as the data type because the name of my token is less than 10 bytes. Feel free
    to change the length. The second variable is the symbol of the token; the name
    and symbol are different. For example, the name of the Ethereum cryptocurrency
    is Ethereum, but the symbol is ETH. Usually, the symbol''s character length is
    3\. The third variable is `totalSupply`, which is the total amount of tokens,
    and the fourth variable is decimals. You know that 1 bitcoin is 100,000,000 satoshis,
    so there will be 21,000,000 bitcoins being created in total in the Bitcoin algorithm.
    Therefore, we can say that the total supply in the Bitcoin algorithm is 2,100,000,000,000,000\.
    The decimal is 8 (because 1 bitcoin is 100,000,000, or 10⁸). Furthermore, the
    fifth variable is `balances`. This is the variable that keeps track of the balance
    of the account''s address. The final variable is `allowed`, which is a nested
    mapping. This is designed to keep track of accounts that have been approved to
    spend ethers from another account''s balance up to a certain amount. If this is
    still not clear, we''ll talk about it in depth later. Now, we will move on to
    the initialization method of this ERC20 token smart contract, as demonstrated
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we initialize the token in the smart contract. We create the token
    in the air, and then give all of the token''s coins to the owner. Then, we set
    the name and the symbol of the token as well as the decimal number. Finally, we
    emit the event of the transfer. The address is `ZERO_ADDRESS is 0x000000000000000000000000000000000000000`.
    This is an indicator that the owner of the smart contract has transferred coins
    from nowhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is used to return the balance of a specific account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the method for transferring the coin. First, you make sure that the
    balance of the sender has enough coins to spend. Then, you just subtract the balance
    of the sender from the number of transfer processes and add that amount to the
    balance of the destination. Don''t forget to log this transaction with the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the `approve` method first. So each account has a mapping
    called `allowed`, but what is this mapping for? It's how each account can let
    other accounts spend its money. For example, let's say there are 5 accounts—account
    A, account B, account C, account D, and account E.
  prefs: []
  type: TYPE_NORMAL
- en: 'Account A has a balance of 50 coins and a mapping variable called `allowed`
    that has account B, account C, account D, and account E keys. The values of this
    mapping are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Account B → 3 coins
  prefs: []
  type: TYPE_NORMAL
- en: Account C → 7 coins
  prefs: []
  type: TYPE_NORMAL
- en: Account D → 2 coins
  prefs: []
  type: TYPE_NORMAL
- en: Account E → 3 coins
  prefs: []
  type: TYPE_NORMAL
- en: This means that at most, account B can spend 3 coins from the balance of account
    A, account C can spend at most 7 coins from the balance of account A, account
    D can spend at most 2 coins from the balance of account A, and account E can spend
    at most 3 coins from the balance of account A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `approve` method, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that account B can spend 3 coins from the balance of account A, account
    A called the `approve` method, with `_spender` set to account B's address, and
    `_amount` is set to 3 coins. Don't forget to log this approval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if account B wants to spend some or all of the 3 coins, account B can
    call the `transferFrom` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first assertion inside the `transferFrom` method is to make sure that account
    B does not spend more than 3 coins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We make sure that account A has at least 3 coins in its balance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, we subtract the amount of spending from the balance of account A, and
    the allowance of account A to account B. After this, we increase the balance of
    the destination account. Don't forget to log this transaction as a `Transfer`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method is to check the mapping of this allowance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is designated to establish how much account B can spend from the balance
    of account A.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may ask what the point of this method is. Why don't we just
    transfer the amount of coins to account B if we want to allow account B to spend
    some ethers in the name of account A? For example, if account A allows account
    B to spend 5 coins from the balance of account A, this means that account A lets
    account B send 5 coins from the balance of account A to the address of account
    B directly. So, why doesn't account A send 5 coins directly to the address of
    account B to save the hassle? If account B changes their mind, they could refund
    the amount of tokens to account A.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we would not allow a normal account to spend on our behalf. However,
    we do allow the smart contract to do this. There are a number of valid reasons
    why we want to allow a smart contract to spend our money. One of these reasons
    is the decentralized exchange smart contract case, in which you want to let the
    decentralized exchange smart contract sell your token. Let's say that you have
    created 1,000 HHH coins, and then you want to sell some of them in decentralized
    exchange. So, you allow this decentralized exchange to spend some coins on your
    behalf. Perhaps you approve the decentralized exchange to spend 30 HHH coins.
    This decentralized exchange can try to sell 30 HHH coins on your behalf. You wouldn't
    allow the decentralized exchange smart contract to have access to all of the coins
    in your balance just because you only want to sell 30 HHH coins. Although you
    could audit the smart contract to make sure the smart contract does not try to
    steal your coins, it's better to have another layer of security. The `approve`
    method is such a layer.
  prefs: []
  type: TYPE_NORMAL
- en: Compile your token smart contract and deploy it, just like before.
  prefs: []
  type: TYPE_NORMAL
- en: 'After doing this, go to the CONTRACTS tab and click the WATCH TOKEN button.
    In the Add token window, insert your ERC20 smart contract''s address. Then, other
    fields such as TOKEN NAME, TOKEN SYMBOL, and DECIMAL PLACES OF SMALLEST UNIT will
    be filled in automatically. This is one of the reasons why we should implement
    the ERC20 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb7d5a7f-c62d-42a9-9048-63714e24e6da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the token, you should see the HAHA COIN label on the CONTRACTS
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fae0c984-6f33-4902-b576-2285792514f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the SEND tab, choose the owner of the ERC20 smart contract and then
    choose Haha Coin instead of ether. Send 1,000 Haha coins to Account 2, and then
    await confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d2121471-d8f5-412d-abd9-82033420abbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, choose Account 2 in the same tab; you will see that Account 2 now has
    1,000 Haha coins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9461d0e9-61dc-481c-a4b7-ca57879f1a75.png)'
  prefs: []
  type: TYPE_IMG
- en: All ERC20 compatible wallets, such as Mist and MetaMask, can recognize and interact
    with your token easily. The people behind cryptocurrency exchange would not have
    any technical difficulties either in integrating your ERC20 coins into their exchange.
    Imagine that you don't follow the ERC20 standard, and that you name a method to
    transfer coins as `tailorSwiftTransferCoin`. In this case, you must build a custom
    wallet for users before they can interact with your token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test for this ERC20 token. Remember, this test is not comprehensive.
    Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_erc20_token.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As well as transferring coin methods, this test also tests the `approval` and
    `transferFrom` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Selling a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a token, it's time to sell the coins. We want to sell our custom
    token for ethers. A crowdsourcing token is very easy do create on the Ethereum
    platform compared to the Bitcoin platform. You already know how to create a method
    in a smart contract to accept ethers. You also know how to increase the token
    balance of some accounts. To sell tokens, you must combine those two things. That's
    all.
  prefs: []
  type: TYPE_NORMAL
- en: This is the core of the **Initial Coin Offering** (**ICO**). The currency of
    Ethereum is valuable. Although the price of ether fluctuates, 1 ether is valued
    at around USD 100\. People would pay real money for some ethers, but not our custom
    token. To make our custom token worthy, we have to make it useful first, or at
    least make it appear useful. But to do that, we need capital. So why not sell
    some of our tokens (say 60%) to early adopters? They can then purchase our custom
    token with ethers. Then, we can withdraw ethers before changing it to fiat money,
    so we can hire more programmers and rent an office to develop our new cryptocurrency.
    This is the basic idea. Of course, because ICO involves a lot of money, it also
    attracts predators.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the crowdsale token smart contract. This is the same as our previous
    ERC20 token smart contract''s source code, but with slight variations. Name this
    smart contract `CrowdSaleToken.vy` and save it inside the `token_project/contracts`
    directory. Refer to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/CrowdSaleToken.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss this smart contract line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We add one event named `Payment` on top of another two events. This event will
    be called when someone pays for the token with ethers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We add a couple of new variables, which are `ethBalances`, `beneficiary`, `minFundingGoal`,
    `maxFundingGoal`, `amountRaised`, `deadline`, `price`, `fundingGoalReached`, and `crowdsaleClosed`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ethBalances` is a variable that''s designed to keep track of how many ethers
    a buyer has spent in this smart contract. We want to keep track of this number
    because we want to refund the ethers if we cannot raise the necessary amount. `beneficiary`
    is a variable that''s used to track who launches this smart contract. This `beneficiary` variable
    is the only account that is able to withdraw the ethers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`minFundingGoal` and `maxFundingGoal` are variables that were designed to make
    sure that the amount that''s raised is greater than the minimum funding goal and
    lower than the maximum funding goal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`amountRaised` is a variable that''s designed to track how many ethers we have
    raised in this smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: '`deadline` is a variable  that''s used to track the deadline of this crowdsale
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: '`price` is how we want to value our digital token in terms of ethers. This
    variable is designed to answer how many coins of our token the buyer can get with
    1 ether.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fundingGoalReached` is a `boolean` variable stating whether our smart contract
    has reached our target.'
  prefs: []
  type: TYPE_NORMAL
- en: '`crowdsaleClosed` is a `boolean` variable stating whether our smart contract
    still receives the buying process. We''ll start from the initialization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The total coin supply in this smart contract is 10,000\. We want to raise at
    least 30 ethers, up to a maximum of 50 ethers.
  prefs: []
  type: TYPE_NORMAL
- en: The deadline is set to 100 days from the time when the smart contract is deployed
    on the blockchain. `block.timestamp` is approximately the current time, or the
    time when the block containing this smart contract code is confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The price of 1 coin is set to `0.01` ether. This means that 1 ether can buy
    100 coins of our token. Then, we move into a default function in a smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is the method that the user can use to buy the token. `__default__` is
    a default, fallback function. If someone does not execute a method on the smart
    contract and pays ethers, this function will be executed. Actually, we don't have
    to use the default function to accept the payment. You can use the standard method,
    just like you have done in previous smart contracts. We simply use the default
    function to explain this concept.
  prefs: []
  type: TYPE_NORMAL
- en: In this payment method, we ensure that the buyer is not the beneficiary, that
    the crowdsale is still happening, and that the amount that has been raised with
    the ethers sent into this method does not exceed the maximum funding goal of 50
    ethers. Lastly, each purchasing action must be at least 0.01 ether. Then, we increase
    the balance of ethers for this buyer as well as increasing the amount of ethers
    raised. We then check the amount of coins they purchased by dividing the amount
    of ethers by the price of 1 coin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to increase the balance of the token for this buyer and decrease
    the balance of the token for the owner of the smart contract. Don''t forget to
    log this event. Then, we move onto the method where we can check whether we have
    reached our target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we make sure that this method can only be executed successfully if the
    deadline has passed. If the amount raised is more than the minimum funding goal,
    we set the `fundingGoalReached` variable to `true`. Then, finally, we set the `crowdsaleClosed` variable to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we only check whether the `block.timestamp` variable
    is larger than the deadline. However, the timestamp in the block could be filled
    with anything the miner likes; it does not have to be the current time that the
    block is confirmed. But, of course, if the miner gave the past timestamp as the
    value to `block.timestamp`, all other miners would reject it. Similarly, if the
    miner gives the future timestamp, which is really far away (for example, a year
    ahead), as the value for `block.timestamp`, all other miners would also reject
    it. To make checking the deadline process more secure, you have to combine it
    with `block.number` to check how many blocks have been confirmed since this smart
    contract launched. Then, we move into the method where the manager of the smart
    contract can withdraw ethers that have accumulated in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `safeWithdrawal` method runs differently, depending on whether the funding
    goal is attained. Inside the preceding method, we make sure that the crowdsale
    is already closed. If the funding goal is not reached, we make sure that every
    buyer can get their ethers back. If the funding goal is reached, then we make
    sure that the beneficiary can withdraw all ethers in the smart contract. The remainder
    of the methods are the same as in the previous smart contract. However, we add
    a number of assertions to make sure that these methods can only be executed after
    the crowdsale is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the test for this crowdsale smart contract. Refer
    to the code file in the following GitLab link for the full code file: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_crowd_sale_token.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at `test_withdrawal` and `test_refund`, especially these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Rather than waiting for 100 days, we want to manipulate the clock in the test
    to believe that the deadline has been reached (101 days from now). Consequently,
    we pretend that we have passed 101 days and then we confirm 1 block. Therefore,
    the `block.timestamp` variable inside the smart contract would be 101 days from
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Stable coin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created a digital token that can be sold autonomously. However, you
    should not restrict yourself to the generic token. You could be more creative
    in your token smart contract by adding more methods to spice up your smart contract.
    What methods you should add are dependent on your smart contract's purpose. The
    token smart contract that is used in a game as currency will have different methods
    to the token smart contract that is used in a supply chain tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a stable coin smart contract. This is a token smart contract that
    is pegged to fiat money, such as the US dollar. We also want this smart contract
    to be a bank where we, as an owner, can freeze an account.
  prefs: []
  type: TYPE_NORMAL
- en: We can base our work on an ERC 20 token smart contract. We just need to add
    three methods—a method to freeze an account, a method to add some coins, and a
    method to throw away some coins.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the smart contract. You can refer to the code file in the following
    GitLab link for the full code file: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/contracts/StableCoin.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the smart contract line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We need to add another event for freezing an account action in the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add two new variables on top of variables from the ERC20 token smart contract,
    which are `frozenBalances` and `owner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`frozenBalances` is a mapping variable to track which accounts have been frozen.
    `owner` is a variable to track the owner of the smart contract.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this initialization method, we set the `owner` variable as the account that
    launched this smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, we make sure that only the owner can call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Then, we set the value of the `frozenBalances` mapping variable. The true value
    means that the account is frozen. Don't forget to call the `Freeze` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is to increase the coins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We increase the total supply and the balance of the owner's account as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method is designed to burn the coins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the previous method, but its purpose is to decrease the amount
    of coins from the total supply. Why do you want to annihilate coins? There are
    a number of valid reasons for this. Suppose you are tracking US dollars with this
    smart contract. Let's say you have 10,000 US dollars in your pocket. So, the total
    supply in the smart contract is 10,000 (1 coin is pegged to 1 US dollar), but
    one day, USD 2,000 of your USD 10,000 is stolen by a thief. To make sure the smart
    contract is consistent, you burn 2,000 coins with this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the methods are exactly the same as under the ERC20 token
    smart contract, with two exceptions: `transfer` and `transferFrom`. We have additional
    assertions in those methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block is the test for this smart contract. You can refer
    to the code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_08/token_project/tests/test_stable_token.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to create a token on top of Ethereum.
    You used Mist an Ethereum wallet, to deploy the contract and interact with the
    token smart contract. Then, you implemented the ERC 20 standard in creating the
    token smart contract by creating implementations of certain methods. You also
    saw how these standard methods help Mist to recognize your token. Then, you created
    a method to sell tokens for ethers. You put a deadline in this smart contract
    and then you used a time travel method to simulate the expired deadline in the
    test of the smart contract. Finally, you added other methods to freeze and unfreeze
    other accounts. The example you used is a stable coin that pegs coins to real-world
    assets, such as fiat.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to create a cryptocurrency wallet that can
    handle ethers and ERC20 tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ethereum.org/token](https://ethereum.org/token)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
