- en: Chapter 3. Getting the Maximum from Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we introduced the basic characteristics of executors as a way to
    improve the performance of concurrent applications that execute lots of concurrent
    tasks. In this chapter, we go a step further and explain advanced characteristics
    of executors that make them a powerful tool for your concurrent application. In
    this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced characteristics of executors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First example – an advanced server application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second example – executing periodic tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information about executors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced characteristics of executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An executor is a class that allows the programmers to execute concurrent tasks
    without being worried about the creation and management of threads. Programmers
    create `Runnable` objects and send them to the executor that creates and manages
    the necessary threads to execute those tasks. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we introduced the basic characteristics of the executor framework:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create an executor and the different options we have when we create one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to send a concurrent task to an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control the resources used by the executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the executor, internally, uses a pool of threads to optimize the performance
    of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, executors can give you many more options to make them a powerful mechanism
    in your concurrent application.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation of tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can cancel the execution of a task after you send it to an executor. When
    you send a `Runnable` object to an executor using the `submit()` method, it returns
    an implementation of the `Future` interface. This class allows you to control
    the execution of the task. It has the `cancel()` method, which attempts to cancel
    the execution of the task. It receives a boolean value as a parameter. If it takes
    the `true` value and the executor is executing this task, the thread executing
    the task will be interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the situations when the task you want to cancel can''t be canceled:'
  prefs: []
  type: TYPE_NORMAL
- en: The task has already been canceled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task has finished its execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task is running and you supplied `false` as a parameter to the `cancel()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other reasons not specified in the API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cancel()` method returns a boolean value to indicate whether the task has
    been canceled or not.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling the execution of tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ThreadPoolExecutor` class is the basic implementation of the `Executor`
    and `ExecutorService` interfaces. But the Java concurrency API provides an extension
    of this class to allow the execution of scheduled tasks. It''s the `ScheduledThreadPoolExeuctor`
    class, and you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute a task after a delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a task periodically; this includes the execution of tasks at a fixed
    rate or with a fixed delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the executor methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The executor framework is a very flexible mechanism. You can implement your
    own executor extending one of the existing classes (`ThreadPoolExecutor` or `ScheduledThreadPoolExecutor`)
    to get the desired behavior. These classes include methods that make it easy to
    change how the executor works. If you override `ThreadPoolExecutor`, you can override
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeExecute()`: This method is invoked before the execution of a concurrent
    task in an executor. It receives the `Runnable` object that is going to be executed
    and the `Thread` object that will execute them. The `Runnable` object that this
    method receives is an instance of the `FutureTask` class and not the `Runnable`
    object you sent to the executor using the `submit()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterExecute()`: This method is invoked after the execution of a concurrent
    task in the executor. It receives the `Runnable` object that has been executed
    and a `Throwable` object that stores a possible exception thrown inside the task.
    As in the `beforeExecute()` method, the `Runnable` object is an instance of the
    `FutureTask` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newTaskFor()`: This method creates the task that is going to execute the `Runnable`
    object you sent using the `submit()` method. It must return an implementation
    of the `RunnableFuture` interface. By default, Open JDK 8 and Oracle JDK 8 returns
    an instance of the `FutureTask` class, but this circumstance can change in future
    implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you extend the `ScheduledThreadPoolExecutor` class, you can override the
    `decorateTask()` method. This method is like the `newTaskFor()` for the scheduled
    tasks. It allows you to override the tasks executed by the executor.
  prefs: []
  type: TYPE_NORMAL
- en: Changing some initialization parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also change the behavior of an executor by changing some parameters
    at its creation. The most useful ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingQueue<Runnable>`: Every executor uses an internal `BlockingQueue`
    to store the tasks that are waiting for its execution. You can pass any implementation
    of this interface as a parameter. For example, you can change the default order
    used by the executor to execute the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThreadFactory`: You can specify an implementation of the `ThreadFactory` interface,
    and the executor will use that factory to create the threads that will execute
    the tasks. For example, you can use a `ThreadFactory` interface to create an extension
    of the `Thread` class that saves log information about the execution times of
    the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RejectedExecutionHandler`: After you call the `shutdown()` or the `shutdownNow()`
    method, all the tasks that are sent to the executor will be rejected. You can
    specify an implementation of the `RejectedExecutionHandler` interface to manage
    this situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first example – an advanced server application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we presented an example of a client/server application. We implemented
    a server to search data over the World Development Indicators of the World Bank
    and a client that makes multiple calls to that server to test the performance
    of the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will extend that example to add to it the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: You can cancel the execution of queries in the server, using a new cancellation
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can control the order of execution of queries using a priority parameter.
    Tasks with higher priority will be executed first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server will calculate the number of tasks and the total execution time used
    by the different users that use the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement these new characteristics, we have made the following changes
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added two parameters to every query. The first one is the name of the
    user that sends the query, and the other is the priority of the query. The new
    format of the queries are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query**: `q;username;priority;codCountry;codIndicator;year` where `username`
    is the name of the user, `priority` is the priority of the query, `codCountry`
    is the code of the country, `codIndicator` is the code of the indicator, and `year`
    is an optional parameter with the year you want to query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Report**: `r;username;priority;codIndicator` where `username` is the name
    of the user, `priority` is the priority of the query, and `codIndicator` is the
    code of the indicator you want to report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: `s;username;priority` where `username` is the name of the user
    and `priority` is the priority of the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**: `z;username;priority` where `username` is the name of the user, and
    `priority` is the priority of the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have implemented a new query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: `c;username;priority` where `username` is the name of the user,
    and `priority` is the priority of the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have implemented our own executor to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the server use per user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the tasks by priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the rejection of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have adapted `ConcurrentServer` and `RequestTask` to take into account the
    new elements of the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the elements of the server (the cache system, the log system, and
    the `DAO` class) are the same, so it won't be described again.
  prefs: []
  type: TYPE_NORMAL
- en: The ServerExecutor class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, we have implemented our own executor to execute the
    tasks of the server. We also have implemented some additional but necessary classes
    to provide all the functionality. Let's describe these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The statistics object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our server will calculate the number of tasks that every user executes on it
    and the total execution time of these tasks. To store this data, we have implemented
    the `ExecutorStatistics` class. It has two attributes to store the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These attributes are `AtomicVariables` that support atomic operations on single
    variables. This allows you to use those variables in different threads without
    using any synchronization mechanisms. Then, it has two methods to increment the
    number of tasks and the execution time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have added methods to get the value of both attributes, and we
    have overridden the `toString()` method to get the information in a readable way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The rejected task controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create an executor, you can specify a class to manage its rejected
    tasks. A task is rejected by the executor when you submit it after the `shutdown()`
    or `shutdownNow()` methods has been invoked in the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control this circumstance, we have implemented the `RejectedTaskController`
    class. This class implements the `RejectedExecutionHandler` interface and implements
    the `rejectedExecution()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `rejectedExecution()` method is called once per task that is rejected and
    receives as parameters the task that has been rejected and the executor that has
    rejected the task.
  prefs: []
  type: TYPE_NORMAL
- en: The executor tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you submit a `Runnable` object to an executor, it doesn't execute that
    `Runnable` object directly. It creates a new object, an instance of the `FutureTask`
    class, and it's this task that is executed by the worker thread of the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, to measure the execution time of the tasks, we have implemented
    our own `FutureTask` implementation in the `ServerTask` class. It extends the
    `FutureTask` class and implements the `Comparable` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, it stores the query that is going to execute as a `ConcurrentCommand`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, it uses the constructor of the `FutureTask` class and stores
    the `ConcurrentCommand` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it implements the `compareTo()` operation comparing the commands stored
    by the two `ServerTask` instances to compare. This can be seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The executor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the auxiliary classes of the executor, we have to implement
    the executor itself. We have implemented the `ServerExecutor` class with this
    purpose. It extends the `ThreadPoolExecutor` class and has some internal attributes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`startTimes`: This is a `ConcurrentHashMap` to store the start date of every
    task. The key of the class will be the `ServerTask` object (a `Runnable` object),
    and the value will be a `Date` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executionStatistics`: This is a `ConcurrentHashMap` to store the statistics
    of use per user. The key will be the username and the value will be a `ExecutorStatistics`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CORE_POOL_SIZE`, `MAXIMUM_POOL_SIZE`, and `KEEP_ALIVE_TIME`: These are constants
    to define the characteristics of the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REJECTED_TASK_CONTROLLER`: This is a `RejectedTaskController` class attribute
    to control the tasks rejected by the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be explained by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the class calls to the parent constructor creating a `PriorityBlockingQueue`
    class to store the tasks that will be executed in the executor. This class orders
    the elements according to the result of the execution of the `compareTo()` method
    (so the elements stored in it have to implement the `Comparable` interface). The
    utilization of this class will allow us to execute our tasks by priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have overridden some methods of the `ThreadPoolExecutor` class. First
    is the `beforeExecute()` method. This method is executed before the execution
    of every task. It receives the `ServerTask` object as a parameter, and the thread
    that is going to execute the task. In our case, we store the actual date in the
    `ConcurrentHashMap` with the start dates of every task, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method is the `afterExecute()` method. This method is executed after
    the execution of every task in the executor and receives the `ServerTask` object
    that has been executed as parameter and a `Throwable` object. This last parameter
    will have value only when an exception is thrown during the execution of the task.
    In our case, we will use this method to:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the execution time of the task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update the statistics of the user in the following manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have overridden the `newTaskFor()` method. This method will be
    executed to convert the `Runnable` object that we send to the executor, using
    the `submit()` method in the instance of `FutureTask` that will be executed by
    the executor. In our case, we replace the default `FutureTask` class with our
    `ServerTask` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included an additional method in the executor to write all the statistics
    stored in the executor in the log system. This method will be called at the end
    of the execution of the server, as you will see later. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The command classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command classes execute the different queries you can send to the server.
    You can send five different queries to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query**: This is to get information about a country, an indicator, and optionally
    a year. It''s implemented by the `ConcurrentQueryCommand` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Report**: This is to get information about an indicator. It''s implemented
    by the `ConcurrentReportCommand` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: This is to get information about the status of a server. It''s
    implemented by the `ConcurrentStatusCommand` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: This is to cancel the execution of the tasks of a user. It''s implemented
    by the `ConcurrentCancelCommand` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**: This is to stop the execution of the server. It''s implemented by
    the `ConcurrentStopCommand` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have the `ConcurrentErrorCommand` class to manage the situation when
    an unknown command arrives at the server, and `ConcurrentCommand` that is the
    base class of all the commands.
  prefs: []
  type: TYPE_NORMAL
- en: The ConcurrentCommand class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the base class of every command. It includes the behavior common to
    all the commands that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the method that implements the specific logic of every command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the results to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close all the resources used in the communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class extends the `Command` class and implements the `Comparable` and `Runnable`
    interfaces. In the example of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, the commands were simple classes, but in this example, the concurrent
    commands are `Runnable` objects that will be sent to the executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It has three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username`: This is to store the name of the user that sends the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority`: This is to store the priority of the query. It will determine the
    order of execution of the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket`: This is the socket used in the communication with the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constructor of the class initializes these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The main functionality of this class is in the abstract `execute()` method,
    which will be implemented by every concrete command to calculate and return the
    results of the query, and in the `run()` method. The `run()` method calls the
    `execute()` method, stores the result in the cache, writes the result in the socket,
    and closes all the resources used in the communication. We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `compareTo()` method uses the priority attribute to determine
    the order of the tasks. This will be used by the `PriorityBlockingQueue` class
    to order the tasks, so the tasks with a higher priority will be executed first.
    Take into account that a task has higher priority when the `getPriority()` method
    returns a lower value. If the `getPriority()` of a task returns `1`, that task
    will have a higher priority than a task that `getPriority()` method returns `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Concrete commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have made minor changes in the classes that implement the different commands,
    and we added a new one implemented by the `ConcurrentCancelCommand` class. The
    main logic of these classes is included in the `execute()` method that calculates
    the response to the query and returns it as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execute()` method of the new `ConcurrentCancelCommand` makes a call to
    the `cancelTasks()` method of the `ConcurrentServer` class. This method will stop
    the execution of all the pending tasks associated with the user passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute()` method of `ConcurrentReportCommand` uses the `query()` method
    of the `WDIDAO` class to get the data requested by the user. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, you can find the implementation of this method. The implementation
    is almost the same. The only difference is command array indices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute()` method of `ConcurrentQueryCommand` uses the `report()` method
    of the `WDIDAO` class to get the data. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, you also can find the implementation of this method. The implementation
    here is almost the same. The only difference is the command array index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`ConcurrentStatusCommand` has an additional parameter in its constructor: the
    `Executor` object, which will execute the commands. This command uses this object
    to obtain information about the executor and send it as a response to the user.
    The implementation is almost the same as in [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*. We have used the same methods to get the status of the `Executor`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ConcurrentStopCommand` and `ConcurrentErrorCommand` are also the same as
    in [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, so we haven't included their source code.
  prefs: []
  type: TYPE_NORMAL
- en: The server part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server part receives the queries from the clients of the server and creates
    the command classes that executes the queries and sends them to the executor.
    It is implemented by two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConcurrentServer` class: It includes the `main()` method of the server
    and additional methods to cancel tasks and finish the execution of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `RequestTask` class: This class creates the commands and sends them to
    the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference with the example of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors* is the role of the `RequestTask` class. In the `SimpleServer` example,
    the `ConcurrentServer` class creates a `RequestTask` object per query and sends
    them to the executor. In this example, we will only have an instance of the `RequestTask`
    that will be executed as a thread. When the `ConcurrentServer` receives a connection,
    it stores the socket to communicate with the client in a concurrent list of pending
    connections. The `RequestTask` thread reads that socket, processes the data sent
    by the client, creates the corresponding command, and sends the command to the
    executor.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for this change is to leave in the tasks executed by the executor
    only the code of the queries and leave the preprocessed code outside the executor.
  prefs: []
  type: TYPE_NORMAL
- en: The ConcurrentServer class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ConcurrentServer` class needs some internal attributes to work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: A `ParallelCache` instance to use the cache system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ServerSocket` instance to get the connections from the clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `boolean` value to know when it has to stop its execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LinkedBlockingQueue` to store the sockets of the clients that sends a message
    to the server. These sockets will be processed by the `RequestTask` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ConcurrentHashMap` to store the `Future` objects associated with every task
    executed in the executor. The key will be the username of the users that sends
    the queries, and the values will be another `Map` whose key will be the `ConcurrenCommand`
    objects, and the value will be the `Future` instance associated with that task.
    We use these `Future` instances to cancel the execution of tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RequestTask` instance to create the commands and sends them to the executor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Thread` object to execute the `RequestTask` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` method of this class initializes these objects and opens the `ServerSocket`
    instance to listen to the connections from the clients. In addition, it creates
    the `RequestTask` object and executes it as a thread. It will be in a loop until
    the `shutdown()` method changes the value of the stopped attribute. After this,
    it waits for the finalization of the `Executor` object, using the `endTermination()`
    method of the `RequestTask` object, and shuts down the `Logger` system and the
    `RequestTask` object with the `finishServer()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It includes two methods to shut down the executor of the server. The `shutdown()`
    method changes the value of the `stopped` variable and closes the `serverSocket`
    instance. The `finishServer()` method stops the executor, interrupts the thread
    that executes the `RequestTask` object, and shuts downs the `Logger` system. We
    divided this process into two parts to use the `Logger` system until the last
    instruction of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The server includes the method that cancels the tasks associated with a user.
    As we mentioned before, the `Server` class uses a nested `ConcurrentHashMap` to
    store all the tasks associated with a user. First, we obtain the `Map` with all
    the tasks of a user and then we process all the `Future` objects of those tasks
    calling to the `cancel()` method of the `Future` objects. We pass the value `true`
    as a parameter, so if the executor is running a task from that user, it will be
    interrupted. We have included the necessary code to avoid the cancellation of
    `ConcurrentCancelCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have included a method to eliminate the `Future` object associated
    with tasks from our nested map of `ServerTask` objects when that task finishes
    its execution normally. It''s the `finishTask()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The RequestTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `RequestTask` class is the intermediary between the `ConcurrentServer` class,
    which connects to the clients, and the `Executor` class, which executes the concurrent
    tasks. It opens the socket with the client, reads the query data, creates the
    adequate command, and sends it to the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses some internal attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: A `LinkedBlockingQueue` where the `ConcurrentServer` class stores the client
    sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ServerExecutor` to execute the commands as concurrent tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ConcurrentHashMap` to store the `Future` objects associated with the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constructor of the class initializes all these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The main method of this class is the `run()` method. It executes a loop until
    the thread is interrupted processing the sockets stored in the `pendingConnections`
    object. In this object, the `ConcurrentServer` class stores the sockets to communicate
    with the different clients that sends a query to the server. It opens the socket,
    reads the data, and creates the corresponding command. This also sends the command
    to the executor and stores the `Future` object in the double `ConcurrentHashMap`
    associated with the `hashCode` of the task and with the user that sent the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `storeController()` method is the one that stores the `Future` object in
    the double `ConcurrentHashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have included two methods to manage the execution of the `Executor`
    class, one to call the `shutdown()` method for the executor and an other to wait
    for its finalization. Remember that you must explicitly call the `shutdown()`
    or `shutdownNow()` methods to end the execution of an executor. If not, the program
    won''t terminate. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The client part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to test our server. In this case, we won't worry much about the
    execution time. The main objective of our test is to check whether the new features
    work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have split the client part into the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The ConcurrentClient class**: This implements an individual client of the
    server. Each instance of this class has a different username. It makes 100 queries,
    90 of type query, and 10 of type report. The query queries have a priority of
    5, and the report queries have lower priority (10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The MultipleConcurrentClient class**: This measures the behavior of the multiple
    concurrent clients in parallel. We have tested the server with one to five concurrent
    clients. This class also tests the cancellation and the stop commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have included an executor to execute the concurrent requests to the server
    to increase the level of concurrency of the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, you can see the results of the cancellation of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The client part](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, four tasks of the **USER_2** user have been canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the final statistics about the number of tasks and
    the execution time of every user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The client part](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second example – executing periodic tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples with executors, the tasks were executed once, and they
    were executed as soon as possible. The executor framework includes other executor
    implementation that gives us more flexibility about the execution time of the
    tasks. It's the `ScheduledThreadPoolExecutor` class that allows us to execute
    tasks *periodically* and to execute tasks *after a delay*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to execute periodic tasks implementing
    a **RSS feed** reader. This is a simple case where you need to make the same task
    (reading the news of a RSS feed) at regular intervals. Our example will have the
    following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Store the RSS sources in a file. We have chosen news about the world from some
    important newspapers, such as The New York Times, the Daily News, or The Guardian.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We sent a `Runnable` object to the executor per RSS source. Every time the executor
    runs the object, it parses the RSS source and converts it to a list of `CommonInformationItem`
    objects with the content of the RSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the **Producer/Consumer design pattern** to write the RSS news to disk.
    The producers will be the tasks of the executor that write every `CommonInformationItem`
    into a buffer. Only the new items will be stored in the buffer. The consumer will
    be an independent thread that reads the news from the buffer and writes them to
    a disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time between the finalization of the execution of a task and its next execution
    will be one minute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have implemented the advanced version of the example where the time
    between two executions of a task can vary.
  prefs: []
  type: TYPE_NORMAL
- en: The common parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, we read an RSS feed and convert them to a list of
    objects. To parse the RSS file, we treat them as an XML file, and we have implemented
    a **SAX** (short for **Simple API for XML**)parser in the `RSSDataCapturer` class.
    It parses the file and creates a list of `CommonInformationItem`. This class stores
    the following information for every RSS item:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title**: Title of the RSS item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date**: Date of the RSS item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link**: Link to the RSS item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: The text of the RSS item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID**: The ID of the RSS item. If the item doesn''t include an ID, we calculate
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source**: The name of the RSS source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We store the news into a disk using the Producer/Consumer design pattern, so
    we need a buffer to store the news and a `Consumer` class that, in this case,
    reads the news from the buffer and stores them into the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented the buffer in the `NewsBuffer` class. It has two internal attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A LinkedBlockingQueue**: This is a concurrent data structure with blocking
    operations. If we want to obtain an item from the list and it''s empty, the thread
    of the calling method will be blocked until there are elements in the list. We
    will use this structure to store `CommonInformationItems`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A ConcurrentHashMap**: This is a concurrent implementation of a `HashMap`.
    We will use it to store the IDs of the news items stored in the buffer before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will only insert in the buffer the news that wasn''t inserted earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two methods in the `NewsBuffer` class: one to store an item in the
    buffer that checks whether the item has been inserted before, and the other to
    obtain the next item from the buffer. We use the `compute()` method to insert
    elements in the `ConcurrentHashMap`. This method receives a lambda expression
    as a parameter with the key and the actual value associated with this key (null
    if the key has no associated value). In our case, we add the item to the buffer
    it has not been processed before. We use the `add()` and `take()` methods to to
    insert, obtain, and delete elements from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The items of the buffer will be written to disk by the `NewsWriter` class that
    will be executed as an independent thread. It only has an internal attribute that
    points to the `NewsBuffer` class used in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` method of this `Runnable` object takes `CommonInformationItem`
    instances from the buffer and saves them to a disk. As we use the blocking method
    `take`, if the buffer is empty, this thread will be blocked until there are elements
    in the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The basic reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic reader will use a standard `ScheduledThreadPoolExecutor` class to
    execute the tasks periodically. We will execute a task per RSS source, and there
    will be one minute between the termination of one execution of a task and the
    commencement of the next execution. These concurrent tasks are implemented in
    the `NewsTask` class. It has three internal attributes to store the name of the
    RSS feed, its URL, and the `NewsBuffer` class to store the news:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` method of this `Runnable` object simply parses the RSS feed, gets
    a list of CommonItemInterface instances, and stores them in the buffer. This method
    will be executed in a periodic way. In every execution, the `run()` method will
    be executed from the beginning to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we also have implemented another thread to implement the initialization
    of the executor and the tasks and the wait for the finalization of the execution.
    We have named this class `NewsSystem`. It has three internal attributes to store
    the path to the file with the RSS sources, the buffer to store the news, and a
    `CountDownLatch` object to control the end of its execution. The `CountDownLatch`
    class is a synchronization mechanism that allows you to make a thread wait for
    an event. We will detail the utilization of this class in [Chapter 9](part0056_split_000.html#1LCVG2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 9. Diving into Concurrent Data Structures and Synchronization Utilities"),
    *Diving into Concurrent Data Structures and Synchronization Utilities*. We have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the `run()` method, we read all the RSS sources, create a `NewsTask` class
    for each one, and send them to our `ScheduledThreadPool` executor. We have created
    the executor using the `newScheduledThreadPool()` method of the `Executors` class,
    and we send the tasks to it using the `scheduleAtFixedDelay()` method. We also
    start the `NewsWriter` instance as a thread. The `run()` method waits for someone
    that tells it to finish its execution using the `await()` method of the `CountDownLatch`
    class and ends the execution of the `NewsWriter` task and of the `ScheduledExecutor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have implemented the `shutdown()` method. This method will notify the
    `NewsSystem` class to end its execution using the `countDown()` method of the
    `CountDownLatch` class. This method will wake up the `run()` method, so it will
    shut down the executor that is running the `NewsTask` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last class of this example is the `Main` class that implements the `main()`
    method of the example. It starts a `NewsSystem` instance as a thread, waits 10
    minutes, and notifies the thread of its finalization, and consequently finishes
    the execution of the entire system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this example, you see how the different tasks are executed
    in a periodic way and how the news items are written to a disk, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic reader](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The advanced reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic news reader is an example of utilization of a `ScheduledThreadPoolExecutor`
    class, but we can go a step further. As occurs with `ThreadPoolExecutor`, we can
    implement our own `ScheduledThreadPoolExecutor` to obtain a particular behavior.
    In our case, we want that the delay time of our periodic task changes depending
    on the moment of the day. In this part, you will learn how to implement this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to implement a class that tells us the delay between two
    executions of a periodic task. We named this the `Timer` class. It only has a
    static method named `getPeriod()`, which returns the number of milliseconds between
    the end of one execution and the start of the next one. This is our implementation,
    but you can make your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to implement the internal tasks of our executor. When you send
    a `Runnable` object to an executor, externally, you see that object as the concurrent
    task but the executor converts this object into another task, an instance of the
    `FutureTask` class, that includes the `run()` method to execute the task and the
    methods of the `Future` interface to manage the execution of the task. To implement
    this example, we have to implement a class that extends the `FutureTask` class,
    and, as we will execute these tasks in a **scheduled executor**, it has to implement
    the `RunnableScheduledFuture` interface. This interface provides the `getDelay()`
    method that returns the time remaining to the next execution of a task. We have
    implemented these internal tasks in the `ExecutorTask` class. It has four internal
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The original `RunnableScheduledFuture` internal task created by the `ScheduledThreadPoolExecutor`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheduled executor that will execute the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The start date of the next execution of the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the RSS feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have overridden or implemented different methods in this class. The first
    one, the `getDelay()` method that, as we told you before, returns the time remaining
    to the next execution of a task in the given unit time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next one, the `compareTo()` method, compares two tasks, taking into account
    the start date of the next execution of the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `isPeriodic()` method returns `true` if the task is periodic or `false`
    if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `run()` method that implements the most important part
    of this example. First, we call the `runAndReset()` method of the `FutureTask`
    class. This method executes the task and resets its status, so it can be executed
    again. Then, we calculate the start date of the next execution using the `Timer`
    class, and finally, we have to insert the task again in the queue of the `ScheduledThreadPoolExecutor`
    class. If we don''t do this final step, the task won''t be executed again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the tasks for the executor, we have to implement the executor.
    We have implemented the `NewsExecutor` class that extends the `ScheduledThreadPoolExecutor`
    class. We have overridden the `decorateTask()` method. With this method, you can
    replace the internal task used by the scheduled executor. By default, it returns
    a default implementation of the `RunnableScheduledFuture` interface, but in our
    case, it will return an instance of the `ExecutorClass` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have to implement other versions of the `NewsSystem` and the `Main` classes
    to use the `NewsExecutor`. We have implemented `NewsAdvancedSystem` and `AdvancedMain`
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can run the advanced news system to see how the delay time between executions
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information about executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have extended `ThreadPoolExecutor` and the `ScheduledThreadPoolExecutor`
    class and overridden some of their methods. But you can override more methods
    if you want a more particular behavior. These are some methods you can override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shutdown()`: You must explicitly call this method to end the execution of
    the executor. You can override it to add some code to free additional resources
    used by your own executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdownNow()`: The difference between `shutdown()` and `shutdownNow()` is
    that the `shutdown()` method waits for the finalization of all the tasks that
    are waiting in the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit()`, `invokeall()`, or `invokeany()`: you call these methods to send
    concurrent tasks to the executor. You can override them if you need to do some
    actions before or after a task is inserted in the task queue of the executor.
    Note that adding a custom action before or after the task is enqueued is different
    than adding a custom action before or after it''s executed, which we did while
    overriding `beforeExecute()` and `afterExecute()` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the news reader example, we use the `scheduleWithFixedDelay()` method to
    send tasks to the executor. But the `ScheduledThreadPoolExecutor` class has other
    methods to execute periodic tasks or tasks after a delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schedule()`: This method executes a task after the given delay. The task is
    executed only once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheduleAtFixedRate()`: This method executes a periodic task with the given
    period. The difference with the s`cheduleWithFixedDelay()` method is that in the
    last one, the delay between two executions goes from the end of the first one
    to the start of the second one and in the first one the delay between two executions
    goes between the start of both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented two examples that explored advanced characteristics
    of executors. In the first example, we continued with the client/server example
    of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*. We implemented our own executor extending the `ThreadPoolExecutor`
    class to execute the tasks by priority and to measure the executing time of the
    tasks per user. We also included a new command to allow the cancellation of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we explained how to use the `ScheduledThreadPoolExecutor`
    class to execute periodic tasks. We implemented two versions of a news reader.
    The first one showed how to use the basic functionality of the `ScheduledExecutorService,`
    and the second one showed how to override the behavior of the `ScheduledExecutorService`
    class to, for example, change the delay time between the two executions of a task.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to execute `Executor` tasks that return
    a result. If you extend the `Thread` class or implement the `Runnable` interface,
    the `run()` method doesn't return any result, but the executor framework includes
    the `Callable` interface that allows you to implement tasks that return a result.
  prefs: []
  type: TYPE_NORMAL
