- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Building Blocks of Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any programming language starts off looking like ancient Greek to the unaccustomed
    eye, and C# is no exception. The good news is beneath the initial mystery, all
    programming languages are made up of the same essential building blocks. Variables,
    methods, and classes (or objects) make up the DNA of conventional programming;
    understanding these simple concepts opens up an entire world of diverse and complex
    applications. After all, there are only four different DNA nucleobases in every
    person on earth; yet, here we are, every one of us a unique organism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to programming, there's going to be a lot of information coming
    at you in this chapter, and this could mark the first lines of code that you've
    ever written. The point is not to overload your brain with facts and figures;
    it's to give you a holistic look at the building blocks of programming using examples
    from everyday life.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is all about the high-level view of the bits and pieces that make
    up a program. Getting the hang of how things work before getting into the code
    directly will not only help you new coders find your feet, but it will also solidify
    the topics with easy-to-remember references. Ramblings aside, we''ll focus on
    the following topics throughout this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting the building blocks together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple question: what is a variable? Depending on your
    point of view, there are a few different ways of answering that question:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Conceptually**, a variable is the most basic unit of programming, as an atom
    is to the physical world (excepting string theory). Everything starts with variables,
    and programs can''t exist without them.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technically**, a variable is a tiny section of your computer''s memory that
    holds an assigned value. Every variable keeps track of where its information is
    stored (this is called a memory address), its value, and its type (for instance,
    numbers, words, or lists).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practically**, a variable is a container. You can create new ones at will,
    fill them with stuff, move them around, change what they''re holding, and reference
    them as needed. They can even be empty and still be useful.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find an in-depth explanation of variables in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A practical real-life example of a variable is a mailbox—remember those?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_02_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Snapshot of a row of colorful mailboxes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'They can hold letters, bills, a picture from your aunt Mabel—anything. The
    point is that what''s in a mailbox can vary: they can have names, hold information
    (physical mail), and their contents can even be changed if you have the right
    security clearance. Similarly, variables can hold different kinds of information.
    Variables in C# can hold strings (text), integers (numbers), and even Booleans
    (binary values that represent either true or false).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Names are important
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Referring to *Figure 2.1*, if I asked you to go over and open the mailbox,
    the first thing you''d probably ask is: which one? If I said the Smith family
    mailbox, or the sunflower mailbox, or even the droopy mailbox on the far right,
    then you''d have the necessary context to open the mailbox I was referencing.
    Similarly, when you are creating variables, you have to give them unique names
    that you can reference later. We''ll get into the specifics of proper formatting
    and descriptive naming in *Chapter 3*,*Diving into Variables, Types, and Methods*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Variables act as placeholders
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create and name a variable, you are creating a placeholder for the
    value that you want to store. Let''s take the following simple math equation as
    an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Okay, no mystery here, but what if we wanted the number `9` to be its variable?
    Consider the following code block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这里没有什么神秘的，但如果我们想让数字`9`成为它的变量呢？考虑以下代码块：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can use the variable name, `MyVariable`, as a substitute for `9` anywhere
    we need it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用变量名`MyVariable`来替代我们需要的`9`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're wondering whether variables have other rules or regulations, they
    do. We'll get to those in the next chapter, so sit tight.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道变量是否有其他规则或规定，答案是肯定的。我们将在下一章中介绍这些内容，所以请耐心等待。
- en: Even though this example isn't real C# code, it illustrates the power of variables
    and their use as placeholder references. In the next section you'll start creating
    variables of your own, so keep going!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子不是真正的C#代码，但它说明了变量的威力以及它们作为占位符引用的用途。在下一节中，你将开始创建自己的变量，所以继续前进吧！
- en: 'Alright, enough theory—let''s create a real variable in the `LearningCurve`
    script we created in *Chapter 1*, *Getting to Know Your Environment*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，理论够了，让我们在我们在*第1章*，*了解你的环境*中创建的`LearningCurve`脚本中创建一个真正的变量：
- en: Double-click on `LearningCurve.cs` from the Unity project window to open it
    in Visual Studio.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity项目窗口中双击`LearningCurve.cs`，在Visual Studio中打开它。
- en: 'Add a space between lines 6 and 7 and add the following line of code to declare
    a new variable:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第6行和第7行之间添加一个空格，并添加以下代码行来声明一个新变量：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Start` method, add two debug logs to print out the following calculations:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中，添加两个调试日志，打印出以下计算结果：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's break down the code we just added. First, we created a new variable called
    `CurrentAge` and assigned it a value of `30`. Then, we added two debug logs to
    print out the result of `30 + 1` and `CurrentAge + 1` to show how variables are
    storage for values. They can be used the exact same way as the values themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解刚刚添加的代码。首先，我们创建了一个名为`CurrentAge`的新变量，并将其赋值为`30`。然后，我们添加了两个调试日志，打印出`30 +
    1`和`CurrentAge + 1`的结果，以展示变量是值的存储器。它们可以与值本身完全相同地使用。
- en: 'It''s also important to note that `public` variables appear in the Unity Inspector,
    while `private` ones don''t. Don''t worry about the syntax right now—just make
    sure your script is the same as the script that is shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，`public`变量会出现在Unity检视面板中，而`private`变量不会。现在不用担心语法，只需确保你的脚本与下面截图中显示的脚本相同：
- en: '![](img/B17573_02_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_02.png)'
- en: 'Figure 2.2: LearningCurve script open in Visual Studio'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在Visual Studio中打开的LearningCurve脚本
- en: To finish, save the file using **Editor** | **File** | **Save**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用**编辑器** | **文件** | **保存**保存文件。
- en: 'For scripts to run in Unity, they have to be attached to *GameObjects* in the
    scene. The sample scene in *Hero Born* has a camera and directional light by default,
    which provides the lighting for the scene, so let''s attach `LearningCurve` to
    the camera to keep things simple:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中运行脚本，它们必须附加到场景中的*游戏对象*上。*英雄诞生*中的示例场景默认包含摄像机和定向光，这为场景提供了照明，所以让我们将`LearningCurve`附加到摄像机上，以保持简单：
- en: Drag and drop `LearningCurve.cs` onto the **Main Camera**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LearningCurve.cs`拖放到**主摄像机**上。
- en: Select the **Main Camera** so that it appears in the **Inspector** panel, and
    verify that the `LearningCurve.cs` (Script) component is attached properly.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**主摄像机**，使其出现在**检视器**面板中，并验证`LearningCurve.cs`（脚本）组件是否正确附加。
- en: Click play and watch for the output in the **Console** panel:![](img/B17573_02_03.png)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并观察**控制台**面板中的输出：![](img/B17573_02_03.png)
- en: 'Figure 2.3: Unity Editor window with callouts for dragging and dropping scripts'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Unity编辑器窗口，带有拖放脚本的标注
- en: 'The `Debug.Log()` statements printed out the result of the simple math equations
    we put in between the parentheses. As you can see in the following **Console**
    screenshot, the equation that used our variable, `CurrentAge`, worked the same
    as if it were a real number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log()`语句打印出了我们放在括号中的简单数学方程的结果。正如你在下面的**控制台**截图中所看到的，使用我们的变量`CurrentAge`的方程的工作方式与它是一个实际数字一样：'
- en: '![](img/B17573_02_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_04.png)'
- en: 'Figure 2.4: Unity console with debug output from the attached script'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：Unity控制台显示了附加脚本的调试输出
- en: We'll get into how Unity converts C# scripts into components at the end of this
    chapter, but first, let's work on changing the value of one of our variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末讨论Unity如何将C#脚本转换为组件，但首先让我们来改变其中一个变量的值。
- en: 'Since `CurrentAge` was declared as a variable on line 7 as shown in *Figure
    2.2*, the value it stores can be changed. The updated value will then trickle
    down to wherever the variable is used in code; let''s see this in action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAge`在第7行被声明为一个变量，如*图2.2*所示，它存储的值可以被改变。更新后的值将传递到代码中使用变量的任何地方；让我们看看这个过程：
- en: Stop the game by clicking the **Pause** button if the scene is still running
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果场景仍在运行，请点击**暂停**按钮停止游戏
- en: Change **Current Age** to `18` in the **Inspector** panel and play the scene
    again, looking at the new output in the **Console** panel:![](img/B17573_02_05.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**面板中将**Current Age**更改为`18`，然后再次播放场景，观察**控制台**面板中的新输出：![](img/B17573_02_05.png)
- en: 'Figure 2.5: Unity console with debug logs and the LearningCurve script attached
    to Main Camera'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Unity控制台显示了调试日志和附加到主摄像机的LearningCurve脚本
- en: The first output will still be `31` because we didn't change anything in the
    script, but the second output is now `19` because we changed the value of `CurrentAge`
    in the Inspector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出仍然是`31`，因为我们在脚本中没有改变任何东西，但第二个输出现在是`19`，因为我们在检视面板中改变了`CurrentAge`的值。
- en: The goal here wasn't to go over variable syntax but to show how variables act
    as containers that can be created once and referenced elsewhere. We'll go into
    more detail in *Chapter 3*, *Diving into Variables, Types, and Methods*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标不是讨论变量语法，而是展示变量如何作为容器，可以创建一次并在其他地方引用。我们将在*第3章*，*深入变量、类型和方法*中详细讨论。
- en: 'Now that we know how to create variables in C# and assign them values, we''re
    ready to dive into the next important programming building block: methods!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在C#中创建变量并赋值，我们准备好深入下一个重要的编程构建块：方法！
- en: Understanding methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法
- en: On their own, variables can't do much more than keep track of their assigned
    values. While this is vital, they are not very useful on their own in terms of
    creating meaningful applications. So, how do we go about creating actions and
    driving behavior in our code? The short answer is by using methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的变量不能做更多的事情，只能跟踪其分配的值。虽然这很重要，但它们单独来说在创建有意义的应用程序方面并不是非常有用。那么，我们如何创建动作并在代码中驱动行为呢？简短的答案是使用方法。
- en: Before we get to what methods are and how to use them, we should clarify a small
    point of terminology. In the world of programming, you'll commonly see the terms
    *method* and *function* used interchangeably, especially in regards to Unity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论方法是什么以及如何使用它们之前，我们应该澄清一个术语的小细节。在编程世界中，你经常会看到术语*方法*和*函数*被交替使用，特别是在Unity方面。
- en: Since C# is an object-oriented language (this is something that we'll cover
    in *Chapter 5*, *Working with Classes, Structs, and OOP*), we'll be using the
    term *method* for the rest of the book to conform to standard C# guidelines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#是一种面向对象的语言（这是我们将在*第5章* *使用类、结构和面向对象编程*中介绍的内容），我们将在本书的其余部分使用术语*方法*，以符合标准的C#指南。
- en: When you come across the word function in the Scripting Reference or any other
    documentation, think method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在脚本参考或其他文档中遇到函数这个词时，想到方法。
- en: Methods drive actions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法驱动行为
- en: 'Similarly to variables, defining programming methods can be tediously long-winded
    or dangerously brief; here''s another three-pronged approach to consider:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量类似，定义编程方法可能会非常冗长或非常简短；这里有另外一个三方面的方法来考虑：
- en: '**Conceptually**, methods are how work gets done in an application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，方法是应用程序中完成工作的方式。'
- en: '**Technically**, a method is a block of code containing executable statements
    that run when the method is called by name. Methods can take in arguments (also
    called parameters), which can be used inside the method''s scope.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，方法是一个包含可执行语句的代码块，当通过名称调用方法时运行。方法可以接受参数（也称为参数），这些参数可以在方法的范围内使用。'
- en: '**Practically**, a method is a container for a set of instructions that run
    every time it''s executed. These containers can also take in variables as inputs,
    which can only be referenced inside the method itself.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，方法是一组指令的容器，每次执行时都会运行。这些容器还可以接受变量作为输入，这些变量只能在方法内部引用。'
- en: Taken all together, methods are the bones of any program—they connect everything
    and almost everything is built off of their structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，方法是任何程序的骨架——它们连接一切，几乎所有的东西都是基于它们的结构构建的。
- en: You can find an in-depth guide to methods in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Microsoft C#文档中找到有关方法的深入指南，网址为[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods)。
- en: Methods are placeholders too
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也是占位符
- en: 'Let''s take an oversimplified example of adding two numbers together to drive
    the concept home. When writing a script, you''re essentially laying down lines
    of code for the computer to execute in sequential order. The first time you need
    to add two numbers together, you could just add them like in the following code
    block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个过于简化的例子来加深概念。在编写脚本时，你实际上是按顺序放置代码行，让计算机执行。第一次需要将两个数字相加时，你可以像下面的代码块中那样直接相加：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But then you conclude that these numbers need to be added together somewhere
    else.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是然后你得出结论，这些数字需要在其他地方相加。
- en: 'Instead of copying and pasting the same line of code, which results in sloppy
    or "spaghetti" code and should be avoided at all costs, you can create a named
    method that will take care of this action:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其复制和粘贴相同的代码行，导致杂乱或“意大利面”代码并且应该尽量避免，你可以创建一个命名的方法来处理这个动作：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now `AddNumbers` is holding a place in memory, just like a variable; however,
    instead of a value, it holds a block of instructions. Using the name of the method
    (or calling it) anywhere in a script puts the stored instructions at your fingertips
    without having to repeat any code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`AddNumbers`就像一个变量一样占据着内存中的位置；但是，它不是一个值，而是一系列指令。在脚本中的任何地方使用方法的名称（或调用它）都可以让你立即使用存储的指令，而无需重复任何代码。
- en: If you find yourself writing the same lines of code over and over, you're likely
    missing a chance to simplify or condense repeated actions into common methods.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己一遍又一遍地写相同的代码行，你很可能错过了简化或将重复操作合并为常见方法的机会。
- en: This produces what programmers jokingly call spaghetti code because it can get
    messy. You'll also hear programmers refer to a solution called the **Don't Repeat
    Yourself** (**DRY**) principle, which is a mantra you should keep in mind.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生程序员开玩笑称之为意大利面代码的东西，因为它可能会变得混乱。你也会听到程序员提到一个叫做**不要重复自己**（**DRY**）原则的解决方案，这是一个你应该牢记的口头禅。
- en: As before, once we've seen a new concept in pseudocode, it's best if we implement
    it ourselves, which is what we'll do in the next section to drive it home.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，一旦我们在伪代码中看到了一个新概念，最好是自己实现一下，这就是我们将在下一节中做的事情。
- en: 'Let''s open up `LearningCurve` again and see how a method works in C#. Just
    like with the variables example, you''ll want to copy the code into your script
    exactly as it appears in the following screenshot. I''ve deleted the previous
    example code to make things neater, but you can, of course, keep it in your script
    for reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开`LearningCurve`，看看C#中的方法是如何工作的。就像变量示例一样，你会想要将代码粘贴到你的脚本中，就像下面的截图中显示的那样。我已经删除了以前的示例代码，以使事情更整洁，但你当然可以将其保留在脚本中以供参考：
- en: Open up `LearningCurve` in Visual Studio.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`LearningCurve`。
- en: 'Add a new variable to line 8:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第8行添加一个新变量：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new method to line 16 that adds `CurrentAge` and `AddedAge` together
    and prints out the result:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第16行添加一个新的方法，将`CurrentAge`和`AddedAge`相加并打印出结果：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Start` with the following line:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`中调用新方法，使用以下行：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Double-check that your code looks like the following screenshot before you
    run the script in Unity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中运行脚本之前，请确保您的代码看起来像以下截图：
- en: '![](img/B17573_02_06.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_06.png)'
- en: 'Figure 2.6: LearningCurve with new ComputeAge method'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：具有新的ComputeAge方法的LearningCurve
- en: Save the file, and then go back and hit play in Unity to see the new **Console**
    output.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后返回Unity并点击播放，看看新的**控制台**输出。
- en: 'You defined your first method on lines 16 to 19 and called it on line 13\.
    Now, wherever `ComputeAge()` is called, the two variables will be added together
    and printed to the console, even if their values change. Remember, you set `CurrentAge`
    to `18` in the Unity Inspector, and the Inspector value will always override the
    value in a C# script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第16到19行定义了您的第一个方法，并在第13行调用了它。现在，无论何时调用`ComputeAge()`，这两个变量都将被相加并打印到控制台上，即使它们的值发生变化。请记住，您在Unity检视器中将`CurrentAge`设置为`18`，检视器的值将始终覆盖C#脚本中的值：
- en: '![](img/B17573_02_07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_07.png)'
- en: 'Figure 2.7: Console output from changing the variable value in the Inspector'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：更改检视器中变量值的控制台输出
- en: Go ahead and try out different variable values in the **Inspector** panel to
    see this in action! More details on the actual code syntax of what you just wrote
    are coming up in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试在**检视器**面板中尝试不同的变量值，看看它是如何运作的！关于您刚刚编写的实际代码语法的更多细节将在下一章中介绍。
- en: With a bird's-eye view of methods under our belts, we're ready to tackle the
    biggest topic in the programming landscape—classes!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了方法的整体概念之后，我们准备好着手处理编程领域中最大的主题——类！
- en: Introducing classes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍类
- en: 'We''ve seen how variables store information and how methods perform actions,
    but our programming toolkit is still somewhat limited. We need a way of creating
    a sort of super container, containing variables and methods that can be referenced
    from within the container itself. Enter classes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到变量存储信息，方法执行操作，但是我们的编程工具包仍然有些有限。我们需要一种创建一种超级容器的方法，其中包含可以从容器内部引用的变量和方法。输入类：
- en: '**Conceptually**, a class holds related information, actions, and behaviors
    inside a single container. They can even communicate with each other.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，类在单个容器内保存相关信息、操作和行为。它们甚至可以相互通信。'
- en: '**Technically**, classes are data structures. They can contain variables, methods,
    and other programmatic information, all of which can be referenced when an object
    of the class is created.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，类是数据结构。它们可以包含变量、方法和其他编程信息，当类的对象被创建时，所有这些信息都可以被引用。'
- en: '**Practically**, a class is a blueprint. It sets out the rules and regulations
    for any object (called an instance) created using the class blueprint.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，类是一个蓝图。它为使用类蓝图创建的任何对象（称为实例）制定了规则和法规。'
- en: You've probably realized that classes surround us not only in Unity but in the
    real world as well. Next, we'll take a look at the most common Unity class and
    how classes function in the wild.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到类不仅在Unity中存在，而且在现实世界中也存在。接下来，我们将看一下最常见的Unity类以及类在实际中的功能。
- en: You can find an in-depth guide to classes in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Microsoft C#文档中找到有关类的深入指南[https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)。
- en: A common Unity class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个常见的Unity类
- en: 'Before you wonder what a class looks like in C#, you should know that you''ve
    been working with a class this whole chapter. By default, every script created
    in Unity is a class, which you can see from the `class` keyword on line 5:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想知道C#中的类是什么样子之前，您应该知道您在整个本章中一直在使用一个类。默认情况下，Unity中创建的每个脚本都是一个类，您可以从第5行的`class`关键字中看到：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MonoBehaviour` just means that this class can be attached to a GameObject
    in the Unity scene.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour`只是意味着这个类可以附加到Unity场景中的GameObject上。'
- en: Classes can exist on their own, which we'll see when we create standalone classes
    in *Chapter 5*, *Working with Classes, Structs, and OOP*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以独立存在，当我们在*第5章*中创建独立类时，我们将看到这一点。
- en: The terms script and class are sometimes used interchangeably in Unity resources.
    For consistency, I'll be referring to C# files as scripts if they're attached
    to GameObjects and as classes if they are standalone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在Unity资源中，脚本和类这两个术语是可以互换使用的。为了保持一致，我将在脚本附加到GameObject时将C#文件称为脚本，并在它们是独立的类时称为类。
- en: Classes are blueprints
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类是蓝图
- en: For our last example, let's think about a local post office. It's a separate,
    self-contained environment that has properties, such as a physical address (a
    variable), and the ability to execute actions, such as sending out your mail (methods).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个例子，让我们想想一个当地的邮局。它是一个独立的、自包含的环境，具有属性，比如物理地址（一个变量），以及执行动作的能力，比如寄出您的邮件（方法）。
- en: 'This makes a post office a great example of a potential class that we can outline
    in the following block of pseudocode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得邮局成为一个潜在类的绝佳例子，我们可以在以下伪代码块中概述：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main takeaway here is that when information and behaviors follow a predefined
    blueprint, complex actions and inter-class communication become possible. For
    instance, if we had another class that wanted to send a letter through our `PostOffice`
    class, it wouldn''t have to wonder where to go to fire this action. It could simply
    call the `SendMail` function from the `PostOffice` class, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要要点是，当信息和行为遵循预定义的蓝图时，复杂的操作和类间通信变得可能。例如，如果我们有另一个类想要通过我们的`PostOffice`类发送一封信，它不必想知道去哪里执行此操作。它可以简单地从`PostOffice`类中调用`SendMail`函数，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could use it to look up the address of the post office so
    you know where to post your letters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用它查找邮局的地址，这样您就知道在哪里寄信：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you're wondering about the use of periods (called dot notation) between words,
    we'll be diving into that in the next section—hold tight.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Communication among classes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we've described classes and, by extension, Unity components as
    separate standalone entities; in reality, they are deeply intertwined. You'd be
    hard-pressed to create any kind of meaningful software application without invoking
    some kind of interaction or communication between classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember the post office example from earlier, the example code made
    use of periods (or dots) to reference classes, variables, and methods. If you
    think of classes as directories of information, then dot notation is the indexing
    tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any variables, methods, or other data types within a class can be accessed with
    dot notation. This applies to nested, or subclass, information as well, but we'll
    tackle all those subjects when we get to *Chapter 5*, *Working with Classes, Structs,
    and OOP*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Dot notation is also what drives communication between classes. Whenever a
    class needs information about another class or wants to execute one of its methods,
    dot notation is used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dot notation is sometimes referred to as the `.` operator, so don't be thrown
    off if you see it mentioned this way in documentation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If dot notation doesn't quite click with you yet, don't worry, it will. It's
    the bloodstream of the entire programming body, carrying information and context
    wherever it's needed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know a little more about classes, let's talk about the tool you'll
    use the most in your programming career—comments!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Working with comments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that `LearningCurve` has an odd line of text (**10**
    in *Figure 2.6*) starting with two forward slashes, which were created by default
    with the script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: These are code comments! In C#, there are a few ways that you can use to create
    comments, and Visual Studio (and other code editing applications) will often make
    it even easier with built-in shortcuts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Some professionals wouldn't call commenting an essential building block of programming,
    but I'll have to respectfully disagree. Correctly commenting out your code with
    meaningful information is one of the most fundamental habits a new programmer
    can develop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Single-line comments
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following single-line comment is like the one we''ve included in `LearningCurve`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Visual Studio doesn't compile lines starting with two forward slashes (without
    empty space) as code, so you can use them as much as needed to explain your code
    to others or your future self.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Multi-line comments
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since it''s in the name, you''d be right to assume that single-line comments
    only apply to one line of code. If you want multi-line comments, you''ll need
    to use a forward slash and an asterisk, (`/*` and `*/` as opening and closing
    characters respectively) around the comment text:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also comment and uncomment blocks of code by highlighting them and using
    the `Cmd` + `/`shortcut on macOS and `Ctrl` + `K` + `C` on Windows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio also provides a handy auto-generated commenting feature; type
    in three forward slashes on the line preceding any line of code (variables, methods,
    classes, and more) and a summary comment block will appear.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Seeing example comments is good, but putting them in your code is always better.
    It's never too early to start commenting!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up `LearningCurve` and add in three backslashes above the `ComputeAge()`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_02_08.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Triple-line comment automatically generated for a method'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You should see a three-line comment with a description of the method generated
    by Visual Studio from the method's name, sandwiched between two `<summary>` tags.
    You can, of course, change the text, or add new lines by hitting `Enter` just
    as you would in a text document; just make sure not to touch the `<summary>` tags
    or Visual Studio won't recognize the comments correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The useful part about these detailed comments is clear when you want to know
    something about a method you''ve written. If you''ve used a triple forward slash
    comment, all you need to do is hover over the method name anywhere it''s called
    within a class or script, and Visual Studio will pop your summary:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_02_09.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Visual Studio pop-up info box with the comment summary'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Your basic programming toolkit is now complete (well, the theory drawer, at
    least). However, we still need to understand how everything we've learned in this
    chapter applies in the Unity game engine, which is what we'll be focusing on in
    the next section!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Putting the building blocks together
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the building blocks squared away, it's time to do a little Unity-specific
    housekeeping before wrapping up this chapter. Specifically, we need to know more
    about how Unity handles C# scripts attached to game objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll keep using our `LearningCurve` script and Main Camera
    GameObject.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Scripts become components
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All GameObject components are scripts, whether they're written by you or the
    good people at Unity. The only difference is that Unity-specific components such
    as `Transform`, and their respective scripts just aren't supposed to be edited
    by users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The moment a script that you have created is dropped onto a GameObject, it becomes
    another component of that object, which is why it appears in the **Inspector**
    panel. To Unity, it walks, talks, and acts like any other component, complete
    with public variables underneath the component that can be changed at any time.
    Even though we aren't supposed to edit the components provided by Unity, we can
    still access their properties and methods, making them powerful development tools.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Unity also makes some automatic readability adjustments when a script becomes
    a component. You might have noticed in *Figures 2.3* and *2.5* that when we added
    `LearningCurve` to Main Camera, Unity displayed it as `Learning Curve`, with `CurrentAge`
    changing to `Current Age`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at how to update a variable in the **Inspector** panel in the *Variables
    act as placeholders* section, but it''s important to touch on how this works in
    more detail. There are three situations in which you can modify a property value:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In **Play Mode** in the Unity Editor window
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Development Mode** in the Unity Editor window
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Visual Studio code editor
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes made in Play Mode take effect in real time, which is great for testing
    and fine-tuning gameplay. However, it's important to note that any changes made
    while in Play Mode will be lost when you stop the game and return to Development
    Mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: When you're in Development Mode, any changes that you make to the variables
    will be saved by Unity. This means that if you were to quit Unity and then restart
    it, the changes would be retained.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The changes that you make to values in the **Inspector** panel while in Play
    Mode do not modify your script, but they will override any values you had assigned
    in your script when in Development Mode.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Any changes made in Play Mode will always reset automatically when you stop
    Play Mode. If you need to undo any changes made in the **Inspector** panel, you
    can reset the script to its default (sometimes called initial) values. Click on
    the three vertical dots icon to the right of any component, and then select **Reset**,
    as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_02_10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Script reset option in the Inspector'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This should give you some peace of mind—if your variables get out of hand, there's
    always the hard reset.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A helping hand from MonoBehaviour
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since C# scripts are classes, how does Unity know to make some scripts components
    and not others? The short answer is that `LearningCurve` (and any script created
    in Unity) inherits from `MonoBehaviour` (a default class provided by Unity). This
    tells Unity that the C# class can be transformed into a component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The topic of class inheritance is a bit advanced for this point of your programming
    journey; think of it as the `MonoBehaviour` class lending a few of its variables
    and methods to `LearningCurve`. *Chapter 5*, *Working with Classes, Struct, and
    OOP*, will cover class inheritance in practical detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承的主题对于您的编程之旅来说有点高级；把`MonoBehaviour`类想象成向`LearningCurve`借用一些变量和方法。*第5章*，*使用类、结构和面向对象编程*，将详细介绍类继承。
- en: The `Start()` and `Update()` methods that we've used belong to `MonoBehaviour`,
    which Unity runs automatically on any script attached to a GameObject. The `Start()`
    method runs once when the scene starts playing, while the `Update()` method runs
    once per frame (depending on the frame rate of your machine).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`Start()`和`Update()`方法属于`MonoBehaviour`，Unity会自动在附加到GameObject的任何脚本上运行它们。`Start()`方法在场景开始播放时运行一次，而`Update()`方法在每帧运行一次（取决于您的机器的帧率）。
- en: Now that your familiarity with Unity's documentation has gotten a nice bump,
    I've put together a short optional challenge for you to tackle!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Unity的文档熟悉度有了很大提升，我为您准备了一个简短的可选挑战！
- en: Hero's trial – MonoBehaviour in the Scripting API
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的试炼-脚本API中的MonoBehaviour
- en: 'Now it''s time for you to get comfortable using the Unity documentation on
    your own, and what better way than to look up some of the common `MonoBehaviour`
    methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让您自己熟悉使用Unity文档了，还有什么比查找一些常见的`MonoBehaviour`方法更好的方法呢：
- en: Try searching for the `Start()` and `Update()` methods in the Scripting API
    to gain a better understanding of what they do in Unity, and when
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在脚本API中搜索`Start()`和`Update()`方法，以更好地了解它们在Unity中的作用，以及何时
- en: If you're feeling brave, go the extra step and have a look at the `MonoBehaviour`
    class in the manual for a more detailed explanation
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您感到勇敢，可以进一步查看手册中的`MonoBehaviour`类，以获得更详细的解释
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've come a long way in a few short pages, but understanding the overarching
    theory of fundamental concepts such as variables, methods, and classes will give
    you a strong foundation to build on. Bear in mind that these building blocks have
    very real counterparts in the real world. Variables hold values like mailboxes
    hold letters; methods store instructions like recipes, to be followed for a predefined
    result; and classes are blueprints just like real blueprints. You can't build
    a house without a well-thought-out design to follow if you expect it to stay standing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短短的几页中走了很长的路，但是理解变量、方法和类等基本概念的总体理论将为您打下坚实的基础。请记住，这些构建块在现实世界中有非常真实的对应物。变量保存值，就像邮箱保存信件一样；方法存储指令，就像食谱一样，用于预定义的结果；类就像真实的蓝图一样。如果您希望房子能够屹立不倒，就不能没有经过深思熟虑的设计来遵循。
- en: The rest of this book will take you on a deep dive into C# syntax from scratch,
    starting with more detail in the next chapter on how to create variables, manage
    value types, and work with simple and complex methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将带您深入学习C#语法，从头开始，从下一章开始更详细地介绍如何创建变量、管理值类型以及使用简单和复杂的方法。
- en: Pop quiz – C# building blocks
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验-C#构建块
- en: What is the main purpose of a variable?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的主要目的是什么？
- en: What role do methods play in scripts?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法在脚本中扮演什么角色？
- en: How does a script become a component?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本如何成为组件？
- en: What is the purpose of dot notation?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点符号的目的是什么？
- en: JOIN us on Discord!
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*会话与作者交谈，以及更多。
- en: Join Now!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
