- en: 3\. kubectl – Kubernetes Command Center
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will demystify some common kubectl commands and see how
    we can use kubectl to control our Kubernetes cluster. We will begin this chapter
    by taking a brief look at what the end-to-end process looks like when using kubectl
    commands to communicate with a Kubernetes cluster. Then, we will set up a few
    shortcuts and autocompletion for the Bash terminal. We will begin with the basics
    of using kubectl by learning how to create, delete, and manage Kubernetes objects.
    We will learn about the two approaches to managing resources in Kubernetes - declarative
    and imperative - with exercises. By the end of this chapter, you will also have
    learned how to update a live application running on your Kubernetes cluster in
    real-time using kubectl.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Introduction to Kubernetes and Containers*, we saw that Kubernetes
    is a portable and highly extensible open-source container orchestration tool.
    It provides very powerful capabilities that can be used to manage containerized
    workloads at scale. In the previous chapter, you got the big picture of how the
    different components of Kubernetes work together to achieve the desired goals.
    We also demonstrated some basic usage of kubectl in *Chapter 2, An Overview of
    Kubernetes*. In this chapter, we will take a closer look at this utility and look
    at how we can make use of its potential.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, kubectl is a command-line utility for interacting with Kubernetes
    clusters and performing various operations. There are two ways to use kubectl
    while managing your cluster - imperative management, which focuses on commands
    rather than the YAML manifests to achieve the desired state, and declarative management,
    which focuses on creating and updating YAML manifest files. kubectl can support
    both these management techniques to manage Kubernetes API objects (also called
    Kubernetes API primitives). In the previous chapter, we saw how the various components
    constantly try to change the state of the cluster from the actual state to the
    desired state. This can be achieved by using kubectl commands or YAML manifests.
  prefs: []
  type: TYPE_NORMAL
- en: kubectl allows you to send commands to Kubernetes clusters. The `kubectl` command
    can be used to deploy applications, inspect, and manage Kubernetes objects, or
    troubleshoot and view logs. Interestingly, even though kubectl is the standard
    tool for controlling and communicating with a Kubernetes cluster, it doesn't come
    with Kubernetes. So, even if you are running kubectl on any of the nodes of your
    cluster, you need to install the kubectl binary separately, which we did in *Exercise
    2.01*, *Getting Started with Minikube and Kubernetes Clusters*, in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will walk you through the behind-the-scenes functionality of kubectl
    and provide more insights into how to use kubectl commands to interact with some
    commonly used Kubernetes objects. We will learn how to set up some shortcuts for
    kubectl. We will walk you through not only creating new objects with kubectl but
    also making changes to a live Deployment in Kubernetes. But before that, let's
    take a peek behind the curtains and get an idea of exactly how kubectl communicates
    with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: How kubectl Communicates with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, the API server manages communications between
    the end-user and Kubernetes, and it also acts as an API gateway to the cluster.
    To achieve this, it implements the RESTful API over the HTTP and HTTPS protocols
    to perform CRUD operations to populate and modify Kubernetes API objects such
    as pods, services, and more based upon the instructions sent by a user via kubectl.
    These instructions can be in various forms. For example, to retrieve information
    for pods running in the cluster, we would use the `kubectl get pods` command,
    while to create a new pod, we would use the `kubectl run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at what happens behind the scenes when you run a
    `kubectl` command. Take a look at the following illustration, which provides an
    overview of the process, and then we will take a closer look at the different
    details of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: A representative flowchart for the kubectl utility'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: A representative flowchart for the kubectl utility'
  prefs: []
  type: TYPE_NORMAL
- en: A kubectl command is translated into an API call, which is then sent to the
    API server. The API server then authenticates and validates the requests. Once
    the authentication and validation stages have been successful, the API server
    retrieves and updates data in `etcd` and responds with the requested information.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Environments with Autocompletion and Shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most Linux environments, you can set up autocompletion for kubectl commands
    before you start working with the instructions mentioned in this chapter. Learning
    how autocompletion and shortcuts work in Linux environments will be significantly
    helpful for those who are interested in getting certifications such as **Certified
    Kubernetes Administrator** (**CKA**) and **Certified Kubernetes Application Developer**
    (**CKAD**), which are conferred by the Linux Foundation. We'll learn how to set
    up autocompletion in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Setting up Autocompletion'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will show you how to set up autocompletion and an alias
    for kubectl commands in Bash. This is a useful feature that will help you save
    time and avoid typos. Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the `bash-completion` package, so install it if it is not already
    installed. You can go to the GitHub repository to get installation instructions
    for various platforms, at [https://github.com/scop/bash-completion](https://github.com/scop/bash-completion).
    If you are running Ubuntu 20.04, you can install it via the APT package manager
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to set up autocomplete in Bash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This command, as well as the subsequent commands in this exercise, will not
    show any responses in the terminal upon successful execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make autocomplete persistent in your Bash shell, you can use
    the following command, which will write `kubectl` autocomplete to the `.bashrc`
    file in your current user directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set up an alias for your `kubectl` commands by using the `alias`
    keyword, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you want to set up an alias for some specific commands, you can
    use commands similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the following command to set up the completion of `kubectl`
    commands when you press *Tab*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also to set up autocomplete in `zsh` (an alternative to the Bash shell)
    by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source <(kubectl completion zsh)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo "if [ $commands[kubectl] ]; then source <(kubectl completion zsh); fi"
    >> ~/.zshrc`'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, you will have an autocomplete set up for your Bash
    shell. You can also use aliases such as `k` instead of `kubectl` in your commands.
    However, to avoid confusion and maintain a standardized structure, we will use
    the full commands throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the kubeconfig Configuration File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most enterprise environments, there is generally more than one Kubernetes
    cluster, depending on the strategy of the organization. An administrator, developer,
    or any other role dealing with Kubernetes clusters would need to interact with
    several of those clusters and switch between them to perform different operations
    on different clusters.
  prefs: []
  type: TYPE_NORMAL
- en: A configuration file makes things a lot easier. You can use this file to store
    information about different clusters, users, namespaces, and authentication mechanisms.
    Such configuration files are referred to as **kubeconfig** files. Note that kubeconfig
    is a generic way to refer to kubectl configuration files and that it is not the
    name of the `config` file. kubectl uses such files to store the information needed
    for us to choose a cluster and communicate with its API server.
  prefs: []
  type: TYPE_NORMAL
- en: By default, kubectl looks for the file in the `$HOME/.kube` directory. In most
    scenarios, you can specify a `KUBECONFIG` environment variable or use the `--kubeconfig`
    flag to specify the kubeconfig files. Those files are usually saved in `$HOME/.kube/config`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about how to configure access to multiple clusters by
    setting up the `KUBECONFIG` environment variable and the `--kubeconfig` flag at
    [https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable).
  prefs: []
  type: TYPE_NORMAL
- en: Security contexts are used to define the privilege and access control settings
    for the pods. We will revisit the idea of access control and security in *Chapter
    13*, *Runtime and Network Security in Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the kubeconfig file to understand how this works. You
    can view the kubeconfig file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: The output of kubectl config view command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2: The output of kubectl config view command'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `context` is a set of information that you need to access a cluster. It contains
    the name of the cluster, the user, and the namespace. The `current-context` field
    in *Figure 3.2* shows the current context that you are working with. If you want
    to switch the current context, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we wanted to switch to a context named `minikube`, we would
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Common kubectl Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously described, kubectl is a CLI tool that is used to communicate with
    the Kubernetes API server. kubectl has a lot of useful commands for working with
    Kubernetes. In this section, we're going to walk you through some commonly used
    kubectl commands and shortcuts that are used to manage Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently Used kubectl Commands to Create, Manage, and Delete Kubernetes Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several simple kubectl commands that you will use almost all the
    time. In this section, we will take a look at some of the basic kubectl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get <object>`: You can use this command to get the list of the desired types
    of objects. Using `all` instead of specifying an object type will get the list
    of all kinds of objects. By default, this will get the list of specified object
    types in the default namespace. You can use the `-n` flag to get objects from
    a specific namespace; for example, `kubectl get pod -n mynamespace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describe <object-type> <object-name>`: You can use this command to check all
    the relevant information of a specific object; for example, `kubectl describe
    pod mypod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs <object-name>`: You can use this command to check all the relevant logs
    of a specific object to find out what happened when that object was created; for
    example, `kubectl logs mypod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit <object-type> <object-name>`: You can use this command to edit a specific
    object; for example, `kubectl edit pod mypod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete <object-type> <object-name>`: You can use this command to delete a
    specific object; for example, `kubectl delete pod mypod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create <filename.yaml>`: You can use this command to create a bunch of Kubernetes
    objects that have been defined in the YAML manifest file; for example, `kubectl
    create -f your_spec.yaml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply <filename.yaml>`: You can use this command to create or update a bunch
    of Kubernetes objects that have been defined in the YAML manifest file; for example,
    `kubectl apply -f your_spec.yaml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walkthrough of Some Simple kubectl Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''re going to walk you through some of the commonly used
    kubectl commands. This section is mostly for demonstration purposes, so you may
    not see the exact output that you see in these images. However, this section will
    help you understand how these commands are used. You will use most of them extensively
    in later exercises, as well as throughout this book. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to display nodes, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: The output of kubectl get nodes command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: The output of kubectl get nodes command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we set up aliases in *Exercise 3.01*, *Setting up Autocompletion*, you
    can also get the same result using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to display all current namespaces, you can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get the same result using the following shortened command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check the version of `kubectl`, you can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see some information regarding your current Kubernetes cluster,
    you can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: The output of kubectl cluster-info command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: The output of kubectl cluster-info command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on further with the demonstrations, we will mention a few commands
    that you can use to create a sample application, which we have already provided
    in the GitHub repository for this chapter. Use the following command to fetch
    the YAML specification for all the objects required to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can deploy the `sample-application.yaml` file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can see the following output, this means that the sample application
    has been successfully created in your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have deployed the provided application, if you try any of the
    commands shown later in this section, you will see the various objects, events,
    and so on related to this application. Note that your output may not exactly match
    the images shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to get everything in your cluster under the
    `default` namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The output of kubectl get all command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: The output of kubectl get all command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events describe what has happened so far in the Kubernetes cluster, and you
    can use events to get a better insight into your cluster and aid in any troubleshooting
    efforts. To list all the events in the default namespace, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The output of kubectl get events command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: The output of kubectl get events command'
  prefs: []
  type: TYPE_NORMAL
- en: 'A service is an abstraction that''s used to expose an application to the end-user.
    You will learn more about services in *Chapter 8*, *Service Discovery*. You can
    use the following command to list all services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: The output of kubectl get services command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: The output of kubectl get services command'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the same result using the following shortened command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A Deployment is an API object that allows us to easily manage and update pods.
    You will learn more about Deployments in *Chapter 7*, *Kubernetes Controllers*.
    You can get the list of Deployments using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get the same result using the following shortened version of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Some Useful Flags for the get Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you have seen, the `get` command is a pretty standard command that is used
    when we need to get the list of objects in our cluster. It also has several useful
    flags. Let''s take a look at a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to list a particular type of resource from all your namespaces,
    you can add the `--all-namespaces` flag in the command. For example, if we want
    to list all Deployments from all namespaces, we can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: The output of kubectl get deployments under all namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.8: The output of kubectl get deployments under all namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that there is an additional column on the left-hand side that
    specifies the namespaces of the respective Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to list a specific type of resource from a specific namespace,
    you can use the `-n` flag. Here, the `-n` flag stands for `namespace`. For example,
    if you want to list all Deployments in a namespace called `keda`, the following
    command would be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command would show an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: The output of kubectl get deployments under the keda namespace'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: The output of kubectl get deployments under the keda namespace'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the `--show-labels` flag to display the labels of the objects in
    the list. For example, if you wanted to get the list of all the pods in the `default`
    namespace, along with their labels, you would use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: The output of kubectl get pods with all labels'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.10: The output of kubectl get pods with all labels'
  prefs: []
  type: TYPE_NORMAL
- en: There is an additional column on the right-hand side that specifies the labels
    of the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-o wide` flag to display more information about objects. Here,
    the `-o` flag stands for `output`. Let''s look at a simple example of how to use
    this flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: The output of kubectl get pods with additional information'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: The output of kubectl get pods with additional information'
  prefs: []
  type: TYPE_NORMAL
- en: You can also see there are additional columns on the right-hand side that specify
    which nodes the pods are running on, as well as the internal IP addresses of the
    node. You can find more ways to use the `-o` flag at [https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will limit this section to commands that are commonly used to limit the scope
    of this chapter. You can find a lot more kubectl commands at [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).
  prefs: []
  type: TYPE_NORMAL
- en: Populating Deployments in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Deployment is a convenient way to manage and update
    pods. Defining a Deployment in Kubernetes is an effective and efficient way to
    provide declarative updates for the application running in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a Deployment by using kubectl imperative commands or by using
    declarative YAML manifest files. In the following exercise, we're going to deploy
    an application (we will go with Nginx for this exercise) in Kubernetes and learn
    how to interact with Deployments using kubectl commands, as well as how to modify
    the YAML manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Creating a Deployment'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to create a Deployment in Kubernetes – using the `kubectl
    create`/`run` command and creating a manifest file in YAML format and then using
    the `kubectl apply` command. We can achieve the same goal with those two options.
    Let''s try both and then compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Deployment using the following command directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can expect an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a Deployment using the `kubectl run` command. To achieve
    the same results here, you could use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl run nginx --image=nginx:1.7.8`'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl run nginx --image=nginx:1.7.8 --replicas=3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a Deployment by defining the YAML manifest file for your
    Deployment. Use your preferred text editor to create a file named `sample-deployment.yaml`
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this YAML definition, the `replicas` field defines the number of replica
    pods in this Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to apply the configuration you''ve defined in the
    YAML manifest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to check the Deployments that currently exist in
    the `default` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have seen the differences in using the different approaches
    to create a Deployment. The `kubectl create` command is widely used for testing.
    For most enterprise solutions where modern DevOps approaches are implemented,
    it makes more sense to use YAML definitions to conveniently define configurations,
    and then track them with source control tools such as Git. When your organization
    integrates YAML definitions with DevOps tools, it makes the solution more manageable
    and traceable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to create a Deployment, in the next exercise, we will
    learn how to modify or update a Deployment that is already running. This is something
    that you will need to do quite often as the software is updated to new versions,
    bugs are identified and fixed, the demands on your application change, or your
    organization moves on to completely new solutions. We will also learn how to roll
    back a Deployment to an earlier version, which is something that you will want
    to do if an update does not lead to the expected outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Updating a Deployment'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will update the application that we deployed in the previous
    exercise to a more recent version and demonstrate how we can roll back the Deployment
    to a previous version if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the two approaches that we saw for creating a Deployment, there
    are two ways to update an application as well – using the `kubectl set image`
    command and updating the YAML manifest file and then using the `kubectl apply`
    command. These steps will guide you through both approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s get the details of the current Deployment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Describing the kubeserve Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12: Describing the kubeserve Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update the image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `image` subcommand indicates that we want to update the `image` field of
    the object, as defined in the YAML manifest that we saw in *Step 2* of the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we specify the object in the `<object-type>/<object name>` format.
  prefs: []
  type: TYPE_NORMAL
- en: The next part, `nginx=nginx:1.9.1`, tells Kubernetes to look for the specific
    image tagged as `1.9.1` in the Docker Hub repository of NGINX. You can check out
    the available tags at [https://hub.docker.com/_/nginx?tab=tags](https://hub.docker.com/_/nginx?tab=tags).
  prefs: []
  type: TYPE_NORMAL
- en: The `--record` flag is very helpful when you want to save the updates that have
    been made by your `kubectl` commands to the current resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying this, you''ll get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get the details of the Deployment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Using the kubectl describe command to check the'
  prefs: []
  type: TYPE_NORMAL
- en: image version in the container
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: Using the kubectl describe command to check the image version
    in the container'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that the image has been successfully
    updated to version `1.9.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to achieve the same result is to modify the YAML file and then
    use the `kubectl apply` command. We will use the same YAML file that we created
    in the previous exercise. If you do not have the YAML file for an object, you
    can export the YAML manifest using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This command will output a file named `kubeserve-spec.yaml` with the manifest
    that is in effect in the cluster. Then, you can use vim, nano, or any other text
    editor to edit it and then apply the edited `kubeserve-spec.yaml` manifest using
    the `kubectl apply` command, as shown in the previous exercise, with the addition
    of the `--record` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to perform a rollback, you can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `kubectl rollout history` command to check all the revisions
    for a specific Deployment, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: The output of the kubectl rollout history command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.14: The output of the kubectl rollout history command'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the following command to check the details of a specific revision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: Checking the details of revision 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.15: Checking the details of revision 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can roll back a Deployment to a specific revision by specifying the `--to-revision`
    flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have learned how to update an already existing Deployment,
    as well as how to roll back a Deployment to its earlier specs.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments allow us to define a desired state for the replica pod in a declarative
    way. We will revisit how Deployment works and discover more about it in *Chapter
    7*, *Kubernetes Controllers*. If you delete the individual pod replica intentionally
    or if the pod fails for any reason, since we define a Deployment with a set number
    of replicas, the Deployment will keep recreating the pod as many times as you
    delete it. This is what we call *auto-healing*. Therefore, you need to delete
    the Deployment itself, which will also delete all the pods managed by it. We will
    learn how to do that in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: Deleting a Deployment'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will delete the Deployment we created in the previous
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a list of existing Deployments using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can expect an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that, for the purpose of this exercise, we want to delete the `kubeserve`
    Deployment that we created in the previous exercise. Use the following command
    to delete the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of Deployments to check and make sure that the target Deployment
    has been deleted successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `kubectl delete` command to delete any other object as well.
    However, as we mentioned earlier, in cases such as pods managed by Deployments,
    it is pointless to delete individual pods as the Deployment will just recreate
    them, so you need to delete the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Editing a Live Deployment for a Real-Life Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are a SysOps engineer who has been asked to manage a cluster
    and deploy a web application. You have deployed it to your Kubernetes cluster
    and made it available to the public. You have been monitoring this application
    ever since it was deployed successfully, and you've detected that the web application
    has been experiencing throttling issues during peak times. Based on your monitoring,
    the solution that you want to implement is to assign more memory and CPU to this
    application. Therefore, you need to edit the Deployment so that you can allocate
    enough CPU and memory resources to run the application and test this application
    at the end. You need to demonstrate that your web application is up and running
    and that it can be accessed through a public IP address via a browser of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this scenario, we're going to deploy a sample application in a Kubernetes
    cluster and show you how to edit a live Deployment. Editing a live Deployment
    is something that you will need to do when fixing issues or for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to get the YAML manifest file that you''re
    going to use in this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This manifest file defines all the different objects that are required to run
    the application, as well as the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This manifest has been adapted from an open-source sample provided by Microsoft
    Azure, available at [https://github.com/Azure-Samples/azure-voting-app-redis](https://github.com/Azure-Samples/azure-voting-app-redis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: First, deploy the target web application using the `kubectl apply` command and
    the provided YAML definition file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the IP address of the service that exposes your application. For this simple
    scenario, this will be similar to *Exercise 2.03, Accessing a Pod via a Service*,
    from the previous chapter. Later chapters will explain how to work with ingress
    controllers and create ingress resources to expose the frontend applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `kubectl edit` command to edit the live deployment. You will need to
    edit the deployment named `melonvote-front`. The following are the fields that
    you need to modify to satisfy the requirements of this scenario. You can simply
    double these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a) `resources.limits.cpu`: This is the resource limit for CPU usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b) `resources.limits.memory`: This is the resource limit for memory usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'c) `resources.requests.cpu`: This is the minimum CPU usage requested to get
    your application up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'd) `resources.requests.memory`: This is the minimum memory usage requested
    to get your application up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this activity, you will be able to see the UI of the application
    that you deployed with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: Expected output of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_03_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.16: Expected output of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demystified how kubectl allows us to control our Kubernetes cluster
    using API calls. First, we learned how to set up an environment for kubectl commands
    and looked at a number of shortcuts. Furthermore, we covered how to create, edit,
    and delete a Kubernetes object using kubectl commands and looked at a Deployment
    as an example. Finally, we deployed a real-life application and showed you how
    to edit a live Deployment. Every example in this chapter has been applied in a
    general context; however, we believe that the skills developed in this chapter
    can help you resolve specific problems that you might encounter in a professional
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll explore the other side of this bridge and dive deeper
    into how the API server works. You will also take a closer look at REST API requests
    and how the API server deals with them.
  prefs: []
  type: TYPE_NORMAL
