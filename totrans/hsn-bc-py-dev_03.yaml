- en: Smart Contract Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the basics of smart contracts. While in Bitcoin we
    store value, in Ethereum we store code. The code that we store in Ethereum is
    called a **smart contract**. A smart contract is a trustless code, meaning the
    integrity of the code is guarded by algorithms and cryptography. We can store,
    the code which is censorship-resistant and is able to avoid third-party interference
    even from the developer of the smart contract. This opens possibilities of creating
    many types of application, such as transparent digital tokens, trustless crowdsale,
    secure voting systems, and autonomous organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing an Ethereum development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a smart contract to Ethereum blockchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why smart contracts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an Ethereum development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to create a smart contract. If you are familiar with Solidity, Truffle,
    Ganache, and the smart contract fundamentals, you can skip ahead to [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml),
    *Implementing Smart Contracts Using Vyper*. Here, we will focus on the content
    of a smart contract created with Solidity. Throughout the remainder of the book,
    we will use the Vyper programming language to develop a smart contract. However,
    we will still use the same development environment (such as Ganache) in the rest
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js is a popular framework for developing web applications, mobile applications,
    and decentralized applications. Head to [https://nodejs.org](https://nodejs.org) and
    download the latest version (which is version 10 at the time of writing). Here
    is how to install Node.js on the Ubuntu Linux platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing Truffle and Solidity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Truffle is a development framework for developing a smart contract with Solidity.
    You can create one without Truffle, but Truffle makes it easier. Without Truffle,
    you can still write a smart contract, but to compile it, you have to launch the
    Solidity compiler with certain flags. Then, in order to deploy this smart contract
    to the blockchain, you have to create a script to send the bytecode to the blockchain.
    With Truffle, in order to compile, you call the, `truffle compile` command, and
    to deploy a smart contract to the blockchain, you call the `truffle migrate` command after
    writing a simple migration script. Truffle also provides you with a tool for interacting
    with the smart contract in the blockchain network. It has everything you need
    to develop a smart contract. As stated previously, however, we will not be using
    this framework in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start by installing Truffle using the Node.js package manager.
    In Ubuntu Linux, in order to install Truffle globally, we have to use `sudo`.
    As described in the previous paragraph, Truffle is a smart contract development
    framework containing many tools, including a console application to interact with
    the blockchain network and the development blockchain software. On top of that,
    with Truffle, you get the Solidity compiler as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, you need to make sure `npm` installs software globally in your home
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then append this line to the `~/.` profile file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open a new Terminal so that the new profile file takes effect or, alternatively,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can install Truffle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing Ganache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For developing a smart contract, people usually use Ganache. Ganache is a private,
    developmental Ethereum network that you can only use in the Ethereum development
    phase. The Truffle framework already includes the Ethereum blockchain network,
    which has the same purpose as Ganache. The difference between the two is that
    Ganache has a frontend GUI and a more user-friendly interface.
  prefs: []
  type: TYPE_NORMAL
- en: When you launch Ganache, you are equipped with 10 accounts, each filled with
    100 ethers, which is the currency in Ethereum blockchain. As you will see later
    in this chapter, the concept of money (such as holding, sending, and receiving
    money, and tracking the balance) in Ethereum programming is important. You need
    to spend money in order to launch a smart contract in Ethereum blockchain. You
    can send money from an account to a smart contract, and a smart contract can,
    in turn, send money to other smart contracts or other accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the software, go to the Ganache website: [https://www.truffleframework.com/ganache](https://www.truffleframework.com/ganache).
    For the Linux platform, the software is called `ganache-1.2.3-x86_64.AppImage`.
    After downloading this, you must set the correct permission before executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Writing a smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once all the requisite software is installed, we can start writing a smart
    contract. First, we will create a new directory, and then initialize it with the
    Truffle development tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `truffle init` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/202a3701-b8b7-47b3-a95b-fab264f8184b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will command Truffle to initialize your directory to be a smart contract
    development project. A couple of directories are  available to you when developing
    a smart contract in this project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You usually incorporate a smart contract''s source code in the `contracts`
    folder. The `migrations` folder holds the files that are used in the deployment
    of smart contracts, and the `test` folder holds the `test` files. You can configure
    the smart contract deployment settings in the `truffle-config.js` file. We will
    create the first smart contract and name it `donation.sol` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you are new to smart contracts, there may be some unfamiliar keywords in
    the preceding example. In this chapter, we are not going to discuss everything
    to do with Solidity. Instead, we will only look into the features of Solidity that
    are necessary for building a smart contract and learning the concept of a smart
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s compile this smart contract written in Solidity to Ethereum
    bytecode and an **application binary interface** (**abi**). To do this, we will
    run the following command in the Truffle project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the compilation can be seen in the `build/contracts` folder,
    named `Donation.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aed6a174-e62d-4c2d-a347-0508e66beca9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open the file, you can see a number of interesting things. This `.json`
    file is 1,530 lines long. The `json` object in this file has 14 keys. You only
    need to think about two keys for now. The first one is the interface (called **abi**),
    and the second one is the binary that can be executed on the Ethereum Virtual
    Machine (called `bytecode`). Refer to the code file in the following GitLab link
    for the code in this section: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_02/my_first_smart_contract/build/contracts/Donation.json](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_02/my_first_smart_contract/build/contracts/Donation.json).'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot run this binary file in the same way as when we compile the C code
    and execute the binary directly. We need to put this binary into the Ethereum
    virtual machine. The interface itself is needed for us to interact with the smart
    contract later when we develop a decentralized application. When you deploy a
    smart contract to Ethereum blockchain, you need the bytecode. When you want to
    interact with a smart contract already deployed in Ethereum blockchain, you need
    the `abi` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a smart contract to Ethereum blockchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the steps for deploying a smart contract to Ethereum blockchain with
    Truffle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write a migration script**: To deploy your smart contract, you need to write
    a migration file. Create a new file named `migrations/2_deploy_donation.js`. Then,
    we fill this file with the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As for the `migrations/1_initial_migration.js` and `contracts/Migrations.sol`
    files, we leave these as they are for now. Truffle needs these files in order
    to deploy a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: '**Launch Ganache (the blockchain for Ethereum development)**: Now you need
    to launch Ganache. Assuming you have been given proper permission, run the following
    command line to execute the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, you have numerous accounts, each
    with a balance of 100 ethers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9129b722-9460-43c9-93ad-bbfa9c292c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: One thing you will notice from the Ganache screen is the **RPC SERVER**, which
    is located in `http://127.0.0.1:7545`. This is where your Ethereum blockchain
    is located in the `Truffle` project directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit the Truffle configuration file**: If you open `truffle-config.js`, the
    code will look like this after removing the comment lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Wipe it out and add the following lines of code to the `truffle-config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `host` and `port` is taken from the RPC server in the Ganache screen, and `network_id`
    is taken from Network ID in the Ganache screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute migration scripts**: To deploy your smart contract, you can execute
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Truffle framework will take your bytecode defined in the `Donation.json`
    file and send it to Ethereum blockchain or Ganache. This will provide you with the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8023d5f-9bd7-4b2e-8de1-993ba598f9d2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `2_deploy_donation.js` section, take note of the hexadecimal number after
    the word `contract address:`, which is `0x3e9417399786347b6ab38f59d3f00829d6bba7b8`.
    This is the smart contract's address, which is similar to the URL of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `Network is up to date.` was output when you tried to deploy your smart
    contract, you can delete the files inside the `build/contracts` directory and
    run this version using the `truffle migrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will take a look at the changes on the Ganache screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/facfd816-d857-4d72-bb6a-7a2b869cfaa9.png)'
  prefs: []
  type: TYPE_IMG
- en: The most important thing to note is that the first account, `0xb105F01Ce341Ef9282dc2201BDfdA2c26903da77`,
    has lost money. The balance is no longer 100 ETH; it is `**99.98 ETH**`. So where
    did the 0.02 ETH go? Miners need to be incentivized in order to write your smart
    contract into the Ethereum blockchain. Note that, the CURRENT BLOCK is no longer
    0, but 4. So, 0.02 ETH will be the fee for the miner who successfully puts the
    block containing your smart contract into the blockchain. But, of course, in this
    case, there is no miner because we use Ganache, the Ethereum development blockchain.
    Ganache just simulates the transaction fee by incorporating a smart contract into
    the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the TRANSACTIONS tab, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7859d31-c0b3-470b-991e-62c54f907791.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now created two contracts (Donation and Migrations). Once a smart contract
    is deployed, unless you apply a method to shut it down, it will be in the blockchain
    forever. If there is a bug in your smart contract, you cannot patch it. You have
    to deploy a fixed smart contract in a different address.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To interact with your smart contract that resides in Ethereum blockchain, execute
    this command inside your `Truffle` project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `truffle` console prompt, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you are confused about `then`, the Truffle console uses the concept of callback,
    on which accessing the smart contract object is executed asynchronously. This
    statement in the Truffle console returns immediately before the callback is being
    executed. In the callback function, you will accept the smart contract instance
    as an `instance` parameter. Then, we can access our `useless_variable` variable
    from this `instance` parameter. Then, to retrieve the value, we have to execute
    the `call` method on that variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Truffle framework would use the **abi** defined in the `Donation.json` file
    to understand what interfaces are available in your smart contract. Recall that
    you define the `useless_variable` in your smart contract and set it to `Donation
    string` in the constructor (or initialization) function. It is free to read a
    public variable in this way; it does not cost any ether because it is stored in
    blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Let me remind you what it means if the variable is stored in blockchain. If
    you incorporate this smart contract in the Ethereum production blockchain, the
    `useless_variable` variable will be stored in every Ethereum node. At the time
    of writing, there are around 10,000 nodes. This number keeps changing, as can
    be seen here: [https://www.ethernodes.org](https://www.ethernodes.org). A node
    can be in one computer, and a computer can hold a couple of nodes. However, it
    is most likely that one computer holds only one node because the requirement to
    become the host of a node is pretty high. You need a node if you want to interact
    with the blockchain (there are also other options for this, such as using API
    to interact with someone else's node). For this reason, it is free to read the `useless_variable` variable because
    you just read it from your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are confused by this free concept, let''s make it clearer by changing
    the `useless_variable` variable into something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a5802f8-3250-4dd9-9968-83361f3674a0.png)'
  prefs: []
  type: TYPE_IMG
- en: There is another cryptic hexadecimal number after the word `from`, which is
    `0xb105F01Ce341Ef9282dc2201BDfdA2c26903da77`. This is the public address of the
    first account in Ganache. You can confirm it by looking at the Ganache screen.
    Here, there is a difference in the way you read the `useless_variable` variable and
    set it with different content. Changing the content of the variable requires different
    syntax and, more importantly, an account to use. An account is required because
    you need to spend some money when changing the variable in blockchain. When you
    change the value of this `useless_variable` variable in the smart contract in
    the blockchain, you are basically broadcasting to all Ethereum nodes in the Ethereum
    production blockchain, which has around 10,000 nodes available to update the content
    of `useless_variable`. We are using Ganache, which is an Ethereum development
    blockchain, but in a production setting, you need to sign your transaction to
    change the content of the variable with a private key. A private key's purpose
    is similar to a password on an account, but a private key cannot be changed, while
    you can update your password as many times as you like. If you forget your password,
    you could reset it and click the link in your confirmation email to update it.
    In blockchain, this is not an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check Ganache now, your balance stays the same; only the block number
    increases from 4 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a3a377f-187e-4367-9528-5f01a2fab109.png)'
  prefs: []
  type: TYPE_IMG
- en: This happens because the amount of money required is so small. You can look
    at the output of the command to change the value of `useless_variable` after you
    execute the last command. Look at the gas used field; this is what you spent when
    executing a function in a smart contract. The amount of gas used is 33684, but
    this is in gwei, not in ether. 1 ether is equal to 1,000,000,000 gwei, so it is
    around 0.00003 ether. In this case, the gas is calculated automatically but, later,
    you can set how much gas you want to allocate when executing any function in Ethereum
    blockchain. If you do not contribute much ether, and the amount of gas allocated
    is small, there is a big chance your execution will be accorded lower priority.
    It will take longer for the transaction to be confirmed (meaning the value of
    the variable has been changed). It could get rejected by miners if the network
    is experiencing heavy traffic.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of spending money to change the state of the program is new. Reading
    everything from blockchain is free because all the data is in your computer (if
    you have Ethereum node), but to change or add something in blockchain requires
    money. This occurs because you change the data in all Ethereum nodes across the
    globe, which is expensive! As well as changing the state of the smart contract,
    computation that runs in memory also requires money.
  prefs: []
  type: TYPE_NORMAL
- en: Sending ether to smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s send some ether to the smart contract. Let''s use the second account
    for this. The second account wants to donate 5 ether using a smart contract as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03e4020c-2b26-49aa-9941-9a3c98ea3560.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As well as the `from` field, you need to add a `value` field. In this `value`
    field, you input how much money you want to send to the smart contract. You may
    wonder why this number has so many zeros. When you transfer money in Ethereum
    blockchain, you must use the lowest currency unit (similarly to converting from
    dollars to cents), which is called **wei**. 1 ether is 1,000,000,000,000,000,000
    wei (18 zeros). You want to send 5 ether, making it 5,000,000,000,000,000,000\.
    Now, if you look at your Ganache screen, you will notice that the balance drops
    to 95 ether. So 5 ether is now held in the smart contract, as demonstrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c1a0285-8d53-4522-8195-738bab39d794.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s withdraw this using the first account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be564c8f-f969-4437-8088-fa8daea2f341.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This execution has the same syntax as before, minus the `value` field. Now
    take a look at the Ganache screen. The first account has between 104 and 105 ether
    (such as 104.8 or 104.9 ether). It is not 105 ether because we already outlaid
    some money launching the smart contract using the first account, and for paying
    the transaction fee when executing some functions in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3583e93d-eaa1-4a9a-ad0c-b78642425f6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Why smart contracts?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now seen a smart contract in action. So what is all the fuss about?
    What can smart contracts do that traditional programs (normal web applications)
    can't? When it comes to changing the value of a variable in a program that lives
    on the network, we can use remote procedure call. More commonly, we can store
    a variable in a database and people can change the value in the database from
    a web application. When sending money, we can integrate our web application with
    Stripe or PayPal, giving us the means to send money. Alternatively, you could
    create a table in a database for storing digital money. Ether in Ethereum is basically
    digital money. In fact, a normal web application can do everything a smart contract
    can do, but faster and cheaper. The key difference is that blockchain solutions
    can be trustless. This means that you can put trust in the program itself, but
    not the operator.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal web application, we rely on trusting the operators (developers or
    system administrators) of the web application. We hope that they develop and deploy
    the web application honestly. There is no way for us, as a user of the web application,
    to make sure the web application does what it tells everyone it is trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have a web application that hosts videos (such as YouTube or Vimeo).
    The web application can increase the number of likes on a video if a user clicks
    the Like button. The rule is that a user can only like a video once. Consequently,
    you would expect a video that contains 400 likes to have 400 users who have liked
    that video. What if I tell you that behind the scenes, a system administrator
    can increase the number of likes artificially? This means that among 400 likes,
    it could be that only 300 likes come from genuine users. The other 100 likes are
    inflated by the system administrator. It does not have to be as raw as updating
    a table in a database directly, for example, through `UPDATE video_likes SET likes_amount
    = 400 WHERE video_id = 5;`. The way to inflate the number of likes could be embedded
    inside the system.
  prefs: []
  type: TYPE_NORMAL
- en: Normal users would not notice this. The company behind the web application could
    publish the source code on GitHub. But how do you make sure the web application
    is indeed built from the source code hosted on GitHub? What if, after deploying
    the web application, the system administrator or the developer patches the system?
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to prevent this digital cheating. First of all, we
    can introduce an IT auditor. These could be from governmental or non-governmental
    organizations. They will audit the source code of the system and, more importantly,
    check what the code does in the production system. In this situation, you move
    your trust from the developers or system administrators to third-party auditors.
  prefs: []
  type: TYPE_NORMAL
- en: As an IT consultant, I make a livelihood by building web applications and mobile
    applications. I once encountered a prospective client who wanted to make a digital
    newspaper (along the lines of the Guardian or the New York Times). This client
    asked me whether there is a way to move any article into the most viewed articles
    section as desired. The motive here was to promote specific articles, even if
    it meant that the system would be lying to users about what the most frequently
    viewed articles are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CEO of Reddit recently issued a public apology for being caught modifying
    comments made about him on the website. More information on this is provided at
    the following link: [https://techcrunch.com/2016/11/23/reddit-huffman-trump/](https://techcrunch.com/2016/11/23/reddit-huffman-trump/)[.](https://techcrunch.com/2016/11/23/reddit-huffman-trump/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even well-known websites play with digital cheating. For instance, some cryptocurrency
    exchanges fake trading volumes. More information is provided on this at the following
    link: [https://medium.com/@sylvainartplayribes/chasing-fake-volume-a-crypto-plague-ea1a3c1e0b5e](https://medium.com/@sylvainartplayribes/chasing-fake-volume-a-crypto-plague-ea1a3c1e0b5e).'
  prefs: []
  type: TYPE_NORMAL
- en: Smart contracts are another means of preventing digital cheating. A developer
    of a smart contract could publish the source code and deploy the smart contract
    into Ethereum blockchain. People can verify whether the source code being published
    and the smart contract being deployed are one and the same. A developer could
    create a method to cheat inside the smart contract, but this will be caught by
    users because they could reconstruct the source code of the smart contract from
    the smart contract's bytecode in the blockchain. A developer could not patch the
    smart contract that is already being deployed.
  prefs: []
  type: TYPE_NORMAL
- en: There are other smart contract properties, such as autonomy and censorship resistance.
    However, none of these properties beat its transparency. Alternatively, you must
    have greater power than all 10,000 nodes working together to protect the credibility
    of the Ethereum system. To make the math simple, you need to buy more than 5,000
    computers with high-end GPUs. Let's say you have that amount of resources in order
    to cheat. Honest miners will be alarmed when you cheat in the Ethereum system,
    and they will make a noise on the internet. So if you have the means to cheat
    in Ethereum, you cannot do it sneakily. Furthermore, if you have the means to
    obtain 5,000 computers with high-end GPUs, you could become a miner in the Ethereum
    platform and generate a nice income. Consequently, it is very hard to cheat in
    the Ethereum platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored how to install Solidity development tools: Node.js,
    Truffle, or Ganache. We then learned how to write a smart contract and compile
    it. After that, we looked at the concept of deploying a smart contract to Ethereum
    blockchain, followed by interacting with a smart contract being deployed with
    the Truffle console tool. We gained an understanding of the concept of sending
    ether to a smart contract and gas usage when executing a function in a smart contract.
    In the last step, we familiarized ourselves with why the smart concept works so
    well, with the potential to create a program that is censorship-resistant and
    transparent, and that cannot be circumvented.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to implement smart contracts using Vyper.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ethereum yellow paper: [https://ethereum.github.io/yellowpaper/paper.pdf](https://ethereum.github.io/yellowpaper/paper.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethereum white paper: [https://github.com/ethereum/wiki/wiki/White-Paper](https://github.com/ethereum/wiki/wiki/White-Paper)'
  prefs: []
  type: TYPE_NORMAL
