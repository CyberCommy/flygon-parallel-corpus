- en: Chapter 4. Consolidate Classes and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an autoloader in place, we can begin to remove all the `include`
    calls that only load up class and function definitions. When we are done, the
    only remaining `include` calls will be those that are executing logic. This will
    make it easier to see which `include` calls are forming the logic paths in our
    legacy application, and which are merely providing definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a scenario where the codebase is structured relatively well.
    Afterwards, we will answer some questions related to layouts that are not so amenable
    to revision.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will use the term `include` to cover not
    just `include` but also `require`, `include_once`, and `require_once`.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidate Class Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will consolidate all the application classes to our central directory
    location as determined in the previous chapter. Doing so will put them where our
    autoloader can find them. Here is the general process we will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Find an `include` statement that pulls in a class definition file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move that class definition file to our central class directory location, making
    sure that it is placed in a sub-path matching the PSR-0 rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the original file *and in all other files in the codebase* where an `include`
    pulls in that class definition, remove that `include` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check to make sure that all the files now autoload that class by browsing
    to them or otherwise running them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until there are no more `include` calls that pull in class definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our examples, we will assume we have a legacy application with this partial
    file system layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your own legacy application may not match this exactly, but you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Find a candidate include
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by picking a file, any file, then we examine it for `include` calls.
    The code therein might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there is a new `User` class being instantiated. On inspecting
    the `lib/sub/User.php` file, we can see it is the only class defined therein.
  prefs: []
  type: TYPE_NORMAL
- en: Move the class file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having identified an `include` statement that loads a class definition, we
    now move that class definition file to the central class directory location so
    that our autoloader function can find it. The resulting file system layout now
    looks like this (note that `User.php` is now in `classes/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remove the related include calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now the problem is that our original file is trying to `include` the class
    file from its old location, a location that no longer exists. We need to remove
    that call from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, there are likely to be other places where the code attempts to load
    the now-missing `lib/sub/User.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: This is where a project-wide search facility comes in handy. We have different
    options here, depending on your editor/IDE of choice and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In GUI editors like TextMate, SublimeText, and PHPStorm, there is usually a
    **Find in Project** menu item that we can use to search for a string or regular
    expression across all the application files at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other editors like Emacs and Vim, there is generally a key-binding that will
    search all the files in a particular directory and its subdirectories for a string
    or regular expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you are of the old school, you can use `grep` at the command line
    to search all the files in a particular directory and its subdirectories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The point is to find all the `include` calls that refer to `lib/sub/User.php`.
    Because the `include` calls can be formed in different ways, we need to use a
    regular expression like this to search for the `include` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not familiar with regular expressions, here is a breakdown of what
    we are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (Regular expressions use `.` to mean `any character` so we have to specify `User\.php`
    to indicate we mean a literal dot, not any character.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use a regular expression search to find those strings in the legacy codebase,
    we will be presented with a list of all matching lines and their corresponding
    files. Unfortunately, it is up to us to examine each line to see if it really
    is a reference to the `lib/sub/User.php` file. For example, this line might turn
    up in the search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, clearly it is not the `User.php` file we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could be more strict with our regular expression so that we search specifically
    for `lib/sub/User.php` but that is more likely to miss some `include` calls, especially
    those in files under the `lib/` or `sub/` directories. For example, an `include`
    in a file in `sub/` could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As such, it's better to be a little loose with the search to get every possible
    candidate, then work through the results manually.
  prefs: []
  type: TYPE_NORMAL
- en: Examine each search result line, and if it is an `include` that pulls in the
    `User` class, remove it and save the file. Keep a list of each modified file,
    as we will need to test them later.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this, we will have removed all the `include` calls for that class
    throughout the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check the codebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After removing the `include` statements for the given class, we now need to
    make sure the application works. Unfortunately, because we have no testing process
    in place, this means we need to pseudo-test or spot check by browsing to or otherwise
    invoking the modified files. In practice this is generally not difficult, but
    it is tedious.
  prefs: []
  type: TYPE_NORMAL
- en: When we spot check we are looking specifically for *file not found* and *class
    not defined* errors. These mean, respectively, that a file tried to `include`
    the missing class file, or that the autoloader failed to find the class file.
  prefs: []
  type: TYPE_NORMAL
- en: To do the testing we need to set PHP error reporting so that it either shows
    us the errors directly, or logs the errors to a file that we examine while testing
    the codebase. In addition, the error reporting level needs to be sufficiently
    strict that we actually see the errors. In general, `error_reporting(E_ALL)` is
    what we want, but because this is a legacy codebase, it may show more errors than
    we can bear (especially *variable not defined* notices). As such, it may be more
    productive to set `error_reporting(E_WARNING)`. The error reporting values can
    be set either in a setup or bootstrap file, or in the correct `php.ini` file.
  prefs: []
  type: TYPE_NORMAL
- en: Commit, Push, Notify QA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the testing is complete and all errors have been fixed, commit the code
    to source control and (if needed) push it to the central code repository. If you
    have a QA team, now would be the time to notify them that a new testing round
    is needed, and provide them the list of files to test.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is the process to convert a single class from `include` to autoloading.
    Go back through the codebase and find the next `include` that pulls in a class
    file and begin the process again. Continue doing so until all classes have been
    consolidated into the central class directory location and their relevant `include`
    lines have been removed. Yes, this is a tedious, tiresome, and time-consuming
    process, but it is a necessary step towards modernizing our legacy codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidate functions into class files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all legacy applications use a large set of classes. Often, instead of classes,
    there is a significant number of user-defined functions for core logic.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions is not a problem in itself, but it does mean that we need to
    `include` the files where the functions are defined. But autoloading only works
    for classes. It would be good to find a way to automatically load the function
    files as well as the class files. That would help us remove even more `include`
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is to move the functions into class files, and call the functions
    as static methods on those classes. That way, the autoloader can load up the class
    file for us, and then we can call the methods in that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This procedure is more complex than when we consolidated class files. Here
    is the general process we will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Find an `include` statement that pulls in a function definition file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert that function definition file into a class file of static methods; we
    need to pick a unique name for the class, and we may need to rename the functions
    to more suitable method names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the original file *and in all other files in the codebase* where any functions
    from that file are used, change calls to those functions into static method calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check to see if the new static method calls work by browsing to or otherwise
    invoking the affected files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the class file to the central class directory location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the original file *and in all other files in the codebase* where an `include`
    pulls in that class definition, remove the relevant `include` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check again to make sure that all the files now autoload that class by
    browsing to them or otherwise running them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until there are no more `include` calls that pull in function definition
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a candidate include
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We pick a file, any file, and look through it for `include` calls. The code
    in our chosen file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there is a `db_query()` function being used, and on inspecting
    the `includes/db_functions.php` file, we can see that function along with several
    others defined therein.
  prefs: []
  type: TYPE_NORMAL
- en: Convert the function file to a class file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that the `db_functions.php` file looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To convert this function file to a class file, we need to pick a unique name
    for the class we're about to create. It seems pretty clear in this case, both
    from the file name and from the function names, that these are all database-related
    calls. As such, we'll call this class Db.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a name, we'll create the class. The functions will become static
    methods in the class. We are not going to move the file just yet; leave it in
    place with its current file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we make our changes to convert the file to a class definition. If we change
    function names, we need to keep a list of old and the new names for later use.
    After the changes, it will look something like the following (note the changed
    method names):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes are very moderate: we wrapped the functions in a unique class name,
    marked them as `public static`, and made minor changes to the function names.
    We made no changes at all to the function signatures or code in the functions
    themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Change function calls to static method calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have converted the contents of `db_functions.php` from function definitions
    to a class definition. If we try to run the application now, it will fail with
    "undefined function" errors. So, the next step is to find all of the relevant
    function calls throughout the application and rename them to static method calls
    on our new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no easy way to do this. This is another case where project-wide search-and-replace
    becomes very handy. Using our preferred project-wide search tool, search for the
    `old` function call, and replace it with the `new` static method call. For example,
    using a regular expression, we might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression indicates the opening parenthesis, not the closing one,
    as we don't need to look for parameters in the function call. This helps to distinguish
    from function names that might be prefixed with the function name we're searching
    for, such as `db_query_raw()`. The regular expression also allows for optional
    whitespace between the function name and the opening parenthesis, since some style
    guides recommend such spacing.
  prefs: []
  type: TYPE_NORMAL
- en: Perform this search-and-replace for each of the `old` function names in the
    old function file, converting each to the `new` static method call in the new
    class file.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check the static method calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are finished renaming the old function names to the new static method
    calls, we need to run through the codebase to make sure everything works. Again,
    there is no easy way to do this. You may need to go so far as browsing to, or
    otherwise invoking, each file that was changed in this process.
  prefs: []
  type: TYPE_NORMAL
- en: Move the class file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point we have replaced the contents of the function definition file
    with a class definition, and "testing" has showed that the new static method calls
    work as expected. Now we need to move the file to our central class directory
    location and name it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our class definition is in the `includes/db_functions.php` file.
    The class in that file is named `Db`, so move the file to its new autoloadable
    location as `classes/Db.php`. Afterwards, the file system will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Do ... While
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we follow the same ending process as we did when moving class files:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the related `include` calls for the function definition file throughout
    the codebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spot check the codebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit, push, notify QA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now repeat it for every function definition file we find in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Should we remove the autoloader include call?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we placed our autoloader code in a class as a static or instance method,
    our search for `include` calls will reveal the inclusion of that class file. If
    you remove that `include` call, autoloading will fail, because the class file
    will not have been loaded. This is a chicken-and-egg problem. The solution is
    to leave the autoloader `include` in place as part of our bootstrapping or setup
    code. If we are fully diligent about removing `include` calls, that is likely
    to be the only `include` remaining in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: How should we pick files for candidate include calls?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to go about this. We could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can manually traverse the entire codebase and work file-by-file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can generate a list of class and function definition files, and then generate
    a list of files that `include` those files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can search for every `include` call and look at the related file to see if
    it has class or function definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if an include defines more than one class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometime a class definition file may have more than one class definition in
    it. This can mess with the autoloading process. If a file named `Foo.php` defines
    both `Foo` and `Bar` classes, then the `Bar` class will never be autoloaded, because
    the file name is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to split the single file into multiple files. That is, create
    one file per class, and name each file for the class it contains per the PSR-0
    naming and autoloading expectations.
  prefs: []
  type: TYPE_NORMAL
- en: What if the one-class-per-file rule is disagreeable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I sometimes hear complaints about how the one-class-per-file rules is somehow
    wasteful or otherwise not aesthetically pleasing when examining the file system.
    Isn''t it a drag on performance to load that many files? What if some classes
    are only needed along with some other class, such as an `Exception` that is only
    used in one place? I have some responses here:'
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a performance reduction in loading two files instead of
    one. The question is *how much* of a reduction, and *compared to what*? I assert
    that, compared to the other more likely performance issues in our legacy application,
    the drag from loading multiple files is a rounding error. It is more likely that
    we have other, far greater performance concerns. If it really is a problem, using
    a bytecode cache like APC will reduce or completely remove these comparatively
    small performance hits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency, consistency, consistency. If some of the time a class file has
    only one class in it, and at other times a class file has more than one class
    in it, that inconsistency will later become a source of cognitive friction for
    everyone on the project. One of the main themes through legacy applications is
    that of inconsistency; let us reduce that inconsistency as much as we can by adhering
    to the one-class-per-file rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we feel that some classes naturally belong together, it is perfectly acceptable
    to place the subordinate or child classes in a subdirectory beneath the master
    or parent class. The subdirectory should be named for that higher class or namespace,
    per the PSR-0 naming rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a series of `Exception` classes related to a `Foo`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Renaming classes in this way will change the related class names throughout
    the codebase where they are instantiated or otherwise referenced.
  prefs: []
  type: TYPE_NORMAL
- en: What if a Class or Function is defined inline?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have seen cases where a page script has one or more classes or functions defined
    inside it, generally when the classes or functions are used only by that particular
    page script.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, remove the class definitions from the script and place them
    in their own files in the central class directory location. Be sure to name the
    files for their class names per the PSR-0 autoloader rules. Similarly, move the
    function definitions to their own related class file as static methods, and rename
    the function calls to static method calls.
  prefs: []
  type: TYPE_NORMAL
- en: What if a definition file also executes logic?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I have also seen the opposite case, where a class file has some logic that
    gets executed as a result of the file being loaded. For example, a class definition
    file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the above case, the logic before the class definition will be executed when
    the file is loaded, even if the class is never instantiated or otherwise called.
  prefs: []
  type: TYPE_NORMAL
- en: This is a much tougher situation to deal with than when classes are defined
    inline with a page script. The class should be loadable without side effects,
    and the other logic should be executable without having to load the class.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the easiest way to deal with this is to modify our relocation process.
    Cut the class definition from the original file and place it in its own file in
    the central class directory location. Leave the original file with its executable
    code in place, and leave all the related `include` calls in place as well. This
    allows us to pull out the class definition so it can be autoloaded, but scripts
    that `include` the original file still get the executable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the above combined executable code and class definition,
    we could end up with these two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is messy, but it preserves the existing application behavior while allowing
    for autoloading.
  prefs: []
  type: TYPE_NORMAL
- en: What if two classes have the same name?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we start moving classes around, we may discover that `application flow
    A` uses a `Foo` class, and that `application flow B` also uses a `Foo` class,
    but the two classes of the same name are actually different classes defined in
    different files. They never conflict with each other because the two different
    application flows never intersect.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have to rename one or both of the classes when we move them
    to our central class directory location. For example, call one of them `FooOne`
    and the other `FooTwo`, or pick better descriptive names of your own. Place them
    each in separate class files named for their class names, per the PSR-0 autoloading
    rules, and rename all references to these classes throughout the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: What about third-party libraries?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we consolidate our classes and functions, we may find some third-party
    libraries in the legacy application. We don't want to move or rename the classes
    and functions in a third-party library, because that would make it too difficult
    to upgrade the library later. We would have to remember what classes were moved
    where and which functions were renamed to what.
  prefs: []
  type: TYPE_NORMAL
- en: With any luck, the third-party library uses autoloading of some sort already.
    If it comes with its own autoloader, we can add that autoloader to the SPL autoloader
    registry stack in our setup or bootstrap code. If its autoloading is managed by
    another autoloader system, such as that found in Composer, we can add *that* autoloader
    to the SPL autoloader registry stack, again in our setup or bootstrap code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the third-party library does not use autoloading, and depends on `include`
    calls both in its own code and in the legacy application, we are in a bit of a
    bind. We don''t want to modify the code in the library, but at the same time we
    want to remove `include` calls from the legacy application. The two solutions
    here are *least-worst* options:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify our application's main autoloader to allow for one or more third party
    libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write an additional autoloader for the third-party library and add it to the
    SPL autoloader registry stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these options are beyond the scope of this book. You will need to examine
    the library in question, determine its class naming scheme, and come up with appropriate
    autoloader code on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in terms of how to organize third-party libraries in the legacy application,
    it might be wise to consolidate them all to their own central location in the
    codebase. For example, this might be under a directory called `3rdparty/` or `external_libs/`.
    If we move a library, we should move the entire package, not just its class files,
    so we can upgrade it properly later. This will also allow us to exclude the central
    third-party directory from our search for `include` calls so that we don't get
    extra search results from files that we don't want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: What about system-wide libraries?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System-wide library collections, like those provided by Horde and PEAR, are
    a special case of third-party libraries. They are generally located on the server
    file system *outside* of the legacy application so they can be available to all
    applications running on that server. The `include` statements related to these
    system-wide libraries generally depend on the `include_path` settings, or else
    are referenced by absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: 'These present a special problem when trying to eliminate `include` calls that
    only pull in class and function definitions. If we are lucky enough to be using
    PEAR-installed libraries, we can modify our existing autoloader to look in two
    directories instead of one. This is because the PSR-0 naming conventions rise
    out of the Horde/PEAR conventions. The trailing autoloader code changes from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For functions, can we use instance methods instead of static methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we consolidated user-defined global functions into classes, we redefined
    them as static methods. This left their global scope unchanged. If we feel particularly
    diligent, we can change them from static to instance methods. This involves more
    work, but in the end it can make testing easier and is a cleaner technical approach.
    Given our earlier `Db` example, using instance instead of static methods would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The only added step when using instance methods instead of static ones is that
    we need to instantiate the class before calling its methods. That is, instead
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Even though it is more work in the beginning, I recommend instance methods over
    static ones. Among other things, it gives us a constructor method that can be
    called on instantiation, and it makes testing easier in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you like, you may wish to start by converting to static methods, and then
    later convert the static methods to instance methods, along with all the related
    method calls. However, your schedule and preferences will dictate which approach
    you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate this process?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I have noted before, this is a tedious, tiresome, and time-consuming process.
    Depending on the size of the codebase, it may take days or weeks of effort to
    fully consolidate the classes and functions for autoloading. It would be great
    if there was some way to automate the process to make it both faster and more
    reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, I have not yet discovered any tools that make this process easier.
    As far as I can tell, this kind of refactoring is still best done by hand with
    strong attention to detail. Having obsessive tendencies and long periods of uninterrupted
    concentration on this task are likely to be of benefit here.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have made a big step forward in modernizing our legacy application.
    We have begun converting from an *include-oriented* architecture to a *class-oriented*
    one. Even if we later discover a class or function that we missed, that's OK;
    we can follow the above process as many times as needed until all definitions
    have been moved to the central location.
  prefs: []
  type: TYPE_NORMAL
- en: We may still have lots of `include` statements in the application, but those
    that remain are related to the application flow, and not to pulling in class and
    function definitions. Any `include` calls that remain are executing logic. We
    can now see the flow of the application much better.
  prefs: []
  type: TYPE_NORMAL
- en: We have put in place a structure for new functionality. Any time we need to
    add a new behavior, we can place it in a new class, and that class will be autoloaded
    whenever we need it. We can stop writing new stand-alone functions; instead, we
    will write new methods on classes. These new methods will be much more amenable
    to unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: However, the *existing* classes that we have consolidated for autoloading are
    likely to have globals and other dependencies in them. This makes them tightly
    bound to each other and difficult to write tests for. With that in mind, the next
    step is to examine the dependencies in our existing classes, and attempt to break
    those dependencies to improve the maintainability of our application.
  prefs: []
  type: TYPE_NORMAL
