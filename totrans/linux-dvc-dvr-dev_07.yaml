- en: I2C Client Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I2C bus, invented by Philips (now NXP) is a two-wire: **Serial Data** (**SDA**
    ), **Serial Clock** (**SCL** ) asynchronous serial bus. It is a multi-master bus,
    though multi-master mode is not widely used. Both SDA and SCL are open drain/open
    collector, meaning that each of these can drive its output low, but none of these
    can drive its output high without having pull-up resistors. SCL is generated by
    the master in order to synchronize data (carried by SDA) transfer over the bus.
    Both slave and master can send data (not at the same time of course), thus making
    SDA a bidirectional line. That said the SCL signal is also bidirectional, since
    slave can stretch the clock by keeping the SCL line low. The bus is controlled
    by the master, which in our case is a part of the SoC. This bus is frequently
    used in embedded systems to connect serial EEPROM, RTC chips, GPIO expander, temperature
    sensors, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00012.gif)'
  prefs: []
  type: TYPE_IMG
- en: I2C bus and devices
  prefs: []
  type: TYPE_NORMAL
- en: Clock speed varies from 10 KHz to 100 KHz, and 400 KHz to 2 MHz. We will not
    cover bus specifications or bus drivers in this book. However, it is up to the
    bus driver to manage the bus and take care of the specifications. An example of
    a bus driver for the i.MX6 chip can be found at `drivers/i2C/busses/i2c-imx.c`
    in kernel source, and I2C specifications can be found at [http://www.nxp.com/documents/user_manual/UM10204.pdf](http://www.nxp.com/documents/user_manual/UM10204.pdf)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are interested in client drivers, in order to handle slave
    devices seated on the bus. The chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: I2C client driver architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the device, thus reading/writing data from/to device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring clients from DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The driver architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the device for which you write the driver takes a seat on a physical bus
    called the *bus controller* , it must rely on the driver of that bus called the
    *controller driver* , responsible for sharing bus access between devices. The
    controller driver offers an abstraction layer between your device and the bus.
    Whenever you perform a transaction (read or write) on an I2C or USB bus for example,
    the I2C/USB bus controller transparently takes care of that in the background.
    Every bus controller driver exports a set of functions to ease the development
    of drivers for devices sitting on that bus. This works for every physical bus
    (I2C, SPI, USB, PCI, SDIO, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: An I2C driver is represented in the kernel as an instance of `struct i2c_driver`
    . The I2C client (which represents the device itself) is represented by a `struct
    i2c_client` structure.
  prefs: []
  type: TYPE_NORMAL
- en: The i2c_driver structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An I2C driver is declared in kernel as an instance of `struct i2c_driver,`
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `struct i2c_driver` structure contains and characterizes general access
    routines, needed to handle the devices claiming the driver, whereas `struct i2c_client`
    contains device-specific information, like its address. A `struct i2c_client`
    structure represents and characterizes an I2C device. Later in this chapter, we
    will see how to populate these structures.
  prefs: []
  type: TYPE_NORMAL
- en: The probe() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `probe()` function is a part of the `struct i2c_driver` structure, and
    is executed any time once an I2C device is instantiated. It is responsible for
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the device is the one you expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether your I2C bus controller of the SoC supports the functionality
    needed by your device, using the `i2c_check_functionality` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up device specific data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the appropriate kernel framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `probe` function''s prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, its parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct i2c_client` pointer: This represents the I2C device itself. This structure
    inherits from the structure device, and is provided to your `probe` function by
    the kernel. The client structure is defined in `include/linux/i2c.h` . Its definition
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All fields are filled by the kernel, based on the parameter you provided to
    register the client. We will see later how to register a device to the kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct i2c_device_id` pointer: This points to the I2C device ID entry that
    matched the device that is being probed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Per-device data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The I2C core offers you the possibility to store a pointer to any data structure
    of your choice, as device-specific data. To store or retrieve the data, use the
    following function provided by the I2C core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These functions internally call `dev_set_drvdata` and `dev_get_drvdata` to update
    or get the value of the `void *driver_data` field of the `struct device` substructure
    in the `struct i2c_client` structure.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of how to use extra client data; an excerpt from `drivers/gpio/gpio-mc9s08dz60.c:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Actually, these functions are not really specific to I2C. They do nothing but
    get/set the `void *driver_data` pointer that is a member of the `struct device`
    , and itself is a member of `struct i2c_client` . In fact, we could have used
    `dev_get_drvdata` and `dev_set_drvdata` directly. One can see their definitions
    in `linux/include/linux/i2c.h` .
  prefs: []
  type: TYPE_NORMAL
- en: The remove() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prototype of the `remove` function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove()` function also provides the same `struct i2c_client*` as the
    `probe()` function, so you can retrieve your private data. For example, you may
    need to process some cleaning or any other stuff, based on the private data you
    set up in the `probe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `remove` function has the responsibility to unregister us from the subsystem
    where we have registered in the `probe()` function. In the preceding example,
    we simply remove the `gpiochip` from the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Driver initialization and registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When one''s module gets loaded, one may need to do some initializing. Most
    of the time, just registering the driver with the I2C core will be sufficient.
    At the same time, when the module is unloaded, we will usually just need to get
    ourselves out from the I2C core. In [chapter 5](text00146.html) , *Platform Device
    Drivers* we saw that it is not worth while to bother ourselves by using init/exit
    functions, but to use `module_*_driver` functions instead. In this case, the function
    to use is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Driver and device provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in matching mechanisms, we need to provide a `device_id` array
    in order to expose devices that our driver can manage. Since we are talking about
    I2C devices, the structure would be `i2c_device_id` . That array will inform the
    kernel about the devices that we are interested in, in the driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to our I2C device driver; having a look in `include/linux/mod_devicetable.h`
    , you will see how `struct i2c_device_id` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, the `struct i2c_device_id` must be embedded in a `struct i2c_driver`
    . In order to let the I2C core (for module auto-loading) know about devices we
    need to handle, we must use the `MODULE_DEVICE_TABLE` macro. The kernel has to
    be aware of which `probe` or `remove` function to call whenever a match occurs,
    which is why our `probe` and `remove` functions must also be embedded in the same
    `i2c_driver` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serial bus transactions are just a matter of accessing registers to set/get
    their content. I2C respects that principle. I2C core provides two kind of API,
    one for plain I2C communications, and another for SMBUS compatible device, which
    also works with I2C devices, but not the reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Plain I2C communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are essential functions one usually deal with when talking to
    I2C devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost all I2C communication functions take a `struct i2c_client` as the first
    parameter. The second parameter contains the bytes to read or write and the third
    represents the number of bytes to read or write. Like any read/write function,
    the returned value is the number of bytes being read/written. One can also process
    message transfers with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`i2c_transfer` sends a set of messages where each can be either a read or a
    write operation, and can be mixed in any way. Remember that there is no stop bit
    between each transaction. Looking at `include/uapi/linux/i2c.h` , a message structure
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `i2c_msg` structure describes and characterizes an I2C message. It must
    contain, for each message, the client address, the number of bytes of the message,
    and the message payload.
  prefs: []
  type: TYPE_NORMAL
- en: '`msg.len` is a `u16` . It means you must always be less than 2^(16) (64k) with
    your read/write buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us have a look at the `read` function for the microchip I2C 24LC512eeprom
    character driver; we should understand how things really work. The full code is
    provided with the source of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`msg.flags` should be `I2C_M_RD` for a read and `0` for a write transaction.
    Sometimes, you may not want to create `struct i2c_msg` but just process simple
    read and write.'
  prefs: []
  type: TYPE_NORMAL
- en: System Management Bus (SMBus) compatible functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMBus is a two-wire bus developed by Intel, and very similar to I2C. I2C devices
    are SMBus-compatible, but not the reverse. Therefore, it is better to use SMBus
    functions if one has a doubt about the chip one is writing the driver for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows some of the SMBus API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Have a look in `include/linux/i2c.h` and `drivers/i2c/i2c-core.c` in the kernel
    sources for more explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a simple read/write operation in an I2C gpio expander:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating I2C devices in the board configuration file (old and depreciated
    way)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must inform the kernel about which devices are physically present on the
    system. There are two ways to achieve that. In the DT, as we will see later in
    the chapter, or through the board configuration file (which is the old and depreciated
    way). Let us see how to do that in the board configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct i2c_board_info` is the structure used to represent an I2C device on
    our board. The structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once again, elements not relevant for us have been removed from the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding structure, `type` should contain the same value as defined
    in the device driver in the `i2c_driver.driver.name` field. You will then need
    to fill an array of `i2c_board_info` and pass it as a parameter to the `i2c_register_board_info`
    function in the board init routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `busnum` is the bus number the devices sit on. This is an old and depreciated
    method, so I'll not go further into it in this book. Feel free to have a look
    at *Documentation/i2c/instantiating-devices* in the kernel sources to see how
    things are done.
  prefs: []
  type: TYPE_NORMAL
- en: I2C and the device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen in the preceding sections, in order to configure I2C devices,
    there are essentially two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define and register the I2C driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define and register the I2C devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C devices belong to nonmemory mapped devices family in the DT, and I2C bus
    is an addressable bus (by addressable, I mean you can address a specific device
    on the bus). In this, the `reg` property in the device node represents the device
    address on the bus.
  prefs: []
  type: TYPE_NORMAL
- en: I2C device nodes are all children of the bus node they seat on. Each device
    is assigned only an address. There is no length or range involved. Standard properties
    one needs to declare for I2C devices are `reg` , which represents the address
    of the device on the bus, and the `compatible` string, which is used to match
    the device with a driver. For more information on addressing, you can refer to
    [Chapter 6](text00162.html) , *The Concept of Device Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample declares an HDMI EDID chip at address 0x50, on SoC's I2C
    bus number 2, and a **real time clock** (**RTC** ), at address 0x68 on the same
    bus.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and registering the I2C driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have seen so far does not change. The extra thing we need is to define
    a `struct of_device_id` . `Struct of_device_id` defined to match the corresponding
    node in the `.dts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the `i2c_driver` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One can then improve the `probe` function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For kernel versions older than 4.10, if one looks at `drivers/i2c/i2c-core.c`
    , in the `i2c_device_probe()` function (for information, it is the function the
    kernel calls every time an I2C device is registered to the I2C core), one will
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that even if one does not need to use the `.id_table` , it is mandatory
    in the driver. In fact, one can use the OF match style only, but cannot get rid
    of `.id_table` . Kernel developers tried to remove the need for `.id_table` and
    exclusively use `.of_match_table` for device matching. The patch is available
    at this URL: [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, regressions have been found and the commit was reverted. Have
    a look here for details: [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed)
    . This has been fixed since kernel version >= 4.10\. The fix looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In other words, one must define both `.id_table` and `.of_match_table` for the
    I2C driver, otherwise your device will not be probed for kernel version 4.10 or
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating I2C devices in the device tree - the new way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`struct i2c_client` is the structure used to describe the I2C device. However,
    with OF style, this structure could not be defined in the board file anymore.
    The only thing we need to do is provide the device''s information in the DT and
    the kernel will build one from it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can declare our I2C `foobar` device node in
    a `dts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To summarize the steps needed to write I2C client drivers, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare device ids supported by the driver. You can do that using `i2c_device_id`
    . If DT is supported, use `of_device_id` too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `MODULE_DEVICE_TABLE(i2c, my_id_table` to register your device list with
    the I2C core. If device tree is supported, you must call `MODULE_DEVICE_TABLE(of,
    your_of_match_table)` to register your device list with the OF core.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the `probe` and `remove` functions according to their respective prototypes.
    If needed, write power management functions too. The `probe` function must identify
    your device, configure it, define per-device (private) data, and register with
    the appropriate kernel framework. The driver's behavior depends on what you have
    done in the `probe` function. The `remove` function must undo everything you have
    done in the `probe` function (free memory and unregister from any framework).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare and fill a `struct i2c_driver` structure and set the `id_table` field
    with the array of ids you have created. Set `.probe` and `.remove` fields with
    the name of the corresponding function you have written above. In the .`driver`
    substructure, set the `.owner` field to `THIS_MODULE` , set the driver name, and
    finally, set the `.of_match_table` field with the array of `of_device_id` if DT
    is supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `module_i2c_driver` function with your `i2c_driver` structure that
    you just filled above: `module_i2c_driver(serial_eeprom_i2c_driver)` in order
    to register your driver with the kernel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just dealt with I2C device drivers. It is time for you to pick any I2C device
    on the market and write the corresponding driver, with DT support. This chapter
    talked about the kernel I2C core and associated API, including device tree support,
    to give you the necessary skills to talk with I2C devices. You should be able
    to write efficient `probe` functions and register with the kernel I2C core. In
    the next chapter, we will use skills we learned here to develop the SPI device
    driver.
  prefs: []
  type: TYPE_NORMAL
