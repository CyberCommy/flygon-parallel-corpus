- en: Functional JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The future of JavaScript will be functional. Indeed, many changes that were
    brought to the language in the last few years are allowing for easier and more
    efficient implementations when using functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see how JavaScript is increasingly becoming a functional
    language and how this programming paradigm can be a vector for performance. We
    will learn how replacing overly complex code with simplified functional versions
    and how using immutability and tail-call optimization will help make JavaScript
    more efficient in the long run. Thus, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More upcoming JavaScript features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, computer science students are told to keep their functions simple.
    It is often said that one function should correspond to one single action. Indeed,
    the more a function has cyclomatic complexity, the harder it is to reuse, maintain
    and test. The more a function becomes a purely logical being that has no real-world
    roots in a clearly identifiable action, the harder it is to grasp and use in combination
    with other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **functional programming** (**FP**) paradigm pushes this reasoning further
    by considering computational design as being based on mathematical functions and
    the immutability of state and data. FP's guiding principle is that the entire
    computer program should be a single, referentially transparent expression. At
    its core, the concept of FP requires that functions be pure, referentially transparent
    and free of side effects. A function is pure when, given the same input, it always
    returns the same output. It is referentially transparent when its functional expression
    is interchangeable with its corresponding value anywhere inside a computer program.
    It is free of side effects when it does not modify an application's state outside
    of its scope. Thus, for example, modifying a variable that is declared outside
    of its scope or echoing a message to a screen are considered to be functional
    side effects that must be avoided as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a pure function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function is not pure, because there are two side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A referentially transparent function can be replaced, anywhere inside the code,
    with a constant that equals the functional expression''s computed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, this function is not referentially transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Amongst the most notable JavaScript functions that are not referentially transparent
    and that generate side effects, we can mention these: `Date`, `Math.random`, `delete`,
    `Object.assign`, `Array.splice`, `Array.sort`, and `RegExp.exec`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages of keeping functions simple and pure. The most important
    ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: Simpler critical paths, whereby the developer's cognitive burden is reduced
    when trying to maintain or update an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier testing of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free compiler optimizations, whereby a compiler might decide to replace a functional
    expression with its corresponding constant value at compile time, rather than
    computing the function each time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future performance boosts due to runtime optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe multithreading by avoiding race conditions due to application state mutability
    (JavaScript is single threaded for now, but who knows what the future holds)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions as first-class citizens is a principle that states that functions
    should be considered to be just like any other datatype. When this is allowed
    within a language, functions can become higher-order functions whereby any function
    can be received as a parameter and returned as a computational value from any
    other function, just as any other datatype would.
  prefs: []
  type: TYPE_NORMAL
- en: When functions are pure and referentially transparent, they can more easily
    be used as first-class citizen functions. Thus, it becomes easier to combine functions
    together in order to dynamically produce other functions. This is what is known
    as function composition. Currying, by which a new function is dynamically generated
    to translate the evaluation of its single argument to another function with multiple
    arguments, and partial application, by which a new dynamically generated function
    with less arity will fix the number of arguments of another function, are the
    two main ways to combine functions together. As we will see later in this chapter,
    ES2020 is getting ready to introduce these concepts into the JavaScript programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What should we do with input and output, networking, user input and user interfaces
    if they are necessary to avoid all forms of side effects? According to FP principles,
    these interactions with the real world are to be encapsulated inside special data
    structures. Even though the contained value or values remains unknown until runtime,
    these special data structures make it possible to map a function to one or more
    wrapped values (functor), to map a wrapped function to one or more wrapped values
    (applicative) or to map a wrapped function that returns an instance of its own
    data structure type to one or more wrapped values (monad). This way, side effects
    remain segregated from pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important principle of FP is immutability. Modifying state and data
    generates cyclomatic complexity and makes any computer program prone to bugs and
    to inefficiency in general. Indeed, all variables should, in fact, be immutable.
    A variable should never change its value, from the moment it is allocated to memory
    until the moment it is deallocated, in order to avoid changing the state of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since ES6, it is now possible to use the `const` keyword to define a constant
    or immutable variable. Here is an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This added feature now makes it possible to prevent the modifications of variables
    through assignments. This way, it is possible to protect a JavaScript application's
    state from mutation during its entire runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever possible, the developer should always prefer using `const` over `let`
    or `var`. Trying to modify a variable that was declared using the `const` keyword
    will cause the following error (`chap8_js_const_1.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/955b0b5c-7a4f-4818-bc13-9efe8dc21f06.png)Assigning to a constant
    variable causes a ''TypeError'''
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since ES6, JavaScript has made it easier to implement software solutions using
    FP. Many engine optimizations have been added that allow for better performance
    when programming JavaScript according to FP principles. Mapping, filtering, reducing
    and tail-call optimization are some of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map is a higher-order function that allows us to map a callback to each element
    of a collection. It is particularly useful when translating all elements of an
    array from one set of values to another. Here is a simple code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This technique makes it possible to avoid using structural loops as much as
    possible when simply modifying the values of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filter is a higher-order function that allows us to distinguish and keep only
    certain elements of a collection based on a Boolean predicate. Of course, filtering
    is particularly useful when removing certain elements from a collection based
    on a certain condition. Take the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Filtering is a great way to avoid loops and nested conditions in order to extract
    some desired dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reduce is a higher-order function that allows us to combine elements of a collection
    into a single returned value based on a combining function. This technique is
    really useful when dealing with cumulative or concatenated values. In the following
    example, we are calculating the sum of the array’s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another FP technique that we will have a look at is tail-call optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Tail-call optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to better understand what **tail-call optimization** (**TCO**) is,
    we will need to define what it is, understand how it works and learn how to determine
    if a function is tail-called or not.
  prefs: []
  type: TYPE_NORMAL
- en: What is TCO?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tail-calling, or tail recursion, is a functional programming technique by which
    a function calls a subroutine function as its final procedure before returning
    control to its own caller. Direct recursion occurs when a function calls itself
    recursively. Recursion is mutual, or indirect, if a function calls another function
    which, in turn, calls the original function.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for example, when a function tail-calls itself, it stacks itself over
    and over again until a certain condition is met, at which point it will definitely
    return, thus effectively popping the entire call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing tail-calls consists of popping the current function from the call
    stack before performing the tail-call and keeping the current function's caller
    address as the return address for the tail-call. Thus, the memory footprint of
    the stack remains small and stack overflow is in fact avoided altogether.
  prefs: []
  type: TYPE_NORMAL
- en: How TCO works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s compare two stack frames, one without TCO and the other with TCO. Let''s
    have a look at the following code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once allocated to memory, without using TCO, the three stack frames from of
    the previous code would look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6827868d-40db-4ec7-b97b-104901360e92.jpg)A typical last-in, first-out
    (LIFO) call stack'
  prefs: []
  type: TYPE_NORMAL
- en: Once value 6 is assigned to variable `z`, the stack frame is ready to be popped.
    In this case, stack frame **2** is kept entirely in memory only to keep the address
    of `console.log()`. This is where TCO can make a difference. If, before calling
    `b()`, stack frame **2** were to be popped from the stack while keeping the original
    caller's return address intact, only one function would get stacked at any given
    moment at runtime and stack space would be reduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire stack would only count two stack frames no matter how many times
    functions would get tail-called. A tail-called optimized stack would therefore
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6a59afc-3610-47a7-89a4-df099ac36392.png)A tail-call optimized call
    stack'
  prefs: []
  type: TYPE_NORMAL
- en: Some have stated that implementing TCO would be a bad idea in certain JavaScript
    implementations, as doing so would disrupt the actual execution flow of an application,
    make debugging harder and break telemetry software in general. This might be the
    case for certain JavaScript implementations, but it is certainly not true in the
    absolute sense. Technically speaking, implementing TCO might prove to be difficult
    due to technical debt in certain JavaScript implementations, but it is certainly
    not necessary to require a syntactic flag for something that should be implicit
    in any language, especially when using a strict mode flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This being said, not all browsers and JavaScript projects have implemented
    this ES6 feature yet, but it is a question of time before they will have to do
    it and developers should be ready for this major change. Indeed, this change from
    the structural to the functional paradigm will make it possible to make very efficient
    loops using functions rather than well-known loop structures. The main advantages
    of programming according to these new principles will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Greater efficiency by consuming less memory and taking less time to complete
    large-sized loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less cyclomatic complexity and simplified critical paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reduced number of lines of code and less cognitive burden for the developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulated and well-organized code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better tested code in general
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of the time of writing, only Safari 11, iOS 11, Kinoma XS6 and Duktape 2.2
    fully support tail-call optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the two following code examples (`chap8_js_performance_1.html`
    and `chap8_js_performance_2.html`) in order to compare the performance of a traditional
    `for` loop with a tail-call optimized function. Here is the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we benchmark these two scripts, we will notice that there is not that much
    of a difference between the two, except that the one that uses tail-calls can
    be more easily unit tested, has a very simple critical path and could easily be
    memoized as it is still referentially transparent even if not pure for obvious
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results for the first script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e1b8d2e-4d1d-4cf0-8ef9-1be527cdd7c3.png)The results when using
    a structural ''for'' loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, the results of the second script are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb839aba-3e5f-40ce-b355-994e4177fcf7.png)The results when using
    stacked functions that are tail-call optimized'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to have a better grasp of this ES6 feature through a few code
    examples that will allow us to better recognize the different ways in which tail-calls
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing tail-calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, tail-calls occur when a subroutine callee is called
    as the last procedure of the current function. There are many ways in which this
    can happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a ternary operator in the following manner, both the `one()`
    and `two()` functions are tail-calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example is not a tail-call, because the callee is called
    from within the body of the function and could be used to do further computation
    instead of simply being returned to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example where one callee is not in a tail-call position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that the `one()` function can be combined with other computations
    in this context, whereas the `two()` function cannot and its returned value will
    simply be assigned to the `a` constant. The same would apply if we were to use
    logical operators instead of a comma as seen in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with other upcoming JavaScript features.
  prefs: []
  type: TYPE_NORMAL
- en: More upcoming JavaScript features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many other features will soon be added to JavaScript that will push the language
    further down the road of functional and asynchronous programming. Let's have a
    look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Async functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of asynchronous programming, the need for FP will be felt even more
    when generators will be used to do so and when avoiding race conditions will become
    even more important than it is now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, ES2017 introduced `async` / `await` functions. These functions will
    allow us to easily create an `event` loop and make asynchronous I/O calls from
    within the loop in order to obtain non-blocking code. There will be many practical
    applications of this, including the possibility of speeding up web page loading
    times by asynchronously downloading complimentary JavaScript files after rendering
    is completed. Here is a code example using these types of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Async generators and for-await-of loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES2018 defines the specifications for async generators and `for-await-of` loops.
    These features are already available in most browsers and will be of great help
    when programming asynchronously in JavaScript. They will mostly simplify the creation
    of queues and loops when iterating over async requests. Moreover, using async
    iterators, iterables and generators with async calls will be made very easy with
    the use of promises. Here is a simple code example using these new features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Pipeline operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ES2020 proposal is in the works to include more FP concepts such as easy
    function chaining using a pipeline operator. Thus, chaining functions will be
    made much simpler. Instead of doing something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We would only need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very important FP technique is also amongst the ES2020 proposals: partial
    application. As mentioned earlier, this FP technique makes it possible to fix
    a number of arguments to a function by producing a new dynamically generated function
    with less arity. Here is a simple code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The ES2020 proposal suggests that partial application could be performed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we could mention many other FP techniques that could find their way
    into the ES2020 specifications, such as function binding, currying and pattern
    matching, but what one must know is that JavaScript is increasingly becoming a
    functional language and that many future engine optimizations will automatically
    enhance overall performance of any executed code if it is written with FP principles
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on functional programming and functional JavaScript,
    please get one of the many good books and videos on these subjects that have been
    published by Packt Publishing in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a better understanding of why JavaScript is increasingly becoming
    a functional language and how this programming paradigm can be a vector for performance.
    We have learned how replacing overly complex code with simplified functional versions
    and how using immutability and tail-call optimization can help make JavaScript
    more efficient. We also got a quick glimpse of the upcoming features of the JavaScript
    language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at a few projects that have went along
    with Google's Faster Web initiative over the years and we will see how it is possible
    to combine these technologies in order to boost overall web server performance.
  prefs: []
  type: TYPE_NORMAL
