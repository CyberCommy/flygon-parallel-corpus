- en: Part I. Module 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。模块1
- en: '**Spring Essentials**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Spring基础知识**'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Build mission-critical enterprise applications using Spring Framework and
    Aspect Oriented Programming*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*使用Spring框架和面向方面的编程构建关键任务的企业应用程序*'
- en: Chapter 1. Getting Started with Spring Core
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。开始使用Spring Core
- en: Spring Framework is the most trusted and widely used application development
    framework in Enterprise Java. Originally introduced as a simple and lightweight
    alternative for the complex J2EE, Spring has now grown to become a truly modern
    application development platform. Spring and its subprojects provide an excellent
    foundation for end-to-end application development, with features beyond even those
    provided by the latest Java EE, such as mobile development, social networking,
    and big data, besides traditional Java web, server-side, or even standalone applications.
    After more than a decade since its inception, Spring continues to inspire technologies
    and technologists across the globe.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架是企业Java中最受信任和广泛使用的应用程序开发框架。最初作为复杂J2EE的简单轻量级替代方案引入，Spring现在已经发展成为一个真正现代的应用程序开发平台。Spring及其子项目为端到端应用程序开发提供了出色的基础，具有甚至超过最新Java
    EE提供的功能，如移动开发、社交网络和大数据，除了传统的Java web、服务器端或独立应用程序。自诞生以来已经超过十年，Spring继续激发全球范围内的技术和技术人员。
- en: Although Spring simplifies Java development drastically, software developers
    and architects are still required to gain a thorough understanding of its core
    concepts and features in order to deduce the best use of the Spring family. The
    simplicity Spring offers to otherwise complex Java development is the result of
    smart abstractions that it provides in the form of excellent APIs and modules.
    Spring components relieve the developer of all the technical complexity and heavy
    lifting of common technical and infrastructure plumbing tasks. As the official
    Spring documentation says, Spring provides comprehensive infrastructure support
    so that you can focus on your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring极大地简化了Java开发，但软件开发人员和架构师仍需要深入了解其核心概念和特性，以便推断出Spring家族的最佳用法。Spring提供给复杂的Java开发带来的简单性是其提供的优秀API和模块形式的智能抽象的结果。Spring组件解除了开发人员对常见技术和基础设施管道任务的所有技术复杂性和繁重工作。正如官方Spring文档所说，Spring提供了全面的基础设施支持，以便您可以专注于您的应用程序。
- en: This book is an attempt to make your Spring learning even easier and a more
    enjoyable experience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书试图使您的Spring学习更加轻松和愉快。
- en: This chapter gives you a solid foundation of the core Spring Framework, guiding
    you through its core concepts, components, and modules accompanied by relevant
    sample code snippets that illustrate the best and most practical usage of each
    feature in order to solve your everyday programming problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了Spring框架核心的坚实基础，引导您了解其核心概念、组件和模块，并附有相关的示例代码片段，以说明每个功能的最佳和最实用的用法，以解决您的日常编程问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Spring landscape
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring的景观
- en: Setting up the development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Your first Spring application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个Spring应用程序
- en: Core concepts
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心概念
- en: The IoC (Inversion of Control) container
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoC（控制反转）容器
- en: Beans in detail
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍bean
- en: Working with bean definition profiles
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用bean定义配置文件
- en: Handling resources
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理资源
- en: SpEL (Spring Expression Language)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpEL（Spring表达式语言）
- en: Aspect Oriented Programming
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: The Spring landscape
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring的景观
- en: Spring covers a wide variety of technological aspects handled by applications
    of different types, ranging from a simple standalone Java application up to the
    most complex, mission critical distributed enterprise systems you can imagine.
    Unlike most other open source or proprietary frameworks that focus on a specific
    technology concern such as Web, Messaging, or Remoting, Spring successfully covers
    almost all the technical aspects of business applications. In most cases, instead
    of reinventing solutions, Spring utilizes and integrates proven existing frameworks
    to achieve this end-to-end coverage. Spring is highly modular; hence, it noninvasively
    allows you to cherry-pick just the modules or features you require in order to
    become a one-stop shop for all your development needs on JVM.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring涵盖了由不同类型的应用程序处理的各种技术方面，从简单的独立Java应用程序到您可以想象的最复杂的、关键任务的分布式企业系统。与大多数其他开源或专有框架不同，它专注于特定技术关注点，如Web、消息传递或远程调用，Spring成功地涵盖了几乎所有业务应用程序的技术方面。在大多数情况下，Spring利用和集成了经过验证的现有框架，而不是重新发明解决方案，以实现端到端的覆盖。Spring高度模块化，因此，它非侵入性地允许您挑选您需要的模块或功能，以成为JVM上所有开发需求的一站式商店。
- en: 'The whole Spring Framework portfolio is organized into three major elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 整个Spring框架组合分为三个主要元素：
- en: Spring Framework
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架
- en: Spring Tool Suite
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring工具套件
- en: Spring subprojects
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring子项目
- en: Spring is constantly improving and becoming more and more modular with every
    new version so that you can use just the required modules.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring不断改进，并且随着每个新版本变得越来越模块化，以便您可以只使用所需的模块。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book is based on Spring version 4.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于Spring 4版本。
- en: The Spring Framework modules
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring框架模块
- en: 'The core Spring Framework provides basic infrastructure for Java development
    on top of its core **Inversion of Control** (**IoC**) container. The IoC container
    is an infrastructure that provides **Dependency Injection** (**DI**) for applications.
    Both the concepts of Dependency Injection and IoC containers are explained in
    detail later in this chapter. The core Spring Framework is divided into the following
    modules, providing a range of services:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 核心Spring框架为Java开发提供了基本的基础设施，构建在其核心的**控制反转**（**IoC**）容器之上。IoC容器是为应用程序提供**依赖注入**（**DI**）的基础设施。依赖注入和IoC容器的概念将在本章后面详细解释。核心Spring框架分为以下模块，提供一系列服务：
- en: '| Module | Summary |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 摘要 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Core container | Provides the IoC and Dependency Injection features. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 核心容器 | 提供IoC和依赖注入功能。 |'
- en: '| AOP and instrumentation | Provides AOP Alliance compliant features for weaving
    cross-cutting concerns in Spring applications. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| AOP和仪器 | 为Spring应用程序中的横切关注点提供符合AOP Alliance标准的特性。 |'
- en: '| Messaging | Provides messaging abstraction over the Spring Integration project
    for messaging-based applications. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 消息 | 为基于消息的应用程序提供了Spring Integration项目上的消息抽象。 |'
- en: '| Data access/integration | The data-access/integration layer consists of JDBC,
    ORM, OXM, JMS, and transaction modules. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 数据访问/集成 | 数据访问/集成层包括JDBC、ORM、OXM、JMS和事务模块。 |'
- en: '| Web | Web technology abstraction over Spring MVC, web socket, and portlet
    APIs. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Web | Spring MVC、web socket和portlet API上的Web技术抽象。 |'
- en: '| Test | Unit testing and integration testing support with JUnit and TestNG
    frameworks. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 使用JUnit和TestNG框架支持单元测试和集成测试。 |'
- en: Spring Tool Suite (STS)
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring工具套件（STS）
- en: STS is an Eclipse-based **IDE** (short for **Integrated Development Environment**)
    for Spring development. You can download the pre-bundled STS from [http://spring.io/tools/sts/all](http://spring.io/tools/sts/all)
    or update your existing Eclipse installation from the update site found at the
    same location. STS provides various high-productivity features for Spring development.
    In fact, a Java developer can use any IDE of their choice. Almost all the Java
    IDEs support Spring development, and most of them have got plugins available for
    Spring.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: STS是基于Eclipse的Spring开发**IDE**（**集成开发环境**）。你可以从[http://spring.io/tools/sts/all](http://spring.io/tools/sts/all)下载预打包的STS，或者从同一位置的更新站点更新现有的Eclipse安装。STS为Spring开发提供了各种高生产力的功能。实际上，Java开发人员可以使用他们选择的任何IDE。几乎所有的Java
    IDE都支持Spring开发，并且大多数都有可用于Spring的插件。
- en: Spring subprojects
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring子项目
- en: Spring has many subprojects that solve various application infrastructure needs.
    From configuration to security, web apps to big data, productivity to **enterprise
    application integration** (**EAI**), whatever your technical pain point be, you
    will find a Spring project to help you in your application development. Spring
    projects are located at [http://spring.io/projects](http://spring.io/projects).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有许多子项目，解决各种应用基础设施需求。从配置到安全，从Web应用到大数据，从生产力到**企业应用集成**（**EAI**），无论你的技术痛点是什么，你都会发现一个Spring项目来帮助你进行应用开发。Spring项目位于[http://spring.io/projects](http://spring.io/projects)。
- en: Some notable projects you may find useful right away are Spring Data (JPA, Mongo,
    Redis, and so on), Spring Security, Spring Web Services, Spring Integration, Spring
    for Android, and Spring Boot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能立即发现有用的一些显著项目包括Spring Data（JPA、Mongo、Redis等）、Spring Security、Spring Web Services、Spring
    Integration、Spring for Android和Spring Boot。
- en: Design concepts behind Spring Framework
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架背后的设计概念
- en: 'The design of Spring Framework is motivated by a set of design patterns and
    best practices that have evolved in the industry to address the complexity of
    Object Oriented Programming, including:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架的设计受到一系列设计模式和最佳实践的启发，这些设计模式和框架已经在行业中发展，以解决面向对象编程的复杂性，包括：
- en: Simple, noninvasive, and lightweight **POJO** (**Plain Old Java Objects**) programming,
    without having a need for complex application servers
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单、非侵入式、轻量级的**POJO**（**Plain Old Java Objects**）编程，无需复杂的应用服务器
- en: Loosely-coupled dependencies, achieved by applying the concepts of *program
    to interfaces* and *composition over inheritance*, which are the underlying design
    principles of design patterns and frameworks
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用*面向接口编程*和*组合优于继承*的概念来实现松耦合的依赖关系，这些是设计模式和框架的基本设计原则
- en: Highly configurable systems composed of objects with externalized Dependency
    Injection
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由对象组成的高度可配置系统，具有外部化的依赖注入
- en: Templated abstractions to eliminate repetitive, boilerplate code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化的抽象以消除重复的样板代码
- en: Declarative weaving of cross-cutting aspects without polluting business components
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性地编织横切关注点，而不污染业务组件
- en: Spring implements established design principles and patterns into its elegant
    components and promotes their use as the default design approach in applications
    built using Spring. This noninvasive approach lets you engineer robust and highly
    maintainable systems composed of loosely coupled components and objects written
    in clean and modular code. Spring Framework components, templates, and libraries
    realize the goals and concepts explained earlier in the chapter, leaving you to
    focus on your core business logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring将已建立的设计原则和模式实现到其优雅的组件中，并促进它们作为Spring构建的应用程序的默认设计方法。这种非侵入式的方法让你能够构建松耦合的组件和以清晰、模块化的代码编写的对象组成的健壮且易于维护的系统。Spring框架的组件、模板和库实现了本章前面解释的目标和概念，让你可以专注于核心业务逻辑。
- en: Setting up the development environment
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'Spring projects are usually created as Java projects based in Maven, Gradle,
    or Ivy (which are build automation and dependency management tools). You can easily
    create a Maven-based Spring project using STS or Eclipse with Spring Tools support.
    You need to make sure your `pom.xml` (Maven configuration) file contains, at the
    minimum, a dependency to `spring-context`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring项目通常是基于Maven、Gradle或Ivy（这些是构建自动化和依赖管理工具）的Java项目创建的。你可以使用STS或带有Spring工具支持的Eclipse轻松创建基于Maven的Spring项目。你需要确保你的`pom.xml`（Maven配置）文件至少包含对`spring-context`的依赖：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, you should add further dependencies to modules such as `spring-tx`,
    `spring-data-jpa`, `spring-webmvc`, and `hibernate`, depending on your project
    type and requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该根据项目类型和要求向模块添加进一步的依赖，比如`spring-tx`、`spring-data-jpa`、`spring-webmvc`和`hibernate`。
- en: 'Unless you explicitly specify the repository location, your project works with
    Maven''s central repository. Alternatively, you can point to Spring''s official
    Maven repository (for example, for milestones and snapshots) by specifying it
    in your `pom.xml` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确指定存储库位置，否则你的项目将使用Maven的中央存储库。或者，你可以在`pom.xml`文件中指定Spring的官方Maven存储库（例如，用于里程碑和快照）：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use the Spring `release`, `milestone`, and `snapshot` repositories as
    required.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要使用Spring的`release`、`milestone`和`snapshot`仓库。
- en: 'If you are using Gradle as your build system, you can declare your dependencies
    (typically in the `build.gradle` file) as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Gradle作为你的构建系统，你可以在`build.gradle`文件中声明你的依赖关系，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you prefer using the Ivy dependency management tool, then your Spring dependency
    configuration will look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用Ivy依赖管理工具，那么你的Spring依赖配置将如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Your first Spring application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Spring应用程序
- en: 'Let''s start with a very simple Spring application now. This application simply
    greets the user with a welcome message. Technically, it demonstrates how you configure
    a Spring `ApplicationContext` (IoC container) with just a single bean in it and
    invoke that bean method in your application. The application has four artifacts
    in it (besides the project build file, of course):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从一个非常简单的Spring应用程序开始。这个应用程序只是用欢迎消息向用户打招呼。从技术上讲，它演示了如何配置一个Spring `ApplicationContext`（IoC容器），其中只有一个bean，并在应用程序中调用该bean的方法。该应用程序有四个部分（当然还有项目构建文件）：
- en: '`GreetingService.java`: A Java interface—just a single method'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GreetingService.java`：一个Java接口—只有一个方法'
- en: '`GreetingServiceImpl.java`: A simple implementation of `GreetingService`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GreetingServiceImpl.java`：`GreetingService`的简单实现'
- en: '`Application.java`: Your application with a `main` method'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.java`：带有`main`方法的应用程序'
- en: '`application-context.xml`: The Spring configuration file of your application'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-context.xml`：您的应用程序的Spring配置文件'
- en: 'The following are the service components of your application. The service implementation
    just prints a greeting message to the logger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你的应用程序的服务组件。服务实现只是向日志记录器打印一个问候消息：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s take a look at the `application-context.xml` file, which is your
    Spring configuration file, where you register `GreetingService` as a Spring bean
    in the following listing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`application-context.xml`文件，这是你的Spring配置文件，在这里你可以在下面的清单中注册`GreetingService`作为Spring
    bean：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, you invoke the `GreetingService.greet()` method from your Spring application,
    as given in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以从你的Spring应用程序中调用`GreetingService.greet()`方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will explore and conquer the mighty Spring Framework right from this very
    simple and pretty much self-explanatory application. We will discuss and elaborate
    the concepts behind this application, and more, in the following sections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个非常简单且相当自解释的应用程序开始，探索并征服强大的Spring框架。我们将在接下来的章节中讨论和详细说明这个应用程序背后的概念，以及更多内容。
- en: Inversion of Control explained
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制反转解释
- en: IoC is a design principle that decouples objects of an object-oriented program
    from their dependencies (collaborators), that is, the objects they work with.
    Usually, this decoupling is achieved by externalizing the responsibility of object
    creation and Dependency Injection to an external component, such as an IoC container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: IoC是一种设计原则，它将面向对象程序的对象与它们的依赖关系（协作者）解耦，也就是说，它们所使用的对象。通常，这种解耦是通过将对象创建和依赖注入的责任外部化到外部组件（如IoC容器）来实现的。
- en: This concept is often compared to the Hollywood principle, "Don't call us, we
    will call you." In the programming world, it recommends the main program (or a
    component) not to instantiate its dependencies by itself but let an assembler
    do that job.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念经常被比作好莱坞原则，“不要打电话给我们，我们会打电话给你。”在编程世界中，它建议主程序（或组件）不要自己实例化它的依赖关系，而是让一个组装器来完成这项工作。
- en: This immediately decouples the program from the many problems caused by tightly
    coupled dependencies and relieves the programmer to let them quickly develop their
    code using abstract dependencies (*program to interfaces*). Later, at runtime,
    an external entity, such as an IoC container, resolves their concentrate implementations
    specified somewhere and injects them at runtime.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即将程序与紧密耦合的依赖关系造成的许多问题解耦，并让程序员能够快速使用抽象依赖关系（*按接口编程*）开发他们的代码。稍后，在运行时，外部实体，如IoC容器，解析它们在某处指定的具体实现，并在运行时注入它们。
- en: You can see this concept implemented in the example we just saw. Your main program
    (`Application.java`) is not instantiating the `GreetingService` dependency; it
    just asks the `ApplicationContext` (IoC container) to return an instance. While
    writing `Application.java`, the developer doesn't need to think about how the
    `GreetingService` interface is actually implemented. The Spring `ApplicationContext`
    takes care of object creation and injects any other functionality transparently,
    keeping the application code clean.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们刚刚看到的示例中看到这个概念的实现。你的主程序（`Application.java`）不是实例化`GreetingService`依赖关系；它只是请求`ApplicationContext`（IoC容器）返回一个实例。在编写`Application.java`时，开发人员不需要考虑`GreetingService`接口实际上是如何实现的。Spring
    `ApplicationContext`负责对象的创建，并在运行时透明地注入任何其他功能，保持应用程序代码的清晰。
- en: Objects managed by an IoC container do not control the creation and resolution
    of their dependencies by themselves; rather, that control is inverted by moving
    it away to the container itself; hence the term "Inversion of Control".
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由IoC容器管理的对象不会自己控制它们的依赖关系的创建和解析；相反，这种控制被转移给了容器本身；因此有了“控制反转”的术语。
- en: The IoC container assembles the components of the application as specified in
    the configuration. It handles the life cycles of the managed objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IoC容器根据配置组装应用程序的组件。它处理受管对象的生命周期。
- en: Dependency Injection
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Dependency Injection is a specific form of Inversion of Control. It is a more
    formalized design pattern, whereby dependencies of an object are injected by an
    assembler. DI is generally performed in three major styles: constructor injection,
    property (setter) injection, or, sometimes, interface injection. IoC and DI are
    often used interchangeably.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是控制反转的一种特定形式。它是一种更加正式的设计模式，对象的依赖关系是由组装器注入的。DI通常以三种主要风格进行：构造函数注入、属性（setter）注入，或者有时接口注入。IoC和DI经常可以互换使用。
- en: DI offers several benefits, including effective decoupling of dependencies,
    cleaner code, and increased testability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DI提供了几个好处，包括有效解耦依赖关系、更清晰的代码和增强的可测试性。
- en: The Spring IoC container
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring IoC容器
- en: 'The core Spring modules, `spring-core`, `spring-beans`, `spring-context`, `spring-context-support`,
    and `spring-expression`, together make up the core container. The Spring IoC container
    is designed as an implementation of the following interfaces:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的核心模块，`spring-core`、`spring-beans`、`spring-context`、`spring-context-support`和`spring-expression`，共同组成了核心容器。Spring
    IoC容器被设计为以下接口的实现：
- en: '`org.springframework.beans.factory.BeanFactory`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.beans.factory.BeanFactory`'
- en: '`org.springframework.context.ApplicationContext`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.context.ApplicationContext`'
- en: The `BeanFactory` interface provides the configuration framework and basic functionality,
    while `ApplicationContext`, an extension of `BeanFactory`, adds more enterprise-specific
    functionality, such as easier integration with Spring's AOP features, message
    resource handling (for internationalization), and event publication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanFactory`接口提供了配置框架和基本功能，而`ApplicationContext`作为`BeanFactory`的扩展，添加了更多的企业特定功能，例如更容易集成Spring的AOP功能、消息资源处理（用于国际化）和事件发布。'
- en: 'Spring provides several concrete implementations of `ApplicationContext` out
    of the box for various contexts. The following table lists the most popular ones
    among them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为各种上下文提供了几种`ApplicationContext`的具体实现。以下表列出了其中最受欢迎的几种：
- en: '| Application context | Typical application type |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 应用上下文 | 典型的应用程序类型 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ClassPathXmlApplicationContext` | Standalone |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `ClassPathXmlApplicationContext` | 独立 |'
- en: '| `AnnotationConfigApplicationContext` | Standalone |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `AnnotationConfigApplicationContext` | 独立 |'
- en: '| `FileSystemXmlApplicationContext` | Standalone |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemXmlApplicationContext` | 独立 |'
- en: '| `GenericWebApplicationContext` | Web |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `GenericWebApplicationContext` | Web |'
- en: '| `XmlWebApplicationContext` | Web |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `XmlWebApplicationContext` | Web |'
- en: '| `XmlPortletApplicationContext` | Web portlet |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `XmlPortletApplicationContext` | Web portlet |'
- en: In Spring, objects managed by the IoC container are called **beans**. The IoC
    container handles the assembly and lifecycles of Spring beans. Beans are defined
    in the configuration metadata consumed by the container, which instantiates and
    assembles them in order to compose your application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，由IoC容器管理的对象称为**bean**。IoC容器处理Spring bean的组装和生命周期。Bean在容器消耗的配置元数据中定义，容器实例化和组装它们以组成您的应用程序。
- en: Configuration metadata
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置元数据
- en: 'Spring supports three forms of configuration metadata to configure your beans:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持三种形式的配置元数据来配置您的bean：
- en: XML-based configuration metadata
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的配置元数据
- en: Annotation-based configuration metadata
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的配置元数据
- en: Java-based configuration metadata
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java的配置元数据
- en: The example code listing you saw earlier used XML-based configuration metadata.
    You can always mix and match different forms of metadata in a single application.
    For example, you may define the primary metadata to be a root XML file that combines
    a set of annotation-based metadata that in turn defines beans from different layers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您在之前看到的示例代码清单使用了基于XML的配置元数据。您可以在单个应用程序中随时混合和匹配不同形式的元数据。例如，您可以定义主要元数据为根XML文件，该文件组合了一组基于注解的元数据，这些元数据反过来定义了来自不同层的bean。
- en: XML-based configuration metadata
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于XML的配置元数据
- en: The `application-context.xml` file we saw in the previous Spring application
    sample is a very minimal example for XML-based configuration metadata. Beans are
    configured as `<bean/>` elements inside a top-level `<beans>` element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Spring应用程序示例中看到的`application-context.xml`文件是基于XML的配置元数据的一个非常简单的示例。Bean被配置为顶级`<beans>`元素内的`<bean/>`元素。
- en: Classes representing the service layer (core business logic, also known as **Service**
    classes), **Data Access Objects** (**DAOs**), managed web backing beans (such
    as Struts action instances and JSF managed beans), infrastructure objects (such
    as Hibernate session factories and JMS queues), and so forth, are excellent candidates
    for Spring beans. Fine-grained domain objects are not generally configured as
    Spring beans, because it is usually the responsibility of DAOs and the business
    logic to create and load domain objects—Hibernate entities are typical examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代表服务层（核心业务逻辑，也称为**Service**类）、数据访问对象（**DAOs**）、管理的网络后备bean（如Struts操作实例和JSF管理的bean）、基础设施对象（如Hibernate会话工厂和JMS队列）等等，都是Spring
    bean的绝佳候选对象。细粒度的领域对象通常不被配置为Spring bean，因为通常是DAO和业务逻辑的责任来创建和加载领域对象——Hibernate实体是典型的例子。
- en: 'You can create a consolidated (root) `ApplicationContext` XML file that imports
    other XML files representing various layers of the application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个合并（根）`ApplicationContext` XML文件，导入表示应用程序各层的其他XML文件：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Annotation-based configuration metadata
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于注解的配置元数据
- en: This method relies on bytecode metadata to wire up components instead of XML-based
    angle bracket declarations. Configuration of a bean is defined at the source level
    of the bean itself, in the form of annotations at class, field, or method levels.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于字节码元数据来连接组件，而不是基于XML的尖括号声明。Bean的配置是在bean本身的源级别上定义的，以类、字段或方法级别的注解形式。
- en: 'Let''s take a look at the simplest Spring bean configured by source-level annotation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个通过源级别注解配置的最简单的Spring bean：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is just an annotated version of the same `GreetingServiceImpl` shown in
    the *Your first Spring application* section, where it was configured in the `application-context.xml`
    file purely in XML form. In this preceding listing, the annotation `@Component`
    makes it a Spring bean. Now, it doesn''t require to be defined in XML, but you
    should instruct your `ApplicationContext` to consider annotations, as given in
    the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是与*您的第一个Spring应用程序*部分中显示的相同的`GreetingServiceImpl`的带注释版本，在那里它纯粹以XML形式在`application-context.xml`文件中配置。在前面的清单中，注解`@Component`使其成为Spring
    bean。现在，它不需要在XML中定义，但您应该指示您的`ApplicationContext`考虑注解，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code snippet in your `application-context.xml` file forces `ApplicationContext`
    to scan the entire application, including all its dependencies—even inside JAR
    files—for components annotated as Spring beans of various stereotypes, such as
    `@Component`, `@Service`, `@Repository`, and `@Controller`. In addition to component
    scanning, the `ApplicationContext` looks for all the annotations in that bean
    at the class, property, constructor, and method levels (including setter methods)
    in order to inject dependencies and other behaviors into your beans at startup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`application-context.xml`文件中的此代码片段会强制`ApplicationContext`扫描整个应用程序，包括其所有依赖项，甚至包括JAR文件中的组件，这些组件被注释为Spring
    bean的各种原型，例如`@Component`，`@Service`，`@Repository`和`@Controller`。除了组件扫描，`ApplicationContext`还会查找该bean中的所有注释，包括类、属性、构造函数和方法级别（包括setter方法），以便在启动时将依赖项和其他行为注入到您的bean中。
- en: Beware, component scanning can be time consuming if you provide a broader package
    name to the `base-package` attribute; it is advised to provide more specific package
    names to scan (for example, a set of comma-separated package names) so that you
    have more control. You can narrow down your component scanning even further using
    `<context:include-filter/>` and `<context:exclude-filter/>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您为`base-package`属性提供了更广泛的包名称，组件扫描可能会耗费时间；建议提供更具体的包名称进行扫描（例如，一组逗号分隔的包名称），以便更好地控制。您甚至可以使用`<context:include-filter/>`和`<context:exclude-filter/>`进一步缩小组件扫描的范围。
- en: Another simple instruction to enable annotation configuration is `<context:annotation-config/>`.
    It simply looks for annotations on beans registered in the application context
    and will not detect the components, whereas if you use `<context:component-scan/>`,
    it handles both component scanning and other annotations, which will be covered
    later in this chapter, so you do not need to explicitly declare `<context:annotation-config/>`.
    So, the best method for annotation-based configuration is to use `<context:annotation-config/>`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 启用注释配置的另一个简单指令是`<context:annotation-config/>`。它只会查找应用程序上下文中注册的bean上的注释，不会检测组件，而如果您使用`<context:component-scan/>`，它会处理组件扫描和其他注释，这将在本章后面进行介绍，因此您不需要显式声明`<context:annotation-config/>`。因此，基于注释的配置的最佳方法是使用`<context:annotation-config/>`。
- en: XML-based versus annotation-based configuration
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于XML与基于注释的配置
- en: XML-based configuration has some advantages over its annotation-based counterpart.
    The biggest one is that all your bean definitions are in one place and not scattered
    in many classes or even JAR dependencies. XML allows you to split your metadata
    files and then combine them using `<import/>`. Using XML, you can configure any
    class, including third-party ones such as Spring beans, and inject dependencies
    and other services into it, which is impossible in the case of annotation. Also,
    you can define the same class as multiple different beans, each with a different
    name, dependencies, configuration, and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的配置与基于注释的配置相比具有一些优势。最大的优势是所有bean定义都在一个地方，而不是分散在许多类甚至JAR依赖项中。XML允许您拆分元数据文件，然后使用`<import/>`将它们组合起来。使用XML，您可以配置任何类，包括Spring
    bean等第三方类，并将依赖项和其他服务注入其中，这在注释的情况下是不可能的。此外，您可以将同一类定义为多个不同的bean，每个bean具有不同的名称、依赖项、配置等。
- en: Annotation-based metadata too has some advantages over XML configuration. It
    is more concise and much easier to develop and maintain, as your annotation and
    DI are right inside your source code. All information about a class is in one
    place.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注释的元数据也比XML配置具有一些优势。它更简洁，更容易开发和维护，因为您的注释和DI就在源代码中。关于类的所有信息都在一个地方。
- en: For bigger applications, the best option would be a mixed approach where the
    more reusable beans (libraries shared between multiple projects) and third-party
    components are configured in XML and those with a smaller scope are annotated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的应用程序，最佳选择是混合方法，其中更可重用的bean（在多个项目之间共享的库）和第三方组件在XML中进行配置，而范围较小的bean则进行注释。
- en: Component stereotype annotations
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件原型注释
- en: 'Spring provides further component stereotypes for beans that represent various
    roles. The primary stereotype is `@Component`, and all the others are its specializations
    for more specific use cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为代表各种角色的bean提供了更多的组件原型。主要的原型是`@Component`，其他所有原型都是其更具体用例的特殊化：
- en: '| Stereotype | Description |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 原型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Component` | A generic type for all Spring-managed components (beans).
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `@Component` | 所有Spring管理的组件（bean）的通用类型。 |'
- en: '| `@Service` | Marker meta-annotation for service layer components. Currently,
    Spring treats this the same as `@Component`, with no special function. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `@Service` | 服务层组件的标记元注释。目前，Spring将其视为`@Component`，没有特殊功能。 |'
- en: '| `@Repository` | Used as DAOs in your persistence layer. Spring Data libraries
    provide additional functionality. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `@Repository` | 用作持久化层中的DAO。Spring Data库提供了额外的功能。 |'
- en: '| `@Controller` | Handles Web MVC endpoints in order to process HTTP requests
    mapped to specific URLs. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `@Controller` | 处理Web MVC端点，以处理映射到特定URL的HTTP请求。 |'
- en: '| `@RestController` | A specialized controller for RESTful web services, part
    of Web MVC. It is a meta-annotation that combines `@Controller` and `@ResponseBody`.
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `@RestController` | 用于RESTful Web服务的专用控制器，属于Web MVC的一部分。它是一个元注释，结合了`@Controller`和`@ResponseBody`。
    |'
- en: Custom stereotypes can be created by defining meta-annotations from scratch
    or combining existing annotations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从头开始定义元注释或组合现有注释来创建自定义原型。
- en: Java-based configuration metadata
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Java的配置元数据
- en: 'Starting with Spring 3.0, you can configure Spring metadata purely inside Java
    classes, completely avoiding any XML configuration while enhancing annotation-based
    metadata. You annotate any Java class with `@Configuration` annotation at the
    class level and have methods annotated as `@Configuration` annotation on a factory
    method that instantiates an `@Component` annotation, or any other specialized
    bean, to define your application context. Let''s see a simple example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring 3.0开始，您可以纯粹在Java类中配置Spring元数据，完全避免任何XML配置，同时增强基于注解的元数据。您可以在任何Java类上用`@Configuration`注解进行注解，并在工厂方法上用`@Configuration`注解进行注解，该工厂方法实例化`@Component`注解或任何其他专门的bean来定义应用程序上下文。让我们看一个简单的例子：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In `SpringJavaConfigurator.java`, the Java configuration class configures the
    Spring beans, replacing the `application-context.xml` file. Your Spring application
    can directly depend on this `Configuration` class for loading `ApplicationContext`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpringJavaConfigurator.java`中，Java配置类配置Spring bean，替换了`application-context.xml`文件。您的Spring应用程序可以直接依赖于这个`Configuration`类来加载`ApplicationContext`。
- en: 'Typically, you use an `AnnotationConfigApplication` instance for instantiating
    your application context:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您使用`AnnotationConfigApplication`实例来实例化应用程序上下文：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When `@Configuration` classes are provided as the constructor argument, the
    `@Configuration` class itself is registered as a bean definition and so are all
    declared `@Bean` methods within the class. Spring will scan for the entire project
    and its dependencies for `@Component` or its specializations (the other stereotypes
    listed previously), matching the argument values provided in `@ComponentScan(basePackages
    = "…")` with all other relevant annotations and building the application context.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@Configuration`类作为构造函数参数提供时，`@Configuration`类本身将被注册为bean定义，类中声明的所有`@Bean`方法也将被注册为bean定义。Spring将扫描整个项目及其依赖项，寻找`@Component`或其特殊化（之前列出的其他原型），将`@ComponentScan(basePackages
    = "…")`中提供的参数值与所有其他相关注解进行匹配，并构建应用程序上下文。
- en: The advantage of JavaConfig metadata is that you have programmatic control over
    Spring configuration while separating out the entire DI and bean configuration
    into a separate Java class. Using JavaConfig, you eliminate the complexity of
    managing many XML files. You detect any configuration issues during development
    at the earliest, as JavaConfig fails during compilation itself, while in the case
    of XML, you will know about the configuration issues only on application startup.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: JavaConfig元数据的优势在于您可以对Spring配置进行编程控制，同时将整个DI和bean配置分离到单独的Java类中。使用JavaConfig，您可以消除管理许多XML文件的复杂性。您可以在开发过程中尽早检测到任何配置问题，因为JavaConfig在编译时就会失败，而在XML的情况下，您只能在应用程序启动时了解配置问题。
- en: JSR 330 standard annotations
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSR 330标准注解
- en: Besides Spring-specific annotations, Spring supports JSR 330 standard annotations
    for DI, starting from Spring 3.0\. You just need to include `javax.inject` artifacts
    in your Maven or Gradle configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Spring特定的注解外，Spring还支持JSR 330标准注解用于DI，从Spring 3.0开始。您只需要在Maven或Gradle配置中包含`javax.inject`构件。
- en: 'JSR 330 standard annotations have the following equivalents in Spring:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 330标准注解在Spring中有以下等价物：
- en: '| Spring | JSR-330 (javax.inject.*) | Target level / Usage |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Spring | JSR-330 (javax.inject.*) | 目标级别/用法 |'
- en: '| --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@Component` | `@Named` | Type (class) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `@Component` | `@Named` | 类型（类） |'
- en: '| `@Autowired` | `@Inject` | Property and setter methods |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `@Autowired` | `@Inject` | 属性和setter方法 |'
- en: '| `@Qualifier` | `@Named` | Type, property and setter methods |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `@Qualifier` | `@Named` | 类型、属性和setter方法 |'
- en: '| `@Scope("singleton")` | `@Singleton` | Meta-annotation for bean declarations
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `@Scope("singleton")` | `@Singleton` | 用于bean声明的元注解 |'
- en: While the default scope of Spring beans is `singleton`, the JSR 330 default
    scope is like Spring's `prototype`. However, for consistency, Spring treats JSR
    330 annotated beans inside Spring as `singleton`, unless declared prototype explicitly
    using `@Scope("..")`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring bean的默认作用域是`singleton`，但JSR 330的默认作用域类似于Spring的`prototype`。但是，为了保持一致，Spring将Spring中的JSR
    330注解的bean视为`singleton`，除非使用`@Scope("..")`显式声明为prototype。
- en: JSR 330 has no equivalents for some Spring-based DI annotations, such as `@Value`,
    `@Required`, and `@Lazy`. We will discuss more about bean scopes later in this
    chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 330没有一些基于Spring的DI注解的等价物，例如`@Value`，`@Required`和`@Lazy`。我们将在本章后面更多地讨论bean作用域。
- en: Beans in detail
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细的bean
- en: A Spring application is composed of a set of beans that perform functionality
    specific to your application layers and are managed by the IoC container. You
    define your beans with configuration metadata in the form of XML, annotation,
    or JavaConfig.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序由一组bean组成，这些bean执行特定于应用程序层的功能，并由IoC容器管理。您可以使用XML、注解或JavaConfig的配置元数据定义您的bean。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default scope of a Spring bean is `singleton`. This means that a single
    instance is shared between clients anywhere in the application. Beware of keeping
    state (class level data) in `singleton` classes, as a value set by one client
    will be visible to all others. The best use case for such `singleton` classes
    are stateless services.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean的默认作用域是`singleton`。这意味着单个实例在应用程序中的任何位置之间共享。要注意在`singleton`类中保持状态（类级数据），因为一个客户端设置的值将对所有其他客户端可见。这种`singleton`类的最佳用例是无状态服务。
- en: Beans are uniquely identified by an `id` attribute, any of the values supplied
    to the (comma, semicolon, or space separated) `name` attribute of the bean definition,
    or even as an `alias` definition. You can refer to a bean anywhere in the application
    with `id` or any of the names or aliases specified in the bean definition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Bean通过`id`属性唯一标识，也可以通过bean定义中提供的任何值（逗号、分号或空格分隔）的`name`属性，甚至作为`alias`定义。您可以在应用程序中的任何位置引用bean，使用`id`或在bean定义中指定的任何名称或别名。
- en: It's not necessary that you always provide an `id` or name to the bean. If one
    isn't provided, Spring will generate a unique bean name for it; however, if you
    want to refer to it with a name or an `id`, then you must provide one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是必须为bean提供`id`或名称。如果没有提供，Spring将为其生成一个唯一的bean名称；但是，如果您想要用名称或`id`引用它，那么您必须提供一个。
- en: Spring will try to autowire beans by type if `id` or name is not provided. This
    means that `ApplicationContext` will try to match the bean with the same type
    or implementation in case it is an interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`id`或名称，Spring将尝试按类型自动装配bean。这意味着`ApplicationContext`将尝试匹配具有相同类型或实现的bean，如果它是一个接口。
- en: You can refer to a bean by type if it is either the only bean registered of
    that type or marked as `@Primary` (`primary="true"` for XML). Generally, for nested
    bean definitions and autowire collaborators, you don't need to define a name unless
    you refer to it outside the definition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个bean是该类型的唯一注册bean，或者标记为`@Primary`（对于XML为`primary="true"`），则可以按类型引用该bean。通常，对于嵌套的bean定义和自动装配的协作者，除非您在定义之外引用它，否则不需要定义名称。
- en: 'You can alias a bean outside the bean definition using the `<alias/>` tag,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`<alias/>`标签在bean定义之外为bean创建别名，如下所示：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bean definition
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean定义
- en: 'A bean definition object that you define to describe a bean has the following
    metadata:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义的用于描述bean的bean定义对象具有以下元数据：
- en: '| Property | Description |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `class` | The fully qualified class name of the bean. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `class` | bean的完全限定类名。|'
- en: '| `id` | The unique identifier of the bean. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `id` | bean的唯一标识符。|'
- en: '| `name` | One or more unique names separated by commas, semicolons, or whitespace.
    Typically, `id` and name would be the same, and you supply either of these. Other
    names in the list become aliases. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 一个或多个由逗号、分号或空格分隔的唯一名称。通常，`id`和名称将是相同的，您可以提供其中一个。列表中的其他名称将成为别名。|'
- en: '| `parent` | The parent bean for inheriting configuration data from a parent
    bean definition. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `parent` | 从父bean定义继承配置数据的父bean。|'
- en: '| `scope` | This decides the scope of the objects. The default scope of a Spring
    bean is `singleton`. This means that a single instance is shared between calls.
    We will discuss more about bean scopes later. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 这决定了对象的范围。Spring bean的默认范围是`singleton`。这意味着在调用之间共享单个实例。我们将在后面讨论更多关于bean范围的内容。|'
- en: '| `constructor args` | Bean references or names for constructor-based DI. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `constructor args` | 用于基于构造函数的DI的bean引用或名称。|'
- en: '| `properties` | Values or references for setter-based DI. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `properties` | 用于基于setter的DI的值或引用。|'
- en: '| `autowire` mode | Instructs the bean whether or how to autowire relationships
    with collaborators. Autowiring will be discussed later. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `autowire`模式 | 指示bean是否以及如何自动装配与协作者的关系。自动装配将在后面讨论。|'
- en: '| `primary` | This indicates that the bean should be considered as the primary
    autowiring candidate in case of multiple matches being found. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `primary` | 这表示在发现多个匹配项时，bean应被视为主要的自动装配候选项。|'
- en: '| `depends-on` | This forces instantiation of dependent beans prior to this
    bean. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `depends-on` | 这会强制在此bean之前实例化依赖的bean。|'
- en: '| `lazy-init` | If true, this creates a bean instance when it is first requested.
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `lazy-init` | 如果为true，则在首次请求时创建bean实例。|'
- en: '| `init-method` | Initialization callback method. This has no `args void` method
    and will be invoked post instance creation. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `init-method` | 初始化回调方法。这是一个没有`args void`方法，将在实例创建后调用的方法。|'
- en: '| `destroy-method` | Destruction callback method. This has no `args void` method
    and will be invoked before `destroy`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `destroy-method` | 销毁回调方法。这是一个没有`args void`方法，将在销毁之前调用的方法。|'
- en: '| `factory-method` | Static instance factory method on the bean itself, unless
    `factory-bean` is provided. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `factory-method` | bean本身上的静态实例工厂方法，除非提供了`factory-bean`。|'
- en: '| `factory-bean` | Another bean reference that is acting as an instance factory
    for this bean. Usually comes along with the `factory-method` property. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `factory-bean` | 作为此bean的实例工厂的另一个bean引用。通常与`factory-method`属性一起使用。|'
- en: 'Let''s take a look at a sample bean definition in XML form:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个XML形式的示例bean定义：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this sample `application-context` file, the bean, `xmlTaskService`, is autowired
    via a constructor, that is, dependencies are injected via a constructor. The first
    constructor argument refers to an existing bean definition, and the second one
    is an inline bean definition without an `id`. The bean has `init-method` and `destroy-method`
    pointed to its own methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的`application-context`文件中，bean `xmlTaskService`是通过构造函数进行自动装配的，也就是说，依赖项是通过构造函数注入的。第一个构造函数参数是指现有的bean定义，第二个是一个没有`id`的内联bean定义。该bean具有`init-method`和`destroy-method`指向其自己的方法。
- en: 'Now, let''s take a look at an annotated bean with slightly different features:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个带有稍微不同特性的注释bean：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `@Service` bean autowires its dependencies on its fields (properties) using
    an `@Autowired` annotation. Note the `@PostConstruct` and `@PreDestroy` annotations,
    the equivalents of `init-method` and `destroy-method` in the previous XML bean
    definition example. These are not Spring specific but are JSR 250 annotations.
    They work pretty well with Spring.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`@Service` bean在其字段（属性）上使用`@Autowired`注解自动装配其依赖项。请注意`@PostConstruct`和`@PreDestroy`注解，这是之前的XML
    bean定义示例中`init-method`和`destroy-method`的等价物。这些不是Spring特定的，而是JSR 250注解。它们与Spring非常配合。
- en: Instantiating beans
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化bean
- en: Bean definitions are recipes for instantiating bean instances. Depending on
    metadata attributes such as `scope`, `lazy`, and `depends-on`, Spring Framework
    decides when and how an instance is created. We will discuss it in detail later.
    Here, let's look at the "how" of instance creation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Bean定义是实例化bean实例的配方。根据`scope`、`lazy`和`depends-on`等元数据属性，Spring框架决定何时以及如何创建实例。我们将在后面详细讨论。在这里，让我们看一下实例创建的“如何”。
- en: With constructors
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: 'Any bean definition with or without constructor arguments but without a `factory-method`
    is instantiated via its own constructor, using the `new` operator:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有或不具有构造函数参数但没有`factory-method`的bean定义都是通过其自己的构造函数实例化，使用`new`运算符：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s see an annotated `@Component` with a default constructor-based instantiation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个带有默认基于构造函数实例化的注释`@Component`：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With a static factory-method
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有静态工厂方法
- en: 'A static method within the same class, marked as `factory-method`, will be
    invoked to create an instance in this case:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将调用同一类中标记为`factory-method`的静态方法来创建一个实例：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With Java configuration, you can use an `@Bean` annotation instead of factory
    methods:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java配置时，您可以使用`@Bean`注解而不是工厂方法：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With an instance factory-method
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实例工厂方法
- en: 'In this case, bean definition does not need a class attribute, but you specify
    the `factory-bean` attribute, which is another bean, with one of its non-static
    methods as `factory-method`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，bean定义不需要class属性，但您可以指定`factory-bean`属性，这是另一个bean，其中一个非静态方法作为`factory-method`：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Injecting bean dependencies
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入bean依赖
- en: The main purpose of an IoC container is to resolve the dependencies of objects
    (beans) before they are returned to the clients who called for an instance (say,
    using the `getBean` method). Spring does this job transparently based on the bean
    configuration. When the client receives the bean, all its dependencies are resolved
    unless specified as not required (`@Autowired(required = false)`), and it is ready
    to use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: IoC容器的主要目的是在将对象（bean）返回给调用实例的客户端之前解析对象（bean）的依赖关系。Spring根据bean配置透明地执行此操作。当客户端接收bean时，除非指定为不需要（`@Autowired(required
    = false)`），否则所有依赖项都已解析，并且可以立即使用。
- en: Spring supports two major variants of DI—constructor-based and setter-based
    DI—right out of the box.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持两种主要的DI变体 - 基于构造函数和基于setter的DI - 开箱即用。
- en: Constructor-based Dependency Injection
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入
- en: 'In constructor-based DI, dependencies to a bean are injected as constructor
    arguments. Basically, the container calls the defined constructor, passing the
    resolved values of the arguments. It is best practice to resolve mandatory dependencies
    via a constructor. Let''s look at an example of a simple POJO `@Service` class,
    a ready candidate for constructor-based DI:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于构造函数的DI中，将依赖项注入到bean作为构造函数参数。基本上，容器调用定义的构造函数，传递参数的解析值。最佳实践是通过构造函数解析强制依赖项。让我们看一个简单的POJO
    `@Service`类的示例，这是基于构造函数的DI的一个准备好的候选者：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s define this as a Spring bean in XML:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在XML中将其定义为Spring bean：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Spring container resolves dependencies via a constructor based on the argument's
    type. For the preceding example, you don't need to pass the index or type of the
    arguments, since they are of complex types.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器通过构造函数解析依赖项的类型。对于前面的示例，您不需要传递参数的索引或类型，因为它们是复杂类型。
- en: 'However, if your constructor has simple types, such as primitives (`int`, `long`,
    and `boolean`), primitive wrappers (`java.lang.Integer`, `Long`, and so on) or
    `String`, ambiguities of type and index may arise. In this case, you can explicitly
    specify the type and index of each argument to help the container match the arguments,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的构造函数具有简单类型，例如基本类型（`int`，`long`和`boolean`），基本包装类型（`java.lang.Integer`，`Long`等）或`String`，可能会出现类型和索引的歧义。在这种情况下，您可以显式指定每个参数的类型和索引，以帮助容器匹配参数，如下所示：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember, index numbers start from zero. The same applies to setter-based injection
    as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，索引编号从零开始。基于setter的注入也是如此。
- en: Setter-based Dependency Injection
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: 'The container calls the setter methods of your bean in the case of setter-based
    DI after the constructor (with or without `args`) is invoked. Let''s see how the
    bean definition for the previous `SystemSettings` would look if the dependencies
    were injected via setter methods, assuming the `SystemSettings` now has a `no-args`
    constructor:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数（带或不带`args`）被调用后，容器会调用您的bean的setter方法。让我们看看如果依赖项通过setter方法注入，假设`SystemSettings`现在有一个`no-args`构造函数，那么前面的`SystemSettings`的bean定义会是什么样子：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Spring validates the bean definitions at the startup of the `ApplicationContext`
    and fails with a proper message in case of a wrong configuration. The string values
    given to properties with built-in types such as `int`, `long`, `String`, and `boolean`
    are converted and injected automatically when the bean instances are created.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在`ApplicationContext`启动时验证bean定义，并在配置错误的情况下失败并提供适当的消息。给定给内置类型的属性的字符串值，例如`int`，`long`，`String`和`boolean`，在创建bean实例时会自动转换和注入。
- en: Constructor-based or setter-based DI – which is better?
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于构造函数或基于setter的DI - 哪种更好？
- en: 'Which of these DI methods is better purely depends on your scenario and some
    requirements. The following best practices may provide a guideline:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DI方法中哪种更好纯粹取决于您的场景和一些要求。以下最佳实践可能提供指导：
- en: Use constructor-based DI for mandatory dependencies so that your bean is ready
    to use when it is first called.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于强制依赖项，请使用基于构造函数的DI，以便在首次调用时准备好使用您的bean。
- en: When your constructor gets stuffed with a large number of arguments, it's the
    figurative bad code smell. It's time to break your bean into smaller units for
    maintainability.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的构造函数被填充了大量的参数时，这是一种比喻性的糟糕代码味道。是时候将您的bean分解成更小的单元以便于维护。
- en: Use setter-based DI only for optional dependencies or if you need to reinject
    dependencies later, perhaps using JMX.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在可选依赖项或需要稍后重新注入依赖项时使用基于setter的DI，也许使用JMX。
- en: Avoid circular dependencies that occur when a dependency (say, bean B) of your
    bean (bean A) directly or indirectly depends on the same bean again (bean A),
    and all beans involved use constructor-based DI. You may use setter-based DI here.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免循环依赖，当您的bean（bean A）的依赖项（例如，bean B）直接或间接地再次依赖于相同的bean（bean A），并且所有涉及的bean都使用基于构造函数的DI时。您可以在这里使用基于setter的DI。
- en: You can mix constructor-based and setter-based DI for the same bean, considering
    mandatory, optional, and circular dependencies.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a typical Spring application, you can see dependencies injected using both
    approaches, but this depends on the scenario, considering the preceding guidelines.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Cleaner bean definitions with namespace shortcuts
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make your bean definitions cleaner and more expressive using `p:(property)`
    and `c:(constructor)` namespaces, as shown here. While the `p` namespace enables
    you to use the `<bean/>` element''s attributes instead of the nested `<property/>`
    elements in order to describe your property values (or collaborating bean refs),
    the `c` namespace allows you to declare the constructor `args` as the attributes
    of the `<bean/>` element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The bean definitions in the preceding listing are cleaner but more expressive.
    Both `c:` and `p:` namespaces follow the same conventions. You need to declare
    both at the XML root element (`<beans/>`) before using them with the `<bean/>`
    elements. Note that you use the `-ref` suffix for bean references.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a List as a dependency
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On occasion, we will need to inject static collections of data as bean dependencies.
    Spring provides a natural method to wire lists. See this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding example wires a `java.util.List<String>` for simplicity. If your
    list contains a collection of beans, you can replace `<value>` with `<ref>` or
    `<bean>`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Wiring a Map as a dependency
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inject `java.util.Map` instances too in a similar fashion. Look at
    this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can inject beans as values, replacing `<value>` with `<ref>` or `<bean>`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Autowiring dependencies
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring can autowire dependencies of your beans automatically by inspecting
    the bean definitions present in the `ApplicationContext` if you specify the autowire
    mode. In XML, you specify the `autowire` attribute of the `<bean/>` element. Alternatively,
    you can annotate a bean with `@Autowired` to autowire dependencies. Spring supports
    four autowiring modes: `no`, `byName`, `byType`, and `constructor`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default autowiring of Spring beans is `byType`. If you are autowiring an
    interface, Spring will try to find an implementation of that interface configured
    as a Spring bean. If there are multiple, Spring will look for the `primary` attribute
    of the configuration to resolve; if not found, it will fail, complaining about
    an ambiguous bean definition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of autowiring constructor arguments:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can autowire at the field level, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Autowiring can be fine-tuned with an `@Qualifier` annotation and required attribute:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can use `@Qualifier` at the constructor level too:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Bean scoping
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining a bean with its dependencies and other configuration values,
    you can optionally specify the scope of a bean in the bean definition. The scope
    determines the life span of the bean. Spring comes up with six built-in scopes
    out of the box and supports the creation of custom scopes too. If not explicitly
    specified, a bean will assume the `singleton` scope, which is the default scope.
    The following table lists the built-in Spring scopes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '| Scope | Description |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `singleton` | This ensures a single instance inside the container. This is
    the default scope. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `prototype` | A new instance is created for every request for the bean. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `request` | Scopes an instance with the life cycle of every new HTTP request.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `session` | Scopes with the life cycle of every new HTTP session. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `globalSession` | Scopes with an HTTP session inside a portlet context. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| `application` | Scopes with the life cycle of a `ServletContext`. It''s `singleton`
    for `ServletContext`. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: While `singleton` and `prototype` work in all environments, request, session,
    and application work only in web environments. The `globalSession` scope is for
    portlet environments.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'In an XML bean definition, the scope is set via the `scope` attribute of the
    `<bean/>` element:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can annotate the bean scope as a meta-annotation to `@Component` or its
    derivations, such as `@Service` and `@Bean`, as shown in the following listing:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Generally, service classes and Spring data repositories are declared as `singleton`,
    since they are built stateless according to best practice.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection with scoped beans
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beans of different scopes can be wired up as collaborators in your configuration
    metadata. For example, if you have a session-scoped bean as a dependency to `singleton`
    and face an inconsistency problem, the first instance of the session-scoped bean
    will be shared between all users. This can be solved using a scoped proxy in place
    of the scoped bean:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Every time the scoped bean is injected, Spring creates a new AOP proxy around
    the bean so that the instance is picked up from the exact scope. The annotated
    version of the preceding listing would look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating a custom scope
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, the scopes supplied by Spring are not sufficient for your specific
    needs. Spring allows you to create your own custom scope for your scenario. For
    example, if you want to keep some business process level information throughout
    its life, you will want to create a new process scope. The following steps will
    enable you to achieve this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Create a Java class extending `org.springframework.beans.factory.config.Scope`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define it in your application context (XML or annotation) as a Spring bean.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the scope bean with your `ApplicationContext` either programmatically
    or in XML with `CustomScopeConfigurer`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hooking to bean life cycles
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, in enterprise application development, developers will want to plug in
    some extra functionality to be executed just after the construction and before
    the destruction of a business service. Spring provides multiple methods for interacting
    with such stages in the life cycle of a bean.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Implementing InitializingBean and DisposableBean
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Spring IoC container invokes the callback methods `afterPropertiesSet()`
    of `org.springframework.beans.factory.InitializingBean` and `destroy()` of `org.springframework.beans.factory.DisposableBean`
    on any Spring bean and implements them:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Annotating @PostConstruct and @PreDestroy on @Components
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring supports JSR 250 `@PostConstruct` and `@PreDestroy` annotations on any
    Spring bean in an annotation-supported environment, as shown here. Spring encourages
    this approach over implementing Spring-specific interfaces, as given in the previous
    section:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The init-method and destroy-method attributes of <bean/>
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using XML-only bean configuration metadata, then your best option
    is to declare `init-method` and `destroy-method` attributes on your `<bean/>`
    tags:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Container-level default-init-method and default-destroy-method
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can even set container-level default `init` and `destroy` methods so that
    you don''t need to set it for each bean. The container invokes these methods on
    beans only if they are present:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Working with bean definition profiles
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For commercial projects, it is a common requirement to be able to maintain two
    or more environment-specific configurations and beans, activated selectively only
    in the corresponding environment. For example, objects such as data sources, e-mail
    servers, and security settings could be different for development, testing, and
    production environments. You would want to switch them declaratively without touching
    the application code, keeping it externally. Developers traditionally write complex
    scripts and property files with separate builds to do this job. Spring comes to
    your rescue here with environment abstraction using bean definition profiles and
    properties.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Bean definition profiles are a mechanism by which application context is configured
    differently for different environments. You group bean definitions under named
    profiles in XML or using annotation and activate one or more profiles in each
    environment. You can set a default profile to be enabled if you do not specify
    one explicitly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look the following sample listing that configures data sources
    for development and production environments:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Practically, for production environments, externalizing this profile config
    in XML would be a better idea, where you allow your DevOps team to modify it for
    different environments and forbid them to touch your Java code. XML configuration
    would look like the following listing:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may create as many profiles as required; it is common for each developer
    to maintain their own configurations, with profiles named after themselves, say
    `@Profile("mary")`. You can have multiple profiles active at the same time too;
    it depends on how well you organize them without having conflicts or duplicate
    bean definitions across profiles.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can activate one or more profiles as you need in each (`dev`, `test`,
    or `prod`) environment using any one of the following methods:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Programmatically invoking `ctx.getEnvironment().setActiveProfiles("p1", "p2",
    ..)`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting the property `spring.profile.active`—with comma-separated profile names
    as value—as an environment variable, JVM system property, or Servlet context param
    in `web.xml`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `-Dspring.profile.active="p1,p2, .."` as a command-line or Java argument
    while starting up your application.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injecting properties into the Spring environment
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the separation of environment-specific configuration using profiles,
    you would still need to externalize many properties, such as database URLs, e-mails,
    and date formats in a property file for easier handling. These properties would
    then either be injected directly into the beans or read from environment by the
    beans at runtime. Spring's environment abstraction, together with `@PropertySource`
    annotation, makes this possible in Spring applications.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@PropertySource` annotation provides a convenient and declarative mechanism
    for adding a `PropertySource` to Spring''s environment:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Externalizing properties with PropertyPlaceholderConfigurer
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PropertyPlaceholderConfigurer` is another convenient utility to externalize
    property values from a bean definition into a separate file that uses the standard
    `java.util.Properties` format. It replaces placeholders in XML bean definitions
    with matching property values in the configured property file, as shown here.
    This is the best way to externalize profile or environment-specific information
    such as datasource config, e-mail settings, and so on. The DevOps team will just
    edit these property files and never mess with your code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is another simpler declaration of `PropertyPlaceholder`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Handling resources
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework provides excellent support for accessing low-level resources,
    thus solving many limitations of Java's standard `java.net.URL` and standard handlers.
    The `org.springframework.core.io.Resource` package and its many concrete implementations
    form a solid foundation for Spring Framework's robust resource handling.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource abstraction is used extensively in Spring itself, inside many implementations
    of `ApplicationContext`—it''s actually very useful to use as a general utility
    class by itself in your own code in order to access resources. You will find the
    following resource implementations that come supplied right out of the box in
    Spring:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource Implementation | Description |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| `UrlResource` | It wraps `java.net.URL` and is useful for accessing anything
    that can be accessed via a URL, such as files (`file:///`), HTTP targets (`http://`),
    and FTP targets (`ftp://`). |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| `ClassPathResource` | It is used for accessing any resource from classpath
    using the prefix `classpath:` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| `FileSystemResource` | This is the resource implementation of `java.io.File`.
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| `ServletContextResource` | This is the parent bean for inheriting configuration
    data from a parent bean definition. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `InputStreamResource` | This is the resource implementation for a given `InputStream`.
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: 'Generally, you do not directly instantiate any of these resources; rather,
    you use a `ResourceLoader` interface to do that job for you. All `ApplicationContext`
    implement a `ResourceLoader` interface; therefore, any `ApplicationContext` can
    be used to obtain resource instances. The code for this is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can inject resources into your beans by simply passing the filename or
    URL of your resource as an argument, as shown here. `ApplicationContext`, which
    is a `ResourceLoader` interface, will create an instance of an appropriate resource
    implementation based on the URL you supply:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the XML version of injecting a resource:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Spring Expression Language
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expression languages are generally used for simple scripting to manipulate object
    graphs in a non object-oriented context. For example, if we want to read data
    or call a method of a Java object from a JSP, XML, or XHTML page, JSP EL and **Unified
    Expression Language (UEL)** come to the rescue. These expression languages allow
    page authors to access external data objects in a simple and easy-to-use way,
    compatible with tag-based languages such as XML and HTML.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The **Spring Expression Language** (**SpEL**), with a language syntax similar
    to UEL, is a powerful expression language built for querying and manipulating
    an object graph at runtime. It offers additional features, most notably method
    invocation and basic string-templating functionality.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: SpEL can be used inside a wide variety of technologies that come under the Spring
    family of projects as well as many technologies that integrate with Spring. It
    can be used directly in the Spring configuration metadata files, both in XML as
    well as Java annotations in the form `#{expression-string}`. You can use SpEL
    inside many view technologies, such as JSP, XML, and XHTML, when integrated with
    the corresponding technologies, such as JSF, JSP, and Thymeleaf.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: SpEL features
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SpEL expression language supports the following functionalities out of
    the box:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, relational, and ternary operators
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions and class expressions
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing properties, arrays, lists, and maps
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method and constructor invocations
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables, assignments, and bean references
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array construction, inline lists, and maps
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined functions and templated expressions
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection, projection, and selection
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpEL annotation support
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SpEL can be used to specify default values for fields, methods and method or
    constructor arguments using the `@Value` annotation. The following sample listing
    contains some excellent usage of SpEL expressions at the field level:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The same approach can be used for XML bean definitions too.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The SpEL API
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, most users use SpEL to evaluate expressions embedded in XML, XHTML,
    or annotations. While SpEL serves as the foundation for expression evaluation
    within the Spring portfolio, it can be used independently in non-Spring environments
    using the SpEL API. The SpEL API provides the bootstrapping infrastructure to
    use SpEL programmatically in any environment.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The SpEL API classes and interfaces are located in the (sub)packages under `org.springframework.expression`.
    They provide the specification and default SpEL implementations which can be used
    directly or extended.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'The following interfaces and classes form the foundation of the SpEL API:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '| Class/Interface | Description |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| `Expression` | The specification for an expression capable of evaluating
    itself against context objects independent of any language such as OGNL or UEL.
    It encapsulates the details of a previously parsed expression string. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| `SpelExpression` | A SpEL-compliant, parsed expression that is ready to be
    evaluated standalone or in a specified context. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| `ExpressionParser` | Parses expression strings (templates as well as standard
    expression strings) into compiled expressions that can be evaluated. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| `SpelExpressionParser` | SpEL parser. Instances are reusable and thread-safe.
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| `EvaluationContext` | Expressions are executed in an evaluation context,
    where references are resolved when encountered during expression evaluation. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| `StandardEvaluationContext` | The default `EvaluationContext` implementation,
    which uses reflection to resolve properties/methods/fields of objects. If this
    is not sufficient for your use, you may extend this class to register custom `ConstructorResolver`,
    `MethodResolver`, and `PropertyAccessor` objects and redefine how SpEL evaluates
    expressions. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| `SpelCompiler` | Compiles a regular parsed expression instead of the interpreted
    form to a class containing bytecode for evaluation. A far faster method, but still
    at an early stage, it does not yet support every kind of expression as of Spring
    4.1. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: 'Let''s take a look at an example that evaluates an expression using the SpEL
    API:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In normal scenarios, you would not need to directly use the SpEL API in a Spring
    application; SpEL with annotation or XML bean definitions would be better candidates.
    The SpEL API is mostly used to load externalized business rules dynamically at
    runtime.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Aspect Oriented Programming
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most software applications usually have some secondary—but critical—features,
    such as security, transaction, and audit-logging, spanned across multiple logical
    modules. It would be a nice idea not to mix these cross-cutting concerns in your
    core business logic. **Aspect Oriented Programming** (**AOP**) helps you achieve
    this.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Oriented Programming** (**OOP**) is about modularizing complex software
    programs, with objects as the fundamental units that hold your core business logic
    and data. AOP complements OOP to add more complex functionality transparently
    across modules of your application without polluting the original object structure.
    AOP stitches (weaves) cross-cutting concerns into your program, either at compile
    time or runtime, without modifying the base code itself. AOP lets the object-oriented
    program stay clean and just have the core business concerns.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic AOP
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In AOP, the framework weaves the cross-cutting concerns into the main program
    transparently. This weaving process comes in two different flavors: static and
    dynamic. In the case of static AOP, as the name implies, Aspects are compiled
    directly into static files, that is, to the Java bytecode, on compilation. This
    method performs better, as there is no special interception at runtime. But the
    drawback is that you need to recompile the entire application every time you change
    anything in the code. AspectJ, one of the most comprehensive AOP implementations,
    provides compile-time weaving of Aspects.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: In the case of dynamic AOP, the weaving process is performed dynamically at
    runtime. Different frameworks implement this differently, but the most general
    way of achieving this is using proxies or wrappers for the advised objects, allowing
    the Advice to be invoked as required. This is a more flexible method as you can
    apply AOP with varying behavior at runtime depending on data, which is not possible
    in the case of static AOP. There is no need for recompiling the main application
    code if you use XML files for defining your AOP constructs (schema-based approach).
    The disadvantage of dynamic AOP is a very negligible performance loss due to the
    extra runtime processing.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP is proxy based, that is, it follows the dynamic flavor of AOP. Spring
    provides the facility to use static AOP by integrating with AspectJ too.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: AOP concepts and terminology
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding AOP concepts and terms gives you an excellent starting point
    for AOP; it helps you visualize how and where AOP can be applied in your application:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '**Aspect**: The concern that cuts across multiple classes or modules. Transaction
    and security are examples. Spring Transaction is implemented as Aspects.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Join point**: A point during the execution of the program at which you want
    to insert additional logic using AOP. A method execution and a class instantiation
    are examples.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advice**: The action taken by (the code or method that executes) the Aspect
    at a particular join point. Different types of advices include `before`, `after`,
    and `around` advices. Typically, an Aspect has one or more Advices.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointcut**: An expression that defines or matches a set of join points. The
    Advice associated with a pointcut executes at any join point it matches. Spring
    supports the AspectJ pointcut expression language by default. An example is `execution(*
    com.xyz.service.*.*(..))`.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target object**: The advised object. If you use dynamic AOP, this would be
    a proxied object.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weaving**: Inserting Aspects into a target object to make it advised at compile
    time, load time or runtime. AspectJ supports compile-time weaving and Spring weaves
    at runtime.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduction**: The process by which you add a new method or field to an
    advised object, with or without making it implement an interface.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring AOP – definition and configuration styles
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring provides a proxy-based dynamic implementation of AOP, developed purely
    in Java. It neither requires a special compilation process like AspectJ nor controls
    the class loader hierarchy, hence it can be deployed inside any Servlet container
    or application server.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Although not a full-blown AOP framework like AspectJ, Spring provides a simple
    and easy-to-use abstraction of most of the common features of AOP. It supports
    only method execution join points; field interception is not implemented. Spring
    provides tight integration with AspectJ, in case you want to advise very fine-grained
    Aspect orientation that Spring AOP doesn't cover by adding more AspectJ-specific
    features without breaking the core Spring AOP APIs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP uses standard JDK dynamic proxies for Aspect orientation by default.
    JDK dynamic proxies allow any interface (or set of interfaces) to be proxied.
    If you want to proxy classes rather than interfaces, you may switch to CGLIB proxies.
    Spring automatically switches to use CGLIB if a target object does not implement
    an interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Spring 2.0, you can follow either a schema-based approach or an
    `@AspectJ` annotation style to write custom Aspects. Both of these styles offer
    fully typed Advice and use of the AspectJ pointcut language while still using
    Spring AOP for weaving.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: XML schema-based AOP
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using schema-based AOP, you need to import `aop` namespace tags into your
    `application-context` file, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '@AspectJ annotation-based AOP'
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@AspectJ` refers to a style of declaring Aspects as regular Java classes that
    are annotated. Spring interprets the same annotations as AspectJ 5, using a library
    supplied by AspectJ for pointcut parsing and matching. Spring AOP has no dependency
    on the AspectJ compiler or weaver, though.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `@AspectJ` annotation style, you first need to enable `@AspectJ`
    support in your Spring configuration, whether or not it is in the XML or Java
    configuration. Additionally, you need to make sure you add `aspectjweaver.jar`
    in your classpath. Adding an `@EnableAspectJAutoProxy` annotation to your Java
    `@Configuration` annotation will enable `@AspectJ` support in your project:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Alternatively, if you use XML-based configuration, `@AspectJ` support can be
    enabled by adding the `<aop:aspectj-autoproxy/>` element in your `application-context`
    file.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an @Aspect annotation
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Aspect is a simple POJO, either annotated with `@Aspect` (`org.aspectj.lang.annotation.Aspect`)
    or declared as `<aop:aspect/>` under the `<aop:config>` section of your `application-context`
    XML file. Remember, the class marked as `@Aspect` should be declared as a Spring
    bean using either an annotation or `<bean/>` declaration in your application context
    XML file.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an annotated Aspect, a Spring component annotated as `@Aspect`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that `@Aspect` is a Spring bean too. It can be any of the specializations
    of `@Component`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the XML alternative for Aspect declaration:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Aspects may have methods and fields, just like any other class. They may also
    contain pointcut, advice, and introduction (inter-type) declarations. Aspects
    themselves cannot be the target of Advice from other Aspects; they are excluded
    from auto-proxying.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Pointcuts
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A pointcut comprises two parts, as shown in the following code snippet: a method
    signature (an empty method with a `void` return type inside the `Aspect` class)
    with any parameters and an expression that matches the exact method executions
    we are interested in. Remember, Spring AOP only supports method execution join
    points:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The pointcut expression follows the standard AspectJ format. You may refer to
    the AspectJ pointcut expression reference for the detailed syntax. The following
    section gives you a strong foundation for constructing pointcuts for Spring AOP.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut designators
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Spring AOP supports just a subset of the original AspectJ **pointcut designators**
    (**PCDs**) for use in pointcut expressions, as given in the following table:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '| PCD | Description |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| `execution` | Method execution join point; the default PCD for Spring AOP
    |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| `within` | Matches methods in a range of types, packages, and so on |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| `this` | Matches proxy instances of a given type |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| `target` | Matches target object with a given type |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| `args` | Matches methods with the given argument types |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| `@target` | Matches methods of classes with the given annotation |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| `@args` | Matches methods having argument (s) with the given annotation (s)
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| `@within` | Matches methods within types that have a given annotation |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| `@annotation` | Matches methods with the given annotation |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: In addition to the preceding table, Spring supports an extra non-AspectJ PCD,
    `bean`, which is useful to directly refer to a Spring bean or a set of beans with
    a comma-separated list of beans using `bean(idsOrNamesOfBean)`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Note that the pointcuts intercept only `public` methods due to the proxy nature
    of Spring AOP. If you want to intercept `protected` and `private` methods or even
    constructors, consider using AspectJ weaving (integrated with Spring itself) instead.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut examples
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pointcut expressions can be combined using `&&`, `||`, and `!`. You can refer
    to pointcut expressions by name, too. Let''s see a few examples:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An XML version of a pointcut definition goes like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Advices
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Advice is the action that gets injected before, after, or around the method
    executions matched by the pointcut expression. The pointcut expression associated
    with an Advice could be a named or defined pointcut, as listed in the above examples,
    or a pointcut expression declared in place, that is, advices and pointcuts can
    be declared together.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example for an Advice that refers to a pointcut expression named
    `Pointcut`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following code listing combines both a join point and Advice in one go.
    This is the most common approach:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following table lists the available Advice annotations:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '| Advice annotation | Description |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '| `@Before` | Runs before method execution. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: '| `@After` | Runs after method exit (finally). |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| `@AfterReturning` | Runs after the method returns without an exception. You
    can bind the return value with the Advice as the method argument. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| `@AfterThrowing` | Runs after the method exits by throwing an exception.
    You can bind the exception with the Advice as the method argument. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| `@Around` | The target method actually runs inside this Advice. It allows
    you to manipulate the method execution inside your Advice method. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: The @Around Advice
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `@Around` Advice gives you more control over method execution, as the intercepted
    method essentially runs inside your Advice method. The first argument of the Advice
    must be `ProceedingJoinPoint`. You need to invoke the `proceed()` method of `ProceedingJoinPoint`
    inside the Advice body in order to execute the target method; else, the method
    will not get called. After the method execution returns to you with whatever it
    returns back to your advice, do not forget to return the result in your Advice
    method. Take a look at a sample `@Around` advice:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Accessing Advice parameters
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two distinct ways of accessing the parameters of the method you are
    advising in the Advice method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a join point as the first argument
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding `args` in the pointcut definition
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the first approach:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can see that `joinpoint.getArgs()` returns `Object[]` of all the arguments
    passed to the intercepted method. Now, let''s see how to bind named arguments
    to the Advice method:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note that the `joinpoint` expression matches the arguments by name. You can
    have a `joinpoint` object as an optional first argument in the method signature
    without specifying it in the expression: you will have both `joinpoint` and arguments,
    enabling more manipulation.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Spring
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The degree of testability shows the elegance and maturity of any framework.
    A more testable system is more maintainable. Spring Framework provides comprehensive
    support for end-to-end testing of applications for both unit testing as well as
    integration testing. Spring promotes **test-driven development** (**TDD**), facilitates
    integration testing, and advocates a set of best practices for the unit testing
    of beans. This is another compelling reason for using Spring to build serious
    applications.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The POJO-based programming model and loosely coupled nature of Spring beans
    make it easier to participate in JUnit and TestNG tests even without Spring in
    the middle. On top of this, Spring provides many testing support components, utilities,
    and mock objects to make the testing easier.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring provides mock implementations of many container-specific components so
    that the beans can be tested outside a server or container environment. `MockEnvironment`
    and `MockPropertySource` are useful for testing environment-dependent beans. To
    test beans that depend on HTTP communications, Spring provides mock classes for
    both client and server sides inside the `org.springframework.mock.http` and `org.springframework.mock.http.client`
    packages.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Another set of useful classes can be found under `org.springframework.mock.jndi`
    to run test suites that depend on JNDI resources. The `org.springframework.mock.web`
    package contains mock objects for web components based on Servlet 3.0, such as
    web contexts, filters, controllers, and asynchronous request processing.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Unit and integration testing utilities
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring ships certain general-purpose and context-specific utilities for unit
    and integration testing. The `org.springframework.test.util` package contains
    a set of utility classes for various testing purposes, including reflection, AOP,
    JSON, and XML manipulations. Classes under `org.springframework.test.web` and
    its nested subdirectories contain a comprehensive set of utility classes to test
    beans dependent on the web environment. Another set of useful classes for usages
    specific to `ApplicationContext` can be found under `org.springframework.test.context`
    and its child packages. Their support includes the loading and caching of web,
    portlet, or application contexts in the test environment; resolving profiles;
    loading property sources and SQL scripts; managing transactions for test environments;
    and so on.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: The support classes and annotations under the packages listed earlier facilitate
    the easy and natural testing of Spring applications. A comprehensive discussion
    over Spring test support is beyond the scope of this book. However, gaining a
    good understanding of Spring's comprehensive support for unit and integration
    tests is vital in order to develop elegant code and maintainable applications
    using Spring.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully covered all the major technologies and concepts of core
    Spring Framework in this chapter. We are now capable of developing robust, standalone
    Spring applications composed of loosely-coupled beans inside the powerful Spring
    IoC container. We know how to apply cross-cutting concerns transparently across
    different layers of an application using the very flexible pointcut expressions
    of Spring AOP. We can manipulate Spring beans using Spring Expression Language,
    which helps keep the code clean and highly maintainable. We learned how to maintain
    multiple environment-specific bean configurations and property files using bean
    definition profiles. Now, we are all set for professional Spring development.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: The source code available with this chapter contains multiple Spring projects
    that demonstrate the different ways of configuring Spring as well as usage scenarios.
    The examples listed in this chapter have been extracted from them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Spring Web module, leveraging all that
    we learned in this chapter in a web-based environment. The topics we have learned
    in this chapter are going to be the foundation for all the advanced topics that
    will be covered in the following chapters.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Building the Web Layer with Spring Web MVC
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web application development is a major focus area for enterprise systems. In
    this age of cloud and big data, web applications are under a tremendous load of
    an ever-increasing number of concurrent users accessing them from multiple devices
    such as mobiles and tablets, as well as traditional desktop web browsers. Modern
    web applications have to address a newer set of nonfunctional requirements, such
    as scalability, performance, productivity, responsiveness, and multi-device support.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is a web framework from Spring, perfectly built from the ground up
    to address the concerns of modern web applications. A lightweight and high-performance
    web framework, Spring MVC is designed to be highly productive from day one, flexible,
    and adaptable with a wide variety of view technologies. Sitting on top of the
    mighty Spring Framework, it integrates well with all Java EE technologies and
    other open source frameworks. Just like any technology under the Spring portfolio,
    Spring MVC also promotes POJO programming with the help of a well-defined set
    of annotations, namespace XML tags, and web-support components.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces Spring MVC and its powerful features to you, describes
    how to set it up, and guides you on its advanced usages, configurations, and optimizations
    with relevant examples. We will mostly use annotations in these examples for simplicity.
    At the end of this chapter, you will be able to build web applications with Spring
    MVC that have HTML-based user interfaces as well as RESTful APIs with JSON and
    XML formats.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Features of Spring MVC
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC bundles a compelling set of features and advantages over rival web
    technologies. Knowledge of these will help you decide on choosing Spring MVC for
    your requirements. The following list covers most of them:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Simple configuration and native integration with Spring Framework, leveraging
    the powerful features of Spring and other open source libraries
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built on top of Java web technologies such as Servlets, JSP, and JSTL and can
    be deployed into any standard Servlet container, such as Tomcat
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented based on the **Model-View-Controller** (**MVC**) architecture pattern,
    with clear separation of concerns using simple annotations and namespace XML tags
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit support for convention over configuration for MVC components
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports a big set of view technologies, such as JSP, Thymeleaf, Handlebars,
    Velocity, FreeMarker, PDF, Excel, and JasperReports
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative input validation, data binding, and exception handling
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible URL mapping with automatic request and response transformation into
    various formats such as JSON, XML, and HTML
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for non-blocking asynchronous request processing and HTTP streaming
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for internationalization, themes, and multipart file uploads
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy integration with Spring Security and thorough testability
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP caching for increased performance
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple, yet powerful, JSP tag library
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes Spring MVC outstanding is its simple programming model, a feature
    inherited from the core Spring Framework itself. A developer familiar with any
    standard web framework will find Spring MVC very familiar and easy to learn.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller pattern
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC is a well-established architectural pattern popularly used for building
    interactive web and desktop applications. There are numerous frameworks implementing
    this pattern in most software platforms. MVC divides the application into three
    core elements that actually represent layers, separates concerns between these
    three core elements, and defines how they communicate with each other.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '![The Model-View-Controller pattern](img/image00781.jpeg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
- en: '**Model** represents data, **View** displays the **Model**, and **Controller**
    handles user actions. Model can be any data, including that stored in a database.
    It usually represents a collection of domain objects with clearly defined relationships
    to each other. A **Model** can be displayed in multiple views depending on how
    the application is designed.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller** acts as an intermediary between **View** and **Model**. It often
    has a set of handlers for each event generated by the view as the user interacts
    with it. **Controller** delegates user actions to appropriate handlers and then
    finally redirects to another view for displaying the result of that action.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: There are so many implementations of the MVC pattern as frameworks across technology
    platforms use it in different ways. Spring MVC has implemented it in the simplest
    and least invasive fashion, while naturally integrating it with the core Spring
    Framework.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Your first Spring MVC application
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump to creating a very simple Spring MVC web application. For the purpose
    of learning, we will develop the web version of *Taskify*, the task management
    system we started in [Chapter 1](part0012.xhtml#aid-BE6O1 "Chapter 1. Getting
    Started with Spring Core"), *Getting Started with Spring Core*. The samples in
    this chapter use **Spring Tool Suite** (**STS**) as the IDE, but you can use your
    favorite IDE, such as IntelliJ and NetBeans. Almost all Java IDEs support Spring
    development; most of them have plugins to manage Spring projects and artifacts.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, follow these steps; then, we will explore the code:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Open STS or Eclipse → create a new project → type a project name → select a
    template, either **Spring MVC Project** or **Simple Spring Web Maven** → specify
    the top-level package name → finish. Your project structure will be generated.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your `pom.xml` file contains Maven dependencies for the `spring-context`,
    `spring-mvc`, `servlet-api`, `jsp-api`, and `jstl` libraries. Note that `jsp-api`
    and `jstl` are required only if you are using JSP as the view technology.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If it hasn''t been generated, create `web.xml` under `WEB-INF`, with the following
    content:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If it hasn''t been generated, create a `root-context.xml` file, with the following
    content:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If it hasn''t been generated, create a `servlet-context.xml` file, with the
    following content:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, create a Java class, `HomeController`, under the package `com.taskify.web.controllers`,
    with the following content:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a JSP view, `home.jsp`, under `~WEB-INF/views`, with the following content:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Make sure you have the `TaskService` class (copy it from [Chapter 1](part0012.xhtml#aid-BE6O1
    "Chapter 1. Getting Started with Spring Core"), *Getting Started with Spring Core*)
    and its concrete implementation in your project, with the methods `findAllTasksCount()`
    and `findAllOpenTasksCount()` implemented.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your project is ready, make sure you have an Apache Tomcat (or any
    other) server installed and configured with your IDE. You can download Tomcat
    from [http://tomcat.apache.org/](http://tomcat.apache.org/) and install on your
    PC.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: STS and Eclipse allow you to run Java web apps from the IDE just by right-clicking
    **Run As** → **Run on Server**. Resolve all errors, if any, and run again.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the home screen of your web app (at `http://localhost:8080/chapter2/`),
    as seen here:![Your first Spring MVC application](img/image00782.jpeg)
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up a Spring MVC application
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's figure out how a Spring MVC web application is configured by analyzing
    the application artifacts listed in the previous section, *Your first Spring MVC
    application*. It contains all the necessary artifacts for building a Spring MVC
    web app.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: The project structure of a Spring MVC application
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to create the project structure and the necessary artifacts
    is using STS to create a Spring MVC project, as described in the previous section.
    Alternatively, you may use one of the Maven archetypes available in various repositories
    online. STS uses such a bundled archetype. Here is the typical project structure
    of a Spring MVC application as viewed in STS:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '![The project structure of a Spring MVC application](img/image00783.jpeg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
- en: This structure represents a single-WAR web application where all the services
    and data access components are collocated with the web controllers. In the case
    of bigger applications, many such components could be part of a different JAR
    library project, to be shared between multiple web apps and then added as Maven
    dependencies to the consuming web apps and beans imported to the web application
    context XML files using an `<import/>` tag or annotation config.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine each artifact listed in *Your first Spring MVC application*
    in detail.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The web.xml file – Springifying the web app
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web.xml` file is the standard Java web descriptor in which the fundamental
    web components that make up a Java web application are registered with the Servlet
    container. `ServletContextListener`, and `ServletFilter` components are configured
    here.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: A Spring MVC application is also configured and bootstrapped in `web.xml`. `ContextLoaderListener`,
    registered as a `ServletContextListener` in the `web.xml` sample, bootstraps Spring's
    root `WebApplicationContext`. In the previous chapter, we saw how a simple console
    application bootstraps the Spring context from inside the main method using `ClassPathXmlApplicationContext`.
    In the case of a web application, following `ContextLoaderListener` loads the
    `WebApplicationContext`. Remember, a Spring MVC application is not just another
    Servlet-based application but rather Spring integrated within a web context.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following listener looks for a `context-param` tag, `contextConfigLocation`,
    which is the location of the Spring root bean definition XML file, as seen in
    the `web.xml` file earlier:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The next very important Spring component configured in the `web.xml` file is
    `DispatcherServlet`, the centralized entry point into the Spring MVC application
    which maps every request with appropriate handlers. `DispatcherServlet` is an
    implementation of the Front Controller design pattern, which is a single, centralized
    entry-point for all HTTP requests that come into the application. This internally
    delegates them to the actual handler of the request type. Here is an excerpt from
    the earlier `web.xml` listing:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding Servlet registration of `DispatcherServlet` maps the root URL
    to `DispatcherServlet` so that every HTTP request that comes into the server will
    be first handled by `DispatcherServlet`. Additionally, it specifies where the
    Spring application context file for this Servlet will be.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your application can have any number of `DispatcherServlet` definitions with
    unique Servlet names, depending on how you want to divide your URL subcontexts
    logically based on your functional modules. Most applications would have just
    one `DispatcherServlet` defined.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: ApplicationContext files in a Spring MVC application
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Spring MVC application is nothing but a Servlet-based Web MVC implementation
    with Spring integrated natively. Hence, it requires Spring bean definitions like
    any other Spring application, as we have seen in the previous chapter. In the
    case of a Spring MVC application, there would be some framework-specific beans
    in addition to application-specific beans registered in the context.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of organizing beans under different logical categories, such as
    web-specific (`DispatcherServlet`) as well as shared beans, multiple bean definitions
    can be used. For example, `DispatcherServlet` can have its own application context
    file with beans helping its processing (just for the web context), and there could
    be a root application context file, where beans that are not specific to the web
    layer but shared between many layers are defined.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Inside the sample listed in the earlier section as part of *Your first Spring
    MVC application*, you can see two Spring bean definition XML files, `root-context.xml`
    and `servlet-context.xml`. The `root-context.xml` file represents your root `WebApplicationContext`
    loaded via `ContextLoaderListener`. This is the place where you define or import
    your shared beans, such as service beans, and data access objects.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The `servlet-context.xml` file is loaded by `DispatcherServlet` on startup.
    The filename, `servlet-context.xml`, is an explicit filename given in the sample
    listing. By default, `DispatcherServlet` looks for an XML bean definition file
    with the pattern `[servlet-name]-servlet.xml`, that is, if it wasn't specified
    explicitly, `appServlet` would look for a file with the name `appServlet-servlet.xml`
    at the root of the `WEB-INF` folder. Typically, this file contains the bean definitions
    controlling the behavior of this Servlet. For example, you can see the resources
    and view resolver bean definitions in the file `servlet-context.xml`. You can
    see that the view resolver configured in the sample listing only supports JSP
    views.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: HomeController – @Controller for the home screen
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HomeController` is a simple POJO with the `@Controller` annotation. This annotation
    registers it as a web controller with a set of annotated handler methods inside
    it. It can have an `@RequestMapping` annotation at the class level to indicate
    the root URL of all handler methods in it. The method `home()` is the request
    handler for the root URL, `http://<context-root>/`.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Since the `@Controller` annotation is yet another Spring bean, you can inject
    any other bean into it as a dependency. The sample listing shows that `HomeController`
    has an autowired dependency to `TaskService`. In the `home()` method, `TaskService`
    methods are invoked, and finally, the return values are set as `Model` attributes
    for the consumption of the latter parts of the request and to be used in a view.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Your application will have many such controllers that serve groups of related
    URL endpoints; consider `HomeController` as your basic example. One controller
    can have multiple request-handling methods that serve different URLs.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: The home.jsp file – the landing screen
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `home.jsp` file is your view artifact for the root (`/`) URL. Notice how
    the `Model` attributes are bound inside the JSP view:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Handling incoming requests
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any request that hits the root URL of the app is first received by `DispatcherServlet`,
    which delegates it to `HomeController.home()`, which processes the request and
    returns the view name (`home`, in this case). `DispatcherServlet` then picks up
    the `home.jsp` file based on the resource and view configurations specified in
    `servlet-context.xml` and renders it, passing the attributes of the model instance
    created inside `HomeController.home()`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: The architecture and components of Spring MVC
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having gone through your first Spring MVC application, it is now time to look
    at Spring MVC applications from an architectural perspective:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '![The architecture and components of Spring MVC](img/image00784.jpeg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
- en: Spring MVC components
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, Spring MVC follows the renowned MVC architectural pattern.
    This pattern ensures the separation of concerns by dividing responsibilities into
    three major roles:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This represents data and business logic'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This represents presentation'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This processes client requests and delegates them to the view
    for rendering back to the client'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Model** we are talking about here is not necessarily persistent data (a
    data model) as such; rather, it represents the information passed back and forth
    between the client and different layers of the server application, which form
    the building blocks of any system.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Besides the **Model**, **View**, and **Controller** components, `DispatcherServlet`
    too plays a crucial role in the Spring MVC architecture. It acts as the Front
    Controller, a popular J2EE design pattern adopted by many MVC Frameworks. In fact,
    `DispatcherServlet` does much more than just a Front Controller. It will be explained
    in detail in the next section.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring MVC application, `DispatcherServlet` first receives a client request
    hitting the server via HTTP with a URL. With the help of the `HandlerMapping`
    configuration, `DipatcherServlet` finds the appropriate **Controller** method
    for the request based on the URL pattern and delegates the request to it. The
    Controller processes the request, optionally fills in the **Model** object, and
    returns the name of the **View** to be rendered. `DispatcherServlet` then picks
    the **View** up and renders it back on the client after applying the attributes
    of the **Model** to the placeholders in the **View**.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: What's mentioned in the previous paragraph is simply the typical request processing
    flow of Spring MVC. However, it is extremely flexible, with a great many options
    to support different types of view technologies and input and output structures
    and formats, including files, streams, and so on. We will explore them more in
    the following sections.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: DispatcherServlet explained
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DispatcherServlet` is the gateway to any Spring MVC application. Inherited
    from `javax.servlet.http.HttpServlet`, it is typically configured declaratively
    in the `web.xml` file. While you can have multiple definitions of `DispatcherServlet`
    with unique URL patterns, most Spring MVC applications only have single `DispatcherServlet`
    with the `context-root` URL(`/`), that is, all requests coming to that domain
    will be handled by `DispatcherServlet`.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from Servlet 3.0, in addition to declarative configuration in the
    `web.xml` file, `DispatcherServlet` can be configured programmatically by implementing
    or extending either of these three support classes provided by Spring:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The `WebAppInitializer` interface
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AbstractDispatcherServletInitializer` abstract class
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AbstractAnnotationConfigDispatcherServletInitializer` abstract class
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code listing demonstrates how to implement a `WebAppInitializer`
    directly in your application:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: WebApplicationContext – ApplicationContext for the Web
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DispatcherServlet` uses a specialized `ApplicationContext` called `WebApplicationContext`
    that has many web request processing capabilities. It is aware of which `ServletContext`
    it is associated with and is also capable of resolving themes. This interface
    has concrete implementations for specific contexts such as XML, `@Configuration`
    annotated classes, and portlets. By default, `DispatcherServlet` uses `XMLWebApplicationContext`.
    When `DispatcherServlet` is loaded, it looks for the bean configuration file of
    `WebApplicationContext` and initializes it.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '`WebApplicationContext` objects are hierarchical. Every Spring MVC application
    has root `ApplicationContext` (configurable with a `context-param` tag called
    `contextConfigLocation` in the `web.xml` file), and each Servlet, including `DispatcherServlet`,
    has its own child context (configurable by its own `init-param`, `contextConfigLocation`).
    Ideally, Servlet-specific child contexts have beans customizing that Servlet,
    and root `ApplicationContext` has all shared beans.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Beans supporting DispatcherServlet and their roles
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upon receiving a web request, `DispatcherServlet` performs a set of operations
    in sequence as part of the request processing, with the help of a set of supporting
    beans. This table lists these special beans and their responsibilities:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '| Bean | Responsibilities |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
- en: '| `HandlerMapping` | Maps incoming web requests to handlers and pre- and post-processors
    |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
- en: '| `HandlerAdapter` | Invokes the handler which resolves arguments and dependencies,
    such as annotated arguments for URL-mapped controller method endpoints |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
- en: '| `HandlerExceptionResolver` | Allows programmatic handling of exceptions and
    maps exceptions to views |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| `ViewResolver` | Resolves logical view names to view instances |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| `LocaleResolver` | Resolves the client''s locale in order to enable internationalization
    |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: '| `LocaleContextResolver` | A richer extension of `LocaleResolver`, with timezone
    information |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
- en: '| `ThemeResolver` | Resolves themes configured in your app for enhanced user
    experience |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
- en: '| `MultipartResolver` | Handles multipart file uploads as part of HTTP requests
    |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
- en: '| `FlashMapManager` | Manages FlashMap instances that store temporary Flash
    attributes between requests redirected from one another |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
- en: '`DispatcherServlet` is extremely flexible; we can even create and configure
    custom implementations for all these beans. However, Spring MVC provides a set
    of nice implementations by default so that you don''t need to customize or provide
    your own implementations unless absolutely required. These default implementations
    can be found inside `org.springframework.web.servlet.DispatcherServlet.properties`.
    If you override them with your own implementation of any of these beans, yours
    will override the defaults.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Controllers in detail
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers, with their methods annotated with `@RequestMapping`, handle web
    requests. They accept input data in multiple forms and transform them into `Model`
    attributes to be consumed by views that are displayed back to the client. They
    connect the user to service-layer beans, where your application behavior is defined.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'A Controller in Spring MVC has the following signature:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A Controller is designed as an interface, allowing you to create any kind of
    implementation. Starting from Spring version 2.5, you can turn any class into
    a Controller just by annotating it with `@Controller`. It relieves you from implementing
    any specific interface or extending a framework-specific class:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `@Controller` annotation assigns the role of a Controller to the given
    class. A Spring MVC application autodetects all the controllers in its classpath
    and registers them with `WebApplicationContext` if you enable component scanning,
    as shown here:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`@Controller`, `@RequestMapping`, and a set of other annotations form the basis
    of Spring MVC. These annotations allow flexible method names and signatures for
    controllers. We will explore them in detail in the following section.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Mapping request URLs with @RequestMapping
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@RequestMapping` annotation maps request URLs onto an entire `@Controller`
    class or its handler methods. It can be applied at the class as well as the method
    levels. Typically, you apply class-level `@RequestMapping` annotation to map a
    group of related URLs, such as a form with many actions, and method-level `@RequestMapping`
    annotation for specific actions, such as create, read, update, delete, upload,
    and download. Let''s take a look at a typical form-based Controller with various
    actions in a pure REST model (`GET`, `POST`, `PUT`, and `DELETE`):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`UserController`, listed in the preceding code, has methods that serve as request
    handlers for URLs representing CRUD operations on user entities with the help
    of `UserService`, which is injected as a dependency into the Controller. Since
    this Controller is based on web views, the handler methods fill up the Model and
    returns either a view name or `ModelAndView` object for further display. The final
    two handler methods, `updateUser()` and `deleteUser()`, redirect the requests
    at the end. They perform URL redirection after returning the response to the client.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `UserController` has a root URL (`/user`) and handler methods have
    a more narrow mapping with a combination of HTTP methods. They are invoked by
    the exact URLs seen in the following table:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | Handler method | HTTP method | Matching URL (sample) |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
- en: '| `/` | `listAllUsers` | `GET` | `http://localhost:8080/user` |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '| `/new` | `newuserForm` | `GET` | `http://localhost:8080/user/new` |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| `/new` | `saveNewUser` | `POST` | `http://localhost:8080/user/new` |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: '| `/{id}` | `viewUser` | `GET` | `http://localhost:8080/user/123` |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
- en: '| `/{id}/edit` | `editUser` | `GET` | `http://localhost:8080/user/123/edit`
    |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
- en: '| `/{id}` | `updateUser` | `PUT` | `http://localhost:8080/user/123` |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: '| `/{id}` | `deleteUser` | `DELETE` | `http://localhost:8080/user/123` |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
- en: 'The HTTP methods `GET` and `POST` are supported by default, in line with the
    limited HTML (hence browser) support for the other two. However, for `PUT` and
    `DELETE` to work, you need to register `HiddenHttpMethodFilter` in your `web.xml`
    file. Use this code:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`HiddenHttpMethodFilter` works even without Spring MVC; you can use it with
    any Java web framework or even a plain Servlet application.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: URI template patterns with the @PathVariable annotation
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the sample `UserController` listing in the preceding code, you might have
    noticed templated URL patterns with variable names replaced by values when handling
    requests. See this, for example:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, the templated variable, `id`, is mapped to an `@PathVariable` annotation.
    It is enclosed inside curly braces and annotated as a method argument for mapping.
    A URL can have any number of path variables. They support regular expressions
    as well as path patterns in the Apache Ant style. They help you build perfect
    URI endpoints in the classic REST model.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Binding parameters with the @RequestParam annotation
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Request parameters that are inline with URI strings can be mapped with method
    arguments using the `@RequestParam` annotation. See the following excerpt from
    `TaskController`:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A typical URL invoking the above handler is `http:<context-root>/tasks?status=Open`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestParam` has four attributes: `name`, `required`, `value`, and `defaultValue`.
    While `name` is a mandatory attribute, all the others are optional. By default,
    all request parameters are required to be set to `true`, unless you specify them
    as `false`. Values of `@RequestParam` are automatically type-converted to parameter
    types by Spring.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Request handler method arguments
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@RequestMapping` methods can have flexible method signatures; a mix of
    frameworks, custom objects, and annotations are supported. They are injected automatically
    during request processing if found as method arguments. Here is a list of a few
    supported framework classes and annotations; refer to the Spring official documentation
    or the Javadoc of `RequestMapping` for the complete list.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '| Supported classes | Annotations |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.ServletRequest` | `@PathVariable` |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.ServletRequest` | `@RequestVariable` |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
- en: '| `javax.servlet.http.HttpSession` | `@RequestParam` |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.ui.Model` | `@RequestHeader` |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.validation.BindingResult` | `@RequestBody` |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
- en: '| `Java.util.Map` | `@RequestPart` |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
- en: '| `Java.io.InputStream` | `@InitBinder` |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
- en: While the framework classes do not need any specific annotation, custom classes
    often need to accompany one of the supported annotations for the handler adapters
    in order to convert/format from the incoming web request object into the class
    instances.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Request handler method return types
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to flexible argument types, methods annotated by `@RequestMapping`
    can have either custom types (often annotated as `@ResponseBody`) or one of the
    many supported framework classes. The following list contains some of the many
    supported types:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '`org.springframework.web.servlet.ModelAndView`'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.ui.Model`'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Map`'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.web.servlet.View`'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void`'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.concurrent.Callable<?>`'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.http.HttpEntity`'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Model attributes
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Model` attributes are for the consumption of the view for display and binding
    with form elements. They can be set at both the controller and handler method
    level.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'Any method with a non-void return type can be annotated as `@ModelAttribute`
    to make the method return type a `Model` attribute for all views resolved by the
    declared Controller. See an example:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Model attributes specific to a view are set inside the handler method from
    where the view was resolved. Here is an example:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Building RESTful services for JSON and XML media
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web application often needs to expose some of its services as web APIs with
    the XML or JSON data formats, or both, for the consumption of AJAX requests from
    browsers as well as other devices, such as mobile and tablets.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '**REpresentational State Transfer** (**REST**), is an established architectural
    style for building web APIs that align with native web protocols and methods.
    With REST, data is represented as resources that can be accessed and manipulated
    using a URI over the stateless protocol of HTTP. REST insists on the mapping of
    the create, read, update, and delete operations (CRUD) around a resource with
    the HTTP methods `POST`, `GET`, `PUT`, and `DELETE`, respectively.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC makes it extremely easy to build simple API endpoints that consume
    and produce different media types such as text, JSON, and XML. A request handler
    method in an `@Controller` annotation can accept JSON, XML, or any other media
    type using the following two steps:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Set the attribute `consumes` to the appropriate media type(s) at the `RequestMapping`
    method, for example, `consumes = {"text/plain", "application/json"})`.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the method argument of the required type with `@RequestBody`. The web
    request is expected to contain the data in the format mentioned in step 1 (`consumes`;
    JSON, XML, and so on) and is resolved to this type by `HttpMessageConverter` during
    handling.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, the request handler method can produce JSON, XML, or any other media
    type using the following two steps:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Set the attribute `produces` with the appropriate media type(s) at the `RequestMapping`
    method, for example, `consumes = {"text/plain", "application/json"})`.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the return type of the handler method or the method declaration itself
    (next to `@RequestMapping`) with `@ResponseBody`. The handler will transform the
    return value into the data format specified in the `produces` attribute of `RequestMapping`.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `consumes` and `produces` attributes of `RequestMapping` narrow down the
    primary mapping to the given media type (for example, `consumes = "application/xml"`)
    or a sequence of media types (for example, `consumes = {"text/plain", "application/json"}`).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the attributes, make sure the following library exists in the
    `pom.xml` file:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here is an example handler method that accepts a JSON request and returns a
    JSON response:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This handler method expects a web request with JSON content:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, the same method could be modified slightly to support XML content, `consumes`
    as well as `produces`. Look at the following listing:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Make sure you have the JAXB annotation `@XmlRootElement` at the root of both
    `RequestBody` and `ResponseBody` types (`CreateTaskRequest` and `CreateTaskResponse`
    in this case).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke the preceding XML handler by sending the following content with
    the web request to the handler URI:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Building a RESTful service with RestController
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RestController` is a convenient stereotype provided for building REST API
    endpoints that serve custom media types such as JSON or XML. It combines `@Controller`
    with `@ResponseBody`, that is, you do not need to annotate `@ResponseBody` in
    the handler methods. `@RequestMapping` methods assume `@ResponseBody` semantics
    by default.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the JSON handler method looks like when it becomes part of
    an `@RestController` annotation:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that the only difference in the mapping is the missing `@ResponseBody`
    annotation. It is best practice to define your REST APIs inside REST controllers.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous request processing in Spring MVC
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an age of APIs, AJAX clients, and devices, web servers are under exponentially
    growing traffic. Figuring out ways to make servers more scalable is an ongoing
    challenge for server vendors. The traditional **one thread per HTTP connection**
    strategy does not scale well for a bigger number of concurrent user access. In
    this model, every request blocks a thread from the thread pool allocated by the
    Servlet container until the request is completely processed (the examples shown
    so far follow this model). When AJAX clients—where a single screen frequently
    fires multiple concurrent connection requests—join the traditional, blocking I/O
    model of web servers with long-running processes, servers easily get exhausted
    due to the thread starvation problem, since no free thread is available in the
    pool. This makes the application unavailable on increased load.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous HTTP request processing is a technique that utilizes the non-blocking
    I/O capability of the Java platform's NIO API. In this model, a server thread
    is not constantly attached to a persistent HTTP connection during the whole request
    processing. The Servlet container releases the container thread as soon as the
    request is received and further processing is delegated to a thread managed by
    another application (Spring, in this case) so that the container thread is free
    to serve new incoming requests. This non-blocking request processing model saves
    a lot of server resources and steadily increases the scalability of the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'Servlet 3.0 introduced asynchronous processing support, and Spring has implemented
    this support starting from Spring 3.2\. As of 4.2, Spring provides two easy ways
    of defining asynchronous request handlers:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Returning a `java.util.concurrent.Callable` instance instead of a value and
    producing the actual return value form inside the `call` method of `Callable`,
    that is, a thread managed by Spring, instead of a Servlet container
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning an instance of the Spring-specific `DeferredResult` type and producing
    the actual return value form inside any other thread or external event, such as
    JMS or a Quartz scheduler
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both these methods release the container thread at the earliest possible opportunity
    and use external threads to continue long-running transactions asynchronously.
    Let''s look at an example for the first option, that is, using `Callable`:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this method, you can see that the handler method returns the `Callable` object
    immediately after receiving the request and without waiting for the `Callable.call()`
    method to execute. Spring MVC invokes the `call()` method in another thread using
    `TaskExecutor`, and the response is dispatched back to the Servlet container once
    the `call()` method returns the value.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to use `DeferredResult`:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Remember, you must enable asynchronous processing support in `DispatcherServlet`
    as well as for all Servlet filters declared in the `web.xml` file (or wherever
    you are defining them—maybe in the JavaConfig class) for it to work. The following
    code shows how you set it in `web.xml`:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You may choose any of the preceding approaches as per your convenience to enable
    asynchronous processing. Consider designing all your non-trivial services to work
    asynchronously for high scalability and performance.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Working with views
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC provides a very flexible view resolution mechanism that is fully
    decoupled from the other elements of the MVC framework. It does not force you
    to use a particular view technology; rather, it makes it easier to use your own
    favorite technology. It even allows you to mix and match multiple technologies
    at the view tier. Spring MVC provides out-of-the-box support for JPS, XSLT, and
    Velocity views.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Resolving views
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical Spring MVC application, the developer chooses a view technology
    of his choice and accordingly uses a `ViewResolver` that resolves views built
    using that technology.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: The component responsible for resolving views in a Spring MVC application is
    `org.springframework.web.servlet.ViewResolver`. It maps logical view names with
    physical view resources and the chosen view technology.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: All request-handling methods of controllers must resolve a logical view name
    by either returning a view name, a view object, or a `ModelAndView` object. The
    `org.springframework.web.servlet.View` object prepares `HttpRequest` for the consumption
    of the chosen view technology.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC comes with a set of convenient view resolvers out of the box:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '| ViewResolver | Description |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
- en: '| `AbstractCachingViewResolver` | This is a convenient base class for `ViewResolver`
    implementations. For better performance, it caches view objects once they are
    resolved. |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
- en: '| `XmlViewResolver` | This uses bean definitions from a dedicated XML file
    to resolve view definitions. The file is specified by a resource location. By
    default, it is located at `WEB-INF/views.xml`. |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
- en: '| `ResourceBundleViewResolver` | This uses bean definitions in `ResourceBundle`
    specified by the bundle basename in order to define views. The default basename
    is `views.properties`. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
- en: '| `UrlBasedViewResolver` | This resolves view names with physical resources
    in the matching URL. Its two supporting properties, prefix and suffix, help locate
    the resource. |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: '| `InternalResourceViewResolver` | This resolves Servlets and JSPs with JSTL
    support. It is a subclass of `UrlBasedViewResolver`. |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
- en: '| `VelocityViewResolver` | This resolves Velocity templates and is a subclass
    of `UrlBasedViewResolver`. |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
- en: '| `FreeMarkerViewResolver` | This resolves FreeMarker templates. It is a subclass
    of `UrlBasedViewResolver`. |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| `JasperReportsViewResolver` | This resolves JasperReport views for different
    formats, such as CSV, HTML, XLS, and XLSX. |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| `TilesViewResolver` | This resolves Tiles views for both version 2 and 3.
    |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: The sample application in this chapter uses `UrlBasedViewResolver` for resolving
    JSP views. When you use multiple view technologies in a web application, you may
    use `ResourceBundleViewResolver`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Resolving JSP views
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Java Server Pages** (**JSP**), the primary web templating technology for
    Java EE, is a simple and easy tool for the rapid development of dynamic web content
    based on JVM. Built on top of Servlet technology, JSP has direct access to the
    entire Java API. JSP makes a web page author''s life a lot easier by allowing
    him to design web pages in natural HTML format and then embed the required Java
    code inside scriptlet blocks.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Server Pages Tag Library** (**JSTL**) is a set of standardized HTML-style
    tags highly useful for JSP pages. JSTL eliminates the need to mix Java code inside
    JSP pages, thus making JSP pages much cleaner and easier to author.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC resolves JSP pages using `InternalResourceViewResolver`. In an earlier
    section, *Your first Spring MVC application*, we already configured the `ViewResolver`
    class for JSP, as follows:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Spring MVC recommends keeping your view files (JSP in this case) under the `WEB-INF`
    directory to avoid direct client access. `ViewResolver` discovers the view files
    from the physical location and caches them by default once resolved, which helps
    performance.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: Binding Model attributes in JSP pages using JSTL
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Views have access to `Model` attributes set from associated handler methods
    and controllers. These `Model` attributes can be displayed in JSP views with the
    help of JSTL. In the following example, the `Model` attribute `tasks` is listed
    using JSTL:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You may have noticed the declaration and usage of JSTL tags in the preceding
    JSP extract of the `/tasks/list.jsp` view. Here is how it would be rendered with
    proper styling in a browser:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding Model attributes in JSP pages using JSTL](img/image00785.jpeg)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
- en: Spring and Spring form tag libraries
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring bundles a set of tags for the easier authoring of plain JSP pages and
    JSP forms, defined in `spring.tld` and `spring-form.tld` respectively. `spring.tld`
    describes general-purpose JSP tags commonly used in JSP pages, listed in the following
    table:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '| Spring tag | Description |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
- en: '| `<spring:bind/>` | This allows the data binding of an attribute given in
    the bind path of a locally declared bean or a `Model` attribute and provides a
    `BindStatus` object to the enclosed body content. |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
- en: '| `<spring:escapeBody/>` | This applies HTML escaping and JavaScript escaping
    for the body. |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
- en: '| `<spring:hasBindErrors/>` | This provides an error instance if there are
    bind errors. |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
- en: '| `<spring:htmlEscape/>` | This sets an HTML escape value for the current JSP
    page. |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
- en: '| `<spring:message/>` | This displays a message for a given code, usually resolved
    from a resource bundle. |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
- en: '| `<spring:nestedPath/>` | This sets a nested path of `ModelAttribute` to the
    `<spring:bind/>` tags enclosed inside. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
- en: '| `<spring:theme/>` | This loads the theme resource using the given code. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
- en: '| `<spring:transform/>` | This transforms properties inside the `<spring:bind/>`
    tag and exports them to a variable in a given scope. |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| `<spring:url/>` | This creates a URL with URI template variables. It is modeled
    after the JSTL `c:url` tag. |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| `<spring:eval/>` | This evaluates SpEL expressions. |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: 'Spring `form` tags provide data binding for HTML forms. They have tight integration
    with request handlers in controllers. Generally, they represent similarly named
    HTML `form` elements and share common attributes:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '| Form tag | Sample |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: '| `<form:input/>` | `<form:input path="name" placeholder="Task Name"/>` |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
- en: '| `<form:textarea/>` | `<form:textarea path="comments" id="txtComments" rows="5"
    cols="30" />` |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '| `<form:select/>``<form:option/>` and`<form:options/>` | `<form:select path="createdBy"
    id="selectCreatedBy">``<form:option value="-1" label="Select"/>``<form:options
    items="${users}" itemValue="id" itemLabel="name" />``</form:select>` |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
- en: '| `<form:label/>` | `<form:label for="txtTaskName" path="name">Task-names</form:label>`
    |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
- en: '| `<form:hidden/>>` | `<form:hidden path="taskId" id="hdnTaskId"/>` |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
- en: '| `<form:password/>` | `<form:password path="userPassword"/>` |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: '| `<form:radiobutton/>` | `<form:radiobutton path="sex" value="Male"/>` |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
- en: '| `<form:radiobuttons/>` | `<form:radiobuttons path="sex" items="${sexOptions}"/>`
    |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| `<form:checkbox/>` | `<form:checkbox path="task.priority" value="1"/>` |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| `<form:checkboxes/>` | `<form:checkboxes path="task.priority" value="${taskPriorities}"/>`
    |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| `<form:password/>` | `<form:password path="password" />` |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| `<form:errors/>` | `<form:errors path="createdBy.id" />` |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: Composing a form in JSP
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring forms can be composed in JSP pages using the `<spring>` and `<form>`
    tags. For the purpose of illustration, let''s take a look at a JSP form that uses
    both the Spring and form tag libraries along with JSTL. The following is a stripped-down
    version of `views/task/new.jsp`:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see in the preceding code listing, you must declare the JSTL, Spring,
    and form tag library directives at the top of your JSP page before you use Spring
    form tags.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'All `<form>` elements should be inside a `<form:form/>` container element.
    The `commandName` attribute value of `<form:form/>` binds the `Model` attribute
    with the name in the handler method of the Controller. The handler method from
    which the preceding JSP form is resolved would look like the following code:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Notice the `Model` attribute, `task`, which is bound with the `<form:form/>`
    tag in the JSP page. The form is submitted to the following handler method, which
    again serializes the `Task` object back for persistence:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Validating forms
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC makes form validation a lot easier using Spring's `Validator` framework.
    You might have noticed the `@Valid` annotation and the usage of the `BindingResult.hasErrors()`
    method call inside handler methods listed in the previous section. They are part
    of the validation framework.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a validator for a `Task` object by following these steps:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Validation API''s Maven dependency, `javax.validation` (build file:
    `pom.xml`).'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you have defined `MessageSourceBean` for the `validation-errors`
    properties file in your bean definition:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Make sure there is a `validation-errors.properties` file with the following
    sample content in your root resources location. You may add as many error messages
    into it as you like.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a `Validator` class, `TaskValidator`:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Register the `TaskValidator` class inside the `TaskController` class using
    `InitBinder`:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Annotate `ModelAttribute` with the `@Valid` annotation of `javax.validation.Valid`
    in the handler method.
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle validation errors in the request handler method, as given in the `createNewTask()`
    method listed in the previous section.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<form:errors/>` tag for each form field you are validating—as seen in
    the `/tasks/new.jsp` file.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The form will look like this in case of validation errors:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating forms](img/image00786.jpeg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: Handling file uploads
  id: totrans-763
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most web applications require multipart file upload functionality. Spring MVC
    makes it extremely easy to handle this otherwise cumbersome feature. It provides
    two built-in implementations of `MultiPartResolvers`: `CommonsMulipartResolver`
    for Apache Commons FileUpload and `StandardServletMultipartResolver` for the Servlet
    3.0 API.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'Since most modern web applications use a Servlet 3.0 container, let''s see
    how the FileUpload functionality can be handled using `StandardServletMultipartResolver`
    with the help of following example:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'Register your `MultipartResolver` in your `servlet-context.xml` file (or add
    it programmatically if you are using a Java configuration):'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Add multipart configuration support to your `DispatcherServlet` in your `web.xml`
    (or JavaConfig) file:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Make sure that the location you provided in the previous section really exists.
    Create the directory if it doesn't.
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the web form with an input file element in it. This sample JSP snippet
    uploads a user''s profile image:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the request handler method in your Controller:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Resolving Thymeleaf views
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thymeleaf is a Java-based XML/HTML/HTML5 template engine library to build web
    applications. It allows faster processing of templates and increased performance
    due to the intelligent caching of parsed view files. Please refer to the official
    Thymeleaf documentation for Thymeleaf page authoring.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'You need Thymeleaf and Spring (`org.thymeleaf`) in your Maven dependencies
    in order to use Thymeleaf in your projects. Thymeleaf views can be resolved in
    your project with the following snippet:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: More view technologies
  id: totrans-779
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC supports an impressive set of view technologies; you can use any
    of these after adding the right Maven dependencies in your project. Spring provides
    view resolvers out of the box for most of the view technologies. Here is a list
    of other view technologies supported by Spring MVC:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Velocity and FreeMarker
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groovy markup templates
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript templates (on Nashhorn): Handlebars, Mustache, ReactJS, and EJS'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ERB templates on JRuby and String templates on Jython
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML views and XSLT (built in)
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tiles
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF (iText) and Excel (Apache POI)
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JasperReports
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feed views
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, you will need to mix and match view technologies in the same
    application. For example, you may use JSP for normal HTML screens, but you will
    still need JasperReports to report screens and may need to download some reports
    as PDF and Excel files. Using Spring MVC ensures that all these features can be
    easily integrated.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build highly scalable and dynamic web applications
    using Spring MVC. Starting from setting up the project and configuring `WebApplicationContext`
    with proper layering, we explored different ways of designing controllers and
    map request handlers for both web and API endpoints—that too including asynchronous
    processing and multipart file uploads—using easily configurable components. Now,
    we can compose beautiful JSP pages using `<spring>` and `<form>` tags and also
    enable form validation using the Validation API.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been holding data in memory without bothering about making it
    persistent somewhere. In the next chapter, we will dive one level deeper into
    the data layer of enterprise application development, learning various data access
    and persistence mechanisms with and without ACID transactions. We are going to
    deal with more serious concerns from this point.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Accessing Data with Spring
  id: totrans-794
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data access or persistence is a major technical feature of data-driven applications.
    This is a critical area where careful design and expertise is required. Modern
    enterprise systems use a wide variety of data storage mechanisms ranging from
    traditional relational databases such as Oracle, SQL Server, and Sybase to more
    flexible, schema-less NoSQL databases such as MongoDB, Cassandra, and Couchbase.
    Spring Framework provides comprehensive support for data persistence in multiple
    flavors of mechanism, ranging from convenient template components to smart abstractions
    over popular **ORM** (**Object Relational Mapping**) tools and libraries, making
    them much easier to use. Spring's data access support is another great reason
    for choosing it for developing Java applications.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Framework offers the following primary approaches for data persistence
    mechanisms for developers to choose from:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: Spring JDBC
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM Data Access
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, Spring standardizes the preceding approaches under a unified **DAO**
    (**Data Access Object**) notation called `@Repository`.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Another compelling reason for using Spring is its first class transaction support.
    Spring provides consistent transaction management, abstracting different transaction
    APIs such as JTA, JDBC, JPA, Hibernate, JDO, and other container-specific transaction
    implementations.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: In order to make development and prototyping easier, Spring provides embedded
    database support, smart abstractions (`DataSource`), and excellent test integration.
    This chapter explores various data access mechanisms provided by Spring Framework
    and its comprehensive support for transaction management in both standalone and
    web environments, with relevant examples.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why use Spring Data Access when we have JDBC?**'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '**JDBC** (**Java Database Connectivity**), the Java Standard Edition API for
    data connectivity from Java to relational databases, is a very a low-level framework.
    Data access via JDBC is often cumbersome; the boiler-plate code the developer
    needs to write makes the code error-prone. Moreover, JDBC exception handling is
    not sufficient for most use cases; there exists a real need for simplified but
    extensive and configurable exception handling for data access. Spring JDBC encapsulates
    the often repeating code, simplifying the developer code tremendously, and lets
    him/her focus directly on his business logic. Spring Data Access components abstract
    the technical details including the lookup and management of persistence resources
    such as connections, statements, and resultsets, and accept the specific SQL statements
    and relevant parameters to perform the operation. Spring Data Access components
    use the same JDBC API under the hood, while exposing simplified, straightforward
    interfaces for the client''s use. This approach makes for a much cleaner and hence
    maintainable data access layer for Spring applications.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: Configuring DataSource
  id: totrans-806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to connect to a database from any Java application is to obtain
    a connection object specified by JDBC. `DataSource`, a part of Java SE, is a generalized
    factory of `java.sql.Connection` objects that represents the physical connection
    to the database and is the preferred means of producing a connection. `DataSource`
    handles transaction management, connection lookup, and pooling functionalities,
    relieving the developer of those infrastructural issues.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '`DataSource` objects are often implemented by database driver vendors and typically
    looked up via JNDI. Application servers and Servlet engines provide their own
    implementations of `DataSource` (and) or connectors to `DataSource` objects provided
    by the database vendor. Typically configured inside XML-based server descriptor
    files, server-supplied `DataSource` objects generally provide built-in connection
    pooling and transaction support. As a developer, you just configure your data
    sources inside the server configuration files declaratively in XML and look them
    up from your application via JNDI.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring application, you configure your `DataSource` reference as a Spring
    bean, and inject it as a dependency into your DAOs or other persistence resources.
    The Spring `<jee:jndi-lookup/>` tag (of [http://www.springframework.org/schema/jee](http://www.springframework.org/schema/jee)
    namespace) allows you to look up and construct JNDI resources easily, including
    a `DataSource` object defined from inside an application server. For applications
    deployed in a J2EE application server, a JNDI `DataSource` object provided by
    the container is recommended.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: For standalone applications, you need to create your own `DataSource` implementation
    or use third-party implementations such as Apache Commons DBCP, C3P0, or BoneCP.
    The following is a sample `DataSource` configuration using Apache Commons DBCP2\.
    It provides configurable connection pooling features too.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Make sure you add the corresponding dependency to your `DataSource` implementation
    in your build file. The following is for DBCP2:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Spring provides `DriverManagerDataSource`, a simple implementation of `DataSource`,
    which is only meant for testing and development purposes, not for production use.
    Note that it does not provide connection pooling. Here is how you configure it
    in your application.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'It can also be configured using the Java-based configuration, as shown in the
    following code:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never use `DriverManagerDataSource` on production environments. Use third-party
    data sources such as DBCP, C3P0, and BoneCP for standalone applications, and JNDI
    `DataSource` provided by the container, for the J2EE container instead. They are
    more reliable and provide efficient connection pooling functionality off the shelf.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: Using embedded databases
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For prototyping and test environments, it is a good idea to use Java-based
    embedded databases to quickly start up the project and configure easily. They
    are lightweight and easily testable. Spring supports the HSQL, H2, and Derby database
    engines for that purpose natively. Here is a sample `DataSource` configuration
    for an embedded HSQL database:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The XML version of this would look like the following code:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Handling exceptions in the Spring Data layer
  id: totrans-826
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With traditional JDBC-based applications, exception handling is based on `java.sql.SQLException`,
    which is a checked exception. It forces the developer to write `catch` and `finally`
    blocks carefully for proper handling and to avoid resource leakages such as leaving
    a database connection open. Spring, with its smart exception hierarchy based on
    `RuntimeException`, spares the developer from this nightmare. Having `DataAccessException`
    as the root, Spring bundles a bit set of meaningful exceptions, translating the
    traditional JDBC exceptions. Spring also covers Hibernate, JPA, and JDO exceptions
    in a consistent manner.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring uses `SQLErrorCodeExceptionTranslator`, which inherits `SQLExceptionTranslator`
    for translating `SQLException` to `DataAccessExceptions`. We can extend this class
    to customize the default translations. We can replace the default translator with
    our custom implementation by injecting into the persistence resources (such as
    `JdbcTemplate`, to be covered later). See the following code listing for how we
    define a `SQLExceptionTranslator` class in your code:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The preceding code snippet catches any `SQLException` and converts it into
    a Spring-based `BadSqlGrammarException` instance. Then, this custom `SQLExceptionTranslator`
    needs to be passed to the `Jdbctemplate` before use, as shown in the following
    code:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now, any invalid query will invoke the custom `SQLExceptionTranslator` class.
    You can customize its behavior according to your requirements.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: DAO support and @Repository annotation
  id: totrans-833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard way of accessing data is via specialized DAOs that perform persistence
    functions under the data access layer. Spring follows the same pattern by providing
    DAO components and allowing developers to mark their data-access components as
    DAOs, using the annotation `@Repository`. This approach ensures consistency over
    various data access technologies such as JDBC, Hibernate, JPA, and JDO, and project-specific
    repositories. Spring applies `SQLExceptionTranslator` across all these methods
    consistently.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: Spring recommends your data-access components to be annotated with stereotype,
    `@Repository`. The term, repository, was originally defined in *Domain-Driven
    Design*, *Eric Evans*, *Addison Wesley* as "a mechanism for encapsulating storage,
    retrieval, and search behavior which emulates a collection of objects." This annotation
    makes the class eligible for `DataAccessException` translation by Spring Framework.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data, another standard data-access mechanism provided by Spring, revolves
    around `@Repository` components. We will discuss this more in later sections.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: Spring JDBC abstraction
  id: totrans-837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring JDBC components simplify JDBC-based data access by encapsulating the
    boilerplate code and hiding the interaction with JDBC API components from the
    developer with a set of simple interfaces. These interfaces handle the opening
    and closing of JDBC resources (connections, statements, resultsets) as required.
    They prepare and execute statements, extract results from resultsets, provide
    callback hooks for converting, mapping and handling data, handle transactions,
    and translate SQL exceptions into the more sensible and meaningful hierarchy of
    `DataAccessException`.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring JDBC provides three convenient approaches for accessing relational databases:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '`JdbcTemplate`'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleJDBC` classes'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDBMS `Sql*` classes
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these Spring JDBC categories has multiple flavors of components under
    them which you can mix-and-match based on your convenience and technical choice.
    You may explore them under the `org.springframework.jdbc` package and its subpackages.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: JdbcTemplate
  id: totrans-844
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JdbcTemplate` is the core component under Spring JDBC abstraction. This powerful
    component executes almost all of the possible JDBC operations with its simple,
    meaningful methods, accepting parameters for an impressive set of flavors of data
    access. It belongs to the package, `org.springframework.jdbc.core`, which contains
    many other supporting classes that help `JdbcTemplate` to complete its JDBC operations.
    A `DataSource` instance is the only dependency for this component. All other Spring
    JDBC components use `JdbcTemplate` internally for their operations.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you configure `JdbcTemplate` as yet another Spring bean, and inject
    it into your DAOs or into any other bean where you want to invoke its methods.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`JdbcTemplate` is one of the implementations of Template Pattern in Spring.
    Template Pattern is a behavioral pattern listed in the *Gang of Four* design pattern
    catalog. It defines the skeleton of an algorithm in a method or operation called
    **Template Method**, deferring some steps into the subclasses, without changing
    the algorithm''s structure. `JdbcTemplate` is a collection of these Template Methods;
    the user can extend it and override some of the behaviors based on specific requirements.
    `JMSTemplate` and `JpaTemplate` are also examples of Template Pattern implementations.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '`JdbcTemplate` executes SQL queries (`SELECT`), update statements (`INSERT`,
    `UPDATE`, and `DELETE`), stored procedure and function calls, returns extracted
    results (for `SELECT` queries), and invokes call-back methods for result-set extraction
    and mapping rows with domain objects. It has a comprehensive set of query and
    execute methods for different methods of result-set extraction. The following
    table introduces a few very useful `JdbcTemplate` methods:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
- en: '| `execute` | A set of overloaded methods for executing a SQL update (`INSERT`,
    `UPDATE`, and `DELETE`) statement, with different parameter sets including the
    SQL statement to be executed, bind parameters, a statement creator, and callback
    methods. |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
- en: '| `query` | A set of overloaded methods for querying `PreparedStatement` for
    a given SQL `SELECT` statement with a multitude of parameter sets including bind
    parameters, argument types, `RowMapper`, `ResultSetExtractor`, `PreparedStatementCreator`,
    `RowCallbackHandler`, and so on. While methods with callbacks are void methods,
    the others return a list of objects of type `<T>` specified with the corresponding
    `RowMapper`, `ResultSetExtractor`, or a populated instance of type `<T>`. |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
- en: '| `queryForList` | A set of overloaded query methods executing a `SELECT` query
    returns a list of objects of type `<T>` specified as an argument, `Class<T> elementType`.
    Those methods not specifying the `elementType` return `List<Map<String, Object>>`.
    |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
- en: '| `queryForMap` | Executes a (`SELECT`) query and returns the result as `Map<String,
    Object>`. |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
- en: '| `queryForObject` | A set of overloaded methods querying a given SQL `SELECT`
    statement with parameter sets including bind parameters, argument types, `RowMapper`,
    and the required return type `<T>`. |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
- en: '| `update` | A set of overloaded methods issuing an update (`INSERT`, `UPDATE`,
    or `DELETE`) statement with parameter sets including bind parameters, argument
    types, `PreparedStatementCreator`, and so on. It returns an integer, which is
    the count of records affected. |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
- en: '| `batchUpdate` | A set of overloaded methods for executing multiple SQL updates
    (`INSERT`, `UPDATE`, and DELETE) with different parameter sets including an array
    of SQL statements and many combinations of `PreparedStatementSetter` and other
    arguments. |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
- en: '| `execute` | A set of overloaded methods for executing a SQL update (either
    `INSERT`, `UPDATE`, or `DELETE`) statement, with different parameter sets including
    the SQL statement to be executed, bind parameters, `StatementCreator`, and callback
    methods. |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
- en: '| `query` | A set of overloaded methods for querying `PreparedStatement` for
    a given SQL `SELECT` statement with several parameter sets including bind parameters,
    argument types, `RowMapper`, `ResultSetExtractor`, `PreparedStatementCreator`,
    `RowCallbackHandler`, and so on. While those methods with callbacks are void methods,
    the others return a list of objects of type `<T>` specified with the corresponding
    `RowMapper`, `ResultSetExtractor`, or a populated instance of type `<T>`. |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
- en: 'Behind the super capabilities of `JdbcTemplate` is a set of callback interfaces
    being passed as arguments for the methods listed in the preceding table. These
    execution hooks help `JdbcTemplate` to deal with relational data in a pure object-oriented
    and reusable fashion. A good understanding of these interfaces is critical for
    the right usage of `JdbcTemplate`. See the following table for these callback
    interfaces:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '| Callback interface | Callback method(s) | Responsibilities |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
- en: '| `CallableStatementCreator` | `execute` | Constructs `java.sql.CallableStatement`,
    which is used to execute stored procedures inside its `createCallableStatement(Connection)`method:.
    |'
  id: totrans-865
  prefs: []
  type: TYPE_TB
- en: '| `PreparedStatementCreator` | `execute`, `update`, `query` | Constructs `java.sql.PreparedStatement,`
    given a connection, inside the method, `createPreparedStatement (Connection)`.
    |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
- en: '| `PreparedStatementSetter` | `update`, `query` | Sets values to `PreparedStatement`
    before execution, inside `JdbcTemplate.setValues (PreparedStatement)`. |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
- en: '| `CallableStatementCallback` | `execute` | Prepares `CallableStatement`. Usually
    sets the `IN` and `OUT` parameters of a stored procedure or function, before the
    actual execution, inside `JdbcTemplate.doInCallableStatement(CallableStatement)`.
    |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
- en: '| `PreparedStatementCallback` | `execute` | Used by `JdbcTemplate` execute
    methods for preparing `PreparedStatement`. Usually sets the bind parameters, before
    the actual execution, inside the `doInPreparedStatement(PreparedStatement)`method:.
    |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
- en: '| `ResultSetExtractor` | `query` | Extracts results from `ResultSet` and returns
    a domain object, inside the `extractData(ResultSet)`method:. |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
- en: '| `RowCallbackHandler` | `query` | Processes each row of a `ResultSet` in a
    stateful manner, inside the `processRow(Resultset)`method, which doesn''t return
    anything. |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
- en: '| `RowMapper` | `query` | Maps each row of a `ResultSet` into a domain object,
    inside the `mapRow(Resultset, int rowNum)`method, returning the created domain
    object. |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
- en: Now let's try some nice realistic usages of `JdbcTemplate`. The following is
    a simple method executing a count query using `JdbcTemplate`.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Do you see how this straightforward one-liner code saves you from all the boilerplate
    and exception-handling code you would otherwise need to write in typical JDBC
    code?
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is a bit more complex and illustrates how to query
    a unique row from a table and map it with a domain object (`User`, in this case)
    using `RowMapper`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'It is so much easier to deal with collections of data using `JdbcTemplate`.
    The following code snippet illustrates the query method of `JdbcTemplate` with
    bind parameters and a `RowMapper` that converts `ResultSet` into a list of type:
    `<Task>`.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`JdbcTemplate` takes care of all the repeating code for you and you just need
    to write the specific code, which is about how you map the data of a row with
    your domain object.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'Another variation of row mapping that uses a `ResultSetExtractor` interface
    that extracts a single row from `ResultSet` is illustrated in the following code:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now let's take a look at some update statements. The following is the execution
    of a simple `INSERT` statement as one-liner code. The SQL `UPDATE` and `DELETE`
    statements follow the same pattern.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The preceding method has a drawback. Although it inserts the new user record
    into the table, the generated ID (probably by a database sequence) is not returned
    back; you would need to issue another query to retrieve it separately. However,
    `JdbcTemplate` offers a nice way to solve this problem: using a `KeyHolder` class.
    It is another `variation` of the `update` method which was explained in the following
    code; you can retrieve the generated key (ID in this case) in a single execution,
    using a `KeyHolder` class in combination with `PreparedStatementCreator`:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '`JdbcTemplate` makes batch updates easy, following the same pattern as shown
    earlier. Take a look at the following code: it executes a single `PreparedStatement`
    over a collection of data:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: NamedParameterJdbcTemplate
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have used `JdbcTemplate` with bind parameters using `?` placeholders.
    When it comes to a bigger number of parameters, a named parameter is a better
    choice for readability and maintainability. `NamedParameterJdbcTemplate`, a specialized
    version of `JdbcTemplate,` supports using named parameters rather than traditional
    `?` placeholders. Instead of extending from `JdbcTemplate`, `NamedParameterJdbcTemplate`
    uses the underlying `JdbcTemplate` for its operations.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: You can define `NamedParameterJdbcTemplate` in the same way as the classic `JdbcTemplate`,
    passing a `DataSource` object as a mandatory dependency. Then, you can use it
    just like `JdbcTemplate`, but using named parameters instead of bound parameters
    (`?`). The following code snippet illustrates the use of the `NamedParameterJdbcTemplate`
    query method that uses `RowMapper` for object-relational mapping.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: SimpleJdbc classes
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SimpleJdbc` classes are another nice approach to accessing data in a more
    object-oriented fashion, but still using the same `JdbcTemplate` internally. They
    belong to the `org.springframework.jdbc.core.simple` package. There are two classes
    in it:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleJdbcCall`'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleJdbcInsert`'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleJdbcCall` handles calls to stored procedures and functions and `SimpleJdbcInsert`
    deals with SQL `INSERT` commands to database tables. Both are `DatabaseMetadata`-aware,
    hence they auto-detect or map similarly named fields of domain objects. Both of
    them act as templates for performing JDBC operations around a relational entity
    (a stored procedure or function and a database table respectively), accepting
    parameters that determine the behavior of the operation once (declared globally),
    and then reusing it repeatedly with a dynamic set of data at runtime.'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: 'A `SimpleJdbcCall` class is declared as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The preceding code declares `SimpleJdbcCall`, which invokes a stored procedure
    (in PostgreSQL, stored procedures are also called functions) and all its parameters.
    Once this is declared, it can be reused any number of times at runtime. Usually,
    you declare it at the class level (of your DAO). The following code illustrates
    how we invoke it at runtime:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '`SimpleJdbcInsert` is typically declared as shown in the following code:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note the declaration of the generated key column beside the table name in the
    following code snippet. Again, this is usually declared at the class level for
    better reuse. Now, take a look at how this is invoked at runtime.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You can see that the generated key is returned after the execution, which is
    set back to the `User` object. `SimpleJdbcCall` and `SimpleJdbcInsert` are convenient
    alternatives to the vanilla `JdbcTemplate`; you can use any of these solutions
    consistently or you can mix-and-match them in the same application.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: JDBC operations with Sql* classes
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A set of classes belonging to the `org.springframework.jdbc.object` package
    offers another method of performing JDBC operations in a more object-oriented
    manner. The following table lists the most common of them:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Responsibilities |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
- en: '| `MappingSqlQuery` | Concrete representation of a SQL query, supporting a
    `RowMapper`, and having a wide variety of convenient `execute` and `find*` methods.
    Supports named parameters too. |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
- en: '| `SqlUpdate` | Executes an SQL update (`INSERT`, `UPDATE`, and `DELETE`) operation,
    with support for named parameters and keyholders (for retrieving generated keys).
    |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
- en: '| `SqlCall` | Performs SQL-based calls for stored procedures and functions
    with support for named-parameters and keyholders (for retrieving generated keys).
    |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
- en: 'The following code illustrates the use of `MappingSqlQuery`:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'SQL updates (`INSERT`, `UPDATE`, and `DELETE`) can be performed using `SqlUpdate`
    with a more descriptive code, as the example in the following code illustrates:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`SqlUpdate` provides a variety of convenient update methods, suitable for many
    parameter combinations. You can mix-and-match any of the preceding listed Spring
    JDBC components according to your convenience and preferred programming style.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  id: totrans-919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data is an umbrella project under the Spring portfolio, designed to provide
    consistent data access across a number of different data stores including relational
    and NoSQL Databases, and other types of data stores such as REST (HTTP), search
    engines, and Hadoop. Under Spring Data, there are subprojects for each specific
    approach and data store, put together by companies or developers of those technologies.
    Spring Data significantly simplifies the building of the data layer regardless
    of the underlying database and persistence technology.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists a few Spring Data subprojects with a short description
    of each:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Description |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Commons | Contains a core Spring Data repository specification
    and supporting classes for all Spring Data projects. Specifies concepts such as
    repository, query, auditing, and history. |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
- en: '| Spring Data JPA | Deals with JPA-based repositories. |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
- en: '| Spring Data MongoDB | Provides easy integration with MongoDB, including support
    for query, criteria, and update DSLs. |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Redis | Integrates with the Redis in-memory data structure store,
    from Spring applications. |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Solr | Provides integration with Apache Solr, a powerful, open
    source search platform based on Apache Lucene. |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
- en: '| Spring Data Gemfire | Provides easy integration with Pivotal Gemfire, a data
    management platform that provides real-time data access, reliable asynchronous
    event notifications, and guaranteed message delivery. |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
- en: '| Spring Data KeyValue | Deals with key value-based data stores. |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
- en: '| Spring Data REST | Exposes repositories with REST APIs. |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
- en: The Spring Data portfolio contains community modules for more data stores that
    are not covered by the official Spring Data projects. Communities of several very
    popular open source and proprietary databases are contributing to these projects,
    which makes Spring Data an excellent source of proven solutions for building the
    data-access layer of enterprise applications regardless of the underlying data
    store. Cassandra, Neo4J, Couchbase, and ElasticSearch are some examples of community
    projects based on Spring Data.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Commons
  id: totrans-933
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Data standardizes data-access via all its store-specific modules (subprojects)
    through a consistent API called Spring Data Commons. Spring Data Commons is the
    foundational specification and a guideline for all Spring Data Modules. All Spring
    Data subprojects are store-specific implementations of Spring Data Commons.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data Commons defines the core components and general behaviors of Spring
    Data modules.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data repository specification
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query derivation methods
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web support
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine each of these components, their setup, and usage in the following
    sections.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data repository specification
  id: totrans-941
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`org.springframework.data.repository.Repository` is the central interface of
    Spring Data abstraction. This marker interface is a part of Spring Data Commons
    and has two specialized extensions, `CrudRepository` and `PagingAndSortingRepository`.'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: A repository manages a domain entity (designed as a POJO). `CrudRepository`
    provides CRUD with the following CRUD operations for an entity.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '`save(One)`, `save(List)`'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find`, `findOne`, `findAll`'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`, `deleteAll`'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exists`'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PagingAndSortingRepository` adds pagination and sorting features over `CrudRepository`.
    It has the following two methods:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '`Page<T> findAll(Pageable)`'
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterable<T> findAll(Sort)`'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now is time to jump ahead and discuss the technology and store-specific modules
    of Spring Data. We are covering Spring Data JPA and Spring Data MongoDB to illustrate
    two totally different worlds in the database universe: relational and NoSQL. When
    we use a specific implementation, we use an implementation-specific repository
    but your method interfaces remain the same; hence, theoretically, a switch from
    a specific Spring Data implementation to another would not affect your client
    programs (service, controller, or test cases).'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Data JPA is the **JPA** (**Java Persistence Architecture**)-based implementation
    of Spring Data, dealing with object-relational data access. For a developer, most
    of the programming is based on what is described in Spring Data Commons, whereas
    Spring Data JPA allows for some extra customizations specific to relational SQL
    and JPA. The main difference is in the repository setup and the query optimization
    using the `@Query` annotation.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Spring Data JPA
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enabling Spring Data JPA in your project is a simple two-step process:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: Add the `spring-data-jpa` dependency to your `maven/gradle` build file.
  id: totrans-958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare enable JPA repositories in your bean configuration.
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Maven, you can add a `spring-data-jpa` dependency as shown in the following
    code:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can enable JPA repositories, as shown in the following line, if you are
    using XML:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In the case of Java configuration, you just annotate to enable JPA repositories.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: JpaRepository
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After enabling JPA repositories, Spring scans the given package for Java classes
    annotated with `@Repository`, and creates fully-featured proxy objects ready to
    be used. These are your DAO, where you just define the methods, Spring gives you
    proxy-based implementations at runtime. See a simple example:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Spring generates smart implementations that actually perform the required database
    operations for these methods inside the proxy implementation, looking at the method
    names and arguments.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data MongoDB
  id: totrans-970
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is one of the most popular document-oriented NoSQL databases. It stores
    data in **BSON** (**Binary JSON**) format, allowing you to store an entire complex
    object in nested structures, avoiding the need to break data into a lot of relational
    tables. Its nested object structure maps directly to object-oriented data structures
    and eliminates the need for any object-relational mapping, as is the case with
    JPA/Hibernate.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data MongoDB is the Spring Data module for MongoDB. It allows Java objects
    to be mapped directly into MongoDB documents. It also provides a comprehensive
    API and infrastructural support for connecting to MongoDB and manipulating its
    document collections.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Spring Data MongoDB
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Data MongoDB can be enabled with the following steps:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: Add `spring-data-mongodb` to your build file (`maven/gradle`).
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register a Mongo instance in your Spring metadata configuration.
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `mongoTemplate` Spring Bean to your Spring metadata.
  id: totrans-977
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adding the `spring-data-mongodb` dependency with Maven should look like this:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can register a Mongo instance in your XML metadata, as shown in the following
    line:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This Mongo instance is a proxy of your actual MongoDB instance running on a
    server.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplistic `mongoTemplate` looks like the listing given in the following
    code:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: MongoRepository
  id: totrans-985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoRepository is the MongoDB-specific repository for Spring Data MongoDB.
    It looks very similar to `JpaRepository`. Take a look at a sample `MongoRepository`
    class:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Domain objects and entities
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data-driven applications often design domain objects as entities and then persist
    them into databases either as relational tables or document structures of key-value
    pairs at runtime. Spring Data deals with domain entities like any other persistence
    framework. In order to illustrate the usage of a repository, we will refer to
    the following three related entities, designed as **Plain Old Java Objects** (**POJOs**)
    in your program.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '![Domain objects and entities](img/image00787.jpeg)'
  id: totrans-990
  prefs: []
  type: TYPE_IMG
- en: The following are the Java representations. The first one is annotated for JPA
    and the other two for MongoDB. JPA entities are annotated with `@Entity`. Columns
    are mapped against each field. Remember that, instead of annotations, you can
    use XML-based mapping for JPA entities too. XML mapping offers several benefits
    including centralized control and maintainability. This example uses annotations
    for simplicity, assuming that the reader is already familiar with JPA or Hibernate
    mappings.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The following is the task entity, annotated as a MongoDB document. Mongo entities
    are annotated with `@Document`. It requires an ID field, either annotated with
    `@Id` or with the name `id`.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The file entity is annotated as a JPA entity.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Query resolution methods
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the declared query (`find`, `count`, `delete`, `remove`, and
    `exists`) methods at interface level, `CrudRepository` supports declared queries
    using the `@Query` annotation methods with any name, which helps to derive the
    actual SQL queries from the **SpEL** (**Spring Expression Language**) expression
    given as a parameter. Of these two query deriving options, Spring Data adopts
    one based on the following query lookup strategies:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '| Query Lookup Strategy | Description |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
- en: '| `CREATE` | Generates module-specific queries from the method name. |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
- en: '| `USE_DECLARED_QUERY` | Uses a query declared by an annotation or some other
    means. |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
- en: '| `CREATE_IF_NOT_FOUND` | This strategy combines the first two. This is the
    default strategy. |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
- en: The query lookup strategy is normally set while enabling JPA repositories.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The query generation strategy (`CREATE`) works around the properties of the
    entity, including their dependencies, in a nested direction. As a developer, you
    define method names based on a specific format that can be interpreted and realized
    by Spring Data. The general structure of the query method is shown here:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '`[return Type] [queryType][limitKeyword]By[criteria][OrderBy][sortDirection]`'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '`return type` can be the entity `<T>` itself (in the case of a unique result),
    a list `<T>`, a stream `<T>`, page `<T>`, primitive numbers, Java wrapper types,
    void, future `<T>`, `CompletableFuture<T>`, `ListenableFuture<T>`, and so on.
    The last three are for Spring''s asynchronous method execution and should be annotated
    with `@Async`.'
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryType` can be `find`, `read`, `query`, `count`, `exists`, `delete`, and
    so on.'
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limitKeyword` supports `distinct`, `First[resultSize]`, and `Top[resultSize]`.
    An example is `First5`.'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`criteria` is built by combining one or more property expressions (using camel-casing)
    with standard operators such as `Or`, `And`, `Between`, `GreaterThan`, `LessThan`,
    `IsNull`, `StartsWith`, and `Exists`. Criteria can be suffixed by `IgnoreCase`
    or `AllIgnoreCase`, to apply case insensitivity.'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderBy` is used as it is, suffixed by property expressions.'
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortDirection` can be either of `Asc` or `Desc`. This is used only with `OrderBy`.'
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see some examples for better clarity. The following sample code illustrates
    how to construct query (or delete) methods so that Spring Data can generate the
    actual SQL query at runtime.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The preceding example showing `JpaRepository` and `MongoRepository` works in
    the same way; you just need to extend from it, without changing the method signatures.
    You have seen the constraining query and filter methods traversing root-level
    properties of the entity, combining operators appropriately. Besides root-level
    properties, you can traverse and filter by nested properties as well, to define
    query constraints, in other words, limiting the result. Take a look at the following
    example:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The methods listed in the preceding example are traversing nested properties
    of the task entity:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '`findByAssigneeId = task.assignee.id`'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findByAssigneeUserName = task.assignee.userName`'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can traverse into any level of nested elements of your entity, depending
    on how complex your entity and requirements are.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Query annotation
  id: totrans-1022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the autogeneration of queries based on method names as demonstrated
    in the previous section, Spring Data allows you to declare queries for entities
    locally, directly in the repository itself, over the method names. You declare
    the query using SpEL, and Spring Data interprets it at runtime and (the proxy
    repository) generates the queries for you. This is an implementation of the query
    resolution strategy: `USE_DECLARED_QUERY`.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some self-explanatory examples:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can see from the preceding example that we can traverse into nested properties
    to constrain the queries, in the criteria part of it. You can also have both query
    generation strategies (`CREATE` and `USE_DECLARED_QUERY`) in the same repository.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example was based on Spring Data JPA; the Spring Data MongoDB
    equivalent is given in the following code. You can see how the `@Query` annotation
    values differ in comparison to the MongoDB structure.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Spring Data web support extensions
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Data provides a smart extension called `SpringDataWebSupport` to Spring
    MVC applications, integrating a few productivity components automatically if you
    enable it. It primarily resolves domain entities as `Pageable` and `Sort` instances
    with request-mapping controller methods directly from request parameters, if you
    are using Spring Data repository programming model for data access.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to enable `SpringDataWebSupport` for your project before you can use
    the features. You can annotate `@EnableSpringDataWebSupport`, as shown in the
    following code, if you are using a Java configuration:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In the case of XML metadata, you can register `SpringDataWebConfiguration`
    as a Spring bean, as shown in the following code:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Once you set up `SpringDataWebSupport`, you can start using Spring Data entities
    as request arguments with request-mapping methods, as shown in the following code:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In the preceding method, you can see that Spring Data loads the `User` entity
    data using `UserRepository` transparently for you. Similarly, you can accept `Pageable`
    and `Sort` instances against JSON or XML post requests. Wise usage of the `SpringDataWebSupport`
    extension makes your code cleaner and more maintainable.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Auditing with Spring Data
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tracking data modifications is a critical feature of serious business applications.
    Administrators and managers are anxious to know when and who changed certain business
    information saved in the database. Spring Data provides smart and easy methods
    for auditing data entities transparently. Spring Data ships the following meaningful
    annotations for capturing modified user and time data entities in the system:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Expected type |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1041
  prefs: []
  type: TYPE_TB
- en: '| `@CreatedBy` | The principal user who created the entity. Typically, it is
    another entity that represents the domain user. |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
- en: '| `@CreatedDate` | Records when the entity is created. Supported types: `java.util.Date`,
    calendar, JDK 8 date/time types, `Joda DateTime`. |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
- en: '| `@LastModifiedBy` | The user principal who last updated the entity. It is
    the same type as `@CreatedBy`. |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
- en: '| `@LastModifiedDate` | Records when the entity was last updated. Supported
    types are the same as for `@CreatedDate`. |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
- en: 'A typical JPA entity should look like the following code:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: If you are using XML instead of annotations to map your entities, you can either
    implement an auditable interface, which forces you to implement the audit metadata
    fields, or extend `AbstractAuditable`, a convenient base class provided by Spring
    Data.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you are recording the information of the user who is creating and modifying
    entities, you need to help Spring Data to capture that user information from the
    context. You need to register a bean that implements `AuditAware<T>`, where `T`
    is the same type of field that you annotated with `@CreatedBy` and `@LastModifiedBy`.
    Take a look at the following example:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'If you are using Spring Security for authentication, then the `getCurrentAuditor`
    method should get and return the user from the `SecurityContextHolder` class,
    as follows:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Now your auditing infrastructure is ready, any modification you make in your
    auditable entities will be tracked transparently by Spring Data.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: So far you have mastered the mighty Spring Data and you know how to create elegant
    and clean yet really powerful data access layers with Spring Data repositories,
    so now it is time to think about how to ensure the data integrity and reliability
    of your application. Spring Transaction is the answer; let's explore it in the
    next section.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: Spring Transaction support
  id: totrans-1055
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data-driven enterprise systems consider data integrity as paramount, hence transaction
    management is a critical feature supported by major databases and application
    servers. Spring framework provides comprehensive transaction support, abstracting
    any underlying infrastructure. Spring Transaction support includes a consistent
    approach across different transaction choices such as JTA, JPA, and JDO. It integrates
    well with all Spring data-access mechanisms. Spring Transaction supports both
    declarative and programmatic transaction management.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **transaction** can be defined as an atomic unit of data exchange, typically
    SQL statements in the case of relational databases, which should be either committed
    or rolled back as a block (all or nothing). A transactional system or a transaction
    management framework enforces **ACID** (**Atomic**, **Consistent**, **Isolated**,
    **Durable**) properties across the participating systems or resources (such as
    databases and messaging queues).
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: Relevance of Spring Transaction
  id: totrans-1059
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise Java application servers natively provide **JTA** (**Java Transaction
    API**) support, which enables distributed transaction, which is also known as
    global transaction, spanning multiple resources, applications and servers. Traditionally,
    **Enterprise Java Beans** (**EJB**) and **Message Driven Beans** (**MDB**) were
    used for **container-managed transactions** (**CMT**), which is based on JTA and
    JNDI. JTA transaction management is resource-intensive; its exception handling
    is based on checked exceptions and so is not developer-friendly. Moreover, unit
    testing is hard with EJB CMT.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: For those who do not want to use resource-intensive JTA transactions, a local
    transaction is another available option, and one that allows you to programmatically
    enforce resource-specific transactions using APIs such as JDBC. Although relatively
    easy to use, it is limited to a single resource, as multiple resources cannot
    participate in a single transaction. Moreover, local transactions are often invasive,
    hence they pollute your code.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Spring Transaction abstraction solves the problems of global and local transactions
    by providing a consistent transaction model that can run in any environment. Although
    it supports both declarative and programmatic transaction management, the declarative
    model is sufficient for most cases. Spring Transaction eliminates the need for
    an application server such as JBoss or WebLogic just for transactions. You can
    start with local transactions using Spring on a simple Servlet engine such as
    Tomcat and scale it up later to distributed transactions on an application server
    without touching your business code, just by changing the transaction manager
    in your Spring metadata.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: Most applications just need local transactions since they do not deal with multiple
    servers or transactional resources such as databases, JMS, and JCA; hence, they
    do not need a full-blown application server. For distributed transactions spanned
    across multiple servers over remote calls, you need JTA, necessitating an application
    server, as JTA needs JNDI to look up the data source. JNDI is normally available
    only in an application server. Use `JTATransactionManager` inside application
    servers for JTA capabilities.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1064
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you deploy your Spring application inside an application server, you can
    use server-specific transaction managers to utilize their full features. Just
    switch the transaction manager to use server-specific `JtaTransactionManager`
    implementations such as `WebLogicJTATransactionManager` and `WebSphereUowTransactionManager`
    inside your Spring metadata. All your code is completely portable now.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Spring Transaction fundamentals
  id: totrans-1066
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Transaction Management abstraction is designed around an interface named
    `PlatformTransactionManager`, which you need to configure as a Spring bean in
    your Spring metadata. `PlatformTransactionManager` manages the actual transaction
    instance that performs the transaction operations such as commit and rollback,
    based on a `TransactionDefinition` instance that defines the transaction strategy.
    `TransactionDefinition` defines the critical transaction attributes such as isolation,
    propagation, transaction timeout, and the read-only status of a given transaction
    instance.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transaction attributes determine the behavior of transaction instances. They
    can be set programmatically as well as declaratively. Transaction attributes are:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation level**: Defines how much a transaction is isolated from (can see)
    other transactions running in parallel. Valid values are: `None`, `Read committed`,
    `Read uncommitted`, `Repeatable reads`, and `Serializable`. `Read committed` cannot
    see dirty reads from other transactions.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '**Propagation**: Determines the transactional scope of a database operation
    in relation to other operations before, after, and nested inside itself. Valid
    values are: `REQUIRED`, `REQUIRES_NEW`, `NESTED`, `MANDATORY`, `SUPPORTS`, `NOT_SUPPORTED`,
    and `NEVER`.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeout**: Maximum time period that a transaction can keep running or waiting
    before it completes. Once at timeout, it will roll back automatically.'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only status**: You cannot save the data read in this mode.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: These transaction attributes are not specific to Spring, but reflect standard
    transactional concepts. The `TransactionDefinition` interface specifies these
    attributes in the Spring Transaction Management context.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your environment (standalone, web/app server) and the persistence
    mechanism you use (such as plain JDBC, JPA, and Hibernate), you choose the appropriate
    implementation of `PlatformTransactionManager` and configure it as required, in
    your Spring metadata. Under the hood, using Spring AOP, Spring injects `TransactionManager`
    into your proxy DAO (or `EntityManager`, in the case of JPA) and executes your
    transactional methods, applying transaction semantics declared in your Spring
    configuration, either using the `@Transactional` annotation or the equivalent
    XML notations. We will discuss the `@Transactional` annotation and its XML equivalent
    later on in this chapter.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 'For applications that operate on a single `DataSource` object, Spring provides
    `DataSourceTransactionManager`. The following shows how to configure it in XML:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'For multiple `DataSource` objects or transactional resources, you need a `JtaTransactionManager`
    with JTA capabilities, which usually delegates to a container JTA provider. You
    need to use `DataSource` objects in Java EE application servers, defined with
    the server, and looked up via JNDI along with `JtaTransactionManager`. A typical
    combination should look like the following code fragment:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: If you are using Hibernate and just a single `DataSource` (and no other transactional
    resource), then the best option is to use `HibernateTransactionManager`, which
    requires you to pass the session factory as a dependency. For JPA, Spring provides
    `JpaTransactionManager`, which binds a single JPA `EntityManager` instance. However,
    it is advisable to use `JtaTransactionManager` in application-container environments.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides specialized transaction managers for application servers for
    WebLogic and WebSphere in order to leverage full power from container-specific
    transaction coordinators. Use `WebLogicTransactionManager` and `WebsphereUowTransactionManager`
    in the respective environments.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: Declarative transaction management
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separating Transaction semantics out of your business code into an XML file
    or annotations above the methods is usually called **declarative transaction management**.
    Spring Framework allows you to apply transactional behavior into your beans transparently
    and non-invasively using its declarative transaction management feature.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: You can apply Spring Transaction declaratively on any Spring bean, unlike EJB
    CMT. With Spring Transaction, you can specify transactional advices around your
    bean methods inside the metadata in an AOP style; then Spring will apply your
    those advices at runtime using AOP. You can set rollback rules to specify which
    exceptions around which beans or methods cause automatic rollback or non-rollback.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: Transactional modes – proxy and AspectJ
  id: totrans-1085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Transactions supports two transactional modes: proxy mode and AspectJ
    mode. Proxy is the default and most popular mode. In proxy mode, Spring creates
    an AOP proxy object, wrapping the transactional beans, and applies transactional
    behavior transparently around the methods using transaction aspects based on the
    metadata. The AOP proxy created by Spring based on transactional metadata, with
    the help of the configured `PlatformTransactionManager`, performs transactions
    around the transactional methods.'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: If you choose AspectJ mode for transactions, the transactional aspects are woven
    into the bean around the specified methods modifying the target class byte code
    during compile-time. There will be no proxying in this case. You will need AspectJ
    mode in special cases such as invoking transactional methods of the same class
    with different propagation levels, where proxying would not help.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Defining transactional behavior
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring offers two convenient approaches for declaratively defining the transactional
    behavior of your beans:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: AOP configuration for transactions in an XML metadata file
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@Transactional` annotation
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with AOP configuration in an XML file. Refer to the *Aspect Oriented
    Programming* section of [Chapter 1](part0012.xhtml#aid-BE6O1 "Chapter 1. Getting
    Started with Spring Core"), *Getting Started with Spring Core*, for a detailed
    discussion of configuring AOP, using aspects, pointcuts, advice, and so on.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you declare transaction advices and pointcuts with pointcut expressions
    in your XML metadata file. The best approach is to keep the transaction configuration
    in a separate bean-definition file (for example, `transation-settings.xml`) and
    import it into your primary application-context file.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you declare transactional advices and other semantics as shown in
    the following code:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'You can see that this AOP configuration instructs Spring how to weave transactional
    advices around the methods using pointcuts. It instructs `TransactionManager`
    to make all find methods of the entire service layer read-only, and to force other
    methods to have the transaction propagation: `REQUIRED`, which means that, if
    the caller of the method is already in a transactional context, this method joins
    the same transaction without creating a new one; otherwise, a new transaction
    is created. If you want to create a different transaction for this method, you
    should use the `REQUIRES_NEW` propagation.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the transaction isolation level is specified as `DEFAULT`, which
    means the default isolation of the database is to be used. Most databases default
    to `READ_COMMITTED`, which means a transactional thread cannot see the data of
    other transactions in progress (dirty reads).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: Setting rollback rules
  id: totrans-1098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Spring transaction, you can set rollback rules declaratively, in the same
    `<tx:advice>` block, as shown in the following code:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You can specify which exceptions should or should not rollback transactions
    for your business operations using the `rollback-for` and `no-rollback-for` attributes
    of the `<tx:method>` element.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TransactionException` thrown by the `PlatformTransactionManager` interface''s
    methods is the unchecked exception, `RuntimeException`. In Spring, transactions
    rollback for unchecked exceptions automatically. Checked, or application exceptions
    are not rolled back unless specified in the metadata, using the `rollback-for`
    attribute.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: Spring Transaction allows you to customize the transactional behavior of your
    beans to a minute level of granularity using Spring AOP and SpEL. Moreover, you
    can specify the behavioral attributes of your transaction such as propagation,
    isolation, and timeout at the method level on the `<tx:method>` element.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Transactional annotation
  id: totrans-1105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Transactional` annotation describes transactional attributes on a method
    or class. Class-level annotation applies to all methods unless explicitly annotated
    at method level. It supports all the attributes you otherwise set at the XML configuration.
    See the following example:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In the preceding example, the transactional method `createTask` with propagation
    `REQUIRED` rolls back for `NoUserFoundException`. Similarly, you can set no-rollback
    rules at the same level too.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@Transactional` can be applied only to public methods. If you want to annotate
    over protected, private, or package-visible methods, consider using AspectJ, which
    uses compile-time aspect weaving. Spring recommends annotating `@Transactional`
    only on concrete classes as opposed to interfaces, as it will not work in most
    cases such as when you use `proxy-target-class="true"` or `mode="aspectj"`.'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: Enabling transaction management for @Transactional
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need to first enable transaction management in your application before
    Spring can detect the `@Transactional` annotation for your bean methods. You enable
    transaction in your XML metadata using the following notation:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The following is the Java configuration alternative for the preceding listing:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Spring scans the application context for bean methods annotated with `@Transactional`
    when it sees either of the preceding settings.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the transaction mode from `proxy`, which is the default, to
    `aspectj` at this level:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Another attribute you can set at this level is `proxy-target-class`, which is
    applicable only in the case of the `proxy` mode.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic transaction management
  id: totrans-1120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring provides comprehensive support for programmatic transaction management
    using two components: `TransactionTemplate` and `PlatformTransactionManager`.
    The following code snippet illustrates the usage of `TransactionTemplate`:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`TransactionTemplate` supports the setting of all transaction attributes, as
    in the case of XML configuration, which gives you more granular control at the
    expense of mixing your business code with transactional concerns. Use it only
    if you need absolute control over a particular feature that cannot be achieved
    with declarative transaction management. Use declarative transaction management
    if possible, for better maintainability and management of your application.'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have so far explored Spring Framework's comprehensive coverage of all technical
    aspects around data access and transaction. Spring provides multiple convenient
    data access methods, which removes much of the hard work for the developer involved
    in building the data layer and standardizing the business components. The correct
    usage of Spring data access components makes the data layer of the Spring application
    clean and highly maintainable. Leveraging Spring Transaction support ensures the
    data integrity of applications without polluting the business code and makes your
    application portable across different server environments. Since Spring abstracts
    much of the technical heavy lifting, building the data layer of your applications
    becomes an enjoyable piece of software engineering.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Understanding WebSocket
  id: totrans-1126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of web applications was built upon a simple paradigm. In a unidirectional
    interaction, a web client sent a request to a server, the server replied to the
    request, and the client rendered the server's response. The communication started
    with a client-side request and ended with the server's response.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: 'We built our web applications based on this paradigm; however, some drawbacks
    existed in the technology: the client had to wait for the server''s response and
    refresh the browser to render it. This unidirectional nature of the communication
    required the client to initiate a request. Later technologies such as AJAX and
    long polling brought major advantages to our web applications. In AJAX, the client
    initiated a request but did not wait for the server''s response. In an asynchronous
    manner, the AJAX client-side callback method got the data from the server and
    the browsers'' new DHTML features rendered the data without refreshing the browser.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: Apart from unidirectional behavior, the HTTP dependencies of these technologies
    required the exchange of extra data in the form of HTTPS headers and cookies.
    This extra data caused latency and became a bottleneck for highly responsive web
    applications.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket reduced kilobytes of transmitted data to a few bytes and reduced latency
    from 150 milliseconds to 50 milliseconds (for a message packet plus the TCP round
    trip to establish the connection), and these two factors attracted the Google's
    attention (Ian Hickson).
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSocket (RFC 6455) is a full duplex and bidirectional protocol that transmits
    data in the form of frames between client and server. A WebSocket communication,
    as shown in the following figure, starts with an HTTP connection for a handshake
    process between a client and a server. Since firewalls let certain ports be open
    to communicate with the outside, we cannot start with the WebSocket protocol:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding WebSocket](img/image00788.jpeg)'
  id: totrans-1132
  prefs: []
  type: TYPE_IMG
- en: WebSocket communication
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: During the handshake process, the parties (client and server) decide which socket-based
    protocol to choose for transmitting data. At this stage, the server can validate
    the user using HTTP cookies and reject the connection if authentication or authorization
    fails.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: Then, both parties upgrade from HTTP to a socket-based protocol. From this point
    onward, the server and client communicate on a full duplex and bidirectional channel
    on a TCP connection.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: Either the client or server can send messages by streaming them into frame format.
    WebSocket uses the heartbeat mechanism using ping/pong message frames to keep
    the connection alive. This looks like sending a ping message from one party and
    expecting a pong from the other side. Either party can also close the channel
    and terminate the communication, as shown in the preceding diagram.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: Like a web URI relies on HTTP or HTTPS, WebSocket URI uses `ws` or `wss` schemes
    (for example, `ws://www.sample.org/` or `wss://www.sample.org/`) to communicate.
    WebSocket's `ws` works in a similar way to HTTP by transmitting non-encrypted
    data over TCP/IP. By contrast, `wss` relies on **Transport Layer Security** (**TLS**)
    over TCP, and this combination brings data security and integrity.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: A good question is where to use WebSocket. The best answer is to use it where
    low latency and high frequency of communication are critical—for example, if your
    endpoint data changes within 100 milliseconds and you expect to take very quick
    measures over the data changes.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework 4 includes a new Spring WebSocket module with Java WebSocket
    API standard (JSR-356) compatibility as well as some additional value-adding features.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: While using WebSocket brings advantages to a web application, a lack of compatibility
    in a version of some browser blocks WebSocket communication. To address this issue,
    Spring 4 includes a fallback option that simulates the WebSocket API in case of
    browser incompatibility.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket transmits data in the frame format, and apart from a single bit to
    distinguish between text and binary data, it is neutral to the message's content.
    In order to handle the message's format, the message needs some extra metadata,
    and the client and server should agree on an application-layer protocol, known
    as a **subprotocol**. The parties choose the subprotocol during the initial handshake.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket does not mandate the usage of subprotocols, but in the case of their
    absence, both the client and server need to transmit data in a predefined style
    standard, framework-specific, or customized format.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: Spring supports **Simple Text Orientated Messaging Protocol** (**STOMP**) as
    a subprotocol—known as STOMP over WebSocket—in a WebSocket communication. Spring's
    Messaging is built upon integration concepts such as messaging and channel and
    handler, along with annotation of message mapping. Using STOMP over WebSocket
    gives message-based features to a Spring WebSocket application.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: Using all of these new Spring 4 features, you can create a WebSocket application
    and broadcast a message to all subscribed clients as well as send a message to
    a specific user. In this chapter, we start by creating a simple Spring web application,
    which will show how to set up a WebSocket application and how a client can send
    and receive messages to or from an endpoint. In the second application, we will
    see how Spring WebSocket's fallback option can tackle browser incompatibly, how
    a broker based messaging system works with STOMP over WebSocket, and how subscribed
    clients can send and receive messages. In the last web application, however, we
    will show how we can send broker-based messages to a specific user.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple WebSocket application
  id: totrans-1145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, while developing a simple WebSocket application, we will learn
    about WebSocket's client and server components. As mentioned earlier, using a
    subprotocol is optional in a WebSocket communication. In this application, we
    have not used a subprotocol.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to set up a Spring web application. In order to dispatch
    a request to your service (called a handler in Spring WebSocket), you need to
    set up a framework Servlet (dispatcher Servlet). This means that you should register
    `DispatcherServlet` in `web.xml` and define your beans and service in the application
    context.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Spring application requires you to configure it in XML format.
    Spring introduced the Spring Boot module to get rid of XML configuration files
    in Spring applications. Spring Boot aims at configuring a Spring application by
    adding a few lines of annotation to the classes and tagging them as Spring artifacts
    (bean, services, configurations, and so on). By default, it also adds dependencies
    based on what it finds in the classpath. For example, if you have a web dependency,
    then Spring Boot can configure Spring MVC by default. It also lets you override
    this default behavior. Covering Spring Boot in complete detail would require a
    full book; we will just use it here to ease the configuration of a Spring application.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the Maven dependencies of this project:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As mentioned in the beginning of this section, there is no subprotocol (and,
    subsequently, no application-layer framework) to interpret WebSocket messages.
    This means that the client and server need to handle the job and be aware of the
    message's format.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server''s side, the handler (endpoint) receives and extracts the message
    and replies back (based on the business logic) to the client. In Spring, you can
    create a customized handler by extending either `TextWebSocketHandler` or `BinaryWebSocketHandler`.
    `TextWebSocketHandler` handles string or text messages (such as JSON data) and
    `BinaryWebSocketHandler` handles binary messages (such as image or media data).
    Here is a code listing that uses `TextWebSocketHandler`:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Since we process only JSON data here, the class `SampleTextWebSocketHandler`
    extends `TextWebSocketHandler`. The method `handleTextMessage` obtains the client's
    message by receiving its payload and converting it into JSON data, and then it
    sends a message back to the client.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to tell Spring to forward client requests to the endpoint (or handler
    here), we need to register the handler:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '`@Configuration` and `@EnableWebsocket` tell Spring this is the WebSocket configurator
    of the project. It registers our handler (`SampleTextWebSocketHandler`) and sets
    the request path (in a WebSocket URL, such as `ws://server-ip:port/path/wsAddress`)
    that will be forwarded to this handler.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the question is how to set up a Spring application and glue all of
    this stuff together. Spring Boot provides an easy way to set up a Spring-based
    application with a configurable embedded web server that you can "just run":'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '`@SpringBootApplication` tags the `EchoWebSocketBootApplication` class as a
    special configuration class of your application and `@SpringBootApplication` behaves
    like the following annotations:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`, which declares the class as a bean definition of an application
    context'
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`, which lets Spring Boot add a dependent bean definition
    based on the classpath (for example, `spring-webmvc` in the project classpath
    tells Spring Boot to set up a web application with its `DispatcherServlet` registration
    in `web.xml`)'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`, which is used to scan all annotations (services, controllers,
    configurations, and so on) within the same package (`com.springessentialsbook.chapter4`)
    and configure them accordingly'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `main` method calls `SpringApplication.run` to set up a Spring
    application within a web application without writing a single line of XML configuration
    (`applicationContext.xml` or `web.xml`).
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 'When a client wants to send a WebSocket request, it should create a JavaScript
    client object (`ws = new WebSocket(''ws://localhost:8090/path/wsAddress'')`) and
    pass the WebSocket service address. In order to receive the data, we need to attach
    a callback listener (`ws.onmessage`) and an error handler (`ws.onerror`), like
    so:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'You can run the application by running this command:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'This runs and deploys the web application on an embedded server on port `8090`
    (`8080` is not used here as it may conflict with your running Apache service).
    So, the index page of the application will be accessible at `http://localhost:8090/`
    (follow the instructions in `read-me.txt` to run the application). It should look
    like this:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple WebSocket application](img/image00789.jpeg)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
- en: The opening page of the application in a Chrome browser
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: When a user sends a text in Chrome, it will be handled by `SampleTextWebSocketHandler`,
    the handler will reply, and the response will be rendered in the browser.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: If you try to test this application in a version of Internet Explorer lower
    than 10, you will get a JavaScript error.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, certain versions of browsers do not support WebSocket.
    Spring 4 provides a fallback option to manage these types of browsers. In the
    next section, this feature of Spring will be explained.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: STOMP over WebSocket and the fallback option in Spring 4
  id: totrans-1175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that in a WebSocket application that does not
    use subprotocols, the client and server should be aware of the message format
    (JSON in this case) in order to handle it. In this section, we use STOMP as a
    subprotocol in a WebSocket application (this is known as **STOMP over WebSocket**)
    and show how this application layer protocol helps us handle messages.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: The messaging architecture in the previous application was an asynchronous client/server-based
    communication.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: The `spring-messaging` module brings features of asynchronous messaging systems
    to Spring Framework. It is based on some concepts inherited from Spring Integration,
    such as messages, message handlers (classes that handle messages), and message
    channels (data channels between senders and receivers that provide loose coupling
    during communication).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this section, we will explain how our Spring WebSocket application
    integrates with the Spring messaging system and works in a similar way to legacy
    messaging systems such as JMS.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: In the first application, we saw that in certain types of browsers, WebSocket
    communication failed because of browser incompatibility. In this section, we will
    explain how Spring's fallback option addresses this problem.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are asked to develop a browser-based chat room application in which
    anonymous users can join a chat room and any text sent by a user should be sent
    to all active users. This means that we need a topic that all users should be
    subscribed to and messages sent by any user should be broadcasted to all. Spring
    WebSocket features meet these requirements. In Spring, using STOMP over WebSocket,
    users can exchange messages in a similar way to JMS. In this section, we will
    develop a chat room application and explain some of Spring WebSocket's features.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to configure Spring to handle STOMP messages over WebSocket.
    Using Spring 4, you can instantly configure a very simple, lightweight (memory-based)
    message broker, set up subscription, and let controller methods serve client messages.
    The code for the `ChatroomWebSocketMessageBrokerConfigurer` class is:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '`@Configuration` tags a `ChatroomWebSocketMessageBrokerConfigurer` class as
    a Spring configuration class. `@EnableWebSocketMessageBroker` provides WebSocket
    messaging features backed by a message broker.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: 'The overridden method `configureMessageBroker`, as its name suggests, overrides
    the parent method for message broker configuration and sets:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '`setApplicationDestinationPrefixes`: Specify `/myApp` as the prefix, and any
    client message whose destination starts with `/myApp` will be routed to the controller''s
    message-handling methods.'
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enableSimpleBroker`: Set the broker topic to `/chatroomTopic`. Any messages
    whose destinations start with `/chatroomTopic` will be routed to the message broker
    (that is, broadcasted to other connected clients). Since we are using an in-memory
    broker, we can specify any topic. If we use a dedicated broker, the destination''s
    name would be `/topic` or `/queue`, based on the subscription model (pub/sub or
    point-to-point).'
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overridden method `registerStompEndpoints` is used to set the endpoint
    and fallback options. Let''s look at it closely:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: The client-side WebSocket can connect to the server's endpoint at `/broadcastMyMessage`.
    Since STOMP has been selected as the subprotocol, we do not need to know about
    the underlying message format and let STOMP handle it.
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.withSockJS()` method enables Spring's fallback option. This guarantees
    successful WebSocket communication in any type or version of browser.
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As Spring MVC forwards HTTP requests to methods in controllers, the MVC extension
    can receive STOMP messages over WebSocket and forward them to controller methods.
    A Spring `Controller` class can receive client STOMP messages whose destinations
    start with `/myApp`. The handler method can reply to subscribed clients by sending
    the returned message to the broker channel, and the broker replies to the client
    by sending the message to the response channel. At the end of this section, we
    will look at some more information about the messaging architecture. As an example,
    let''s look at the `ChatroomController` class:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Here, `@Controller` tags `ChatroomController` as an MVC workflow controller.
    `@MessageMapping` is used to tell the controller to map the client message to
    the handler method (`broadCastClientMessage`). This will be done by matching a
    message endpoint to the destination (`/broadcastMyMessage`). The method's returned
    object (`ReturnedDataModelBean`) will be sent back through the broker to the subscriber's
    topic (`/chatroomTopic/broadcastClientsMessages`) by the `@SendTo` annotation.
    Any message in the topic will be broadcast to all subscribers (clients). Note
    that clients do not wait for the response, since they send and listen to messages
    to and from the topic and not the service directly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'Our domain POJOs (`ClientInfoBean` and `ReturnedDataModelBean`), detailed as
    follows, will provide the communication message payloads (actual message content)
    between the client and server:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'To add some sort of security, we can add basic HTTP authentication, as follows
    (we are not going to explain Spring security in this chapter, but it will be detailed
    in the next chapter):'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The `@Configuration` tags this class as a configuration class and `@EnableGlobalMethodSecurity`
    and `@EnableWebSecurity` set security methods and web security in the class. In
    the `configure` method, we set basic authentication, and in `configureGlobal`,
    we set the recognized username and password as well as the role that the user
    belongs to.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Spring Security features, we should add the following Maven dependencies:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'As we explained in the previous section, the `@SpringBootApplication` tag sets
    up a Spring application within a web application without us having to write a
    single line of XML configuration (`applicationContext.xml` or `web.xml`):'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Finally, you can run the application by running this command:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'This runs and deploys the web application on an embedded web server on port
    `8090` (`8080` is not used as it may conflict with your running Apache service).
    So, the index page of the application will be accessible at `http://localhost:8090/`
    (follow `read-me.txt` to run the application):'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: On the client side, notice how the browser connects (with `joinChatRoom`) and
    sends data (in the `sendMyClientMessage` method). These methods use the JavaScript
    libraries SockJS and Stomp.js.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when a client subscribes to a topic, it registers a listener
    method (`stompClient.subscribe(topic, function(serverReturnedData){.…}`). The
    listener method will be called when any message (from any client) arrives in the
    topic.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, some versions of browsers do not support WebSocket. SockJS
    was introduced to handle all versions of browsers. On the client side, when you
    try to connect to the server, the SockJS client sends the `GET/info` message to
    get some information from the server. Then it chooses the transport protocol,
    which could be one of WebSocket, HTTP streaming, or HTTP long-polling. WebSocket
    is the preferred transport protocol; however, in case of browser incompatibility,
    it chooses HTTP streaming, and in the worse case, HTTP long-polling.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning of this section, we described how our WebSocket application
    integrates with the Spring messaging system and works in a way similar to legacy
    messaging systems.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: 'The overridden method settings of `@EnableWebSocketMessageBroker` and `ChatroomWebSocketMessageBrokerConfigurer`
    create a concrete message flow (refer to the following diagram). In our messaging
    architecture, channels decouple receivers and senders. The messaging architecture
    contains three channels:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: The client inbound channel (**Request channel**) for request messages sent from
    the client side
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client outbound channel (**Response channel**) for messages sent to the
    client side
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Broker channel** for internal server messages to the broker
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our system uses STOMP destinations for simple routing by prefix. Any client
    message whose destination starts with `/myApp` will be routed to controller message-handling
    methods. Any message whose destination starts with `/chatroomTopic` will be routed
    to the message broker.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '![STOMP over WebSocket and the fallback option in Spring 4](img/image00790.jpeg)'
  id: totrans-1216
  prefs: []
  type: TYPE_IMG
- en: The simple broker (in-memory) messaging architecture
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the messaging flow of our application:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: The client connects to the WebSocket endpoint (`/broadcastMyMessage`).
  id: totrans-1219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client messages to `/myApp/broadcastMyMessage` will be forwarded to the `ChatroomController`
    class (through the **Request channel**). The mapping controller's method passes
    the returned value to the Broker channel for the topic `/chatroomTopic/broadcastClientsMessages`.
  id: totrans-1220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The broker passes the message to the **Response channel**, which is the topic
    `/chatroomTopic/broadcastClientsMessages`, and clients subscribed to this topic
    receive the message.
  id: totrans-1221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Broadcasting a message to a single user in a WebSocket application
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw a WebSocket application of the multiple subscriber
    model, in which a broker sent messages to a topic. Since all clients had subscribed
    to the same topic, all of them received messages. Now, you are asked to develop
    an application that targets a specific user in a WebSocket chat application.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to develop an automated answering application in which a user
    sends a question to the system and gets an answer automatically. The application
    is almost the same as the previous one (STOMP over WebSocket and the fallback
    option in Spring 4), except that we should change the WebSocket configurer and
    endpoint on the server side and subscription on the client side. The code for
    the `AutoAnsweringWebSocketMessageBrokerConfigurer` class is:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `config.setUserDestinationPrefix("/user")` method sets a prefix noting
    that a user has subscribed and expects to get their own message on the topic.
    The code for the `AutoAnsweringController` class is:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In the endpoint, we use `@SendToUser` instead of `@SendTo("...")`. This forwards
    the response only to the sender of the message. `@MessageExceptionHandler` will
    send errors `(broadcast = false)` to the sender of message as well.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '`AutoAnsweringService` is just a mock service to return an answer to the client
    message. On the client side, we only add the `/user` prefix when a user subscribes
    to the topic (`/user/queue/message`):'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The topic `user/queue/error` is used to receive errors dispatched from the server
    side.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more about Spring's WebSocket support, go to [http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/websocket.html).
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: For more about WebSocket communication, refer to *Chapter 8*, *Replacing HTTP
    with WebSockets* from the book *Enterprise Web Development*, *Yakov Fain, Victor
    Rasputnis, Anatole Tartakovsky, Viktor Gamov*, *O'Reilly*.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained WebSocket-based communication, how Spring 4 has
    been upgraded to support WebSocket, and the fallback option to overcome browsers'
    WebSocket incompatibility. We also had a small sample of adding basic HTTP authentication,
    which is a part of Spring Security. We will discuss more on security in [Chapter
    5](part0057.xhtml#aid-1MBG22 "Chapter 5. Securing Your Applications"), *Securing
    Your Applications*.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Securing Your Applications
  id: totrans-1237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security provides a wide range of features for securing Java/Spring-based
    enterprise applications. At first glance, the security features of Servlets or
    EJB look an alternative of Spring Security; however, these solutions lack certain
    requirements for developing enterprise applications. The server's environment
    dependency could be another drawback of these solutions.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization are the main areas of application security.
    Authentication is the verification of a user's identity, whereas authorization
    is the verification of the privileges of a user.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security integrates with a variety of authentication models, most of
    which are provided by third-party providers. In addition, Spring Security has
    developed its own authentication models, based upon major security protocols.
    Here are some of these protocols:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  id: totrans-1241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Basic authentication
  id: totrans-1242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAAS
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Open Single Sign On
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open ID authentication
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is a big list of Spring Security models, we can only detail the
    most popular of them in this chapter.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security is quite strong on authorization features. We can categorize
    these features into three groups: web, method, and domain object authorization.
    Later, in the *Authorization* section, we will explain these categories.'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Spring Security features in a web application, you need to
    include the following dependencies in your project:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The **open standard for authorization** (**OAuth**) concept, introduced in late
    2006, aimed to allow third-party limited access to users' resources on Microsoft,
    Google, Facebook, Twitter, or similar accounts, without sharing their usernames
    and passwords.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: In 2010, OAuth was standardized as the OAuth 1.0a protocol in RFC 5849\. Later
    in 2012, it evolved to the OAuth 2.0 framework in RFC 6749\. In this chapter,
    we explain Spring's OAuth 2.0 framework implementation.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2.0 Authorization Framework enables a third-party application to obtain
    limited access to an HTTP service, either on behalf of a resource owner by orchestrating
    an approval interaction between the resource owner and the HTTP service, or by
    allowing the third-party application to obtain access on its own behalf ([http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749)).
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a separate module (`spring-security-oauth2`) for its OAuth 2.0
    implementation, which relies on Spring Security features. In this chapter, we
    explain authentication and how Spring facilitates the process by providing its
    own easy-to-use features as well as giving you options to plug in your customized
    implementation. Authorization is the second topic included in this chapter, in
    which we explain how to configure separate security models within the same application.
    In the last section, we explain Spring's OAuth 2.0 feature.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-1255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an application's security domain, the first thing that comes to mind is authentication.
    During the authentication process, an application compares a user's credentials
    (for example, a username and password or a token) with the information available
    to it. If these two match, it allows the process to enter the next step. We will
    follow the next step in the *Authorization* section.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security provides features to support a variety of security authentication
    protocols. In this section, we will focus on basis and form-based authentication.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a built-in form for the purpose of form-based authentication.
    In addition, it lets you define your own customized login form.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: Spring gives you the option to use in-memory authentication, in which the username
    and password will be hardcoded in the application.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: An alternative option is to use a customized authentication provider that lets
    you decide how to authenticate users by program, for example, calling a data layer
    service to validate users. It also lets you integrate Spring Security with your
    existing security framework.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need in order to configure Spring Security to authenticate
    users is to define a Servlet filter known as `springSecurityFilterChain`. This
    filter is responsible for applying security measures (for example, validating
    users, navigating to different pages after login bases on the user's role, and
    protecting application URLs) in a web application.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '`WebSecurityConfigurerAdapter` is a convenient Spring template for configuring
    `springSecurityFilterChain`:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '`@Configuration` registers this class as a configuration class. The method''s
    name, `configureGlobalSecurity`, is not important, as it only configures an `AuthenticationManagerBuilder`
    instance through autowire. The only important thing is annotating the class with
    `@EnableWebSecurity`, which registers Spring web security in the application.
    As you can see, we used in-memory authentication for simplicity, which hardcoded
    the user''s username, password, and role used for user authentication. In real
    enterprise applications, LDAP, databases or the cloud provide services for validating
    user credentials.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: We don't code all that much in the config class, but it really does a lot behind
    the scenes. Here are some of the features implemented by the class. Apart from
    user authentication and role assignment, we will explain other features next in
    this chapter.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: Protecting all application URLs by asking for authentication first
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Spring default login form to authenticate the user
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating users (operator/password, admin/password, accountant/password)
    and assigning separate roles for each user (user, admin, and accountant) using
    form-based authentication
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the user to log out
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSRF attack prevention
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we explained, in real-world enterprise applications, one never hardcodes
    user credentials within the application's code. You may have an existing security
    framework that calls a service in order to validate users. In this case, you can
    configure Spring Security in a customized service to authenticate the user.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: The authentication interface implementation is what carries user credentials
    within the Spring Security context. You can obtain the authentication object anywhere
    within the application using `SecurityContextHolder.getContext().getAuthentication()`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: When a user is authenticated, `Authentication` will be populated. If you don't
    specify `AuthenticationProvider` (for example, if you use in-memory authentication),
    `Authentication` will be populated automatically. Here, we look at how to customize
    `AuthenticationProvider` and populate the `Authentication` object.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how Spring''s `AuthenticationProvider` implementation
    class integrates with a customized user detail service (which returns user credentials
    from a data source):'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Your customized authentication provider should implement `AuthenticationProvider`
    and its `authenticate` method.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `userService` instance here should implement the Spring `UserDetailsService`
    interface and its `loadUserByUserName` method. The method returns the data model
    of a user. Note that you can extend Spring''s `User` object and create your own
    customized user. We mocked the `UserService` integration part with a data service.
    In a real application, there could be a service call to fetch and return user
    data, and your `UserServiceImpl` class will only wrap the user in the `UserDetails`
    data model, as follows:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: After this, you can set your customized provider in the configuration class,
    as shown in the following code. When a user is authenticated, the authentication
    object should be populated programmatically. Later in this chapter, in the *Authorization*
    section, we will explain this object.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We defined the `springSecurityFilterChain` filter in the first step. To make
    it work, we need to register it in the web application, like so:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The class doesn't need any code, as the superclass (`AbstractSecurityWebApplicationInitializer`)
    registers the Spring Security filter. This happens while the Spring context starts
    up.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t use Spring MVC, we should pass the following to the constructor:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The class `AnnotatedConfigDispatcherServletInitializer` extends Spring''s Servlet
    initializer `AbstractAnnotationConfigDispatcherServletInitializer`. This class
    allows Servlet 3 containers (for example, Tomcat) to detect the web application
    automatically, without needing `web.xml`. This is another step of simplifying
    the setting up of a web application, and it registers `DispatcherServlet` and
    Servlet mapping programmatically. By setting the `WebSecurityConfigurator` class
    in `getRootConfigClasses`, you tell the parent class method that creates the context
    of the application to use your annotated and customized Spring Security configuration
    class. The following is the code for the `AnnotatedConfigDispatcherServletInitializer`
    class:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: What we have configured so far in Spring Security is for checking whether the
    username and password are correct. If we want to configure other security features,
    such as defining a login page and the web application URL request to be authenticated,
    we need to override the `configure(HttpSecurity http)` method of `WebSecurityConfigurerAdapter`.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: 'In our customized security configurator, we define a login page (`login.jsp`)
    and an authorization failure page (`nonAuthorized.jsp`), as follows:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'This code tells Spring to process a submitted HTTP request form (with the POST
    method) with the expected username and password as parameters and `"/login"` as
    the action. Here is the login form:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Tip
  id: totrans-1293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't specify a username, password, and `loginProcessingUrl` parameter
    in the configuration file, Spring Security expects `j_username`, `j_password`,
    and `j_spring_security_check` from the client browser. By overriding Spring's
    default values, you can hide the Spring Security implementation from the client
    browser.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: A **cross-site request forgery** (**CSRF**) attack happens, for example, when
    a malicious link clicked by an authenticated web client performs an unwanted action,
    such as transferring funds, obtaining contact e-mails, or changing passwords.
    Spring Security provides a randomly generated CSRF to protect the client from
    CSRF attacks.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: If you omit `.loginPage` in the `configure` method, Spring uses its default
    login page, which is a very plain HTML login page. In this case, Spring Security
    uses the expected `j_username`, `j_password`, and `j_spring_security_check` parameters
    for the username, password, and action, and you should not configure them in the
    method.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we ask Spring to provide its own default login form:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Spring Security supports HTTP Basic authentication, in which the client browser
    opens a popup (for the initial time) when you want to access a resource that matches
    a pattern (`"/adResources*/**"` in this case):'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Server-side navigation could be the next step after authentication. Even though
    routing information is provided from the client side in modern client-side frameworks
    such as AngularJS, you may still want to keep routing logic on the server side.
    A success handler is a Spring Security feature that lets you define navigation
    logic after authentication in a web application.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security lets you configure customized server-side navigation after
    authentication. You can configure it inside the `configure` method (using `successHandler`):'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Your customized navigation handler should implement the interface `AuthenticationSuccessHandler`.
    `OnAuthenticationSuccess` is the method that will be called when a user is authenticated.
    Within this method, we should define the target URL. In the sample implementation
    class shown here, the user''s role is just used to define the target URL:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Spring Security lets you configure your security configuration in multiple
    methods, and in each method, you can define a different category of resources.
    Here, we have separated the security configuration for form-based and basic authentication
    into these two classes:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: For example, in one method, we configure resources in the `adResources` path
    to be viewed by the admin role in an HTTP-based authentication (the browser opens
    a popup and asks for a username and password). In the second method, we apply
    form login authorization and limit access to resources based on user roles.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  id: totrans-1309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Authentication* section, we showed how user-provided credentials (username/password)
    are compared with application-stored ones, and if they match, the user is authenticated.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: To boost security, we can limit the user's access to application resources.
    This is where authorization comes into the picture—the question of who should
    access which application's resources.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides very comprehensive authorization features. We can
    categorize these features into these three authorization groups:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: Web request (who can access which application URL?)
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method invoking (who can call a method?)
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain object access (who can see which data?)
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a customer should be able to see his own order and profile data,
    whereas an admin should be able to see all the customers' orders plus the data
    that is not visible to any customer.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: Since version 3.0 of Spring Security, Spring has added Spring EL expressions
    to its authorization features. Spring EL lets you convert complex authorization
    logic into simple expressions. In this section, we use Spring EL for authorization.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '`GrandAuthority` in Spring Security is the object for including a string value
    that is interchangeably called an authority, right, or permission (refer to the
    *Authentication* section, where the `AuthenticationProvider` interface is explained,
    to see how `GrandAuthority` is created). By default, if this string value starts
    with the prefix `ROLE_` (for example, `ROLE_ADMIN`), it will be considered as
    a user''s role. So, it is also flexible enough to be used as a permission if it
    does not start with the prefix. Spring Security uses this object for web, method,
    and domain object authorization.'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: 'For web request authorization, we can limit user access based on the user''s
    role in Spring Security, as follows (we will see later in this section how to
    do this in a controller):'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Since we use spring MVC, we deny all URLs that end with `.jsp` (`*.jsp`) and
    let MVC map the URL to the JSP page. We permit anybody to have access to the login
    page using (`.antMatchers("/", /login").permitAll()`).
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: We limit user access to accountant resources to the admin and accountant roles
    (for example, `antMatchers("/accountant*//**").access("hasRole('ADMIN') or hasRole('ACCOUNTANT')")`).
    We set an error URL and forward a user to it if he fails authentication or tries
    to access non-authorized resources with `failureUrl("/nonAuthorized")`.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add `@EnableGlobalMethodSecurity(prePostEnabled=true)` to be able
    to apply method/domain-level authorization:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We already described how to limit access to URLs using a configuration file.
    You can do the same thing in the controller''s methods too:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'For method-invoking authorization, you can configure Spring Security at the
    method level and define who can run a particular method in your application''s
    service layer:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'For domain object access, you can apply method-invoking authorization and have
    a service method to fine-tune who can see which data in the application. For example,
    in the service layer, you can limit access if the username parameter is equal
    to the logged-in username or the user has an admin role (refer to `bussinessServiceImpl`
    in the code):'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The OAuth2 Authorization Framework
  id: totrans-1331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OAuth2 Authorization Framework is simply a way to let third-party applications
    access your protected resources without you sharing your user credentials (username/password).
    You will have faced this situation when a website such as LinkedIn asks you to
    share your e-mail contacts, and when you agree, you are forwarded to your mail
    provider's login page (for example, Yahoo!).
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: When you log in, the mail provider asks for your permission to share your contacts
    with LinkedIn. Then, LinkedIn can get the list of your contacts in order to send
    them an invitation.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth2 relies on the following entities:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '**The resource owner**: This is the user with protected resources, for example,
    a Yahoo! e-mail user'
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The client or third-party application**: This is an external application
    that requires access to the owner''s protected resources, for example, LinkedIn'
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The authorization server**: This server grants access to the client/third
    party after authenticating the resource owner and obtaining authorization'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The resource server**: This server hosts the owner''s protected resources,
    for example, the Yahoo! server'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many leading providers (for example, Google and Facebook) have both authorization
    and resource servers.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram illustrates how the OAuth2 framework works in a simple form:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '![The OAuth2 Authorization Framework](img/image00791.jpeg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
- en: 'Spring facilitates the OAuth2 framework by reusing Spring Security concepts
    for authentication and authorization and includes new features to implement authorization
    and resource servers. To use Spring OAuth2 in your project, you need the following
    dependency:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: What we explained in the *Authentication* section with respect to validating
    the user and protecting resources remains the same here. The new things are the
    authorization and resource server settings.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2.0 service includes authorization and resource servers. Spring Security
    lets you have separate applications as authorization and resource servers, on
    which one authorization server could be shared by one or many resource servers,
    or have both types of servers in a single application. For simplicity, we implement
    authorization and resource servers within the same application.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: In the class `MultiOAuth2ResourceAndAuthorizationConfigurator`, we define resource
    and authorization servers. `@EnableResourceServer` tags the class `ResourceServerConfiguration`
    as a resource server, which defines resources with the URL `/public` as non-protected
    and ones with the `/protected/**` URL as secure resources that require a valid
    token to access.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableAuthorizationServer` tags `AuthorizationServerConfiguration` as an
    authorization server that grants tokens to third-party clients. `TokenStore` is
    a Spring interface; its implementation classes (`InMemoryTokenStore`, `JdbcTokenStore`,
    and `JwtTokenStore`) keep track of tokens.'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '`JdbcTokenStore` uses a database to store tokens and has a Spring-JDBC dependency.
    `JdbcTokenStore` is suitable when you want to have a history of tokens, recovery
    after server failure, or the sharing of tokens among several servers.'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '`JwtTokenStore` encodes token-related data into the token itself. `JwtTokenStore`
    does not make tokens persistent and requires `JwtAccessTokenConverter` as a translator
    between a JWT-encoded token and OAuth authentication information.'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we use the `InMemoryTokenStore` implementation class, but in
    real applications, using `JdbcTokenStore`/`JwtTokenStore` is a better practice.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: We reuse the `AuthenticationManager` class that was detailed in the *Authentication*
    section.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `configure(ClientDetailsServiceConfigurer clients)` is the location
    in which we configure token generation settings, as follows:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '`withClient` tells us which client can access resources (this is separate from
    user authentication)'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secret` is the client''s password'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authorities` tells us which user roles are eligible to access the resource'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authorizedGrantType` specifies which grant type the client has (for example,
    the refresh and access token)'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessTokenValiditySeconds` sets the token''s time to live'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The settings are mentioned in the following code:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The resources we granted access to using the token are included in a controller.
    Here, we define a very simple resource:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'You can run the project with the following command, which builds and runs the
    resource and authorization server:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'If you try the following, you can see the resource because this URL is unprotected:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'However, if you try the next command, you get a "non-authorized" error and
    you need a valid token to access this resource:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'You need to get a token first to be able to access protected resources. Spring
    MVC exposes an endpoint, `TokenEndpoint`, in order to get the token with the `/oauth/token`
    URL by default. The following command gives you an authorization token:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Now, you can provide the token and access the secure resource:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Notice that we set a time to live for the token and we need to refresh the
    token if it expires. The following command renews the token by calling the `/oauth/token`
    endpoint and passing `refresh_token` as the `grant_type` parameter:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Summary
  id: totrans-1374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we detailed some features of Spring Security. Since Spring
    Security is a separate module and has a variety of features, in order to get more
    information about the whole specification, you need to go through [https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html](https://docs.spring.io/spring-security/site/docs/current/reference/html/index.html)
    and [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/).
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Building a Single-Page Spring Application
  id: totrans-1376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having mastered many powerful features of Spring Framework while handling all
    the major technical concerns of enterprise applications, it is time to build a
    modern web application by putting all the techniques we learned in the previous
    chapters together. The current trend in web development is to build **single-page
    applications** (**SPAs**) that offer native-like user experience and an intuitive
    UI. In this chapter, let's build a responsive SPA powered by a Spring backend.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: We will use Ember.js for building the SPA and Bootstrap for styling and responsive
    behavior. For Ember development, we will use a command-line tool called **Ember
    CLI**, which runs on Node.js and combines a collection of supporting tools for
    various critical functions of JavaScript-based modern frontend development.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: The motivations behind SPAs
  id: totrans-1379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Spring mainly focuses on the server side, that is, the integration,
    service, and data layers. Spring relies on other web technologies for rendering
    the presentation layer. Although Spring MVC does facilitate the presentation layer
    with the help of web technologies such as JSP and Thymeleaf, all of them work
    based on server-side rendering and full-page refreshes for responding to user
    interactions. In this traditional approach, the presentation layer of a web application
    is composed of a bunch of totally independent HTML files served by a server on
    demand, each representing a single screen, with just one rendered to the client
    browser at a time, taking a full round trip to the server for each user interaction.
    This provides a very poor user experience compared to native desktop applications,
    which gracefully re-render just the specific parts of the screen when required.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use some AJAX-using frameworks such as jQuery, in order to
    get data from a server or even for partial rendering of the UI (as in the case
    of JSF), it requires a lot of server resources for the presentation layer, and
    server processing is easily exhausted when the number of concurrent users grows.
    The presentation layer concerns are distributed across both the server and client
    tiers in this approach. UI developers need both client-side as well as server-side
    skills in this case, which makes web development harder.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: Web developers had always been looking for a smarter method to build the UI
    of a data-driven application which is developed entirely on the client side, running
    inside a web browser, which offers a native-like rich user experience without
    a full refresh to the server for page transitions and navigations. They wanted
    a way to make their UI dynamic with data purely on the client side, eliminating
    the need for a server during frontend development, and plugs in to the server
    only when everything is ready on the client side. And for all these problems and
    requirements, the SPA paradigm is the answer.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: SPAs explained
  id: totrans-1383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An SPA is a web application or website composed entirely of static web resources
    such as HTML, JavaScript, and CSS, loaded just once into the web browser in a
    single page load. Once booted, it updates itself intelligently as the user starts
    interacting with it. Unlike traditional web applications that perform a full page
    refresh for screen navigations, SPA routes and redraws (re-renders) screens without
    reloading the whole page (or the next page) from the server. It reconstructs the
    DOM structure with the help of JavaScript and styles itself with CSS in response
    to user actions and application events in order to represent them on the screen.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: After the initial boot, the only time an SPA confers with a server is for dynamic
    data. SPAs usually rely on AJAX or WebSockets for data access from the server.
    The data transfer format is mostly JSON and sometimes XML. They contact the server
    via AJAX over HTTP asynchronously behind the scenes; this gives a smooth, fluid
    user experience without blocking the screen or keeping the user waiting for server
    responses. Besides, the server can synchronize its data changes with the client
    using the WebSocket API to provide a real-time experience.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: The architectural benefits of SPAs
  id: totrans-1386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the massive productivity gain and prominence of frontend developers,
    SPA offers many architectural benefits. It is blazingly fast compared to traditional
    server-rendered web applications, since it works entirely locally to the client.
    SPA offers a much more smooth and fluid user experience because of its immediate
    response, without needing us to resubmit the entire page to the server on every
    user interaction.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript-intensive web applications run best on modern web browsers with enough
    memory on the host computer. Most frameworks utilize many HTML5 features and newer
    JavaScript functionality such as AJAX. SPAs can kill older browsers on slower
    PCs in no time.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: SPAs offload the responsibility of the entire application state to the browser,
    freeing up server resources to focus on the core business logic (service) and
    data in terms of stateless web services, often designed as REST APIs. With SPAs,
    the server just becomes an API server; the entire user interaction is handled
    by the client, which improves server scalability a lot.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage, probably the most important one of SPAs, is that both client
    and server applications can be designed and evolved independently from each other.
    You can replace either of these without affecting the other as long as the endpoint
    (API) contracts remain intact. Also, you can let frontend developers build the
    UI and backend developers provide the data; both teams can focus on their own
    domain while working around a data contract.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks
  id: totrans-1392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developing an SPA in plain JavaScript is not a smart idea considering the magnitude
    of responsibility handled by the SPA paradigm. It would be extremely tiring and
    error-prone if we set out to write all the routing, data binding, screen authoring,
    and rendering code from scratch in our applications. Fortunately, a set of very
    impressive frameworks emerged out of the SPA concept. Each of them offers varying
    levels of abstraction and architecture styles; some of them use powerful templating
    technologies. Let''s take a look at the most popular SPA frameworks:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '**AngularJS**: Maintained by Google and supported by a community of developers
    and companies, Angular is the most popular and widely used SPA framework. It enhances
    vanilla HTML with the help of smart directives by adding two-way data binding.
    Angular supports localization and the building of reusable components.'
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReactJS**: Backed by Facebook, Instagram, and a community of developers and
    companies, React is the fastest growing SPA framework at the time of writing.
    Facebook and Instagram have been developed using React. Its working is based on
    the concept of virtual DOM, an in-memory representation of displayed DOM that
    can be rendered either at the client or server (using Node), and manipulated using
    one-way binding. React screens are authored using JSX, an extension of JavaScript
    that allows the easy quoting of HTML inside JavaScript functions.'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ember.js**: A very powerful JavaScript MVC framework created by Yehuda Katz
    and contributed to by a strong community of active developers, Ember is used by
    many popular heavy traffic websites and applications, such as Groupon, Yahoo!
    (Ad Manager Plus), Zendesk, Square, Discourse, and LivingSocial. Ember can be
    used for building mobile and desktop applications: Apple Music is a notable desktop
    application built with Ember. Ember addresses the end-to-end problems of client-side
    web applications in an opinionated fashion. An early adopter of web and JavaScript
    standards such as ES6, web components, and promises, Ember comes with a set of
    powerful productivity tools and components that make it a complete-stack frontend
    framework.'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use Ember.js for building an SPA that works as the
    frontend for a Spring API server. We will explore Ember.js, its core components,
    and the development tools first and then develop the frontend application using
    Ember, connecting to a Spring-based API server on the backend. This chapter will
    make you a full-stack developer with both server-side and client-side skills on
    the modern technology stack.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ember.js
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember is a comprehensive frontend framework for creating ambitious web applications.
    It is modeled after the **Model-View-Controller** (**MVC**) architectural pattern
    for the frontend. Its well-designed components with clearly defined responsibilities
    and rich capabilities allow developers to develop complex web applications with
    dramatically less code. In an Ember application, screens are composed using Handlebars
    templates that update themselves automatically when the underlying data changes.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember is productive out of the box, with a comprehensive development stack
    and a friendly API. The Ember development stack contains the following tools:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '**Ember CLI**: This is a command-line tool for creating projects, scaffolding,
    and managing their resources. It provides a development server with live reload,
    a testing framework, mocking server, and comprehensive asset management support.'
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ember Inspector**: This is a debugger-cum-inspector tool for Ember applications,
    shipped as a plugin for Firefox and Chrome browsers. It allows you to evaluate
    and change Ember objects, elements, and variables while debugging, and provides
    a visual representation of the running Ember app.'
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ember Data**: This subproject of Ember is a data-persistence library that
    can be directly mapped to a remote data source, such as a REST API. It maps Ember
    model objects with data entities on the server side via channels such as API endpoints.
    Ember Data provides adapters and serializers for standard REST and JSON API endpoints,
    and allows you to create your own adapters for any data source, for example, the
    browser''s local storage.'
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fastboot**: This is a server based on Node.js for the server-side rendering
    of Ember resources, eliminating the need for downloading JavaScript payloads post
    the loading of static assets for increased performance.'
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liquid Fire**: This provides animation support for Ember views.'
  id: totrans-1405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A testing framework**: Ember CLI integrates QUnit for testing Ember resources.'
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember is a very opinionated framework; this means that you are expected to structure
    the app by its own conventions, and then the framework takes care of the rest.
    If you follow the guidelines, you will end up writing very little, and very readable,
    code. Ember CLI generates the Ember project structure and artifacts with simple
    commands, in the way expected by the framework.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an Ember application
  id: totrans-1408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ember application is composed of a set of core elements with well-defined
    responsibilities and properties. They are defined under the Ember and DS namespaces
    of the Ember API.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram depicts the high-level structure of an Ember application:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '![The anatomy of an Ember application](img/image00792.jpeg)'
  id: totrans-1411
  prefs: []
  type: TYPE_IMG
- en: Routers
  id: totrans-1412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A router manages the application state. It maps a set of logical routes against
    unique URLs as mapped in the router configuration.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: Routes or route handlers
  id: totrans-1414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A route handler, also known as a route (defined in `Ember.Route`), represents
    the handler for an individual route transition. A route can render a template
    that displays a screen. A route provides a model (data) that can be consumed by
    its template and controller. It has a corresponding controller that can handle
    user actions and maintain the state. A route can handle user actions by itself.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  id: totrans-1416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates are HTML fragments, usually rendered by routes and components. The
    user interface of an Ember application is composed of a collection of templates.
    Templates use the Handlebars syntax, which looks like regular HTML with some Handlebars
    expressions, which are enclosed in double curly braces (`{{ }}`). These Handlebars
    expressions bind Ember resources such as properties, objects, helpers, and components.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: Components
  id: totrans-1418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Components control the behavior of the user interface. They handle user actions
    and manage many attributes that are used by the templates. A component consists
    of two parts:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript object that extends `Ember.Component`, where the actions and attributes
    are defined
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template that is rendered into the parent view, usually that of a router
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models
  id: totrans-1422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of the Ember Data project, models represent the state of domain data in
    an Ember application. An Ember application will typically have a set of models
    extending from `DS.Model`. Routes usually display model data with the help of
    templates and modify data from the action handlers. Models are often loaded from
    a store (`DS.Store`), while Model instances are fetched from the actual persistent
    storage, mostly an API endpoint on the web server. Models can be persisted to
    the store; usually, they are sent back to the appropriate API endpoints.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  id: totrans-1424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controllers have a limited role in modern Ember applications; they will be deprecated
    in future versions. Currently, their use is limited to maintaining the state for
    a route and handling user actions. Since routes and components can handle actions,
    they are the perfect places for adding action handlers instead of controllers.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: Besides these core elements, there are some supporting components that help
    the application development be easier and more elegant.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: Input helpers
  id: totrans-1427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are ready-made components bundled with Ember for taking inputs from users.
    Most of them are Ember versions of general form controls. Examples are the `{{input}}`
    and `{{textarea}}` input helpers. Custom-developed components can be used similarly
    to input helpers.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: Custom helpers
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helpers add custom functionality to an application when they are not readily
    available, for using inside templates. Mostly, they are used for some kind of
    formatting. Examples are `{{format-date}}` and `{{format-currency}}`.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Initializers
  id: totrans-1431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initializers can perform certain operations on application boot. There are
    two types of initializers: application initializers, which are executed on application
    boot, and application instance initializers, which load on application instance
    boot.'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-1433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services are objects that can hold data and functions whose scope is application-wide.
    They are typically used for encapsulating core business logic spanned across many
    routes. Services can be injected into controllers, routes, components, and so
    on, where their methods can be invoked.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ember CLI
  id: totrans-1435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember CLI is an integrated, rapid development environment for Ember applications.
    Based on Broccoli, a fast and reliable asset pipeline that runs on Node.js, Ember
    CLI is a powerful command-line interface that integrates many productivity tools
    and optimization utilities necessary for JavaScript development.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember CLI provides the following features and tools for Ember development:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: It creates a strong, convention-based project structure for Ember applications
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It generates Ember-specific application resources, such as routes, templates,
    and components, from the command line
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports template authoring in the Handlebars, HTMLBars, and Emblem.js formats
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports scripting in ES2015 (ES6) modules, CoffeeScript, and EmberScript
    syntaxes
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports CSS authoring in CSS, Sass, Compass, and Stylus
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It converts Node.js-style ES2015 modules into RequireJS-model AMD modules
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates the npm and Bower package managers for managing dependencies to
    JS libraries
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates a development server with LiveReload, which automatically rebuilds
    and updates code changes to all connected browsers
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs asset management functions for application resources (combining,
    minifying, uglifying, versioning, and so on)
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables the sharing of code and functionality using add-ons and blueprints
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter, we will use Ember CLI as a development tool for building
    an Ember application and its various artifacts.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ember CLI
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember CLI depends on Node.js. So, the first step is installing Node.js. Follow
    the instructions given on the website [http://nodejs.org](http://nodejs.org) to
    set up Node.js.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Node.js is installed, you can install Ember CLI using `npm`, with the
    following command:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Now, install Bower using the following command:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: You may optionally install Watchman for better watching of code changes and
    the PhantomJS test-running environment.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Ember CLI commands
  id: totrans-1456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once Ember CLI is installed, you may start creating Ember applications incrementally
    using this set of commands to generate the required Ember artifacts:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Purpose |'
  id: totrans-1458
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
- en: '| `ember` | Prints the available commands. |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
- en: '| `ember new <appname>` | Generates a fresh new project root folder with the
    same name as `<appname>`, the whole project structure, and all the necessary artifacts
    for a starter Ember application. |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
- en: '| `ember init` | Turns the current directory into an Ember application and
    generates all necessary artifacts. |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
- en: '| `ember build` | Builds and generates the deployable to the `dist` directory.
    Specify the environment using the environment flag, which defaults to `development`.
    |'
  id: totrans-1463
  prefs: []
  type: TYPE_TB
- en: '| `ember server (or serve)` | Starts the development server at port `4200`.
    You may point to another port using the `--port` flag, for example, `ember serve
    --port 8080`. |'
  id: totrans-1464
  prefs: []
  type: TYPE_TB
- en: '| `ember generate <generatortype> <name> <options>` | Generates specific generators,
    such as route, template, and helper, with the given name and options. Type `ember
    help generate` for the full list of available generators. Use the `--pod` flag
    for generators in the POD structure (explained later). |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
- en: '| `ember destroy <generatortype> <name> <options>` | Removes artifacts created
    using the `ember generate` command. Remember to use the `--pod` flag if it was
    used while generating the artifact. |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
- en: '| `ember test` | Runs tests written in the application using the Testem test
    runner. |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
- en: '| `ember install <addon-name>` | Installs the given add-on into the application
    and registers it in the `package.json` file. |'
  id: totrans-1468
  prefs: []
  type: TYPE_TB
- en: The Ember project structure
  id: totrans-1469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the `ember new <project-name>` command, Ember CLI generates and
    organizes files in a specific structure based on convention and then compiles
    them and performs a set of tasks during building and runtime. The following table
    describes the folder layout and important files generated by Ember CLI:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '| File/Folder | Description |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
- en: '| `app/` | This is the Ember application root. The `index.html` file and all
    your JavaScript files and templates go inside this, under proper subdirectories.
    Everything except `index.html` is compiled through the ES6 module transpiler,
    minified and concatenated to `<app-name>.js`, and then loaded by the `index.html`
    file at build time. |'
  id: totrans-1473
  prefs: []
  type: TYPE_TB
- en: '| `app/index.html` | This is the only HTML page loaded from the server, which
    boots the Ember application on load from `<app-name>.js`, and is loaded using
    the `<script/>` tag embedded in it. Ember builds the entire DOM structure from
    inside this foundation HTML document in the browser at runtime. |'
  id: totrans-1474
  prefs: []
  type: TYPE_TB
- en: '| `app/app.js` | This is the Ember application module. This is the application''s
    entry point, where all the other modules are initialized and injected in order
    to create the entire application instance based on the resolver and environment-specific
    configuration. |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
- en: '| `app/router.js` | This is the router configuration module of the application.
    |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
- en: '| `app/adapters/` | Adapters for Ember Data modules go here. This folder is
    generated when the `ember generate adapter <model-name>` command is executed for
    the first time. |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
- en: '| `app/components/` | All components go here, unless the `--pod` option is
    used. |'
  id: totrans-1478
  prefs: []
  type: TYPE_TB
- en: '| `app/controllers/` | All controllers go here, unless the `--pod` option is
    used. |'
  id: totrans-1479
  prefs: []
  type: TYPE_TB
- en: '| `app/helpers/` | All helpers go here, unless the `--pod` option is used.
    |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
- en: '| `app/models/` | All models go here, unless the `--pod` option is used. |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
- en: '| `app/routes/` | All routes go here, unless the `--pod` option is used. |'
  id: totrans-1482
  prefs: []
  type: TYPE_TB
- en: '| `app/services` | All services go here, unless the `--pod` option is used.
    |'
  id: totrans-1483
  prefs: []
  type: TYPE_TB
- en: '| `app/styles/` | Put all your style sheets for the application, whether Sass,
    LESS, Stylus, Compass, or plain CSS, here. Only plain CSS is supported by default;
    you can enable other types by installing the appropriate `npm` modules. For Sass,
    type `ember install ember-cli-sass` in the command line. For LESS, the command
    is `ember-cli-less`; for Compass, `ember-cli-compass-compiler`, and so on. For
    the default CSS option, add your styles to `app.css`. You can also organize the
    styles in different CSS files and import them to your `app.css` file. |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
- en: '| `app/templates/` | All templates go here, unless the `--pod` option is used.
    |'
  id: totrans-1485
  prefs: []
  type: TYPE_TB
- en: '| `bower.json` | This is the Bower configuration file. |'
  id: totrans-1486
  prefs: []
  type: TYPE_TB
- en: '| `bower_components/` | Dependencies managed by Bower go here. |'
  id: totrans-1487
  prefs: []
  type: TYPE_TB
- en: '| `config/` | Application configuration files fall here. |'
  id: totrans-1488
  prefs: []
  type: TYPE_TB
- en: '| `config/environment.js` | Your environment-specific configurations go inside
    this file. |'
  id: totrans-1489
  prefs: []
  type: TYPE_TB
- en: '| `dist/` | The deployable files generated by the build process go here. This
    is what you need to distribute for release. |'
  id: totrans-1490
  prefs: []
  type: TYPE_TB
- en: '| `ember-cli-build.js` | This is the Broccoli build file. Include all resources
    managed by Bower and `npm` here. |'
  id: totrans-1491
  prefs: []
  type: TYPE_TB
- en: '| `node_modules` | All node dependencies managed by npm go here. |'
  id: totrans-1492
  prefs: []
  type: TYPE_TB
- en: '| `package.json` | This is the NPM dependency configuration file. |'
  id: totrans-1493
  prefs: []
  type: TYPE_TB
- en: '| `public/` | This is a directory for uncompiled assets, such as fonts and
    images. The contents are copied as they are. |'
  id: totrans-1494
  prefs: []
  type: TYPE_TB
- en: '| `server/` | This is where you can set up a development server for mock APIs
    and tests. |'
  id: totrans-1495
  prefs: []
  type: TYPE_TB
- en: '| `tests/` | All your unit and integration tests go here. |'
  id: totrans-1496
  prefs: []
  type: TYPE_TB
- en: '| `tmp/` | This is a temporary folder for build execution. |'
  id: totrans-1497
  prefs: []
  type: TYPE_TB
- en: '| `vendor/` | Place your external dependencies that are not managed by npm
    or Bower here. |'
  id: totrans-1498
  prefs: []
  type: TYPE_TB
- en: At the end of the build process, Ember CLI generates the deployable at `dist/directory`.
    You need to distribute the contents of this directory for hosting the deployable
    on a web server on release.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: Working with the POD structure
  id: totrans-1500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the `ember generate <generator>` command generates artifacts inside
    specific resource directories directly under the `app` root directory. So, all
    your routes go under `app/routes`, templates under `app/templates`, and so on.
    However, this becomes a bit unmaintainable as the application grows. To solve
    this problem, Ember CLI provides the option of organizing your files in a feature-driven
    (POD) structure using the `--pod` flag when you generate an artifact using the
    `ember generate` command.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the POD structure to work, you need to first configure the POD
    directory in `config/environment.js` as given in the following code:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The preceding snippet specifies that all the artifacts you generate with the
    `--pod` flag will be generated inside the `<app-root>/pod-modules` directory.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: Once you configure the POD, you can start generating your artifacts with the
    `--pod` flag.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to generate a route inside the POD structure, use
    the following command:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: This will generate the route file at `/app/pod-modules/user/route.js`.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: POD modules group all the artifacts related to a feature in one place, thus
    making it more manageable.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Ember object model
  id: totrans-1510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember comes with a rich API out-of-the-box, extending vanilla JavaScript classes
    and introducing new structures, providing enhanced capabilities such as two-way
    data binding, property observation, and so on. It provides smarter replacements
    for most of the common JavaScript constructs such as objects and arrays.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: '`Ember.Object` is the main base class of all Ember objects. It provides a class
    system with advanced features such as mixins and constructor methods. `Ember.Object`
    provides many special features, such as computed properties, data binding, and
    property-value change observers.'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: Declaring types (classes) and instances
  id: totrans-1513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inherit all the features of `Ember.Object` in your objects; just extend
    it in a purely object-oriented fashion, as given in the following code:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The preceding snippet is just a declaration of the `User` type. Now, you need
    to instantiate this class structure in order to use it in your program, as follows:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'You can either call a no args constructor like the preceding snippet, or you
    can pass a set of attributes with values as a JS object in order to create an
    instance of a declared class, as follows:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Accessing and mutating properties
  id: totrans-1520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the type is initialized, you can access its properties using a `get` method,
    as follows:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Remember to always use the `get` method instead of `object.property`, since
    Ember objects store managed properties in a different hash, which provides a few
    special features, unlike a vanilla JS object.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you use the `set` method for enabling all the special features of
    Ember objects, such as computed properties and property observation:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Computed properties
  id: totrans-1526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A computed property is a virtual property derived from other normal properties,
    or it is a value returned by a function. `Ember.Object` can have computed properties
    too, as shown here:'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Once instantiated, you can access computed properties as well in the same manner
    as normal properties. They update themselves whenever a dependent property changes.
    You can create mutable computable properties too. The following is an example
    of a sensible implementation of such a computed property:'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Since the computed property is like any other function, you can add any business
    logic to it.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: Property observers
  id: totrans-1532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can observe normal or computed properties for any change in value. Register
    the property with `Ember.Observer` for this purpose. See the following example:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: In the preceding snippet, the `dobChanged` function will fire whenever the `dateOfBirth`
    property gets updated. You can bind multiple properties with a single observer
    method by passing all the properties as arguments into the `Ember.observer` method
    prior to the function definition.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computed properties can also be observed. However, the observer method will
    not be triggered until the computed property is accessed, even if the dependent
    properties are updated.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Working with collections
  id: totrans-1538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ember makes array manipulation smarter using a set of core collection classes,
    shown in the following table. Each of these provide many convenient methods that
    abstract complex array manipulation:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection type | Description |'
  id: totrans-1540
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1541
  prefs: []
  type: TYPE_TB
- en: '| `Ember.Array` | This is an abstract implementation of observer-friendly array-like
    behavior. Concrete implementations are expected to have implemented methods, such
    as `length()` and `objectAt()`. Notable convenient methods are `any()`, `every()`,
    `filter()`, `filterBy()`, `find()`, `findBy()`, `forEach()`, `getEach()`, `map()`,
    `mapBy()`, `objectAt()`, `replace()`, `reverse()`, `sortBy`, `without()`, and
    so on. |'
  id: totrans-1542
  prefs: []
  type: TYPE_TB
- en: '| `Ember.ArrayProxy` | `ArrayProxy` wraps objects that implement `Ember.Array`
    for binding use cases and swapping content while iterating. |'
  id: totrans-1543
  prefs: []
  type: TYPE_TB
- en: '| `Ember.MutableArray` | This is an extension of `Array`, supporting an array
    of ordered sets. |'
  id: totrans-1544
  prefs: []
  type: TYPE_TB
- en: '| `Ember.Enumerable` | This is a mixin for enumerating arrays. |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
- en: '| `Ember.NativeArray` | This is the most concrete implementation of all of
    the above. You would use this in most cases. |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
- en: Building UI templates using Handlebars
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary UI authoring technology in Ember.js is Handlebars. Handlebars templates
    allow HTML fragments to embed dynamic content using Handlebars expressions placed
    inside double curly braces (`{{ }}`), the dynamic scripting blocks. Handlebars
    expressions perform data binding with attributes of routes, models, controllers,
    components, services, utils, and even application instances. Here is a sample
    Handlebars expression:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: This code snippet expects an object (preferably derived from `Ember.Object`,
    though it binds with normal JS objects too) with the name `loggedInUser`, present
    somewhere in the context in the parent context hierarchy (template, controller,
    route, or application). Then, it establishes a one-way data binding with the `fullName`
    attribute of the `loggedInUser` object; hence, it just displays the value of the
    bound attribute.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars helpers
  id: totrans-1551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handlebars relies on helpers for business logic inside the dynamic scripting
    blocks. Handlebars executes the business logic implemented inside the helpers
    (if any) placed inside the curly braces, or it simply performs data binding with
    bound attributes.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember ships a set of built-in helpers and provides a nice way of developing
    custom helpers too. Built-in helpers can be categorized as follows:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: Input helpers
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow helpers
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event helpers
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development helpers
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helpers can either be inline or en bloc. Inline helpers are just one-liners,
    similar to empty HTML and XML tags. See the `action` helper, which is an inline
    helper that takes parameters for processing:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Inline helpers can be nested, embedding more dynamic values inside them:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Block helpers have a start and an end construct with the same name, similar
    to HTML tags:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Data binding with input helpers
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates can establish two-way data binding using input helpers. Input helpers
    are mostly HTML form elements wrapped inside Ember components or views. Ember
    ships some built-in input helpers, such as `Ember.TextField`, `Ember.TextArea`,
    and `Ember.Checkbox`. Let''s take a look at an example:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '`{{input}}` is a built-in input helper that wraps HTML input text fields and
    checkboxes based on the value of the `type` attribute, which defaults to `text`.
    It allows two-way binding between the generated `<input type="text"/>` tag and
    the attribute `editingUser.userName`. Whenever either of the values is changed,
    it updates the other participant of the two-way binding. The `{{input}}` helper
    supports many useful attributes, such as `readonly`, `required`, `size`, `height`,
    `name`, `autofocus`, `placeholder`, `tabindex`, and `maxlength`.'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes are created using the same `{{input}}` helper, but by setting the
    type attribute to `checkbox`. The `{{textarea}}` helper represents the HTML `<textarea/>`
    component.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own input helpers as Ember components, which we will learn
    later in this chapter.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: Using control flow helpers in Handlebars
  id: totrans-1570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like most scripting languages, Handlebars supports the following control flow
    helpers:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditionals:'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{if}}`'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{#else}}`'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{#else if}}`'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{#unless}}`'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loops:'
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{#each}}`'
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the `{{if}}`, `{{else}}`, and `{{else if}}` helpers:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The `{{#each}}` helper is used to loop (iterate) through a collection, display
    it, and provide event hooks or actions around each element in the collection.
    A typical `{{#each}}` helper looks like this:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Using event helpers
  id: totrans-1583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event helpers respond to user-invoked actions. The two primary event helpers
    in Ember are the `{{action}}` and `{{link-to}}` helpers.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{{link-to}}` helper helps in navigating to another route. See the following
    example:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The `{{action}}` helper is generally added to a normal HTML element in order
    to attach an event and event handler to it:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Handling routes
  id: totrans-1589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ember application transitions its state between a set of routes; each can
    render a template that displays the current state and a controller to support
    its state-based data. Routes are registered inside the router configuration, typically
    inside `router.js`, in the case of an Ember CLI project structure. Routes are
    defined inside their own JS files.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: 'Routes can be generated and autoconfigured from the command line as follows:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'This command generates `route.js` and `template.hbs` under `app/<pod-directory>/user/`.
    Upon generation, both artifacts will have a basic structure and you need to flesh
    them out according to your specific requirements. A typical route will have a
    model hook, which prepares its data. See the structure of a typical but minimal
    route given in the following code:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: In the preceding example, the `model` hook fetches data from `DS.Store`, the
    Ember Data repository. The route renders the `template.hbs` file in the same directory
    in the case of an Ember CLI project, unless another template is specified inside
    the `renderTemplate` method. The model of a route is available to the controller
    and template (via a controller) for manipulation and rendering.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: Handling UI behavior using components
  id: totrans-1596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the building blocks of dynamic UI fragments or elements in Ember.
    They render a template, optionally backed by a class extending `Ember.Component`.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to create a component is to create a template file with a dash-separated
    name in the `app/components/` directory. Then you can embed it in inside other
    templates by just calling `{{<component-name>}}` and passing the required parameters.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: Components are independent and completely isolated from the client context;
    all required data must be passed as parameters. However, if you use `{{yield}}`
    inside the template, it essentially becomes a block (or container) component,
    where you can add any content; this content can access any controller attribute
    and model.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: 'A component can be generated by the following command:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: This command generates two files, `component.js` and `template.hbs`, under the
    `app/<pod-dir>/components/<component-name>/` directory. If you do not use the
    `--pod` flag, it generates the `<component-name>.js` and `<component-name>.hbs`
    files under the directory `app/components/`.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: Components insert the content into the DOM structure, where it is invoked, and
    control the behavior of the inserted content. By default, a component renders
    a `<div/>` element with the content generated by its template inside the `<div/>`
    element. You can specify a different HTML element instead of the `<div/>` element
    by setting the `tagName` attribute inside the `component.js` file. Similarly,
    you can set CSS class names dynamically using another property, `assNameBindings`.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: Components provide some very useful life cycle hooks for manipulating different
    phases of the component. Some life cycle methods that can be overridden in the
    component class are `didInsertElement()`, `willInsertElement()`, and `willDestroyElement()`.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: Components support standard HTML element events, depending upon which `tagName`
    is being used. They support all the standard touch events such as `touchStart`
    and `touchMove`, keyboard events such as `keyDown`, `keyUp`, and `keyPressed`,
    mouse events such as `mouseDown`, `mouseOver`, `click`, and `doubleClick`, form
    events such as submit and change, and HTML5 drag and drop events such as `dragStart`
    and `dragEnd`. You just need to declare the event as a function inside the component
    class; the component will fire the event and the associated function will get
    invoked as the user interacts with it.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: Besides events, components can respond to action handlers, which are named functions
    defined inside the `actions` hash of the component class. These actions can be
    triggered anywhere from the component's template. Action handlers can accept parameters
    from the client code or templates.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: Building a ToggleButton component step by step
  id: totrans-1607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's learn how to build an Ember component step by step using Ember CLI. We'll
    build a toggle button that turns off and on when clicked on. The component just
    changes its label and style based on its status attribute, `isActive`. We use
    Bootstrap styles for this example.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s generate the component class and template file (`.hbs`) using
    Ember CLI. Issue this command from the command line at the root of your project:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'See the `component.js` and `template.hbs` files generated at `app/<pod-dir>/components/toggle-button/`.
    Open and see the `component.js` file, it looks as given in the following code:'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The generated `template.js` file just has `{{yield}}` inside it. Now you need
    to add necessary attributes and business logic into these two artifacts in order
    to make it a proper toggle button component. Here is a modified `component.js`
    file, with the proper behavior:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: In the preceding code, notice that you specified the `tagName` attribute as
    `button`; otherwise, the generated HTML would be `<div/>`. Also, see how CSS class
    names are bound dynamically based on the `isActive` attribute. The `currentLabel`
    attribute is a computed attribute that depends on a few other attributes. In effect,
    the component responds to a click event and actually toggles the `isActive` variable.
    Everything else will work based on this event.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the modified `template.js` file to see how it utilizes
    the attributes and events handled by the `component.js` file:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Surprise! This is all the content in the template. It''s so simple to build.
    All the rest of the heavy lifting is done by the `component.js` file itself. Now
    the most interesting part is how the component is invoked from the client. Let''s
    take a look:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This is how you add the toggle button component in your client code, it is mostly
    route's template. You can start clicking on the button repeatedly and see that
    it switches on and off.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: 'This component can be customized by overriding its default properties. Let''s
    try changing its labels when it is on and off from the client side:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: You can see the new active and inactive labels on the screen as you click on
    the button, toggling it. The toggle button is the simplest example of an Ember
    component, intended to give you just a taste of Ember components. A typical Ember
    application will have many complex components. Converting a reusable UI module
    or portion into a component is the best way to make your application more elegant
    and maintainable.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with Ember Data
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ember Data is Ember's data-access mechanism. It provides a simple API to deal
    with data, abstracting the complexities and protocols of data access and diverse
    data sources. With Ember Data, clients can deal with data models just as any other
    Ember object.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: 'Ember Data defines a set of fundamental components that handle various roles
    and responsibilities in data access. These components are grouped under the namespace
    `DS`. The following table describes the most important Ember Data components defined
    under `DS`:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Purpose |'
  id: totrans-1627
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1628
  prefs: []
  type: TYPE_TB
- en: '| `DS.Model` | This is the fundamental unit of data and represents a record
    in a data collection. You need to define your data models by extending this class.
    It provides methods to save, delete, reload, and iterate properties, relationships,
    related types, and so on. It provides information about states, attributes, fields,
    relationships, errors, and so on. Also, it provides life cycle hook events. |'
  id: totrans-1629
  prefs: []
  type: TYPE_TB
- en: '| `DS.Store` | This is the local repository of all the data created, fetched,
    and modified by Ember Data. `Store` fetches data with the help of adapters and
    converts them into appropriate `DS.Model` instances. Using serializers, `Store`
    serializes model instances into forms suitable for the servers. It provides methods
    for querying and creating new records. |'
  id: totrans-1630
  prefs: []
  type: TYPE_TB
- en: '| `DS.Adapter` | This is an abstract implementation that receives various persistence
    commands from Store and translates them into forms that the actual data source
    (such as a Server API or a browser local storage) understands. Ember ships two
    concrete implementations: `DS.RESTAdapter` and `DS.JSONAPIAdapter`. Override the
    adapters if you want to change the default behaviors or attributes, such as remote
    URLs and headers. |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
- en: '| `DS.Serializer` | This normalizes `DS.Model` instances into payloads for
    the API (or whichever data source it is) and serializes them back into the model.
    Two default serializers are `RestSerializer` and `JSONAPISerializer`. Override
    the serializers to customize the data formats for the server. |'
  id: totrans-1632
  prefs: []
  type: TYPE_TB
- en: Ember Data architecture
  id: totrans-1633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ember Data components communicate with each other asynchronously for data access
    operations, based on a **promise**. The `query` and `find` methods of both the
    **Store** and **Adapter** are asynchronous, and essentially return a **promise**
    object immediately. Once resolved, the model instance is created and returned
    to the client. The following diagram demonstrates how Ember Data components coordinate
    a `find` method operation asynchronously:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: '![Ember Data architecture](img/image00793.jpeg)'
  id: totrans-1635
  prefs: []
  type: TYPE_IMG
- en: The clients of Ember Data components, which are typically routes, components,
    controllers, services, and so on, do not directly deal with adapters and serializers.
    They talk to the **Store** and model for normal data-access operations. Since
    the `Route.model` method (hook) supports **promise** objects, the transition will
    pause until the **promise** is resolved. We do not deal with resolving promises
    and hence with asynchronicity; rather, Ember handles it smartly.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: Defining models
  id: totrans-1637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Models represent the domain data of an Ember application. They need to be defined
    in proper structures and registered with the store before they can be used for
    data access. An Ember CLI project expects models under the `app/models/` directory,
    or `app/<pod-dir>/models/` in case you are using the POD directory structure.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a sample model definition. The following is the definition of a
    user model:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Model attributes can be of the string, number, Boolean, and date types by default.
    For custom types, you need to subclass `DS.Transform`. Attributes can have default
    values too. You can specify default values as shown in the following line:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Defining model relationships
  id: totrans-1643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Models can engage in one-to-one, one-to-many, and many-to-many relationships
    among themselves:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: A one-to-one relationship is defined using `DS.belongsTo` in both model definitions
  id: totrans-1645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A one-to-many relationship is defined using `DS.belongsTo` in one model and
    `DS.hasMany` in the other model
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A many-to-many relationship is declared when both models have `DS.hasMany` defined
    for each other
  id: totrans-1647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Taskify application
  id: totrans-1648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey, it's time to build our Taskify application end-to-end. First, let's go
    back to building a proper API layer using Spring and then revisit Ember to build
    the frontend SPA. We will use Spring Data to connect to and access data from the
    API server.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, we will not apply any security to the server; we will just
    focus on performing CRUD operations on two models: `User` and `Task`. Both `User`
    and `Task` are related to each other: `Task belongsTo User`. We will build models
    on both (server and client) sides. Let''s see how both technologies work together
    without having direct dependencies on each other.'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: Building the API server app
  id: totrans-1651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored the building of web apps using Spring MVC in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Building the Web Layer with Spring Web MVC"), *Building the Web Layer
    with Spring Web MVC*. In [Chapter 3](part0044.xhtml#aid-19UOO1 "Chapter 3. Accessing
    Data with Spring"), *Accessing Data with Spring*, we also learned how to persist
    data using Spring Data JPA. We are going to apply both these techniques again
    for building an API application for Taskify.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and configuring the project
  id: totrans-1653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have already learned the basics of creating Spring MVC applications
    with Spring Data JPA, at this point, we will go into detail only about the specifics
    of the API endpoints. Refer to [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Building
    the Web Layer with Spring Web MVC"), *Building the Web Layer with Spring Web MVC*
    for Spring MVC configuration and [Chapter 3](part0044.xhtml#aid-19UOO1 "Chapter 3. Accessing
    Data with Spring"), *Accessing Data with Spring* for details about Spring Data
    JPA. Set up and configure the project with the following steps:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring MVC application with a dependency on Spring Data JPA and the
    database of your choice.
  id: totrans-1655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable JPA repositories, specifying the base packages. For JavaConfig, annotate
    like this:'
  id: totrans-1656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Configure Spring Data JPA artifacts such as `DataSource`, `JdbcTemplate`, `TransactionManager`,
    and `EntityManager` with the flavor of your choice.
  id: totrans-1658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the model definitions – User and Task
  id: totrans-1659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application has the following two models as domain objects:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the model definitions – User and Task](img/image00794.jpeg)'
  id: totrans-1661
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to realize these as Java classes, annotated as JPA entities, so
    that we can persist them to a database, as follows:'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '`User.java`'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '`Task.java`'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Once the JPA entities are ready, create the DAOs for both `User` and `Task`—`UserDAO`
    and `TaskDAO`—annotated with `@Repository`. As the best approach and for proper
    application layering, create the corresponding `@Service` beans too. Since we
    already covered the JPA `@Repository` and `@Service` classes in the previous chapters,
    the code for these beans is not listed here. You can find the exact code in the
    code bundle provided with this book.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: Building API endpoints for the Taskify app
  id: totrans-1668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the API server is to expose API endpoints for the consumption
    of clients, including the Taskify Ember frontend app. Let's build these web services
    in the REST model, with JSON data format support.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will list two classes annotated with `@RestController`:
    `UserController` and `TaskController`. The handler methods support asynchronous,
    non-blocking IO so that they are more scalable and faster. Handler methods are
    designed in the REST model. The HTTP methods `GET`, `POST`, `PUT`, and `DELETE`
    are mapped against the **Create**, **Read**, **Update**, and **Delete** (CRUD)
    operations.'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: UserController.java
  id: totrans-1671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UserController` exposes endpoints for CRUD operations on the `User` entity.
    You can see the endpoints of `UserController` accepting and producing JSON data
    appropriately in its code, which is as follows:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: TaskController.java
  id: totrans-1674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TaskController` maps request endpoints for CRUD operations around the `Task`
    entity. Its code is as follows:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: We have built all the necessary artifacts for the API server. You can package
    the application and deploy it. You should be able to access the `UserController`
    handlers at `http://<app-context-root>/api/v1/user` and the `TaskController` handlers
    at `http://<app-context-root>/api/v1/task/`. Now let's go build the frontend.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Building the Taskify Ember app
  id: totrans-1678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get back to Ember development to build our SPA. Follow these steps. We
    will occasionally refer to previous sections of this chapter, and detail the specifics
    here.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Taskify as an Ember CLI project
  id: totrans-1680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s generate the project and set up all the artifacts. Follow these steps:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Ember project using Ember CLI from the command line:'
  id: totrans-1682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Install `broccoli-merge-trees` and `broccoli-static-compiler` for a richer
    Broccoli configuration. Issue the following commands from the command line:'
  id: totrans-1684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Install Bootstrap with Bower from the command line:'
  id: totrans-1686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Configure Broccoli to include bootstrap.js, CSS, and fonts in the `ember-cli-build.js`
    file:'
  id: totrans-1688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'In the application, we will be using a third-party Ember add-on called `ember-bootstrap-datetimepicker`.
    Let''s install it into the project:'
  id: totrans-1690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Build `npm` and `bower` dependencies:'
  id: totrans-1692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Start the Ember server using the `ember serve` command, and make sure your application
    is accessible at `http://localhost:4200/`.
  id: totrans-1694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the POD directory inside `/config/environment.js`:'
  id: totrans-1695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Now we can start generating the required Ember artifacts in this POD directory.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Ember Data
  id: totrans-1698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need two models: `User` and `Task`. Let''s generate them first with the
    following code. For models, we do not use POD:'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Find the generated models under the `/app/models/` folder. Open them and set
    the attributes and relationships:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '`User.js`'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '`Task.js`'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Let''s generate an (Ember Data) application adapter that has some global properties
    common to all adapters:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Open the generated `/app/adapters/application.js` file, and add two attributes,
    `host` and `namespace`, with the right values as shown in the following code.
    After this, adapters for all models will take these attributes unless overridden
    individually:'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'We need to override the default serializers, as Ember Data expects the ID of
    the dependent objects for sideloading, where the API server sends out nested objects
    embedded within. So, generate both serializers from the command line and then
    update the content appropriately:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Update the generated `/app/serializers/user.js` file with the following content:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'Update the generated `/app/serializers/task.js` file with the following content:'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Configuring application routes
  id: totrans-1716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routes represent application states. They need to be registered with the router
    of the application in order to enable navigation. Our application has three primary
    routes: `index`, `user`, and `task`. Let''s generate them in the `pod` directory.
    Do it from the command line:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Take a look at `router.js` now; you will see these new routes registered there.
    Also, the `route.js` and `template.hbs` files generated for each of these under
    the POD directories will be present.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: Building the home screen
  id: totrans-1720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s set up the index template to show counts for the total number of
    tasks and the number of open tasks in the system. Open the `/app/modules/index/template.js`
    file and update it with this content:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The preceding template binds the model attributes using Handlebars and expects
    the model to be loaded with proper data. Let''s go build the model in the `route.js`
    file:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'In the preceding code, the model hook first loads data from the server using
    `DS.Store` (Ember Data), constructs the model object with attributes, including
    computed properties, and then returns. The home screen will look like the following
    image (ignore the headers for now):'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the home screen](img/image00795.jpeg)'
  id: totrans-1726
  prefs: []
  type: TYPE_IMG
- en: Building the user screen
  id: totrans-1727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s build the user screen for listing all the users in the system.
    Let''s build the model inside the route''s model hook first. Add this method inside
    `/app/modules/user/route.js`:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: You can see how beautifully Ember and Ember Data work together to simplify such
    an otherwise complex task of fetching, transforming, and deserializing data into
    model instances and finally making it available for the consumption of the template
    and controller, asynchronously, without blocking the screen.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s display this data on a screen. Update the `/app/modules/user/template.hbs`
    file with the following content:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Now you can see the `user` route at `http://localhost:4200/user`, which looks
    like this:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the user screen](img/image00796.jpeg)'
  id: totrans-1734
  prefs: []
  type: TYPE_IMG
- en: Building a custom helper
  id: totrans-1735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `template.hbs` file, you may notice a custom helper:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Let''s go build it; you should have already got an error since this helper
    hasn''t been defined yet. From the command line, generate it using the following
    command:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Update the generated `/app/helpers/format-date.js` file with the following
    script:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Now look at your browser; the user list should render properly.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: Adding action handlers
  id: totrans-1743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `/app/modules/user/template.hbs` file, there are four action invocations:
    `createNewUser`, `showUser`, `editUser`, and `deleteUser`. All these methods accept
    a `user` variable as a parameter. Let''s add these actions inside `/app/modules/user/route.js`
    first:'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-1745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Building a custom component – modal window
  id: totrans-1746
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code listing, both the `createNewUser` and `editUser` methods
    use `userViewModal` using jQuery. This is a Bootstrap modal window built as a
    custom Ember component. In fact, there are four components working together in
    a nested fashion: `{{modal-window}}`, `{{modal-header}}`, `{modal-body}}`, and
    `{{modal-footer}}`.'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate the artifacts from a commandline first:'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-1749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The `component.js` and `template.hbs` files should be generated under the `/app/modules/components/<component-name>/`
    directory. Now let''s update the `.js` and `.hbs` files to make it a true modal
    window:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '`modal-window/template.hbs`'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '`modal-window/component.js`'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '`modal-header/template.hbs`'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '`modal-header/component.js`'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '`modal-body/template.hbs`'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '`modal-body/component.js`'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '`modal-footer/template.hbs`'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '`modal-footer/component.js`'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Building userEditModal using {{modal-window}}
  id: totrans-1767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The four modal related components have been built; it''s time to add `userEditModal`
    into the `user/template.js` file. Add the following code or `userEditModal` into
    the `user/template.js` file:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'The preceding code listing integrates the user edit form with `{{modal-body}}`,
    with the form title inside `{{modal-header}}`, action buttons inside `{{modal-footer}}`,
    and all of this inside `{{modal-window}}` with the ID `userEditModal`. Just click
    the **Edit** button of a user row; you will see this nice modal window pop up
    in front of you:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '![Building userEditModal using {{modal-window}}](img/image00797.jpeg)'
  id: totrans-1771
  prefs: []
  type: TYPE_IMG
- en: 'The **Save** button of `userEditModal` invokes the `saveUser` action method,
    the **Cancel** button invokes the `closeEditModal` action, and the **Delete**
    button invokes `deleteUser`. Let''s add them inside the `actions` hash of `user/route.js`,
    next to `deleteUser`:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Similarly, `user/template.js` has `userViewModal`, which just displays the user
    data in read-only format. Now, you can easily derive it from `userEditModal`;
    hence, we're not listing it here.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: Building the task screen
  id: totrans-1775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The task screen follows the same pattern as the user screen. This section describes
    only the portions logically different from the user screen and assumes that you
    will start developing the task screen from the user screen and incorporate the
    changes described here. Also, you can see the complete code from the project files
    attached to this chapter of the book.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: 'The task screen has some extra state-specific data besides the model data (the
    list of tasks). For maintaining that data while the task screen is active, we
    will create a controller:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'The relationship between `Task` and `User` is that a task is created by a user
    and assigned to another user. So, on the edit task (or create new task) screen,
    a list of users should be shown in a selection box so that one can be selected
    from the list. For that, we need to load the list of users from `DS.store` to
    a variable inside the controller. Here is the controller method that loads the
    `user` list:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'This method will get fired on initialization of the controller, courtesy of
    the `.on("init")` construct. The template code extract that renders the user list
    in an HTML selection is here:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'The action method, `changeCreatedBy`, is listed here:'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-1784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Similarly, task priorities are also a list of integers from 1 to 10\. The code
    to load them is here (this goes inside the controller):'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Code for the priority selection box is as follows:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-1788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: As a further step, you may add security to both ends of the application. You
    may personalize tasks for the logged-in user. Ember also supports WebSockets.
    Tasks can be pushed to the client as they are assigned to the logged-in user by
    another user somewhere else. For simplicity, those advanced features are not covered
    in this chapter. However, with the knowledge you have gained in this and the previous
    chapters, you are already at a comfortable stage to implement end-to-end security
    and real-time updates using WebSockets inside Taskify.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of single-page applications and implemented
    a Taskify frontend as an SPA, connecting to the Spring-based API server on the
    backend. We got a fair understanding of Ember.js and its tools as we built our
    frontend. Spring and Ember have together simplified the building of an otherwise
    complex rich web application of this type. The use of Ember is just an illustration
    of how Spring can power the backend of modern SPAs. Spring powers SPAs built on
    other frameworks, such as Angular, React, and Backbone, created by teams across
    the globe.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have successfully covered the most important features of Spring Framework.
    This foundation enables you to venture into more advanced features of Spring,
    packaged as Spring portfolio projects. Projects such as Spring Integration, Spring
    AMQP, Spring Cloud, and Spring Web Services solve the more complex problems of
    enterprise computing. With the knowledge you have gained from this book, you can
    now design powerful solutions using Spring Framework and its subprojects.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Integrating with Other Web Frameworks
  id: totrans-1793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flexibility offered by Spring Framework to pick third-party products is
    one of the core value propositions of Spring and Spring supports integration with
    third-party presentation frameworks. While Spring's presentation layer framework—Spring
    MVC, brings the maximum extent of flexibility and efficiency to the development
    of web applications, Spring lets you integrate most popular presentation frameworks.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: Spring can be integrated with far too many of Java's web frameworks to be included
    in this chapter, and only the most popular ones, JSF and Struts, will be explained.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: Spring's JSF integration
  id: totrans-1796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A JSF web application can be easily integrated with Spring by loading a Spring
    context file within `web.xml` (through a context loader listener). Since JSF 1.2,
    Spring's `SpringBeanFacesELResolver` object reads Spring beans as JSF managed
    beans. JSF only deals with the presentation tier and has a controller named `FacesServlet`.
    All we need to do is register `FacesServlet` in the application deployment descriptor
    or `web.xml` (in this section, we use JavaConfig to register it) and map any request
    with the desired extension (`.xhtml` here) to go through `FacesServlet`.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should include the JSF API and its implementation in the project
    dependencies:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-1799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'The dispatcher Servlet initializer is the location to register `FacesServlet`.
    Notice that we set a mapping request to `FacesServlet` here. Since we use JavaConfig
    to register settings, we register `FacesServlet` in the `AnnotationConfigDispchServletInit`
    class, as follows:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-1801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Note
  id: totrans-1802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must set `FacesServlet` to start up on load prior to the others (notice `facesServlet.setLoadOnStartup`).
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: Another important setting is configuring the listener to read the `faces-config`
    XML file. By default, it looks for `faces-config.xml` under the `WEB-INF` folder.
    By setting `org.springframework.web.jsf.el.SpringBeanFacesELResolver` as `ELResolver`,
    we access Spring POJOs as JSF beans. By registering `DelegatingPhaseListenerMulticaster`,
    any Spring's bean that implements the `PhaseListener` interface, JSF's phase events
    will be broadcasted to corresponding implemented methods of `PhaseListener` in
    the Spring's bean.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `faces-config.xml` file:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'In JSF, we can define beans with a session, request, or application scope and
    the bean values retained within the specific scope. Setting the `eager` flag to
    `false` implies lazy initialization, which creates beans when the first request
    arrives, whereas `true` implies creating the beans on startup. The code for the
    `OrderBean` class is:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Also, these beans are available in the presentation layer to interact with
    the backend. On the first screen (`order.xhtml`), we call the bean''s method (`placeAnOrder`):'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'The method returns a confirmation as a string and specify navigation in the
    `action` attribute means the next page is `confirmation.xhtml`, which looks like
    this:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Spring's Struts integration
  id: totrans-1813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC relies on `DispatcherServlet`, which sends requests to controllers
    that are configurable mapping handlers with view and theme resolution. In Struts,
    the controller's name is `Action`. While `Action` instances will be instantiated
    for every request in Struts 2 to tackle the thread safety issue, Spring MVC creates
    controllers once, and each controller's instance serves all requests.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: To enable Spring integration with Struts 2, Struts provides `struts2-spring-plugin`.
    In Struts 2.1, Struts introduced the convention plugin (`struts2-convention-plugin`),
    which simplified the creation of `Action` classes (by annotation) without any
    configuration file (`struts.xml`). The plugin expects a set of naming conventions
    for the `Action` class, package, and view naming that will be explained in this
    section.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate Struts 2 with Spring, you need to add these dependencies:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'The `struts2-convention-plugin` plugin searches for packages with the strings
    "struts", "struts2", "action", or "actions", and detects `Action` classes either
    whose names end with `Action` (`*Action`) or who implement the interface `com.opensymphony.xwork2.Action`
    (or extend its subclass `com.opensymphony.xwork2.ActionSupport`). The code for
    the `ViewOrderAction` class is as follows:'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-1819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '`@Action` maps `/order` (in the request URL) to this action class and `@ResultPath`
    specifies where views (JSP files) exist. `@Result` specifies navigation to the
    next page up to the string value of the `execute()` method. We created `ViewOrderAction`
    to be able to navigate to a new page and to perform an action (business logic)
    when submitting a form within a view (`orderEntryForm.jsp`):'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Also, here is the JSP code that calls the `Action` class. Notice the form's
    `doOrder` action, which calls the `DoOrderAction` class (using `@Action("doOrder")`).
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-1823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'As you can see, we used `OrderVO`, whose code is as follows, as the data model
    in the view. Any changes to this object in the JSP code or action class will be
    carried forward to the next page:'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-1825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'In the `DoOrderAction` action class, in the method execution, we implement
    the business logic and return the string value of the method specified in the
    navigation logic in the presentation layer. Here, the action class either goes
    to `orderProceed.jsp` (if it is a valid order) or `failedOrder.jsp` (in the case
    of a failure). Here is the orderProceed.jsp page, to which a success order will
    be forwarded:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Summary
  id: totrans-1828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explained how to integrate Spring with two famous presentation
    technologies: JSF and Struts.'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more info about Spring''s integration with web frameworks here:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-integration.html)'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about Spring''s Struts plugin, visit this link:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '[http://struts.apache.org/docs/spring-plugin.html](http://struts.apache.org/docs/spring-plugin.html)'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more details about naming conventions in the Struts convention
    plugin here:'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: '[https://struts.apache.org/docs/convention-plugin.html](https://struts.apache.org/docs/convention-plugin.html)'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, big companies are shifting toward single-page applications in the
    presentation layer. To learn about this topic, read [Chapter 6](part0060.xhtml#aid-1P71O1
    "Chapter 6. Building a Single-Page Spring Application"), *Building a Single-Page
    Spring Application*.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
