- en: Porting Exploits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed how to write exploits in Metasploit.
    However, we do not need to create an exploit for particular software in cases
    where a public exploit is already available. A publicly available exploit might
    be in a different programming language such as Perl, Python, C, or others. Let''s
    now discover some strategies for porting exploits to the Metasploit framework
    in a variety of different programming languages. This mechanism enables us to
    transform existing exploits into Metasploit-compatible exploits, thus saving time
    and giving us the ability to switch payloads on the fly. By the end of this chapter,
    we will have learned about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Porting exploits from various programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering the essentials from standalone exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Metasploit modules from existing standalone scanners/tool scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting scripts into the Metasploit framework is an easy job if we can figure
    out which essentials from the existing exploits can be used in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: This idea of porting exploits into Metasploit saves time by making standalone
    scripts workable on a wide range of networks rather than a single system. Also,
    it makes a penetration test more organized due to every exploit being accessible
    from Metasploit. Let's understand how we can achieve portability using Metasploit
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a stack-based buffer overflow exploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the upcoming example, we will see how we can import an exploit written in
    Python to Metasploit. The publicly available exploit can be downloaded from: [https://www.exploit-db.com/exploits/31255/](https://www.exploit-db.com/exploits/31255/).
    Let''s analyze the exploit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This straightforward exploit logs into the PCMAN FTP 2.0 software on port `21`
    using anonymous credentials and exploits the software using the `CWD` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire process of the previous exploit can be broken down into the following
    set of points:'
  prefs: []
  type: TYPE_NORMAL
- en: Store username, password, and host in `fuser`, `pass`, and `host` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `junk` variable with `2008` A characters. Here, `2008` is the offset
    to overwrite EIP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the JMP ESP address to the `espaddress` variable. Here, `espaddress 0x71ab9372`
    is the target return address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store 10 NOPs in the `nops` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the payload for executing the calculator in the `shellcode` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concatenate `junk`, `espaddress`, `nops`, and `shellcode` and store them in
    the `sploit` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a socket using `s.socket(s.AF_INET,s.SOCK_STREAM)` and connect to the
    host using `connect((host,21))` on port 21.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply the `fuser` and `fpass` using `USER` and `PASS` to log in to the target
    successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue the `CWD` command followed by the `sploit` variable. This will cause the
    EIP overwrite at an offset of `2008` and pop up the calculator application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try executing the exploit and analyze the results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2167f364-4221-4433-8a30-d9a6e721d154.png)'
  prefs: []
  type: TYPE_IMG
- en: The original exploit takes the username, password, and host from the command
    line. However, we modified the mechanism with fixed hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we executed the exploit, the following screen showed up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13f57961-9c6e-4e48-a1ea-33d9ee9819cc.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the calculator application has popped up, which states that
    the exploit is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s find out what essential values we need to take from the preceding exploit
    to generate an equivalent module in Metasploit from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Serial Number** | **Variables** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Offset value | `2008` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Target return/jump address/value found in executable modules using JMP
    ESP search | `0x71AB9372` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Target port | `21` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Number of leading NOP bytes to the shellcode to remove irregularities
    | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Logic | The `CWD` command followed by junk data of 2008 bytes, followed
    by EIP, NOPs, and shellcode |'
  prefs: []
  type: TYPE_TB
- en: We have all the information required to build a Metasploit module. In the next
    section, we will see how Metasploit aids FTP processes and how easy it is to create
    an exploit module in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Metasploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to start building a Metasploit module is to copy an existing similar
    module and make changes to it. However, a `Mona.py` script can also generate Metasploit-specific
    modules on the fly. We will see how to generate quick exploits using `Mona.py`
    script in the latter sections of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the equivalent code of the exploit in Metasploit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we worked on many exploit modules. This exploit is
    no different. We started by including all the required libraries and the `ftp.rb`
    library from the `/lib/msf/core/exploit` directory. Next, we assigned all the
    necessary information in the `initialize` section. Gathering the essentials from
    the exploit, we assigned `Ret` with the return address and set the `Offset` as
    `2008`. We also declared the value for the `FTPPASS` option as `''anonymous''`.
    Let''s see the next section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `connect_login` method will connect to the target and try performing a login
    to the software using the anonymous credentials we supplied. But wait! When did
    we supply the credentials? The `FTPUSER` and `FTPPASS` options for the module
    are enabled automatically by including the FTP library. The default value for
    `FTPUSER` is `anonymous`. However, for `FTPPASS`, we supplied the value as `anonymous`
    in the `register_options` already.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `rand_text_alpha` to generate the junk of `2008` using the value
    of `Offset` from the `Targets` field, and then store it in the `sploit` variable.
    We also save the value of `Ret` from the `Targets` field in little-endian format,
    using a `pack('V')` function in the `sploit` variable. Concatenating NOPs generated
    by the `make_nop` function with the shellcode, we store it to the `sploit` variable.
    Our input data is ready to be supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we just send the data in the `sploit` variable to the target in the `CWD`
    command using the `send_cmd` function from the FTP library. So, how is Metasploit
    different? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: We didn't need to create junk data because the `rand_text_aplha` function did
    it for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We didn't need to provide the `Ret` address in the little-endian format because
    the `pack('V')` function helped us transform it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We never needed to manually specify NOPs as `make_nops` did it for us automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did not need to supply any hardcoded shellcode since we can decide and change
    the payload on the runtime. This saves time by eliminating manual changes to the
    shellcode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We simply leveraged the FTP library to create and connect the socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, we didn't need to connect and log in using manual commands
    because Metasploit did it for us using a single method, that is, `connect_login`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting the target application with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw how beneficial the use of Metasploit over existing exploits is. Let''s
    exploit the application and analyze the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dade4e48-05f5-4b43-879d-808fcfc4b1db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that `FTPPASS` and `FTPUSER` already have the values set as `anonymous`.
    Let''s supply `RHOST` and the payload type to exploit the target machine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/526769ad-65ee-4cc0-8748-fb6ed698e058.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our exploit executed successfully. Metasploit also provided
    some additional features, which makes exploitation more intelligent. We will look
    at these features in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a check method for exploits in Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible, in Metasploit, to check for the vulnerable version before exploiting
    the vulnerable application. This is very important since if the version of the
    application running at the target is not vulnerable, it may crash the application
    and the possibility of exploiting the target becomes nil. Let''s write an example
    check code for the application we exploited in the previous section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We begin the `check` method by issuing a call to the `connect_login` method.
    This will initiate a connection to the target. If the connection is successful
    and the application returns the banner, we match it to the banner of the vulnerable
    application using a regex expression. If the banner matches, we mark the application
    as vulnerable using `Exploit::Checkcode::Appears`. However, if we are not able
    to authenticate but the banner is correct, we return the same `Exploit::Checkcode::Appears`
    value, which denotes the application as vulnerable. In case all of these checks
    fail, we return `Exploit::CheckCode::Safe` to mark the application as not vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if the application is vulnerable or not by issuing a `check` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/104c9107-d4f9-41c9-8fd3-c546231d8ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the application is vulnerable. We can proceed to the exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on implementing the `check` method, refer to: [https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method](https://github.com/rapid7/metasploit-framework/wiki/How-to-write-a-check%28%29-method).
  prefs: []
  type: TYPE_NORMAL
- en: Importing web-based RCE into Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can import web application exploits
    into Metasploit. Our entire focus throughout this chapter will be to grasp essential
    functions equivalent to those used in different programming languages. In this
    example, we will look at the PHP utility belt remote code execution vulnerability
    disclosed on 8 December 2015\. The vulnerable application can be downloaded from: [https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip](https://www.exploit-db.com/apps/222c6e2ed4c86f0646016e43d1947a1f-php-utility-belt-master.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remote code execution vulnerability lies in the code parameter of a `POST`
    request, which, when manipulated using specially crafted data, can lead to the
    execution of server-side code. Let''s see how we can exploit this vulnerability
    manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d544578-7e5a-447e-aed6-15e04c2f6f11.png)'
  prefs: []
  type: TYPE_IMG
- en: The command we used in the preceding screenshot is `fwrite`, which writes data
    to a file. We used `fwrite` to open a file called `info.php` in the writable mode.
    We wrote `<?php $a = "net user"; echo shell_exec($a);?>` to the file.
  prefs: []
  type: TYPE_NORMAL
- en: When our command runs, it will create a new file called `info.php` and will
    put the PHP content into this file. Next, we just need to browse to the `info.php`
    file, where the result of the command can be seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s browse to the `info.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b694398-d3b8-424e-a4ce-a4e7f2255d57.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that all the user accounts are listed on the `info.php` page. To
    write a Metasploit module for the PHP belt remote code execution vulnerability,
    we are required to make GET/POST requests to the page. We will need to make a
    request where we POST our malicious data onto the vulnerable server and potentially
    get meterpreter access.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important things to do while exploiting a web-based bug in Metasploit
    are to figure out the web methods, figure out the ways of using those methods,
    and figure out what parameters to pass to those methods. Moreover, another thing
    that we need to know is the exact path of the file that is vulnerable to the attack.
    In this case, we know that the vulnerability is present in the `CODE` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Grasping the important web functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The important web methods in the context of web applications are located in
    the `client.rb` library file under `/lib/msf/core/exploit/http`, which further
    links to `client.rb` and the `client_request.rb` file under `/lib/rex/proto/http`,
    where core variables and methods related to `GET` and `POST` requests are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods from the `/lib/msf/core/exploit/http/client.rb` library
    file can be used to create HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee7dc12f-ae07-400b-9995-596ac1b8ff56.png)'
  prefs: []
  type: TYPE_IMG
- en: The `send_request_raw` and `send_request_cgi` methods are relevant when making
    a HTTP-based request, but in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: We have `send_request_cgi`, which offers much more flexibility than the traditional
    `send_request_raw` function in some cases, whereas `send_request_raw` helps to
    make more straightforward connections. We will discuss more on these methods in
    the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what values we need to pass to these functions, we need to investigate
    the `REX` library. The `REX` library presents the following headers relevant to
    the request types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1ae8b68-eddd-4e6e-b464-3bbaa675cbf9.png)'
  prefs: []
  type: TYPE_IMG
- en: We can pass a variety of values related to our requests by using the preceding
    parameters. One such example is setting our specific cookie and a host of other
    parameters of our choice. Let's keep things simple and focus on the `URI` parameter,
    that is, the path of the exploitable web file.
  prefs: []
  type: TYPE_NORMAL
- en: The `method` parameter specifies that it is either a `GET` or a `POST` type
    request. We will make use of these while fetching/posting data to the target.
  prefs: []
  type: TYPE_NORMAL
- en: The essentials of the GET/POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GET` method will request data or a web page from a specified resource and
    use it to browse web pages. On the other hand, the `POST` command sends the data
    from a form or a specific value to the resource for further processing. Now, this
    comes in handy when writing exploits that are web-based. The HTTP library simplifies
    posting particular queries or data to the specified pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we need to perform in this exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `POST` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send our payload to the vulnerable application using the `CODE` parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get Meterpreter access to the target
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a few post exploitation functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are clear on the tasks that we need to perform. Let's take a further step
    and generate a compatible matching exploit, and confirm that it's working.
  prefs: []
  type: TYPE_NORMAL
- en: Importing an HTTP exploit into Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the exploit for the PHP utility belt remote code execution vulnerability
    in Metasploit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have declared all the required libraries and provided the
    necessary information in the initialize section. Since we are exploiting a PHP-based
    vulnerability, we choose the platform as PHP. We set `DisableNops` to true to
    turn off `NOP` usage in the payload since the exploit targets remote code execution
    vulnerability in a web application rather than a software-based vulnerability.
    We know that the vulnerability lies in the `ajax.php` file. Therefore, we declared
    the value of `TARGETURI` to the `ajax.php` file. We also created a new string
    variable called `CHECKURI`, which will help us create a check method for the exploit.
    Let''s look at the next part of the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We used the `send_request_cgi` method to accommodate the `POST` requests in
    an efficient way. We set the value of method as `POST`, URI as the target URI
    in the normalized format, and the value of the `POST` parameter `CODE` as `fwrite(fopen('info.php','w'),'<?php
    echo phpinfo();?>');`. This payload will create a new file called `info.php` while
    writing the code which, when executed, will display a PHP information page. We
    created another request for fetching the contents of the `info.php` file we just
    created. We did this using the `send_request_raw` technique and setting the method
    as `GET`. The `CHECKURI` variable, which we created earlier, will serve as the
    URI for this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that we stored the result of the request in the `resp` variable.
    Next, we match the body of `resp` to the `phpinfo()` expression. If the result
    is true, it will denote that the `info.php` file was created successfully onto
    the target and the value of `Exploit::CheckCode::Vulnerable` will return to the
    user, which will display a message marking the target as vulnerable. Otherwise,
    it will mark the target as safe using `Exploit::CheckCode::Safe`. Let''s now jump
    into the exploit method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see we just created a simple `POST` request with our payload in the
    code parameter. As soon as it executes on the target, we get PHP Meterpreter access.
    Let''s see this exploit in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b55d368-febe-452a-98e2-fab97148a29f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we have Meterpreter access on the target. We have successfully
    converted remote code execution vulnerability into a working exploit in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Official Metasploit modules for the PHP utility belt already exists. You can
    download the exploit from: [https://www.exploit-db.com/exploits/39554/](https://www.exploit-db.com/exploits/39554/).
  prefs: []
  type: TYPE_NORMAL
- en: Importing TCP server/browser-based exploits into Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will see how we can import browser-based or TCP
    server-based exploits in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'During an application test or a penetration test, we might encounter software
    that may fail to parse data from a request/response and end up crashing. Let''s
    see an example of an application that has vulnerability when parsing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db3f606-a65b-424e-b98c-1170c42baf3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application used in this example is BSplayer 2.68\. We can see that we
    have a Python exploit listening on port `81`. The vulnerability lies in parsing
    the remote server''s response when a user tries to play a video from a URL. Let''s
    see what happens when we try to stream content from our listener on port `81`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd716a16-ebc1-470d-a30c-e13b7ecf3684.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the calculator application popping up, which denotes that the exploit
    is working successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Download the Python exploit for BSplayer 2.68 from: [https://www.exploit-db.com/exploits/36477/](https://www.exploit-db.com/exploits/36477/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the exploit code and gather essential information from it to build
    the Metasploit module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6674a0f-3c2a-4a48-9719-879662dc9dfd.png)'
  prefs: []
  type: TYPE_IMG
- en: The exploit is straightforward. However, the author of the exploit has used
    the backward jumping technique to find the shellcode that was delivered by the
    payload. This technique is used to countermeasure space restrictions. Another
    thing to note here is that the author has sent the malicious buffer twice to execute
    the payload due to the nature of the vulnerability. Let's try building a table
    in the next section with all the data we require to convert this exploit into
    a Metasploit-compatible module.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following table that highlights all the necessary values
    and their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Serial number** | **Variable** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Offset value | `2048` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Known location in memory containing POP-POP-RETN series of instructions/P-P-R
    address | `0x0000583b` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Backward jump/long jump to find the shellcode | `\xe9\x85\xe9\xff\xff`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Short jump/pointer to the next SEH frame | `\xeb\xf9\x90\x90` |'
  prefs: []
  type: TYPE_TB
- en: We now have all the essentials to build the Metasploit module for the BSplayer
    2.68 application. We can see that the author has placed the shellcode precisely
    after `2048` NOPs. However, this does not mean that the actual offset value is
    `2048`. The author of the exploit has placed it before the SEH overwrite because
    there might be no space left for the shellcode. However, we will take this value
    as the offset, since we will follow the exact procedure from the original exploit.
    Additionally, `\xcc` is a breakpoint opcode, but in this exploit, it has been
    used as padding. The `jmplong` variable stores the backward jump to the shellcode
    since there are space constraints. The `nseh` variable stores the address of the
    next frame, which is nothing but a short jump, as we discussed in the previous
    chapter. The `seh` variable stores the address of the `P/P/R` instruction sequence.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note here is that in this scenario, we need the target
    to make a connection to our exploit server, rather than us trying to reach the
    target machine. Hence, our exploit server should always listen for incoming connections
    and, based on the request, it should deliver the malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Metasploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start the coding part of our exploit in Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Having worked with so many exploits, we can see that the preceding code section
    is no different, with the exception of the TCP server library file from `/lib/msf/core/exploit/tcp_server.rb`.
    The TCP server library provides all the necessary methods required for handling
    incoming requests and processing them in various ways. Inclusion of this library
    enables additional options such as `SRVHOST`, `SRVPORT`, and `SSL`. Let''s look
    at the remaining part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have no exploit method with this type of exploit. However,
    we have the `on_client_connect`, `on_client_data`, and `on_client_disconnect`
    methods. The most useful and the easiest is the `on_client_connect` method. This
    method is fired as soon as a client connects to the exploit server on the chosen
    `SRVHOST` and `SRVPORT`.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we created NOPs in the Metasploit way using `make_nops` and
    embedded the payload using `payload.encoded`, thus eliminating the use of hardcoded
    payloads. We assembled the rest of the `sploit` variable using a similar method
    to the one used for the original exploit. However, to send the malicious data
    back to the target when requested, we have used `client.put()`, which will respond
    with our chosen data to the target. Since the exploit requires the data to be
    sent twice to the target, we have used `client.get_once` to ensure that the data
    is transmitted twice instead of being merged into a single unit. Sending the data
    twice to the target, we fire the handler that actively looks for incoming sessions
    from successful exploits. In the end, we close the connection to the target by
    issuing a `service.client_close` call.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we have used the `client` object in our code. This is because
    the incoming request from a particular target will be considered as a separate
    object and it will also allow multiple targets to connect at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our Metasploit module in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/724811da-24b6-42b5-a4e6-8abdb9895c45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s connect to the exploit server on port `8080` from BSplayer 2.8 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273b6582-a87e-408e-8bae-3b0031ac184d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as a connection attempt is made to our exploit handler, the Meterpreter
    payload is delivered to the target, and we are presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58eb7755-4617-4b6b-a4ab-79a918e32311.png)'
  prefs: []
  type: TYPE_IMG
- en: Jackpot! The Meterpreter shell is now accessible. We successfully wrote an exploit
    server module in Metasploit using TCP server libraries. In Metasploit, we can
    also establish HTTP server functionalities using HTTP server libraries.
  prefs: []
  type: TYPE_NORMAL
- en: For more on HTTP server functions, refer to: [https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb](https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/http/server.rb).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Covering the brainstorming exercises of porting exploits, we have now developed
    approaches to import various kinds of exploits in Metasploit. After going through
    this chapter, we have learned how we can port exploits of different kinds into
    the framework with ease. In this chapter, we have developed mechanisms to figure
    out the essentials from a standalone exploit. We saw various HTTP functions and
    their use in exploitation. We have also refreshed our knowledge of SEH-based exploits
    and how exploit servers are built.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try your hands at the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Port 10 exploits to Metasploit from: [https://exploit-db.com/](https://exploit-db.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on at least 3 browser exploits and port them to Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try creating your own custom shellcode module and port it to Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, by now, we have covered most of the exploit writing exercises. In the next
    chapter, we will see how we can leverage Metasploit to carry out penetration testing
    on various services, including VOIP, DBMS, SCADA, and much more.
  prefs: []
  type: TYPE_NORMAL
