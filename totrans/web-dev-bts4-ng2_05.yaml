- en: Chapter 5. Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web applications require more than one page or view, and Angular is well
    equipped to handle this with its router. The router uses JavaScript code and manages
    the navigation between views as users perform application tasks. In this chapter,
    we will take a look at how we can create static routes, as well as routes containing
    parameters, and how to configure them. We will also discover some of the pitfalls
    we might face. In this chapter, we will set up the top navigation with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Component router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router link and router outlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating components and navigation for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've heard about **Single-Page Applications** ( **SPA** ) many times, but
    why develop web applications like that? What are the benefits?
  prefs: []
  type: TYPE_NORMAL
- en: The main idea for using SPAs is quite simple—users would like to use web applications
    which look like and behave like native applications. An SPA is a web application
    that loads a single HTML page and dynamically updates it as the user interacts
    with multiple components on it. Some of the components support many states, such
    as open, collapsed, and so on. Implementing all of these features with server-side
    rendering is hard to do, therefore much of the work happens on the client side,
    in JavaScript. This is achieved by separating data from the presentation of data
    by having a model layer that handles data and a view layer that reads from the
    models.
  prefs: []
  type: TYPE_NORMAL
- en: This idea brings some level of complexity to the code and often results in changing
    people's minds about the development process. Now we start thinking about the
    conceptual parts of the application, file and module structures, performance issues
    over bootstrapping, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are making an SPA and we don't want any page refreshes, we'll use the
    routing capabilities of Angular. The routing module is a crucial part of Angular.
    From one side it helps to update the URL of the browser as the user navigates
    through the application. From another side, it allows changes to the URL of the
    browser to drive navigation through the web application, thus allowing the user
    to create bookmarks to locations deep within the SPA. As a bonus, we can split
    the application into multiple bundles and load them on demand.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of HTML 5, browsers acquired the ability to create programmatically
    new browser history entries that change the displayed URL without the need for
    a new request. This is achieved using the `pushState` method of history that exposes
    the browser's navigational history to JavaScript. So now, instead of relying on
    the anchor hack to navigate routes, modern frameworks can count on `pushState`
    to perform history manipulation without reloads.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router uses this model to interpret a browser URL as an instruction
    to navigate to a client-generated view. We can pass optional parameters along
    to the view component to help it decide what specific content to present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal, create the folder `ecommerce` and move in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the content of the project from the folder `chapter_5/1.ecommerce-seed`
    into the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following script to install NPM modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the TypeScript watcher and lite server with following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This script opens the web browser and navigates to the welcome page of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Routing path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, let''s plan out exactly what routes we''re going to need for
    the Dream Bean grocery store website:'
  prefs: []
  type: TYPE_NORMAL
- en: The welcome view uses the `/#/welcome` path. It is going to be our entry point
    for the application, which will list all categories in a grid and slideshow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The products view utilizes the `/#/products` path. We'll be able to see the
    goodies within the chosen category there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We show the products view on `/#/product/:id` . Here, we will display information
    about the product. The `:id` here and in the next example is a token for a route
    parameter. We will talk about it later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/#/cart` path is where we will see the cart view list all items in the
    user's shopping cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the checkout view with the `/#/checkout/:id` path, we will include a form
    that will allow a user to add contact information; it also provides the order
    information and purchase conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all of our essential routes; now let's take a look at how we can create
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The router is packaged as a module inside Angular, but it is not a part of
    the Angular core, so we need to manually include it inside the bootstrapping configuration
    in the `systemjs.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The base URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have decided to use routing, then we should add the `base` element as
    the first child in the `head` tag. The reference in this tag resolves relative
    URLs and hyperlinks, and tells the router how to compose navigation URLs. For
    our project, I assigned the `"/"` to the `href` of the `base` element, because
    the `app` folder is the application root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we deploy the application to the server within a particular context, such
    as `portal` , then we must change this value accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Angular router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The actual routing from one view to another happens with the help of the **Angular
    router** . It is an optional service, and represents the component view for a
    specific URL. It has its own library package, and we must import from it before
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The router configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application must have only one router. We should configure it so that it
    knows how to map the browser's URL to the corresponding `Route` and determine
    the component to display. The primary way to do that uses the `RouterModule.forRoot`
    function with an array of routes which bootstraps the application with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the file `app.routes.ts` and import necessary elements from the router
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the constants to keep the application routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the array of route objects that describe how to navigate. Each route
    maps a URL `path` to a `component` to display. The router parses and constructs
    the URL, helping us to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Path references to the base element, eliminating the necessity of using leading
    splashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second item in the router configuration points only to `products` , but
    as I mentioned earlier, we''ll be able to see the goodies within the chosen category
    there. It sounds like the information we would like to include in our URL is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: We can leave the request without extra information to get all the products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the particular category to fetch the products belonging to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These kinds of parameters do not fit easily into a URL path, so, usually, it
    is complicated or impossible to create the pattern matching required to translate
    an incoming URL to a named route. Fortunately, the Angular router supports the
    **URL** **query string** for conveying any arbitrary information during navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Router parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third element in the `routes` array has an `id` in its path. It is a token
    for a **route** **parameter** ; the value corresponding with the view component
    will use it to find and present the product information. In our example, the URL
    `'product/20'` keeps the value `20` of the `id` parameter. The `ProductComponent`
    can use this value to find and display the product with an ID equaling `20` .
    This route is commented out because we don't have the `ProductComponent` implemented
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Route versus query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the general rules to help you choose what parameters to use. Use the
    route parameters when the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The value is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value is necessary for navigation to another route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the query parameters when the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The value is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value is complex or contains multivariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register routing in bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the end, we should use the `RouterModule.forRoot` method to return a new
    instance of `RouterModule` containing the configured and ready-to-use router service
    provider and required routing libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to register the returned module in `AppModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, when a user types the address of the Dream Bean website, he/she provides
    the website domain name: [http://www.dreambean.com](http://www.dreambean.com)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL does not match any configured routes, and Angular cannot show any
    component at that moment. The user must click on some link to navigate to the
    view, or we can teach the configuration to display the particular route with the
    help of the `redirectTo` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After those changes, if the user navigates to the original URL, the router translates
    from the initial URL (`''` ) to the default URL (`'welcome'` ) and displays the
    Welcome View.
  prefs: []
  type: TYPE_NORMAL
- en: 'The redirected route has a required property, `pathMatch` , to tell the router
    how to match the URL to the path. We have two options for this value:'
  prefs: []
  type: TYPE_NORMAL
- en: The `full` shows that the selected route must match the entire URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prefix` dictates to the router to match the redirect route to any URL that
    begins with the prefixed value in the `path` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router outlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, once we have settled the router configuration, it's time to present some
    components on the screen. But wait—we need a place for them, and this is why the
    router outlet is coming to the stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RouterOutlet` is a placeholder that Angular dynamically fills based on
    the application''s route. The `RouterOutlet` is the part of the `RouterModule`
    imported before, so we don''t need to import it elsewhere. Here is a wireframe
    that splits the SPA into three rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router outlet](Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe of the SPA
  prefs: []
  type: TYPE_NORMAL
- en: In the first row, we keep the `NavigationComponent` ; in the last row, the footer
    container. All space in between is the place where the `RouterOutlet` will display
    the corresponding view.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We configured the application routes and added them to the `AppModule` , so
    now we need to create the Welcome View because it is a crucial part of the routing.
    Create a `welcome` folder and two files inside `welcome.component.html` and `welcome.component.ts`
    . Now move the content of `app.component.html` between the `navbar` and the footer
    into `welcome.component.html` and replace it. Markup represents the `RouterOutlet`
    as a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste the following content into the `welcome.component.ts` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I moved almost all code from the `AppComponent` into `WelcomeComponent` , and
    it dramatically reduced its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I used the link to navigate from Welcome View to the products view with a selected
    category instead of making a call to the `selectCategory` method, so I deleted
    the last one as well.
  prefs: []
  type: TYPE_NORMAL
- en: The footer component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, when you have an idea how to create a component, you can do it yourself.
    Create the `footer` folder, `footer.component.ts` , and `footer.component.html`
    . Here, the source code of the `footer.component.ts` is the following :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it looks the same as other components that we created before.
    Move the content of the footer container from the `application.component.html`
    into the `footer.component.html` and replace it with the `FooterComponent` tag,
    so now the HTML of our application looks pretty neat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The category data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I kept the category data as part of the `AppComponent` because it was a quick
    and obvious way at the moment when we started development. Now, as application
    grows, it''s time to move all category data into the category file. Open the `category.ts`
    file and copy the following source code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `getCategories` function returns the list of categories. The `getCategory`
    returns the category found by the ID or throws a `CategoryNotFoundException` .
  prefs: []
  type: TYPE_NORMAL
- en: Category card view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open the `category-card.component.html` file and change the markup as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When a user clicks on the **Browse** button, Angular calls the `filterProducts`
    method with a category specified as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `category-card.component.ts` file, import the `Router` from the library,
    and add the reference in the constructor of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the `filterProducts` method. We use a router configured in
    the bootstrapping of the application and available in this component. Because
    we decided to use query parameters, I invoked a navigation method and passed the
    same name as the second parameter object. We can convey any information and Angular
    will convert it into the query string of URL like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are done with the Welcome View and are now moving to the Products View.
  prefs: []
  type: TYPE_NORMAL
- en: The product data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We don''t use the back end server to return the products data yet, so let''s
    create the `product.ts` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely, you will find a similarity to the `category.ts` file. I'm
    just following the naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Products View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Products View provides a listing of all goodies within the chosen category.
    From it, a customer can see all product information, and add any of the listed
    products to his or her shopping cart. A user can also navigate to any of the provided
    categories or use the **Quick Shop** feature to search products by name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Products View](Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe of the products view
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of this component is a composition of two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: The first column contains the **Quick Shop** and list of **Categories**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second column is a nested column combined into rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick shop component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is an `input-group` field for searching and using `Quick Shop` to see
    the products available in the grocery. We use the URL query string for conveying
    the search information as we did for the category because we don't know what the
    user will type into the search field. Create the `product` folder where we will
    add all components and services belonging to `product.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `product-search.component.html` in the `product` folder with
    the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I use the Bootstrap 4 `input-groups` with a button inside the `Card` component.
    The template reference variable `search` grants us direct access to an input element
    so that we can use the text value in the `searchProduct` method when a user types
    the product name and clicks on the **Go!** button. Create the `product-search.component.ts`
    file and create the `ProductSearch` component similar to a `CategoryCard` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I use the navigation method of `Router` to search for a product by name with
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Quick shop component](Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to create the `CategoryList` component so that the user can
    use it to select the category.
  prefs: []
  type: TYPE_NORMAL
- en: List of categories component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 3](text00047.html#page "Chapter 5. Routing") , *Advanced Bootstrap
    Components and Customization* , we introduced the flexible Bootstrap 4 `list-group`
    component. `Categories` is a list of unordered items, so we can use this particular
    one to render categories quickly. I use the same mechanism to update the URL with
    the specific category that we used in `CategoryCard` component. Create `category-list.component.html`
    in the `category` folder with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Card` component wraps the `list-group` . The built-in `NgFor` directive
    helps to organize iteration through categories to display the items. Create the
    `category-list.component.ts` , and copy and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getCategories` function from the `category` file to assign all of
    them to the `categories` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Update the CategoryModule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should update the `CategoryModule` with the new component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I have exported the `CategoryListComponent` because we will use it in other
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Router links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, the users navigate between views as a result of an action
    that they have performed on a link, such as a click happening on an anchor tag.
    We can bind the router to the links on a page, so that when the user clicks on
    the link, it will navigate to the appropriate application view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The router logs activity in the history journal of the browser so that the back
    and forward buttons work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular team introduced a `RouterLink` directive to the anchor tag to bind
    it to the template expression containing the array of route link parameters. Let's
    create the `Product Card` component with the help of `RouterLink` .
  prefs: []
  type: TYPE_NORMAL
- en: Product card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I suppose it is a good idea to present the product as a card. I create the
    `product-card.component.html` in the `product` folder with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In our code, the `RouterLink` binds in the anchor tag. Pay attention to the
    template expression we bind to the `routerLink` . Obviously, it is an array, which
    means that we can add more than one item, and Angular will combine them to build
    the URL. We can specify all the pieces of the route exclusively, like `"product/1"`
    , but I intentionally leave them as separated items of an array as it''s easy
    to maintain. Let''s parse it:'
  prefs: []
  type: TYPE_NORMAL
- en: The first item identifies the parent root `"/product"` path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no parameters for this parent element, such as `"product/groups/1"`
    , so we are done with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second item identifies the child route for the product and requires the
    ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation with `RouterLink` is very flexible, so we can write an application
    with multiple levels of routing with a link parameters array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `product-card.component.ts` in the `product` folder. The `RouterLink`
    belongs to `RouterModule` , so it''s available on markup now. Copy and paste the
    following code into the `product-card.component.ts` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will bind the data from `ProductGreedComponent` into the instance of `ProductCardComponent`
    via the `product` property.
  prefs: []
  type: TYPE_NORMAL
- en: Products grid component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to show the products as a grid with three columns and multiple rows.
    The card component is the most suitable one to display the product information
    and navigate to the product view. All of the cards in the row must have the same
    width and height. How can we display them in a particular place inside the parent
    grid layout? Let''s create `product-grid.component.html` and `product-grid.component.ts`
    files in the `product` folder. Copy and paste the following code into the `product-grid.component.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Card groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the **Bootstrap 4 Card** groups to present multiple cards as a single
    attached element with equal width and height. We need only include all cards within
    a parent element marked with the `card-group` class. Copy and paste the following
    code into the `product-grid.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is not what I want because some cards are attached to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Card groups](Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Card columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another layout is `card-columns` from Bootstrap 4\. It allows you to display
    multiple cards in each column. Each card inside a column is stacked on top of
    another. Include all cards within a `card-columns` class. Copy and paste the following
    code into the `product-grid.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks quite funny:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Card columns](Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Card desks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last layout is a card desk from Bootstrap 4\. It is similar to the Card
    group, except the cards aren''t attached to each other. This one requires two
    wrapping elements: `card-deck-wrapper` and a `card-deck` . It uses table styles
    for the sizing and the gutters on `card-deck` . The `card-deck-wrapper` is used
    to negative margin out the border-spacing on the `card-deck` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move back to the `product-card.component.html` file and update it with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Card Desk works perfectly enough with one row, so we expose the `products`
    input in `ProductCardComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `setClasses` method helps change the card's background if the product has
    a `special` price. We call the `buy` method when the user clicks on the **Buy
    Now** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of that in place, we can update the markup of the `ProductGridComponent`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Quite neat, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we use our pretty component, we need to transform an array of products
    into an array of rows with three products per line. Please pay attention to the
    code in the constructor of the `ProductGridComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We split the products into multiple rows containing a maximum of three columns.
  prefs: []
  type: TYPE_NORMAL
- en: Combine them all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we create the component that will combine all of  our other product components
    to display them in a place provided by the router outlet tag. Will you please
    welcome the `ProductListComponent` !
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `product-list.component.ts` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `product-list.component.html` , and copy and paste the next
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it draws the `ProductSearchComponent` and `CategoryListComponent`
    in the first column and the `ProductGridComponent` in the second one, which corresponds
    to our wireframe.
  prefs: []
  type: TYPE_NORMAL
- en: The product module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last two cents in the `product` folder are the `ProductModule` . Create
    the `product.module.ts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It imports the `CategoryModule` as well as system modules. We declare and export
    all of the four components that we created before.
  prefs: []
  type: TYPE_NORMAL
- en: Update the AllModule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, with `CategoryModule` and `ProductModule` in place, we need make all of
    their components available to the application so that we can import them into
    the `AppModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `NavbarComponent` , `FooterComponent` , and `WelcomeComponent` belong to
    the `AppModule` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_5/2.ecommerce-router` .
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router change events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned when looking at router configuration, the `ProductListComponent`
    can represent the Product View when a user navigates to the URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ActivatedRouter` class contains the information about a route associated
    with a component loaded in an outlet. We can subscribe to route change events
    to inform the `ProductGridComponent` about the changes happening in the query
    parameters of the URL. Open the `product-grid.component.ts` file, import `ActivatedRouter`
    from the library, and inject it into the `router` property of the constructor.
    Now we can subscribe to the route changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are listening to the changes that happen only in `queryParams`
    and using them to filter data in the  `getProducts` function. Later, with the
    help of the `transform` method, we will translate the filtered products in the
    data appropriate to the display.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we must change the signature of the `getProducts` function because
    now we may pass two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This function filters data by category, searches text, or leaves it as is,
    depending on the parameters that we send to the function. Save the code, and try
    to play with the filtered data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Router change events](Image00103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Routing strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of our essential routes have been configured, and we now have access to
    a separate view for all of them. That''s great, but maybe you are not happy with
    the path following the `#` symbol in the URL. As I mentioned, modern web browsers
    support the `pushState` technique to help change a location and history in the
    browser without a request to the server. The `Router` uses this method to build
    the URL. The Angular router uses a different `LocationStrategy` to provide support
    for both old and new ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PathLocationStrategy` provides the default, HTML 5 style based on `pushState`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HashLocationStrategy` utilizes the hash in the URL style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the strategy is crucial for future development because it won't be
    easy to change it later, so it is better do it at the right time. You can use
    the `HashLocationStrategy` if your server doesn't support the ability to redirect
    to a fallback page when a route is not found. Likely, the `lite-server` we use
    in our development supports this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.module.ts` file and import the strategy from the common module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We are registering the `PathLocationStrategy` or `HashLocationStrategy` as
    a provider to the `LocationStrategy` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Save it and check how the application works within and without hash in the browser's
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Routing strategies](Image00104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_5/3.ecommerce-router-search` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we transformed our application from a single page into a multipage
    view and multiroute app that we can build on the Dream Bean grocery store. We
    started by planning out the essential routes in our application before writing
    any lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We then built static and dynamic routes containing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how we can remove the `#` symbol from the URL using HTML
    5's `pushState` and how we can link both types of routes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](text00058.html#page "Chapter 6. Dependency Injection") , *Dependency
    Injection* , we will talk about dependency injection, which teaches the readers
    how to decouple the requirements of an application and how to create a consistent
    source of data as a service. Plus, we will continue to build the project we started
    to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
