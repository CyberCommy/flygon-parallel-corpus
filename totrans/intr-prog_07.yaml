- en: Interfaces, Classes, and Object Construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explains to readers the most important aspects of Java programming:
    **Application Programming Interfaces** (**APIs**), object factories, method overriding,
    hiding, and overloading. An explanation of the design advantage of aggregation
    (versus inheritance) follows, starting the discussion around software system design.
    The chapter concludes with an overview of Java data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface and object factory as APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding, hiding, and overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` and `super` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors and constructor overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final variable, final method, and final class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object association (aggregation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Restricting a class instantiation to a single shared instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **Application Programming Interface** (**API**) is a specification
    of protocols, procedures, and services that can be used as building blocks by
    a programmer to implement a required functionality. An API may represent a web-based
    system, operating system, database system, computer hardware, or software library.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, in everyday life, the term API is often applied to the
    system that implements the specification. For example, you might be familiar with
    Twitter APIs ([https://developer.twitter.com/en/docs](https://developer.twitter.com/en/docs))
    or Amazon APIs ([https://developer.amazon.com/services-and-apis](https://developer.amazon.com/services-and-apis)),
    or you might have worked with devices (sensors) that are able to respond to a
    request by providing the data (measurement results). So, when programmers say
    *we can use an Amazon API*, they mean not only the description of the provided
    procedures, but the services themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we have also a few variations of the term *API usage* that we would
    like to identify and describe in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Java APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java APIs include two big groups of APIs and libraries that implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: Java core packages ([http://www.oracle.com/technetwork/java/api-141528.html](http://www.oracle.com/technetwork/java/api-141528.html))
    that come with the Java installation and are included in the JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other frameworks and libraries that can be downloaded separately, such as Apache
    Commons APIs ([https://commons.apache.org](https://commons.apache.org)), for example,
    or the three libraries we have already included as dependencies in the Maven `pom.xml`
    file of our demo project. The vast majority of them can be found in the Maven
    repository ([https://mvnrepository.com](https://mvnrepository.com)), but a variety
    of new and experimental libraries and frameworks can be found eslewhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A command line API describes the command format and its possible options that
    can be used to execute the application (tool). We have seen such examples when
    we talked about using the tools (applications) `java` and `javac` in [Chapter
    1](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml), *Java Virtual Machine (JVM) on
    Your Computer*. We even built our own application in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project,* defined its API, and described its command line API
    as accepting an integer as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP-based APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web-based application often provides an HTTP-based API using a variety of
    protocols ([https://en.wikipedia.org/wiki/List_of_web_service_protocols](https://en.wikipedia.org/wiki/List_of_web_service_protocols))
    that allow access to the application functionality via the internet. HTTP stands
    for Hypertext Transfer Protocol, which is an application protocol for distributed
    information systems that serves as the foundation of data communication for the
    **World Wide Web** (**WWW**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most popular web service protocols are:'
  prefs: []
  type: TYPE_NORMAL
- en: XML-based **SOAP** (Simple Object Access Protocol) protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-based REST or RESTful (**REpresentational State Transfer**) style over
    HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both describe how functionality (services) can be accessed and incorporated
    into the application.  We do not describe web services in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Software component API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software component may be a library, an application subsystem, an application
    layer, or even a single class--something that can be used directly from Java code
    by invoking its methods. An API of a software component looks like an interface
    that describes method signatures which can be invoked on the objects of classes
    that implement the interface. If the component has public static methods (which
    do not require objects and can be invoked using classes only), these methods have
    to be included in the API description as well. But for a complete description
    of the component API, as we have mentioned already in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, the information about how the objects of the component
    can be created should be part of the API description, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we are not going beyond application boundaries and will use the
    term API only in the sense of a software component API, as described previously.
    And, we will call the entities that implement an API (the services that the API
    describes) by their names: application subsystem, application layer, library,
    class, interface, and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: That is why we started an API-related discussion about interfaces and object
    factories that complement each other and, together with static methods, compose
    a complete description of a software component API.
  prefs: []
  type: TYPE_NORMAL
- en: Interface and object factory as API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The noun abstract means a content summary of a book, article, or formal speech.
    The adjective abstract means existing in thought or as an idea, but not having
    a physical or concrete existence. The verb to abstract means to consider (something)
    theoretically or separately from something else.
  prefs: []
  type: TYPE_NORMAL
- en: That is why an interface is called an abstraction—because it captures only method
    signatures and does not describe how the result is achieved. Various implementations
    of the same interface—different classes—may behave quite differently, even if
    they receive the same parameters and return the same results. The last statement
    is a loaded one because we have not defined the term behavior. Let's do it now.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of a class or its objects is defined by the actions its methods
    perform and the results they return. If a method returns nothing (`void`), it
    is said that such a method is used only for its side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Such a view implies that a method that returns a value has a direct (not a side)
    effect. However, it can have a side effect, too, by sending a message to another
    application, for example, or storing data in a database. Ideally, one has to try
    and capture the side-effect in the method name. If that is not easy because the
    method does many things, it may indicate the need to break such a method into
    several better-focused ones.
  prefs: []
  type: TYPE_NORMAL
- en: The statement that two implementations of the same method signature can have
    different behavior makes sense only when the method name does not capture all
    the side effects, or the author of the implementations did not honor the meaning
    of the method name. But even when the behavior of different implementations is
    the same, the code itself, the libraries it uses, and how effectively it works
    may be different.
  prefs: []
  type: TYPE_NORMAL
- en: Why it is important to hide the implementation details we will explain in [Chapter
    8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented Design (OOD)
    Principles*. For now, we will just mention that the clients' isolation from the
    implementation allows the system to be more flexible in adopting new versions
    of the same implementation or in switching to a completely different one.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about interfaces in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, so now we will just look at some examples. Let''s create a new
    package, `com.packt.javapath.ch06demo.api`. Then, we can right-click `com.packt.javapath.ch06demo.api`, open
    New | Java Class, select Interface, type `Calculator`, and click the OK button.
    We have created an interface and can add to it a method signature, `int multiplyByTwo(int
    i)`, so the result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf0e6a7-cecc-4cfe-bc2b-3337a3a24d78.png)'
  prefs: []
  type: TYPE_IMG
- en: This will be the public face of every class that implements this interface.
    In real life, we would not use the package name `api` and use `calculator` instead,
    as it is more specific and descriptive. But we are discussing the term "API" and
    that is the reason we decided to name the package this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another package,  `com.packt.javapath.ch06demo.api.impl`, which
    will hold all implementations of `Calculator` and other interfaces that we will
    add to the `com.packt.javapath.ch06demo.api` package. The first implementation
    is the `CalulatorImpl` class. By now, you should know already how to create the
    `com.packt.javapath.ch06demo.api.impl` package and the `CalulatorImpl` class in
    it. The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6e713bb-a6b6-40d0-8fe0-7be774bf7f0d.png)'
  prefs: []
  type: TYPE_IMG
- en: We have put implementations in the package one level deeper than `api`, thus
    indicating that those are details that should not be exposed to the users of the
    API we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to write a test and use it to make sure our functionality
    is correct and convenient for users. Again, we assume that by now you know how
    to do it. The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8199defb-2557-47f7-97e8-35febe1cb351.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we add the missing test body and annotations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("API Calculator tests")'
  prefs: []
  type: TYPE_NORMAL
- en: public class CalculatorTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Happy multiplyByTwo()")'
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo(){
  prefs: []
  type: TYPE_NORMAL
- en: CalculatorImpl calculator = new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int result = calculator.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(4, result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code serves us not only as the functionality test; it can also be viewed
    as an example of a client code the API users would write. So, the test helps us
    to see our API from a client perspective. Looking at this code, we realize that we
    were not able to completely hide the implementation. The `CalculatorImpl` class
    is still accessed by the client directly, even if we change the line that creates
    the object to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator calculator = new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if case we change the signature of the `CalculatorImpl` constructor
    or switch to another implementation of the same interface (let it be called `AnotherCalculatorImpl`),
    the client code has to be changed, too. To avoid it, programmers use classes called
    object factories.
  prefs: []
  type: TYPE_NORMAL
- en: Object factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of an object factory is to hide the details of object creation
    so that the client does not need to change the code if the implementation changes.
    Let''s create a factory that produces `Calculator` objects. We will put it in the
    same package, `com.packt.javapath.ch06demo.api.impl`, as the implementations of
    the `Calculator` interface reside in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/525f9e16-73db-40de-ae66-c526bd1ab207.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And we can change the test (client code) to use this factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("API Calculator tests")'
  prefs: []
  type: TYPE_NORMAL
- en: public class CalculatorTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Happy multiplyByTwo()")'
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo(){
  prefs: []
  type: TYPE_NORMAL
- en: Calculator calculator = CalculatorFactory.createInstance();
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int result = calculator.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(4, result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have achieved our goal: the client code does not have any notion
    of the classes that implement `Calculator` interface. We can, for example, change
    the factory so that it creates objects of another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator create(){
  prefs: []
  type: TYPE_NORMAL
- en: return AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnotherCalculatorImpl` class may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class AnotherCalculatorImpl  implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(AnotherCalculatorImpl.class.getName());
  prefs: []
  type: TYPE_NORMAL
- en: return i + i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This `multiplyByTwo()` method adds two values instead of multiplying the input
    parameter by 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can make the factory read the configuration file and instantiate the
    implementation based on the configuration file values:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class CalculatorFactory {
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator create(){
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getStringValueFromConfig("calculator.conf", "which.impl");
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals("multiplies")){
  prefs: []
  type: TYPE_NORMAL
- en: return new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (whichImpl.equals("adds")){'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key which.impl value " + whichImpl + " is in config.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We did not talk about the `if...else` constructions or about the `RuntimeException` class
    yet (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow
    Statements*). And, we will discuss the `Utils.getStringValueFromConfig()` method
    shortly. But, we hope you understand what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiates the class depending on the value of the `which.impl` key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exits the method by throwing an exception (thus informing the client that there
    is a problem that has to be resolved) if there is no class that corresponds to
    the value of the `which.impl` key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here is how the configuration file `calculator.conf` may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"which.impl": "multiplies"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This is called **JavaScript Object Notation** (**JSON**) format, which is based
    on key-value pairs separated by a colon (`:`). You can read more about JSON at
    [http://www.json.org/](http://www.json.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The `calculator.conf` file resides in the `resources` directory (a subdirectory
    of the `main` directory). Maven, by default, places the content of this directory
    on the classpath, so it can be found by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell the factory to use another `Calculator` implementation, we need to
    do only the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the value of the key `which.impl` in the file `calculator.conf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the factory `create()` method to instantiate the new implementation based
    on this new value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to notice that the client code (`CalculatorTest` class) is not
    affected when we switch `Calculator` implementation. That is the advantage of
    hiding the implementation details from the client code using the interface and
    object factory class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look inside the `Utils` class and its `getStringValueFromConfig()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reading configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By looking at the real-life implementation of the `getStringValueFromConfig()` method, we
    are jumping ahead of your knowledge of Java and Java libraries. So we do not expect
    you to understand all the details, but we hope this exposure will give you an
    idea about how things are done and what are we aiming at in our course.
  prefs: []
  type: TYPE_NORMAL
- en: Using the json-simple library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getStringValueFromConfig()` method is located in the `Utils` class, which
    we have created to read the values from the `.conf` file. This class has the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import org.json.simple.JSONObject;
  prefs: []
  type: TYPE_NORMAL
- en: import org.json.simple.parser.JSONParser;
  prefs: []
  type: TYPE_NORMAL
- en: import org.json.simple.parser.ParseException;
  prefs: []
  type: TYPE_NORMAL
- en: public class Utils {
  prefs: []
  type: TYPE_NORMAL
- en: private static JSONObject config = null;
  prefs: []
  type: TYPE_NORMAL
- en: public static String getStringValueFromConfig(String configFileName,
  prefs: []
  type: TYPE_NORMAL
- en: String key){
  prefs: []
  type: TYPE_NORMAL
- en: if(config == null){
  prefs: []
  type: TYPE_NORMAL
- en: ClassLoader classLoader = Utils.class.getClassLoader();
  prefs: []
  type: TYPE_NORMAL
- en: File file =
  prefs: []
  type: TYPE_NORMAL
- en: new File(classLoader.getResource(configFileName).getFile());
  prefs: []
  type: TYPE_NORMAL
- en: try(FileReader fr = new FileReader(file)){
  prefs: []
  type: TYPE_NORMAL
- en: JSONParser parser = new JSONParser();
  prefs: []
  type: TYPE_NORMAL
- en: config = (JSONObject) parser.parse(fr);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (ParseException | IOException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: return "Problem reading config file.";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'return config.get(key) == null ? "unknown" : (String)config.get(key);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, please notice the technique called caching. We check the value
    of the `config` static class field first. If it is not `null`, we use it. Otherwise, we
    find the `config` file on the classpath using the same class loader that was used
    to load the known class we passed in as a parameter.  We parse the config file,
    which means breaking it into key-value pairs. The result is the reference to the
    generated object of the `JSONObject` class we assign to the `config` field (cache
    it so the next time it will be available to use).
  prefs: []
  type: TYPE_NORMAL
- en: That is the caching technique, used to avoid wasting time and other resources.
    The drawback of this solution is that any change to the configuration file requires
    restarting the application so the file can be read again. In our case, we assumed
    it is acceptable. But in other cases, we could add a timer and refresh the cached
    data after the defined period of time has passed, or do something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the config file, we use the `FileReader` class from the Apache Commons
    library ([https://commons.apache.org/proper/commons-io](https://commons.apache.org/proper/commons-io)).
    To let Maven know that we need this library, we have added the following dependency
    to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>commons-io</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>commons-io</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>2.5</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To process data in JSON format, we use JSON.simple library (released under Apache
    License, too) and have added the following dependency to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>com.googlecode.json-simple</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>json-simple</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>1.1</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `JSONObject` class stores key-value pairs presented in JSON format. If the
    passed-in key is not present in the file, the object of the `JSONObject` class returns
    the value `null`. In such a case, our `getStringValueFromConfig()` method returns
    a `String` literal unknown. Otherwise, it casts the return value to `String`.
    We can do it because we know that the value can be assigned to a variable of `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<condition>? <option1> : <option2>` construct is called a ternary operator.
    It returns `option1` when the condition is true, and otherwise returns `option2`.
    We will talk about it more in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the json-api library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatively, we could use another JSON processing API and its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>javax.json</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>javax.json-api</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>1.1.2</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.glassfish</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>javax.json</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>1.1.2</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the code of the `getStringValueFromConfig()` method would look slightly
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import javax.json.Json;
  prefs: []
  type: TYPE_NORMAL
- en: import javax.json.JsonObject;
  prefs: []
  type: TYPE_NORMAL
- en: import javax.json.JsonReader;
  prefs: []
  type: TYPE_NORMAL
- en: public class Utils {
  prefs: []
  type: TYPE_NORMAL
- en: private static JsonObject config = null;
  prefs: []
  type: TYPE_NORMAL
- en: public static String getStringValueFromConfig(String FileName,
  prefs: []
  type: TYPE_NORMAL
- en: String key){
  prefs: []
  type: TYPE_NORMAL
- en: if(config == null){
  prefs: []
  type: TYPE_NORMAL
- en: ClassLoader classLoader = Utils.class.getClassLoader();
  prefs: []
  type: TYPE_NORMAL
- en: File file = new File(classLoader.getResource(fileName).getFile());
  prefs: []
  type: TYPE_NORMAL
- en: try(FileInputStream fis = new FileInputStream(file)){
  prefs: []
  type: TYPE_NORMAL
- en: JsonReader reader = Json.createReader(fis);
  prefs: []
  type: TYPE_NORMAL
- en: config = reader.readObject();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IOException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: return "Problem reading config file.";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'return config.get(key) == null ? "unknown" : config.getString(key);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This second implementation requires a bit less code and uses a more consistent
    camel case style (`JsonObject` versus `JSONObject`). But, since their performance
    is not very different, which library to use is largely a matter of a personal
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a unit test that proves the method works as expected. By now,
    you should be able to create a `UtilsTest` class in the `test/java/com/packt/javapath/ch06demo` directory
    (or in the `test\java\com\packt\javapath\ch06demo` directory in the case of the
    Windows). The test should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Utils tests")'
  prefs: []
  type: TYPE_NORMAL
- en: public class UtilsTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Test reading value from config file by key")'
  prefs: []
  type: TYPE_NORMAL
- en: void getStringValueFromConfig(){
  prefs: []
  type: TYPE_NORMAL
- en: //test body we will write here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `test/resources/utilstest.conf`  file (`test\resources\utilstest.conf` for
    Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"unknown": "some value"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will play the role of a `config` file. With that, the test code looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Test reading value from config file by key")'
  prefs: []
  type: TYPE_NORMAL
- en: void getStringValueFromConfig(){
  prefs: []
  type: TYPE_NORMAL
- en: String fileName = "utilstest.conf";
  prefs: []
  type: TYPE_NORMAL
- en: String value = Utils.getStringValueFromConfig(fileName, "some value");
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("some value", value);
  prefs: []
  type: TYPE_NORMAL
- en: value = Utils.getStringValueFromConfig(fileName, "some value");
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("unknown", value);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We test two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The returned value should be equal `some value` in the first case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value should come back as `unknown` if the key does not exist in the config
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We run this test and observe the success. To make sure, we can also change
    the `utilstest.conf` file settings to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"unknown": "another value"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This should cause the test to fail the first case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit the Calculator API.
  prefs: []
  type: TYPE_NORMAL
- en: Calculator API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the previous discussion, we can describe the Calculator API in the
    `Calculator` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: return CalculatorFactory.create();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If the constructor of the `Calculator` implementation requires parameters, we
    would add them to the `create()`  factory method and to the `createInstance()` static
    method of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: When only one implementation of the `Calculator` interface exists, the previous
    API declaration would be enough. But when you give the client a choice of two
    or more implementations, as we have described previously, then the API should
    also include the description of `calculator.conf` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration description would have to list all possible values of the
    `which.impl` key (`multiplies` and `adds`, in our case). We would also need to
    explain how the implementations are different so that the programmer who uses
    our calculator could make an informed choice.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds like too much, then you might step back and look at your API
    design again because it is probably not well focused and tries to cover too many
    things. Consider breaking such an API into several simpler APIs. Describing each
    of these smaller APIs is easier both to write and to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is how the configuration description can be added to an interface
    in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i);
  prefs: []
  type: TYPE_NORMAL
- en: static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: return  CalculatorFactory.create();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String CONF_NAME = "calculator.conf";
  prefs: []
  type: TYPE_NORMAL
- en: String CONF_WHICH_IMPL = "which.impl";
  prefs: []
  type: TYPE_NORMAL
- en: enum WhichImpl{
  prefs: []
  type: TYPE_NORMAL
- en: multiplies, //use multiplication operation
  prefs: []
  type: TYPE_NORMAL
- en: adds        //use addition operation
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have captured the configuration filename in a constant, as
    well as the configuration key name. And we have created an `enum` for all possible
    values of the key. We have also added an explanation of the difference between
    the implementations as a comment. If the explanation is too long, the comment
    can provide a reference to documentation, a website name, or a URL, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are two implementations and two possible values in the configuration
    file, we need to run our unit test `CalculatorTest` twice—for each possible value
    of the configuration—to make sure that both implementations work as expected.
    But we do not want to change the configuration inside the deliverable software
    component itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is when the `test/resources` directory (`test\resources` for Windows)
    comes into play again. Let''s create a `calculator.conf` file in it and add the
    following lines to the `CalculatorTest` test, which will print the current settings
    in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getStringValueFromConfig(Calculator.CONF_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Calculator.CONF_WHICH_IMPL + "=" + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalculatorTest` code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo() {
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("\n" + Calculator.CONF_WHICH_IMPL +
  prefs: []
  type: TYPE_NORMAL
- en: '"=" + whichImpl);'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator calculator = Calculator.createInstance();
  prefs: []
  type: TYPE_NORMAL
- en: int i = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int result = calculator.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(4, result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a line that prints out the class name of each implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class CalculatorImpl implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(CalculatorImpl.class.getClass().getName());
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class AnotherCalculatorImpl implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(AnotherCalculatorImpl.class.getClass().getName());
  prefs: []
  type: TYPE_NORMAL
- en: return i + i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set the value of `which.impl` (in the `calculator.conf` file in the `test`
    directory) to `adds`, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a123ab51-0369-4fe3-ac54-a73a829b2d6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And the result of the `CalculatorTest` test will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4af08c61-2654-40bc-89c4-a10f08681e58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output tells us three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `which.impl` in `calculator.conf` was set to `adds`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The corresponding implementation of `AnotherCalculatorImpl` was used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invoked implementation worked as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we can run our unit test for the `calculator.conf` file set to `multiplies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks very good, but we still can improve the code and make it less
    susceptible to error, if sometime in the future somebody decides to enhance the
    functionality by adding a new implementation or something similar. We can take
    advantage of the constants added to the `Calculator` interface and make the `create()`  factory
    method more protected from a human mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator create(){
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl = Utils.getStringValueFromConfig(Calculator.CONF_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals(Calculator.WhichImpl.multiplies.name())){
  prefs: []
  type: TYPE_NORMAL
- en: return new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (whichImpl.equals(Calculator.WhichImpl.adds.name())){'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
  prefs: []
  type: TYPE_NORMAL
- en: '" value " + whichImpl + " is in config.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make sure that the test doing its job, we change the value in the `calculator.conf` file
    in the test directory to `add` (instead of `adds`) and run the test again. The
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252fb2df-1745-4fa7-8b42-92fae0a4f19d.png)'
  prefs: []
  type: TYPE_IMG
- en: The test failed, as was expected. It gives us a level of confidence that the
    code works and doesn't just always show success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, the code can be improved to become more readable, more testable, and less
    susceptible to human errors when it is modified or expanded. Using the knowledge
    of the `enum` functionality, we can write a method that converts the value of
    the key `which.impl` in the `calculator.conf` file to one of the constants (instances)
    of the class `enum WhichImpl`. To do it, we add this new method to the class `Utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl getWhichImplValueFromConfig(String configFileName, String key){
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl = getStringValueFromConfig(configFileName, key);
  prefs: []
  type: TYPE_NORMAL
- en: try{
  prefs: []
  type: TYPE_NORMAL
- en: return Enum.valueOf(WhichImpl.class, whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IllegalArgumentException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key " + Calculator.CONF_WHICH_IMPL +'
  prefs: []
  type: TYPE_NORMAL
- en: '" value " + whichImpl + " is in config.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is based on the usage of the method `getStringValueFromConfig()`, which
    we have tested already and know it works as expected. The construct `try...catch` allows
    us to capture and process situations when some code (the method `Enum.valueOf()` in
    this case) encounters a condition it cannot resolve and throws an exception (we
    will learn more about this in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*). One has to read the Java API documentation in order to know
    that the method `Enum.valueOf()` can throw an exception. For example, here is
    a quote from the documentation about the method `Enum.valueOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Throws: IllegalArgumentException - if the specified enum type has no constant
    with the specified name or the specified class object does not represent an enum
    type"'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to read the API documentation of any third-party class you
    are going to use. In our code, we catch it and throw a new exception with our
    own wording for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would expect, we have also written a unit test for the method `getWhichImplValueFromConfig()`
    and added it to `UtilsTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: '@DisplayName("Test matching config value to enum WhichImpl")'
  prefs: []
  type: TYPE_NORMAL
- en: void getWhichImpValueFromConfig(){
  prefs: []
  type: TYPE_NORMAL
- en: String confifFileName = "utilstest.conf";
  prefs: []
  type: TYPE_NORMAL
- en: for(int i = 1; i <= WhichImpl.values().length; i++){
  prefs: []
  type: TYPE_NORMAL
- en: String key = String.valueOf(i);
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(confifFileName, key);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(key + "=" + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(confifFileName, "unknown");
  prefs: []
  type: TYPE_NORMAL
- en: fail("Should not get here! whichImpl = " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key which.impl value unknown is in config.",'
  prefs: []
  type: TYPE_NORMAL
- en: ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(confifFileName, "some value");
  prefs: []
  type: TYPE_NORMAL
- en: fail("Should not get here! whichImpl = " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key which.impl value unknown is in config.",'
  prefs: []
  type: TYPE_NORMAL
- en: ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this test, we have also added two more entries to the `utilstest.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"1": "multiplies",'
  prefs: []
  type: TYPE_NORMAL
- en: '"2": "adds",'
  prefs: []
  type: TYPE_NORMAL
- en: '"unknown": "unknown"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This test covers three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If all the constants from the `enum WhichImpl` are present in the config file,
    the method `getWhichImplValueFromConfig()` works just fine—it finds each of them
    and does not throw an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key passed into the method `getWhichImplValueFromConfig()` is not from `enum
    WhichImpl`, the method throws an exception with the message `Houston, we have
    a problem. Unknown key which.impl value unknown is in config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key passed into the method `getWhichImplValueFromConfig()` is not present
    in the config file, the method throws an exception with the message `Houston,
    we have a problem. Unknown key which.impl value unknown is in config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we have confidence that this method works as expected, we can rewrite
    the factory method `create()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator create(){
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  prefs: []
  type: TYPE_NORMAL
- en: return new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another " +
  prefs: []
  type: TYPE_NORMAL
- en: '"problem. We do not have implementation for the key " +'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `switch()` construct is quite straightforward: it directs the execution
    thread to the code block under the case that matches the corresponding value (more
    about it in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of creating and using the method `getWhichImplValueFromConfig()` is
    that the `create()` method became much cleaner and focused on one task only: creating
    the right object. We will talk about the *Single Responsibility Principle* in
    section *So many OOD principles and so little time* of [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.'
  prefs: []
  type: TYPE_NORMAL
- en: We have captured the Calculator API in one place—the interface `Calculator`
    —and we have tested it and proved that it works as designed. But there is another
    possible API aspect—the last one—we have not covered, yet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static methods to API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the classes that implement the `Calculator` interface may have static
    methods in addition to the instance methods defined in the interface. If such
    static methods could be helpful to the API's users, we should be able to document
    them in the `Calculator` interface, too, and that is what we are going to do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that each of the implementations of the `Calculator` interface
    has a static method, `addOneAndConvertToString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class CalculatorImpl implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(CalculatorImpl.class.getName());
  prefs: []
  type: TYPE_NORMAL
- en: return Double.toString(d + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class AnotherCalculatorImpl implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(AnotherCalculatorImpl.class.getName());
  prefs: []
  type: TYPE_NORMAL
- en: return String.format("%.2f", d + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the methods have the same signature but slightly different implementations.
    The method in `CalculatorImpl` returns the result as is, while the method in `AnotherCalculatorImpl` returns
    the formatted value with two decimal places (we will show the result shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, static methods are called via a dot-operator applied to a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = CalculatorImpl.addOneAndConvertToString(42d);
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = AnotherCalculatorImpl.addOneAndConvertToString(42d);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we would like to hide (encapsulate) from an API client the implementation
    details so that the client code continues to use only the interface `Calculator`.
    To accomplish that goal, we will use the class `CalculatorFactory` again and add
    to it the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Calculator.CONF_NAME,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  prefs: []
  type: TYPE_NORMAL
- en: return CalculatorImpl.addOneAndConvertToString(d);
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  prefs: []
  type: TYPE_NORMAL
- en: return AnotherCalculatorImpl.addOneAndConvertToString(d);
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another " +
  prefs: []
  type: TYPE_NORMAL
- en: '"problem. We do not have implementation for the key " +'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, it looks very similar to the factory method `create()`.
    We also used the same values of the `which.impl` property—`multiplies` and `adds`—as
    identification of the class. With that, we can add the following static method
    to the `Calculator` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: return CalculatorFactory.addOneAndConvertToString(d);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this way we were able to hide the names of the classes that
    implemented the interface `Calculator` and the static method `addOneAndConvertToString
    ()`, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this new addition, we have expanded code in `CalculatorTest` by adding
    these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: double d = 2.12345678;
  prefs: []
  type: TYPE_NORMAL
- en: String mString = "3.12345678";
  prefs: []
  type: TYPE_NORMAL
- en: String aString = "3.12";
  prefs: []
  type: TYPE_NORMAL
- en: String s = Calculator.addOneAndConvertToString(d);
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals(Calculator.WhichImpl.multiplies)){
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(mString, s);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: assertNotEquals(mString, s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals(Calculator.WhichImpl.adds)){
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(aString, s);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: assertNotEquals(aString, s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test, we expect one value of `String` type, in case of `WhichImpl.multiplies`
    and the same value in a different format (only two decimal places) in the case
    of `WhichImpl.adds`. Let''s run `CalculatorTest` with the following setting in `calculator.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"which.impl": "adds"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d70771b8-dd6c-442b-a6cd-8ea6393c6e3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And when we set  `calculator.conf` to the value `multiplies`, the result is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbaa099b-1060-4191-8a6e-87d12be01e1f.png)'
  prefs: []
  type: TYPE_IMG
- en: With that, we complete the discussion on the Calculator API.
  prefs: []
  type: TYPE_NORMAL
- en: The API is complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final version of our API looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i);
  prefs: []
  type: TYPE_NORMAL
- en: static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: return  CalculatorFactory.create();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: return  CalculatorFactory.addOneAndConvertToString(d);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String CONF_NAME = "calculator.conf";  //file name
  prefs: []
  type: TYPE_NORMAL
- en: String CONF_WHICH_IMPL = "which.impl"; //key in the .conf file
  prefs: []
  type: TYPE_NORMAL
- en: enum WhichImpl{
  prefs: []
  type: TYPE_NORMAL
- en: multiplies, //uses multiplication operation
  prefs: []
  type: TYPE_NORMAL
- en: // and returns addOneAndConvertToString()
  prefs: []
  type: TYPE_NORMAL
- en: // result without formating
  prefs: []
  type: TYPE_NORMAL
- en: adds    //uses addition operation
  prefs: []
  type: TYPE_NORMAL
- en: // and returns addOneAndConvertToString()
  prefs: []
  type: TYPE_NORMAL
- en: // result with two decimals only
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This way, we maintain the single source of record—the interface that captures
    all the API details. If more details are needed, the comments may refer to some
    external URL with full documentation that describes each of the `Calculator` implementations.
    And, to repeat what we have said already at the beginning of this section, the
    method name should describe all the side effects the method produces.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, programmers try to write small, well-focused methods and capture
    everything the method does in its name, but they rarely add more than abstract
    signatures to an interface. And when they talk about APIs they usually mean only
    abstract signatures, which is the most important aspect of an API. But we think
    it is a good idea to also document all other API aspects in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading, overriding, and hiding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already mentioned method overriding and explained it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*. Method overriding is replacing the methods implemented
    in a parent class (or default methods implemented in an interface) with the methods
    of the same signatures in the child class (or in the class that implements the
    interface, or in the child interface correspondingly). Method overloading is creating
    several methods with the same name and different parameters (thus, different signatures)
    in the same class or interface. In this section, we will discuss overriding and
    overloading the members of an interface, a class, and a class instance in more
    detail and will explain what hiding is as well. We start with an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interface method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already said in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, that in addition to abstract methods, an interface can have default
    methods and static members—constants, methods, and classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an abstract, default, or static method `m()` already exists in an interface,
    one cannot add another method `m()` with the same signature (method name and list
    of parameter types). So, the following examples generate compilation errors because
    each pair of methods has the same signature, while the access modifier (`private`,
    `public`), `static` or `default` keywords, returned value type, and implementation
    are not part of the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface A {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: double m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface B {
  prefs: []
  type: TYPE_NORMAL
- en: int m(int s);
  prefs: []
  type: TYPE_NORMAL
- en: static int m(int i) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C {
  prefs: []
  type: TYPE_NORMAL
- en: int m(double i);
  prefs: []
  type: TYPE_NORMAL
- en: private double m(double s) { return 42d; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface E {
  prefs: []
  type: TYPE_NORMAL
- en: private int m(int s) { return 1; };
  prefs: []
  type: TYPE_NORMAL
- en: default double m(int i) { return 42d; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface F {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s) { return 1; };
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface G {
  prefs: []
  type: TYPE_NORMAL
- en: private int m(double d) { return 1; };
  prefs: []
  type: TYPE_NORMAL
- en: static int m(double s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface H {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(int i) { return 1; };
  prefs: []
  type: TYPE_NORMAL
- en: default double m(int s) { return 42d; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a different signature, one has either to change the method name or
    change the list of parameter types. Having two or more methods with the same method
    name and different parameter types constitutes method overloading. Here are a
    few examples of legitimate method overloading in an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface A {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s, double d);
  prefs: []
  type: TYPE_NORMAL
- en: int m(double d, String s);
  prefs: []
  type: TYPE_NORMAL
- en: String m(int i);
  prefs: []
  type: TYPE_NORMAL
- en: private double m(double d) { return 42d; }
  prefs: []
  type: TYPE_NORMAL
- en: private int m(int i, String s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s, int i) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface B {
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s, int i) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloading is applied to inherited methods, too, which means that the following
    overloading of non-static methods is not different from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(int i, String s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s, int i) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C {
  prefs: []
  type: TYPE_NORMAL
- en: default double m(double d) { return 42d; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface B extends C, D {
  prefs: []
  type: TYPE_NORMAL
- en: int m(double d, String s);
  prefs: []
  type: TYPE_NORMAL
- en: String m(int i);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface A extends B {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s, double d);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that we have changed the `private` methods to `default` in
    the previous code. We did it because otherwise the `private` access modifier makes
    the method inaccessible to a child interface and thus cannot be overloaded in
    a child.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the static methods, the following combinations of static and non-static
    methods, although allowed, do not constitute overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface A {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s, double d) { return 1 }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface B {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s, int i);
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s, int s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s, double s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface E {
  prefs: []
  type: TYPE_NORMAL
- en: private int m() { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods belong to a class (and thus exist uniquely in the application),
    while non-static methods are associated with an instance (and a method copy is
    created for each object).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, static methods of different interfaces do not overload
    each other, even if the interfaces have a parent-child relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface G {
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface F extends G {
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s, int i) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Only the static methods that belong to the same interface can overload each
    other, while non-static interface methods can be overloaded even if they belong
    to different interfaces, provided they have parent-child relations.
  prefs: []
  type: TYPE_NORMAL
- en: Interface method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By contrast with overloading, which happens with the static and non-static methods
    of signatures that are different but have the same name, method overriding happens
    only with non-static methods and only when they have exactly the same signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference is that the overriding method resides in the child interface,
    while the overridden method belongs to the parent interface. The following are
    examples of method overriding:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String s) { // does not override anything
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C extends D {
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String d) { // overrides method of D
  prefs: []
  type: TYPE_NORMAL
- en: return 42;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The class that implements interface `C` directly and does not implement the
    method `m()` will get the implementation of this method from interface `C` and
    will not get the implementation of this method from interface `D`. Only the class
    that implements interface `D` directly and does not implement the method `m()`
    will get the implementation from interface `D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we use the word directly. By saying that class `X` implements interface
    `C` directly, we mean that class `X` is defined as follows: `class X implements
    C`. If interface `C extends D`, then class `X` implements interface `D` as well,
    but not directly. That is an important distinction because the methods of interface
    `C` in such a case can override the methods of interface `D` that have the same
    signature, thus making them inaccessible for class `X`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing code that depends on overriding, a good practice would be to
    use the annotation `@Override` which expresses the programmer''s intent. The Java
    compiler and an IDE that uses it then check whether overriding took place and
    generates an error if the method with this annotation does not override anything.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface B {
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface A extends B {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override             //no error'
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: default int m1(String s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C extends D {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override            //error'
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String d) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The error will help you notice that the method in the parent interface is spelled
    differently (`m1()` versus `m()`). And here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C extends D {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override                  //error'
  prefs: []
  type: TYPE_NORMAL
- en: default int m(String d) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example generates an error because an instance method cannot override
    a static method and vice versa. Also, a static method cannot override a static
    method of the parent interface because each static method of an interface is associated
    with the interface itself, not with a class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface D {
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String s) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface C extends D{
  prefs: []
  type: TYPE_NORMAL
- en: '@Override               //error'
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String d) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But a static method in a child interface can hide the static method with the
    same signature in a parent interface. In fact, any static member—a field, a method,
    or a class—can hide the corresponding static member of the parent interface, direct
    parent or not. We will discuss hiding in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interface static member hiding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface B {
  prefs: []
  type: TYPE_NORMAL
- en: String NAME = "B";
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String d) { return 1; }
  prefs: []
  type: TYPE_NORMAL
- en: class Clazz{
  prefs: []
  type: TYPE_NORMAL
- en: String m(){ return "B";}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface A extends B {
  prefs: []
  type: TYPE_NORMAL
- en: String NAME = "A";
  prefs: []
  type: TYPE_NORMAL
- en: static int m(String d) { return 42; }
  prefs: []
  type: TYPE_NORMAL
- en: class Clazz{
  prefs: []
  type: TYPE_NORMAL
- en: String m(){ return "A";}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface `B` is a parent (also called superinterface or base interface) of
    interface `A` (called a derived interface, child interface, subinterface, or subtype).
    All the members of an interface are `public` by default. Interface fields and
    classes are also `static` by default. So, all members of interfaces `A` and `B`
    are `public` and `static`. Let''s, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(B.NAME);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(B.m(""));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(new B.Clazz().m());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de04757c-fb2d-4658-a5be-bad01309bd8c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the effect looks like overriding, but the mechanism that produces
    it is hiding. The difference is more prominent in the case of the hiding of class
    members, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Class member hiding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at these two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: public static String field = "static field C";
  prefs: []
  type: TYPE_NORMAL
- en: public static String m(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "static method C";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassD extends ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: public static String field = "static field D";
  prefs: []
  type: TYPE_NORMAL
- en: public static String m(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "static method D";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'They have two static members each—a field and a method. With that, look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ClassD.field);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ClassD.m(""));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(new ClassD().field);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(new ClassD().m(""));
  prefs: []
  type: TYPE_NORMAL
- en: ClassC object = new ClassD();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(object.field);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(object.m(""));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Stop reading and try to guess what will the output be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same code with numbers of lines and the output (captured in the
    comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 1 System.out.println(ClassD.field);       //static field D
  prefs: []
  type: TYPE_NORMAL
- en: 2 System.out.println(ClassD.m(""));       //static method D
  prefs: []
  type: TYPE_NORMAL
- en: 3 System.out.println(new ClassD().field); //static field D
  prefs: []
  type: TYPE_NORMAL
- en: 4 System.out.println(new ClassD().m("")); //static method D
  prefs: []
  type: TYPE_NORMAL
- en: 5 ClassC object = new ClassD();
  prefs: []
  type: TYPE_NORMAL
- en: 6 System.out.println(object.field);       //static field C
  prefs: []
  type: TYPE_NORMAL
- en: 7 System.out.println(object.m(""));       //static method C
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the first two lines was probably expected. Lines 3 and 4 are not
    as intuitive, but probably also make sense. Any object of a class should be able
    to access class members. Nevertheless, it is not recommended to access static
    members via an object because such code hides the fact that the accessed members
    are static, which makes the code less readable and may lead to unnecessary object
    creation. Same applies to lines 6 and 7\. And, just to reiterate what we have
    discussed in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language
    Basics*, lines 5, 6, and 7 demonstrate that we are able to assign the object of
    `ClassD` to the reference of type `ClassC` because `ClassC` is the parent class,
    and all the children (of all generations) of a class have the same type as the
    parent class. This means that a child can have many types inherited from all its
    parents—direct and indirect. It looks like genetic inheritance, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: So, you can see static members of a child class (also called a derived class,
    extended class, subclass, or subtype) can hide the static members of its parent
    (also called a base class or superclass).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two differences between hiding fields and hiding methods. A static
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: Hide an instance variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even hide a field with the same name but different type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the allowable cases for hiding, described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: public static String field1 = "instance field C";
  prefs: []
  type: TYPE_NORMAL
- en: public String m1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "instance method C";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassD extends ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: public String field1 = "instance field D";
  prefs: []
  type: TYPE_NORMAL
- en: public String m1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "instance method D";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate it, we can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(new ClassD().field1);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(new ClassD().m1(""));
  prefs: []
  type: TYPE_NORMAL
- en: ClassC object1 = new ClassD();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(object1.m1(""));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(object1.field1);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(((ClassD)object1).field1);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can stop reading now and guess what the output will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 1 System.out.println(new ClassD().field1);     //instance field D
  prefs: []
  type: TYPE_NORMAL
- en: 2 System.out.println(new ClassD().m1(""));     //instance method D
  prefs: []
  type: TYPE_NORMAL
- en: 3 ClassC object1 = new ClassD();
  prefs: []
  type: TYPE_NORMAL
- en: 4 System.out.println(object1.m1(""));          //instance method D
  prefs: []
  type: TYPE_NORMAL
- en: 5 System.out.println(object1.field1);          //instance field C
  prefs: []
  type: TYPE_NORMAL
- en: 6 System.out.println(((ClassD)object1).field1);//instance field D
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, line 5 outputs the value of the static variable `ClassC.field1` although
    the field with the same name, `field1`, exists in `ClassD`, too. Even if we change
    `field1` in `ClassC` to non-static, the same result will be displayed: line 5
    prints out the value of the field using the declared type of the reference `object1`,
    not the actual type of the object assigned to it. To make matters even more complicated,
    as we have stated before, the type of the field `field1` in `ClassC` may be different
    from the type of field with the same name in `ClassD`, and the effect of public
    field hiding will still be the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid confusion, always follow these two best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the identifier of a static variable in uppercase characters, while the
    identifier of an instance variable should be in lowercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to never allow public access to the instance fields; make them private
    and access to their values via getters and setters, instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: private String field1 = "instance field C";
  prefs: []
  type: TYPE_NORMAL
- en: public String getField(){ return field1; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setField(String s){ field1 = s; }
  prefs: []
  type: TYPE_NORMAL
- en: public String m1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "instance class C";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class ClassD extends ClassC {
  prefs: []
  type: TYPE_NORMAL
- en: private String field1 = "instance field D";
  prefs: []
  type: TYPE_NORMAL
- en: public String getField(){ return field1; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setField(String s){ field1 = s; }
  prefs: []
  type: TYPE_NORMAL
- en: public String m1(String s){
  prefs: []
  type: TYPE_NORMAL
- en: return "instance class D";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This way, in the case of overriding or hiding, you will have only one set of
    rules related to methods. It is much simpler and more straightforward. Besides,
    you can have better control over the values of the private fields. For example,
    you can add code to the setter that makes sure that the field is never assigned `null` or
    another undesirable value.
  prefs: []
  type: TYPE_NORMAL
- en: Instance method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since, as we have seen in the previous section, class (or static) members cannot
    override each other but only hide, we can talk about overriding instance members,
    only. We have also already established that instance fields hide each other and
    the rules of field hiding are quite different from the much simpler rules of method
    overriding, so the best practice would be to not expose instance fields and access
    their values via getters and setters only. This way, instance member overriding
    is reduced to instance method overriding, and that is what we are going to describe
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for instance method overriding are not different than the rules for
    interface default method overriding: a method in a child class overrides the method
    in a parent class with the same signature. If the signatures are different, but
    the method name is the same, the method is overloaded, not overridden. So, if
    you would like to override a method, it is always advisable to add the `@Override`
    annotation to the method to make sure it is not just overloaded silently.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have established earlier, too, a static method in a child class cannot
    override an instance method from the parent class. It makes class instance overriding
    rules much simpler than interface overriding rules.
  prefs: []
  type: TYPE_NORMAL
- en: One important feature to note is that constructors, although they look like
    methods, are not methods or even members of the class. A constructor doesn’t have
    a return type and has the same name as the class. Therefore, a constructor cannot
    be overridden, but it can be overloaded. Its only purpose is to be called when
    a new instance of the class (object) is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we move to the last subsection of the *Overloading, overriding,
    and hiding* section: instance method overloading.'
  prefs: []
  type: TYPE_NORMAL
- en: Instance method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instance method overloading, there are just two statements to describe
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: For a non-static method to be overloaded, it has to have the same name and a different
    set of parameter types as another non-static method of the same class or the class
    that has a parent-child relationship with the class that contains the overloaded
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private non-static method can be overloaded only by a non-static method of
    the same class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, here is an example of method overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void m() {
  prefs: []
  type: TYPE_NORMAL
- en: // some code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s){
  prefs: []
  type: TYPE_NORMAL
- en: // some code
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void m(int i){
  prefs: []
  type: TYPE_NORMAL
- en: // some code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int m(String s, double d){
  prefs: []
  type: TYPE_NORMAL
- en: // some code
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int m(double d, String s){
  prefs: []
  type: TYPE_NORMAL
- en: // some code
  prefs: []
  type: TYPE_NORMAL
- en: return 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the name of the overloaded method stays the same, but the number
    of parameters, their type, or the sequence of parameter types, must be different.
    Otherwise, it is not overloading and the compiler will generate an error. The
    returned type does not play any role in the overloading. It can be the same or
    different.
  prefs: []
  type: TYPE_NORMAL
- en: To look at it from another perspective, all the overloaded methods are considered
    different. In the previous example, we could just give a different name to each
    method and have exactly the same code behavior. So, overloading is useful when
    you have several methods with the same functionality (that's why you don't want
    to change the method name), but different parameters or different parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one possible case of overloading use. You might remember one of the
    first classes we created was called `SimpleMath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SimpleMath {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we might want to add to it another method that, for user convenience,
    will accept a number as a `String` type: `multiplyByTwo(String s)`. We could do
    it the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SimpleMath {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: return 2 * i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(String s){
  prefs: []
  type: TYPE_NORMAL
- en: int i = Integer.parseInt(s);
  prefs: []
  type: TYPE_NORMAL
- en: return 2 * i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, if we would like to keep the complicated code of multiplying by two in
    one place (so we can change it in one place only if there is a need to modify
    it), we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SimpleMath {
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: return 2 * i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(String s){
  prefs: []
  type: TYPE_NORMAL
- en: int i = Integer.parseInt(s);
  prefs: []
  type: TYPE_NORMAL
- en: return multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor cannot be overloaded in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SimpleMath {
  prefs: []
  type: TYPE_NORMAL
- en: private int i;
  prefs: []
  type: TYPE_NORMAL
- en: private String s;
  prefs: []
  type: TYPE_NORMAL
- en: public SimpleMath() {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public SimpleMath(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: this.i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public SimpleMath(String s) {
  prefs: []
  type: TYPE_NORMAL
- en: this.s = s;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Other methods that use values of the fields i and s
  prefs: []
  type: TYPE_NORMAL
- en: // go here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we conclude the topic of overloading, overriding, and hiding. It
    is time to explain in more detail the use of the keywords `this` (used earlier)
    and `super` (not used yet), and talk more about constructors.
  prefs: []
  type: TYPE_NORMAL
- en: This, super, and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The keyword `this` provides a reference to the current object. The keyword `super`
    refers to the parent class object. A constructor is used to initialize the object
    state (values of the instance fields). It can be accessed using the keywords `new`,
    `this`, or `super`.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword this and its usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw several examples of its usage in a constructor similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public SimpleMath(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: this.i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to clearly distinguish between the object property and local variable,
    especially when they have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use of the keyword `this` can be demonstrated in the implementation
    of the method `equals()` in the following `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private String firstName;
  prefs: []
  type: TYPE_NORMAL
- en: private String lastName;
  prefs: []
  type: TYPE_NORMAL
- en: private LocalDate dob;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(String firstName, String lastName, LocalDate dob) {
  prefs: []
  type: TYPE_NORMAL
- en: this.firstName = firstName;
  prefs: []
  type: TYPE_NORMAL
- en: this.lastName = lastName;
  prefs: []
  type: TYPE_NORMAL
- en: this.dob = dob;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getFirstName() { return firstName; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getLastName() { return lastName; }
  prefs: []
  type: TYPE_NORMAL
- en: public LocalDate getDob() { return dob; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object other){
  prefs: []
  type: TYPE_NORMAL
- en: if (other == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if (this == other) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (!(other instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: final Person that = (Person) other;
  prefs: []
  type: TYPE_NORMAL
- en: return this.getFirstName().equals(that.getFirstName()) &&
  prefs: []
  type: TYPE_NORMAL
- en: this.getLastName().equals(that.getLastName()) &&
  prefs: []
  type: TYPE_NORMAL
- en: this.getDob().equals(that.getDob());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need to override the `equals()` method in the parent class `java.lang.Object` (which
    is the default parent class for all Java classes) is that we would like two objects
    of the class `Person` to be equal not only when they are actually the same object,
    but also when the value of each property of one object is the same as the value
    of the corresponding property of another object. As you can see, we have added
    an annotation `@Override` to make sure that this method does override the method
    `equals()` in the parent class `java.lang.Object`. Otherwise, if we make a mistake
    in the method signature, it may just overload the method `equals()` in the class
    `java.lang.Object` or, if we make mistake in the method name, be added as just
    another unrelated to the `equals()` method and we never know about it or would
    struggle to understand why two different objects of class `Person` are not equal,
    although all their property values are the same.
  prefs: []
  type: TYPE_NORMAL
- en: The first line checks if the passed in reference value is `null`. If yes, the
    returned value is `false` because, obviously, the current (`this`) object is not
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of our method `equals()` checks the equality of the references
    and returns `true` if they refer the same object. This is the same way the default
    `equals()` method in the parent class `Object` works.
  prefs: []
  type: TYPE_NORMAL
- en: The third line of our method `equals()` checks if the object `other` is an instance
    of the class `Person`. We need this line because in the next line we are casting
    the object `other` to the type `Person` in order to be able to access the getters
    of `Person`. If the object `other` cannot be cast to the type `Person` (which
    means the reference `other` does not refer an object that has class `Person` as
    a direct or indirect parent) the fourth line will throw an exception and break
    the flow of the execution (JVM will exit with an error). So, we check and make
    sure that the object `other` has the class `Person` in its ancestry and will not
    break the execution flow during casting.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of our new method, `equals()`, is a Boolean expression (we will
    talk about such expressions in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*) that compares the values of three properties
    of the current object with the corresponding values of another object and returns
    `true` only if each of the three fields have the same value in both objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a unit test for our new method, `equals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class PersonTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void equals() {
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate dob = LocalDate.of(2001, 01, 20);
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate dob1 = LocalDate.of(2001, 01, 21);
  prefs: []
  type: TYPE_NORMAL
- en: Person p = new Person("Joe", "Blow", dob);
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(p.equals(p));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(p.equals(new Person("Joe", "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person("Joe1", "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person("Joe", "Blow1", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person("Joe", "Blow", dob1)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals( new Person("Joe1", "Blow1", dob1)));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have created two objects for different dates of birth. Then,
    we create a `Person` object and compare it:'
  prefs: []
  type: TYPE_NORMAL
- en: To itself—should be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To another object with the same state (property values)—should be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To another object with the first name different only—should not be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To another object with the last name different only —should not be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To another object with the date of birth different only —should not be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To another object with all property values different—should not be equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We run this test and get the green color of success.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then, we decide to test what happens if one or all the values are `null` and
    add the following lines to the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(null));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person(null, "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person("Joe", null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person(null, null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person(null, null, null)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person(null, "Blow", dob)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person(null, "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person("Joe", null, dob)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person("Joe", null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person("Joe", "Blow", null)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person("Joe", "Blow", null)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person(null, null, null)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person(null, null, null)));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: First, we compare the existing object with all properties not `null` and a new
    object that has either one property or all properties set to `null`. We expect
    the first four comparisons to tell us the objects are not equal. Then, we compare
    two objects with the same state that have one or all values set to `null`. We
    expect all the pairs to be reported as equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test, here is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afc4e8bc-30cb-4dac-9b07-8ceb89e62803.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error (a `NullPointerExceptions`) indicates that we are trying to call
    a method on a reference that is not assigned yet (has a `null` value) in line
    57 of the class `Person`. Here is that line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: return this.getFirstName().equals(that.getFirstName()) &&
  prefs: []
  type: TYPE_NORMAL
- en: this.getLastName().equals(that.getLastName()) &&
  prefs: []
  type: TYPE_NORMAL
- en: this.getDob().equals(that.getDob());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We realize that all the getters return a `null` value when we call them on the method
    `equals()`, which is the source of `NullPointerException`. We need to change either
    our implementation of the method `equals()` (taking into account the possibility
    of a `null` value) or change the implementation of the constructor (and not allow
    the values passed in to be `null`). Very often, the decision can be made based
    on the business requirements. For example, is it possible, that in the data we
    are going to process there could be a person without a first name, last name,
    date of birth, or even any of these values? The last one—a person without any
    properties—is probably not realistic. Yet, the real data often comes with errors
    and the question we might ask our business folks (also called domain experts)
    is how the code should process such cases. Then, we change the code to reflect
    the new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume they have told us that one or even two properties can be `null` and
    we should handle such cases as if they are not `null`. But, they said, we should
    not process a case when all the properties are `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reviewing the new requirements, we go to the domain experts again and
    suggest, for example, that we convert `null` values of `String` type into the
    empty literal `""` and the `LocalDate` type into the date as of January 1, zero
    years, but only when not all values are `null`. We skip the person data when all
    the values are `null` after adding a corresponding record to a log file. They
    suggest we allow the first and last name to be `null` and convert them to the
    empty `String` type literal `""`, but do not process a person without a date of
    birth and make a record of such a case in a log file. So, we change the constructor
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public Person(String firstName, String lastName, LocalDate dob) {
  prefs: []
  type: TYPE_NORMAL
- en: 'this.firstName = firstName == null ? "" : firstName;'
  prefs: []
  type: TYPE_NORMAL
- en: 'this.lastName = lastName == null ? "" : lastName;'
  prefs: []
  type: TYPE_NORMAL
- en: this.dob = dob;
  prefs: []
  type: TYPE_NORMAL
- en: if(dob == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Date of birth is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And our test section that handles the null values changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(null));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person(null, "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person("Joe", null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertFalse(p.equals(new Person(null, null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: new Person("Joe", "Blow", null);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (RuntimeException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: assertNotNull(ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: //add the record ex.getMessage() to the log here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person(null, "Blow", dob)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person(null, "Blow", dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person("Joe", null, dob)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person("Joe", null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(new Person(null, null, dob)
  prefs: []
  type: TYPE_NORMAL
- en: .equals(new Person(null, null, dob)));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We run it and get the green color of success.
  prefs: []
  type: TYPE_NORMAL
- en: That was an example of the use of the keyword `this`. We will show another example
    in the *Constructors* section. And there is a very important case of the use of
    the keyword `this` at the end of the *Final variable* section, too. You do not
    want to miss it! Otherwise, it can be a source of bugs that are very difficult
    to find.
  prefs: []
  type: TYPE_NORMAL
- en: And now, we will explain how the keyword `super` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword super and its usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The keyword `super` represents the parent class object. To demonstrate its
    usage, let''s create a programming model of a vehicle, a truck, and a car. Let''s
    start with a vehicle. The class that models it calculates the speed of the vehicle
    it can reach in a specified period of time, in seconds. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: private int weightPounds, horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: public Vehicle(int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: this.weightPounds = weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: this.horsePower = horsePower;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){ return this.weightPounds; }
  prefs: []
  type: TYPE_NORMAL
- en: protected double getSpeedMph(double timeSec, int weightPounds){
  prefs: []
  type: TYPE_NORMAL
- en: double v =
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 * this.horsePower * 746 * timeSec * 32.174 / weightPounds;
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(Math.sqrt(v) * 0.68);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The class has two properties set by the constructor and two protected methods.
    Protected is an access modifier that means the method can be accessed only by
    the children of this class. We will talk more about access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Car` and `Truck` classes(which model a car and a truck) can extend this
    class and inherit the two protected methods, so they can be used for calculating
    the car and truck speed. There are other possible ways to organize code. Generally,
    using aggregation (setting the `Vehicle` object as a field value of the `Car`
    and `Truck` classes ) is preferred, unless one has a reason to have a common parent
    (we will talk about this in [Chapter 8,](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)
    *Object-Oriented Design (OOD) Principles*). But for now, let''s assume that we
    have a good reason to use inheritance, so we can demonstrate the use of the keyword
    `super`. And it sort of makes sense, in general: a car and a truck are both vehicles,
    aren''t they?'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is how the class `Truck` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Truck extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: private int payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: public Truck(int payloadPounds, int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds, horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setPayloadPounds(int payloadPounds) {
  prefs: []
  type: TYPE_NORMAL
- en: this.payloadPounds = payloadPounds;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.payloadPounds + getWeightPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class has one property: the current payload weight the truck has. It factors
    in the speed calculations. The heavier the payload, the longer it takes the truck
    to reach the same speed. Since the payload weight may change any time after the
    object is created, the setter for the payload weight is provided, and the protected
    method `getWeightPounds()` returns the total weight of the vehicle with its payload.
    The main method and the purpose of all the modeling is the method `getSpeedMph()`,
    which returns the truck''s speed (in miles per hour) it can reach in `timeSec`
    seconds after it starts.'
  prefs: []
  type: TYPE_NORMAL
- en: But, we now discuss the use of the keyword `super`. You probably noticed that
    it was already included in the constructor. As you can guess, it represents the
    constructor of the parent class. In such cases, the keyword `super` has to be
    the first line of the child constructor. We will talk about it in the next section, *Constructors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the class that models car speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Car extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: private int passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: public Car(int passengersCount, int weightPounds, int horsePower) {
  prefs: []
  type: TYPE_NORMAL
- en: super(weightPounds , horsePower);
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setPassengersCount(int passengersCount) {
  prefs: []
  type: TYPE_NORMAL
- en: this.passengersCount = passengersCount;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.passengersCount * 200 + getWeightPounds(); }
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It looks very similar to the class `Truck`. The only difference is the way the
    payload is calculated. It is assumed that each passenger ways `200` pounds. Thus,
    when the passenger count is set, the payload is calculated as the number of passengers
    multiplied by `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both classes—`Car` and `Truck`—have a defect (also called a bug, or an error).
    To discover it, let''s try to calculate a truck''s speed 10 seconds from the start
    time by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Truck truck = new Truck(500, 2000, 300);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(truck.getSpeedMph(10));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do that, the result will be a `StackOverflowError` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/926fdbd6-6ee7-4eef-90c4-096d1d553e6b.png)'
  prefs: []
  type: TYPE_IMG
- en: A stack is the JVM memory area where the chain of method calls is stored. The
    last method name called is stored on the top. When the last method called is completed,
    its name is removed from the top and the next method is executed, and so on until
    the stack is empty—that is, when the `main()` method is completed—and the application
    completes its execution (JVM exits).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the stack grew uncontrollably and eventually overflowed. The JVM
    could not add another method name on the top of the stack and exited with an error.
    The reason for such a condition is a recursive call our code requested in this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.payloadPounds + getWeightPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We wanted to add the truck payload to the weight of the vehicle itself, stored
    as the property in the parent class, but instead told the JVM to call the same
    method, which calls itself recursively, because this method is overridden and
    has the same name in the child class. That is where the keyword `super` comes
    to the rescue. By adding it in front of the method `getWeightPounds()`, we tell
    the JVM to call not the child''s method, but the parent''s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: protected int getWeightPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.payloadPounds + super.getWeightPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If  we run the same code again, we will get the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3425b1a1-e668-4157-bc08-a22eff82094d.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, our speed calculating formula seems over-optimistic. But who knows? Maybe
    by the time the book is printed, electric trucks will be closing in on this speed
    or hyperloop traffic will get there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, please notice that we have not added `super` in front of the same method
    in the code that calculates speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is because we do not want to call the method of the parent class. Instead,
    we would like to get the weight from its overridden version in the child class.
    To make sure, and to avoid confusion by making code more easily readable, we could
    add the keyword `this` in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public double getSpeedMph(double timeSec){
  prefs: []
  type: TYPE_NORMAL
- en: return getSpeedMph(timeSec, this.getWeightPounds());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, that is one of the best practices that we recommend to follow at all
    times.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the discussion of the use of the keyword `super`. We will see
    it again, and the keyword `this`, in the *Constructors* section too, where we
    are going to explain how the constructors do their job and what a default constructor is.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object is an instance of a class used as the template for object creation.
    Each object is defined by its state and behavior. The object's state is defined
    by the values of its fields (also called properties), the object behavior by its
    methods. Since all Java objects are descendants of `java.lang.Object`, it is not
    possible to have an object without state and behavior because every object inherits its
    methods and some basic state from `java.lang.Object`. But when we talk about application
    code, classes, and objects this code creates, we mean the methods and state we
    define in order to build the functionality we want. In this sense, it is possible
    to have an object without methods. Such objects are usually called data objects,
    data structures, or data transfer objects. And it is possible to have objects
    without a state, with methods only. Such objects are often called utilities.
  prefs: []
  type: TYPE_NORMAL
- en: If an object can have a state, the state has to be initialized during object
    creation. It means that some values have to be assigned to the variables that
    represent the object fields. This initial assignment can be done either using
    an assignment operator, `=`, explicitly or by letting the JVM assign the default
    values to the object's fields. What these default values are depends on the field type.
    We have discussed the default value of each type in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. Primitive numeric types have the default type
    of zero, the Boolean type `false`, and the reference type `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object is created using the operator `new`. This operator requires specifying
    the constructor that has to be used for object creation. The primary duty of a
    constructor is to initialize the object state. But, there are three cases when
    an explicit definition of a constructor in the class is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: When neither the object nor any of its parents can have a state (no fields are
    defined)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an initial value is assigned to each field along with the type declaration
    (`int x = 42;`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When default values are good enough (for example, the field `int x;` is initialized
    to the value of zero by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How then can an object be created?  The operator `new` expects the constructor.
    The answer is that in such a case—when there is no constructor explicitly defined
    in a class—a default constructor is generated for the class by the compiler. This
    default constructor looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public ClassName(){
  prefs: []
  type: TYPE_NORMAL
- en: super();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it does only one thing: calls the constructor (the one without
    parameters) of the parent class using the keyword `super`. This parent constructor
    without parameters may be a default one too, or may be explicitly created. And
    here resides a possible source of confusion: if a class has an explicitly defined
    constructor, the default one (without parameters) is not generated automatically.
    The reason for this limitation is that it puts the programmer in command and lets
    the class author decide whether to add a constructor without parameters to the
    class or not. Otherwise, imagine you have created a class, `Person`, and do not
    want to allow an instance of this class without certain fields populated. And
    you do not want these values to be the default ones, but would like to force the
    client code to populate them explicitly every time a new `Person` object is created.
    That''s why no constructor is going to be generated automatically behind the scenes
    as soon as at least one constructor—with or without parameters—is defined in a
    class. Let''s test this behavior. Here are two classes without explicitly defined
    constructors (or any code at all for that matter):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the following code just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: new Child();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does not do anything, but that is not the point. Let''s add a constructor
    with a parameter to the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent {
  prefs: []
  type: TYPE_NORMAL
- en: public Parent(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to create an object of the class `Child` again, we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98593acd-b710-4f3a-92f1-02e2f4603e30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the red line to see this error message in IntelliJ, because the compiler
    error message is not as helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f59184e5-c542-45ae-b001-196162ea43f0.png)'
  prefs: []
  type: TYPE_IMG
- en: It identifies the explicitly defined constructor (with a parameter of type `int`)
    as required and its list of parameters as a formal argument list. Meanwhile, a
    default constructor of the class `Child` attempts (as we described before) to
    call a no-arguments constructor of the class `Parent` and cannot find one. The
    error wording is not very clear on that.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add a constructor without parameters to the class `Parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent {
  prefs: []
  type: TYPE_NORMAL
- en: public Parent() {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Parent(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: An object of the class `Child` can now be created without any problems. That
    is how the class author can control the process of object creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you decide that the `Parent` object has to be created using a constructor
    with parameters only, you can remove the no-arguments constructor from it again
    and add to the class `Child` a constructor that calls the `Parent` constructor
    with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: public Child() {
  prefs: []
  type: TYPE_NORMAL
- en: super(10);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, you can add to the child a constructor with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: public Child(int i) {
  prefs: []
  type: TYPE_NORMAL
- en: super(i);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Any of these work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this demonstration, you have probably realized that in order to create
    an object of a child, all its parent objects have to be created (and their state
    initialized) first. And it has to be done starting from the most ancient ancestor.
    Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private String name = "GrandDad";
  prefs: []
  type: TYPE_NORMAL
- en: public GrandDad() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent extends GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private String name = "Parent";
  prefs: []
  type: TYPE_NORMAL
- en: public Parent() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: private String name = "Child";
  prefs: []
  type: TYPE_NORMAL
- en: public Child() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you guess what the output is going to be if we try to create the child
    `new Child()`? If you guessed the `GrandDad` constructor finishes first, then
    `Parent`, then `Child`, you are correct. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e65391e6-3a1e-406c-a12f-7d5f588b3abc.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Child` constructor calls the `Parent` constructor, which in turn calls
    the `GrandDad` constructor, which calls the `java.lang.Object` constructor. Only
    after a parent object has been created (and its constructor has finished doing
    what it had to do) does the child constructor finish executing, and so on through
    the chain of parent-child relations.
  prefs: []
  type: TYPE_NORMAL
- en: After thinking a moment, we decide to derive the value of the field `name` from
    the class name. Every Java object has a base class, `java.lang.Object`, which
    provides access to the class information via the method `getClass()`. This method
    returns an object of the class `java.lang.Class` with all the information about
    the class used as a template for the object, including its name. Naturally, we
    first consider using `this.getClass().getName()` to get the class name inside
    `Child`, `Parent`, and `GrandDad`. But, if we start the chain of calls by calling
    `new Child()` (as we do in our example), the construct `this.getClass().getName()` always
    returns the name of the class `Child`, even when we use the construct in `GrandDad`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that, although the keyword `this` represents the current object
    (the `GrandDad` object, for example, if `this` is used in `GrandDad`), the method
    `getClass()` returns information *not about the current object*, but about the
    *runtime* object (the one that was created by the operator `new`) which is an
    instance of `Child` in this case. That is why, in our example, the construct `this.getClass().getName()` always
    returns the name of the class `Child`, whether this construct is used inside `Child`, `Parent`,
    or `GrandDad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is another way to access the class information that better suits
    our needs. We can use the class name explicitly, add the extension `.class` to
    it, and only then get the class name. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: GrandDad.class.getSimpleName(); //always returns "GrandDad"
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It seems like it's not much different from using the `String` literal we used
    before, does it? Nevertheless, it is an improvement because, if the name of the
    class changes, the value assigned to the variable `NAME` will change, too, while
    in the case of a `String` literal, its value is not tied to the name of the class
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have added a static field `NAME` with initialization to each of our
    three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = GrandDad.class.getSimpleName();
  prefs: []
  type: TYPE_NORMAL
- en: public GrandDad() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent extends GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = Parent.class.getSimpleName();
  prefs: []
  type: TYPE_NORMAL
- en: public Parent() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = Child.class.getSimpleName();
  prefs: []
  type: TYPE_NORMAL
- en: public Child() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have followed the convention of writing static variable identifiers
    in uppercase only.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `new Child()`, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32346bc4-8430-4745-b9c5-f076a9180520.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we add a constructor with a parameter, the code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = GrandDad.class.getSimpleName()
  prefs: []
  type: TYPE_NORMAL
- en: public GrandDad() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public GrandDad(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Parent extends GrandDad{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = Parent.class.getSimpleName()
  prefs: []
  type: TYPE_NORMAL
- en: public Parent() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Parent(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = Child.class.getSimpleName()
  prefs: []
  type: TYPE_NORMAL
- en: public Child() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(NAME);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Child(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of the line `new Child("The Blows")` will now change the output
    only for the child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5431dce-b244-456c-b391-1cacaff45e5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is because the new child''s constructor continues to call the parent''s
    constructor without parameters by default. To engage the new parent''s constructor,
    we need to do it explicitly, using the keyword `super` (we show only the constructors
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public GrandDad(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Parent(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: super(familyName);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Child(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: super(familyName);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'By executing the same line, `new Child("The Blows")`, we get the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d82cd27-f808-4711-8a56-be19b801524a.png)'
  prefs: []
  type: TYPE_IMG
- en: Please notice that the keyword `super` has to be the first line of a constructor.
    If you try to put it anywhere else, an error will be generated. That is because
    all the constructors have to be completely executed before any other code can
    be invoked. All the objects in the parent-child chain have to be created and their
    state initialized first, starting from the topmost base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last constructor-related feature that we would like to mention here is
    this: one constructor can call another constructor of the same class by using
    the keyword `this`. For example, let''s say we do not want a family to exist without
    a family name, but the client code might never be able to supply one. So, we decide
    to add a default family name to the constructor without parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Child extends Parent{
  prefs: []
  type: TYPE_NORMAL
- en: private static String NAME = Child.class.getSimpleName()
  prefs: []
  type: TYPE_NORMAL
- en: public Child() {
  prefs: []
  type: TYPE_NORMAL
- en: this("The Defaults");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Child(String familyName) {
  prefs: []
  type: TYPE_NORMAL
- en: super(familyName);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(familyName + ": " + NAME);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the line `new Child()` again, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef79cfa-e0bf-4034-9227-629400f76540.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the constructors of the same class can be overloaded and call
    each other the same way the methods do. But constructors are not inherited and
    thus cannot be hidden or overridden. That is just impossible.
  prefs: []
  type: TYPE_NORMAL
- en: As for any other method, it can be overridden if not private or final. What
    is private; you probably already have an idea. We will talk about it in more detail
    in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*. And we will talk about *Final variable* in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Final variable, final method, or final class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the keyword `final` and its effects depend on the context. It can
    make a variable value unchangeable, a method not overridable, or a class not extendable.
    We will briefly discuss each of this situations.
  prefs: []
  type: TYPE_NORMAL
- en: Final variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a keyword `final` is placed in front of a variable declaration, the value
    of this variable once assigned (the variable is initialized) cannot be changed.
    The way a variable can be initialized depends on how the variable is used. There
    are three kinds of variable usage, and each has different initialization rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A local variable is a variable declared in the block of code; it can be initialized
    using an assignment in the same statement with the declaration, or sometime later,
    but only once; here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class SomeClass{
  prefs: []
  type: TYPE_NORMAL
- en: private String someValue = "Initial value";
  prefs: []
  type: TYPE_NORMAL
- en: public void setSomeValue(String someValue) {
  prefs: []
  type: TYPE_NORMAL
- en: this.someValue = someValue;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getSomeValue() {
  prefs: []
  type: TYPE_NORMAL
- en: return someValue;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class FinalDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args) {
  prefs: []
  type: TYPE_NORMAL
- en: final SomeClass o = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(o.getSomeValue());   //Initial value
  prefs: []
  type: TYPE_NORMAL
- en: o.setSomeValue("Another value");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(o.getSomeValue());   //Another value
  prefs: []
  type: TYPE_NORMAL
- en: o.setSomeValue("Yet another value");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(o.getSomeValue());   //Yet another value
  prefs: []
  type: TYPE_NORMAL
- en: final String s1, s2;
  prefs: []
  type: TYPE_NORMAL
- en: final int x, y;
  prefs: []
  type: TYPE_NORMAL
- en: y = 2;
  prefs: []
  type: TYPE_NORMAL
- en: int v = y + 2;
  prefs: []
  type: TYPE_NORMAL
- en: x = v - 4;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("x = " + x);        //x = 0
  prefs: []
  type: TYPE_NORMAL
- en: s1 = "1";
  prefs: []
  type: TYPE_NORMAL
- en: s2 = s1 + " and 2";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s2);                // 1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: //o = new SomeClass();                 //error
  prefs: []
  type: TYPE_NORMAL
- en: //s2 = "3";                            //error
  prefs: []
  type: TYPE_NORMAL
- en: //x = 5;                               //error
  prefs: []
  type: TYPE_NORMAL
- en: //y = 6;                               //error
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The primitive types' final variables—after they are initialized the first time—become
    just constants and cannot be changed (see the last two lines that are commented
    as error). Similarly, the reference type `String` type final variable cannot be
    changed too, because of the `String` type immutability discussed in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. But other reference type objects, including
    arrays, are just referred to by the final variables. So, the reference itself
    cannot be changed (or reassigned) and remains a constant, too. But the state of
    the referred object can be changed, as demonstrated previously, using an object
    of `SomeClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance variable can be initialized using an assignment in the same statement
    as the declaration (the same way as a local variable), using an instance initialization
    block, or in a constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class FinalDemo {
  prefs: []
  type: TYPE_NORMAL
- en: final SomeClass o = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: final String s1 = "Initial value";
  prefs: []
  type: TYPE_NORMAL
- en: final String s2;
  prefs: []
  type: TYPE_NORMAL
- en: final String s3;
  prefs: []
  type: TYPE_NORMAL
- en: final int i = 1;
  prefs: []
  type: TYPE_NORMAL
- en: final int j;
  prefs: []
  type: TYPE_NORMAL
- en: final int k;
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: j = 2;
  prefs: []
  type: TYPE_NORMAL
- en: s2 = "new value";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public FinalDemo() {
  prefs: []
  type: TYPE_NORMAL
- en: k = 3;
  prefs: []
  type: TYPE_NORMAL
- en: s3 = "new value";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void method(){
  prefs: []
  type: TYPE_NORMAL
- en: //this.i = 4;         //error
  prefs: []
  type: TYPE_NORMAL
- en: //this.j = 4;         //error
  prefs: []
  type: TYPE_NORMAL
- en: //this.k = 4;         //error
  prefs: []
  type: TYPE_NORMAL
- en: //this.s3 = "";       //error
  prefs: []
  type: TYPE_NORMAL
- en: this.o.setSomeValue("New value");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But, after the initialization, the primitive types and `String` values of the
    final instance variable cannot be changed, while the properties of an object (or
    components of an array) can, similar to the final local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The (`static`) class final variable can be initialized using an assignment
    in the same statement as the declaration (the same way as a local or instance
    variable), or using a static initialization block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class FinalDemo {
  prefs: []
  type: TYPE_NORMAL
- en: final static SomeClass OBJ = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: final static String S1 = "Initial value";
  prefs: []
  type: TYPE_NORMAL
- en: final static String S2;
  prefs: []
  type: TYPE_NORMAL
- en: final static int INT1 = 1;
  prefs: []
  type: TYPE_NORMAL
- en: final static int INT2;
  prefs: []
  type: TYPE_NORMAL
- en: static {
  prefs: []
  type: TYPE_NORMAL
- en: INT2 = 2;
  prefs: []
  type: TYPE_NORMAL
- en: S2 = "new value";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: OBJ.setSomeValue("new value");
  prefs: []
  type: TYPE_NORMAL
- en: //OBJ = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: //S1 = "";
  prefs: []
  type: TYPE_NORMAL
- en: //S2 = "";
  prefs: []
  type: TYPE_NORMAL
- en: //INT1 = 0;
  prefs: []
  type: TYPE_NORMAL
- en: //INT2 = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As in the cases of local and instance final variables, the static final variables
    of primitive types and `String` become constants after the first assignment, while
    the property of an object (or components of an array) can be changed many times
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think you never saw a final variable before this section, please notice
    that an interface field is final implicitly. Once assigned, it cannot be changed.
    There are two other kinds of variable that are implicitly final: a variable declared
    as a resource of a `try...with...resources` statement (we will see examples in
    [Chapter 16](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml), *Database Programming*)
    and an exception parameter of a multi-catch clause (we will talk about them in
    [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*).'
  prefs: []
  type: TYPE_NORMAL
- en: Final variables are important for security, but we are not going to talk about
    security in this book. Instead, we will see many uses of final variables during
    the discussion of Java functional programming in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While reading other people''s code, you might notice that the method parameters
    are declared final:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod(final int i, final String s, final SomeClass o){
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is often done with an intent to prevent the side effects of changing values
    outside the method. But we have demonstrated already in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, of primitive types are passed as copies and
    their re-assignment changes only the copy, not the original. In the case of the
    reference type `String`, we also demonstrated in the same chapter that its value
    is immutable because, for every `String` variable reassignment, a new copy of
    the value is created and the original value is not affected. As for the other
    reference types, making the reference itself final helps only to prevent an assignment
    of a new object. But if that is not the case, the reference being final does not
    prevent a change of properties of the original object outside the method.
  prefs: []
  type: TYPE_NORMAL
- en: So, unless it is really necessary (for anonymous classes, for example, or a
    few other cases—the compiler and IDE will tell you about them), making these variables
    `final` prevents reassigning them a new value only inside the method, and does
    not help to avoid side effects outside the method.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers also argue that declaring variables final wherever possible
    makes the code author's intent easier to understand. That is true, but only if
    the convention is followed consistently and all variables that can be declared
    `final` are declared final. Otherwise, if some variables are declared final and
    some not (although they could be), the code may be misleading. One could think
    that the variables without the `final` keyword in front of them are declared so
    intentionally because they are reassigned to a different value somewhere. If you
    are not the code author (or even if you are the code author, but you are  looking
    at the code after a period of time), you can reasonably assume that there might
    be a branch of logic that takes advantage of a certain variable not being final.
    You are reluctant to add `final` to the existing variables because you are not
    sure if that was just missed or omitted intentionally, which means that the code
    is not clearer and the idea of more readable code falls apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be fair, there is a class of difficult to discover errors that can be easily
    avoided if one applies the keyword `final` wherever one can. Please look at this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class FinalVariable{
  prefs: []
  type: TYPE_NORMAL
- en: private int i;
  prefs: []
  type: TYPE_NORMAL
- en: public FinalVariable() { this.i = 1; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setInt(int i){
  prefs: []
  type: TYPE_NORMAL
- en: this.i = 100;
  prefs: []
  type: TYPE_NORMAL
- en: i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getInt(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has a field `i` that is initialized in the constructor to the value
    `1`. The class also has a getter and setter for this field. In the setter, the
    programmer made a mistake. Can you spot it? Let''s run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: FinalVariable finalVar = new FinalVariable();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("Initial setting: finalVar.getInt()=" +'
  prefs: []
  type: TYPE_NORMAL
- en: finalVar.getInt());
  prefs: []
  type: TYPE_NORMAL
- en: finalVar.setInt(5);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("After setting to 5: finalVar.getInt()=" +'
  prefs: []
  type: TYPE_NORMAL
- en: finalVar.getInt());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, we create an object of class `FinalVariable`. The constructor
    assigns it the value of `1` and we confirm it using the getter. Then, we try to
    assign it the value of `5` and expect the getter to return this value. Instead,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eab4c3b7-7a1c-4f4c-b2f8-51d8a0c086e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what happens if we declare the parameter `final`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public void setInt(final int i){
  prefs: []
  type: TYPE_NORMAL
- en: this.i = 100;
  prefs: []
  type: TYPE_NORMAL
- en: i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler and IDE would warn us that we are trying to assign the variable
    `i` to another value. We would see the problem and fix it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public void setInt(final int i){
  prefs: []
  type: TYPE_NORMAL
- en: this.i = 100;
  prefs: []
  type: TYPE_NORMAL
- en: this.i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the code would start behaving as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b909084a-8295-4ad3-8470-576f6d6ee355.png)'
  prefs: []
  type: TYPE_IMG
- en: But there are not many such cases, and soon you are going to learn how to avoid
    such pitfalls and start adding `this` in front of the instance variable automatically.
    So, in our opinion, extensive use of the keyword `final` as the way to improve
    code quality is not justified, but some programmers still prefer doing that, so
    we leave it as a matter of programming style.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, adding the keyword `final` as a way to improve application performance
    is reportedly useful in some special cases, but we have not encountered these
    cases ourselves and thus leave it to those who can demonstrate such a case.
  prefs: []
  type: TYPE_NORMAL
- en: Final method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The keyword `final` in front of a method makes it impossible to override it
    in a child class instance or hide if, the method is static. It provides an assurance
    that the method functionality cannot be changed through overriding. The class
    `java.lang.Object`, for example, has many of its methods as final.
  prefs: []
  type: TYPE_NORMAL
- en: But if a final method uses non-final ones, this may allow for the backdoor introduction
    of undesirable changes. Naturally, such considerations are very important for
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, one can read that making methods final can improve code performance.
    It may be the case, but in some very specific situations and does not seem to
    help significantly in mainstream programming. For performance improvements, there
    are usually much better opportunities available, including the proven object-oriented
    design principles (see [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*).
  prefs: []
  type: TYPE_NORMAL
- en: All private methods and methods of a final class (which are not inherited) are
    effectively final because one cannot override them.
  prefs: []
  type: TYPE_NORMAL
- en: Final class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class declared final cannot be extended. That is, it cannot have children,
    which makes all the methods of the class effectively final.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is widely used for security or when a programmer would like to
    make sure the class functionality cannot be overridden, overloaded, or hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Restricting a class instantiation to a single shared instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a class in such a way that it guarantees that only one object can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is one possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SingletonClassExample {
  prefs: []
  type: TYPE_NORMAL
- en: private static SingletonClassExample OBJECT = null;
  prefs: []
  type: TYPE_NORMAL
- en: private SingletonClassExample(){}
  prefs: []
  type: TYPE_NORMAL
- en: public final SingletonClassExample getInstance() {
  prefs: []
  type: TYPE_NORMAL
- en: if(OBJECT == null){
  prefs: []
  type: TYPE_NORMAL
- en: OBJECT = new SingletonClassExample();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return OBJECT;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other class functionality
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Another solution could be to make the class private inside the factory class
    and store it in the factory field, similarly to the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware, though, that if such a single object has a state that is changing,
    one has to make sure it is acceptable to modify the state and rely on it concurrently,
    because this object may be used by different methods at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most often used terms, API, was thoroughly discussed in this chapter,
    as well as the related topics of object factories, overriding, hiding, and overloading.
    Also, the use of the keywords `this` and `super` was explored in detail and demonstrated
    during the explanation of constructors. The chapter concluded with an overview
    of the keyword `final` and its use for local variables, fields, methods, and classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe package and class member accessibility (also
    called visibility), which will help us to expand on one of the key object-oriented
    programming concepts, encapsulation. It will lay the foundation for our discussion
    of object-oriented design principles.
  prefs: []
  type: TYPE_NORMAL
