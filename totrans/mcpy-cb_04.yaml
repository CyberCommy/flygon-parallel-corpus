- en: Interacting with Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to methods of interacting with the buttons and
    touchpads that come with the Adafruit Circuit Playground Express. You will learn
    how to detect whether a button is being pressed and you will also explore more
    advanced topics, such as fine tuning the sensitivity of capacitive touchpads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting push button presses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling LEDs with push buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a slide switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions on the button state change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving active LEDs with push buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a beep on the button press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting touch on a touchpad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the touchpad raw measurements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the touch threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit Circuit Playground Express layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following photograph displays the locations of the two push buttons, labeled
    A and B, that come with the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/218effcf-eb72-4d4b-9d79-22da608a3f65.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photograph shows the location of the slide switch on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/654587b7-181c-48c5-be45-6e3d7f9b9d2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: 'The following photograph shows the location of the seven capacitive touchpads
    on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d427f3e-82fd-4e6f-b431-d853f833347e.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: Each touchpad contains a different material that can conduct electricity. Alligator
    clips can be used to connect these materials to the pads. Additionally, metals,
    water, and fruits can conduct electricity well enough to be used as connectors
    to the pads.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how to detect the press of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting push button presses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a program that will print a message
    when the push button is pressed. Push buttons are a great way to create user interaction
    on your devices. This board comes with two push buttons, A and B, so you can create
    all sorts of different interactions with your users by reading and responding
    to push button events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following lines of code in the REPL. The value of `cpx.button_a` is
    `False` here because the button is not pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep push button A pressed while you run the following code block. This will
    change the value to `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code to the `main.py` file and this will repeatedly
    print the state of push button A on execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a property called `button_a`. This property will return `True`
    when the button is pressed, and it will return `False` when the button is not
    pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The script loops forever with a 50 millisecond delay between each loop. The
    state of the button press is continually printed. When running this program, hold
    and release the push button to see the printed output change.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is another property called `button_b`, which serves the same
    function but for push button B instead.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interface for interacting with the push button in Python is very straightforward.
    Essentially, it translates to a Boolean value, which you can inspect at any time
    during your script execution in order to check the current state of the button.
  prefs: []
  type: TYPE_NORMAL
- en: This polling model of repeatedly checking the button state works well in simple
    scenarios. However, it proves to be problematic when you want to perform a single
    action for each button press, as opposed to continually pressing the button. This
    is similar to how you would expect to interact with a keyboard on a desktop. In
    this scenario, you expect that one physical key press will translate into an action
    being applied once. On the other hand, a physical key press that is held down
    for an extended period of time usually produces repeated key actions.
  prefs: []
  type: TYPE_NORMAL
- en: On most operating systems, a delay of 500 milliseconds or so is applied before
    the key is released, where it is considered as a **repeat key action**. It is
    important to bear these details in mind when you are trying to implement code
    that interacts with the push buttons in a natural and intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the `button_a` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.button_a).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of interacting with push buttons can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/buttons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling LEDs with push buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to control two separate NeoPixels with two
    independent push buttons. This is a fun and simple way of creating interactivity
    with your device. Here, you will get immediate feedback from the board the moment
    you press each push button, as the pixels will light up in response.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep push button A pressed while you run the following code block. You should
    see pixel 2, which is located right next to the push button, light up green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Release push button A and run the following code block; you should now see
    pixel 2 turn off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file and it will turn pixel 2 and pixel
    7 *on*, depending on whether push button A or push button B is being pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. The constants
    for the green and black color are defined and the pixel brightness is then set
    to a comfortable level.
  prefs: []
  type: TYPE_NORMAL
- en: Then, an infinite loop is started, which executes two lines of code on each
    iteration. The first line will set the color of pixel 2 to green if push button
    A is pressed, otherwise, it will set the pixel to off. The second line will set
    the color of pixel 7 to green if push button B is pressed, otherwise, it will
    set the pixel to off.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to the first recipe in this chapter, there is no call to the `sleep`
    function to cause a delay between each loop. In this specific recipe, there is
    a reason why no delay is needed between each time the button state is polled.
    If one of the buttons is held down, then one of the lights will turn on and stay
    on without an issue.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the first recipe, a flood of print statements will occur while
    the button is being pressed. It is important to look at each scenario carefully
    to decide whether a delay is required between each poll.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation on conditional expressions can be found at [https://docs.python.org/3/reference/expressions.html#conditional-expressions](https://docs.python.org/3/reference/expressions.html#conditional-expressions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further details on how push buttons work can be found at [https://sciencing.com/push-switches-work-electrical-circuit-5030234.html](https://sciencing.com/push-switches-work-electrical-circuit-5030234.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a slide switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a program that will repeatedly print
    whether a slide switch is on or off. Slide switches have their own strengths,
    and this recipe will demonstrate how you can incorporate one into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the slide switch is flipped to the left-hand side. Run the following
    lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the slide switch to be flipped to the right-hand side. Run the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file and it will repeatedly print the
    state of the slide switch on execution. Turn the slide switch to the left and
    right to observe the change in output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a property called `switch`. This property will return `True` when
    the switch is in the left position, and `False` when it is in the right position.
  prefs: []
  type: TYPE_NORMAL
- en: The script loops forever with a 50 millisecond delay between each loop. The
    state of the slide switch is continually printed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Push buttons are great for applying an action repeatedly, or when you want to
    register a single button press. Slide switches, however, are more suitable when
    you want people to be able to specify between two operating modes.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you might have a project that has two animation modes that can
    be selected with a slide switch. You could use the slide switch to enable or disable
    an alarm sound in your project. Depending on the user action, a slide switch or
    push button might be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about the Circuit Playground Express is that both options are
    available, so you can pick and choose which one works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the switch property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.switch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of how common types of switches work can be found at [https://learn.sparkfun.com/tutorials/switch-basics/all](https://learn.sparkfun.com/tutorials/switch-basics/all).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions on the button state change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to call a function when the state of a button
    has changed. It is a common requirement that you only want an action to be performed
    when a button has a state change, as opposed to while the button is pushed down.
    This recipe demonstrates one technique that you can use to implement this requirement
    in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will define the `button_change` function, which will be called each time
    a change has occurred in the button state. Run the following code and then repeatedly
    press and release push button A:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this to the `main.py` file; it will print a message each
    time push button A is pressed or released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `button_change` function is defined, which will be called each time the
    state of the button changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `last` global variable will be used to keep track of the last state of the
    button. Then, an infinite loop is started, which will check whether the current
    state of the button differs from its last state. If it has detected a change,
    then it will call the `button_change` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the latest button state is saved in the `last` variable whenever it
    changes. This script essentially implements an event loop that detects button
    press events and calls the `button_change` event handler to handle these events
    whenever they are detected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, you might want to register a button press as a single event regardless
    of whether the user holds the button down for a long or short period of time.
    This recipe achieves that goal by keeping track of the previous state of the button
    and only calling the event handler once, as the result of a button press.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you have the extra step of tracking the last state of a button,
    the benefit of this approach is that you don't have to fiddle with the timing
    of delays between polling for key presses, or the timing of repeated keyboard
    delays. This recipe is just another viable approach to solve the problem of when
    and how to respond to physical button interactions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of an event loop and event handlers can be found at [https://docs.python.org/3/library/cmd.html](https://docs.python.org/3/library/cmd.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of responding to button presses can be found at [https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch](https://learn.adafruit.com/sensor-plotting-with-mu-and-circuitpython/buttons-and-switch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving active LEDs with push buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to move the active NeoPixel clockwise and
    counterclockwise depending on whether the left or right push button is pressed.
    This recipe goes beyond the simpler button and LED interactions shown in previous
    recipes. This is a more involved recipe, which will create the impression that
    button presses are moving the light in a circular motion around the board.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code and press the push buttons to see the effect this has
    on the pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this block of code to the `main.py` file and it will change
    the direction of the lighted pixels from clockwise to counterclockwise each time
    push button A and push button B are pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library and the
    `time` library. Then, the color constants and brightness level are set. The `i` variable
    will keep track of which pixel is currently lit. The `direction` variable will
    either have the value of `1` or `-1` and will control whether the pixel moves
    in a clockwise or counterclockwise direction.
  prefs: []
  type: TYPE_NORMAL
- en: In the infinite loop, the direction will be changed if either push button A
    or push button B is pressed. The direction is applied to the position and a modulus
    10 operation is applied so that the position value rotates between the values
    of 0 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, all the pixels are turned off and then the selected pixel
    is turned on. The speed of the light animation is controlled with a call to make
    the board sleep for 50 milliseconds between each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe combines a number of different techniques in order to produce the
    final result. It uses an animation effect where someone looking at the board thinks
    the light is moving around the board in a circle.
  prefs: []
  type: TYPE_NORMAL
- en: The animation effect has been implemented to support directional motion so that
    it will look as if the light is moving in either a clockwise or counterclockwise
    direction. Then, the push buttons are combined with this animation to change the
    direction of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: You can take this base recipe and adapt it to different scenarios. For instance,
    you could replace the light show with a sound effect that goes from either quiet
    to loud, or loud to quiet, depending on which button is pressed. Additionally,
    you could use the two push buttons to increase or decrease the level of brightness.
    Having two push buttons opens many options to either increase or decrease a particular
    value depending on which button is being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Details on a Circuit Playground project that uses the push buttons and pixels
    can be found at [https://learn.adafruit.com/circuit-playground-simple-simon](https://learn.adafruit.com/circuit-playground-simple-simon).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the modulo operator can be found at [https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations](https://docs.python.org/3.3/reference/expressions.html#binary-arithmetic-operations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a beep on the button press
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to play a beeping tone when the button is
    pressed. The previous recipes allowed us to interact with light using the buttons.
    This recipe will show you how to introduce button and sound interactions in your
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL while keeping push button A pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The speaker should have given a low-pitch beep. Run the following code while
    keeping push button B pressed, and you should hear a high-pitch beep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe and adds a
    `while` loop to it to make one complete program. Add this to the `main.py` file,
    and, when executed, it will produce either a high-or low-pitch beep each time
    either push button A or push button B is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. An infinite
    loop is then entered that will check whether push button A or push button B is
    being pressed in each loop iteration, and play a different pitched beep in each
    case for a duration of 0.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This simple recipe demonstrates how you can make the board react to different
    button presses by playing different tones. Another way that you can make the script
    behave is by playing different audio `.wav` files depending on which push button
    is being pressed. The slide switch could also be incorporated into the recipe
    to set two different modes; one mode could play notes of a low pitch, and the
    other could play notes of a high pitch.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of how CircuitPython can read the input from push buttons can be found
    at [https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out](https://learn.adafruit.com/circuitpython-essentials/circuitpython-digital-in-out).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of a Circuit Playground project that reacts to inputs to play different
    tones can be found at [https://learn.adafruit.com/dear-diary-alarm](https://learn.adafruit.com/dear-diary-alarm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting touch on a touchpad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to detect when a touchpad is touched and to
    print a message each time this event occurs. The Circuit Playground Express comes
    with a number of touchpad connectors that can be attached to all sorts of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, anything that can conduct electricity can be used as a way to interact
    with your device. You can use wires, conductive thread, fruit, water, or copper
    tape to interact with your device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. The value of `cpx.touch_A1` is
    `False` because touchpad A1 is not being touched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep your finger touching touchpad A1 while you run the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be added to the `main.py` file. This will print a
    message every time you press touchpad A1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first few lines of code import the Circuit Playground Express library and
    the `time` library. The script then enters into an infinite loop where it checks
    the state of touchpad A1 in each loop iteration. If it has detected a touch occurring,
    then it will print a message.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates a simple way to interact with touchpads. However, when
    it comes to capacitive touch sensors, the devil is in the detail. Depending on
    how conductive the material you attach to the touchpad is, you might find yourself
    in one of two extremes; that is, the sensors might not detect some touch events
    at all, or if there is a lot of ambient noise, which is being falsely detected
    as multiple touch events.
  prefs: []
  type: TYPE_NORMAL
- en: These devices aren't as simple as a mechanical push button. On the flip side,
    however, they will let you create projects where you can interact with your embedded
    device using bananas and oranges (as they are electrically conductive).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the `touch_A1` property can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.touch_A1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of interacting with capacitive touch sensors can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch](https://learn.adafruit.com/adafruit-circuit-playground-express/adafruit2-circuitpython-cap-touch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the touchpad raw measurements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to monitor the touchpad raw measurements,
    which is a very useful way to verify how much the touch threshold should be adjusted.
    It is very important to be able to directly read the raw sensor values that are
    coming from the touch sensors.
  prefs: []
  type: TYPE_NORMAL
- en: This level of detail is necessary when you want to correctly set touch thresholds
    or when you want to find out why the touchpads aren't responding the way you expect
    them to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. The output shows the value taken
    from a raw touch measurement and the initial threshold value that was automatically
    set when the object was created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep your finger touching touchpad A1 while you run the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Release your finger from touchpad A1 while you run the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be added to the `main.py` file and then run. While
    this code is executing, it will continually print the raw touch measurements and
    the current threshold, and determine whether the current reading is considered
    a touch event. This script can be used to get live sensor readings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first few lines of code import the different low-level libraries that are
    required to interact with the touchpad. A `TouchIn` object is created and connected
    to pad A1\. Then, an infinite loop is run, which continually prints out a number
    of values relating to the sensor. It prints the current raw touch measurement
    of the threshold and whether the current measurement should be registered as a
    touch event.
  prefs: []
  type: TYPE_NORMAL
- en: The last value is simply `True`, but if the raw value exceeds the threshold,
    then it is `False`. The threshold is set when the `TouchIn` object is first instantiated
    by taking the initial raw value and adding 100 to this value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is very useful for verifying the actual values that are being read
    from the touch sensor and for deciding how low or high the touch threshold should
    be set. It's also a great way to connect different materials to your board and
    see how well they perform in conducting electricity and detecting touch events.
    Without these raw values, you can only guess at what is actually going on.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-level properties used elsewhere in this chapter actually used a lot
    of the libraries introduced in this recipe under the hood. It is helpful to look
    at the source code of this higher-level code, as much of it is implemented in
    Python. Additionally, it gives you an insight into how the code is actually interacting
    with the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the `touchio` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further documentation on the `board` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion on the capabilities of capacitive touch sensors on the Circuit
    Playground can be found at [https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch](https://learn.adafruit.com/circuit-playground-fruit-drums/hello-capacitive-touch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of how capacitive touch sensors work can be found at [https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/](https://scienceline.org/2012/01/okay-but-how-do-touch-screens-actually-work/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the touch threshold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to adjust the sensitivity of the touchpad
    by changing the threshold value. This is used to decide whether a signal will
    be treated as a touch event not. This is an important setting to tweak and set
    to the correct value. If you don't, then a lot of your touch projects won't behave
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. The touch threshold will have
    been increased by `200` at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep your finger touching touchpad A1 while you run the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be added to the `main.py` file and run. The script
    will increase the touch threshold by `200` and print a message each time the sensor
    detects a touch event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a method called `adjust_touch_threshold`. This method can be used
    to change the configured threshold on the touchpads. When called, the threshold
    for all touchpads will be increased by the specified amount.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the threshold value makes the touchpad less sensitive, while decreasing
    this value will make the sensor more sensitive. If the threshold setting is set
    too low, then many sensor readings will be incorrectly detected as touch events.
    On the other hand, if the threshold is too high, then genuine touch events will
    not be detected. A sleep function of 500 milliseconds is applied between each
    loop iteration so that a flood of touch events isn't detected during each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to decide on what to set as the value for the threshold is through
    experimentation. Connect all the actual conductive materials to the touchpads
    before starting your threshold tuning. Then, use the *Monitoring the touchpad
    raw measurements* recipe in this chapter to get a live view of the sensor readings
    you are receiving.
  prefs: []
  type: TYPE_NORMAL
- en: You can also repeatedly touch the material in question to see how the readings
    vary when you touch and let go. Based on these readings, you can set the ideal
    threshold that will reliably read touch events. It is important to restart your
    script each time you change the materials as the initial threshold autoconfiguration
    occurs each time you run the code the first time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the `adjust_touch_threshold` method can be found at
    [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.adjust_touch_threshold).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of calling the `adjust_touch_threshold` method can be found at [https://learn.adafruit.com/make-it-sense/circuitpython-6](https://learn.adafruit.com/make-it-sense/circuitpython-6).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
