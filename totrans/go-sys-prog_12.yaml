- en: Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about developing web applications, talking
    to databases, and dealing with JSON data in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topic of this chapter is the development of Go applications that work over
    TCP/IP networks. In addition, you will learn how to create TCP and UDP clients
    and servers. The central Go package of this chapter will be the `net` package:
    most of its functions are quite low level and require a good knowledge of TCP/IP
    and its family of protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: However, have in mind that network programming is a huge theme that cannot be
    covered in a single chapter. This chapter will give you the foundational directions
    for how to create TCP/IP applications in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'More analytically, this chapter will talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How TCP/IP operates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `net` Go standard package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing TCP clients and servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programing UDP clients and servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an RPC client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an RPC server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Wireshark and `tshark(1)` network traffic analyzers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing DNS lookups from Go programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About network programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network programming** is the development of applications that can operate
    over computer networks using TCP/IP, which is the dominant networking protocol.
    Therefore, without knowing the way TCP/IP and its protocols work, you cannot create
    network applications and develop TCP/IP servers.'
  prefs: []
  type: TYPE_NORMAL
- en: The best two advices that I can give to developers of network applications,
    are to know the theory behind the task they want to perform and to know that networks
    fail all the time for several reasons. The nastiest types of network failures
    have to do with malfunctioning or misconfigured DNS servers, because such problems
    are challenging to find and difficult to correct.
  prefs: []
  type: TYPE_NORMAL
- en: About TCP/IP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TCP/IP** is a family of protocols that help the internet to operate. Its
    name comes from its two most well-known protocols: **TCP** and **IP**.'
  prefs: []
  type: TYPE_NORMAL
- en: Every device that uses TCP/IP must have an IP address, which should be unique
    at least to its local network. It also needs a **network mask** (used for dividing
    big IP networks into smaller networks) that is related to its current network,
    one or more **DNS servers** (used for translating an IP address to a human-memorable
    format and vice versa) and, if you want to communicate with devices beyond your
    local network, the IP address of a device that will act as the **default gateway**
    (a network device that TCP/IP sends a network packet to when it cannot find where
    else to send it).
  prefs: []
  type: TYPE_NORMAL
- en: Each TCP/IP service, which in reality is a Unix process, listens to a port number
    that is unique to each machine. Note that port numbers 0-1023 are restricted and
    can only be used by the root user, so it is better to avoid using them and choose
    something else, provided that it is not already in use by a different process.
  prefs: []
  type: TYPE_NORMAL
- en: About TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TCP** stands for **Transmission** **Control** **Protocol**. TCP software
    transmits data between machines using segments, which are called TCP **packets**.
    The main characteristic of TCP is that it is a reliable protocol, which means
    that it attempts to make sure that a packet was delivered. If there is no proof
    of a packet delivery, TCP resends that particular packet. Among other things,
    a TCP packet can be used for establishing connections, transferring data, sending
    acknowledgments, and closing connections.'
  prefs: []
  type: TYPE_NORMAL
- en: When a TCP connection is established between two machines, a full duplex virtual
    circuit, similar to the telephone call, is created between these two machines.
    The two machines constantly communicate to make sure that data are sent and received
    correctly. If the connection fails for some reason, the two machines try to find
    the problem and report to the relevant application.
  prefs: []
  type: TYPE_NORMAL
- en: TCP assigns a sequence number to each transmitted packet and expects a positive
    acknowledgment (ACK) from the receiving TCP stack. If the ACK is not received
    within a timeout interval, the data is retransmitted as the original packet is
    considered undelivered. The receiving TCP stack uses the sequence numbers to rearrange
    the segments when they arrive out of order, which also eliminates duplicate segments.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP header of each packet includes **source port and destination port**
    fields. These two fields plus the source and destination IP addresses are combined
    to uniquely identify each TCP connection. The TCP header also includes a 6-bit
    flags field that is used to relay control information between TCP peers. The possible
    flags include SYN, FIN, RESET, PUSH, URG, and ACK. The SYN and ACK flags are used
    for the initial TCP 3-way handshake. The RESET flag signifies that the receiver
    wants to abort the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP handshake!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a connection is initiated, the client sends a TCP SYN packet to the server.
    The TCP header also includes a sequence number field that has an arbitrary value
    in the SYN packet. The server sends back a TCP [SYN, ACK] packet, which includes
    the sequence number of the opposite direction and an acknowledgment of the previous
    sequence number. Finally, in order to truly establish the TCP connection, the
    client sends a TCP ACK packet in order to acknowledge the sequence number of the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Although all these actions take place automatically, it is good to know what
    is happening behind the scenes!
  prefs: []
  type: TYPE_NORMAL
- en: About UDP and IP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IP** stands for **Internet Protocol**. The main characteristic of IP is that
    it is not a reliable protocol by nature. IP encapsulates the data that travels
    in a TCP/IP network because it is responsible for delivering packets from the
    source host to the destination host according to the IP addresses. IP has to find
    an addressing method to effectively send the packet to its destination. Although
    there exist dedicated devices called routers that perform IP routing, every TCP/IP
    device has to perform some basic routing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP** (short for **User Datagram Protocol**) is based on IP, which means
    that it is also unreliable. Generally speaking, UDP is simpler than TCP mainly
    because UDP is not reliable by design. As a result, UDP messages can be lost,
    duplicated, or arrive out of order. Furthermore, packets can arrive faster than
    the recipient can process them. So, UDP is used when speed is more important than
    reliability! An example for this is live video and audio applications where catching
    up is way more important than buffering and not losing any data.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when you do not need too many network packets to transfer the desired information,
    using a protocol that is based on IP might be more efficient than using TCP, even
    if you have to retransmit a network packet, because there is no traffic overhead
    from the TCP handshake.
  prefs: []
  type: TYPE_NORMAL
- en: About Wireshark and tshark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wireshark** is a graphical application for analyzing network traffic of almost
    any kind. Nevertheless, there are times that you need something lighter that you
    can execute remotely without a graphical user interface. In such situations, you
    can use `tshark`, which is the command-line version of Wireshark.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to help you find the network data you really want, Wireshark and `tshark`
    have support for capture filters and display filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture filters are the filters that are applied during network data capturing;
    therefore, they make Wireshark discard network traffic that does not match the
    filter. Display filters are the filters that are applied after packet capturing;
    therefore, they just hide some network traffic without deleting it: you can always
    disable a display filter and get your hidden data back. Generally speaking, display
    filters are considered more useful and versatile than capture filters because,
    normally, you do not know in advance what you will capture or want to examine.
    Nevertheless, applying filters at capture time can save you time and disk space
    and that is the main reason for using them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the traffic of a TCP handshake in more detail
    as captured by Wireshark. The client IP address is `10.0.2.15` and the destination
    IP address is `80.244.178.150`. Additionally, a simple display filter (`tcp &&
    !http`) makes Wireshark display fewer packets and makes the output less cluttered
    and therefore easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cd7d321-edd4-4d49-8713-bc9cea9535f6.png)'
  prefs: []
  type: TYPE_IMG
- en: The TCP handshake!
  prefs: []
  type: TYPE_NORMAL
- en: 'The same information can be seen in text format using `tshark(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `-r` parameter followed by an existing filename allows you to replay a previously
    captured data file on your screen, whereas a more complex display filter, which
    is defined after the `-Y` parameter, does the rest of the job!
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Wireshark at [https://www.wireshark.org/](https://www.wireshark.org/)
    and by looking at its documentation at [https://www.wireshark.org/docs/](https://www.wireshark.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: About the netcat utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times that you will need to test a TCP/IP client or a TCP/IP server:
    the `netcat(1)` utility can help you with that by playing the role of the client
    or server in a TCP or UDP application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `netcat(1)` as a client for a TCP service that runs on a machine
    with the `192.168.1.123` IP address and listens to port number `1234`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can use `netcat(1)` as a client for a UDP service that runs
    on a Unix machine named `amachine.com` and listens to port number `2345`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-l` option tells `netcat(1)` to listen for incoming connections, which
    makes `netcat(1)` to act as a TCP or UDP server. If you try to use `netcat(1)`
    as a server with a port that is already in use, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The net Go standard package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most useful Go package for creating TCP/IP applications is the `net` Go
    standard package. The `net.Dial()` function is used for connecting to a network
    as a client, and the `net.Listen()` function is used for accepting connections
    as a server. The first parameter of both functions is the network type, but this
    is where the similarities end.
  prefs: []
  type: TYPE_NORMAL
- en: For the `net.Dial()` function, the network type can be one of tcp, tcp4 (IPv4-only),
    tcp6 (IPv6-only), udp, udp4 (IPv4-only), udp6 (IPv6-only), ip, ip4 (IPv4-only),
    ip6 (IPv6-only), Unix, Unixgram, or Unixpacket. For the `net.Listen()` function,
    the first parameter can be one of tcp, tcp4, tcp6, Unix, or Unixpacket.
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the `net.Dial()` function is of the `net.Conn` interface
    type, which implements the `io.Reader` and `io.Writer` interfaces! This means
    that you already know how to access the variables of the `net.Conn` interface!
  prefs: []
  type: TYPE_NORMAL
- en: So, although the way you create a network connection is different from the way
    you create a text file, their access methods are the same because the `net.Conn`
    interface implements the `io.Reader` and `io.Writer interfaces`. Therefore, as
    network connections are treated as files, you might need to review [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: Unix sockets revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)*,* *Processes
    and Signals*, we talked a little about Unix sockets and presented a small Go program
    that was acting as a Unix socket client. This section will also create a Unix
    socket server to make things even clearer. However, the Go code of the Unix socket
    client will be also explained here in more detail and will be enriched with error
    handling code.
  prefs: []
  type: TYPE_NORMAL
- en: A Unix socket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unix socket server will act as an Echo server, which means that it will
    send the received message back to the client. The name of the program will be
    `socketServer.go` and it will be presented to you in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `socketServer.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the Unix socket server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is where the function that serves incoming connections is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third portion of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the use of the `net.Listen()` function with the `unix` argument
    for creating the desired socket file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each connection is first handled by the `Accept()` function
    and served by its own goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `socketServer.go` serves a client, it generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you cannot create the desired socket file, for instance, if it already exists,
    you will get an error message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A Unix socket client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the Unix socket client program is `socketClient.go` and will be
    presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special here, just the required Go packages. The second portion
    contains the definition of a Go function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `readSocket()` function reads the data from a socket file using `Read()`.
    Note that, although `socketClient.go` just reads from the socket file, the socket
    is bisectional, which means that you can also write to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `net.Dial()` function with the right first argument allows you to connect
    to the socket file before you try to read from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `socketClient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use `socketClient.go`, you must have another program dealing with
    the Unix socket file, which, in this case will be `socketServer.go`. So, if `socketServer.go`
    is already running, you will get the following output from `socketClient.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not have enough Unix file permissions to read the desired socket
    file, then `socketClient.go` will fail with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the socket file you want to read does not exist, `socketClient.go`
    will fail with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Performing DNS lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There exist many types of DNS lookups, but two of them are the most popular.
    In the first type, you want to go from an IP address to a domain name and in the
    second type you want to go from a domain name to an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows an example of the first type of DNS lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows three examples of the second type of DNS lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you just saw in the aforementioned examples, an IP address can serve many
    hosts and a host name can have many IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library provides the `net.LookupHost()` and `net.LookupAddr()`
    functions that can answer DNS queries for you. However, none of them allow you
    to define the DNS server you want to query. While using standard Go libraries
    is ideal, there exist external Go libraries that allow you to choose the DNS server
    you desire, which is mainly required when troubleshooting DNS configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Using an IP address as input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the Go utility that will return the hostname of an IP address will
    be `lookIP.go` and will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `net.ParseIP()` function allows you to verify the validity of the given
    IP address and is pretty handy for catching illegal IP addresses such as `288.8.8.8`
    and `8.288.8.8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `net.LookupAddr()` function returns a string slice with
    the list of names that match the given IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `lookIP.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate the output of `dnsLookup.go` using `host(1)` or `dig(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using a host name as input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The name of this DNS utility will be `lookHost.go` and will be presented in
    three parts. The first part of the `lookHost.go` utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `net.LookupHost()` function also returns a string slice with
    the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program has the following code, which is for error checking
    and printing the output of `net.LookupHost()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `lookHost.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the output is the IPv6 address, whereas the second output
    line is the IPv4 address of `www.google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the operation of `lookHost.go` by comparing its output with
    the output of the `host(1)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Getting NS records for a domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will present an additional kind of DNS lookup that returns the
    domain name servers for a given domain. This is very handy for troubleshooting
    DNS-related problems and finding out the status of a domain. The presented program
    will be named `lookNS.go` and will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `net.LookupNS()` function does all the work for us by returning a slice
    of `NS` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the code is mainly for printing the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `lookNS.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason that the following query will fail is that `www.mtsoukalos.eu` is
    not a domain but a single host, which means that it has no `NS` records associated
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `host(1)` utility to verify the previous output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Developing a simple TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will develop a TCP server that implements the **Echo** service.
    The Echo service is usually implemented using the UDP protocol due to its simplicity,
    but it can also be implemented with TCP. The Echo service usually uses port number
    `7`, but our implementation will use other port numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `TCPserver.go` file will hold the Go code of this section and will be presented
    in six parts. For reasons of simplicity, each connection is handled inside the
    `main()` function without calling a separate function. However, this is not the
    recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the TCP server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of `TCPserver.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What is important to remember here is that `net.Listen()` returns a `Listener`
    variable, which is a generic network listener for stream-oriented protocols. Additionally,
    the `Listen()` function can support more formats: check the documentation of the
    `net` package to find more information about that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the TCP server has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Only after a successful call to `Accept()`, the TCP server can start interacting
    with TCP clients. Nonetheless, the current version of `TCPserver.go` has a very
    serious shortcoming: it can only serve a single TCP client, the first one that
    will connect to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth portion of the `TCPserver.go` code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, you read data from your client using `bufio.NewReader().ReadString()`.
    The aforementioned call allows you to read your input line by line. Additionally,
    the `for` loop allows you to keep reading data from the TCP client for as long
    as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the Echo TCP server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The current version of `TCPserver.go` stops when it receives the `STOP` string
    as input. Although TCP servers do not usually terminate in that style, this is
    a pretty handy way to terminate a TCP server process that will only serve a single
    client!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test `TCPserver.go` with `netcat(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `netcat(1)` part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first and third lines are our input, whereas the second and fourth
    lines are the responses from the Echo server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use an improper port number, `TCPserver.go` will generate the
    following error message and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Developing a simple TCP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will develop a TCP client named `TCPclient.go`. The port
    number the client will try to connect to as well as the server address will be
    given as command-line arguments to the program. The Go code of the TCP client
    will be presented in five parts; the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `TCPclient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of `TCPclient.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once again, you use the `net.Dial()` function to try to connect to the desired
    port of the desired TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the TCP client is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, you read data from the user that you will send to the TCP server using
    `fmt.Fprintf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `TCPclient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you get data from the TCP server using `bufio.NewReader().ReadString()`.
    The reason for using the `strings.TrimSpace()` function is to remove any spaces
    and newline characters from the variable you want to compare with the static string
    (`STOP`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now it is time to verify that `TCPclient.go` works as expected using it
    to connect to `TCPserver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If no process listens to the specified TCP port at the specified host, then
    you will get an error message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using other functions for the TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will develop the functionality of `TCPserver.go` using
    some slightly different functions. The name of the new TCP server will be `TCPs.go`
    and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `TCPs.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the TCP server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So far, there are no differences from the code of `TCPserver.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences start in the third part of `TCPs.go`, which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use the `net.ResolveTCPAddr()` and `net.ListenTCP()` functions. Is
    this version better than `TCPserver.go`? Not really. But the Go code might look
    a little clearer and this is a big advantage for some people. Additionally, `net.ListenTCP()`
    returns a `TCPListener` value that when used with `net.AcceptTCP()` instead of
    `net.Accept()` will return `TCPConn`, which offers more methods that allow you
    to change more socket options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `TCPs.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here. You still use `Accept()` to get and process client
    requests. However, this version uses `Read()` to get the client data all at once,
    which is great when you do not have to process lots of input.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of `TCPs.go` is the same with the operation of `TCPserver.go`,
    so it will not be shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to create a TCP server using an invalid port number, `TCPs.go` will
    generate an informative error message, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Using alternative functions for the TCP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we will implement `TCPclient.go` using some slightly different functions
    that are provided by the `net` Go standard package. The name of the new version
    will be `TCPc.go` and will be shown in four code segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The second code segment of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This time, we will send a static message to the TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `TCPc.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you see the use of `net.ResolveTCPAddr()` and `net.DialTCP()`,
    which is where the differences between `TCPc.go` and `TCPclient.go` exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the TCP client is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You might ask if you can use `TCPc.go` with `TCPserver.go` or `TCPs.go` with
    `TCPclient.go`. The answer is a definitive *yes* because the implementation and
    the function names have nothing to do with the actual TCP/IP operations that take
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a simple UDP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will also develop an Echo server. However, this time the Echo server
    will use the UDP protocol. The name of the program will be `UDPserver.go` and
    will be presented to you in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of `UDPserver.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The UDP approach is similar to the TCP approach: you just call functions with
    different names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the UDP case, you use `ReadFromUDP()` to read from a UDP connection and `WriteToUDP()`
    to write to an UDP connection. Additionally, the UDP connection does not need
    to call a function similar to `net.Accept()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the UDP server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we will test `UDPserver.go` with `netcat(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Developing a simple UDP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a UDP client, which we will name `UDPclient.go`
    and present in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see, the code differences between the Go code of `UDPclient.go`
    and `TCPc.go` are basically the differences in the names of the functions used:
    the general idea is exactly the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the UDP client is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the utility contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of `UDPclient.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special here: just the use of `net.ResolveUDPAddr()` and `net.DialUDP()`
    to connect to the UDP server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the UDP client is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This time, you send your data to the UDP server using `Write()`, although you
    will read from the UDP server using `ReadFromUDP()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `UDPclient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have `UDPserver.go` and we know that it works, we can test the operation
    of `UDPclient.go` using `UDPserver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute `UDPclient.go` without a UDP server listening to the desired
    port, you will get the following output, which does not clearly state that it
    could not connect to an UDP server: it just shows an empty reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: A concurrent TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to develop a concurrent TCP server: each
    client connection will be assigned to a new goroutine that will serve the client
    request. Note that although TCP clients initially connect to the same port, they
    are served using a different port number than the main port number of the server:
    this is automatically handled by TCP and is the way TCP works.'
  prefs: []
  type: TYPE_NORMAL
- en: Although creating a concurrent UDP server is also a possibility, it might not
    be absolutely necessary due to the way UDP works. However, if you have a really
    busy UDP service, then you might consider developing a concurrent UDP server.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program will be `concTCP.go` and will be presented in five parts.
    The good thing is that once you define a function to handle incoming connections,
    all you need is to execute that function as a goroutine, and the rest will be
    handled by Go!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `concTCP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the concurrent TCP server is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here is the implementation of the function that handles each TCP request. The
    time delay at the end of it is used for giving you the necessary time to connect
    with another TCP client and prove that `concTCP.go` can serve multiple TCP clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth part of `concTCP.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So far, there is nothing special in the `main()` function because although `concTCP.go`
    will handle multiple requests, it only needs a single call to `net.Listen()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last chunk of Go code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: All the differences in the way `concTCP.go` processes its requests can be found
    in the last lines of Go code. Each time the program accepts a new network request
    using `Accept()`, a new goroutine gets started and `concTCP.go` is immediately
    ready to accept more requests. Note that in order to terminate `concTCP.go`, you
    will have to press *Ctrl* + *C* because the `STOP` keyword is used for terminating
    each goroutine of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `concTCP.go` and connecting to it using various TCP clients, will
    generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Remote procedure call (RPC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Remote Procedure Call** (**RPC**) is a client-server mechanism for interprocess
    communication. Note that the RPC client and the RPC server communicate using TCP/IP,
    which means that they can exist in different machines.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to develop the implementation of an RPC client or RPC server, you will
    need to follow some steps and call some functions in a given way. Neither of the
    two implementations is difficult; you just have to follow certain steps.
  prefs: []
  type: TYPE_NORMAL
- en: Also, visit the documentation page of the `net/rpc` Go standard package that
    can be found at `https://golang.org/pkg/net/rpc/`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the presented RPC example will use TCP for client-server interaction.
    However, you can also use HTTP for client-server communication.
  prefs: []
  type: TYPE_NORMAL
- en: An RPC server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present an RPC server named `RPCserver.go`. As you will
    see in the preamble of the `RPCserver.go` program, the RPC server imports a package
    named `sharedRPC`, which is implemented in the `sharedRPC.go` file: the name of
    the package is arbitrary. Its contents are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: So, here you define a new structure that holds the signs and the values of two
    unsigned integers and a new interface named `MyInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you should install `sharedRPC.go`, which means that you should execute
    the following commands before you try to use the `sharedRPC` package in your programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are on a macOS machine (`darwin_amd64`) and you want to make sure that
    everything is OK, you can execute the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'What you really must keep in mind is that, at the end of the day, what is being
    exchanged between an RPC server and an RPC client are function names and their
    arguments. Only the functions defined in the interface of `sharedRPC.go` can be
    used in an RPC interaction: the RPC server will need to implement the functions
    of the `MyInterface` interface. The Go code of `RPCserver.go` will be presented
    in five parts; the first part of the RPC server has the expected preamble, which
    also includes the `sharedRPC` package we made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `RPCserver.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of the first function that will be offered to the
    RPC clients: you can have as many functions as you want, provided that they are
    included in the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `RPCserver.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This is the second function that is offered to the RPC clients by this RPC server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `RPCserver.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As our RPC server uses TCP, you need to make calls to `net.ResolveTCPAddr()`
    and `net.ListenTCP()`. However, you will first need to call `rpc.Register()` in
    order to be able to serve the desired interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, you accept a new TCP connection using `Accept()` as usual, but you serve
    it using `rpc.ServeConn()`.
  prefs: []
  type: TYPE_NORMAL
- en: You will have to wait for the next section and the development of the RPC client
    in order to test the operation of `RPCserver.go`.
  prefs: []
  type: TYPE_NORMAL
- en: An RPC client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will develop an RPC client named `RPCclient.go`. The Go
    code of `RPCclient.go` will be presented in five parts; the first part is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `sharedRPC` package in the RPC client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `RPCclient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of the program has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As the `MyInts` structure is defined in `sharedRPC.go`, you need to use it as
    `sharedRPC.MyInts` in the RPC client. Moreover, you call `rpc.Dial()` to connect
    to the RPC server instead of `net.Dial()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of the RPC client contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use the `Call()` function to execute the desired function in the RPC
    server. The result of the `MyInterface.Add()` function is stored in the `reply`
    variable, which was previously declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `RPCclient.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Here, you do the same thing as before for executing the `MyInterface.Subtract()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can guess, you cannot test the RPC client without having an RCP server
    and vice versa: `netcat(1)` cannot be used for RPC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to start the `RPCserver.go` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will execute the `RPCclient.go` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `RPCserver.go` process is not running and you try to execute `RPCclient.go`,
    you will get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Of course, RPC is not for adding integers or natural numbers, but for doing
    much more complex operations that you want to control from a central point.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the documentation of the net package in order to find out about its list
    of available functions at [https://golang.org/pkg/net/](https://golang.org/pkg/net/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wireshark is a great tool for analyzing network traffic of any kind: try to
    use it more.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `socketClient.go` in order to read the input from the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `socketServer.go` in order to return a random number to the
    client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `TCPserver.go` in order to stop when it receives a given
    Unix signal from the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Go code of `concTCP.go` in order to keep track of the number of clients
    it has served and print that number before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `quit()` function to `RPCserver.go` that does what its name implies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop your own RPC example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to TCP/IP, and we talked about developing
    TCP and UDP servers and clients in Go and about creating RPC clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, there is no next chapter because this is the last chapter of
    this book! Congratulations for reading the whole book! You are now ready to start
    developing useful Unix command-line utilities in Go; so, go ahead and start programming
    your own tools immediately!
  prefs: []
  type: TYPE_NORMAL
