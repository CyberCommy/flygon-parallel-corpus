- en: Understanding and Using Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is a specialized data structure that is based on the tree abstract data
    type and used in many algorithms and data structures. A common data structure
    that can be built using a heap is the Priority Queue. Also, one of the most popular
    and efficient sorting algorithms that heap sort is based on is heap data structure.
    In this chapter, we are going to discuss a heap's properties, different variants
    of heaps, and heap operations. We will also discover the heap sort and will be
    implementing heap using SPL as we progress through the chapter. We are now going
    to explore the heap and its definition in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What is a heap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By definition, a heap is a specialized tree data structure that supports a
    heap property. A heap property is defined in such a way that the root of a heap
    structure will be either smaller or larger than its child nodes. If the parent
    node is greater than the child nodes, then it is known as max-heap and if the
    parent node is smaller than the child nodes then it is known as min-heap. The
    following figure shows an example of max-heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the root node, the value **100** is greater than the two child
    nodes **19** and **36** . Similarly for **19** , the value is greater than **17**
    and **3** . It applies the same rule for **36** and **17** . As we can see from
    the tree structure, the tree is not completely sorted or ordered. But the important
    fact is we can always find the maximum or minimum at the root of the tree, which
    can be very efficient for many use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There are many variations of heap structure, such as binary heap, b-heap, Fibonacci
    heap, ternary heap, treap, weak heap, and so on. A Binary heap is one of the most
    popular for heap implementations. A binary heap is a complete binary tree where
    all inner levels of the tree are fully filled. The last level can be fully filled
    or partially filled. Since we are considering a binary heap, we can perform most
    of our operations in logarithmic time. In this book, we are going to focus on
    binary heap implementation and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Heap operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have mentioned a few times that heap is a specialized tree data structure,
    we have to make sure that we first construct a heap from a given list of items.
    As heap has a strict heap property, we have to satisfy the heap property on each
    step. Here are some of the core operations for heap:'
  prefs: []
  type: TYPE_NORMAL
- en: Create heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a new value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract minimum or maximum from heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a heap from a given list of items or numbers requires us to ensure
    that both heap property and binary tree property are satisfied. Which means the
    parent node must be greater or less than the child nodes and that will be true
    for all nodes in the tree. Also the tree must be a complete binary tree all the
    time. While creating a heap, we start with one node and insert a new node to the
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The insert node operation has a defined set of steps. We cannot start from
    an arbitrary node. The steps for insert operation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert the new node at the bottom of the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the new node with parent value if they are in the right order. If they
    are in the right order, stop there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they are not in the right order, swap them and move to the previous step
    to check the newly swapped node with its parent node. This step along with the
    previous one is known as sift up or up-heap, or bubble-up, or heapify-up, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The extract operation (minimum or maximum) takes out the root node from the
    heap. After this we have to do the following operations to ensure heap properties
    for the remaining heap:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the last node from the heap as the new root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the new root node with the child nodes, if they are in the correct order,
    stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, swap the root node with the child node (minimum child for `MinHeap`
    , maximum child for `MaxHeap` ) and continue with the previous step. This step
    along with the previous one is known as sift down or down-heap, or bubble-down
    or heapify-down, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In heap, one of the important operations is swapping. In many cases, we have
    to swap two values from two nodes without impacting the tree's properties. Now
    we are going to implement a binary heap using PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a binary heap in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular ways to implement a binary heap is using an array. Since
    heaps are complete binary trees, they can be easily implemented using an array.
    If we consider the root item to be at index 1, then the child items will be at
    index 2 and 3\. We can represent this as *i* for the root and *2*i* for the left
    child and *2*i +1* for the right child. Also, we are going to implement the mean
    heap as our example. So, let us get started with the class structure for the min-heap
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to start by creating a class for `MinHeap` , which will
    have two properties, one for storing the heap array and another count for the
    number of elements in the heap at any given moment. Here is the code for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the preceding code, we can see that we have initialized the heap
    array to have all 0 values from 0 index to `$size + 1` . Since we are considering
    putting the root at index 1, we are going to require an array with one extra space.
    Now we need a way to build a heap from a given array. As we have to satisfy heap
    property, we have to add one item to the heap and check if the heap property satisfies
    or not by using the C steps. Here is the code block for creating a heap by inserting
    one item at a time and also the `siftUp` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First we use the `create` method to build a heap from an array. For each element
    in the array, we insert it to the heap using an `insert` method. In the `insert`
    method, we check if the current size of the heap is 0 or not. If the current size
    is 0, we add the first item to index 1 and setting the next counter at 2\. If
    the heap already has an item, we will store the new item in the last position
    and increment the counter. We also call the `siftUp()` method to make sure the
    newly inserted value satisfies the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `siftUp` method, we consider the last position and its parent position
    to compare. If the child value is less than the parent one, we swap them. We continue
    this until we reach the root node at the top. This method ensures that if the
    inserted value at the end is smallest, it will be sifted up in the tree. But if
    it is not, the tree will remain as it is. Though we have talked about swapping,
    we have not seen the implementation yet. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the root element has the minimum value in the heap (we are implementing
    min-heap). The `extract` method will return the minimum value of the current heap
    all the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extractMin` method returns the first index of the array and replaces it
    with the last item of the array. After that, it performs the siftDown check for
    the newly placed root so that it ensures the heap property. Since we are extracting
    the root value, we are replacing the last index value with 0, which we have used
    for initializing the heap array. Now we are going to write the `siftDown` method,
    which we are calling the `extract` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We consider that the item at index `$k` is the smallest value. Then we compare
    the smallest value with the left and right child. If there is smaller value available,
    we swap the smallest value with the root node and it continues until the tree
    satisfies the heap property. This function calls itself recursively every time
    swapping is required. Now we need one more method to display the current heap
    as a string. For that we can write a small method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pull all the pieces together now, we have a solid implementation for
    min-heap. Let us now run a test to see if our implementation satisfies the min-heap
    properties. Here is the code we can run to build the heap and also extract the
    minimum from the heap multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the following output will be shown in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding output, when we constructed the min-heap, the
    lowest value of `9` is in the root. Then we extracted the minimum value, we took
    `9` from the heap. The root was then taken by the next minimum value of `26` and
    then followed by `34` , `37` , `44` , and `65` . Every time we take the minimum
    out, the heap is reconstructed again for the minimum value. Since we have seen
    all applicable operations for a heap data structure, we are now going to analyze
    the complexity for different heap operations.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the complexity of heap operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since there are different variations for heap implementation, the complexity
    also varies in the different implementation. One of the key facts for the heap
    is the extract operation that will always take `O(1)` time to get the maximum
    or minimum from the heap. Since we have focused on binary heap implementation,
    we are going to see the analysis of binary heap operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Complexity - average** | **Complexity - Worst** |'
  prefs: []
  type: TYPE_TB
- en: '| Search | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Insert | `O(1)` | `O(log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | `O(log n)` | `O(log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Extract | `O(1)` | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Space | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: Since the heap is not fully sorted, the search operation will take more than
    a regular binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: Using heaps as a priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main ways to use the heap data structure is to create a priority
    queue. As we have seen in [Chapter 4](text00098.html) , *Constructing Stacks and
    Queues* , priority queues are special queues where the FIFO behavior depends on
    the priority of the element rather than the way items are added to the queue.
    We have already seen the implementation using Linked list and SPL. Now we are
    going to explore the priority queue implementation using heap and especially max-heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to implement the priority queue using `MaxHeap` . Here, the
    maximum priority item is removed from the queue first. Our implementation will
    be similar to our last implementation of `MinHeap` with a little difference. Instead
    of starting the root at 1, we want to start it from 0\. So, the calculation of
    the left and right child changes as well. This will help us to understand both
    approaches of constructing a heap using an array. Here is the implementation for
    the `MaxHeap` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through our implementation of the `MaxHeap` class. There are some
    minor differences in our `MaxHeap` implementation from our `MinHeap` implementation
    in the last section. The first difference is that we have an array of size *n*
    for `MaxHeap` , whereas we had an array of size *n+1* for `MinHeap` . That makes
    our insert operation for `MaxHeap` start inserting from index 0, whereas in `MinHeap`
    , we started from index 1\. The `siftUp` functionality only sifts a value to the
    top if the value of the newly inserted item is greater than the immediate parent
    value. Also, the `extractMax` method returns the first value of the array at index
    0, which is the maximum from the heap. Once we extract the maximum value, we need
    to get the maximum value from the remaining items and store it at index 0\. The
    `siftDown` function also operates to check if the left or right child value is
    bigger than the parent node value and we swap the values to store the maximum
    value at parent node. We continue to do this recursively to ensure the maximum
    value is stored in the root at the end of function calls. This `MaxHeap` implementation
    can be used as standalone heap implementation if we want. Since we are planning
    to implement the priority queue using a heap, we are going to add another class
    to extend the `MaxHeap` class to show the characteristics of a Priority Queue.
    Let us explore the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are just extending the `MaxHeap` class and adding a wrapper for `enqueue`
    and `dequeue` operations using the `insert` and `extractMax` at stealth mode.
    Let us now run the `PriorityQ` code with the same numbers we did for `MinHeap`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding code, we are not constructing the heap directly
    from the array. We are using the priority queue class to enqueue each number in
    the queue. Also, the dequeue operation will get the top priority item from the
    queue. If we run this code from the command line, we will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the `MaxHeap` implementation is helping us to
    get the maximum value item on each dequeue operation. This is one of the ways
    of implementing the priority queue. If we want, we can also sort the whole heap
    at one go and then use the sorted array as the priority queue. For that, we can
    implement a sorting function that is known as heap sort. It is one of the most
    efficient and used sorting mechanisms in computer programming. We are now going
    to explore that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using heap sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap sort requires us to build a heap from a given list of elements and then
    continuously checks the heap property so that the whole heap remains sorted all
    the time. Unlike a regular heap where we stop checking the heap property once
    the newly inserted value satisfies the conditions, we continue to do so for the
    next elements during the heap sort implementation. The pseudocode of the heap
    sort looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The pseudocode shows that whenever we are trying to sort a list of elements,
    the start process depends on building the heap. Each time we add an item to the
    heap, we check if that satisfies heap properties through the `heapify` function.
    Once the heap is built, we check the heap properties of all elements. Let us now
    implement the heap sort based on the preceding pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now use the `heapSort` function to sort an array. Since we are passing
    the argument as by reference, we are not returning anything from the function.
    The actual array will be sorted at the end of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, it will have the following output in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to change the sorting to descending order, we just need to change
    the comparison in the `heapify` function. If we consider time and space complexity
    for the `heapSort` algorithm, we will see that heap sort has the best complexity
    for a sorting algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(nlog(n))` |'
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O (nlog(n))` |'
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(nlog(n))` |'
  prefs: []
  type: TYPE_TB
- en: '| Space Complexity (Worst case) | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: Compared to merge sort, heap sort has better space complexity. As a result,
    many developers prefer heap sort for sorting lists of items.
  prefs: []
  type: TYPE_NORMAL
- en: Using SplHeap, SplMaxHeap, and SplMinHeap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we do not want to implement our own Heap implementations, we can use the
    built-in heap classes from the Standard PHP Library - SPL. SPL has three different
    implementations for the heap. One for generic Heap, which is `SplHeap` , for `MaxHeap`
    we have `SplMaxHeap` , and for `MinHeap` we have `SplMinHeap` . It is important
    to know that SPL classes are not considered as very performant while running on
    PHP 7\. So we are not going to explore in details about them here. We will just
    focus on a sample example here so that if we are using any other version than
    PHP 7, we can use those built-in classes. Let us try an example using `SplMaxHeap:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have used max-heap, we are expecting the output to be in descending
    order. Here is the output from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we want to sort it the other way around, we can use `SplMinHeap` for that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about another efficient data structure, named
    heap. When we implement priority queues using a heap, they are considered maximally
    efficient implementations. We have also learned about another efficient sorting
    method named heap sort, which can be achieved through a heap data structure. Here,
    we are going to conclude our discussion regarding data structures for this book.
    In the remaining chapters, we are going to focus on advanced algorithms, built-in
    functions for algorithms, and data structures, along with functional data structures
    at the end. First, we are going to explore the world of dynamic programming in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
