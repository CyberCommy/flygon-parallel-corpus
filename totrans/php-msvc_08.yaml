- en: Chapter 8. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, you have learned how to develop an application
    based on microservices. Now, it is time to learn about the deployment of your
    application, learning the best strategies to automate and roll back your application
    and also, doing back ups and restores if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 5](ch01.html "Chapter 1. What are Microservices?"),
    *Microservice Development*, **Composer** is the most-used dependency management
    tool; it can help us move a project from the development environment to production
    in the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: There are some different opinions about what the best workflow for the deployment
    process is, so let's look at the advantages and disadvantages of every case.
  prefs: []
  type: TYPE_NORMAL
- en: Composer require-dev
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be used on the development environment, Composer provides a section on their
    `composer.json`, called `require-dev`, and when we need to install some libraries
    on our application that do not need to be on production, we have to use it.
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, the command to install a new library using Composer is `composer
    require library-name`, but if we want to install a new library, such as testing
    libraries, debugging libraries, or any others that do not make sense on production,
    we can use `composer require-dev library-name` instead. It will add the library
    to the `require-dev` section and when we deploy the project to production, we
    should use the `--no-dev` parameter when executing `composer install --no-dev`
    or `composer update --no-dev` in order to avoid installing development libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The .gitignore file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `.gitignore` file, it is possible to ignore files or folders that you
    do not want to track. Even though Git is a versioning tool, many developers use
    this in the deployment process. The `.gitignore` file contains a list of files
    and folders that will not be tracked on your repository when they change. This
    is usually used to upload folders that contain images or any other file uploaded
    by users and also, it is used for the vendor folder, the folder that contains
    all the libraries used on the project.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `vendor` folder contains all the libraries used in our application. As previously
    mentioned, there are two different ways of thinking about how to use the `vendor`
    folder.  There are advantages and disadvantages of including Composer in production
    in order to get the `vendor` folder from the repository once the application is
    deployed or when it is downloading the libraries used on development into production.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deployment workflow can be different in every application depending on the
    project needs. For example, if you want to keep the whole project, including the
    `vendor` folder, in the repository or if you prefer to get the libraries from
    Composer once the project is deployed. We will look at a couple of the most common
    workflows in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor folder on repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first deployment workflow has the entire application on the repository.
    This is when we use Composer for the first time in our development environment
    and we push the `vendor` folder to our repository, so all the libraries will be
    kept on the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, on production we will get the entire project from the repository
    without needing to do a Composer update because our libraries were put in production
    with the deployment. So, you do not need Composer in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of including the **`vendor`** folder in the repository are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You know that the same code (including libraries) was working on development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minor risk of breaking updated libraries in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not depend on external services in the deployment process. Sometimes,
    the libraries are not available at a specific moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of including the **`vendor`** folder on the repository are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Your repository has to store libraries already stored on Composer. The space
    needed can be a problem if you need many or large libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are storing code that is not yours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composer in production
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second deployment workflow has two different ways of proceeding, but both
    of them do not need to store the `vendor` folder in the repository; they will
    get the libraries from Composer once the code is deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code is deployed to production, the `composer update` command will
    be executed either **manually** or **automatically** in the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of running Composer in production are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You are saving space in your repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can execute–optimize-autoload in production in order to map the libraries
    added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantages of running Composer in production are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The deployment process will depend on external services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major risk in some situations when updating packages. For example, if a library
    is suddenly modified or corrupted, your application will break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to know that it is possible to have management dependencies
    on the frontend side too, so it is possible to choose if it is better to put it
    on the repository or not. Grunt and Gulp are two of the most used tools in order
    to automatize tasks in your application. Also, if your application based on microservices
    has a frontend part you should use the following tools in order to manage styles and assets.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Grunt** is a tool to automatize tasks on your application. Grunt can help
    you to concat or minify JS and CSS files, optimize images, or even help you with
    unit testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Every task is implemented by a Grunt plugin developed on Javascript. Also, they
    use Node.js, so it makes Grunt a multiplatform tool. You can check all the available
    plugins at  [http://gruntjs.com/plugins](http://gruntjs.com/plugins).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not necessary to learn Node.js, just install Node.js and you will have
    Node Packaged Modules available to install Grunt (and many other packages). Once
    Node.js is installed, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a `package.json` that will be read by the NPM command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `npm install` will install the dependencies contained in the `package.json`
    file. Grunt will be stored in the `node_modules` folder. Once Grunt is installed,
    it is necessary to create a `Gruntfile.js` to define the automated tasks, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three sections to define the automated tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InitConfig**: This refers to tasks that will be executed by Grunt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadNpmTask**: This is used to load the required plugin to make the tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RegisterTask**: This registers the tasks that will run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we decide what plugin to install and define all the necessary tasks, run
    grunt on your terminal to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like Grunt, **Gulp** is also a tool to automatize tasks and it is also developed
    on NodeJS, so it is necessary to install Node.js in order to have NPM available
    to install it. Once we have installed Node.js, we can install Gulp globally by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of installing gulp, and is the recommended option, is locally and
    you can do it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tasks should be included in a `gulpfile.js` located on the root project
    to be automated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very simple. As you can see, the code is `gulp.task`,
    the task name, and then the `function` defined for that task name.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the functions defined, you can run `gulp`.
  prefs: []
  type: TYPE_NORMAL
- en: SASS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS is complex, large, and hard to maintain. Can you imagine maintaining a file
    with thousands and thousands of lines? This is where Sass can be used. This is
    a preprocessor that adds features, such as variables, nesting, mixins, inheritance,
    and others to CSS that makes CSS a real development language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntactically Awesome Stylesheets** (**SASS**) is a metalanguage of CSS.
    It is a script language that is translated to CSS. SassScript is the Sass language
    and it has two different syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Indented syntax:** This uses the indent to separate block codes and the new
    line character to separate rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCSS**: This one is an extension of the CSS syntax, it uses braces for code
    blocks and semicolons to separate lines within a block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indented syntax has `.sass` extensions, and SCSS has `.scss` extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Sass is very simple to run. Once it is installed, just run `sass input.scss
    output.css` on your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Bower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bower** is a dependency management like Composer, but it works for the frontend
    side. It is also based on Node.js, so once Node.js is installed, you can install
    Bower using NPM. Using Bower, it is possible to have all the frontend libraries
    updated, without needing to update them manually. The command to install Bower
    once Node.js is installed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can execute `bower init` in order to create the `bower.json` file
    on your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bower.json` file will remind you of `composer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you can you can see the dependencies added to the project.
    They can be modified in order to have these dependencies installed on your application
    like Composer works. Also, the commands to work with Bower are very similar to
    Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bower install:** This is to install all the dependencies on `bower.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bower update:** This is to update the dependencies contained on `bower.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bower install package-name:** This installs a package on Bower'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, your application will be deployed to production. If your application
    is small and you only use a few containers/servers, everything will be fine, you
    can easily manage all your resources (containers, VMs, servers, and so on) by
    hand in each deployment. However, what happens if you have hundreds of resources
    you need to update on each deployment? In this case, you need some kind of deployment
    mechanism; even if you have a small project and only one container/server, we
    recommend automating your deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of using an automatic deployment process are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to maintain:** Most of the time, the steps needed by the deployment
    can be stored in files so that you can edit them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable:** You can execute the deployment again and again and it will
    follow the same steps each time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less error-prone:** We are humans and, as humans, we make mistakes multitasking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to track:** There are multiple tools you can use to keep a log of everything
    that happens in every commit. These tools can also be used to create groups of
    users who can make deploys. The most common tools you can use are **Jenkins**,
    **Ansible Tower**, and **Atlassian Bamboo**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to release more often:** Having a deployment pipeline in place will
    help you develop and deploy faster because you will not spend time dealing with
    the push of your code to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at some ways to automate your deployments, starting with the simplest
    options and increasing the complexity and features more and more. We will analyze
    the pros and cons of each one so that, at the end of the chapter, you will be
    available to choose the perfect deployment system for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Simple PHP script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most simple way you can automate your deployments--you can add
    a script to your code (in a public location), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, we only do a pull from master if the script is reached
    with the correct key. As you can see, it is very easy and it can be fired by anyone
    who knows the secret key, for example, by a browser. If your code repository allows
    the set up of webhooks, you can use them to fire your script each time a push
    or commit is done in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the pros of this deployment method:'
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to create if the work required is small, for example, a` git pull`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to keep track of changes to the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to be fired by you or any external tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the disadvantages of this deployment method:'
  prefs: []
  type: TYPE_NORMAL
- en: The web server user needs to be able to use the repo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases in complexity when you need to deal with, for example, branches
    or tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not easy to use when you need to deploy to multiple instances, you will need
    external tools like rsync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not very secure. If your key gets found out by a third party, they can deploy
    on your server whatever they want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an ideal world, all your commits to production will be perfect and pristine,
    but you know the truth--at some point in the future, you will need to roll back
    all your changes. If you have this deployment method in place and you want to
    create a rollback strategy, you have to increase the complexity of your PHP script
    so that it can manage tags. Another not-recommended option is, instead of adding
    a rollback to your scripts, you can do, for example, a `git undo` and push all
    the changes again.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible and Ansistrano
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ansible** is an IT automation engine that can be used to automate cloud provisioning,
    manage configurations, deploy applications, or orchestrate services among other
    uses. This engine does not use an agent, so there is no need for additional security
    infrastructure, it was designed to be used through SSH. The main language used
    to describe your automation jobs (also called **playbooks**)is YAML and its syntax
    is similar to English. Due to the fact that all your playbooks are simple text
    files, you can store them easily in your repository. An interesting feature that
    you can find in Ansible is its Galaxy, a hub of add-ons you can use in your playbooks.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible uses the SSH protocol to manage all the hosts, and you only need to
    install this tool on one machine--the machine you will use to manage your fleet
    of hosts. The main requisite for the control machine is Python 2.6 or 2.7 (from
    Ansible 2.2 it has support for Python 3), and you can use any OS except Microsoft
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement on the managed hosts is Python 2.4+, which comes installed
    by default by most of the UNIX-like operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming that you have the correct Python version on your control machine, installing
    Ansible is very easy with the help of the package managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'On RHEL, CentOS and similar linux distributions execute the following command
    to install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ubuntu command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The FreeBSD command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mac OS command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What is Ansistrano?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ansistrano** is an open source project composed with `ansistrano.deploy`
    and `ansistrano.rollback`, two Ansible Galaxy roles used to easily manage your
    deployments. It''s considered to be the Ansible port for Capistrano.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have Ansible available on our machine, it is very easy to install the
    Ansistrano roles with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After the execution of this command, you will be able to use Ansistrano in your
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: How does Ansistrano work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ansistrano deploys your application following the Capistrano flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup phase**: In this phase, Ansistrano creates the folder structure that will
    hold the application releases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code update phase**: In this phase, Ansistrano puts your release in your
    hosts; it can use rsync, Git, or SVN among other methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Symlink phase** (see below): After the new release is deployed, it changes
    the current softlink that points the available release to the new release location.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cleanup phase**: In this phase Ansistrano removes old releases stored in
    your hosts. You can configure the number of releases in your playbooks through
    the `ansistrano_keep_releases` parameter. In following examples you will se how
    this parameter works'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Ansistrano, you can hook custom tasks to be executed before and after each
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example to explain how it works. Imagine that your
    application is deployed to `/var/www/my-application`; the contents of this folder
    will be similar to the following example after your first deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, the current symlink points to the
    first release we have in our host. Your application will always be available in
    the same path, `/var/www/my-application/current`, so you can use this path in
    any place you need, for example, NGINX or PHP-FPM.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your deployments continue, Ansistrano will deal with the deploys for you.
    The next example will show you what your application folder will look like after
    a second deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding example, now we have two releases in our
    hosts and symlink was updated to point to the new version of your code. What happens
    if you do a rollback with Ansistrano? Easy, this tool will remove the latest release
    you have in your hosts and update the symlink. In our example, your application
    folder content will be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid problems, if you try to roll back and Ansistrano can't find a previous
    version to move to, it will do nothing, keeping your hosts without changes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Ansistrano
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's create a small automation system with Ansible and Ansistrano. We
    are assuming that you have a known and persistent infrastructure available where
    you will push your app or microservice. Create a folder in your development environment
    to keep all your deployment scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we previously created three VMs in our local environment with SSH
    enabled. Note that we are not covering the provisioning of those VMs but if you
    want, you can even use Ansible to do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to create is a `hosts` file. In this file, you can
    store and group all your servers/hosts so that you can later use them in the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, we created two groups of hosts-–`production`
    and `staging`. On each one of them, we have a few hosts available; in our case,
    we set up the IP address of our local VM for testing purposes, but you can use
    URIs if you want. One of the advantages of grouping your hosts is the ability
    you have to even create bigger groups; for example, you can create a group formed
    by other groups. For example, we have a `servers` group that wraps all the production
    and staging hosts. If you are wondering what happens if you have a dynamic environment,
    no problem; Ansible has your back and comes with multiple connectors that you
    can use to get your dynamic infrastructure, for example, from AWS or Digital Ocean,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your `hosts` file ready, it is time to create our `deploy.yml`
    file where we will store all the tasks we want to execute in our deployment. Create
    a `deploy.yml` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to Ansistrano, our deployment tasks are very easy to define, as you can
    see from the preceding example. What we did is create a new task that will be
    executed in all the hosts wrapped under the tag servers, and define a few variables
    available for the Ansistrano role. Here, we defined where we will deploy our application
    on each host, the method we will use for the deploy (Git), how many releases we
    will keep in the hosts (5), and the branch we want to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting feature of Ansible is that you can pass variables from the command
    line to your generic deployment process. This is what we do in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a `GIT_BRANCH` variable to define which branch we want to
    deploy; if Ansible can't find this defined variable, it will use master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Are you ready to test what we have done? Open a terminal and go to the location
    where you have stored the deployment tasks. Imagine that you want to deploy the
    latest versions of your code to your production hosts; you can do it with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we are telling Ansible to use our `deploy.yml` playbook
    and we also defined our `GIT_BRANCH` to be master so that this branch will be
    deployed. As we have all our hosts in the hosts file and we only want to make
    the deployment to the `production` hosts, we limited the execution to the desired
    hosts with `--limit` `production`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that you have a new version ready, all your code was committed
    and tagged under the `v1.0.4` tag, and you want to push this release to your staging
    environment. You can do it with a very simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, deploying your application is very easy with Ansible/Ansistrano
    and it is even easier to roll back to a previously deployed release. To manage
    the rollbacks, you only need to create a new playbook. Create a `rollback.yml`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding piece of code, we are using the Ansistrano rollback role to
    move to the previous deployed release. If you only have one release in your hosts,
    Ansible will not undo the changes because it is not possible. Do you remember
    the variable we set up in the `deploy.yml` file, called `ansistrano_keep_releases`?
    This variable is very important to know how many rollbacks you can do in your
    hosts, so adjust it to your needs. To roll back your production servers to the
    previous release, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Ansible is a very powerful tool that you can use for your deployments,
    but it is not used only for deployments; you can even use it for orchestration,
    for example. With a vibrant community and with RedHat supporting the project,
    Ansible is a necessary tool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible has an enterprise version of a web tool that you can use to manage all
    your Ansible playbooks. Even though it needs a paid subscription, if you manage
    less than ten nodes, you can use it for free.
  prefs: []
  type: TYPE_NORMAL
- en: Other deployment tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can imagine, there are multiple and different tools that you can use
    to do your deployments and we cannot cover all of them in this book. We wanted
    to show you a simple one (PHP scripts) and a more complex and powerful one (Ansible),
    but we don''t want you to finish this chapter without knowing the other tools
    that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chef**: This is an interesting open source tool you can use to manage your
    infrastructure as code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Puppet**: This is an open source configuration management tool with a paid
    enterprise version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bamboo**: This is a continuous integration server from Atlassian and, of
    course, you need to pay to use this tool. This is the most complete tool you can
    use combine with the Atlassian catalog of products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeship**: This is a cloud continuous deployment solution that aims to be
    a tool focused on being an end-to-end solution for running tests and deploying
    apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Travis CI**: This is a similar tool to Jenkins used for continuous integration;
    you can also use it to make your deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packer, Nomad, and Terraform**: These are different tools from HashiCorp
    that you can use to write your infrastructure as code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capistrano**: This is a well-known remote server automation and deployment
    tool, which is easy to understand and easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced deployment techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we showed you some ways you can deploy your application.
    Now, it's time to increase the level of complexity with some advanced techniques
    used on big deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration with Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jenkins is the most known continuous integration application; being an open
    source project allows you to create your own pipeline with high flexibility. It
    was built in Java, so this is the main requirement you have if you want to install
    this tool. With Jenkins, everything is easier, even the installation. For example,
    you can spin up a Docker container with the last version with only a few commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download and create a new container with the latest
    Jenkins version, ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea behind Jenkins is the concept of a job. A job is a sequence of
    commands or steps you can execute automatically or by hand. With jobs and the
    use of plugins (available to download from the web UI), you can create your custom
    workflow. For example, you can create a workflow similar to the next one that is
    fired by your repository as soon as a commit/push happens:'
  prefs: []
  type: TYPE_NORMAL
- en: A unit test plugin starts testing your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as it passes, a code sniffer plugin checks your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the previous steps are okay, Jenkins connects through SSH to a remote host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins pulls all the changes in the remote host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding example is an easy one; you can improve and complicate the example
    more, firing an Ansible playbook instead of using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: This application is so versatile that you can use it in any you want. For example,
    you can use it to check the replication status of your Master-Slave database.
    In our opinion, this application is worth a try and you can find examples of any
    kinds of tasks adapted to this software.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/Green deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This deployment technique relies on having a duplicate of your infrastructure
    so that you can have a new version of your application installed in parallel with
    the current version. In front of your application, you have a router or **Load
    Balancer** (LB) that is used to redirect the traffic to the desired version. As
    soon as you have your new version ready, you only need to change your router/LB
    to redirect all the traffic to the new version. Having two sets of releases gives
    you the flexibility and advantage of easy rollbacks and also gives you time to
    ensure that the new version works fine. Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blue/Green deployment](graphics/B06142_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blue/Green deployment on microservices
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding image, the Blue/Green deployment can be done
    at any level of your application. In our example image, you can spot a microservice
    that is getting ready to deploy a new version but has not been released yet, and you
    can see that some microservices released the latest version of their code, keeping
    the previous one for rollback.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is widely used by big tech companies without any kinds of problems;
    the main disadvantage is the increased amount of resources you need to run your
    application--more resources means more money to be spent on your infrastructure.
    If you want to give it a try, the most-used load balancers on this kind of deployments
    are **ELB**, **Fabio**, and **Traefik**, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Canary releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Canary releases** is a similar deployment technique to the Blue/Green one
    with a subtle difference--only a small amount of hosts are upgraded at the same
    time. Once you have a portion of your hosts with the release you want, using a
    cookie, a lb, or a proxy, a fraction of the traffic is redirected to the new version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique allows you to test your changes with a small portion of your
    traffic; if the application behaves as expected, we continue migrating more hosts
    to the new version until all the traffic is redirected to the new version of your
    application. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canary releases](graphics/B06142_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Canary releases with microservices
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding image, there are four instances of some microservices;
    three of them keep the old version of the application and only one has the latest
    version. The LB is used to split the traffic between the different versions, sending
    the majority of the traffic to the **v1.0.0** and only a small portion of the
    traffic to the **v2.0.0**. If everything is fine, the next step will be increasing
    the number of **v2.0.0** instances, reducing the number of **v1.0.0** instances,
    and redirecting more traffic to the new versions.
  prefs: []
  type: TYPE_NORMAL
- en: This deployment technique adds a little bit of complexity to your current infrastructure,
    but allows you to start testing your changes with small portions of users/traffic.
    Another benefit is the reuse of your existing infrastructure; you don't need to
    have duplicated set of hosts to make your deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days, a trend in the tech industry is to use immutable infrastructure.
    When we say immutable infrastructure, we mean that what you have in your development
    environment is later deployed to production without any changes. You can achieve
    this thanks to the containerization technology and some tools, such as Packer.
  prefs: []
  type: TYPE_NORMAL
- en: With Packer, you can create an image of your application and later distribute
    this image through your infrastructure. The main benefit of this technique is
    that you ensure that your production environment will behave like your development.
    Another important aspect is security; imagine that there is a security breach
    in your NGINX container, a new release with the base image update will solve the
    issue and it will be propagated with your application without the need of external
    intervention.
  prefs: []
  type: TYPE_NORMAL
- en: Backup strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any project, the backup is one of the most important ways to avoid losing
    data. In this chapter, we will learn the backup strategies to be used in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: What is backup?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Backup** is the process of saving code or data in a different place to where
    the code or data is usually stored. This process can be done using different strategies,
    but all of them have the same goal--not to lose data in order for it to be accessed
    in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A backup can be done for two reasons. The first one is the loss of data due
    to a hack attack, corrupted data, or any mistakes executing queries on the production
    server. This backup will help restore the lost or corrupted data.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is policy. The law says that it is required to store user
    data for years. Sometimes, this functionality is done by a system, but a backup
    is another way to store this data.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, backups allow us to be calm. We ensure that we are doing things properly
    and in case any disasters happen, we have a solution to fix them fast and without
    (significant) data loss.
  prefs: []
  type: TYPE_NORMAL
- en: What and where we need to back up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are using some repositories, such as Git, in our application, this can
    be our backup place for the files. The assets or any other files uploaded by users
    should be backed up too.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice to see if we are backing up all the necessary files is reviewing
    the `.gitignore` file and ensuring that we have backed up all the files and folders
    included in that folder.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the most important and precious thing to back up is the database. This
    should be backed up more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not store a backup in the same place where the application is working. Try
    to have different locations for the backup copies.
  prefs: []
  type: TYPE_NORMAL
- en: Backup types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The backups can be full, incremental, or differential. We will look at the
    difference between them and how they work. Applications usually combine different
    backup types: a full backup with incremental or differential backups.'
  prefs: []
  type: TYPE_NORMAL
- en: Full backup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full backup is the basic one; it consists of generating a full copy of the
    current application. This option is used by large applications periodically, and
    small applications can use it daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The full application is backed up in a single file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always generates a full copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The time to generate it can be very long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backup will need a lot of disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that it's generally good practice to include date/time in the backup
    file name so you can know when was created only looking to the file name.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental and differential backups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The incremental backup copies the data that has changed since the last backup.
    The `datetime` should be included in this kind of backup in order to be checked by
    the backup tools the next time a new backup is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is faster than a full backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes up less disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The entire application is not stored in a single generated backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another type, called **differential**. This is like the incremental
    backup (copying all the data that has changed since the last backup); it is executed
    the first time and then it will continue copying all the modified data from the
    last full backup.
  prefs: []
  type: TYPE_NORMAL
- en: So, it will generate more data than the incremental one but less than the full
    one after the first time. This type is an intermediate one between full and incremental.
    It needs more space and time than incremental and less than full.
  prefs: []
  type: TYPE_NORMAL
- en: Backup tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to find many backup tools. The most common tool in large projects
    is Bacula. There are other similar ones for small projects like a custom script
    that will be run frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Bacula
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bacula** is a backup management tool. This application manages and automates
    the backup tasks and it is perfect for large applications. This tool is a little
    complex to set up, but once you have it ready, it does not need any other changes
    and it will work without any problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three different parts exist on Bacula, and every single part needs to be installed
    in a different package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Director**: This manages all the backup processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: This is where the backup is stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File**: This is the client machine where we have our application running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our application based on microservices, we will have many files (one for
    each microservice) and optionally, many storage locations (in order to have different
    locations for the backups) and directors.
  prefs: []
  type: TYPE_NORMAL
- en: This tool works with daemons. Each part has its own daemon and each daemon works
    following its own config files. The config files are set up in the installation
    process, and it is only necessary to change some little things, such as the remote
    IP address, certificates, or the plan to automate backups.
  prefs: []
  type: TYPE_NORMAL
- en: The security of Bacula is really amazing--every part (director, storage, and
    file) has its own key and depending on the connection, it is encrypted using it.
    Also, Bacula allows TLS connections for more security.
  prefs: []
  type: TYPE_NORMAL
- en: Bacula allows you to do full, incremental, or differential backups, and they
    can be automated on the director's part.
  prefs: []
  type: TYPE_NORMAL
- en: Percona xtrabackup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**XtraBackup** is an open source tool to do hot database backups on your application
    without blocking the database. This is possibly the most important feature of
    this application.'
  prefs: []
  type: TYPE_NORMAL
- en: This tool allows MySQL databases, such as MariaDB and Percona, to perform streaming
    and compression and do incremental backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast backups and restores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninterrupted transaction processing during the backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves disk space and network bandwidth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic backup verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fastest way to create backups is to use a custom script in production. This
    is a script that when it runs, it creates a backup by doing a `mysqldump` (if
    we are using a MySQL database), compressing the desired files, and putting them
    in the desired location (ideally, remotely on a different machine).
  prefs: []
  type: TYPE_NORMAL
- en: These scripts should be executed by a cronjob that can be set up to run them
    every day or week.
  prefs: []
  type: TYPE_NORMAL
- en: Validating backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of the backup strategies, it is a good practice to have techniques to
    validate the data stored on the backups. If you have backups with errors, it is
    like not having any backups at all.
  prefs: []
  type: TYPE_NORMAL
- en: In order to check that our backups are valid, are not corrupted, and they work
    as expected, it is necessary to frequently do a mock restore to avoid failure
    if we need to restore them in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Be ready for the apocalypse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No one wants to have to restore a backup, but it is necessary to be ready in
    case any of your microservices are broken or corrupted and we have to react fast.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is knowing where the most recent backup of your application is
    in order to restore it as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If the problem is related to the database, we have to put the application under
    maintenance, restore the database backup, check that it works properly, and then,
    make the application live again.
  prefs: []
  type: TYPE_NORMAL
- en: If the problem is related to something like assets or files, it is possible
    to restore without putting the application under maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Keep calm and get your backup.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to deploy your application to production and automate the deployment process.
    Also, you learned what you have to deploy and that you can get it from any dependency
    management, how to do a rollback if necessary, and the different strategies to
    back up your application.
  prefs: []
  type: TYPE_NORMAL
