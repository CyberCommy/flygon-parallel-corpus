- en: Chapter 4. Exploitation and Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered some of the command-line tools that handle
    target enumeration on the network. In this chapter, we're going to look at a collection
    of tools that enable you to perform activities such as reverse engineering and
    backdooring hosts, and we will also cover ways to integrate powerful tools such
    as the Metasploit exploitation framework and bash scripting.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will cover a collection of tools in this chapter that may enable
    you to discover memory corruption, code injection, and general data- or file-handling
    flaws that may be used to instantiate arbitrary code execution vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Every vulnerability discovered everywhere at some point involves reverse engineering.
    When someone figures out how to exploit a given behavior—in a piece of code—it
    means this person has, to some extent, detailed the nuances of the given behavior
    and used this knowledge to take advantage of it. This process is called reverse
    engineering. As reverse engineering has such crucial importance, we will cover
    some of the fundamental tools that play a part in reverse engineering. We will
    specifically focus on the tools packaged with Kali Linux that are purely command-line-driven—hence
    the book's title.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Metasploit command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit is probably the most widely used penetration testing and exploitation
    development framework—the one tool people use the most for testing, finding, and
    developing exploits for vulnerabilities. Over the years, Metasploit is seen as
    support to the security industry's most talented developers and exploit writers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many useful functionalities of the Metasploit Framework is its ability
    to expose the invocation of its modules and tools to the command line. This means
    Metasploit can be used in the feature-rich and powerful problem-solving environment
    of the bash shell. This functionality is known as the **Metasploit command-line
    interface** (**msfcli**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with msfcli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will see how to use the Metasploit command-line interface
    to do basic scanning, exploit some generic vulnerabilities, and integrate some
    useful bash scripting with the Metasploit command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the usage specification for the `msfcli` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous command, `MODULE`, `OPTIONS`, and `MODE` are explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[MODULE]`: This is the Metasploit module to invoke. This could be any of the
    modules you can invoke from the Metasploit console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[OPTIONS]`: This is a space-delimited key-value pair list of options for the
    given module. These options are specific to the module being invoked here. In
    the following paragraphs, we will see how to determine the options for a given
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[MODE]`: This is the invocation mode of the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `MODULE` option would be `exploit/windows/smb/ms08_067_netapi`
    and the `OPTIONS` list is `RHOST=192.168.10.108`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify a bigger list of options for the modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's not important exactly what this exploit does here; we are merely demonstrating
    a basic use of msfcli. Later on, we will demonstrate ways to use msfcli to find
    out more about the exploitation modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using invocation modes with msfcli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Metasploit command-line interface can be invoked in different ways depending
    on the invocation mode you specify. Invocation modes vary in effect, that is,
    from providing you with information about a module, for instance, information
    about who developed it, to modes that provide you with information about how you
    can enable IDS evasion techniques and which payloads can be used to trigger or
    package the associated vulnerability, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with, let''s look at the invocation modes that are designed to
    deliver information about a module. You may not always know which options are
    available for the module you''d like to invoke. In this case, Metasploit has a
    very useful mode you can invoke with the msfcli module. The following command
    is used to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will produce the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using invocation modes with msfcli](img/5107OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The option invocation mode—abbreviated `O` as a command-line argument—displays
    a short summary of only the necessary options, namely the options strictly required
    in order to successfully run the specified module. You may also want to know a
    little bit more about the background of the module, for instance, who developed
    it, which vulnerability it tries to exploit, and which are the operating systems
    it is designed to target. You can find this out by using the Summary invocation
    mode, which is abbreviated as `S`. The following command is used to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will produce the output as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Using invocation modes with msfcli](img/5107OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The mode demonstrated in the preceding screenshot only prints a summary of
    the basic, necessary options. You could also have Metasploit print out the full
    list of options that use the advanced mode using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command produces the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using invocation modes with msfcli](img/5107OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some output from the preceding screenshot has been omitted for the sake of
    brevity. The following could be the other invocation options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AC`: This details the available options for the given module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: This checks the routine for the supplied module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I`: This shows the IDS evasion techniques available for this module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P`: This lists the available payload types for the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T`: This lists the available operating system targets for this module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion about the Metasploit Frameworks command-line interface.
    The next section will cover useful ways to integrate this functionality with bash
    scripting and other command-line utilities in common situations during a penetration
    test or vulnerability assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Bash hacks and msfcli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that msfcli allows us to invoke Metasploit modules straight from the command
    line, we can do some pretty useful things such as integrate the results of an
    Nmap scan with msfcli, or plug in the results of a DNS or Whois lookup directly
    to a msfcli module invocation. The following section will demonstrate a few useful
    bash scripts that do just this.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to check the exploitability of a given vulnerability on a range
    of IPs proliferated from a Whois lookup, you can execute the following bash script
    straight from your command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous commands, `[MODULE]` and `[DOMAIN NAME]` will be the name and
    path of the Metasploit module you want to use—as it is used in the Metasploit
    console—and the domain name you'd like to run the module against, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About long command lines**'
  prefs: []
  type: TYPE_NORMAL
- en: The previous example must be entered in its entirety, in one command line, in
    your bash shell. This means no pressing *Enter* until you've completed entering
    the line as it is shown. The `\` escape character allows you to enter multiple
    lines in your terminal and have it treated as a single command-line invocation.
    This avoids having your output wrap around the screen, which in some instances
    becomes a little unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module you choose needs to support multiple hosts for the check invocation
    mode. A simple practical example is using this with a given domain name to do
    a port scan with one of the Metasploit modules. The following command shows how
    you to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if the organization you are assessing is responsible for a number
    of IP ranges according to the Whois database, you can first enumerate all the
    IP ranges and feed them to msfcli with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to specify the previous command in a single command line, it
    would look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful way in which you can combine msfcli with bash is to plug out
    from an Nmap scan, and based on which ports are found to be open, start fuzzing
    them using some of the Metasploit fuzzing modules. The following command shows
    you how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If specified in a single command line, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you could fuzz the HTTP forms on a page with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example would be fuzzing the SSHv2 servers with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are many more examples that one can demonstrate here. In fact, you can
    write an entire book that comprises just examples that involve msfcli and port
    scanning tools. Not only this, but you could also develop your own Metasploit
    fuzzing and vulnerability scanning modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point behind explaining these examples was to show you a general style
    you can follow, should you want to grab a list of IPs either from Nmap or another
    enumeration tool and feed the results autonomously to msfcli. The following is
    the general pattern we will follow while developing these kinds of bash scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `grep` or awk to isolate the data in the results you're interested in
    integrating with your Metasploit module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterating through a list of the extracted data samples, if applicable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stuffing them to the command line that invokes a given module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are tons of problems you could not only solve but also automate using
    this pattern. It may also help you combine Metasploit modules in ways the framework
    doesn't really cater to by default—unless we include scripting our own modules
    to the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing payloads with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During penetration tests, you may often need to demonstrate that you have unbridled
    control of a host, or you may need to actually interact with them using some form
    of remotely—either from the local network or the wider Internet—accessible command-line
    interface. If you find yourself in a situation that allows you to execute the
    arbitrary code on a host, and you'd like to control it remotely, one of the most
    common ways to take advantage of the situation is to upload a shell that allows
    you to remotely interact with the command shell or prompt. Metasploit has a tool
    dedicated to catering to these situations called msfpayload.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit payload generator (msfpayload) allows you to generate an executable
    package that connects back to the Meterpreter instance that runs in your Metasploit
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About Meterpreter**'
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit's Meterpreter is an interface to a payload that allows its users
    to dynamically inject instructions into a host compromised with the appropriate—Meterpreter-enabled—payload.
    In simpler terms, penetration testers can prepare payloads that call back to a
    Meterpreter instance, which allows them to interact with the host with a variety
    of tools, such as injecting the code to dump password hashes, escalate privileges,
    and even avoid detection.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we will demonstrate how to prepare exploits that grant you
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with, let''s take a look at the payloads available. You can check
    these out by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the previous option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing payloads with Metasploit](img/5107OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each payload has a number of options, as is the style with most Metasploit
    modules. To see the available invocation options for your payload, you should
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing payloads with Metasploit](img/5107OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a number of ways to represent the various payloads based on which
    code format you''d like to use. The following are the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R`: This is for raw, binary format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: This is for the C code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: This is for the Ruby code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This is for the C# code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P`: This is for the Perl code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`J`: This is for JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`: This is for the executable formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: This is for Dynamic Linkable Libraries (DLLs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V`: This is for the VBA code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: This is for War archives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the effect of some of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing payloads with Metasploit](img/5107OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of the options exists to cater to exploitation on different operating system
    and runtime environments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying a payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, we will create a backdoor for an Ubuntu 32-bit machine. Perform
    the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the payload in an executable format. Here, we will use a Meterpreter
    shell and save it in a file called `backdoor`. The following command will achieve
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`LHOST` is the IP address of the machine you as an attacker are using, or rather
    the machine from which you would like to interact with the backdoor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following screenshot for a example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and deploying a payload](img/5107OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploy the backdoor on the target host. This step will obviously depend on your
    access to the mentioned host. For our example, we will simply use `scp` to upload
    it to the home folder of a given user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a Metasploit handler on the attacker machine with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, use the following command to start a Metasploit handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Execute the payload on the target host. For our example, this will simply involve
    starting the payload as shown in the following screenshot:![Creating and deploying
    a payload](img/5107OT_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the following startup on your machine, namely a connect back
    to the Meterpreter handler:![Creating and deploying a payload](img/5107OT_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding screenshot shows directory access to the affected host.
  prefs: []
  type: TYPE_NORMAL
- en: You should keep in mind that msfpayload is used quite prolifically in the security
    industry, both by penetration testers and the guys who write antivirus software.
    What this means is that if you try to deploy one of the run-of-the-mill Metasploit
    payloads on a host that has modern antivirus installed, it likely won't do much
    except trigger a signature in the antivirus's database. To defeat this protection,
    you need to employ the services of an encoder or a polymorphic engine. The two
    mechanisms (encoding and polymorphing) encode and obfuscate the malicious payload
    in your backdoor so that an antivirus is incapable of recognizing it as malicious.
    Refer to the *Further reading* section at the end of this chapter for more details
    on this.
  prefs: []
  type: TYPE_NORMAL
- en: That's about it for the msfpayload command. We can move on to learning the reverse
    engineering tools.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction of this chapter, reverse engineering is a crucial
    aspect of an all-effective security research. One important aspect of reverse
    engineering—of compiled executable files—is disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembly is the process of reversing the effect of code compilation as much
    as possible. Kali Linux offers a few very good tools to orchestrate this process;
    however, when it comes to disassembly on the command line, very few tools come
    close to Objdump.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling with Objdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to use Objdump and some of its various invocation
    options to strip out various sections of information from the **Executable and
    Linkable Format** (**ELF**) binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About the Executable and Linkable Format**'
  prefs: []
  type: TYPE_NORMAL
- en: ELF is the file format that packages executable, shared libraries, object files
    for Linux/Unix systems, and some of the their various derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Using Objdump is pretty straightforward though whether you'd be able to make
    use of it properly or not depends on how well you understand the ELF format; for
    this reason, I've included some very useful references in the *Further reading*
    section of this chapter, which details the format, and I suggest you check them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disassemble a given binary—here we will use the example of the bash shell
    executable binary—with Objdump, you can perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use the actual binary for the bash shell. To grab a copy of
    it, you can execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will grab a copy of the binary for the bash shell—the
    current focus of the book. We're going to pull it through Objdump to find out
    more about how it works and detail areas to look for an explanation on the way
    it executes according to its code. We opt for working on a copy of the bash executable
    binary in case we do anything that corrupts it accidentally—after all Kali runs
    as root by default!
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the following command to run Objdump on the binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What this command does is supply the `–D` option, which tells Objdump to disassemble
    the binary and print it to the screen. You should see the output as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling with Objdump](img/5107OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's all you need to do to get Objdump to disassemble a binary. Though the
    fun doesn't end there, an executable binary has a number of sections, each dedicated
    to detailing a given part of the executable behavior. Objdump has a number of
    options, each dedicated to extracting various kinds of information from the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call up Objdump as we did in the example, you may see this section of
    the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling with Objdump](img/5107OT_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output details the sections available in the given binary; though, if you''d
    like to only look at the code for a given section, you should use the following
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you''d like to dump the code for the `.text` section, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For our current example, it will produce an output similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disassembling with Objdump](img/5107OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a number of options available with Objdump. I've added some useful
    links to the *Further reading* section for those of you who would like to find
    out more.
  prefs: []
  type: TYPE_NORMAL
- en: A note about the reverse engineering assembler code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we've pretty much covered the basics as far as Objdump goes. However, I
    would not be doing you justice if I didn't mention a little something about what
    you need to understand about binaries in order to become a successful reverse
    engineer.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section about Objdump, we learned how to extract information
    about the `.text` segment. The `.text` segment of an ELF contains the executable
    code. This section will naturally contain the information about how the binary
    behaves, which is usually what a reverse engineer is interested in. The executable
    code in an ELF is represented in assembler language, and in order for you to understand
    the information in the `.text` segment, you will need to understand the assembler
    code to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembler code is the language that semantically describes the machine code,
    and machine code is the collection of bits and bytes that literally control your
    CPU and memory—what we call software. So, the assembler code represents the actual
    code that runs your machine, as opposed to C, C++, Java, and others that the code
    was developed in. This is because computers actually don''t possess the computational
    power to understand C, C++, or any other high-level languages we develop and must
    rely on compilers to parse and translate these languages into a more basic, atomic
    language before it can be executed. An assembler language describes a software
    computation strictly in terms of the interactions between the CPU registers and
    memory and vice-versa. This is based on a set of simple operations: addition,
    subtraction, XOR, comparison of values, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Each CPU, or rather architecture, represents these instructions in a format
    unique to it. These formats are called instructions and can be categorized according
    to a base set of attributes. Broadly, they are categorized into either **Reduced
    Instruction Set Computer** (**RISC**) or **Complex Instruction Set Computing**
    (**CISC**). Each RISC and CISC instruction set is then defined according to the
    largest amount of data that can be moved from the memory to a register, which
    is called the register size. I'm sure some of you are familiar with 32-bit or
    x86 and 64-bit or x86-64 machines.
  prefs: []
  type: TYPE_NORMAL
- en: If you have some experience in programming, you will already know that when
    the code is executing, it is almost always doing so in the context of a function.
    This means a lot of the code that is translated into the assembler will describe
    the process of setting up execution inside a function and transferring the execution
    to another function. Each instruction set and architecture has a certain standard
    that defines how this is to be done in terms of the CPU registers and operations
    involved. This standard is referred to as a procedure-calling function. I've included
    some of the procedure-calling standards for ARM, Intel, and MIPS architectures
    in the *Further reading* section, and unless you want to spend weeks reading about
    assembler, which you really don't need to, I suggest checking these references
    out.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, we can move onto dynamic analysis of binaries using GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging binaries for dynamic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools such as Objdump are great for getting a look at the code in an executable
    while it's not executing. However, if you'd like to actually observe an executable
    in execution and find out more about how it processes information as well as how
    its internal data structures are altered by its execution, you will need something
    called a debugger. One such tool is called the **GNU Debugger** (**GDB**). In
    this section, we will cover the basic usage of GDB, and you will also get to know
    some of the tasks it allows us to pull off during a binary's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off with, let''s load up a binary and run it in GDB using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For our current example, this command would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What GDB does here is prepare to attach itself to the binary during its execution—this
    means it places the binary in a special environment that allows it to observe
    detailed information during its execution. It also tries to read the debugging
    information from the supplied file, which is a collection of information that
    helps describe the program more semantically for testing purposes. Unfortunately,
    bash, as in our example, was not complied with the debugging flag set. This means
    there is no semantic metadata about objects such as variable names, source code
    to assembler code mapping, and so on available for GDB to work with, and you are
    left with just the low-level assembler code to work with. However, this is not
    a dead end for a determined reverse engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the binary is loaded up, the first thing we''re going to do is run the
    program inside GDB. Use the following command from within your `gdb` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following pop up on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with GDB](img/5107OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The way GDB and most debugging programs operate, they allow you to specify a
    halt point or rather a breakpoint at a given address in the program's executable
    code. This allows you to stop the program and inspect its data structures for
    information. GDB allows you to do many things with a program once it reaches a
    breakpoint. You can inspect the values of the CPU registers or rather the copy
    of the contents of the CPU registers available for this program during its execution.
    You can also inspect the value of memory, print out local and global variables,
    inspect the stack, and perform tons of other tasks. We're going to cover the bare
    minimum to get you going and show you how to find out more information about the
    things GDB is capable of.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `run` command to pass arguments to the executable you''re
    currently studying. The command would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command would pass the two strings `Hello` and `World` as arguments
    to the current executable. You should also know that the `run` command is fully
    integrated with the bash command-line processer, so you can use the full specification
    of bash hacks, command substitution, redirects, and pipes to pass arguments via
    the `run` command. The following is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will pass an argument containing all lines in the `/etc/passwd`
    file that start with the word `root` as an argument to the current executable.
  prefs: []
  type: TYPE_NORMAL
- en: Setting execution breakpoints and watch points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, moving on, you probably want to set a breakpoint at some point during your
    reverse engineering adventures with GDB, but before we do so, we need to find
    an address to set a breakpoint at.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''re going to use the first address in the main function
    that is executed as soon as this program starts up. Before we do that, we need
    to find out what this address is and you can use the following command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will grab the first address that executes in the function
    called `main`. If you''d like to set breakpoints for arbitrary addresses in the
    `main` function, you need to scratch around in the code a bit. To find out which
    addresses are available in the `main` function, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command tells GDB to disassemble the `main` function of the given
    executable. This is usually where all the code written by the developer and specific
    to the given executable starts off. You should see something similar to the following
    screenshot appear on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the `disass` command, shorthand
    for the disassemble, is being used. It performs the same function as the `disassemble`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows how GDB disassembles the `main` function. What
    we are interested in is the first address of the `main` function. To make things
    simpler, we are going to emulate the behavior of the breakpoint `main` command
    executed in a preceding example. The address you're looking for is the first one
    that is listed; for this example, it will be the address `0x0806dc0`. Addresses
    are listed here in a hexadecimal format. If you're not used to working with hex
    numbers, you should study up on how they work as soon as possible; most reverse
    engineers probably read in hexadecimal more than they read in their native tongues!
  prefs: []
  type: TYPE_NORMAL
- en: 'For interest''s sake, you would probably have guessed that Objdump should give
    you the same information about the address that starts off the `main` function.
    The following screenshot shows what Objdump says about the starting point of main
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Objdump seems to agree with GDB about the `main` function's starting address.
    This is because the `.text` section of an executable is mapped to static and predetermined
    collection addresses; that is, the `.text` section will reliably always appear
    in the addresses detailed in the `.text` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what you''d want to do now is set a breakpoint for this address as a simple
    demonstration of breakpoints. To do this, enter the following command in your
    GDB prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For our example, this command will work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You could also use the shorthand for the breakpoint command, which works as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you could use the following command to specify a specific memory
    address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides setting breakpoints, which interrupt and stop the execution of a binary
    depending on the value of the instruction pointer, you can also interrupt execution
    using watch points. The following command shows how you set a watch point for
    a given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the variable''s address, you could do this the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our current example here, we can set a watch point for the top of the
    stack pointer, namely the value saved in the ESP when `main` starts executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we rerun the executable, the watch point will trigger as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting execution breakpoints and watch points](img/5107OT_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting registers, memory values, and runtime information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve gotten the hang of stopping a binary just where you''d like it
    to stop—that is, at a function or specific line in the code or once a variable
    changes its value according to a given criteria—you may want to start poking around
    at the executable''s data structures and memory contents. Building on the example
    we just discussed, let''s take a look at the register values saved after our first
    breakpoint hit. The following command shows how you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also print the current stacktrace, namely information about which function
    is the caller of the current function and which arguments were passed to it during
    invocation, as well as the caller's caller and that caller's caller ad infinitum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the current stacktrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also look at the actual contents of the stack using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using the Swiss army knife called x, which prints memory values.
    It''s used in the GDB prompt to print values from the memory, local variables,
    and other information storage areas in an executable in various formats. For example,
    x is capable of printing values in decimal, hexadecimal, octal, and binary, as
    well as converting data into instructions so that it can print a list of the executable
    instructions stored at a given memory address. What we did here is give `x` an
    argument of `/5x,` which means:'
  prefs: []
  type: TYPE_NORMAL
- en: Print 5 address values in hexadecimal format—indicated with a 'x'.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For more information about how `x` works, execute the `help x` command in your
    GDB prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyways, the previous command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''d like to estimate the stack size at the current instance in the execution,
    you can execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will print the following to the screen, depending on
    when you perform those commands during the execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting registers, memory values, and runtime information](img/5107OT_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use the `eval` command to build commands based on variable values such
    as this for just about any purpose. Here, we used this command to calculate the
    difference in the addresses saved at the top of stack pointer value saved in the
    ESP register and at the bottom of the stack pointer saved in the EBP register.
    We also divided this value by `4` to calculate the number of addresses needed
    to print just about the entire stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, there is a myriad of other runtime analysis tools and functions.
    For more information on these functions, execute the following command in your
    GDB prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list and describe the info type functions you can execute. To find
    out more about any of GDB''s capabilities, you can use the `help` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the basic usage of GDB. Hopefully, you've learnt enough about
    it to make it a useful tool in reverse engineering and penetration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered using the command-line-based reverse engineering
    and general application-focused exploitation tools available in the Kali Linux
    and also detailed ways to integrate them with some very useful bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, we learned to use the Metasploit command-line interface.
    We also covered the Metasploit Frameworks command-line-based payload generator
    and, as an example, saw how to build backdoors for Linux 32-bit machines. Lastly,
    we looked at the reverse engineering tools Objdump and GDB. We used Objdump to
    detail the sections of an executable and also look up the address of a given function.
    Our example was to look up `main`. With GDB, we covered setting breakpoints, setting
    watch points, and proliferating useful information not only from a binary before
    its execution but also during its execution, by dumping the stack, register values,
    and also keeping track of some memory values as they change.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, all of these tools will come in handy anytime you need to crack open
    an application and find out what it's all about. For more information about the
    tools we covered in this chapter, as well as some of the important support technical
    information, please refer to the links in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About the Metasploit Meterpreter, you can find more information at [http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter](http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Metasploit's Meterpreter, go to [https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf](https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Meterpreter Basics, go to [http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics](http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on MSFCLI can be obtained at [http://www.offensive-security.com/metasploit-unleashed/Msfcli](http://www.offensive-security.com/metasploit-unleashed/Msfcli)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read up the GNU GDB documentation at [http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read up the Executable and Linkable Format at [http://wiki.osdev.org/ELF](http://wiki.osdev.org/ELF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For The ELF Object File Format: Introduction, go to [http://www.linuxjournal.com/article/1059](http://www.linuxjournal.com/article/1059)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read up more on DWARF Debugging Information Format revision 2.2.0, go to
    [http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf](http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on the Objdump command reference, go to [https://sourceware.org/binutils/docs/binutils/objdump.html#objdump](https://sourceware.org/binutils/docs/binutils/objdump.html#objdump)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read up on the Introduction to x64 Assembly by Intel at [https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf](https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, check out Intel Architecture Software Developer's Manual Volume 2 by Intel
    at [https://www.cs.cmu.edu/~410/doc/intel-isr.pdf](https://www.cs.cmu.edu/~410/doc/intel-isr.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM-THUMB Procedure Call Standard can be found at [http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf](http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf%20)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM Procedure Call Standard – ARM can be found at [http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read up further on iOS ABI Function Call Guide, Apple Developers Site,
    at [https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse Engineering for Beginners by Dennis Yurichev can be found at [http://yurichev.com/writings/RE_for_beginners-en.pdf](http://yurichev.com/writings/RE_for_beginners-en.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
