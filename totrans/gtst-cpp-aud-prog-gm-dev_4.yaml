- en: Chapter 4. 3D Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our perception of sound varies depending on where we are located in relation
    to its source, and on several characteristics of the environment. We have already
    discussed that sound is a mechanical wave, which has an origin, and needs to travel
    all the way to our ears before we can hear it. Along the way, those sound waves
    interact with the environment, such as walls, objects, or the air itself, and
    begin to change. Many of the changes provide valuable cues for our brain to determine
    the location of the sound or the nature of the environment. The following is a
    list of some of the most important factors that have an impact on sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance**: The distance between the source of the sound and our ears has
    a significant effect on its intensity, because air and other mediums attenuate
    sound as it passes by.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direction**: Our ears can identify the direction a sound is coming from thanks
    to minor time and intensity variations between the sounds captured by each ear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movement**: The relative speed between the sound source and our ears can
    make it appear to have a different pitch, because of a phenomenon known as the
    *Doppler effect*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Room**: The size and shape of the room we are in can cause multiple echoes
    to accumulate, producing a reverberation effect, where sound seems to persist
    temporarily even after the original sound has stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obstacles**: Obstacles between the sound source and our ears tend to attenuate
    and muffle the sound. This is particularly true in the case of large obstacles
    such as walls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore the basics of 3D audio, which is the field
    of audio programming that tries to take some (or all) of these factors into consideration
    in order to produce a realistic audio simulation. This is one of the areas where
    using an audio engine such as FMOD really pays off, as it would be extremely difficult
    to implement some of these features ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Positional audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first aspect of 3D audio that we are going to work with (and perhaps the
    most important) is positional audio. **Positional audio** deals primarily with
    the location of each object that produces sound (which we will refer to as **audio
    sources**) in relation to or our ears (which we will refer to as the **audio listener**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step required to create a 3D audio simulation is to describe every
    audio source and listener in the environment. Note that there is typically only
    one audio listener in a scene, unless we are creating a multiplayer split-screen
    type of game. The following figure shows an example of a scene with multiple audio
    sources and one audio listener in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Positional audio](img/9099OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For each audio source and listener in the scene, we store information such
    as position, orientation, and velocity. Using this information, the audio engine
    produces a 3D audio simulation by modifying all the sounds in real time in several
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Position**: The volume of a source decreases and becomes muffled (by filtering
    the sound to attenuate some of the higher frequencies) as the distance to the
    listener increases. The formula used to calculate the volume of the sound given
    a distance is usually controllable by selecting a minimum and maximum distance,
    and a roll-off model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orientation**: Depending on the orientation of the listener in relation to
    each source, the audio engine simulates sound direction and position using speaker
    placement (for surround sound systems such as 5.1) or panning (for stereo sound
    systems). Audio sources can also be oriented, usually by defining a sound projection
    cone, with direction and angle information. Sound is then attenuated for listeners
    standing outside the range of the cone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity**: If the audio source is moving in relation to the listener, the
    pitch of the sound changes (increasing as the entities move closer and decreasing
    as the entities move apart) because of the Doppler effect. You can hear this effect
    in the real world, for example, when an ambulance passes next to you with its
    siren turned as soon as the ambulance moves past your location, there is a sudden
    drop in the pitch of the siren.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positional audio in FMOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using positional audio in FMOD is not too different from what we have done so
    far. In fact, we have already used all the classes required for positional audio
    on the previous chapters; the `FMOD::Channel` class already works as an audio
    source, while the `FMOD::System` class controls all the audio listeners in the
    scene. Let us break down the entire process into steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an audio source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first point that we have to remember is to create our sounds using the
    `FMOD_3D` flag; otherwise, the 3D audio engine will not process them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then we simply need to play the sounds as usual, storing a reference to the
    channel handle so that we can modify the 3D properties of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the audio source's position and velocity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we play the sound and get back a channel handle, we can use it to set
    the position and velocity of the audio source with the `set3DAttributes` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will typically set these values once when creating the audio source and update
    them every frame, or every time the game object associated with the audio source
    changes its position or velocity.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the position is defined in meters, and the velocity is defined in
    meters per second (as we would typically see on a physics engine). We can change
    this scale by setting a different `distancefactor` parameter in the `System::set3DSettings`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that simply subtracting an object''s position by its position on the previous
    frame does not yield a velocity in meters per second, as required. If we need
    to use this method, for example, because we do not know the actual velocity of
    the object, we have to multiply this delta by the time elapsed since the previous
    frame first (in seconds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting the audio source's direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, every sound source is omnidirectional which means that the sound
    is emitted equally in every direction. We can give a sound source a direction,
    by defining a projection cone, using the `set3DConeOrientation` and `set3DConeSettings`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `set3DConeOrientation` method takes a vector defining the main direction
    of the sound cone. The `set3DConeSettings` method takes three parameters, containing
    the inner angle, the outer angle, and the outer volume of the sound cone. The
    sound source is at full volume when the listener is within the inner angle, and
    attenuates towards the outer volume as the listener moves outside that angle.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the audio source's range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can control the overall distance where a sound is still audible with the
    `set3DMinMaxDistance` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify the range of the sound as a pair of values: the minimum distance
    and maximum distance. The minimum distance is the point at which the sound starts
    attenuating. If the listener is any closer to the source than the minimum distance,
    the sound will play at full volume. The maximum distance is the point at which
    the sound stops attenuating and its volume remains constant (a volume which is
    not necessarily zero).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way volume varies between the minimum and maximum distance is known as
    the **rolloff model**. By default, FMOD uses a **logarithmic rolloff** that attenuates
    volume as a proportion of the minimum distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By changing the minimum distance, we can control the overall size of the sound
    (for example, we could set a value of 0.1 for the sound of a fly, or a value of
    500 for the sound of an explosion). When using this model, the maximum distance
    should have a large value, in order to give the sound enough distance to attenuate
    to silence. We can make the sound attenuate slower or faster by changing the `rolloffscale`
    parameter in the `System::set3DSettings` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logarithmic model is realistic, but has the disadvantage of making it harder
    to calculate the full range of the sound, that is, the distance to silence. For
    this reason there are other models available that are easier to use, such as the
    `linear` rolloff model, which maps the minimum distance to full volume, the maximum
    distance to silence, and interpolates linearly in between. We can select the `linear`
    rolloff model when creating the sound by adding the `FMOD_3D_LINEARROLLOFF` flag.
    In this model, the system rolloff scale does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setting the audio listener's properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we must set the position, velocity, and orientation of the audio listener,
    using the `set3DListenerAttributes` method of the `system` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to setting up the attributes for an audio source, except
    for the added orientation. The orientation is specified as a pair of normalized,
    perpendicular vectors, pointing in the up and forward directions of the listener
    (which you will typically get from your camera object or from the view transformation
    matrix).
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is an index that identifies the audio listener. By default,
    there is only one audio listener in the scene, so we use the value of `0`. If
    we need more than one audio listener, we can use the `set3DNumListeners` method
    of the `system` object to increase that number.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with a game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to approach this problem, depending on the architecture
    used by the game engine, but in general, the process is to assign an audio source
    to each game object that can emit a sound, and assign an audio listener to the
    camera object. Then, in the update phase of our game loop, every time we change
    the position, velocity, or orientation of a game object or camera, we must follow
    it up with an update to the corresponding audio structures. Finally, at the end
    of the update phase, we update the audio system, which processes all the changes
    made to the sources and listeners and updates the simulation accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Reverb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Positional audio (with its attenuation, speaker placement, and Doppler effect)
    comprises the most fundamental level of 3D audio. Now we will cover some advanced
    techniques that we can use on top of positional audio to provide a more complete
    simulation of how sounds interact with the environment. One of those techniques
    is called **reverberation**, or **reverb**.
  prefs: []
  type: TYPE_NORMAL
- en: Reverb is the capability of sound to persist in a particular space for some
    time after the original sound has stopped. We can think of reverb as a succession
    of echoes with very little time in between them.
  prefs: []
  type: TYPE_NORMAL
- en: Reverb occurs because most audio sources project sound in several directions
    at once. Some of those sound waves reach our ears directly, in the shortest path
    possible. Others, however, head in different directions, and reflect off various
    surfaces, such as walls, before finally reaching our ears. These reflected sound
    waves take longer to reach our ears than the direct sound waves, and become quieter
    with every bounce they make. The combination of all the reflected sound waves
    creates the effect of reverb.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverb](img/9099OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simulating reverb in a game can enhance the realism of a scene because it provides
    strong cues about the size and nature of the environment. For example, an empty
    cathedral with large, reflective walls will usually result in a lot of reverb.
    On the other hand, an outdoor location with no walls will have virtually no reverb.
    We can also infer the size of a room from the duration of the reverb, since sound
    waves have to travel longer in a large room than in a small room.
  prefs: []
  type: TYPE_NORMAL
- en: Reverb in FMOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are already using positional audio in our scene, adding reverb in FMOD
    requires only a few extra lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reverb object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to create an `FMOD::Reverb` object using the `createReverb`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This creates a reverb zone that automatically applies reverb to every sound
    that a listener can hear when standing inside that zone. You can safely create
    more than one reverb zone simultaneously, as FMOD automatically combines their
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable a reverb zone, you can use the `setActive` method. Alternatively,
    if you do not need that zone any more, you can destroy it permanently with the
    `release` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting reverb properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A reverb has many properties to customize its behavior. These properties are
    defined inside the `FMOD_REVERB_PROPERTIES` structure, and can be applied to the
    reverb object using the `setProperties` method. Fortunately, FMOD also provides
    a set of presets that you can use directly, such as `FMOD_PRESET_CONCERTHALL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Setting reverb position and radius
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can specify the position and range of the reverb using the `set3DAttributes`
    method. The range of the reverb is specified with a minimum radius (reverb is
    at full volume within that radius) and a maximum radius (reverb is disabled outside
    that radius).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Setting the default ambient reverb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also set which reverb properties to use when the listener is not inside
    any reverb zone, using the `setReverbAmbientProperties` method of the `system`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Obstruction and occlusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obstacles in the environment, such as large objects, or walls, also alter the
    way we perceive sound. We can often hear a person speaking in an adjacent room,
    but the sound is not as clear as if they were standing next to us. The reason
    for this is that although sound can pass through several types of materials, it
    loses energy and several of its higher frequencies during the process. This results
    in a quieter, muffled sound. There are two techniques used to simulate obstacles
    in 3D audio: **obstruction** and **occlusion**.'
  prefs: []
  type: TYPE_NORMAL
- en: Obstruction occurs when the source and the listener are in the same environment,
    and there is an obstacle in the way, but there is still enough space around the
    obstacle for the sound waves to flow. In this situation, sound waves passing directly
    through the obstacle are attenuated and filtered, but reflected sound waves are
    not affected.
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion occurs when the source and listener are in different environments,
    and all the sound needs to go through an obstacle, such as a wall, before reaching
    the listener. In this situation, both direct and reflected sound waves are attenuated
    and filtered.
  prefs: []
  type: TYPE_NORMAL
- en: The filter applied to the obstructed or occluded sound waves is usually a low
    pass filter, which attenuates the higher frequencies, resulting in a muffled sound.
  prefs: []
  type: TYPE_NORMAL
- en: '![Obstruction and occlusion](img/9099OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Obstruction and occlusion in FMOD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simulate obstruction and occlusion in FMOD using the built-in geometry
    engine. This only works if we already have our audio sources and listeners set
    up. Afterwards, we need to create geometry objects to represent the obstacles
    in our environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to create these objects is to start from a 3D triangle mesh
    representation of our obstacle. Then we create an instance of `FMOD::Geometry`
    with enough space to store all of our triangles and vertices, using the `createGeometry`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, for each triangle in our mesh, we add a new polygon to the geometry object
    using the `addPolygon` method. The first two parameters control the amount of
    obstruction and occlusion to perform. The third parameter decides if the polygon
    should be double sided. The fourth parameter is the number of vertices in the
    polygon, and the fifth parameter is the polygon data itself. The sixth parameter
    returns an index which can be used to perform further operations on the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We should create the polygon using vertices in object space, not in world space.
    Then, in order to position the geometry the world, we can use a combination of
    the `setPosition`, `setRotation`, and `setScale` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides all of the 3D audio simulations described earlier, there is another
    subject that we should cover: DSP effects. A **DSP** effect (which stands for
    **digital signal processing**) is an algorithm that takes sound data as input,
    modifies it in some way, and returns a new set of data as output. Most effects
    either manipulate the amplitudes or frequencies of the sound data, or add multiple
    sounds together (frequently that sound is a delayed and attenuated version of
    itself). The following is a list of some common types of DSP effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalize**: This effect scales the volume of the sound so that the peak
    amplitude is at the maximum volume level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressor**: This effect makes the loud sections of the sound quieter, then
    brings the entire volume up to compensate, reducing the dynamic range of the sound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distortion**: This effect distorts the sound, making it sound harsher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-pass filter**: This effect attenuates all frequencies in the sound above
    a certain range, making the sound muffled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-pass filter**: This effect attenuates all frequencies in the sound below
    a certain range, making the sound thinner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parametric EQ**: This effect provides complex volume control over all different
    ranges of frequencies in the sound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delay**: In this effect the sound plays once, and keeps repeating after a
    certain amount of time, until it runs out of energy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Echo**: In this effect a delay with a duration that is long enough for us
    to perceive as separate sounds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flanger**: This effect doubles the sound with a very small delay between
    each instance, and varies this delay over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chorus**: This effect plays multiple instances of the sound together, with
    small pitch and time variations between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitch shift**: This effect changes the pitch of a sound without altering
    its playback speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise removal**: This effect silences every value below a certain volume
    threshold'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effects in FMOD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will only cover the very basics here. The easiest way to create
    a DSP effect in FMOD is to use the `createDSPByType` method, with one of the available
    DSP types as a parameter (check the FMOD documentation for the complete list of
    types).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns an `FMOD::DSP` object that you can apply to any channel, channel
    group, or the `system` object itself, using the `addDSP` method of the corresponding
    object. You can also add more than one DSP effect to the same object, which chains
    them together automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter allows more control over the DSP connection, but we will
    ignore it for our simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, most DSP effects have a set of parameters that you can control using
    the `setParameter` method (once again, check the documentation for a list of all
    the available parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 1 – time stretching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our first application of DSP effects, here is an example that shows how to
    change the playback speed of a sound without affecting its pitch. To do this,
    we need to combine a regular frequency change, which modifies both the pitch and
    the speed of the sound, with a pitch shift DSP effect, in order to return the
    pitch back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Example 2 – simple radio effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also combine multiple effects to achieve behaviors that are more complicated.
    For example, here is a rudimentary radio effect simulation, which works by applying
    a distortion and a high pass filter to the sound.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The distortion simulates the loss of information that often occurs when transmitting
    analog signals and the high pass filter makes the sound thinner by getting rid
    of the lower frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to simulate sound coming from specific locations
    in the environment, how to simulate reverb from reflected sound waves, how to
    simulate obstruction and occlusion from obstacles, and finally how to apply DSP
    effects to sounds.
  prefs: []
  type: TYPE_NORMAL
