- en: Securing Your Server with a Firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is one of those things that's best done in layers. *Security-in-depth*,
    we call it. So, on any given corporate network, you will find a firewall appliance
    separating the internet from the **demilitarized zone** (**DMZ**), where your
    internet-facing servers are kept. You will also find a firewall appliance between
    the DMZ and the internal LAN, and firewall software installed on each individual
    server and client. We want to make it as tough as possible for intruders to reach
    their final destinations within our networks.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly though, of all the major Linux distros, only the SUSE distros
    and the Red Hat-type distros come with firewalls already set up and enabled. When
    you look at your Ubuntu virtual machine, you'll see that it's wide open, as if
    it were extending a hearty welcome to any would-be intruder.
  prefs: []
  type: TYPE_NORMAL
- en: Since the focus of this book is on hardening our Linux servers, we'll focus
    this chapter on that last level of defense, the firewalls on our servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of iptables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncomplicated Firewall for Ubuntu systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: firewalld for Red Hat systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nftables, a more universal type of firewall system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common misconception is that iptables is the name of the Linux firewall.
    In reality, the name of the Linux firewall is **netfilter** and every Linux distro
    has it built-in. What we know as iptables is just one of several command-line
    utilities that we can use to manage netfilter. It was originally introduced as
    a feature of Linux kernel, version 2.6, so it''s been around for a long time.
    With iptables, you do have a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It's been around long enough that most Linux admins already know how to use
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to use iptables commands in shell scripts to create your own custom
    firewall configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has great flexibility, in that you can use it to set up a simple port filter,
    a router, or a virtual private network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It comes preinstalled on pretty much every Linux distro, although most distros
    don't come with it preconfigured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very well documented, with free of charge, book-length tutorials available
    on the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, as you might know, there are also a few disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6 require their own special implementation of iptables. So, if your
    organization still needs to run IPv4 while in the process of migrating to IPv6,
    you'll have to configure two firewalls on each server, and run a separate daemon
    for each (one for IPv4, the other for IPv6).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to do Mac bridging that requires **ebtables**, which is the third
    component of iptables, with its own unique syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: arptables, the fourth component of iptables, also requires its own daemon and
    syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you add a rule to a running iptables firewall, the entire iptables
    ruleset has to be reloaded, which can have a huge impact on performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until recently, iptables was the default firewall manager on every Linux distro.
    It still is on most distros, but Red Hat Enterprise Linux 7 and all of its offspring
    now use a newer technology called **firewalld**. Ubuntu comes with **Uncomplicated
    Firewall** (**ufw**), an easy-to-use frontend for iptables. An even newer technology
    that we'll explore at the end of the chapter is **nftables**.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we'll only look at the IPv4 component of iptables.
    (The syntax for the IPv6 component would be very similar.)
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage of iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'iptables consists of four tables of rules, each with its own distinct purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter table**: For basic protection of our servers and clients, this is
    the only table that we would normally use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NAT table**: **Network Address Translation** (**NAT**) is used to connect
    the public internet to private networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mangle table**: This is used to alter network packets as they go through
    the firewall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security table**: The security table is only used for systems that have SELinux
    installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we're currently only interested in basic host protection, we'll only look
    at the filter table. Each table consists of chains of rules, and the filter table
    consists of the `INPUT`, `FORWARD`, and `OUTPUT` chains. Since our CentOS 7 machine
    uses Red Hat's firewalld, we'll look at this on our Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: While it's true that Red Hat Enterprise Linux 7 and its offspring do come with
    iptables already installed, it's disabled by default so that we can use firewalld.
    It's not possible to have both iptables and firewalld running at the same time,
    because they're two totally different animals that are completely incompatible.
    So, if you need to run iptables on a Red Hat 7 system, you can do so, but you
    must disable firewalld first.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your organization is still running its network with version 6 of
    either Red Hat or CentOS, then your machines are still running with iptables,
    since firewalld isn't available for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first look at our current configuration with `sudo iptables -L` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And remember, we said that you need a separate component of iptables to deal
    with IPv6\. Here we will use `sudo ip6tables -L` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, you see that there are no rules, and that the machine is wide
    open. Unlike the SUSE and Red Hat folk, the Ubuntu folk expect you to do the work
    of setting up a firewall. We''ll start by creating a rule that will allow the
    passage of incoming packets from servers to which our host has requested a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-A INPUT`: The `-A` places a rule at the end of the specified chain, which
    in this case is the `INPUT` chain. We would have used a `-I` had we wanted to
    place the rule at the beginning of the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m`: This calls in an iptables module. In this case, we''re calling in the
    `conntrack` module for tracking connection states. This module allows iptables
    to determine whether our client has made a connection to another machine, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ctstate`: The `ctstate` or connection state, portion of our rule is looking
    for two things. First, it''s looking for a connection that the client established
    with a server. Then, it looks for the related connection that''s coming back from
    the server, in order to allow it to connect to the client. So, if a user were
    to use a web browser to connect to a website, this rule would allow packets from
    the web server to pass through the firewall to get to the user''s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-j`: This stands for *jump*. Rules jump to a specific target, which in this
    case is `ACCEPT`. (Please don''t ask me who came up with this terminology.) So,
    this rule will accept packets that return from the server with which the client
    has requested a connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our new ruleset looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll next open up port `22` in order to allow us to connect through Secure
    Shell. For now, we don''t want to open any more ports, so we''ll finish this with
    a rule that blocks everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-A INPUT`: As before, we want to place this rule at the end of the INPUT chain
    with a `-A`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p tcp`: The `-p` indicates the protocol that this rule affects. This rule
    affects the TCP protocol, of which Secure Shell is a part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dport ssh`: When an option name consists of more than one letter, we need
    to precede it with two dashes, instead of just one. The `--dport` option specifies
    the destination port on which we want this rule to operate. (Note that we could
    also have listed this portion of the rule as `--dport 22`, since `22` is the number
    of the SSH port.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-j ACCEPT`: Put it all together with `-j ACCEPT`, and we have a rule that
    allows other machines to connect to this one through Secure Shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DROP` rule at the end silently blocks all connections and packets that
    aren't specifically allowed in by our two `ACCEPT` rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are actually two ways in which we could have written that final blocking
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo iptables -A INPUT -j DROP`: It causes the firewall to silently block
    packets, without sending any notification back to the source of those packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo iptables -A INPUT -j REJECT`: It would also cause the firewall to block
    packets, but it would also send a message back to the source about the fact that
    the packets have been blocked. In general, it''s better to use `DROP`, because
    we normally want to make it harder for malicious actors to figure out what our
    firewall configuration is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way, you always want to have this rule at the end of the chain, because
    any `ALLOW` rule that comes after it will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have an almost complete, usable ruleset for our `INPUT` chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s almost complete, because there''s still one little thing that we forgot.
    That is, we need to allow traffic for the loopback interface. That''s okay, because
    it gives us a good chance to see how to insert a rule where we want it, if we
    don''t want it at the end. In this case, we''ll insert the rule at `INPUT 1`,
    which is the first position of the `INPUT` chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at our new ruleset, we''ll see something that''s rather strange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm...
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule and the last rule look the same, except that one is a `DROP`
    and the other is an `ACCEPT`. Let''s look at it again with the `-v` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we see that `lo`, for loopback, shows up under the `in` column of the
    first rule, and `any` shows up under the `in` column of the last rule. This all
    looks great, except that if we were to reboot the machine right now, the rules
    would disappear. The final thing that we need to do is make them permanent. There
    are several ways to do this, but the simplest way to do this on an Ubuntu machine
    is to install the `iptables-persistent` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'During the installation process, you''ll be presented with two screens that
    ask whether you want to save the current set of iptables rules. The first screen
    will be for IPv4 rules, and the second will be for IPv6 rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/052567bc-129d-4fcc-a237-81b925648105.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll now see two new rules files in the `/etc/iptables` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you were to now reboot the machine, you'd see that your iptables rules are
    still there and in effect.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for basic iptables usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll do this lab on your Ubuntu virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Shut down your Ubuntu virtual machine, and create a snapshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll roll back to this snapshot for the lab in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at your iptables rules, or lack thereof, with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the rules that you need for a basic firewall, allowing for Secure Shell
    access but denying everything else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'View the results with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops, it looks like you forgot about that loopback interface. Add a rule for
    it at the top of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'View the results with these two commands. Note the difference between the output
    of each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `iptables-persistent` package, and choose to save the IPv4 and
    IPv6 rules when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Reboot the virtual machine and verify that your rules are still active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, I know you're thinking, "*Wow, that's a lot of hoops to jump through just
    to set up a basic firewall*." And yeah, you're right. So, give me a moment to
    get rid of what I just did with iptables, and I'll show you what the Ubuntu folk
    came up with to make things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the whole scoop on how to do iptables on Ubuntu here: [https://help.ubuntu.com/community/IptablesHowTo](https://help.ubuntu.com/community/IptablesHowTo).
  prefs: []
  type: TYPE_NORMAL
- en: Uncomplicated Firewall for Ubuntu systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Uncomplicated Firewall is already installed on your Ubuntu machine. It still
    uses the iptables service, but it offers a vastly simplified set of commands.
    Perform just one simple command to enable it, and you have a good, preconfigured
    firewall. There's a graphical frontend for use on desktop machines, but since
    we're learning about server security, we'll just cover the command-line utility
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage of ufw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ufw is disabled by default, so you''ll need to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To do this, I logged in to the virtual machine remotely from a terminal of my
    trusty OpenSUSE workstation. It gave me a warning that my Secure Shell connection
    could be disrupted, but that didn't happen. (It could be because of connection
    tracking rules, or it could be that I just got lucky.) I'll leave it up to you
    to do a `sudo iptables -L`, because ufw creates a very large default ruleset that
    would be impossible to display in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a rule that will allow us to remotely connect through Secure
    Shell in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a `sudo iptables -L`, and you''ll see that the new rule shows up in the
    `ufw-user-input` chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `sudo ufw allow 22/tcp` command, we had to specify the TCP
    protocol, because TCP is all that we need for Secure Shell. We can also open a
    port for both TCP and UDP just by not specifying a protocol. For example, if you''re
    setting up a DNS server, you''ll want to have port `53` open for both protocols
    (you''ll see the entries for port `53` listed as `domain` ports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you do `sudo ip6tables -L`, you'll see that a rule for IPv6 also got added
    for both of the two preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for basic ufw usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll do this lab on a clean snapshot of your Ubuntu virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Shut down your Ubuntu virtual machine and restore the snapshot. (You want to
    do this to get rid of all of the iptables stuff that you just did.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''ve restarted the virtual machine, verify that the iptables rules
    are now gone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'View the status of ufw, enable it, and view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Open port `22/tcp` to allow Secure Shell access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, open port `53` for both TCP and UDP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: firewalld for Red Hat systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at iptables, a generic firewall management system that's
    available on all Linux distros, and ufw, which is only available for Ubuntu. For
    our next act, we turn our attention to **firewalld**, which is specific to Red
    Hat Enterprise Linux 7 and all of its offspring.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike ufw for Ubuntu, firewalld isn't just an easy-to-use frontend for iptables.
    Rather, it's an entirely new way of doing your firewall business, and it isn't
    compatible with iptables. Understand, though, that iptables still comes installed
    on the Red Hat 7 family, but it isn't enabled, because you can't have iptables
    and firewalld enabled at the same time. If you have to use older shell scripts
    that leverage iptables, you can disable firewalld and enable iptables.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that iptables and firewalld are incompatible is that iptables stores
    its rules in plain text files in the `/etc/sysconfig` directory, and firewalld
    stores its rules files in `.xml` format files in the `/etc/firewalld` directory
    and in the `/usr/lib/firewalld` directory. Also, iptables doesn't understand the
    concepts of zones and services the way that firewalld does, and the rules themselves
    are of a completely different format. So, even if you could have both iptables
    and firewalld running at the same time, you'd just end up confusing the system
    and breaking the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is, you can run either iptables or firewalld on your Red Hat
    or CentOS machine, but you can't run both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: If you're running Red Hat or CentOS on a desktop machine, you'll see in the
    applications menu that there is a GUI frontend for firewalld. On a text-mode server,
    though, all you have is the firewalld commands. For some reason, the Red Hat folk
    haven't created an ncurses-type program for text-mode servers, the way they did
    for iptables configuration on older versions of Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of firewalld is the fact that it's dynamically managed. That
    means that you can change the firewall configuration without restarting the firewall
    service, and without interrupting any existing connections to your server.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the status of firewalld
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by verifying the status of firewalld. There are two ways to do
    this. We can use the `--state` option of `firewall-cmd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want a more detailed status, we can just check the daemon, the same
    as we would any other daemon on a systemd machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: firewalld zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'firewalld is a rather unique animal, in that it comes with several preconfigured
    zones and services. If you look in the `/usr/lib/firewalld/zones` directory of
    your CentOS machine, you''ll see the zones files, all in `.xml` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each zone file specifies which ports are to be open, and which ones are to be
    blocked for various given scenarios. Zones can also contain rules for ICMP messages,
    forwarded ports, masquerading information, and rich language rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `.xml` file for the public zone, which is set as the default,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `service name` lines, you can see that the only open ports are for Secure
    Shell access and for DHCPv6 discovery. Look at the `home.xml` file, and you''ll
    see that it also opens the ports for Multicast DNS, and the ports that allow this
    machine to access shared directories from either Samba servers or Windows servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `firewall-cmd` utility is what you would use to configure firewalld. You
    can use it to view the list of zone files on your system, without having to `cd`
    into the zone file directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick way to see how each zone is configured is to use the `--list-all-zones`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is only a portion of the output, because the listing for all
    zones is more than we can display here. More likely, you''ll just want to see
    information about one particular zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, the `internal` zone allows the `ssh`, `mdns`, `samba-client`, and `dhcpv6-client`
    services. This would be handy for setting up client machines on your internal
    LAN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any given server or client will have one or more installed network interface
    adapter. Each adapter in a machine can be assigned one, and only one, firewalld
    zone. To see the default zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s great, except that it doesn''t tell you anything about which network
    interface is associated with this zone. To see that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first install Red Hat or CentOS, the firewall will already be active
    with the public zone as the default. Now, let''s say that you''re setting up your
    server in the DMZ, and you want to make sure that its firewall is locked down
    for that. You can change the default zone to the `dmz` zone. Let''s take a look
    at the `dmz.xml` file to see what that does for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the only thing that the DMZ allows through is the Secure Shell. Okay, that''s
    good enough for now, so let''s set the `dmz` zone as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll verify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And we're all good. Except, that is, that an internet-facing server in the DMZ
    probably needs to do more than just allow SSH connections. This is where we'll
    use the firewalld services. But, before we look at that, let's consider one more
    important point.
  prefs: []
  type: TYPE_NORMAL
- en: 'You never want to modify the files in the `/usr/lib/firewalld` directory. Whenever
    you modify the firewalld configuration, you''ll see the modified files show up
    in the `/etc/firewalld` directory. So far, all we''ve modified is the default
    zone. So, we''ll see this in `/etc/firewalld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a `diff` on those two files to see the difference between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, the newer of the two files shows that the `dmz` zone is now the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more information about firewalld zones, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man firewalld.zones`'
  prefs: []
  type: TYPE_NORMAL
- en: firewalld services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each service file contains a list of ports that need to be opened for a particular
    service. Optionally, the service files may contain one or more destination addresses,
    or call in any needed modules, such as for connection tracking. For some services,
    all you need to do is to open just one port. Other services, such as the Samba
    service, require that multiple ports be opened. Either way, it's sometimes handier
    to remember the service name, rather than the port numbers, that goes with each
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The services files are in the `/usr/lib/firewalld/services` directory. You
    can look at the list of them with the `firewall-cmd` command, just as you could
    do with the list of zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dropbox-lansync` service would be very handy for us Dropbox users. Let''s
    see which ports this opens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It looks like Dropbox uses ports `17500` UDP and TCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that we have our web server set up in the DMZ, with the `dmz`
    zone set as its default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw before, the Secure Shell port is the only one that''s open. Let''s
    fix that so that users can actually access our website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the info for the `dmz` zone again, we''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the `http` service is now allowed through. But look what happens
    when we add the `--permanent` option to this `info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Oops! The `http` service isn't here. What's going on?
  prefs: []
  type: TYPE_NORMAL
- en: For pretty much every command-line alteration of either zones or services, you
    need to add the `--permanent` option to make the change persistent across reboots.
    But, without that `--permanent` option, the change takes effect immediately. With
    the `--permanent` option, you'll have to reload the firewall configuration in
    order for the change to take effect. To demo, I'm going to reboot the virtual
    machine to get rid of the `http` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, I''ve rebooted, and the `http` service is now gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, I''ll add two services with just one command, and specify for the
    change to be permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add as many services as you need to with a single command, but you
    have to separate them with commas and enclose the whole list within a pair of
    curly brackets. Let''s look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we decided to make this configuration permanent, it hasn''t yet taken
    effect. But, if we add the `--permanent` option to this `--info-zone` command,
    we''ll see that the configuration files have indeed been changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to make that change take effect by reloading the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Run the `sudo firewall-cmd --info-zone=dmz` command again, and you'll see that
    the new configuration is now in effect.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a service from a zone, just replace `--add-service` with `--remove-service`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we never specified which zone we're working with in any of these service
    commands. That's because if we don't specify a zone, firewalld just assumes that
    we're working with the default zone. If you want to add a service to something
    other than the default zone, just add a `--zone=` option to your commands.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ports to a firewalld zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having the service files is handy, except that not every service that you''ll
    need to run has its own predefined service file. Let''s say that you''ve installed
    Webmin on your server, which requires port `10000/tcp` to be open. A quick `grep`
    operation will show that port `10000` isn''t in any of our predefined services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s just add that port to our default zone, which is still the `dmz`
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this isn''t permanent, because we didn''t include the `--permanent`
    option. Let''s do it again and then reload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add multiple ports at once by enclosing the comma-separated list
    within a pair of curly brackets, just as we did with the services (yeah, I purposely
    left the `--permanent` out):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And of course, you can remove ports from a zone by substituting `--remove-port`
    for `--add-port`.
  prefs: []
  type: TYPE_NORMAL
- en: firewalld rich language rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've looked at so far might be all you'll ever need for general use scenarios,
    but for more granular control, you'll want to know about **rich language rules**.
    (Yes, that really is what they're called.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to iptables rules, rich language rules are a bit less cryptic, and
    are closer to plain English. So, if you''re new to the business of writing firewall
    rules, you might find rich language a bit easier to learn. On the other hand,
    if you''re already used to writing iptables rules, you might find some elements
    of rich language a bit quirky. Let''s look at one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re adding a rich rule. Note that the entire rule is surrounded by a
    pair of single quotes, and the assigned value for each parameter is surrounded
    by a pair of double quotes. With this rule, we''re saying that we''re working
    with IPv4, and that we want to silently block the `http` port from accepting packets
    from the `200.192.0.0/24` network. We didn''t use the `--permanent` option, so
    this rule will disappear when we reboot the machine. Let''s see what our zone
    looks like with this new rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The rich rule shows up at the bottom. After we''ve tested this rule to make
    sure that it does what we need it to do, we''ll make it permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You could just as easily write a rule for IPv6 by replacing `family="ipv4"`
    with `family="ipv6"`, and supplying the appropriate IPv6 address range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some rules are generic, and apply to either IPv4 or IPv6\. Let''s say that
    we want to log messages about **Network Time Protocol** (**NTP**) packets, and
    you want to log no more than one message per minute. The command to create that
    rule would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, of course, a lot more to firewalld rich language rules than we can
    present here. But, you at least now know the basics. For more information, consult
    the `man` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Hands-on lab for firewalld commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this lab, you''ll get some practice with basic firewalld commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log into your CentOS 7 virtual machine and run the following commands. Observe
    the output after each one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Briefly view the `man` pages that deal with firewalld zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: (Yes, there are two of them. One explains the zone configuration files, and
    the other explains the zones themselves.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the configuration information for all of the available zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the list of predefined services. Then, look at information about the
    `dropbox-lansync` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the default zone to `dmz`. Look at information about the zone, add the
    `http` and `https` services, and then look at the zone information again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the firewall configuration, and look at zone info again. Also, look
    at the list of services that are being allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Permanently open port `10000/tcp`, and view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the port that you just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'View the list of main pages for firewalld:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nftables – a more universal type of firewall system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now turn our attention to nftables, the new kid on the block. So, what
    does nftables bring to the table? (Yes, the pun was intended.):'
  prefs: []
  type: TYPE_NORMAL
- en: You can now forget about needing separate daemons and utilities for all of the
    different networking components. The functionality of iptables, ip6tables, ebtables,
    and arptables is now all combined in one neat package. The nft utility is now
    the only firewall utility that you'll need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With nftables, you can create multidimensional trees to display your rulesets.
    This makes troubleshooting vastly easier, because it's now easier to trace a packet
    all the way through all of the rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With iptables, you have the filter, NAT, mangle, and security tables installed
    by default, whether or not you use each one. With nftables, you only create the
    tables that you intend to use, resulting in enhanced performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike iptables, you can specify multiple actions in one rule, instead of having
    to create multiple rules for each action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike iptables, new rules get added atomically. (That's a fancy way of saying
    that there's no longer a need to reload the entire ruleset in order to just add
    one rule.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nftables has its own built-in scripting engine, allowing you to write scripts
    that are more efficient and more human-readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you already have lots of iptables scripts that you still need to use, you
    can install a set of utilities that will help you convert them to nftables format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nftables tables and chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re used to iptables, you might recognize some of the nftables terminology.
    The only problem is, some of the terms are used in different ways, with different
    meanings. Here''s some of what I''m talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tables**: Tables in nftables refer to a particular protocol family. The table
    types are ip, ip6, inet, arp, bridge, and netdev.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chains**: Chains in nftables roughly equate to tables in iptables. For example,
    in nftables you could have filter, route, or NAT chains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with nftables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a clean snapshot of our Ubuntu virtual machine, and install
    the nftables package.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line utility for nftables is `nft`. You can either do `nft` commands
    from the Bash shell, or you can do `sudo nft -i` to run nft in interactive mode.
    For our present demos, we'll just run the commands from the Bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the list of installed tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm... You didn't see any tables, did you? So, let's load some up.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `nftables.conf` file in the `/etc` directory, you''ll see
    the beginnings of a basic nft firewall configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown of what all this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#!/usr/sbin/nft -f`: Although you can create normal Bash shell scripts with
    nftables commands, it''s better to use the built-in scripting engine that''s included
    with nftables. That way, we can make our scripts more human-readable, and we don''t
    have to type `nft` in front of everything we want to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flush ruleset`: We want to start with a clean slate, so we''ll flush out any
    rules that may have already been loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table inet filter`: This creates an inet family filter, which works for both
    IPv4 and IPv6\. The name of this table is `filter`, but it could just as well
    have been something a bit more descriptive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain input`: Within the first pair of curly brackets, we have a chain with
    the name of `input`. (Again, the name could have been something more descriptive.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type filter hook input priority 0;`: Within the next pair of curly brackets,
    we define our chain and then list the rules. This chain is defined as a `filter`
    type. `hook input` indicates that this chain is meant to process incoming packets.
    Because this chain has both a `hook` and a `priority`, it will accept packets
    directly from the network stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the standard rules for a very basic host firewall, starting
    with the `iif` rule that allows the loopback interface to accept packets (**iif**
    stands for **input interface**.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the standard connection tracking (`ct`) rule, which accepts traffic
    that's in response to a connection request from this host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, there's a commented-out rule to accept Secure Shell and both secure and
    nonsecure web traffic. The `ct state new` indicates that the firewall will allow
    other hosts to initiate connections to our server on these ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ipv6` rule accepts neighbor discovery packets, allowing for IPv6 functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `counter drop` rule at the end silently blocks all other traffic, and counts
    both the number of packets and the number of bytes that it blocks. (This is an
    example of how you can have one rule perform two different actions.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If all you need on your Ubuntu server is a basic, no-frills firewall, your
    best bet is to just edit this `/etc/nftables.conf` file to suit your own needs.
    For starters, let''s remove the comment symbol from in front of the `tcp dport`
    line, and get rid of ports `80` and `443`. The line should now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you're only opening one port, you don't need to enclose that
    port number within curly brackets. When opening multiple ports, just include the
    comma-separated list within curly brackets, with a blank space before the first
    element and after the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the configuration file, and view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we want to block certain IP addresses from reaching the
    Secure Shell port of this machine. We can edit the file, placing a `drop` rule
    above the rule that opens port `22`. The relevant section of the file would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: After we reload the file, we'll be blocking SSH access from two different IPv4
    addresses. Note that we've placed the `drop` rule ahead of the `accept` rule,
    because if the `accept` rule gets read first, the `drop` rule will never have
    any effect.
  prefs: []
  type: TYPE_NORMAL
- en: Another really cool thing to note is how we've mixed IPv4 (ip) rules with IPv6
    (ip6) rules in the same configuration file. That's the beauty of using an inet-type
    table. For simplicity and flexibility, you'll want to use inet tables as much
    as possible, rather than separate ip and ip6 tables.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when all you need is just a simple host firewall, your best
    bet would be to just use this `nftables.conf` file as your starting point, and
    edit the file to suit your own needs. However, there's also a command-line component
    that you may at times find useful.
  prefs: []
  type: TYPE_NORMAL
- en: Using nft commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to use the nft utility. You can just do everything directly
    from the Bash shell, prefacing every action you want to perform with nft, followed
    by the `nft` subcommands. You can also use nft in interactive mode. For our present
    purposes, we'll just go with the Bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first delete our previous configuration, and create an inet table, since
    we want something that works for both IPv4 and IPv6\. We''ll want to give it a
    somewhat descriptive name, so let''s call it `ubuntu_filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll add an `input` filter chain to the table that we just created. (Note
    that since we're doing this from the Bash shell, we need to escape the semi-colon
    with a backslash.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this command, the first `input` after the `ubuntu_filter` is the name of
    the chain. (We could have given it a more descriptive name, but for now, `input`
    works.) Within the pair of curly brackets, we're setting the parameters for this
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each nftables protocol family has its own set of hooks, which define how packets
    will be processed. For now, we''re only concerned with the ip/ip6/inet families,
    which have these hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerouting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postrouting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, we're presently only concerned with the input and output hooks, which
    would apply to filter-type chains. By specifying a hook and a priority for our
    input chain, we're saying that we want this chain to be a base chain, which will
    accept packets directly from the network stack. You also see that certain parameters
    must be terminated by a semicolon, which in turn would need to be escaped with
    a backslash if you're running the commands from the Bash shell. Finally, we're
    specifying a default policy of `drop`. If we had not specified `drop` as the default
    policy, then the policy would have been `accept` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Every `nft` command that you enter takes effect immediately. So, if you're doing
    this remotely, you'll drop your Secure Shell connection as soon as you create
    a filter chain with a default `drop` policy.
  prefs: []
  type: TYPE_NORMAL
- en: Some people like to create chains with a default `accept` policy, and then add
    a `drop` rule as the final rule. Other people like to create chains with a default
    `drop` policy, and then leave off the drop rule at the end. The advantage of using
    a default `accept` rule is that you would be able to perform these firewall commands
    remotely, without having to worry about locking yourself out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the chain has been added, and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s great, but we still need some rules. Let''s start with a connection
    tracking rule and a rule to open the Secure Shell port. We''ll then verify that
    they got added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that looks good. You now have a basic, working firewall that allows Secure
    Shell connections. Well, except that just as we did in the ufw chapter, we forgot
    to create a rule to allow the loopback adapter to accept packets. Since we want
    this rule to be at the top of the rules list, we''ll use `insert` instead of `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re all set. But what if we want to insert a rule in a specific location?
    For that, you''ll need to use `list` with the `-a` option to see the `handles`
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s no real rhyme or reason to the way the handles are
    numbered. Let''s say that we want to insert the rule about blocking certain IP
    addresses from accessing the Secure Shell port. We see that the `ssh accept` rule
    is `handle 3`, so we''ll need to insert our `drop` rule before it. Our command
    to do that would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to place the rule before the rule with the `handle 3` label, we have to
    `insert` to `position 3`. The new rule that we just inserted has the label `handle
    6`. To delete a rule, we''ll specify the rule''s handle number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with iptables, everything you do from the command line will
    disappear once you reboot the machine. To make it permanent, let''s redirect the
    output of the `list` subcommand into a configuration file (of course, we''ll want
    to give the file a unique name that''s different from the name of our default
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to a quirk in the Bash shell, we can''t just redirect output to a file
    in the `/etc` directory in the normal manner, even when we use `sudo`. That''s
    why I had to add the `sh -c` command, with the `nft list` command surrounded by
    double quotes. Now, when we look at the file, we''ll see that there are a couple
    of things that are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You sharp-eyed folk will see that we''re missing the `flush` rule, and the
    `shebang` line to specify the shell that we want to interpret this script. Let''s
    add them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better. Let''s test it by loading the new configuration and observing
    the `list` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to creating your own simple host firewall. Of course, running
    commands from the command line, rather than just creating a script file in your
    text editor, does make for a lot more typing.  But, it does allow you to test
    your rules on the fly, as you create them. And, creating your configuration in
    this manner and then redirecting the `list` output to your new configuration file
    relieves you of the burden of having to keep track of all of those curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to take all of the `nft` commands that we just did, and place
    them into a regular, old-fashioned Bash shell script. Trust me, though, you really
    don't want to do that. Just use the nft-native scripting format as we've done
    here, and you'll have a script that performs better, and that is much more human-readable.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab for nftables on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this lab, you need a clean snapshot of your Ubuntu virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore your Ubuntu virtual machine to a clean snapshot to clear out any firewall
    configurations that you created previously. Verify with the commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You should see no rules listed for iptables, and the ufw status should be `inactive`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `nftables` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'List the tables, which should give you no output. Load the default configuration
    file, and list both the tables and the rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a backup copy of the nftables configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the original `/etc/nftables.conf` file in your text editor. Just before
    the `tcp dport . . . accept` line, insert this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the configuration and view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at four different frontends for the netfilter
    firewall. We first looked at our trusty old friend, iptables. We saw that even
    though it's been around forever and still works, it does have some shortcomings.
    We then saw how Ubuntu's Uncomplicated Firewall can vastly simplify setting up
    an iptables-based firewall. For you Red Hatters, we looked at firewalld, which
    is specific to Red Hat-type distros. Finally, we wrapped things up by looking
    at the latest in Linux firewall technology, nftables.
  prefs: []
  type: TYPE_NORMAL
- en: In the space allotted, I've only been able to present the bare essentials that
    you need to set up basic host protection. But, it is at least enough to get you
    started.
  prefs: []
  type: TYPE_NORMAL
