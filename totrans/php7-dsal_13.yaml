- en: Functional Data Structures with PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the demand for functional programming language over object-oriented
    programming has increased. One of the core reasons is that **functional programming**
    (**FP** ) has inherent parallelism. While OOP is used widely, functional programming
    is quite significantly making a mark in recent times. As a result, languages such
    as Erlang, Elixir, Clojure, Scala, and Haskell are the most popular functional
    programming languages for programmers. PHP is not on the list, as PHP is considered
    an imperative and object-oriented language. Though PHP has lots of support for
    functional programming, it is mainly used for OOP and imperative programming.
    The core essence of FP is the lambda calculus, which denotes a formal system in
    mathematical logic and computer science for expressing computation by way of variable
    binding and substitution. It is not a framework or a new concept. In fact, functional
    programming predates all other programming paradigms. It has been there for a
    long time and will be there in the future as well, as the world is demanding for
    more concurrent computation and faster processing languages. In this chapter,
    you will learn about functional programming with PHP and how to implement data
    structures with functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming with PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike any object-oriented programming language where everything is represented
    through an object, functional programming starts thinking everything in terms
    of functions. OOP and FP are not mutually exclusive. While OOP focuses on code
    maintainability and reusability by encapsulation and inheritance, functional programming,
    unlike state-oriented imperative programming, is focused on value-oriented programming,
    which considers computation as a pure mathematical evaluation and avoids mutability
    and state modification. When working with OOP, one of the challenges is that the
    object we have created can bring many extra properties or methods along with it
    whether or not we are using it in a particular case. Here are the three key characteristics
    of functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions and referential transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class citizen functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher order function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition (currying)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of immutability tells us that an object will not change after its
    creation. It will remain the same during its whole life cycle. It has a great
    advantage as we do not need to revalidate the object whenever we use it. Also,
    if it requires being mutable, we can create a copy of the object or create a new
    object with new properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, in this book, we saw lots of examples of data structures and algorithms
    using code blocks, loops, and conditions. In general, this is known as imperative
    programming, where it is expected to define each step of the execution. For example,
    consider the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code actually sets the first character of each name to upper
    case. Logically, the code is correct and we have presented it here step-by-step,
    so that we understand what is going on. However, this can be written as a single
    line using the functional programming approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both of these methods do the same thing, but one is a comparatively smaller
    code block than the other one. The later one is known as declarative programming.
    While imperative programming focuses on algorithms and steps, declarative programming
    focuses on input and output of the function along with recursion (not iteration).
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of functional programming is that it is free of any
    side effects. It is an important feature to have and it ensures that a function
    will not have any implicit effects anywhere on the input. One of the common examples
    of functional programming is sorting an array in PHP. Usually, the argument is
    passed by reference and when we get the sorted array, it actually destroys the
    initial array. This is an example of side effects in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping to functional programming with PHP, let's explore some functional
    programming terms, which we will come across in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: First class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A language with first-class functions allows the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign a function to a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass them to another function as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP supports all of these behaviors and, hence, PHP functions are first-class
    functions. In our previous example, the `ucfirst` function is an example of a
    first-class function.
  prefs: []
  type: TYPE_NORMAL
- en: Higher order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A higher order function can take one or multiple functions as an argument and
    also return a function as a result. PHP also has support for higher order functions;
    `array_map` from our previous example is a higher order function.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pure function is a function where for an input X, the output will be always
    Y under any circumstances. The output will never change for the same input for
    a pure function. So, for pure functions, there are no side effects or dependencies
    on the runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda functions or anonymous functions are functions without a name. They can
    be very handy when used as first-class functions (to assign in a variable) or
    for call back functions where we can define the function in the place of a call
    back parameter. PHP has support for anonymous functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A closure is very much similar to a lambda function, but the basic difference
    is that a closure has access to its outer scope variables. In PHP, we cannot access
    outer scope variables directly. In order to do so, PHP has introduced the keyword
    "use" to pass any outer scope variables to inner functions.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currying is a technique of transforming a function that takes multiple arguments
    to a chain of functions where each function will take exactly one argument. In
    other words, if a function can be written as *f(x,y,z)* , then the currying version
    of this will be *f(x)(y)(z).* let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have written a simple function with three parameters and when called
    with numbers, it will return *sum* of the numbers. Now, if we write this function
    as a curry, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now if we run the `currySum` as a currying function, we will get the result
    60 for the preceding example. This is a very useful feature for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, it was not possible to call a function like *f(a)(b)(c)* in PHP. Since
    PHP 7.0, Uniform Variable Syntax allows immediate execution of a callable, as
    we saw in this example. However, to do this in PHP 5.4 and higher versions, we
    would have to create temporary variables in order to store the lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Partial applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A partial application or partial function application is a technique to reduce
    the number of arguments of a function or to use partial arguments and create another
    function to act on the remaining arguments in order to produce the same output
    as what we would get if it were called with all the arguments at once. If we consider
    our `sum` function to be partial, where it is expected to take three parameters,
    but we can call it with two arguments, and later on add the remaining one. Here
    is the code sample. The `sum` function used in this example is from the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we get confused between currying and partial application even though
    they are completely different in their approaches and principles.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are so many things to consider while dealing with functional
    programming in PHP. It will be a lengthier process to implement data structures
    using functional programming in PHP from scratch. In order to solve this problem,
    we will explore an excellent functional programming library for PHP, called **Tarsana**
    . It is open source and comes with the MIT license. We will explore this library
    and also use it as our base for functional data structure implementation in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Tarsana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tarsana is an open source library written by Amine Ben Hammou and is available
    on GitHub for download. It is inspired from Ramda JS, a functional programming
    library for JavaScript. It does not have any dependencies and has more than 100
    predefined functions to use for different purposes. Functions in FP are spread
    over different modules and there are several modules such as functions, list,
    object, string, math, operators, and common. Tarsana can be downloaded from GitHub
    ( [https://github.com/Tarsana/functional](https://github.com/Tarsana/functional)
    ) or can be installed via composer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the library is downloaded, we have to use it by importing the `Tarsana\Functional`
    namespace, just like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the interesting features of Tarsana is that we can convert any of our
    existing functions to a curried function. For example, if we want to use our `sum`
    function using Tarsana, then it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the output of 7 and 13, respectively. Tarsana also has an
    option to keep place holders using the `__()` function. The following example
    shows the array reduce and array sum of the entries provided in the placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Tarsana also provides a piping functionality, where we can apply a series of
    functions from left to right. The leftmost function may have any arity; the remaining
    functions must be unary. The result of piping is not curried. Let''s consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we have already explored some features of Tarsana, we are ready to start
    our functional data structures using Tarsana. We will also implement those data
    structures using simple PHP functions so that we have both parts covered, if we
    do not want to use functional programming. Let's get started with the implementation
    of stack.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the implementation of stacks in [Chapter 4](text00098.html) ,
    *Constructing Stacks and Queues* . For simplicity, we won''t discuss the whole
    stack operation again. We will jump right into the implementation of push, pop,
    and top operations using functional programming. Tarsana has lots of built-in
    functions for list operations. We will use their built-in functions to implement
    our functional operations of the stack. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the append function of Tarsana for the push operation, the last
    function we used here for the top operation, and the `init` function for the pop
    operation. The output of the following code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can implement a queue using Tarsana and the built-in functions for list
    operations. We will use the array for queue representation as well using this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `append` function to perform enqueue, and the `head` and `tail`
    functions for the first item in the queue and dequeuer, respectively. Here is
    the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will shift our focus to implementing hierarchical data using simple
    PHP functions instead of classes and objects. Since functional programming is
    still a new topic in PHP, implementation of hierarchical data might seem challenging
    and also time consuming. Instead, we will convert our hierarchical data implementation
    using basic PHP functions along with some basic functional programming concept
    such as first-class functions and higher order functions. So, let's implement
    a binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement a binary tree using a PHP array with a simple recursive function-based
    traversal. We are just rewriting the functionality using one function instead
    of a class. Here is the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding code, we have simply modified the traversal function
    and converted it to a standalone function. It is a pure function as we are not
    modifying the actual input here, which is the `$nodes` variable. We will construct
    a string on each level and use that for the output. We can now convert most of
    our class-based structures to function-based ones.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is comparatively new for PHP developers as the support
    for its prerequisites was added as of version 5.4\. The emergence of functional
    programming will require us to understand the paradigm and write pure functions
    that are free of any side effects when required. PHP has some good support for
    writing functional programming code and, with that, we can also write functional
    data structures and algorithm implementations as we have tried to show in this
    book. In the near future, it might come in handy for optimizing and improving
    our application's efficiency.
  prefs: []
  type: TYPE_NORMAL
