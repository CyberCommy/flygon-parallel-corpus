- en: Posters, Headshots, and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Movies are a visual medium, so a database of movies should, at the very least,
    have images. Letting users upload files can have big security implications; so,
    in this chapter, we'll discuss both topics together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a file upload functionality that lets users upload images for each movie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the **Open Web Application Security Project** (**OWASP**) top 10 list
    of risks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll examine the security implications of the file upload as we go. Also, we'll
    take a look at where Django can help us and where we have to make careful design
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding file upload to MyMDB.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files to our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a model that will represent and manage the files
    that our users upload to our site; then, we'll build a form and view to validate
    and process those uploads.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring file upload settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin implementing file upload, we will need to understand that file
    upload depends on a number of settings that must be different in production and
    development. These settings affect how files are stored and served.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django has two sets of settings for files: `STATIC_*` and `MEDIA_*`. **Static
    files** are files that are part of our project, developed by us (for example,
    CSS and JavaScript). **Media files** are files that users upload to our system.
    Media files should not be trusted and certainly *never* executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set two new settings in our `django/conf/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`MEDIA_URL` is the URL that will serve the uploaded files. In development,
    the value doesn''t matter very much, as long as it doesn''t conflict with the
    URL of one of our views. In production, uploaded files should be served from a
    different domain (not a subdomain) than the one that serves our app. A user''s
    browser that gets tricked into executing a file it requested from the same domain
    (or a subdomain) as our app will trust that file with the cookies (including the
    session ID) for our user. This default policy of all browsers is called the **Same
    Origin Policy**. We''ll discuss this again in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MEDIA_ROOT` is the path to the directory where Django should save the code.
    We want to make sure that this directory is not under our code directory so that
    it won''t be accidentally checked in to version control or accidentally granted
    any generous permissions (for example, execution permission) that we grant our
    code base.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other settings we will want to configure in production, such as limiting
    the request body, but those will be done as part of deployment in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create that `media_root` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Great! Next, let's create our `MovieImage` model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MovieImage model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `MovieImage` model will use a new field called `ImageField` to save the
    file and to *attempt* to validate that a file is an image. Although `ImageField`
    does try to validate the field, it is not enough to stop a malicious user who
    crafts an intentionally malicious file (but will help a user who accidentally
    clicked on a `.zip` instead of a `.png`). Django uses the `Pillow` library to
    do this validation; so, let''s add `Pillow` to our requirements file `requirements.dev.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install our dependencies with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ImageField` is a specialized version of `FileField` that uses `Pillow` to
    confirm that a file is an image. `ImageField` and `FileField` work with Django''s
    file storage API, which provides a way to store and retrieve files, as well as
    read and write them. By default, Django ships with `FileSystemStorage`, which
    implements the storage API to store data on the local filesystem. This is sufficient
    for development, but we''ll look at alternatives in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*.'
  prefs: []
  type: TYPE_NORMAL
- en: We used the `upload_to` parameter of `ImageField` to specify a function to generate
    the uploaded file's name. We don't want users to be able to specify the name of
    files in our system, as they may choose names that abuse our users' trust and
    make us look bad. We use a function that will store all the images for a given
    movie in the same directory and use `uuid4` to generate a universally unique name
    for each file (this also avoids name collisions and dealing with files overwriting
    each other).
  prefs: []
  type: TYPE_NORMAL
- en: We also record who uploaded the file so that if we find a bad file, we have
    a clue for how to find other bad files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now make a migration and apply it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's build a form for our `MovieImage` model and use it in our `MovieDetail`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using the MovieImageForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our form will be much like our `VoteForm` in that it will hide and disable
    the `movie` and `user` fields that are necessary for our model but dangerous to
    trust from the client. Let''s add it to `django/core/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We don't override the `image` field with a custom field or widget because the
    `ModelForm` class will automatically provide the correct `<input type="file">`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use it in the `MovieDetail` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, our code is simpler because users can *only* upload new images, no
    other operations are supported, letting us always provide an empty form. However,
    with this approach, we still don't show error messages. Losing error messages
    should not be viewed as best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll update our template to use our new form and uploaded images.
  prefs: []
  type: TYPE_NORMAL
- en: Updating movie_detail.html to show and upload images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll have to make two updates to our `movie_detail.html` template. First, we
    will need to update our `main` template `block` to have a list of images. Second,
    we'll have to update our `sidebar` template `block` to contain our upload form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `main` block first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We used the `image` field's `url` property in the preceding code, which returns
    the `MEDIA_URL` setting joined with the calculated filename so that our `img`
    tag correctly displays the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `sidebar` `block`, we''ll add our form to upload a new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to our preceding form. However, we *must* remember to include
    the `enctype` property in our `form` tag for the uploaded file to be attached
    to the request properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're done with our template, we can create our `MovieImageUpload`
    view to save our uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the MovieImageUpload view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our penultimate step will be to add a view to process the uploaded file to
    `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our view once again delegates all the work of validating and saving the model
    to `CreateView` and our form. We retrieve the `user.id` attribute from the request's
    `user` property (certain that the user is logged in because of the `LoginRequiredMixin`
    class) and the movie ID from the URL, then pass them to the form as initial arguments
    since the `user` and `movie` fields of `MovieImageForm` are disabled (so they
    ignore the values from the request body). The work of saving and renaming the
    file is all done by Django's `ImageField`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can update our project to route requests to our `MovieImageUpload`
    view and serve our uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to views and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll update `URLConf` of `core` to route requests to our new
    `MovieImageUpload` view and look at how we can serve our uploaded images in development.
    We'll take a look at how to serve the uploaded images in production [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml),
    *Deploying with Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To route requests to our `MovieImageUpload` view, we''ll update `django/core/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We add our `path()` function as usual, and ensure that we remember that it expects
    a parameter called `movie_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Django will know how to route to our view, but it doesn't know how to serve
    the uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve the uploaded files in development, we''ll update `django/config/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Django offers the `static()` function, which will return a list with a single
    `path` object that will route any request beginning with the string `MEDIA_URL`
    to a file inside `document_root`. It will give us a way of serving our uploaded
    image files in development. This feature is not appropriate for production, and
    `static()` will return an empty list if `settings.DEBUG` is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen much of Django core functionality, let's discuss how it
    relates to the **Open Web Application Security Project** (**OWASP**) list of the
    top 10 most critical security risks (OWASP Top 10).
  prefs: []
  type: TYPE_NORMAL
- en: OWASP Top 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OWASP is a not for profit charitable organization focused on making *security
    visible* by providing impartial practical security advice for web applications.
    All of OWASP's materials are free and open source. Since 2010, OWASP solicits
    data from information security professionals and uses it to develop a list of
    the top 10 most critical security risks in web application security (the OWASP
    Top 10). Although this list does not claim to enumerate all problems (it's just
    the top 10), it is based on what security professionals are seeing out in the
    wild while doing penetration tests and code audits on real code either in production
    or development at companies around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Django is developed to minimize and avoid these risks as much as possible and,
    where possible, to give developers the tools to minimize the risks themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Let's enumerate the OWASP Top 10 from 2013 (the latest version at the time of
    writing, the 2017 RC1 having been rejected) and take a look at how Django helps
    us mitigate each risk.
  prefs: []
  type: TYPE_NORMAL
- en: A1 injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been the number one issue since the creation of the OWASP Top 10\.
    **Injection** means users being able to inject code that is executed by our system
    or a system we use. For example, SQL Injection vulnerabilities let an exploiter
    execute arbitrary SQL code in our database, which can lead to them circumventing
    almost all the controls and security measures we have (for example, letting them
    authenticate as an administrative user; SQL Injection exploits may lead to shell
    access). The best solution for this, particularly for SQL Injection, is to use
    parametrized queries.
  prefs: []
  type: TYPE_NORMAL
- en: Django protects us from SQL Injection by providing us with the `QuerySet` class.
    `QuerySet` ensures that all queries it sends are parameterized so that the database
    is able to distinguish between our SQL code and the values in the queries. Using
    parametrized queries will prevent SQL Injection.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django does permit raw SQL queries using `QuerySet.raw()` and `QuerySet.extra()`.
    Both these methods support parameterized queries, but it is up to the developer
    to ensure that they **never** put values from a user into a SQL query using string
    formatting (for example, `str.format`) but **always** use parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A2 Broken Authentication and Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Broken Authentication** and **Session Management** refer to the risk of an
    attacker being able to either authenticate as another user or take over another
    user''s session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django protects us here in a few ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Django's `auth` app always hashes and salts passwords so that even if the database
    is compromised, user passwords cannot be reasonably cracked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django supports multiple *slow* hashing algorithms (for example, Argon2 and
    Bcrypt), which make brute-force attacks impractical. These algorithms are not
    provided out of the box (Django uses `PBDKDF2` by default) because they rely on
    third-party libraries but can be configured using the `PASSWORD_HASHERS` setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django session ID is never made available in the URL by default, and the
    session ID changes after login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, Django's cryptographic functionality is always seeded with the `settings.SECRET_KEY` string.
    Checking production value of `SECRET_KEY` into version control should be considered
    a security problem. The value should never be shared in plain text, as we’ll discuss
    [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying with Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: A3 Cross Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross Site Scripting** (**XSS**) is when an attacker is able to get a web
    app to display HTML or JavaScript created by the attacker rather than the one
    created by the developer(s). This attack is very powerful because if the attacker
    can execute arbitrary JavaScript, then they can send requests, which look indistinguishable
    from genuine requests from the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Django protects all variables in templates with HTML encoding by default.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django does provide utilities to mark text as safe, which will result
    in values not being encoded. These should be used sparingly and with a full appreciation
    for the dire security consequences if they are abused.
  prefs: []
  type: TYPE_NORMAL
- en: A4 insecure direct object references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Insecure direct object references** are when we insecurely expose implementation
    details in our resource references without protecting the resources from illicit
    access/exploitation. For example, the paths in the `src` attribute of our movie
    detail page''s `<img>` tag map directly to files in the filesystem. If a user
    manipulates a URL, they could access images to which they should not have access
    to, thus exploiting a vulnerability. Or, using auto incrementing primary keys
    that are exposed to the user in a URL can let malicious users iterate through
    all the items in the database. The impact of this risk is highly dependent on
    the resources exposed.'
  prefs: []
  type: TYPE_NORMAL
- en: Django helps us by not coupling routing paths to views. We can do model lookups
    based on primary keys, but we are not required to do so and may add extra fields
    to our models (for example, `UUIDField`) to decouple table primary keys from IDs
    used in URLs. In our Mail Ape project in Part 3, we'll see how we can use the
    `UUIDField` class as the primary key of a model.
  prefs: []
  type: TYPE_NORMAL
- en: A5 Security misconfiguration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security misconfiguration** refers to the risk incurred when the proper security
    mechanisms are deployed inappropriately. This risk is at the border of development
    and operations and requires the two teams to cooperate. For example, if we run
    our Django app in production with the `DEBUG` setting set to `True`, we would
    risk exposing far too much information to the public without having any errors
    in our code base.'
  prefs: []
  type: TYPE_NORMAL
- en: Django helps us with sane defaults and technical and topic guides on the Django
    project website. The Django community is also helpful—they post on mailing lists
    and online blogs, though online blog posts should be treated skeptically until
    you validate their claims.
  prefs: []
  type: TYPE_NORMAL
- en: A6 Sensitive data exposure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sensitive data exposure** is the risk that sensitive data may be accessed
    without the proper authorization. This risk is broader than just an attacker highjacking
    a user''s session, as it includes questions of how backups are stored, how encryption
    keys are rotated, and, most importantly, which data is actually considered *sensitive*.
    The answers to these questions are project/business specific.'
  prefs: []
  type: TYPE_NORMAL
- en: Django can help reduce risks of inadvertent exposure from attackers using network
    sniffing by being configured to serve pages only over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django doesn't provide encryption directly nor does it manage key rotation,
    logs, backups, and the database itself. There are many factors that affect this
    risk, which are outside of Django's scope.
  prefs: []
  type: TYPE_NORMAL
- en: A7 Missing function level access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While A6 referred to data being exposed, missing function level access control
    refers to functionality being inadequately protected. Consider our `UpdateVote`
    view—if we had forgotten the `LoginRequiredMixin` class, then anyone could send
    an HTTP request and change our users' votes.
  prefs: []
  type: TYPE_NORMAL
- en: Django's `auth` app provides a lot of useful features to mitigate these issues,
    including a permission system that is outside the scope of this project and mixins
    and utilities to make using these permissions simple (for example, `LoginRequiredMixin` and `PermissionRequiredMixin`).
  prefs: []
  type: TYPE_NORMAL
- en: However, it is up to us to use Django's tools appropriately to the job at hand.
  prefs: []
  type: TYPE_NORMAL
- en: A8 Cross Site Request Forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CSRF** (pronounced *see surf*) is the most technically complex risk in the
    OWASP Top 10\. CSRF relies on the fact that it will automatically send all the
    cookies associated with the domain whenever a browser requests any resource from
    a server. A malicious attacker may trick one of our logged in users to view a
    page on a third-party site (for example, `malicious.example.org`) with, for example,
    an `img` tag with a `src` attribute that points to a URL from our site (for example,
    `mymdb.example.com`). When the user''s browser sees that `src`, it will make a
    `GET` request to that URL and send all the cookies (including session ID) associated
    with our site.'
  prefs: []
  type: TYPE_NORMAL
- en: The risk is that if our web app receives a `GET` request, it will make a modification
    that the user didn't intend. The mitigation for this risk is to make sure that
    any operation that makes a modification (for example, `UpdateVote`) has a unique
    and unpredictable value (a CSRF token) that only our system knows, which confirms
    that the user is intentionally using our app to perform this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Django helps us a lot to mitigate this risk. Django provides the `csrf_token`
    tag to make it easy to add a CSRF token to a form. Django takes care of adding
    a matching cookie (to validate against the token) and that any request with a
    verb that is not a `GET`, `HEAD`, `OPTIONS`, or `TRACE` has a valid CSRF token
    to be processed. Django further helps us do the right thing by having all its
    generic editing views ( `EditView`, `CreateView`, `DeleteView`, and `FormView`)
    perform only a modification operation on `POST` and never on `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django can't save us from ourselves. If we decide to disable this functionality
    or write views that have side effects on `GET`, Django can't help us.
  prefs: []
  type: TYPE_NORMAL
- en: A9 Using components with known vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A chain is only as strong as its weakest link, and, sometimes, projects can
    have vulnerabilities in the frameworks and libraries they rely on.
  prefs: []
  type: TYPE_NORMAL
- en: The Django project has a security team that accepts confidential reports of
    security issues and has a security disclosure policy to keep the community aware
    of issues affecting their projects. Generally, a Django release receives support
    (including security updates) for 16 months from its first release, but **Long-Term
    Support** (**LTS**) releases receive support for 3 years (the next LTS release
    will be Django 2.2).
  prefs: []
  type: TYPE_NORMAL
- en: However, Django doesn't automatically update itself and doesn't force us to
    run the latest version. Each deployment must manage this for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: A10 Unvalidated redirects and forwards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If our site can be used to redirect/forward a user to a third-party site automatically,
    then our site is at risk of having its reputation used to trick users into being
    forwarded to malicious sites.
  prefs: []
  type: TYPE_NORMAL
- en: Django protects us by making sure that the `next` parameter of `LoginView` will
    only forward user's URLs that are part of our project.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django can't protect us from ourselves. We have to make sure that we
    never use use-provided and unvalidated data as the basis of an HTTP redirect or
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we've updated our app to let users upload images related to
    movies and reviewed the OWASP Top 10\. We covered how Django protects us and also
    where we need to protect ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll build a list of the top 10 movies and take a look at how to use
    caching to avoid scanning our entire database each time.
  prefs: []
  type: TYPE_NORMAL
