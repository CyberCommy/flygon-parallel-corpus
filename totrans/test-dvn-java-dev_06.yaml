- en: Mocking – Removing External Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Talk is cheap. Show me the code."'
  prefs: []
  type: TYPE_NORMAL
- en: – Linus Torvalds
  prefs: []
  type: TYPE_NORMAL
- en: TDD is about speed. We want to quickly demonstrate whether an idea, concept,
    or implementation is valid or not. Further on, we want to run all tests quickly.
    A major bottleneck to this speed is external dependencies. Setting up the DB data
    required by tests can be time-consuming. The execution of tests that verify code
    that uses third-party APIs can be slow. Most importantly, writing tests that satisfy
    all external dependencies can become too complicated to be worthwhile. Mocking
    both external and internal dependencies helps us solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: We'll build on what we did in [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml),
    *Red-Green-Refactor – From Failure Through Success until Perfection*. We'll extend
    Tic-Tac-Toe to use MongoDB as data storage. None of our unit tests will actually
    use MongoDB since all communications will be mocked. At the end, we'll create
    an integration test that will verify that our code and MongoDB are indeed integrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tic-Tac-Toe v2 requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Tic-Tac-Toe v2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone who has done any of the applications more complicated than *Hello World*
    knows that Java code is full of dependencies. There can be classes and methods
    written by other members of the team, third-party libraries, or external systems
    that we communicate with. Even libraries found inside JDK are dependencies. We
    might have a business layer that communicates with the data access layer which,
    in turn, uses database drivers to fetch data. When working with unit tests, we
    take dependencies even further and often consider all public and protected methods
    (even those inside the class we are working on) as dependencies that should be
    isolated.
  prefs: []
  type: TYPE_NORMAL
- en: When doing TDD on the unit tests level, creating specifications that contemplate
    all those dependencies can be so complex that the tests themselves would become
    bottlenecks. Their development time can increase so much that the benefits gained
    with TDD quickly become overshadowed by the ever-increasing cost. More importantly,
    those same dependencies tend to create such complex tests that they contain more
    bugs than the implementation itself.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of unit testing (especially when tied to TDD) is to write specifications
    that validate whether the code of a single unit works regardless of dependencies.
    When dependencies are internal, they are already tested, and we know that they
    do what we expect them to do. On the other hand, external dependencies require
    trust. We must believe that they work correctly. Even if we don't, the task of
    performing deep testing of, let's say, the JDK `java.nio` classes is too big for
    most of us. Besides, those potential problems will surface when we run functional
    and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: While focused on units, we must try to remove all dependencies that a unit may
    use. Removal of those dependencies is accomplished through a combination of design
    and mocking.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using mocks include reduced code dependency and faster text
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks are prerequisites for the fast execution of tests and the ability to concentrate
    on a single unit of functionality. By mocking dependencies external to the method
    that is being tested, the developer is able to focus on the task at hand without
    spending time setting them up. In a case of bigger or multiple teams working together,
    those dependencies may not even be developed. Also, the execution of tests without
    mocks tends to be slow. Good candidates for mocks are databases, other products,
    services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go deeper into mocks, let us go through reasons why one would employ
    them in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Why mocks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list represents some of the reasons why we employ mock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The object generates nondeterministic results. For example, `java.util.Date()`
    provides a different result every time we instantiate it. We cannot test that
    its result is as expected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The object does not yet exist. For example, we might create an interface and
    test against it. The object that implements that interface might not have been
    written at the time we test code that uses that interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object is slow and requires time to process. The most common example would
    be databases. We might have a code that retrieves all records and generates a
    report. This operation can last minutes, hours, or, in some cases, even days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding reasons in the support of mock objects apply to any type of testing.
    However, in the case of unit tests and, especially, in the context of TDD, there
    is one more reason, perhaps more important than others. Mocking allows us to isolate
    all dependencies used by the method we are currently working on. This empowers
    us to concentrate on a single unit and ignore the inner workings of the code that
    the unit invokes.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Terminology** can be a bit confusing, especially since different people use
    different names for the same thing. To make things even more complicated, mocking
    frameworks tend not to be consistent when naming their methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, let us briefly go through terminology.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test doubles** is a generic name for all of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Dummy object's purpose is to act as a substitute for a real method argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test stub can be used to replace a real object with a test-specific object that
    feeds the desired indirect inputs into the system under test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Spy** captures the indirect output calls made to another component by
    the **System Under Test** (**SUT**) for later verification by the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock object replaces an object the SUT depends on, with a test-specific object
    that verifies that it is being used correctly by the SUT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake object replaces a component that the SUT depends on with a much lighter-weight
    implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are confused, it may help you to know that you are not the only one.
    Things are even more complicated than this, since there is no clear agreement,
    nor a naming standard, between frameworks or authors. Terminology is confusing
    and inconsistent, and the terms mentioned earlier are by no means accepted by
    everyone.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify things, throughout this book we'll use the same naming used by Mockito
    (our framework of choice). This way, methods that you'll be using will correspond
    with the terminology that you'll be reading further on. We'll continue using mocking
    as a general term for what others might call **test doubles**. Furthermore, we'll
    use a mock or spy term to refer to `Mockito` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock objects simulate the behavior of real (often complex) objects. They allow
    us to create an object that will replace the real one used in the implementation
    code. A mocked object will expect a defined method with defined arguments to return
    the expected result. It knows in advance what is supposed to happen and how we
    expect it to react.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at one simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we defined `collection` to be a `mock` of `TicTacToeCollection`. At this
    moment, all methods from this mocked object are fake and, in the case of Mockito,
    return default values. This is confirmed in the second line, where we `assert`
    that the `drop` method returns `false`. Further on, we specify that our mocked
    object collection should return `true` when the `drop` method is invoked. Finally,
    we `assert` that the `drop` method returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: We created a mock object that returns default values and, for one of its methods,
    defined what should be the return value. At no point was a real object used.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we'll work with spies that have this logic inverted; an object uses
    real methods unless specified otherwise. We'll see and learn more about mocking
    soon when we start extending our Tic-Tac-Toe application. Right now, we'll take
    a look at one of the Java mocking frameworks called Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mockito is a mocking framework with a clean and simple API. Tests produced
    with Mockito are readable, easy to write, and intuitive. It contains three major
    static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mock()`: This is used to create mocks. Optionally, we can specify how those
    mocks behave with `when()` and `given()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spy()`: This can be used for partial mocking. Spied objects invoke real methods
    unless we specify otherwise. As with `mock()`, behavior can be set for every public
    or protected method (excluding static). The major difference is that `mock()`
    creates a fake of the whole object, while `spy()` uses the real object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verify()`: This is used to check whether methods were called with given arguments.
    It is a form of assert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll go deeper into Mockito once we start coding our Tic-Tac-Toe v2 application.
    First, however, let us quickly go through a new set of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Tic-Tac-Toe v2 requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements of our Tic-Tac-Toe v2 application are simple. We should add
    a persistent storage so that players can continue playing the game at some later
    time. We'll use MongoDB for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Add MongoDB persistent storage to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Tic-Tac-Toe v2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll continue where we left off with Tic-Tac-Toe in [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml),
    *Red-Green-Refactor – From Failure Through Success until Perfection*. The complete
    source code of the application developed so far can be found at [https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo.git).
    Use the VCS|Checkout from Version Control|Git option from the IntelliJ IDEA to
    clone the code. As with any other project, the first thing we need to do is add
    the dependencies to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Importing the MongoDB driver should be self-explanatory. Jongo is a very helpful
    set of utility methods that make working with Java code much more similar to the
    Mongo query language. For the testing part, we'll continue using JUnit with the
    addition of Mockito mocks, spies, and validations.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we won't install MongoDB until the very end. With Mockito,
    we will not need it, since all our Mongo dependencies will be mocked.
  prefs: []
  type: TYPE_NORMAL
- en: Once dependencies are specified, remember to refresh them in the IDEA Gradle
    Projects dialogue.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in the `00-prerequisites` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/00-prerequisites)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have prerequisites set, let's start working on the first requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Requirement 1 – store moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should be able to save each move to the DB. Since we already have all the
    game logic implemented, this should be trivial to do. Nonetheless, this will be
    a very good example of mock usage.
  prefs: []
  type: TYPE_NORMAL
- en: Implement an option to save a single move with the turn number, the *x* and
    *y* axis positions, and the player (`X` or `O`).
  prefs: []
  type: TYPE_NORMAL
- en: We should start by defining the Java bean that will represent our data storage
    schema. There's nothing special about it, so we'll skip this part with only one
    note.
  prefs: []
  type: TYPE_NORMAL
- en: Do not spend too much time defining specifications for Java boilerplate code.
    Our implementation of the bean contains overwritten `equals` and `hashCode`. Both
    are generated automatically by IDEA and do not provide a real value, except to
    satisfy the need to compare two objects of the same type (we'll use that comparison
    later on in specifications). TDD is supposed to help us design better and write
    better code. Writing 15-20 specifications to define boilerplate code that could
    be written automatically by IDE (as is the case with the `equals` method) does
    not help us meet these objectives. Mastering TDD means not only learning how to
    write specifications, but also knowing when it's not worth it.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, consult the source code to see the bean specification and implementation
    in it's entirety.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in the `01-bean` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/01-bean)).
    The particular classes are `TicTacToeBeanSpec` and `TicTacToeBean`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go to a more interesting part (but still without mocks, spies, and
    validations). Let's write specifications related to saving data to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this requirement, we''ll create two new classes inside the `com.packtpublishing.tddjava.ch03tictactoe.mongo`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TicTacToeCollectionSpec` (inside `src/test/java`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TicTacToeCollection` (inside `src/main/java`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification – DB name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should specify what the name of the DB that we''ll use will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are instantiating a new `TicTacToeCollection` class and verifying that the
    DB name is what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation is very straightforward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When instantiating the `TicTacToeCollection` class, we're creating a new `MongoCollection`
    with the specified DB name (`tic-tac-toe`) and assigning it to the local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Bear with us. There's only one more specification left until we get to the interesting
    part where we'll use mocks and spies.
  prefs: []
  type: TYPE_NORMAL
- en: Specification – a name for the Mongo collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous implementation, we used `bla` as the name of the collection
    because `Jongo` forced us to put some string. Let''s create a specification that
    will define the name of the Mongo collection that we''ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This specification is almost identical to the previous one and probably self
    explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we have to do to implement this specification is change the string we used
    to set the collection name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have got the impression that refactoring is reserved only for the
    implementation code. However, when we look the objectives behind refactoring (more
    readable, optimal, and faster code), they apply as much to specifications as to
    the implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two specifications have the instantiation of the `TicTacToeCollection`
    class repeated. We can move it to a method annotated with `@Before`. The effect
    will be the same (the class will be instantiated before each method annotated
    with `@Test` is run) and we''ll remove the duplicated code. Since the same instantiation
    will be needed in further specs, removing duplication now will provide even more
    benefits later on. At the same time, we''ll save ourselves from throwing `UnknownHostException`
    over and over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Use setup and teardown methods. The benefits of these allow preparation or setup
    and disposal or teardown code to be executed before and after the class or each
    test method.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, some code needs to be executed before the test class or each
    method in a class. For this purpose, JUnit has the `@BeforeClass` and `@Before`
    annotations that should be used in the setup phase. The `@BeforeClass` executes
    the associated method before the class is loaded (before the first test method
    is run). `@Before` executes the associated method before each test is run. Both
    should be used when there are certain preconditions required by tests. The most
    common example is setting up test data in the (hopefully in-memory) database.
    On the opposite end are the `@After` and `@AfterClass` annotations, which should
    be used as the teardown phase. Their main purpose is to destroy the data or state
    created during the setup phase or by tests themselves. Each test should be independent
    from others. Moreover, no test should be affected by the others. The teardown
    phase helps maintain the system as if no test were previously executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's do some mocking, spying, and verifying!
  prefs: []
  type: TYPE_NORMAL
- en: Specification – adding items to the Mongo collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should create a method that saves data to MongoDB. After studying Jongo documentation,
    we discovered that there is the `MongoCollection.save` method, which does exactly
    that. It accepts any object as a method argument and transforms it (using Jackson)
    into JSON, which is natively used in MongoDB. The point is that after playing
    around with Jongo, we decided to use and, more importantly, trust this library.
  prefs: []
  type: TYPE_NORMAL
- en: We can write Mongo specifications in two ways. One more traditional and appropriate
    for **End2End** (**E2E**) or integration tests would be to bring up a MongoDB
    instance, invoke the Jongo's save method, query the database, and confirm that
    data has indeed been saved. It does not end here, as we would need to clean up
    the database before each test to always guarantee that the same state is unpolluted
    by the execution of previous tests. Finally, once all tests are finished executing,
    we might want to stop the MongoDB instance and free server resources for some
    other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, there is quite a lot of work involved for a single
    test written in this way. Also, it's not only about work that needs to be invested
    into writing such tests. The execution time would be increased quite a lot. Running
    one test that communicates with a DB does not take long. Running ten tests is
    usually still fast. Running hundreds or thousands can take quite a lot of time.
    What happens when it takes a lot of time to run all unit tests? People lose patience
    and start dividing them into groups or give up on TDD all together. Dividing tests
    into groups means that we lose confidence in the fact that nothing got broken,
    since we are continuously testing only parts of it. Giving up on TDD... Well,
    that's not the objective we're trying to accomplish. However, if it takes a lot
    of time to run tests, it's reasonable to expect developers to not want to wait
    until they are finished running before they move to the next specification, and
    that is the point when we stop doing TDD. What is a reasonable amount of time
    to allow our unit tests to run? There is no one-fits-all rule that defines this;
    however, as a rule of thumb, if the time is longer than 10-15 seconds, we should
    start worrying, and dedicate time to optimizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should run quickly. The benefits are that the tests are used often.
  prefs: []
  type: TYPE_NORMAL
- en: If it takes a lot of time to run tests, developers will stop using them or run
    only a small subset related to the changes they are making. One benefit of fast
    tests, besides fostering their usage, is fast feedback. The sooner the problem
    is detected, the easier it is to fix it. Knowledge about the code that produced
    the problem is still fresh. If a developer has already started working on the
    next feature while waiting for the completion of the execution of tests, they
    might decide to postpone fixing the problem until that new feature is developed.
    On the other hand, if they drops their current work to fix the bug, time is lost
    in context switching.
  prefs: []
  type: TYPE_NORMAL
- en: If using live DB to run unit tests is not a good option, then what is the alternative?
    Mocking and spying! In our example, we know which method of a third-party library
    should be invoked. We also invested enough time to trust this library (besides
    integration tests that will be performed later on). Once we know how to use the
    library, we can limit our job to verifying that correct invocations of that library
    have been made.
  prefs: []
  type: TYPE_NORMAL
- en: Let us give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should modify our existing code and convert our instantiation of
    the `TicTacToeCollection` into a `spy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Spying on a class is called **partial** mocking. When applied, the class will
    behave exactly the same as it would if it was instantiated normally. The major
    difference is that we can apply partial mocking and substitute one or more methods
    with mocks. As a general rule, we tend to use spies mostly on classes that we're
    working on. We want to retain all the functionality of a class that we're writing
    specifications for, but with an additional option to, when needed, mock a part
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us write the specification itself. It could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Static methods, such as `mock`, `doReturn`, and `verify`, are all from the `org.mockito.Mockito`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re creating a new `TicTacToeBean`. There''s nothing special there.
    Next, we are creating a `mock` object out of the `MongoCollection`. Since we already
    established that, when working on a unit level, we want to avoid direct communication
    with the DB, mocking this dependency will provide this for us. It will convert
    a real  class into a mocked one. For the class using `mongoCollection`, it''ll
    look like a real one; however, behind the scenes, all its methods are shallow
    and do not actually do anything. It''s like overwriting that class and replacing
    all the methods with empty ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re telling that a mocked `mongoCollection` should be returned whenever
    we call the `getMongoCollection` method of the collection spied class. In other
    words, we''re telling our class to use a fake collection instead of the real one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''re calling the method that we are working on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should verify that the correct invocation of the `Jongo` library
    is performed once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to implement this specification.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the specification we just wrote, let us do only a partial
    implementation. We''ll create an empty method, `saveMove`. This will allow our
    code to compile without implementing the specification yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our specifications (`gradle test`), the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Mockito tells us that, according to our specification, we expect the `mongoCollection.save`
    method to be invoked, and that the expectation was not fulfilled. Since the test
    is still failing, we need to go back and finish the implementation. One of the
    biggest sins in TDD is to have a failing test and move onto something else.
  prefs: []
  type: TYPE_NORMAL
- en: All tests should pass before a new test is written. The benefits of this are
    that the focus is maintained on a small unit of work, and implementation code
    is (almost) always in a working condition.
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes tempting to write multiple tests before the actual implementation.
    In other cases, developers ignore problems detected by the existing tests and
    move towards new features. This should be avoided whenever possible. In most cases,
    breaking this rule will only introduce technical debt that will need to be paid
    with interest. One of the goals of TDD is ensuring that the implementation code
    is (almost) always working as expected. Some projects, due to pressures to reach
    the delivery date or maintain the budget, break this rule and dedicate time to
    new features, leaving the fixing of the code associated with failed tests for
    later. Those projects usually end up postponing the inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the implementation too, for example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our specifications again, the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time we are invoking the expected method, but the arguments we are passing
    to it are not what we hoped for. In the specification, we set the expectation
    to a bean (new `TicTacToeBean(3, 2, 1, 'Y')`) and in the implementation, we passed
    null. Not only that, Mockito verifications can tell us whether a correct method
    was invoked, and also whether the arguments passed to that method are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct implementation of the specification is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time all specifications should pass, and we can, happily, proceed to the
    next one.
  prefs: []
  type: TYPE_NORMAL
- en: Specification – adding operation feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us change the return type of our `saveMove` method to `boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This implementation is very straightforward. We should change the method return
    type. Remember that one of the rules of TDD is to use the simplest possible solution.
    The simplest solution is to return `true` as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have probably noticed that the last two specifications have the first two
    lines duplicated. We can refactor the specifications code by moving them to the
    method annotated with `@Before`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Specification – error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us contemplate the option that something might go wrong when using
    MongoDB. When, for example, an exception is thrown, we might want to return `false`
    from our `saveMove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we introduce to another Mockito method: `doThrow`. It acts in a similar
    way to `doReturn` and throws an `Exception` when set conditions are fulfilled.
    The specification will throw the `MongoException` when the save method inside
    the `mongoCollection` class is invoked. This allows us to `assert` that our `saveMove`
    method returns `false` when an exception is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation can be as simple as adding a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Specification – clear state between games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very simple application that, at least at this moment, can store only
    one game session. Whenever a new instance is created, we should start over and
    remove all data stored in the database. The easiest way to do this is to simply
    drop the MongoDB collection. Jongo has the `MongoCollection.drop()` method that
    can be used for that. We'll create a new method, `drop`, that will act in a similar
    way to `saveMove`.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't worked with Mockito, MongoDB, and/or Jongo, the chances are you
    were not able to do the exercises from this chapter by yourself, and just decided
    to follow the solutions we provided. If that's the case, this is the moment when
    you may want to switch gears and try to write the specifications and implementation
    by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should verify that `MongoCollection.drop()` is invoked from our own method
    `drop()` inside the `TicTacToeCollection` class. Try it by yourself before looking
    at the following code. It should be almost the same as what we did with the `save`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this is a wrapper method, implementing this specification should be fairly
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Specification – drop operation feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're almost done with this class. There are only two specifications left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us make sure that, in normal circumstances, we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If things look too easy with TDD, then that is on purpose. We are splitting
    tasks into such small entities that, in most cases, implementing a specification
    is a piece of cake. This one is no exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Specification – error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let us make sure that the `drop` method returns `false` in case of
    an `Exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us just add a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, we are finished with the `TicTacToeCollection` class
    that acts as a layer between our `main` class and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in the `02-save-move` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/02-save-move)).
    The classes in particular are `TicTacToeCollectionSpec` and `TicTacToeCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: Requirement 2 – store every turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us employ the `TicTacToeCollection` methods inside our main class `TicTacToe`.
    Whenever a player plays a turn successfully, we should save it to the DB. Also,
    we should drop the collection whenever a new class is instantiated so that a new
    game does not overlap the old one. We could make it much more elaborate than this;
    however, for the purpose of this chapter and learning how to use mocking, this
    requirement should do for now.
  prefs: []
  type: TYPE_NORMAL
- en: Save each turn to the database and make sure that a new session cleans the old
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do some setup first.
  prefs: []
  type: TYPE_NORMAL
- en: Specification – creating new collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since all our methods that will be used to communicate with MongoDB are in
    the `TicTacToeCollection` class, we should make sure that it is instantiated.
    The specification could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The instantiation of `TicTacToe` is already done in the method annotated with `@Before`.
    With this specification, we're making sure that the collection is instantiated
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing special about this implementation. We should simply overwrite
    the default constructor and assign a new instance to the `ticTacToeCollection`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we should add a local variable and a getter for `TicTacToeCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that''s left is to instantiate a new `collection` and assign it to
    the variable when the `main` class is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We also created another way to instantiate the class by passing `TicTacToeCollection`
    as an argument. This will come in handy inside specifications as an easy way to
    pass a mocked collection.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us go back to the specifications class and make use of this new constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Specification refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To utilize a newly created `TicTacToe` constructor, we can do something such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now all our specifications will use a mocked version of the `TicTacToeCollection`.
    There are other ways to inject mocked dependencies (for example, with Spring);
    however, when possible, we feel that simplicity trumps complicated frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Specification – storing current move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we play a turn, it should be saved to the DB. The specification can
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you should be familiar with Mockito, but let us go through the code
    as a refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are instantiating a `TicTacToeBean` since it contains the data that
    our collections expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it is time to play an actual turn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to verify that the `saveMove` method is really invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we have done throughout this chapter, we isolated all external invocations
    and focused only on the unit (`play`) that we're working on. Keep in mind that
    this isolation is limited only to the public and protected methods. When it comes
    to the actual implementation, we might choose to add the `saveMove` invocation
    to the `play` public method or one of the private methods that we wrote as a result
    of the refactoring we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This specification poses a couple of challenges. First, where should we place
    the invocation of the `saveMove` method? The `setBox` private method looks like
    a good place. That's where we are doing validations of if the turn is valid, and
    if it is, we can call the `saveMove` method. However, that method expects a `bean`
    instead of the variables `x`, `y`, and `lastPlayer` that are being used right
    now, so we might want to change the signature of the `setBox` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the method looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks after the necessary changes are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The change of the `setBox` signature triggers a few other changes. Since it
    is invoked from the `play` method, we''ll need to instantiate the `bean` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that we used a constant value `1` as a turn. There is
    still no specification that says otherwise, so we took a shortcut. We'll deal
    with it later.
  prefs: []
  type: TYPE_NORMAL
- en: All those changes were still very simple, and it took a reasonably short period
    of time to implement them. If the changes were bigger, we might have chosen a
    different path; and made a simpler change to get to the final solution through
    refactoring. Remember that speed is the key. You don't want to get stuck with
    an implementation that does not pass tests for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Specification – error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if a move could not be saved? Our helper method `saveMove` returns
    `true` or `false` depending on the MongoDB operation outcome. We might want to
    throw an exception when it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: we should change the implementation of the `before` method
    and make sure that, by default, `saveMove` returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have stubbed the mocked collection with what we think is the default
    behavior (return `true` when `saveMove` is invoked), we can proceed and write
    the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We're using Mockito to return `false` when `saveMove` is invoked. Since, in
    this case, we don't care about a specific invocation of `saveMove`, we used `any(TicTacToeBean.class)`
    as the method argument. This is another one of Mockito's static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is set, we use a JUnit expectation in the same way as we did
    before throughout [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a simple `if` and throw a `RuntimeException` when the result is not
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Specification – alternate players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember the turn that we hard coded to be always `1`? Let's fix that
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke the `play` method twice and verify that the turn changes from
    `1` to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with almost everything else done in the TDD fashion, implementation is fairly
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few more specifications and their implementations are still missing. We should
    invoke the `drop()` method whenever our `TicTacToe` class is instantiated. We
    should also make sure that `RuntimeException` is thrown when `drop()` returns
    `false`. We'll leave those specifications and their implementations as an exercise
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in the `03-mongo` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/03-mongo)).
    The classes in particular are `TicTacToeSpec` and `TicTacToe`.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did a lot of unit tests. We relied a lot on trust. Unit after unit was specified
    and implemented. While working on specifications, we isolated everything but the
    units we were working on, and verified that one invoked the other correctly. However,
    the time has come to validate that all those units are truly able to communicate
    with MongoDB. We might have made a mistake or, more importantly, we might not
    have MongoDB up and running. It would be a disaster to discover that, for example,
    we deployed our application, but forgot to bring up the DB, or that the configuration
    (IP, port, and so on) is not set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The integration test's objective is to validate, as you might have guessed,
    the integration of separate components, applications, systems, and so on. If you
    remember the testing pyramid, it states that unit tests are the easiest to write
    and fastest to run, so we should keep other types of tests limited to things that
    UTs did not cover.
  prefs: []
  type: TYPE_NORMAL
- en: We should isolate our integration tests in a way that they can be run occasionally
    (before we push our code to repository, or as a part of our **continuous integration**
    (**CI**) process) and keep unit test as a continuous feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: Tests separation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we follow some kind of convention, it is fairly easy to separate tests in
    Gradle. We can have our tests in different directories and distinct packages or,
    for example, with different file suffixes. In this case, we choose the latter.
    All our specification classes are named with the `Spec` suffix (that is, `TicTacToeSpec`).
    We can make a rule that all integration tests have the `Integ` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let us modify our `build.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll tell Gradle that only classes ending with `Spec` should be used
    by the `test` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create a new task, `testInteg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With those two additions to `build.gradle`, we continue having the test tasks
    that we used heavily throughout the book; however, this time, they are limited
    only to specifications (unit tests). In addition, all integration tests can be
    run by clicking the `testInteg` task from the Gradle projects IDEA window or running
    the following command from command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Let us write a simple integration test.
  prefs: []
  type: TYPE_NORMAL
- en: The integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create a `TicTacToeInteg` class inside the `com.packtpublishing.tddjava.ch03tictactoe`
    package in the `src/test/java` directory. Since we know that Jongo throws an exception
    if it cannot connect to the database, a test class can be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The invocation of `assertEquals` is just as a precaution. The real objective
    of this test is to make sure that no `Exception` is thrown. Since we did not start
    MongoDB (unless you are very proactive and did it yourself, in which case you
    should stop it), `test` should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e8e2b6-439a-45e2-ac2a-206f307010a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know that the integration test works, or in other words, that it
    indeed fails when MongoDB is not up and running, let us try it again with the
    DB started. To bring up MongoDB, we'll use Vagrant to create a virtual machine
    with Ubuntu OS. MongoDB will be run as a Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the 04-integration branch is checked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0e5e0fa-4005-4021-9cd1-e2dc393f35fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the command prompt, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Be patient until VM is up and running (it might take a while when executed
    for the first time, especially on a slower bandwidth). Once finished, rerun integration
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60c4a316-d999-4143-9697-359e4df6e661.png)'
  prefs: []
  type: TYPE_IMG
- en: It worked, and now we're confident that we are indeed integrated with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: This was a very simplistic integration test, and in the real-world, we would
    do a bit more than this single test. We could, for example, query the DB and confirm
    that data was stored correctly. However, the purpose of this chapter was to learn
    both how to mock and that we should not depend only on unit tests. The next chapter
    will explore integration and functional tests in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in the `04-integration` branch of the `tdd-java-ch06-tic-tac-toe-mongo`
    Git repository ([https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration](https://bitbucket.org/vfarcic/tdd-java-ch06-tic-tac-toe-mongo/branch/04-integration)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking and spying techniques are used to isolate different parts of code or
    third-party libraries. They are essential if we are to proceed with great speed,
    not only while coding, but also while running tests. Tests without mocks are often
    too complex to write and can be so slow that, with time, TDD tends to become close
    to impossible. Slow tests mean that we won't be able to run all of them every
    time we write a new specification. That in itself leads to deterioration in the
    confidence we have in the our tests, since only a part of them is run.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is not only useful as a way to isolate external dependencies, but also
    as a way to isolate our own code from a unit we're working on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we presented Mockito as, in our opinion, the framework with
    the best balance between functionality and ease of use. We invite you to investigate
    its documentation in more detail ([http://mockito.org/](http://mockito.org/)),
    as well as other Java frameworks dedicated to mocking. EasyMock ([http://easymock.org/](http://easymock.org/)),
    JMock ([http://www.jmock.org/](http://www.jmock.org/)), and PowerMock ([https://code.google.com/p/powermock/](https://code.google.com/p/powermock/))
    are a few of the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to put some functional programming concepts
    as well as some TDD concepts applied to them. For that matter, part of the Java
    functional API is going to be presented.
  prefs: []
  type: TYPE_NORMAL
