- en: Chapter 6. Interest Rate Derivatives with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter illustrates the application of C++ to the pricing of interest
    rate derivatives. We will consider two examples: the pricing of a plain vanilla
    **Interest Rate Swap** (**IRS**) (basic example) and the pricing of a Cap (advanced
    example). We provide the full working C++ implementation for both. Both the examples
    are solved using one factor **Libor Market Model** (**LMM**) and Monte Carlo simulation.
    A simpler C implementation (without the OO features) can be found in the accompanying
    book website. The LMM is described in "The Market Model of Interest Rate Dynamics".
    An excellent description of the Monte Carlo simulation can be found in "Efficient
    Methods for Valuing Interest Rate Derivatives".'
  prefs: []
  type: TYPE_NORMAL
- en: Basic example – plain vanilla IRS (IR1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that Monte Carlo simulation requires a random number generator to operate.
    We will take advantage of the random number generator, which we developed in [Chapter
    3](part0024_split_000.html#MSDG2-f9cfc61bea324a5db85ec5ea1673cdfd "Chapter 3. Numerical
    Methods"), *Numerical Methods*, to price equity derivatives (the Box-Muller algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: We consider an example of a plain vanilla IRS on a notional of one million EUR.
    The length of the contract is one year and the frequency of payments is every
    three months. The floating rates are therefore indexed to EURIBOR3M. The fixed
    rate is 4 percent p.a.
  prefs: []
  type: TYPE_NORMAL
- en: We use LMM with Monte Carlo simulation with 10,000 simulations. We assume an
    initial flat term structure of interest rates at 5 percent p.a. We also assume
    a volatility of 15 percent for the forward rates (this value is usually calibrated
    from observed swaptions in the market).
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming code snippets implement the algorithm from the Bento Box template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 16 – IR1_main.cpp (IRS with Monte Carlo LMM)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Code 17 – IR1_source.cpp (IRS with Monte Carlo LMM)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet for `IR1_source.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the basic example (IR1), you will have to compile and run code snippets
    16, 17, 18, 4, 5, and 13 (which include the header, matrix, and random functions).
    Afterwards, you should obtain the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic example – plain vanilla IRS (IR1)](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Basic example (IR1) screenshot with results
  prefs: []
  type: TYPE_NORMAL
- en: Advanced example – IRS with Cap (IR2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this second example, we consider the pricing of an IRS with a cap The details
    of the approach are shown in the following Bento Box template advanced example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced example – IRS with Cap (IR2)](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bento Box template for advanced example (IR2)
  prefs: []
  type: TYPE_NORMAL
- en: Our target is to compute the net present value of the swap as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: An IRS cap is just like a standard IRS but with one key difference—at each payment
    date, we compute the maximum between (a) the difference between the floating rate
    and the strike and (b) zero. With this difference, we compute the value of a caplet;
    the cap is simply the sum of the caplets contained in the IRS.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is shown in box 4 of the Bento Box template. The implementation
    of the algorithm in C++ is shown in code snippets 19 and 20\. Code snippet 19
    is the main code block, while code snippet 20 is its associated source.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code 19 – IR2_main.cpp (cap with Monte Carlo LMM)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Code 20 – IR2_source.cpp (cap with Monte Carlo LMM)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We consider the example of an IRS having a cap with a strike 5 percent and a
    maturity of 2.5 years. We assume a flat term structure of 5 percent with a forward
    volatility of 15 percent. Payments are every six months and a notional of 1 EUR.
    The floating rate is EURIBOR6M.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the advanced example (IR2), you need to compile and run code snippets
    19, 20, 18, 4, 5, and 13 (which include the a header, matrix, and random functions).
    Afterwards, you should obtain the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced example – IRS with Cap (IR2)](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Advanced example (IR2) screenshot with results
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have solved two pricing problems in interest rate derivatives.
    We have seen a basic example (plain vanilla IRS) and an advanced example. For
    each, we have provided the complete C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will now proceed to the last asset class, credit derivatives, in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
