- en: Chapter 9. Physics Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE physics system is an extensible physics implementation that allows
    for the creation of a truly dynamic world. With a sizeable API, developers will
    find that there's plenty of wiggle room when it comes to implementing physical
    simulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the workings of the physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to debug our physicalized geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to ray cast and intersect primitives to discover contact points, ground
    normal, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own physicalized entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make things go boom by using simulated explosions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CryPhysics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The physical entity system is oriented around the concepts of physical entities,
    which are accessible via the `IPhysicalEntity` interface. A physical entity represents
    geometry with a physical proxy that can affect and be affected by intersections,
    collisions, and other events.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to create physical entities without an underlying entity
    (`IEntity`) via the `IPhysicalWorld::CreatePhysicalEntity` function, it is most
    common to call `IEntity::Physicalize` in order to enable the physics proxy of
    the model currently loaded by the entity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The physics proxy is a simplified model of the render mesh. This is used to
    decrease the strain on the physics system.
  prefs: []
  type: TYPE_NORMAL
- en: When `IEntity::Physicalize` is called, a new entity proxy is created that will
    handle its physicalized representation via a call to `IPhysicalWorld::CreatePhysicalEntity`.
    The CryENGINE allows for a number of physical entity types to be created, depending
    on the purpose of the physicalized object.
  prefs: []
  type: TYPE_NORMAL
- en: Physicalized entity types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the types of physicalized entities currently implemented by the
    CryENGINE:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PE_NONE**: This is used when the entity should not be physicalized, or passed
    to `IEntity::Physicalize` when we want to dephysicalize. While not physicalized,
    the entity will not have a physics proxy and can therefore not physically interact
    with other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_STATIC**: This tells the physics system to utilize the entity''s physics
    proxy, but never allows it to be moved or rotated through the use of physical
    interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_RIGID**: This applies the rigid body type to the object, which allows
    foreign objects to collide and move the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_WHEELEDVEHICLE**: This is a specialized type used for vehicles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_LIVING**: This is used for living actors, such as humans, that require
    ground alignment and ground contact queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_PARTICLE**: This physicalizes based on the particle passed in `SEntityPhysicalizeParams`,
    and is useful for avoiding issues with fast moving objects such as projectiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_ARTICULATED**: This is used for articulated structures consisting of several
    rigid bodies connected by joints, and is used on, for example, ragdolls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_ROPE**: This is used for creating physicalized rope objects that can tie
    together two physical entities, or hang freely. It is also used for the Sandbox
    rope tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE_SOFT**: This is a a collection of connected vertices that can interact
    with the environment, for example, cloth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing physical entity identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All physical entities are assigned unique identifiers which can be retrieved
    via `IPhysicalWorld::GetPhysicalEntityId`, and used to obtain the physical entity
    via `IPhysicalWorld::GetPhysicalEntityById`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The physical entity ID is serialized as a way to associate data with specific
    physical entities, and should therefore be consistent between reloads.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing entity proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make use of the `p_draw_helpers` CVar to get visual feedback on the various
    physicalized objects present in the level.
  prefs: []
  type: TYPE_NORMAL
- en: To draw all physicalized objects, simply set the CVar to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing entity proxies](img/5909_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For more complex usage, use `p_draw_helpers [Entity_Types]_[Helper_Types]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to draw the terrain proxy geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Drawing entity proxies](img/5909_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entity types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Following is a list of entity types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**: This shows terrain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s**: This shows static entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r**: This shows sleeping rigid bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R**: This shows active rigid bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**l**: This shows living entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**i**: This shows independent entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**g**: This shows triggers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**a**: This shows areas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**y**: This shows the `RayWorldIntersection` rays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**e**: This shows explosion occlusion maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helper types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Following is a list of helper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**g**: This shows geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**c**: This shows contact points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**b**: This shows bounding boxes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**l**: This shows tetrahedral lattices for breakable objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**j**: This shows structural joints (will force translucency on the main geometry)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**t(#)**: This shows bounding volume trees up to the level #'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**f(#)**: This only shows geometries with this bit flag set (multiple f''s
    stack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical entity actions, parameters, and status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `IPhysicalEntity` interface provides three methods of altering and obtaining
    the physical state of the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Physical entity parameters determine how the physical representation of the
    geometry should behave in the world. Parameters can be retrieved via the `IPhysicalEntity::GetParams`
    function, and set by using `IPhysicalEntity::SetParams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All parameters are passed as structs that derive from `pe_params`. For example,
    to modify what gravity the entity is affected by, we can use `pe_simulation_params`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code will change the gravitational pull that is applied to the entity to
    -9.81f.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the physical entity parameter struct's default constructors mark certain
    data as unused; this way we don't have to worry about overriding parameters we
    did not set.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar in usage to parameters, actions allow the developer to force certain
    physical events, such as impulses or resetting entity velocity.
  prefs: []
  type: TYPE_NORMAL
- en: All actions are derived from the `pe_action` struct, and can be applied via
    the `IPhysicalEntity::Action` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to apply a simple impulse to our entity which launches it into
    the air, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to get various status data from the entity, to, for example,
    determine where its center of mass is, or to get its velocity.
  prefs: []
  type: TYPE_NORMAL
- en: All statuses are derived from the `pe_status` struct, and can be retrieved via
    the `IPhysicalEntity::GetStatus` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get the velocity of a living physical entity such as a player,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Physicalized entity type details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of parameters, actions, and statuses for the default physicalized
    entity implementation. We have listed a selection of their most commonly used
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Common parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_pos**: This is used to set the position and orientation of the
    physical entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_params_bbox**: This allows forcing an entity''s bounding box to a specific
    value, or querying it when used with `GetParams`, as well as querying intersections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_params_outer_entity**: This allows specifying an outer physical entity.
    Collisions with the outer entity will be ignored if they occur within the bounding
    box of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_simulation_params**: This sets simulation parameters for compatible entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_action_impulse**: This applies a one-time impulse to the entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_action_add_constraint**: This is used to add a constraint between two
    physical entities. For example, an ignore constraint could be used to make a ghost
    walk through walls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_action_set_velocity**: This is used to force the velocity of a physical
    entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common statuses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_status_pos**: This requests the current transformation of an entity or
    an entity part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_status_dynamics**: This is used to get entity movement stats such as acceleration,
    angular acceleration, and velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physicalizing an entity with the static type results in the creation of the
    base physicalized entity type, from which all extensions such as rigid or living
    are derived.
  prefs: []
  type: TYPE_NORMAL
- en: Static entities are physicalized, but will not move. For example, if a ball
    is thrown at a static object, it will bounce back without moving the target object.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refers to basic physicalized entity that can be moved in the world when
    affected by external forces.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the same previous example, throwing a ball at a rigid object will
    result in the rigid object being pushed away
  prefs: []
  type: TYPE_NORMAL
- en: Wheeled vehicle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This represents a wheeled vehicle, putting it simply, the implementation is
    a rigid body with added vehicle functionality such as wheels, brakes, and the
    CryENGINE.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_car**: This is used to get or set vehicle-specific parameters,
    such as CryENGINE power, RPM, and the number of gears'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_params_wheel**: This is used to get or set parameters specific to one
    of the vehicle''s wheels, such as friction, surface ID, and damping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique statuses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_status_vehicle**: This is used to get vehicle stats, allows getting velocity,
    current gear, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_status_wheel**: This gets the status of a specific wheel, for example,
    contact normal, torque, and surface ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_status_vehicle_abilities**: This allows checking of the maximum possible
    velocity for a specific turn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_action_drive**: This is used on vehicle events such as brakes, pedals,
    and gear switches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Living
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The living entity implementation is a specialized setup for handling actors
    and their movement requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Living entities have two states: on ground and in air. When on ground, the
    player will be "glued" to the ground until an attempt to detach it is made (by
    applying significant velocity away from the ground).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember the animated character movement requests from [Chapter 5](ch05.html
    "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*? The system uses
    living entity `pe_action_move` requests in the core.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_player_dimensions**: This is used to set parameters related to the living
    entity''s static properties, such as sizeCollider, and whether it should use a
    capsule or cylinder for the collision geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_player_dynamics**: This is used to set dynamic parameters related to the
    living entity, such as inertia, gravity, and mass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique statuses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_status_living**: This gets the current living entity status, including
    stats such as time flying, velocity, and ground normal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_status_check_stance**: This is used to check whether new dimensions cause
    collisions. Parameters have the same meaning as in pe_player_dimensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_action_move**: This is used to submit move requests for the entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also possible to use particle representations of objects. This is commonly
    done for objects that should move at high speeds, for example, projectiles. Essentially,
    this means that the physics representation of our entity is simply a two-dimensional
    plane.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_particle**: This is used to set particle-specific parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articulated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Articulated structures consist of several rigid bodies connected by joints,
    for example, a ragdoll. This approach allows for setting tearing limits and more.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_joint**: This is used to create a joint between two rigid bodies
    when setting, and queries an existing joint when used together with `GetParams`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pe_params_articulated_body**: This is used to set parameters specific to
    the articulated type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to create ropes that tie multiple physicalized objects together,
    you should utilize ropes. This system allows ropes to attach to dynamic or static
    surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_rope**: This is used to alter or get physics rope parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Soft is a system of non-rigidly connected vertices that can interact with the
    environment, for example, cloth objects.
  prefs: []
  type: TYPE_NORMAL
- en: Unique parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_params_softbody**: This is used to configure a physicalized soft body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pe_action_attach_points**: This is used to attach some of the soft entity''s
    vertices to another physical entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ray world intersections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `IPhysicalWorld::RayWorldIntersection` function, we can cast a ray
    from one point of our world to another to detect distance to specific objects,
    surface types, normal of ground, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '`RayWorldIntersection` is pretty easy to use, and we can prove it! To start
    off, see the following example of a ray cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The ray_hit struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reference to our `ray_hit hit` variable is passed to `RayWorldIntersection`,
    and is where we'll be able to retrieve all of the information about the ray hit.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used member variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**float dist**: This is the distance from the origin (in our case the position
    of our entity) to the place where the ray hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPhysicalEntity *pCollider**: This is the pointer to the physical entity
    that our ray collided with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**short surface_idx**: This is the surface identifier of the surface type of
    the material our ray collided with (see `IMaterialManager::GetSurfaceType` to
    get its `ISurfaceType` pointer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vec3 pt**: This is the point of contact, in world coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vec3 n**: This is the surface normal at the point of contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ray_hit *next**: This points to the next `ray_hit` structure if our ray hit
    multiple times. See the *Allowing multiple ray hits* section for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Origin and direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and second parameters of the `RayWorldIntersection` function define
    from where the ray should be cast, and how far in a specific direction.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we shoot the ray from the current position of our entity, one unit
    downwards.
  prefs: []
  type: TYPE_NORMAL
- en: Object types and ray flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how after `dir`, we passed two types of flags to the `RayWorldIntersection`
    function. These indicate how the ray should intersect objects, and which collisions
    to ignore.
  prefs: []
  type: TYPE_NORMAL
- en: Object types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object types parameter expects flags based on the `entity_query_flags` enum,
    and is used to determine what types of objects we want to allow our ray to collide
    with. If the ray collides with an object type that we did not define, it will
    simply ignore it and pass through.
  prefs: []
  type: TYPE_NORMAL
- en: '**ent_static**: This refers to static objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_sleeping_rigid**: This indicates sleeping rigid bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_rigid**: This indicates active rigid bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_living**: This refers to living objects, for example, players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_independent**: This indicates independent objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_terrain**: This indicates terrain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ent_all**: This refers to all types of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ray flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ray flags parameter is based on the `rwi_flags` enum, and is used to determine
    how the cast should behave.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing multiple ray hits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, it''s also possible to allow the ray to hit objects multiple
    times. To do so, we simply create a `ray_hit` array and pass it to the `RayWorldIntersection`
    function along with the number of hits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating a physicalized entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how the physics system works, we can create our own physicalized
    entity that can collide with other physicalized geometry in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section assumes that you have read [Chapter 3](ch03.html "Chapter 3. Creating
    and Utilizing Custom Entities"), *Creating and Utilizing Custom Entities*.
  prefs: []
  type: TYPE_NORMAL
- en: In C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on what we learned earlier, we know that we can physicalize a static
    entity via the `PE_STATIC` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that geometry had been loaded for the entity prior to calling `IEntity::Physicalize`,
    other physicalized objects will now be able to collide with our entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to allow collisions to move our object in the world? That''s
    where the `PE_RIGID` type comes into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, CryENGINE will know that our object weighs 10 kilograms, and will be moved
    when it collides with another physicalized entity.
  prefs: []
  type: TYPE_NORMAL
- en: In C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also do this in C#, by using the `EntityBase.Physicalize` function,
    along with the `PhysicalizationParams` struct. For example, if we want to physicalize
    a static object, we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this assumes that an object has been loaded via the `EntityBase.LoadObject`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to make a rigid entity, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our entity now weighs 50 kilograms and can be moved when collisions with other
    physicalized objects occur.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating explosions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know you're thinking, "What good is all this physics knowledge if we can't
    blow stuff up?", and we've got you covered!
  prefs: []
  type: TYPE_NORMAL
- en: The physical world implementation provides a simple function for simulating
    explosions in the world, with a wide range of parameters to allow customization
    of the blast area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we''ll create an explosion with a maximum radius of 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimulateExplosion` function will merely simulate an explosion and generate
    a force that pushes entities away, it will not create any particle effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the basic workings of the physical world implementation
    and how to visually debug physics proxies.
  prefs: []
  type: TYPE_NORMAL
- en: With your new knowledge, you should be aware of how you can use ray world intersections
    to gather knowledge about the surrounding game world. Oh, and we've blown stuff
    up.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't feel ready to move on, why not create an extended physicalized
    entity or physics modifier such as a gravity gun, or a trampoline?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the rendering pipeline, including how
    to author custom shaders, and how to modify materials at runtime.
  prefs: []
  type: TYPE_NORMAL
