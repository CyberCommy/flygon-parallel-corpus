- en: '*Chapter 8*: Optimizing IR'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM uses a series of Passes to optimize the **intermediate representation**
    (**IR**). A Pass performs an operation on a unit of IR, either a function or a
    module. The operation can be a transformation, which changes the IR in a defined
    way, or an analysis, which collects information such as dependencies. A series
    of Passes is called the **Pass pipeline**. The Pass manager executes the Pass
    pipeline on the IR that our compiler produces. Therefore, it is important that
    we know what the Pass manager does and how to construct a Pass pipeline. The semantics
    of a programming language might require the development of new Passes, and we
    must add these Passes to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the LLVM Pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Pass using the new Pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting a Pass for use with the old Pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an optimization pipeline to your compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to develop a new Pass and how to
    add it to a Pass pipeline. You will have also acquired the knowledge required
    to set up the Pass pipeline in your own compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter08)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the LLVM Pass manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LLVM core libraries optimize the IR your compiler creates and turn it into
    object code. This giant task is broken down into separate steps, called **Passes**.
    These Passes need to be executed in the right order, which is the objective of
    the Pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: But why not hardcode the order of the Passes? Well, the user of your compiler
    usually expects that your compiler provides a different level of optimization.
    Developers prefer a faster compilation speed over-optimization during development
    time. The final application should run as fast as possible, and your compiler
    should be able to perform sophisticated optimizations, with longer compilation
    times accepted. A different level of optimization means a different number of
    optimization Passes that need to be executed. And, as a compiler writer, you might
    want to provide your own Passes to take advantage of your knowledge of the source
    language. For example, you might want to replace well-known library functions
    with inline IR or, if possible, with the computed result of that function. For
    C, such a Pass is part of the LLVM core libraries, but for other languages, you
    will need to provide it yourself. And introducing your own Passes, you might need
    to reorder or add some Passes. For example, if you know that the operation of
    your Pass leaves some IR code unreachable, then you should also run the dead code
    removal Pass after your own Pass. The Pass manager helps you to organize these
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Pass is often categorized according to the scope in which it works:'
  prefs: []
  type: TYPE_NORMAL
- en: A *function Pass* takes a single function as input and performs its work on
    this function only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *module Pass* takes a whole module as input. Such a Pass performs its work
    on the given module and can be used for intraprocedural operations inside this
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *call graph* Pass traverses the functions of a call graph in bottom-up order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the IR code, a Pass might also consume, produce, or invalidate some
    analysis results. There are a lot of different analyses performed; for example,
    alias analysis or the construction of a dominator tree. The dominator tree helps
    move invariant code out of a loop, so a Pass performing such a transformation
    can only run after the dominator tree has been created. Another Pass might perform
    a transformation that could invalidate the existing dominator tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the Pass manager ensures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis results are shared among Passes. This requires you to keep track of
    which Pass requires which analysis, and of the state of each analysis. The goal
    is to avoid needless recomputation of analyses and to free up the memory held
    by the analysis results as soon as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Passes are executed in a pipeline fashion. For example, if several function
    Passes should be executed in sequence, then the Pass manager runs each of these
    function Passes on the first function. It will then run all function Passes on
    the second function, and so on. The underlying idea here is to improve the cache
    behavior, as the compiler performs transformations on only a limited set of data
    (that is, one IR function) and then moves on to the next limited set of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two Pass managers in LLVM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The old (or legacy) Pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new Pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The future belongs to the new Pass manager, but the transition is not yet complete.
    A number of crucial Passes, such as object code emission, have not yet been migrated
    to the new Pass manager, so it is important to understand both Pass managers.
  prefs: []
  type: TYPE_NORMAL
- en: The old Pass manager requires a Pass to inherit from a base class, for example,
    from the `llvm::FunctionPass` class for a function Pass. In contrast, the new
    Pass manager relies on a concept-based approach, requiring inheritance from the
    special `llvm::PassInfo<>` mixin class only. The dependence between Passes was
    not expressed explicitly with the old Pass manager. In the new Pass manager, it
    needs to be explicitly coded. The new Pass manager also features a different approach
    to handling analysis and allows the specification of an optimization pipeline
    through a textual representation on the command line. Some LLVM users reported
    a reduction of compile of up to 10% just by switching from the old to the new
    Pass manager, which is a very convincing argument for using the new Pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will implement a Pass for the new Pass manager and explore how to
    add it to the optimization pipeline. Later, we will take a look at how to use
    a Pass with the old Pass manager, too.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Pass using the new Pass manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Pass can perform arbitrary complex transformations on the LLVM IR. To illustrate
    the mechanics of adding a new Pass, our new Pass only counts the number of IR
    instructions and basic blocks. We name the Pass `countir`. Adding the Pass to
    the LLVM source tree or as a standalone Pass differs slightly, so we will do both
    in the following sections. Let's begin by adding a new Pass to the LLVM source
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Pass to the LLVM source tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by adding the new Pass to the LLVM source. This is the right approach
    if we later want to publish the new Pass in the LLVM tree.
  prefs: []
  type: TYPE_NORMAL
- en: The source of Passes that perform transformations on the LLVM IR is located
    in the `llvm-project/llvm/lib/Transforms` folder, and the header files are in
    the `llvm-project/llvm/include/llvm/Transforms` folder. Because there are so many
    Passes, they are sorted into subfolders after the category they fit in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our new Pass, we create a new folder, called `CountIR`, in both locations.
    First, let''s implement the `CountIR.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we need to make sure that the file can be included multiple times.
    Additionally, we need to include the Pass manager definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are inside the LLVM source, we put our new `CountIR` class into
    the `llvm` namespace. The class inherits from the `PassInfoMixin` template. This
    template only adds some boilerplate code, such as a `name()` method. It is not
    used the determine the type of Pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, the `run(`) method of the task will be called. The signature of
    the `run()` method determines the type of Pass. Here, the first argument is a
    reference to the `Function` type, so this is a function Pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to close the class, the namespace, and the header guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the definition of our new Pass is so simple because we have only
    performed a trivial task.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the implementation of the Pass inside the `CountIIR.cpp`
    file. LLVM supports the collection of statistical information about a Pass if
    compiled in debug mode. For our Pass, we will make use of this infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the source by including our own header file and the required LLVM
    header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To shorten the source, we tell the compiler that we are using the `llvm` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in debug infrastructure of LLVM requires that we define a debug type,
    which is a string. This string is later shown in the printed statistic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We define two counter variables with the `STATISTIC` macro. The first parameter
    is the name of the counter variable, and the second parameter is the text that
    will be printed in the statistic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `run()` method, we loop through all of the basic blocks of the function
    and increment the corresponding counter. We do the same for all instructions of
    a basic block. To prevent a compiler from warning us about unused variables, we
    insert a no-op use of the `I` variable. Because we only count and do not alter
    the IR, we tell the caller that we have preserved all existing analyses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have implemented the functionality of our new Pass. We will reuse
    this implementation later for an out-of-tree Pass. For the solution inside the
    LLVM tree, we must change several files in LLVM to announce the existence of the
    new Pass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a `CMakeLists.txt` file to the source folder. This file
    contains the build instructions for a new LLVM library name, `LLVMCountIR`. The
    new library needs to link against the LLVM `Support` component because we use
    the debug and statistic infrastructure, and against the LLVM `Core` component,
    which contains the definition of the LLVM IR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make this new library part of the build, we need to add the folder
    into the `CMakeLists.txt` file of the parent folder, which is the `llvm-project/llvm/lib/Transforms/CMakeList.txt`
    file. Then, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PassBuilder` class needs to know about our new Pass. To do this, we add
    the following line into the `include` section of the `llvm-project/llvm/lib/Passes/PassBuilder.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we need to update the Pass registry, which is in the `llvm-project/llvm/lib/Passes/PassRegistry.def`
    file. Look for the section in which function Passes are defined, for example,
    by searching for the `FUNCTION_PASS` macro. Inside this section, you add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now made all the necessary changes. Follow the build instructions from
    [*Chapter 1*](B15647_01_ePub_RK.xhtml#_idTextAnchor015), *Installing LLVM,* in
    the *Building with CMake* section, to recompile LLVM. To test the new Pass, we
    store the following IR code inside the `demo.ll` file in our `build` folder. The
    code has two functions and, in sum, three instructions and two basic blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the new Pass with the `opt` utility. To run the new Pass, we will
    utilize the `--passes="countir"` option. To get the statistical output, we need
    to add the `--stats` option. Because we do not need the resulting bitcode, we
    also specify the `--disable-output` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We run our news Pass, and the output matches our expectations. We have successfully
    extended LLVM!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running a single Pass helps with debugging. With the `–-passes` option, you
    cannot only name a single Pass but describe a whole pipeline. For example, the
    default pipeline for optimization level 2 is named `default<O2>`. You can run
    the `countir` Pass before the default pipeline with the `–-passes="module(countir),default<O2>"`
    argument. The Pass names in such a pipeline description must be of the same type.
    The default pipeline is a module Pass and our `countir` Pass is a function Pass.
    To create a module pipeline from both, first, we must create a module Pass containing
    the `countir` Pass. That is done with `module(countir)`. You can add more function
    Passes to this module Pass by specifying them in a comma-separated list. In the
    same way, the module Passes can be combined. To study the effects of this, you
    can use the `inline` and `countir` Passes: running them in a different order,
    or as a module Pass, will give you a different statistical output.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new Pass to the LLVM source tree makes sense if you plan to publish
    your Pass as a part of LLVM. If you do not plan to do this, or if you want to
    distribute your Pass independently of LLVM, then you can create a Pass plugin.
    In the next section, we will view the steps to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new Pass as a plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide a new Pass as a plugin, we will create a new project that uses LLVM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new folder, called `countirpass`, in our source
    folder. The folder will have the following structure and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have reused the functionality from the previous section, with
    some small adaptions. The `CountIR.h` header file is now in a different location,
    so we change the name of the symbol that is used as a guard. We also do not use
    the `llvm` namespace, because we are now outside the LLVM source. As a result
    of this change, the header file becomes the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can copy the `CountIR.cpp` implementation file from the previous section.
    Small changes are needed here, too. Because the path of our header file has changed,
    we need to replace the `include` directive with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to register the new Pass at the Pass builder. This happens when
    the plugin is loaded. The Pass plugin manager calls the special function, `llvmGetPassPluginInfo()`,
    which performs the registration. For this implementation, we require two additional
    `include` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The user specifies the Passes to run on the command line with the `–-passes`
    option. The `PassBuilder` class extracts the Pass names from the string. In order
    to create an instance of the named Pass, the `PassBuilder` class maintains a list
    of callbacks. Essentially, the callbacks are called with the Pass name and a Pass
    manager. If the callback knows the Pass name, then it adds an instance of this
    Pass to the Pass manager. For our Pass, we need to provide such a callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to register this function as the `PassBuilder` instance.
    After the plugin is loaded, a registration callback is called for exactly this
    purpose. Our registration function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, each plugin needs to provide the mentioned `llvmGetPassPluginInfo()`
    function. This function returns a structure with four elements: the LLVM plugin
    API version used by our plugin, a name, the version number of the plugin, and
    the registration callback. The plugin API requires that the function uses the
    `extern "C"` convention. This is to avoid problems with C++ name mangling. The
    function is very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of one separate function for each callback helps us to understand
    what is going on. If your plugin provides several Passes, then you can extend
    the `RegisterCB` callback function to register all of the Passes. Often, you can
    find a very compact approach. The following `llvmGetPassPluginInfo()` function
    combines `PipelineParsingCB()`, `RegisterCB()`, and `llvmGetPassPluginInfo()`
    from earlier into a single function. It does so by making use of lambda functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to add the build files. The `lib/CMakeLists.txt` file contains
    just one command to compile the source file. The LLVM-specific command, `add_llvm_library()`,
    ensures that the same compiler flags that were used to build LLVM are utilized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The top-level `CMakeLists.txt` file is more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we set the required CMake version and the project name. Additionally,
    we set the `LLVM_EXPORTED_SYMBOL_FILE` variable to `ON`. This is necessary to
    make the plugin work on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look for the LLVM installation. We also print information about the
    found version to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the `cmake` folder from LLVM to the search path. We include
    the LLVM-specific files, `ChooseMSVCCRT` and `AddLLVM`, which provide additional
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler needs to know about the required definitions and the LLVM paths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add our own include and source folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Having implemented all of the required files, we can now create the `build`
    folder beside the `countirpass` folder. First, change to the build directory and
    create the build files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can compile the plugin, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the plugin with the `opt` utility, which is the `opt` utility produces
    an optimized version of the input file. To use the plugin with it, you need to
    specify an additional parameter to load the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output is the same as the previous version. Congratulations; the Pass plugin
    works!
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only created a Pass for the new Pass manager. In the next section,
    we will also extend the Pass for the old Pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting a Pass for use with the old Pass manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The future belongs to the new Pass manager, and it makes no sense to develop
    a new Pass for the old Pass manager exclusively. However, during the ongoing transition
    phase, it would be useful if a Pass could work with both Pass managers, as most
    of the Passes in LLVM already do.
  prefs: []
  type: TYPE_NORMAL
- en: The old Pass manager requires a Pass that has been derived from certain base
    classes. For example, a function Pass must derive from the `FunctionPass` base
    class. There are more differences, too. The method run by the Pass manager is
    named `runOnFunction()`, and an `ID` for the Pass must also be provided. The strategy
    we follow here is to create a separate class that we can use with the old Pass
    manager and refactor the source code in a way that the functionality can be used
    with both Pass managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the Pass plugin as a base. In the `include/CountIR.h` header file, we
    add a new class definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new class needs to derive from the `FunctionPass` class, so we include
    an additional header to get the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We name the new class `CountIRLegacyPass`. The class needs an ID for the internal
    LLVM machinery, and we initialize the parent class with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to implement the Pass functionality, two functions must be overridden.
    The `runOnFunction()` method is called for every LLVM IR function and implements
    our counting functionality. The `getAnalysisUsage()` method is used to announce
    that all of the analysis results are saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the changes to the header file now complete, we can enhance the implementation
    inside the `lib/CountIR.cpp` file. To reuse the counting functionality, we move
    the source code into a new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The method for the new Pass manager needs to be updated in order to use the
    new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we implement the method for the old Pass manager. With the
    `false` return value, we indicate that the IR did not change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To preserve the existing analysis results, the `getAnalysisUsage()` method
    must be implemented in the following way. This is similar to the `PreservedAnalyses::all()`
    return value in the new Pass manager. If you do not implement this method, then
    all analysis results are thrown away by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ID` field can be initialized with an arbitrary value because LLVM uses
    the address of the field. The common value is `0`, so we use it too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the Pass registration is missing now. To register the new Pass, we need
    to provide a static instance of the `RegisterPass<>` template. The first argument
    is the name of the command-line option to invoke the new Pass. The second argument
    is the name of the Pass, which is used, among other things, as information for
    the user when invoking the `-help` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These changes are enough to allow us to invoke our new Pass under the old Pass
    manager and the new Pass manager. To test the addition, change back into the `build`
    folder and compile the Pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To load the plugin for use with the old Pass manager, we need to use the `--load`
    option. Our new Pass is invoked with the `--countir` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please also check, in the command line from the previous section, that the invocation
    of our Pass with the new Pass manager still works fine!
  prefs: []
  type: TYPE_NORMAL
- en: Being able to run our new Pass with an LLVM-provided tool is nice, but ultimately,
    we want to run it inside our compiler. In the next section, we will explore how
    to set up an optimization pipeline and how to customize it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an optimization pipeline to your compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `tinylang` compiler, which was developed in the previous chapters, performs
    no optimizations on the created IR code. In the following sections, we will add
    an optimization pipeline to the compiler to perform this exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an optimization pipeline with the new Pass manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Central to the setup of the optimization pipeline is the `PassBuilder` class.
    This class knows about all of the registered Passes and can construct a Pass pipeline
    from a textual description. We use this class to either create the Pass pipeline
    from a description given on the command line or use a default pipeline based on
    the requested optimization level. We also support the use of Pass plugins, such
    as the `countir` Pass plugin, which we discussed in the previous section. With
    this, we mimic part of the functionality of the `opt` tool and also use similar
    names for the command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: The `PassBuilder` class populates an instance of a `ModulePassManager` class,
    which is the Pass manager to hold the constructed Pass pipeline and actually run
    it. The code generation Passes still use the old Pass manager; therefore, we have
    to retain the old Pass manager for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation, we extend the `tools/driver/Driver.cpp` file from our
    `tinylang` compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use new classes, so we begin by adding new `include` files. The `llvm/Passes/PassBuilder.h`
    file provides the definition of the `PassBuilder` class. The `llvm/Passes/PassPlugin.h`
    file is required for plugin support. Finally, the `llvm/Analysis/TargetTransformInfo.h`
    file provides a Pass that connects IR-level transformations with target-specific
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To use certain features of the new Pass manager, we add three command-line
    options, using the same names as the `opt` tool. The `--passes` option enables
    the textual specification of the Pass pipeline, and the `--load-pass-plugin` option
    enables the use of Pass plugins. If the `--debug-pass-manager` option is given,
    then the Pass manager prints out information about the executed Passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The user influences the construction of the Pass pipeline with the optimization
    level. The `PassBuilder` class supports six different optimization levels: one
    level with no optimization, three levels for optimizing the speed, and two levels
    for reducing the size. We capture all of these levels in one command-line option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin mechanism of LLVM supports a static plugin registry, which is created
    during the configuration of the project. To make use of this registry, we include
    the `llvm/Support/Extension.def` database file to create the prototype for the
    functions, which returns the plugin information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace the existing `emit()` function with a new version. We declare the
    required `PassBuilder` instance at top of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the support for the Pass plugins given on the command line, we
    loop through the list of plugin libraries given by the user and try to load the
    plugin. We emit an error message if this fails; otherwise, we register the Passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The information from the static plugin registry is used in a similar way to
    register those plugins with our `PassBuilder` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to declare variables for the different analysis managers. The only
    parameter is the debug flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we populate the analysis managers with calls to the respective `register`
    method on the `PassBuilder` instance. Through this call, the analysis manager
    is populated with the default analysis Passes and also runs registration callbacks.
    We also make sure that the function analysis manager uses the default alias-analysis
    pipeline and that all analysis managers know about each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MPM` module Pass manager holds the Pass pipeline that we construct. The
    instance is initialized with the debug flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement two different ways to populate the module Pass manager with the
    Pass pipeline. If the user provided a Pass pipeline on the command line, that
    is, they used the `--passes` option, then we use this as the Pass pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we use the chosen optimization level to determine the Pass pipeline
    to construct. The name of the default Pass pipeline is `default`, and it takes
    the optimization level as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pass pipeline to run transformations on the IR code is now set up. We need
    an open file to write the result to. The system assembler and LLVM IR output are
    text based, so we should set the `OF_Text` flag for both of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For the code generation, we have to use the old Pass manager. We simply declare
    the `CodeGenPM` instances and add the Pass that makes target-specific information
    available at the IR transformation level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To output the LLVM IR, we add a Pass that just prints the IR into a stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we let the `TargetMachine` instance add the required code generation
    Passes, directed by the `FileType` value that we Pass as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After all of this preparation, we are now ready to execute the Passes. First,
    we run the optimization pipeline on the IR module. Next, the code generation Passes
    are run. Of course, after all this work, we want to keep the output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a lot of code, but it was straightforward. Of course, we also have
    to update the dependencies in the `tools/driver/CMakeLists.txt` build file. Besides
    adding the target components, we add all the transformation and code generation
    components from LLVM. The names roughly resemble the directory names where the
    source is located. The component name is translated to the link library name during
    the configuration process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Our compiler driver supports plugins, and we announce the following support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way as before, we have to link against our own libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: These are necessary additions to the source code and the build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the extended compiler, change into your `build` directory and type
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Changes to the files of the build system are automatically detected, and `cmake`
    is run before we compile and link our changed source. In case you need to rerun
    the configuration step, please follow the instructions located in [*Chapter 2*](B15647_02_ePub_RK.xhtml#_idTextAnchor032),
    *Touring the LLVM Source,* in the *Compiling the tinylang application* section.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have used the options for the `opt` tool as a blueprint, you should
    try running `tinylang` with the options to load a Pass plugin and run the Pass,
    as we did in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: With the current implementation, we can either run a default Pass pipeline or
    construct one ourselves. The latter is very flexible but, in almost all cases,
    overkill. The default pipeline runs very well for C-like languages. What is missing
    is a way to extend the Pass pipeline. In the next section, we will explain how
    to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Pass pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we used the `PassBuilder` class to create a Pass pipeline,
    either from a user-provided description or a predefined name. Now, we will look
    at another way to customize the Pass pipeline: using **extension points**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the construction of the Pass pipeline, the Pass builder allows you to
    add Passes contributed by the user. These places are called extension points.
    A number of extension points exist, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline start extension point allows you to add Passes at the beginning
    of the pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peephole extension point allows you to add Passes after each instance of
    the instruction combiner Pass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other extension points exist, too. To employ an extension point, you register
    a callback. During the construction of the Pass pipeline, your callback is run
    at the defined extension point and can add a Pass to the given Pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a callback for the pipeline start extension point, you call the
    `registerPipelineStartEPCallback()` method of the `PassBuilder` class. For example,
    to add our `CountIRPass` Pass to the beginning of the pipeline, you need to adapt
    the Pass to be used as a module Pass with a call to the `createModuleToFunctionPassAdaptor()`
    template function, and then add the Pass to the module Pass manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can add this snippet in the Pass pipeline setup code at any point before
    the pipeline is created, that is, before the `parsePassPipeline()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very natural extension to what we have done in the previous section is to
    let the user Pass a pipeline description for an extension point on the command
    line. The `opt` tool allows this, too. Let''s do this for the pipeline start extension
    point. First, we add the following code to the `tools/driver/Driver.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a new command line for the user to specify the pipeline description.
    Again, we take the option name from the `opt` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a lambda function as a callback is the most convenient way. To parse
    the pipeline description, we call the `parsePassPipeline()` method of the `PassBuilder`
    instance. The Passes are added to the `PM` Pass manager and given as an argument
    to the lambda function. If there is an error, we print an error message without
    stopping the application. You can add this snippet after the call to the `crossRegisterProxies()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To allow the user to add Passes at every extension point, you need to add the
    preceding code snippet for each extension point.
  prefs: []
  type: TYPE_NORMAL
- en: It's now a good time to try out the different `pass manager` options. With the
    `--debug-pass-manager` option, you can follow which Passes are executed in which
    order. You can print the IR before or after each Pass is invoked using the `--print-before-all`
    and `--print-after-all` options. If you create your own Pass pipeline, then you
    can insert the `print` Pass in points of interest. For example, try the `--passes="print,inline,print"`
    option. You can also use the `print` Pass to explore the various extension points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it is possible to add more than one Pass to the Pass manager in this
    fashion. The `PassBuilder` class also uses the `addPass()` method during the construction
    of the Pass pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: New functionality in LLVM 12 – running extension point callbacks
  prefs: []
  type: TYPE_NORMAL
- en: Because the Pass pipeline is not populated for optimization level `O0`, the
    registered extension points are not called. If you use the extension points to
    register Passes, which should also run at the `O0` level, this is problematic.
    In LLVM 12, the new `runRegisteredEPCallbacks()` method can be called to run the
    registered extension point callbacks, resulting in a Pass manager populated only
    with the Passes registered through the extension points.
  prefs: []
  type: TYPE_NORMAL
- en: With the addition of the optimization pipeline to `tinylang`, you can create
    an optimizing compiler such as clang. The LLVM community works on improving the
    optimizations and the optimization pipeline with each release. Because of this,
    it is very seldom that the default pipeline is not used. Most often, new Passes
    are added to implement certain semantics of the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a new Pass for LLVM. You ran the
    Pass using a Pass pipeline description and an extension point. You extended your
    compiler with the construction and execution of a Pass pipeline similar to clang,
    turning `tinylang` into an optimizing compiler. The Pass pipeline allows you to
    add Passes at extension points, and you learned how to register Passes at these
    points. This enables you to extend the optimization pipeline with your own developed
    Passes or existing Passes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how LLVM generates machine instructions
    from the optimized IR.
  prefs: []
  type: TYPE_NORMAL
