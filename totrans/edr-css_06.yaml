- en: Chapter 6. Dealing with State Changes in ECSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we considered project organisation and how to understand
    and apply the ECSS class naming conventions. In this chapter we will move our
    focus to how ECSS deals with active interfaces and how we can facilitate style
    changes in a rationale and accessible manner.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of web applications need to deal with states.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s just crystallise what we mean by *states*. Consider some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A user clicks a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value in an interface is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An area of an interface is disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A widget in the interface is busy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An entered value exceeds allowable values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A section of the application starts containing live data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these eventualities can be defined as **state changes**. State changes that
    we typically need to communicate to the user. As such they are changes that need
    to be communicated to the DOM, and subsequently our style sheets need some sane
    way of catering to these needs.
  prefs: []
  type: TYPE_NORMAL
- en: How can we define these state changes in a consistent and considered manner?
  prefs: []
  type: TYPE_NORMAL
- en: How ECSS used to handle state change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [Chapter 3](ch03.html "Chapter 3. Implementing Received Wisdom"), *Implementing
    Received Wisdom*, I related how much I liked the SMACSS approach of communicating
    state. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Indicates that on, or somewhere below this node, the *mini cart* is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would communicate that the Component or one within it is showing some value
    (that was previously hidden).
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, that was how I communicated state when applying ECSS. I used
    a micro-namespaced class, in addition to any existing classes on the node to communicate
    this state. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How ECSS used to handle state change](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A node using these classes in the DOM might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Historically, changing a class in the DOM, especially near the root of the
    DOM has been discouraged. Doing so invalidates the render tree meaning the browser
    has to perform a whole bunch of re-calculation. However, things are improving.
    Recent work by Antii Koivisto in WebKit (which powers iOS and Safari browsers)
    means that such changes are now *near optimal*. Interested parties can read the
    WebKit Changeset for class changes here: [http://trac.webkit.org/changeset/196383](http://trac.webkit.org/changeset/196383)
    and attribute selectors, such as `aria-*` here: [http://trac.webkit.org/changeset/196629](http://trac.webkit.org/changeset/196629)'
  prefs: []
  type: TYPE_NORMAL
- en: Switching to WAI-ARIA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, having researched ARIA a little for another book, (*Responsive Web
    Design with HTML5 and CSS3* in case you are interested) it struck me that if this
    information has to go in the DOM purely for styling hooks, it may as well lift
    a little more weight while it's there.
  prefs: []
  type: TYPE_NORMAL
- en: 'These same styling hooks can actually be placed in the DOM as *WAI-ARIA* ([https://www.w3.org/TR/wai-aria/](https://www.w3.org/TR/wai-aria/))
    states. The [States and Properties](http://www.w3.org/TR/wai-aria/states_and_properties)
    section of WAI-ARIA describes the W3C''s standardised manner in which to communicate
    states and properties to assistive technology within an application. In the opening
    section of the abstract description for WAI-ARIA, it contains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*These semantics are designed to allow an author to properly convey user interface
    behaviors (sic) and structural information to assistive technologies in document-level
    markup*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While the specification is aimed at helping communicate state and properties
    to users with disability (via assistive technology) it serves the need of ECSS
    beautifully. What a great result! We get to improve the accessibility of our web
    application, while also gaining a clearly defined, well considered lexicon for
    communicating the states we need in our application logic. Here''s the prior example
    re-written with aria to communicate state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Class handles the aesthetics of the button. The `aria-*` attribute communicates
    the state (if any) of that node or its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript application land, the only change needed is shifting from `classList`
    amendments for state changes to `setAttribute` amendments. For example, to set
    our `button` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that separating concerns in this manner does require an additional
    *touchpoint* in your JavaScript. If you absolutely, positively want the fastest/easiest
    way to handle a state change, doing it once with a `classList` update will be
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: ARIA attributes as CSS selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our preferred CSS syntax, writing that change within a single set of braces
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the ampersand (`&`) as a parent selector and the attribute selector to
    leverage the enhanced specificity having the aria attribute on the node provides.
    Then we can just style the changes as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to nest state changes within a rule in this manner provides increased
    developer ergonomics. The intention is that a rule is only defined at root level
    once throughout the entire application styles. This provides a single source of
    truth to define all possible eventualities pertaining to that class. For more
    information, ensure you read [Chapter 8](ch08.html "Chapter 8. The Ten Commandments
    of Sane Style Sheets"), *The Ten Commandments of Sane Style Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a related note, the *CSS Selectors Level 4 specification* ([https://drafts.csswg.org/selectors-4/#attribute-case](https://drafts.csswg.org/selectors-4/#attribute-case))
    makes provision for case insensitivity by using a `i` flag before the closing
    square bracket. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`css .co-Button { background-color: $color-button-passive; &[aria-selected="true"
    i] { background-color: $color-button-selected; } }` This allows any case value
    variant of the attribute to pass (by default it is case sensitive)'
  prefs: []
  type: TYPE_NORMAL
- en: States and properties, redone with ARIA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section of the WAI-ARIA specification describes *Widget Attributes*, these
    contain many of the common states needed when working with a web application and
    rapidly changing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the examples given at the beginning of this chapter re-written using
    ARIA:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aria-disabled="true"` (used instead of `is-Suspended`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aria-live="polite"` (used instead of `.is-Live`, the polite value is one of
    *three possible values* ([https://www.w3.org/TR/wai-aria/states_and_properties#aria-live](https://www.w3.org/TR/wai-aria/states_and_properties#aria-live))
    to describe how updates should be communicated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aria-current="true"` (this one is currently proposed for WAI-ARIA 1.1 [http://www.w3.org/TR/wai-aria-1.1/#aria-current](http://www.w3.org/TR/wai-aria-1.1/#aria-current))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aria-busy="true"` (used instead of `is-Busy`, to indicate the element and
    it''s subtree (if any) are busy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty more and the specification is, by W3C specification standards,
    easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: If ARIA can't be used
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If, for whatever reason, you aren''t able to use `aria-*` attributes to communicate
    state in a site or application. I now tend to lean towards naming selectors without
    using the micro-namespace to designate state. For example, instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '![If ARIA can''t be used](img/Warning-image-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'I would instead recommend using a variant version of the selector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This keeps the context of the module in tact and merely indicates a variant
    of this same class is being applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should be aware that there is a *gotcha* when using attribute selectors
    to communicate state. Certain older versions of Android (Android 4.0.3 stock browser
    as an example) don''t force a re-calculation of styles when an attribute value
    is changed. The upshot of this is that any styles that rely on a attribute won''t
    work dynamically (for example when toggled with JavaScript). There are two possible
    workarounds. Firstly, you can toggle a class somewhere in the DOM at the same
    time you change the attribute. Alternatively, you can initiate the attribute selectors
    by listing empty rules for each somewhere in the CSS. Even chaining together works
    e.g. `[aria-thing][aria-thing2]{}`. Either option certainly adds an undesirable
    complication to proceedings. A bug report of this behaviour can be found for WebKit
    here: [https://bugs.webkit.org/show_bug.cgi?id=64372](https://bugs.webkit.org/show_bug.cgi?id=64372)
    and the workaround mentioned came courtesy of this Stack Overflow question: [http://stackoverflow.com/questions/6655364/css-attribute-selector-descendant-gives-a-bug-in-webkit/](http://stackoverflow.com/questions/6655364/css-attribute-selector-descendant-gives-a-bug-in-webkit/)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using WAI-ARIA states to communicate changes in the DOM provides styling hooks
    that are as useful and easy to use as standard HTML classes. Although purely preference,
    I'm also a fan of the fact that an entirely different selector is used to communicate
    state in the style sheets; it is simpler to spot within a rule.
  prefs: []
  type: TYPE_NORMAL
- en: None of those prior factors really get you anything new. What using WAI-ARIA
    states will do, virtually for free, is start to provide a better means of communicating
    your web application state to users of assistive technology. If money talks, consider
    also that by using WAI-ARIA you are widening your product up to a greater number
    of users (see the additional info below).
  prefs: []
  type: TYPE_NORMAL
- en: As such, using WAI-ARIA states and properties, is the recommended means of communicating
    state in projects adopting a ECSS methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information and statistics from the Royal National Institute for
    the Blind (RNIB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *RNIB* ([http://rnib.org.uk/](http://rnib.org.uk/)) was kind enough to
    supply a little data regarding the number of blind people here in the UK. These
    may prove useful when arguing/considering a case for using ARIA states in your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: There are just over 84,000 registered blind and partially sighted people of
    working age in the UK (out of an estimated population of around 64 million).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, according to the government''s Labour Force Survey, around 185,000
    people of working age in the UK have a self-reported *seeing difficulty*. This
    includes people whose sight loss would not be eligible for registration, but which
    is still of sufficient severity to affect their everyday lives. It also includes
    those who do not consider themselves as disabled. Of the 185,000:'
  prefs: []
  type: TYPE_NORMAL
- en: 113,000 consider themselves as long-term disabled with a *seeing difficulty*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 72,000 consider themselves as not disabled with a *seeing difficulty*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimated number of people in the UK living with sight loss in 2011 - 1,865,900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimated number of people in the UK predicted to be living with sight loss
    in 2020 - 2,269,700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimated number of adults with diabetes, a major cause of visual impairments
    in 2012 - 3,866,980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
