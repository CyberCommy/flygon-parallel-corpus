- en: Chapter 7.  Flink Graph API - Gelly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are living in the era of social media where everyone is connected to each
    other by some means. Every single object is in a relationship with another. Facebook
    and Twitter are excellent examples of social graphs, where *x* is friends with
    *y* and *p* is following *q*, and so on. These graphs are so huge that we need
    an engine which can process them efficiently. If we are surrounded by such graphs,
    it is very important to analyze them in order to get more insights about their
    relationships and next-level relationships.
  prefs: []
  type: TYPE_NORMAL
- en: There are various technologies in the market which help us analyze such graphs,
    for example, graph databases such as Titan and Neo4J, graph processing libraries
    such as Spark GraphX and Flink Gelly, and so on. In this chapter, we are going
    to understand the details of graphs and how we can use Flink Gelly to analyze
    graph data.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: What is a graph?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the computer science field, a graph is a means of representing relationships
    amongst the object. It consists of a set of vertices connected via edges. **Vertices**
    are objects on a plane, identified by co-ordinates or some unique id/name while
    **Edges** are the connecting links between the vertices having certain weights
    or the relationship. A graph can be directed or undirected. In a directed graph,
    the edges are directed from one vertex to other while there is no direction for
    edges in undirected graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the basic representation of a directed graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a graph?](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A graph structure can be used for various purposes, such as finding the shortest
    path to a certain destination, or it could be used for finding out the degree
    of relationship between certain vertices, or it could be used for finding out
    the nearest neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's dive deep into Flink's Graph API - Gelly.
  prefs: []
  type: TYPE_NORMAL
- en: Flink graph API - Gelly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flink provides a graph processing library called Gelly to simplify the development
    of graph analysis. It provides data structures to store and represent graph data
    and it provides methods to analyze the graphs. In Gelly, we can transform graphs
    from one state to another using Flink's higher-level functions. It also provides
    a set of algorithms used for detailed graph analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Gelly is currently available as a part of the Flink libraries, so we need to
    add a Maven dependency in our programs to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at various options we have in order to use Gelly effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Graph representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Gelly, a graph is represented as dataset of nodes and datasets of edges.
  prefs: []
  type: TYPE_NORMAL
- en: Graph nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A graph node is represented by a `Vertex` data type. A `Vertex` data type consists
    of a unique ID and an optional value. A unique ID should implement a comparable
    interface because, while doing graph processing, we compare the nodes by their
    IDs. A `Vertex` can have a value or it can have a null value as well. A null-valued
    vertex is defined by the type, `NullValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets show how to create nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Graph edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, an edge can be defined by the type, `Edge`. An `Edge` has a source
    node ID, a destination node ID, and an optional value. The value represents the
    degree or weight of relationship. Source and Target Ids need to be of same type.
    Edges with no value can be defined using `NullValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets shows `Edge` definitions in Java and Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In Gelly, a graph is always directed from a source to a destination vertex.
    In order to show an undirected graph, we should add another edge representing
    a connection from the destination to the source and back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet represents a directed graph in Gelly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is its visual representation for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph edges](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet represents the vertex and edge definitions for an
    undirected graph in Gelly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is its visual representation for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph edges](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graph creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Flink Gelly, graphs can be created in multiple ways. The following are some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: From dataset of edges and vertices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippets represent how we create graphs using the dataset
    of edges and optional vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From dataset of tuples representing edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippets represent how we create graphs using the dataset
    of Tuple2 representing edges. Here Gelly automatically converts Tuple2 into edges
    having source and destination vertices IDs and null value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippets represent how we create graphs using the dataset
    of Tuple3 representing edges. Here vertices are represented using Tuple2 while
    edge using Tuple3 are represented with information about source, destination vertex,
    and weight. We can also read the set of values from CSV files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From CSV files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippets represent how we create graphs using the CSV file
    reader. CSV files should have data represented in the form vertices and edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet creates a graph from CSV files of the format, source,
    target, weight, for edges and ID, name for vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a vertex value initializer as well by defining a `map` function
    while creating the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From collection lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also create graphs from a collection of list. The following code snippet
    show how we create graphs from a list of edges and vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If no vertex input is provided, then we can think of providing a `map` initialization
    function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Graph properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows the set of methods available to retrieve graph properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **In Java** | **In Scala** |'
  prefs: []
  type: TYPE_TB
- en: '| `getVertices` dataset | `DataSet<Vertex<K, VV>> getVertices()` | `getVertices:
    DataSet[Vertex[K, VV]]` |'
  prefs: []
  type: TYPE_TB
- en: '| `getEdges` dataset | `DataSet<Edge<K, EV>> getEdges()` | `getEdges: DataSet[Edge[K,
    EV]]` |'
  prefs: []
  type: TYPE_TB
- en: '| `getVertexIds` | `DataSet<K> getVertexIds()` | `getVertexIds: DataSet[K]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getEdgeIds` | `DataSet<Tuple2<K, K>> getEdgeIds()` | `getEdgeIds: DataSet[(K,
    K)]` |'
  prefs: []
  type: TYPE_TB
- en: '| Get dataset of vertex IDs and `inDegrees` for all vertices | `DataSet<Tuple2<K,
    LongValue>> inDegrees()` | `inDegrees: DataSet[(K, LongValue)]` |'
  prefs: []
  type: TYPE_TB
- en: '| Get dataset of vertex IDs and `outDegrees` for all vertices | `DataSet<Tuple2<K,
    LongValue>> outDegrees()` | `outDegrees: DataSet[(K, LongValue)]` |'
  prefs: []
  type: TYPE_TB
- en: '| Get dataset of vertex IDs and in, `getDegree` for all vertices | `DataSet<Tuple2<K,
    LongValue>> getDegrees()` | `getDegrees: DataSet[(K, LongValue)]` |'
  prefs: []
  type: TYPE_TB
- en: '| Get `numberOfVertices` | `long numberOfVertices()` | `numberOfVertices: Long`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Get `numberOfEdges` | `long numberOfEdges()` | `numberOfEdges: Long` |'
  prefs: []
  type: TYPE_TB
- en: '| `getTriplets` provides triplets consisting of source vertex, target vertex
    and the edge | `DataSet<Triplet<K, VV, EV>> getTriplets()` | `getTriplets: DataSet[Triplet[K,
    VV, EV]]` |'
  prefs: []
  type: TYPE_TB
- en: Graph transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gelly provides various transformation operations which helps transforming graphs
    from one form to another. The following are some transformations we can do by
    using Gelly.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gelly provides map transformations which keeps the vertices and edge IDs intact
    and transforms the values as per given in the function. This operation always
    returns a new graph. The following code snippet shows how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Translate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Translate is a special function that allows translating vertex IDs, vertex values,
    edge IDs, and so on. Translation is performed using a custom map function provided
    by the user. The following code snippet shows how we use the translate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FilterFunction` can be used to filter out vertices and edges based on certain
    conditions. `filterOnEdges` will create a sub-graph of the original one. In this
    operation, the vertices dataset remains unchanged. Similarly, `filterOnVertices`
    applies the filter on vertices values. In this case, edges that do not find target
    nodes are removed. The following code snippet shows how we use `FilterFunction`
    in Gelly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a graphical representation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filter](img/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the following diagram shows `filterOnEdges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filter](img/image_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `join` operation helps in joining vertices and edge datasets with other
    datasets. The `joinWithVertices` method joins with vertex IDs and the first field
    of Tuple2\. The `join` method returns a new graph. Similarly, input datasets can
    be joined with edges. There are three ways we can join edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '`joinWithEdges`: Joins graphs with the Tuple3 dataset on composite keys of
    both source and target vertex IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joinWithEdgeOnSource`: Joins with the Tuple2 dataset on the source key and
    first attribute of the Tuple2 dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joinWithEdgeOnTarget`: Joins with the Tuple2 dataset on the target key and
    first attribute of the Tuple2 dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to use joins in Gelly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reverse` method returns a graph with edge direction reverted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to use the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Undirected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `undirected` method returns a new graph with additional edges opposite to
    the original ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to use the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Union
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `union` operation returns a graph combining vertices and edges of two graphs.
    It joins the vertices on vertex IDs. Duplicate vertices are removed while edges
    are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a graphical representation of the `union` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Union](img/image_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Intersect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `intersect` method performs the intersection of edges from given graph datasets.
    Two edges are considered equal if they have the same source and target vertices.
    The method also contains distinct parameter; if set to `true`, it only returns
    distinct graphs. The following are some code snippets show casing the `intersect`
    method usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Graph mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gelly provides methods to add/remove edges and vertices to existing graphs.
    Let's try to understand these mutations one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mutation** | **In Java** | **In Scala** |'
  prefs: []
  type: TYPE_TB
- en: '| Add vertex. | `Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex)` |
    `addVertex(vertex: Vertex[K, VV])` |'
  prefs: []
  type: TYPE_TB
- en: '| Add list of vertices. | `Graph<K, VV, EV> addVertices(List<Vertex<K, VV>>
    verticesToAdd)` | `addVertices(verticesToAdd: List[Vertex[K, VV]])` |'
  prefs: []
  type: TYPE_TB
- en: '| Add edges to the graph. This adds new edges and vertices if they don''t exist
    already. | `Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target,
    EV edgeValue)` | `addEdge(source: Vertex[K, VV], target: Vertex[K, VV], edgeValue:
    EV)` |'
  prefs: []
  type: TYPE_TB
- en: '| Add edges, if vertices do not exist then the edge is considered invalid.
    | `Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges)` | `addEdges(edges: List[Edge[K,
    EV]])` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove vertex, removes edges and vertices from the given graph. | `Graph<K,
    VV, EV> removeVertex(Vertex<K, VV> vertex)` | `removeVertex(vertex: Vertex[K,
    VV])` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove multiple vertices from the given graph. | `Graph<K, VV, EV> removeVertices(List<Vertex<K,
    VV>> verticesToBeRemoved)` | `removeVertices(verticesToBeRemoved: List[Vertex[K,
    VV]])` |'
  prefs: []
  type: TYPE_TB
- en: '| Removes all edges that match the given edge. | `Graph<K, VV, EV> removeEdge(Edge<K,
    EV> edge)` | `removeEdge(edge: Edge[K, EV])` |'
  prefs: []
  type: TYPE_TB
- en: '| Removes edges that match the given list of edges. | `Graph<K, VV, EV> removeEdges(List<Edge<K,
    EV>> edgesToBeRemoved)` | `removeEdges(edgesToBeRemoved: List[Edge[K, EV]])` |'
  prefs: []
  type: TYPE_TB
- en: Neighborhood methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Neighborhood methods help in performing operations related to its first hop
    neighborhood. Methods such as `reduceOnEdges()` and `reduceOnNeighbours()` can
    be used to perform aggregate operations. The first one is used to compute aggregation
    on neighboring edges of the vertex while the latter is used to compute aggregation
    on neighboring vertices. The neighbor scope can be defined by providing edge directions,
    and we have options such as `IN`, `OUT`, or `ALL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example where we need to get the maximum weight of all vertices
    for `OUT` direction edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neighborhood methods](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we want to find out the maximum weighted `OUT` edge for each vertex. Gelly
    provides us with neighborhood methods with which we can find the desired result.
    The following is the code snippet for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Gelly solves this by first segregating each vertex and finding out the maximum
    weighted edge for each vertex. The following is a graphical representation for
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Neighborhood methods](img/image_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can also write one more function to sum the values of incoming
    edges in all neighborhoods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Graph validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gelly provides us with a utility to validate the input graph before sending
    it for processing. In various situations, we first need to validate the graph
    with certain conditions and only then send it for further processing. Validations
    could be checking if the graph contains duplicate edges or checking if the graph
    structure is bipartite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bipartite or Bigraph is a graph whose vertices can be divided into two distinct
    sets such that every vertex in each set has an edge connecting to vertex in another
    set. A simple example of bipartite graph is a graph of Basket Ball Players and
    the teams they play for. Here we will have two sets as players and teams and each
    vertex in player set would have edge to team set. More details on Bipartite graph
    can be read here [https://en.wikipedia.org/wiki/Bipartite_graph](https://en.wikipedia.org/wiki/Bipartite_graph).
  prefs: []
  type: TYPE_NORMAL
- en: We can also define custom validate methods to get the desired output. Gelly
    also provides a built-in validator called `InvalidVertexValidator`. This checks
    if the edge set contains validate vertex IDs. The following are some code snippets
    showcasing its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Iterative graph processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gelly enhances Flink''s iterative processing capabilities to support large
    scale graph processing. Currently it supports implementation of the following
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertex-Centric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter-Gather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gather-Sum-Apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by understanding these models in the context of Gelly.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex-Centric iterations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggest, these iterations are built thinking the vertex is in the
    center. Here each Vertex processes the same user-defined function in parallel.
    Each step of execution is called a **superset**. A vertex can send a message to
    another vertex as long as it knows its unique ID. This message would be used as
    input to the next superset.
  prefs: []
  type: TYPE_NORMAL
- en: To use Vertex-Centric iterations, the user needs to provide a `ComputeFunction`.
    We can also define an optional `MessageCombiner` to reduce the cost of communication.
    We can solve problems, such as Single Source Shortest Path in which we need to
    find the shortest path from source vertex to all other vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single Source Shortest Path is where we try to minimize the sum of weights joining
    two distinct vertices. A very simple example could be a graph of cities and flight
    routes. In this case, SSSP algorithm will try to find the shortest distance connecting
    two cities considering the available flight routes. More details on SSSP can be
    found at [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem).
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippets show how we solve the Single Source Shortest Path
    problem using Gelly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can use following configurations in Vertex-Centric iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name: `setName()` | Sets the name of Vertex-Centric iteration. Can be seen
    in logs. |'
  prefs: []
  type: TYPE_TB
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregator: `registerAggregator()` | Registers custom defined aggregator
    function to be used by the computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  prefs: []
  type: TYPE_TB
- en: Scatter-Gather iterations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scatter-Gather iterations also works in superset iterations and also have a
    vertex at its center and we also define a function that are executed in parallel.
    Here each vertex has two important things to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scatter**: Scatter produces the message it needs to send to other vertices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gather**: Gather updates the vertex value from the messages it received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gelly provides methods for scatter and gather. The user needs to implement only
    these two functions to make use of these iterations. `ScatterFunction` produces
    messages for the rest of the vertices while `GatherFunction` computes the updated
    value for the vertex based on the messages it has received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can solve the Single Source Shortest
    Path problem using Gelly-Scatter-Gather iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure Scatter-Gather iterations using the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name: `setName()` | Sets the name of scatter-gather iteration. Can be seen
    in logs. |'
  prefs: []
  type: TYPE_TB
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregator: `registerAggregator()` | Registers the custom defined aggregator
    function to be used by the computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  prefs: []
  type: TYPE_TB
- en: '| Number of vertices: `setOptNumVertices()` | Accesses the total no. of vertices
    in an iteration. |'
  prefs: []
  type: TYPE_TB
- en: '| Degrees: `setOptDegrees()` | Sets the number of in/out degrees to be reached
    within an iteration. |'
  prefs: []
  type: TYPE_TB
- en: '| Messaging directions: `setDirection()` | By default we only consider out
    degrees for processing but we can change that by setting this property. Options
    are `in`, `out`, and `all`. |'
  prefs: []
  type: TYPE_TB
- en: Gather-Sum-Apply iterations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the previous two models, **Gather-Sum-Apply** (**GSA**) iterations are
    also synchronized in iterative steps. Each superset consists of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gather**: A user defined function executed on edges and each neighbor, producing
    a partial value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum**: Partial values calculated in earlier step would be aggregated in this
    step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Apply**: Each vertex value is updated by applying the function on the aggregated
    value from the previous step and the current value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will try to solve the Single Source Shortest Path using the GSA iteration.
    To use this, we need to define custom functions for gather, sum, and apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure GSA iterations using the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Name: `setName()` | Sets the name of the GSA iteration. Can be seen in logs.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Aggregator: `registerAggregator()` | Registers the custom defined aggregator
    function to be used by the computation function. |'
  prefs: []
  type: TYPE_TB
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  prefs: []
  type: TYPE_TB
- en: '| Number of vertices: `setOptNumVertices()` | Accesses the total number of
    vertices in an iteration. |'
  prefs: []
  type: TYPE_TB
- en: '| Neighbour directions: `setDirection()` | By default we only consider `OUT`
    degrees for processing but we can change that by setting this property. Options
    are `IN`, `OUT`, and `ALL`. |'
  prefs: []
  type: TYPE_TB
- en: Use case - Airport Travel Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider a use case where we have data for the airports and the distance
    between them. In order to travel to certain destination from a particular airport,
    we have to find the shortest path between the two. Our airport data looks like
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Id | Airport name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| s01 | A |'
  prefs: []
  type: TYPE_TB
- en: '| s02 | B |'
  prefs: []
  type: TYPE_TB
- en: '| s03 | C |'
  prefs: []
  type: TYPE_TB
- en: '| s04 | D |'
  prefs: []
  type: TYPE_TB
- en: '| s05 | E |'
  prefs: []
  type: TYPE_TB
- en: 'The distance information between the airport looks like as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| From | To | Distance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| s01 | s02 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| s01 | s02 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| s01 | s03 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| s01 | s04 | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| s04 | s11 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| s05 | s15 | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| s06 | s17 | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| s08 | s09 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| s08 | s09 | 12 |'
  prefs: []
  type: TYPE_TB
- en: Now let's use Gelly to find the Single Source Shortest Path.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have options to choose among the three algorithms we learnt in previous
    section. In this example, we will use Vertex-Centric iterations method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve the Single Source Shortest Path, we have to first load the
    data from CSV files as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we run Vertex-Centric iteration as discussed in the previous section on
    the graph we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of Compute function and Combiner is similar to what we looked
    in the earlier section. When we run this code, we will get the answer for SSSP
    from given source vertex.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code and sample data for this use case is available at [https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly](https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly)
  prefs: []
  type: TYPE_NORMAL
- en: In general, all three iterations ways look similar but they have minute differences.
    One needs to really think which algorithm to use based on use case. Here is some
    good reading about the this thought [https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison](https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various aspects of the graph processing API provided
    by the Flink Gelly library. We learnt how to define graphs, load data, and process
    it. We also looked at various transformations one can do on a graph. Finally we
    learnt details of iterative graph processing options that Gelly provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to execute Flink applications on Hadoop
    and YARN.
  prefs: []
  type: TYPE_NORMAL
