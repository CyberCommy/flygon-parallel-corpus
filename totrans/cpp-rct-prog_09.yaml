- en: Reactive GUI Programming Using Qt/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt (pronounced *cute*) ecosystem is a comprehensive C++ based framework
    for writing cross-platform and multiplatform GUI applications. If you write your
    programs using the portable core of the library, you can leverage the *Write Once
    and Compile Everywhere* paradigm supported by the framework. In some cases, people
    use the platform-specific features, such as support for the ActiveX programming
    model for writing Windows-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: We come across situations where Qt is preferred over MFC for writing applications
    in Windows. A plausible reason for this could be ease of programming, as Qt uses
    a very tiny subset of C++ language features for its library. The original goal
    of the framework was, of course, cross-platform development. Qt's single source
    portability across platforms, feature richness, availability of source code, and
    well-updated documentation, make it a very programmer-friendly framework. This
    has helped it thrive for more than two decades, ever since its first release,
    in 1995.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides a complete interface environment, with support for developing multiplatform
    GUI applications, Webkit APIs, media streamers, filesystem browsers, OpenGL APIs,
    and so on. Covering the full features of this wonderful library would take a book
    of its own. The purpose of this chapter is to introduce how to write reactive
    GUI applications, by leveraging Qt and the RxCpp library. We have already covered
    the core of the Reactive programming model in Chapter 7, *Introduction to Data
    Flow Computation and the RxCpp Library*, and Chapter 8, *RxCpp – the Key Elements*.
    Now, it is time to put what we learned in the previous chapters into practice!
    The Qt framework itself has a robust event processing system, and one needs to
    learn these library features before he or she can incorporate RxCpp constructs
    into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to Qt GUI programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World – Qt program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt event model, with signals/slots/MOC – an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the RxCpp library with the Qt event model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Custom Operators in Rxcpp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick introduction to Qt GUI programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is a cross-platform application development framework for writing software
    that can run on numerous platforms as a native application without changing much
    code, with native platform capabilities and speed. Aside from GUI applications,
    we can also write console or command-line applications using the framework—but
    the primary use cases are graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Although applications using Qt are usually written in C++,  QML bindings to
    other languages also exist. Qt simplifies many aspects of C++ development, using
    comprehensive and powerful APIs and tools. Qt supports many compiler toolchains,
    such as the GCC C++ compiler and the Visual C++ compiler. Qt also provides Qt
    Quick (which includes QML, a declarative scripting language based on ECMAScript)
    to write logic. This helps with rapid application development for mobile platforms,
    although the logic can be written using native code for the best possible performance.
    The ECMAScript/C++ combination provides the best of declarative development and
    native code speed.
  prefs: []
  type: TYPE_NORMAL
- en: Qt is currently being developed and maintained by The Qt Company, and the framework
    is available with open source and proprietary licenses. When first launched, Qt
    used its own paint engine and controls by emulating the look and feel of a different
    platform (thanks to the custom paint engine, one can create a Windows look and
    feel under GNU Linux). This helped developers easily port across platforms, because
    of the minimal target platform dependency. As the emulation was imperfect, Qt
    started to use native-style APIs for the platforms, with its own native widget
    set. This resolved the issue with emulation of Qt's own paint engine, but at the
    cost of no more uniform look and feel across the platforms. The Qt library has
    an excellent binding with the Python programming language, christened as PyQt.
  prefs: []
  type: TYPE_NORMAL
- en: There are some essential things a programmer must understand before he/she leverages
    the library. In the following sections, we will quickly cover aspects of the Qt
    object model, signals and slots, the event system, and the meta-object system.
  prefs: []
  type: TYPE_NORMAL
- en: Qt object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a GUI framework, both run-time efficiency and high-level flexibility are
    key factors. The standard C++ object model provides very efficient run-time support,
    but its static nature is inflexible in certain problematic domains. The Qt framework
    combines the speed of C++ with the flexibility of the Qt object model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt object model supports the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signals and slots**, for seamless object communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queryable and designable **object properties**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful events and event filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful internally driven timers, enabling smooth, non-blocking work in many
    of the tasks in an event-driven GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internationalization** with contextual string translation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarded pointers (**QPointers**) that are automatically set to 0 when the referenced
    object is destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **dynamic cast** working across library boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these features are implemented as standard C++ classes, based on inheritance
    from `QObject`. Others, like signals and slots and the object properties system,
    require the meta-object system provided by Qt's own **Meta-object compiler** (**MOC**).
    The meta-object system is an extension of the C++ language, to make it better
    suited for GUI programming. The MOC acts as an pre-compiler, which generates code
    based on the hints embedded in the source, and removes those hints for an ANSI
    C++ compiler to perform its normal compilation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at some classes in the Qt object model:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `QObject` | The base class of all Qt objects ([http://doc.qt.io/archives/qt-4.8/qobject.html](http://doc.qt.io/archives/qt-4.8/qobject.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QPointer` | The template class that provides guarded pointers to `QObject` ([http://doc.qt.io/archives/qt-4.8/qpointer.html](http://doc.qt.io/archives/qt-4.8/qpointer.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QSignalMapper` | Bundles signals from identifiable senders ([http://doc.qt.io/archives/qt-4.8/qsignalmapper.html](http://doc.qt.io/archives/qt-4.8/qsignalmapper.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QVariant` | Acts like a union for the most common Qt data types ([http://doc.qt.io/archives/qt-4.8/qvariant.html](http://doc.qt.io/archives/qt-4.8/qvariant.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaClassInfo` | Additional information about a class ([http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html](http://doc.qt.io/archives/qt-4.8/qmetaclassinfo.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaEnum` | Metadata about an enumerator ([http://doc.qt.io/archives/qt-4.8/qmetaenum.html](http://doc.qt.io/archives/qt-4.8/qmetaenum.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaMethod` | Metadata about a member function ([http://doc.qt.io/archives/qt-4.8/qmetamethod.html](http://doc.qt.io/archives/qt-4.8/qmetamethod.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaObject` | Contains meta-information about Qt objects ([http://doc.qt.io/archives/qt-4.8/qmetaobject.html](http://doc.qt.io/archives/qt-4.8/qmetaobject.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaProperty` | Metadata about a property ([http://doc.qt.io/archives/qt-4.8/qmetaproperty.html](http://doc.qt.io/archives/qt-4.8/qmetaproperty.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QMetaType` | Manages named types in the meta-object system ([http://doc.qt.io/archives/qt-4.8/qmetatype.html](http://doc.qt.io/archives/qt-4.8/qmetatype.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QObjectCleanupHandler` | Watches the lifetimes of multiple `QObject` ([http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html](http://doc.qt.io/archives/qt-4.8/qobjectcleanuphandler.html))
    |'
  prefs: []
  type: TYPE_TB
- en: Qt objects are generally treated as identities, not values. Identities are cloned,
    not copied or assigned; cloning an identity is a more complex operation than copying
    or assigning a value. Therefore, `QObject` and all subclasses of `QObject` (direct
    or indirect) have their copy constructors and assignment operators disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals and slots are mechanisms used in Qt to achieve communication between
    objects. The signals and slots mechanism is a central feature of Qt, as a GUI
    framework. Widgets get notified about changes in other widgets in Qt through this
    mechanism. In general, objects of any kind communicate with one another using
    this mechanism. For example, when a user clicks on a close button, we probably
    want the window's `close()` function to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots are alternatives to the callback technique in C/C++. A signal
    gets emitted when a particular event occurs. All of the widgets in the Qt framework
    have predefined signals, but we can always subclass a widget to add our own signals
    to it. A slot is a function that gets called in response to a signal. Similar
    to predefined signals, the Qt widgets have many predefined slots, but we can add
    custom slots to handle the signals that we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram from Qt''s official documentation ([http://doc.qt.io/archives/qt-4.8/signalsandslots.html](http://doc.qt.io/archives/qt-4.8/signalsandslots.html)),
    demonstrates how inter-object communication happens through signals and slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08250b9c-326e-4c29-905e-2296d3d94f91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Signals and slots are loosely coupled communication mechanisms; the class that
    emits a signal doesn't care about the slot which receives the signal. Signals
    are a perfect example of fire and forget systems. The signals and slots system
    ensures that if a signal is connected to a slot, the slot will be called with
    the signal's parameters at the right time. Both signals and slots can take any
    number of arguments of any type, and they are completely type safe. The signatures
    of both signals and receiving slots must match; hence, the compilers can help
    us to detect type mismatches, as a bonus.
  prefs: []
  type: TYPE_NORMAL
- en: All objects inherited from `QObject`, or any of its subclasses (such as `QWidget`),
    can contain signals and slots. Signals are emitted by an object when it changes
    its state, which may be interesting to other objects. The object doesn't know
    (or care) if there are any objects at the receiving end. A signal can be connected
    to as many slots as needed. Similarly, we can connect as many signals as we want
    to a single slot. It is even possible to connect a signal to another signal; thus,
    signal chaining is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, together, signals and systems make an extremely flexible and pluggable
    component programming mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Event system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Qt, events represent things that have happened within an application or a
    user activity that the application needs to know about. In Qt, events are the
    objects derived from an abstract `QEvent` class. Events can be received and handled
    by any instance of a `QObject` subclass, but they are especially relevant to widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an event occurs, an appropriate `QEvent` subclass instance gets constructed
    and gives its possession to a particular instance of `QObject` (or any relevant
    subclass) by calling its `event()` function. This function does not handle the
    event itself; based on the type of event delivered, it calls an event handler
    for that specific type of event and sends a response based on whether the event
    was accepted or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Some events, such as `QCloseEvent` and `QMoveEvent`, come from the application
    itself; some, such as `QMouseEvent` and `QKeyEvent`, come from the window system;
    and some, such as `QTimerEvent`, come from other sources. Most events have specific
    subclasses derived from `QEvent`, and sometimes event-specific functions to meet
    the specific behavior of the extended events. To exemplify, the `QMouseEvent`
    class adds `x()` and `y()` functions to enable widgets to discover the positions
    of the mouse cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Every event has a type associated with it, defined under `QEvent::Type`, and
    this is a convenient source of run-time type information that is used to quickly
    identify what subclass the event has been constructed from.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, events are rendered by calling associated virtual functions. The
    virtual function is responsible for responding as intended. If custom virtual
    function implementations do not perform all that is necessary, we may need to
    call the base class's implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following example handles the left mouse button clicks on
    a custom label widget, while passing all other button clicks to the base `QLabel`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we want to replace base class functionality, we must implement everything
    in the virtual function override. If the requirement is to simply extend base
    class functionality, we can implement what we want, and call the base class function
    for any other case that we don't want to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Sending events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications that are using the Qt framework want to send their own events,
    just like the framework-provided events. Suitable custom events can be constructed
    by using event objects and sending them with `QCoreApplication::sendEvent()` and
    `QCoreApplication::postEvent()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sendEvent()` is synchronous in execution; therefore, it processes the event
    immediately. For many event classes, there is a function called `isAccepted()`,
    which tells us whether the event was accepted or rejected by the last handler
    that was called.'
  prefs: []
  type: TYPE_NORMAL
- en: '`postEvent()` is asynchronous in execution; hence, it posts the event in a
    queue for later dispatch. The next time Qt''s main event loop runs, it dispatches
    all posted events, with some optimization. For example, if there are several resize
    events, they are compressed into one, as a union of all resize events, which avoids
    flickering in the user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Meta-object system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt meta-object system realizes the signals and slots mechanism for inter-object
    communication, the dynamic property system, and run-time type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt meta-object system is based on three key aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QObject` class: The base class that provides the advantages of the meta-object
    system to Qt objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q_OBJECT` macro: The macro to provide in the private section of the class
    declarations, used to enable meta-object features, such as dynamic properties,
    signals, and slots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MOC: It supplies each `QObject` subclass with the necessary code to implement
    meta-object features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MOC executes before the actual compilation of a Qt source file. When the
    MOC finds class declarations that contain the `Q_OBJECT` macro, it produces another
    C++ source file, with meta-object code, for each of those classes. This generated
    source file is either included in the class's source file using `#include` or,
    more usually, compiled and linked with the class's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World – Qt program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's get started with GUI application development using Qt/C++. Before
    getting into the following sections, download Qt SDK and Qt Creator from Qt's
    official site ([https://www.qt.io/download](https://www.qt.io/download)). The
    codes that we are going to discuss in this chapter are entirely LGPL compatible
    and will be hand-coded by writing pure C++ code. The Qt framework is designed
    to be pleasant and intuitive so that you can handcode an entire application without
    using the Qt Creator IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator is a cross-platform C++, JavaScript, and QML integrated development
    environment, a part of the SDK for the Qt GUI application development framework.
    It includes a visual debugger and an integrated GUI layout and forms designer.
    The editor's features include syntax highlighting and autocompletion. Qt Creator
    uses the C++ compiler from the GNU Compiler Collection on Linux and FreeBSD. On
    Windows, it can use MinGW or MSVC, with the default install, and can also use
    Microsoft Console Debugger, when compiled from source code. Clang is also supported. – *Wikipedia*
    ([https://en.wikipedia.org/wiki/Qt_Creator](https://en.wikipedia.org/wiki/Qt_Creator))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a simple *Hello World* program, using a label widget. In
    this example, we will create and show a label widget, with the text `Hello World,
    QT!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have included two libraries: `<QApplication>` and `<QLabel>`.
    The `QApplication` object is defined in the `QApplication` library, which manages
    the resources in an application, and it is required to run any Qt GUI-based application.
    This object accepts the command-line arguments from the program, and, when `app.execute()`
    is called, the Qt event loop gets launched.
  prefs: []
  type: TYPE_NORMAL
- en: An **event loop** is a program structure that permits events to be prioritized,
    queued, and dispatched to objects. In an event-based application, certain functions
    are implemented as passive interfaces that get called in response to certain events.
    The event loop generally continues running until a terminating event occurs (the
    user clicks on the QUIT button, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '`QLabel` is the simplest widget among all Qt widgets, defined in `<QLabel>`.
    In this code, the label is instantiated with the text `Hello World, QT`. When
    `label.show()` gets called, a label with instantiated text will appear on the
    screen in its own window frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to build and run the application, the first thing we need is a project
    file. To create a project file and compile the application, we need to follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory and save the source code in a CPP file, residing in this
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a shell and verify the version of `qmake` installed by using the `qmake
    -v`command. If `qmake` can't be found, the installation path needs to be added
    to the environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change the directory into the Qt file path in the shell, and execute the `qmake
    -project` command. This will create a project file for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the project file and add the following line to the `.pro` file after `INCLUDEPATH`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, run `qmake` without arguments to create the `make` file that contains
    the rules to build your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `make` (`nmake` or `gmake`, depending on the platform), which builds the
    application according to the rules specified in `Makefile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the application, a small window with a label saying Hello World,
    QT! will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The steps to building any Qt GUI applications are the same, except for the changes
    that may be required in project files. For all of the future examples that we
    will discuss in this chapter, *build and run* means to follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go on to the next example, let''s have some fun. Replace the `QLabel`
    instantiation with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, rebuild and run the application. As this code illustrates, it is easy to
    customize the Qt's user interface by using some simple HTML-style formatting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to handle the Qt events and the use of
    signals and slots for object communication.
  prefs: []
  type: TYPE_NORMAL
- en: Qt event model with signals/slots/MOC – an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create an application to handle mouse events in `QLabel`.
    We will override the mouse events in a custom `QLabel` and handle them in the
    dialog where the custom label is placed. The approach to this application is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom `my_QLabel` class, inherited from the framework `QLabel` class,
    and override the mouse events, such as mouse-move, mouse-pressed, and mouse-leave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the signals that correspond to these events in `my_QLabel`, and emit
    them from the corresponding event handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a dialog class inherited from the `QDialog` class, and handcode the positions
    and layouts of all of the widgets, including the custom widget created to handle
    mouse events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog class, define the slots to handle the emitted signals from the `my_QLabel`
    object, and display the appropriate results in the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate this dialog under the `QApplication` object, and execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the project file to build a widget application and get it up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the header file `my_qlabel.h` to declare the class `my_QLabel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`QLabel` and `QMouseEvent` are defined under the included libraries, `<QLabel>`
    and `<QMouseEvent>`. The class is derived from `QLabel` to inherit its default
    behavior, and `QObject` is propertied to handle the signaling mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: In the private section of the header file, we have added a `Q_OBJECT` macro
    to notify the MOC that it must generate meta-object code for this class. The meta-object
    code is required for the signals and slots mechanism, the run-time type information,
    and the dynamic property system.
  prefs: []
  type: TYPE_NORMAL
- en: In the class header, along with the constructor declaration, the mouse events
    such as mouse-move event, mouse-press event, and mouse-leave event are overridden.
    Also, the public integer variables hold the current *X* and *Y* coordinates of
    the mouse pointer. Finally, the signals emitted from each mouse event are declared
    under the signals section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define these items in a CPP file, `my_qlabel.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, the parent is passed on to the `QLabel` base class to inherit
    the unhandled cases in the overridden class, and the coordinate variables are
    initialized to zero. In the `mouse-move` event handler, the member variables holding
    the mouse coordinates get updated, and a signal `Mouse_Position()` is emitted.
    The dialog using `my_QLabel` can connect this signal to the corresponding `mouse-move`
    slot in the parent dialog class and update the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the `mouse-press` event handlers, the signal `Mouse_Pressed()` is emitted,
    and from the `mouse-leave` event, the `Mouse_Left()` signal is emitted. These
    signals get connected to corresponding slots in the parent widget (`Dialog` class)
    and update the GUI. Hence, we have written a custom label class to handle the
    mouse events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the label class has been implemented, we need to implement the dialog class
    to place all of the widgets and handle all of the signals emitted from the `my_QLabel`
    object. Let''s start with the `dialog.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a `Dialog` class inherited from `QDialog`, defined under
    the `<QDialog>` library. The classes `QLabel` and `my_QLabel` are forward declared
    in this class header, as the actual libraries will be included in the class definition
    file. As we already discussed, the `Q_OBJECT` macro must be included to generate
    meta-object code for enabling signals and slots mechanisms, the run-time type
    information, and the dynamic property system.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the constructor and destructor declarations, private slots are
    declared to connect to the signals emitted from the `my_QLabel` object. The slots
    are normal functions, and can be called normally; their only special feature is
    that signals can be connected to them. The `Mouse_CurrentPosition()` slot will
    be connected to the signal emitted from the `mouseMoveEvent()` of the `my_QLabel`
    object. Similarly, `Mouse_Pressed()` will be connected to `mousePressEvent()`,
    and `MouseLeft()` will be connected to the `leaveEvent()` of the `my_QLabel` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the declaration of all widget pointers and one private function called `initializeWidgets()` is
    done to instantiate and lay out the widgets in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Dialog` class belongs in `dialog.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, the title of the application dialog is set to `My Mouse-Event
    Handling App`. Then, the `initializeWidgets()` function gets called—that function
    will be explained shortly. After creating and setting the layouts calling `initializeWidgets()`,
    the signals that emit from `my_QLabel` objects are connected to the corresponding
    slots declared in the `Dialog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mouse_CurrentPosition()` function is the slot to the signal emitted from
    the mouse-move event of the `my_QLabel` object. In this function, the label widget `label_Mouse_CurPos`
    gets updated with the current mouse coordinates, and `label_MouseEvents` updates
    its text to `Mouse Moving!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mouse_Pressed()` function is the slot to the signal which has been emitted
    from the mouse-press event that gets called every time a user clicks inside of
    the mouse area (the `my_QLabel` object). The function updates the text in the `label_MouseEvents`
    label as `"Mouse Pressed!"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, whenever the mouse leaves the mouse area, the mouse-leave event of
    the `my_QLabel` object emits a signal connected to the `Mouse_Left()` slot function.
    Then, it updates the text in the `label_MouseEvents` label to `"Mouse Left!"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `initializeWidgets()` function to instantiate and set the layouts in
    the dialog, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `label_MouseArea` object is instantiated with the custom label
    class, `my_QLabel`*.* Then, the label properties are modified (such as the label
    text modified to `"Mouse Area"`), mouse tracking is enabled inside the `label_MouseArea`
    object, the alignment is set to center and the frame style is set to a thick line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The label objects `label_Mouse_CurPos` and `label_MouseEvents` are updating
    its properties, such as text alignment and frame style, similar to the `label_MouseArea`
    object. But the text in `label_Mouse_CurPos` is initially set to `"X = 0, Y =
    0"`, and the `label_MouseEvents` label to `"Mouse current events!"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a vertical box layout (`QVBoxLayout`) is created, and the `label_Mouse_CurPos`
    and `label_MouseEvents` label widgets are added to it. Also, a group box is created
    with the tag `Mouse Events`, and the layout of the group box is made into a vertical
    box layout, created with the widgets. At last, the positions and sizes of the
    mouse area label and the mouse events group box are set to predefined values.
    Hence, the widget creation and layout settings are done.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now write `main.cpp` to create the `Dialog` class and display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code is exactly like the Hello World Qt application that we discussed.
    Instead of a `QLabel`, we are instantiating the `Dialog` class we created, resizing
    the dialog window frame to a predefined value by using the `resize()` function.
    Now, the application is ready to build and run. But, before building the application,
    let us handcode the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build the application and run it. A dialog box will pop up as follows
    (Windows platform):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/364c4bdf-cdad-490f-8f1f-5d5c30eee32b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we hover the mouse pointer through the left side label (Mouse Area), the
    coordinates of the mouse will get updated in the first label on the right side,
    and the second label on the right side will display the text, Mouse Moving! Upon
    pressing any mouse button in the mouse area, the text in the second label will
    change to Mouse Pressed! When the mouse pointer leaves the mouse area, the text
    will be updated to Mouse Left!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a dialog window, widgets under a dialog,
    layouts in the widgets, and so on. We also learned how to enable customizing a
    widget (the label widget), and how to handle system events. We then learned about
    the creation and connection of objects using user-defined signals and slots. Finally,
    we used all of these widgets, including a custom widget, and created an application
    to handle Qt mouse events in a window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's implement a similar application to handle mouse events in a `QLabel`
    and display mouse coordinates in another label. Here, the event handling is performed
    by using event subscription and event filtering, with `RxCpp` observables and
    Qt event filters.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the RxCpp library with the Qt event model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw the Qt framework from a bird's eye view in the previous sections.
    We learned how to handle Qt events, especially mouse events and the signals/slots
    mechanism. We also learned about the `RxCpp` library and its programming model
    in the previous two chapters. In the process, we came across many significant
    reactive operators that matter while writing programs leveraging the reactive
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to write an application to handle mouse events
    in a label widget, which is similar to the previous example. In this example,
    instead of handling mouse events to emit signals (like we did in the last example),
    we will be subscribing to Qt mouse events using the `RxCpp` subscriber and will
    filter different mouse events from the resultant mouse events Stream. The events
    (that are not filtered out) will be related to the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Qt event filter – a reactive approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, the Qt framework has a robust event mechanism. We
    need to bridge between the Qt and RxCpp scheme of things. To get started with
    this application, we are going to write a header file, `rx_eventfilter.h`, wrapping
    the required RxCpp headers and the Qt event filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `<rxcpp/rx.hpp>` library is included to get the definitions for `RxxCppsubscriber`
    and `observable`, which we use in this class, and the `<QEvent>` library for `QEvent`
    definition. The entire header file is defined under the namespace `rxevt`. Now,
    the `EventEater` class is a Qt event filter class implanted to `filter-in` the
    only Qt events the member `eventType` is initialized with. To achieve that, the
    class has two member variables. The first one is `eventSubscriber`, which is an `rxcpp::subscriber`
    of the `QEvent` type, and the next one is `eventType`, to hold the `QEvent::Type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, the parent `QObject` (the widget upon which events need
    to be filtered) is passed to the base class `QObject`. The member variables `eventType`
    and `eventSubscriber` get initialized with the `QEvent::Type` that needs to be
    filtered and the `rxcpp::subscriber` of the corresponding event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have overridden the `eventFilter()` function to call `on_next()` only if
    the event type is the same as the initialized type. The `EventEater` is an event
    filter object that receives all events that are sent to this object. The filter
    can either stop the event or forward it to this object. The `EventEater` object
    receives events via its `eventFilter()` function. The `eventFilter()` function
    ([http://doc.qt.io/qt-5/qobject.html#eventFilter](http://doc.qt.io/qt-5/qobject.html#eventFilter))
    must return true if the event should be filtered (in other words, stopped); otherwise,
    it must return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s write a utility function under the same header file to create and
    return an `rxcpp::observable` from the event Stream using the `EventEater` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we are returning the observable of `QEvent` from the stream
    of events that we will filter using the `EventEater` object. A `QObject` instance
    can be set to monitor the events of another `QObject` instance before the latter
    object even sees them. This a really powerful feature of Qt's event model. The
    call of the `installEventFilter()` function makes it possible, and the `EventEater`
    class has the conditions to perform filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the window – setting layouts and alignments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write the application code to create the widget window, which contains
    two label widgets. One label will be used as the mouse area, similar to the previous
    example, and the latter will be used to display the filtered mouse event and the
    mouse coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into the code in `main.cpp` as two sections. Initially, we will
    discuss the code to create and set the layout for the widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included the `rx_eventfilter.h` header file to use the event filtering
    mechanism implemented using the `RxCpp` library. In this application, instead
    of creating these widgets inside of a dialog, a `QWidget` object is created, and
    the two `QLabel` widgets are added into a `QVBoxLayout` layout; this is set as
    the layout of the application widget. The size of the application window is a
    predefined value of `200pixels` wide and `280pixels` high. Similar to the previous
    application, mouse tracing is enabled for the first label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The size policy of both widgets is set to `QSizePolicy::Expanding` to allow
    for the stretching of widgets inside the vertical layout box. This allows us to
    make the mouse area label larger than the status display label. The `setStretch()`
    function sets the stretch factor at the position index to stretch.
  prefs: []
  type: TYPE_NORMAL
- en: Event type specific observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to subscribe to the `rxcpp::observable` of mouse events is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mouse move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse button press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse button double-click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rxevt::from()` function returns the `rxcpp::observable` of the events
    from `label_mouseArea`, based on the `QEvent::Type` we are passing as the argument.
    In this code, we are subscribing to an Observable of events in `label_mouseArea`,
    which are of the `QEvent::MouseMove` type. Here, we are updating the `label_coordinates`
    text with the current *X* and *Y* positions of the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to mouse-move filtering, an observable of `QEvent` is returned by the
    `rxevt::from()` function, including only events of the type `QEvent::MouseButtonPress`.
    Then, the text is updated in `label_coordinates`, with the position of the mouse
    click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the event type `QEvent::MouseButtonDblClick` is also handled similar
    to a single mouse click, and the text in `label_coordinates` is also updated with
    the double-click position. Then, the `show()` function of the application window
    widget is called, and the `exec()` function is called to start the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project file, `Mouse_EventFilter.pro`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since the RxCpp library is a header-only library, a folder named `include` is
    created inside of the project directory, and the RxCpp library folder is copied
    there. Updating `INCLUDEPATH` will help the application to fetch any include files
    present in the directories specified there. Now, let's build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to RxQt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RxQt` library is a public domain library written over the `RxCpp` library
    and makes it easy to program with Qt events and signals in a reactive manner.
    To understand the library, let us jump into an example so that we can track the
    mouse events and filter them using the observable supplied by the library. The
    library can be downloaded from the GitHub repository at [https://github.com/tetsurom/rxqt](https://github.com/tetsurom/rxqt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates `QWidget`, which acts as the parent of two other
    `QLabels`. Two label widgets are created to move inside the parent widget, along
    the top and left border of the windows. The dockable label along the *X*-axis
    is colored red, and the one along the *Y*-axis is blue in color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `rxqt::from_event()` function filters all of the
    events from the widget class, except for the `QEvent::MouseButtonPress` event,
    and returns a `rxcpp::observable<QEvent*>` instance. The `rxcpp::observable` here
    is already filtered with those mouse events if the button is the left mouse button.
    Then, inside the Lambda function of the `subscribe()` method, we are changing
    the cursor into `Qt::ClosedHandCursor`. We also set the position of `xDock` to
    the mouse *x*-position value, along with the top edge of the window, and the `yDock`
    position to the mouse *y*-position, along with the left edge of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are filtering all the mouse-move events from the widget window
    using the `RxQt` library. The observable here is a stream of mouse events with
    both mouse-move and left mouse button press events are present. Inside the subscribe
    method, the code updates the position of  `xDock` and `yDock` along the top and
    left edges of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the filtered mouse button release events are filtered, and the mouse
    cursor is set back to `Qt::OpenHandCursor`. To add some more fun to this application,
    let''s create one more widget, similar to `xDock` and `yDock`; this will be a
    gravity object. The gravity object will follow the mouse cursor when it is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must create an instance of the gravity widget under the application
    window (from the newly created `Gravity_QLabel` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the creation and size settings of `xDock` and `yDock`, the new `gravityDock`
    object has been created. Also, the position of this object must be set in the
    mouse coordinate values whenever a `press` event is thrown. Therefore, inside
    of the Lambda function of the subscribe method for `QEvent::MouseButtonPress`,
    we need to add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the position of `gravityDock` needs to be updated, as per the mouse
    move. To achieve that, inside of the Lambda function of the `subscribe` method
    for `QEvent::MouseMove`, we need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the position of `gravityDock` is updated to a new value, which is the
    sum of 96% of the previous value and 4% of the new position. Hence, we are filtering
    the Qt events using the `RxQt` and RxCpp libraries to create an *X*-*Y* mouse
    position indicator and a gravity object. Now, let's build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dealt with the topic of reactive GUI programming using Qt.
    We started with a quick overview of GUI application development using Qt. We learned
    about concepts in the Qt framework, such as the Qt object hierarchy, the meta-object
    system, and signals and slots. We wrote a basic *Hello World* application using
    a simple label widget. Then, we wrote a mouse event handling application using
    a custom label widget. In that application, we learned more about how the Qt event
    system works, and how to use the signals and slots mechanism for object communication.
    Finally, we wrote an application to handle mouse events and filter them by using
    the `RxCpp` subscription model and Qt event filters. We covered how RxCpp can
    be used in a GUI framework (such as Qt) to follow a Reactive programming model.
    We also covered the `RxQt` library, a public domain that integrates RxCpp and
    the Qt library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to the next chapter, you need to learn about writing *custom
    operators for RxCpp observables*. This topic is covered in the online section.
    You can refer to the following link: [https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf](https://www.packtpub.com/sites/default/files/downloads/Creating_Custom_Operators_in_RxCpp.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: After you have completed reading the preceding mentioned topic, we can proceed
    to the next chapter, where we will take a look at design patterns and idioms for
    C++ reactive programming.
  prefs: []
  type: TYPE_NORMAL
