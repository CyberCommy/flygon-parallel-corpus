- en: '*Chapter 6*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test Methods and Mock Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What should we test in methods? That's a question that we had when we started
    doing unit tests. Everything comes down to *testing what that method does and
    only that*. This means we need to *avoid calls to any dependency*, so we'll need
    to mock them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `submit` event to the form in the `Form.vue` component that we
    created in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.prevent` modifier is just a convenient way to call `event.preventDefault()`
    so that it doesn''t reload the page. Now, make some modifications to call an API,
    and then store the result by adding a `results` array to the data as well as an
    `onSubmit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the method is using `axios` to perform an HTTP call to the **posts** endpoint
    of `jsonplaceholder`, which is just a RESTful API for this kind of example. Additionally,
    with the `q` query parameter, we can search for posts using the `value` provided
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing the `onSubmit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to call `axios.get` actual method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to check it is calling axios (but not the real one) and that it returns
    a `promise`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That `promise` callback should set `this.results` to the promised result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is probably one of the hardest things to test when you have external dependencies,
    plus those return promises that do things inside. What we need to do is to **mock
    the external dependencies**.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking External Module Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest provides a really great mocking system that allows you to mock everything
    in quite a convenient way. In fact, you don't need any extra libraries to do it.
    We have seen already `jest.spyOn` and `jest.fn` for spying and creating stub functions,
    although that's not enough for this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we need to mock the whole `axios` module. That''s where `jest.mock` comes
    into play. It allows us to easily mock module dependencies by writing at the top
    of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You must know that `jest.mock` *is hoisted*, which means it will be placed
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the preceding code is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, I still haven't found much information about how to
    do in Jest what we're going to do here on the internet. Luckily, you don't have
    to go through the same struggle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the mock for `axios` at the top of the `Form.test.js` test file
    and the corresponding test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great. We''re indeed mocking `axios`, so the original axios is not
    called and neither is any HTTP called. And we''re even checking, by using `toBeCalledWith`,
    that it''s been called with the correct parameters. However, we''re still missing
    something: *we''re not checking whether it returns a* `promise`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make our mocked `axios.get` method to return a `promise`.
    `jest.fn` accepts a factory function as a parameter, so we can use it to define
    its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we still cannot access the `promise` because we''re not returning
    it. In testing, it is a good practice to return something from a function when
    possible, as it makes testing much easier. So, let''s now do this in the `onSubmit`
    method of the `Form.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the very clean ES2017 `async/await` syntax in the test to
    check the promise result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we don't just check the promised result, but also that
    the `results` internal state of the component is updated, as expected, by doing
    `expect(cmp.vm.results).toEqual([3])`.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Mocks Externalized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest allows us to have all our mocks separated into their own JavaScript file
    by placing them under a `__mocks__` folder and keeping the tests as clean as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can take the `jest.mock...` block from the top of the `Form.test.js`
    file out to its own file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Just like this, and with no extra effort, Jest automatically applies the mock
    in all our tests so that we don't have to do anything extra, or manually mock
    it in every test. Notice that the module name must match the filename. If you
    run the tests again, they should still pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the modules registry and the mocks state are kept as they
    are, so, if you write another test afterward, you may get undesirable results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The second test should fail, but it doesn't. That's because `axios.get` was
    called on the test before.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it''s good practice to clean the module registry and the mocks,
    since they''re manipulated by Jest in order to make mocking happen. For that,
    you can add in your `beforeEach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that each test starts with clean mocks and modules, as it should
    be in unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jest mocking feature, along with snapshot testing, are the two things I
    love most about Jest. That's because they make what is usually quite hard to test
    very easy, allowing you to focus on writing faster and better-isolated tests and
    keeping your code base bulletproof.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the code for this chapter on **GitHub** ([https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest](https://github.com/alexjoverm/vue-testing-series/tree/Test-State-Computed-Properties-and-Methods-in-Vue-js-Components-with-Jest)).
  prefs: []
  type: TYPE_NORMAL
