["```js\nVue.component('light-bulb', { \n\n  template: ` \n\n  <div class='light-bulb'> \n\n    <p>\n\nEureka!</p> \n\n  </div> \n\n  ` \n\n})\n\n```", "```js --is in reality a back tick. It doesn't exist in all the keyboards; if you don't find it in yours, you will have to copy and paste it. It's part of ES6 syntax, and it tells the browser (or transpiler) that the string may span more than one line.\n\nTo use our component, we need our usual Vue instance:\n\n```", "```js\n\nAlso, we need some HTML to actually place it in the page:\n\n```", "```js\n\nIf you run the application now, you will see three lightbulbs. What a great idea!:\n\n![](Image00066.jpg)\n\n# How it works...\n\nA component is extremely similar to a Vue instance. Here, I am quoting from the official documentation:\n\nIn Vue, a component is essentially a Vue instance with predefined options.\n\nAs a matter of fact, even the anatomy of declaring a Vue instance is quite similar to declaring a Vue component. Let's put them side by side and identify the similarities and differences:\n\n|  \n```", "```js\n\n |  \n```", "```js\n\n |\n\nThe first thing you should note is the option objects present in both. While it contains only the template option in the lightbulb components, it contains only the `el` option in the Vue instance.\n\nThese two options are related but different. The `template` option talks\u00a0about the shape of the component, and the `el` option tells us about the position of the component.\n\nSo, while talking about the lightbulb, we know what shape it has just by looking at the preceding\u00a0code but we don't know where it is in the web page. On the other hand, looking at the code for the Vue instance, we know where it will be mounted, but we don't know how it will look. Where is the `el` for the light bulb, and where is the `template` for the Vue instance?\n\nWell, it's express in the HTML code:\n\n```", "```js\n\nWe know that the Vue instance will look like the insides of the `<div>` app, \u00a0and we know that the light bulb will be mounted whenever the `<light-bulb>` tag is encountered. Why this tag you ask? It's because that's the name we gave to our component. The general syntax is as follows:\n\n```", "```js\n\nIf you specify the name in CamelCase, you have to remember that Vue will convert it to kebab-case. This is because HTML is case insensitive. So, an equivalent name for our light bulb will be\u00a0`Vue.component('lightBulb', { ...options... })` .\n\n# Scope of components\n\nIn this recipe, we declared our component just above the Vue instance that will use it. This is okay because the component is in the same scope as the Vue root instance; the component is automatically registered by the instance.\n\nIn bigger applications, or when importing components, this might be a little more involved.\n\nInside Vue instances, there is an option called `components` that is equivalent to a registry of all the components that can be rendered inside its template. If a tag is encountered that is not standard (built-in in the browser) and not in this registry, Vue will log the following\u00a0error:\n\n```", "```js\n\nWhat we have done in our recipe is to register the component in the global space; this is picked up by our Vue instance that adds the component to the registry.\n\nLet's try another route and register the component manually:\n\n```", "```js\n\nThis is called local registration. If we had a second Vue instance, it would not automatically have access to the light bulb component. This kind of registration allows you to have the light bulb defined in a separate file. You will then import the file and use the component having a neat separation of concerns. You can find more on this in the\u00a0*Having recursive components* recipe.\n\n# The render function\n\nIn Vue 2, there is an alternative way to write how components are rendered. You can always use the template option, but you can also use the `render` function. Delete the light bulb options and write them again like this:\n\n```", "```js\n\nThe component we have written is perfectly equivalent to the previous one. We already saw an application of this style of writing components in [Chapter 2](text00082.html) , *Basic Vue.js Features* ,\u00a0recipe\u00a0 *Output raw HTML* .\n\nThe first line marks the component as functional , which\u00a0means that the component is not allowed to have any internal state (no data option). It\u00a0acts more like\u00a0a mathematical function--it takes some input (in our case, we don't though) and renders some output, which is the light bulb emoji and the 'Eureka!' text.\n\nThe `createElement` function is oftentimes abbreviated with the letter `h` , so you can encounter something like this:\n\n```", "```js\n\nThe `render` function is called when the component has to be drawn on screen and receives the `createElement` function as an argument. The `createElement` function has the following syntax:\n\n```", "```js\n\nWhile the `template` method is preferred and mostly used for displaying data in our components, the `render` function is used when we want more programming control on what we display.\n\n# Passing data to your components with props\n\nSimple components behave a little like stamps. You can save yourself from creating the same element many times using components. While it's fine to have the exact same copy of the same component throughout the page, we must have some means of telling the component what to do. This way, we can have the same components thrice, each of which does a slightly different function.\n\nSince everything is reactive in Vue, with props we have a direct line of communication with our components, and you will\u00a0learn how to use this line in this recipe.\n\n# Getting\u00a0ready\n\nYou don't need any particular knowledge to complete this recipe, just ensure that you know how to define and register basic components. Look back one recipe if you forgot how to do it.\n\n# How to do it...\n\nWe will\u00a0build an icon that represents the sound volume. Adjusting the sound level will change the icon. The icon itself will be a component, like the following:\n\n```", "```js\n\nNote how the `data` option is not an object but a function.\n\nThe following Vue instance will save the current sound level:\n\n```", "```js\n\nThis sound level will be passed down as a prop to the component by an input box. The following HTML displays how:\n\n```", "```js\n\nIf you launch your application now, you will see how the icon changes when the volume changes.\n\n![](Image00071.jpg) ![](Image00072.jpg)\n\n# How it works...\n\nWe have put an array with only one element--the string level-- in the `props` option. This is the property that our component will hold in its internal state.\n\nYou have to keep two things in mind when declaring props in your components:\n\n*   Props are one-way only communication\n*   They can be **fixed** or **dynamic**\n\nProps are specifically for communicating parent to child. In our example, the Vue instance told the sound icon what the sound level was. There was no way for the sound icon to reply\u00a0to the instance.\n\nNote the colon in front of our prop in the line:\n\n```", "```js\n\nHad we written `level=\"soundLevel\"` without the initial colon, the meaning would have been different. No colon means \"use this string for the value of the prop and never change it\", so the value of level would have been fixed to `soundLevel` \u00a0when it should, in fact, be a dynamic number.\n\nIn our child component, we didn't use the usual syntax to declare the data. In child components, the `data` option is a function. We have only one instance of a Vue, so an object will do the job. We can have multiple instances of children objects; so if we use an object, the same object will be shared among them. We want a different object for each child component, and the right way to achieve this is by calling a function at every instantiation--the `data` \u00a0function. If you try to assign an object, Vue will issue the following warning:\n\n```", "```js\n\n# Kebab case and camel case\n\nKebab case is written like works are put in a shish-kebab-- `like-this-for-example` . Camel case uses capitalization instead of spaces-- `capitalizationLooksLikeThis` . Since HTML is case insensitive, it cannot use camel case. However,\u00a0JavaScript is all about camel case; how do we make the two work together?\n\nWhat Vue does is that it converts all the camel case into kebab case once it has to go in HTML. This is relevant to props because they are used in HTML.\n\nSuppose, for a second, that our level variable is now called `soundLevel` :\n\n```", "```js\n\nConsider that\u00a0you try to use it as is in the HTML:\n\n```", "```js\n\nIt won't work because the variable is now called `sound-level` in the HTML:\n\n```", "```js\n\nAlways remember to refer to your variable by kebab case in your HTML if you used camel case in your JavaScript.\n\nThere is an exception to this rule though. If you are writing a template of a component and are using a string (like the one we used in the `sound-icon` component), you can actually use camel case in your HTML. This is because it will be picked up by Vue for interpretation rather than the browser. This also applies to components written with the `render` function since that is not even HTML.\n\n# There's more\n\nThere's a little more to learn about `props` . It's not really recommended to use the syntax we used in a production environment:\n\n```", "```js\n\nWhat we are doing here is declaring an array of `props` and listing the name of the `props.`\n\nThere is a richer syntax we can use, and we should use it to our advantage to specify stricter requirements for our `props.`\n\nThe first thing we can do is specify the type; this will be checked at runtime if we are in the development mode (it won't be checked, for example, if you use the minified version of Vue.js):\n\n```", "```js\n\nIf this check doesn't pass, we will receive a message like the following:\n\n```", "```js\n\nIn our recipe, we specified that the variable in our input box should be casted to a number; so we won't have this problem (unless we clear the input box).\n\nWe can allow more than one type with the array syntax:\n\n```", "```js\n\nAlternatively, we can use an expanded syntax:\n\n```", "```js\n\nThe available types are as follows:\n\n*   String\n*   Number\n*   Boolean\n*   Function\n*   Object\n*   Array\n\nThe preceding\u00a0types are special. Vue will use `instanceof` under the cover to decide whether\u00a0the type passed is right; so you can pass your constructors to check against the type of the passed props, like in the following code:\n\n```", "```js\n\nThere are also three other options: one is for setting a default value, another is for having a custom validator if type checking doesn't cut it, and the last is when we\u00a0require the prop to be specified, giving us more control over our `props` and what we choose to allow:\n\n```", "```js\n\nWhen specifying a default value for a `prop` of type array or object, we have to specify a function, otherwise Vue will use the very same object instead of generating a new one for every component--`default () { return { greetings: 'hello' } }` .\n\n\n\n# Making components talk to each other\n\nIn the\u00a0*Passing data to your components with props* recipe, we saw how parent components can talk to children components; this recipe is more general. How can two components exchange data in the more general case? You will learn how in the next few minutes.\n\n# Getting ready\n\nYou only need to know what a component is to proceed with this recipe. If I were you, though, I would take a look at the preceding\u00a0recipe to have a sense of context of what we are talking about.\n\n# How to do it...\n\nOur application will consist of two blabber components that talk to each other. Here's the HTML:\n\n```", "```js\n\nEach blabber component will contain a script to recite as a dialogue. Since we want to keep it simple, the dialogue will be circular and will go on forever:\n\n```", "```js\n\nThis, along with the variable that will mark the current line to say, will stay inside the component's data:\n\n```", "```js\n\nThe template of the component will only be the current line:\n\n```", "```js\n\nEach blabber will wait two seconds, update its current line, and increment the line for the next blabber. This behavior will start after the component is mounted:\n\n```", "```js\n\nIf you have done everything correctly, your final code for the component should look like this:\n\n```", "```js\n\nThere is still one missing. Just before the component, we should initialize our line variable:\n\n```", "```js\n\nWrite the Vue instance, which is just the following code:\n\n```", "```js\n\nWhen you run your application, you will see the dialog of the two blabbers going on forever.\n\n# How it works...\n\nThe secret sauce that makes the two components talk to each other is the `line` variable:\n\n![](Image00073.jpg)\n\nEach component will try to read the variable and update it. This is not exactly a good way to write code, but it demonstrates that you can use simple variables outside of regular Vue code to make your components communicate with the external world.\n\nA more proper way to achieve the same goal would be to leverage the parent Vue instance to hold the same state and then pass it as a prop to the two children components. Now, the problem with this is that the two components are not allowed to modify the prop since the communication is one-way (from the parent to the children). The workaround is for components to send events to the parent and tell them to update the line variable.\n\nAt this point, it becomes more obvious as to what the right solution is--make the two components talk to each other with events. Let's try and re-implement our recipe with this, more involved but more extendable, solution.\n\nSince we cannot rely on randomness to decide who starts the dialog anymore, we are in need of a variable in the blabber component to decide who starts the communication:\n\n```", "```js\n\nWe then need to update the state variables with the initialization of `currentLine` :\n\n```", "```js\n\nThis is to be done so\u00a0that our HTML becomes as follows:\n\n```", "```js\n\nTo make the two components communicate, we need a bus that will exchange the messages. We can instantiate another empty Vue instance before the component definition to hold our messages:\n\n```", "```js\n\nOur mounted hook becomes as shown:\n\n```", "```js\n\nWe need to pair this with a created hook:\n\n```", "```js\n\nThis means that when a line message is received after 2 seconds (in which, presumably, the blabber is thinking for a comeback), the line of the dialog is incremented by one and a line message is sent to the other blabbers connected to the bus. The blabber itself will receive its own message; that's why we need to check whether\u00a0the line we receive is our own before setting a timeout. What was a number variable earlier\u00a0is now a full-fledged Vue instance:\n\n![](Image00074.jpg)\n\n# Making components talk with Vuex\n\nMaking components communicate in Vue can be done in several ways. In this recipe, you will build two components that communicate through a shared state in a structured manner, using Vuex.\n\n# Getting ready\n\nVuex is state management for Vue. We will talk about it more extensively in [Chapter 10](text00466.html) , *Large Application Patters with Vuex* . For now, we will\u00a0try it out as an indirect means of communication between components. There are no particular skills you should have to carry out this recipe, but you should have at least an understanding of what the Flux pattern is, since Vuex is is inspired by Flux, Redux, and The Elm Architecture. You can find more information at [https://facebook.github.io/flux/docs/overview.html](https://facebook.github.io/flux/docs/overview.html) .\n\nWe will\u00a0use words such as\u00a0*Mutations* \u00a0and assume that you know what we are talking about. If you don't know and want a briefer nonetheless, you can take\u00a0a look at [Chapter 10](text00466.html) , *Large Application Patterns with Vuex* .\n\n# How to do it...\n\nWe will\u00a0centralize the state of our whole application in a Vuex store. To install Vuex, you can add it as a dependency (more instructions at [https://vuex.vuejs.org/en/installation.html](https://vuex.vuejs.org/en/installation.html) ); for now, I\u00a0will assume that you are working on JSFiddle or a single web page, in which you can add [https://unpkg.com/vuex](https://unpkg.com/vuex) as a dependency.\n\nWe declare a new store for our state, as follows:\n\n```", "```js\n\nWe then add properties to the empty object inside the parenthesis, just like we would do with a Vue instance.\n\nFirst, we will\u00a0tell Vuex to help us debug by noticing us every time we modify the state outside of a mutation:\n\n```", "```js\n\nThen, we will declare the state that we will\u00a0use to characterize the whole system:\n\n```", "```js\n\nWe will\u00a0fill in the actor array with objects that will represent the actors themselves. Moreover, we will\u00a0access the `actor` \u00a0and `dialogue` arrays in a circular manner.\n\nThe next things you have to write inside the Vuex store object are the mutations. Define one mutation that will add one actor to the scene and one mutation that will advance the current line by one:\n\n```", "```js\n\nYou successfully completed the store. Now you need to define the component that will act in this comedy:\n\n```", "```js\n\nThe blabber component has a simple template (it just says its line). It retrieves its line from the store with a computed property and, at creation time, signals its entrance to the store.\n\nYou can put two blabbers in the HTML:\n\n```", "```js\n\nMaybe add some style to frame your blabbers with some border through CSS:\n\n```", "```js\n\nThe last thing you have to do to make all this machinery work is to commit the `nextLine` mutation to the store every 2 seconds so that the show goes on. You can do it in the Vue instance by installing a `setInterval` :\n\n```", "```js\n\nWhen you launch the application now, you will see the two blabbers talking in circle for hours.\n\n# How it works...\n\nThe blabbers always know their line because they communicate indirectly through the store.\n\nIf you look closely, the blabbers themselves have no state. Yeah they have a **UUID** (**Universally Unique Identifier** ), but that is just to give them an identity, and it never really changes.\n\nTheir state is centralized in the store, and the actor array will look like this during execution:\n\n```", "```js\n\nThanks to Vue reactivity, the component is just a mirror of this state.\n\nThe communication, while indirectly, is done in the store. Every 2\u00a0seconds, a `nextLine` mutation is issued:\n\n```", "```js\n\nThis advances the `currentActor` and the `currentLine` \u00a0 indexes\u00a0by one step; after that, the actor at the\u00a0 `currentActor` index says the line at the\u00a0 `currentLine` \u00a0index. The actors don't communicate directly to each other, instead they just watch the result (line ) of a shared counter (the `currentLine` ) that advances at every step.\n\nMore than components talking to each other, we created an orchestra director that will tell the components what to do.\n\n# There\u2019s more\n\nIf you open Vue Devtools, you will be able to see the `mutators` committed in the Vuex section:\n\n![](Image00075.jpg)\n\nEvery 2\u00a0seconds, there should be a new `nextLine` mutator. I suggest that you also expand the `actors` array and see what's inside. You can even take a peek at the `currentActor` and the `currentLine` and watch them go in circles.\n\nIf you feel adventurous, you can even add a third blabber:\n\n```", "```js\n\nYou will discover whether the blabbers reorganize themselves in a sensible fashion, or whether\u00a0the system we put in place for two blabbers won't work for three.\n\n# Reading a child's state\n\nAs we saw\u00a0in some recipes in this chapter, communication between parent and child is unidirectional with props (top-down) and passes through a hub with events. In this recipe, we will\u00a0leverage some tricks to read a child's state directly. This technique can be useful when two components are tightly coupled by design or when some debugging is needed.\n\n# Getting ready\n\nThis recipe is not for beginners, so ensure that you understand a little about components and how events and props work before moving ahead.\n\n\n\n# How to do it...\n\nWe have a child who really ate a cookie but won't admit he did. We won't let him get away with it by checking internal state and discover the truth.\n\nWrite the HTML structure of our application, which is the following:\n\n```", "```js\n\nThe `ref` attribute gives the component a mark that we can later retrieve from code.\n\nCopy the child component, like the following:\n\n```", "```js\n\nThis component will display only the string inside the variable mouth .\n\nYou can write the Vue instance, as illustrated:\n\n```", "```js\n\nWe have a mounted hook that will assign the content of the stomach of the child inside a variable in the parent.\n\nNow, run the application to know the truth:\n\n![](Image00076.jpg)\n\n# How it works...\n\nThe `ref` we used on the `child` \u00a0tag is a special attribute\u00a0that we can put it on components or on elements in the page to get a reference that we can use later on in the code.\n\nThe use of `ref` is\u00a0not reactive, for this reason you cannot bind it to a variable. Furthermore, the `$refs` option takes some time to be populated; we had to wait for the mounted hook to be triggered before being able to use it.\n\nThis code, for example, doesn't work:\n\n```", "```js\n\nThe reason is that since the mustaches are evaluated in the render of the template (in this case, the HTML) and the `$refs` variable is populated after the said render, junior is undefined at this point and nothing will be printed because the initial render of the template failed.\n\n# Using ref with v-for\n\nIf we have many components with the same `ref` , the handle that results will be of the `array` type.\n\nWe can rewrite our example for multiple children. Here's a slight modification for the child component:\n\n```", "```js\n\nWe want 10 children in our HTML, and we are interested in the stomach of the fourth\u00a0child:\n\n```", "```js\n\nThe `child4Stomach` variable is initialized in the Vue instance, as follows:\n\n```", "```js\n\nThe number 3 is there because arrays are 0-based, so it's actually the fourth\u00a0element of the array of children:\n\nHere's the result you should get:\n\n![](Image00077.jpg)\n\n# Using components in your own components\n\nWe are talking about composition. Composition is a basic principle in software engineering that allows you to build big and complex systems out of small and self-contained pieces. The working is not exoteric but is similar to playing with Legos.\n\n# Getting ready\n\nBefore venturing in composition, you should be able to create components in the first place. Go to the\u00a0*Creating and registering a component* recipe if you need a refresher. Since this recipe uses props, you should also complete the\u00a0*Passing data to your components with props* \u00a0recipe to be on track.\n\n# How to do it...\n\nWe will\u00a0build a menu for a restaurant. We will have a component for the complete course, and it will contain a smaller component for the individual dishes.\n\nWe will first go\u00a0bottom-up by writing the component for every dish:\n\n```", "```js\n\nThe `&lt;` part is an HTML entity and means \"less than\"; it will be displayed as the `<` \u00a0symbol.\n\nThe course component will have the dish component inside it, and we will add some validation for the prop, just to ensure that all the menus have a similar layout:\n\n```", "```js\n\nOur validator checks whether\u00a0the type of `food` \u00a0is a string and whether the length of the array is equal to 4.\n\nNormally, you will query a service or an API to retrieve the menu; but we will, instead, store two of them directly in the Vue instance for the purpose of this recipe:\n\n```", "```js\n\nIn our HTML, place two courses with the menu you just wrote:\n\n```", "```js\n\nTo visually separate the two menus, we will add a style to the CSS:\n\n```", "```js\n\nIt's not a high-end restaurant menu, but I hope the customers will appreciate a good composition over inheritance in Vue:\n\n![](Image00086.jpg)\n\n# How it works...\n\nWhen using composition, there's a simple rule of thumb from the official docs that you have to keep in mind.\n\nEverything in the parent template is compiled in parent scope; everything in the child template is compiled in child scope.\n\nThis means that you have to pay some attention to the variables you use in your templates, especially props.\n\nLet's examine our course component more closely. We declared a prop called `menu` of the\u00a0`Array` \u00a0type, and we used it like this:\n\n```", "```js\n\nIn this context, we are writing the template of the Vue root instance. As a matter of fact, `menu1` and `menu2` are declared exactly there and we are able to use them without any problem.\n\nLet's suppose that we have the following component:\n\n```", "```js\n\nWe want it to display only when the `show` variable is `true.` We can think of writing something like this in our Vue instance template:\n\n```", "```js\n\nNo! This won't work because show is not in the scope of the Vue instance but in the scope of the advertising component.\n\nIn our recipe, we have the following hierarchy:\n\n1.  The Vue instance, which contains the `menu1` and `menu2` variables\n2.  The Course component, which\u00a0uses the `menu` `prop` variable\n3.  The Dish component, which\u00a0receives a single ham from the menu as prop\n\nSo, the real data is only in one place--in the Vue instance. In general, it can also be external to the Vue instance; for example, it can be retrieved by an API. This is good because we can supply new data easily by acting only in one place. We passed the data through props, which makes where reactive variables are compiled clear.\n\n# Using mixins in your components\n\nIn Vue and in JavaScript in general, there is no general way to have inheritance as intended in programming. Vue nonetheless has some means of recycling the same features for more components. In this recipe, you will give superpowers to your components, but you will write the powers only once.\n\n# Getting ready\n\nThis recipe is fairly advanced; it uses some nasty tricks that\u00a0are very useful to understand how Vue works and may be helpful as a workaround in some situations. Anyway, it is not recommended if you don't already have some experience with Vue.\n\n# How to do it...\n\nFirst, we will\u00a0create two regular elements: the first will represent a man--you can use the man emoji:\n\n```", "```js\n\nWell, that was simple. Next, we will\u00a0create a cat component:\n\n```", "```js\n\nAfter those, you can instantiate\u00a0Vue like this:\n\n```", "```js\n\nIn your HTML, you compose all the three with the following code:\n\n```", "```js\n\nRun the page and you will see the two emojis:\n\n![](Image00089.jpg)\n\nWe will give superpowers to those two components, but we don't want to edit them both. You have to define a super powerful mixin; put the following code at the top, before the component creation and the Vue instantiation so that it's defined for them:\n\n```", "```js\n\nThe `super` class is a rule to your CSS:\n\n```", "```js\n\nNow, add the `mixin` to the two components:\n\n```", "```js\n\nRun the application and click on the buttons to give superpowers to your components!:\n\n![](Image00090.jpg) ![](Image00091.jpg)\n\n# How it works...\n\nMixins add a lot of flexibility to our components, and it is a way to reuse a piece of functionality in different components.\n\nThe basic mechanism is that you define an object that mimics the options of a component. You then put the object in an array inside the `mixins` option inside the real component. Vue will look for mixins when it's time to create the component and will mix the options of the components with the one you defined.\n\nWhat will happen in our recipe is that the created hook will encapsulate the component in a `<div>` by modifying the template. It will add a button to\u00a0the creation hook; it will then add a `superMe` method that turns on the `superPowers` mixed state variable and add the CSS `super` class.\n\n\n\n# Mixin order\n\nVue will use different strategies for mixing different options.\n\nAs a general rule, options that contain objects are merged into one big object. For example, if you have a component that contains three methods \u00a0and your mixin adds one, the final component will contain all of them. When you have two methods with the same name (or computed properties, components, directives, and so on), the mixin's keys will be discarded.\n\nHook functions don't get merged, but both the mixin's and the component's are launched, with the ones from the mixin taking precedence.\n\n# There\u2019s more\n\nI want to close this recipe by telling you about **component subclassing** . To my knowledge, component subclassing is not officially supported; this doesn't mean it's impossible, of course.\n\nI won't go in great detail, but I will give you a general direction to go in.\n\nWrite your base component, which will be a simple greeter:\n\n```", "```js\n\nIt's just a simple string that will become `hello` when you press the greet button.\n\nHave we really written the base component, or did we just write a mixin?\n\nThe subclassing is all in this ambivalence; we can use `Greeter` as a component and mixin because they are mostly made of the same things.\n\nPut it in a subcomponent as a mixin:\n\n```", "```js\n\nPut it in the main Vue instance as a component:\n\n```", "```js\n\nFinally, you can add them both to\u00a0the HTML:\n\n```", "```js\n\nNow you have a component and a subcomponent in which you overwrote the template and added a method.\n\nNote that the greet method is present in the subclass also, it is just not used. Maybe you can figure out a way to have polymorphism? It's an open problem even for me.\n\n# Content distribution with slots\n\nSometimes you want to build a component that can be used to put other elements or components inside it. You may want to build a generic modal dialog component but give the user of your component the ability to write the text of the modal dialog. Alternatively,\u00a0maybe you want to use a general layout in a component and fill it with other elements. Slots are a way to have a fixed structure in one component and delegate the contents of certain parts of it to the father.\n\n# Getting ready\n\nI suggest you to go on and complete the *Using components in your own components* \u00a0recipe\nas it explains the important concept of scope. We will cover that here also, but \"repetita iuvant\".\n\n# How to do it...\n\nThe Russian cat mafia, in order to improve the morale of cats, decides to put up a web page with the best employee of the month and decides to write a Vue component for that.\n\nThey hire you as the principal developer to help them you write the following component:\n\n```", "```js\n\nThe slot tag represents a placeholder in which you will put more content in the parent template. Of course, you add some CSS to embellish the component:\n\n```", "```js\n\nThis is how the HTML looks:\n\n```", "```js\n\nNote how we put another component inside the framed component. The `cat` component that will be framed is this:\n\n```", "```js\n\nThis means that it will load a random cat image every time the page is requested, and the image will be `220px` in width and `220px` in height.\n\nWe can also add `figcaption` in the `h3` rule of the CSS:\n\n```", "```js\n\nThe Vue instance will look like the following:\n\n```", "```js\n\nWe are just generating a random (Russian) cat name and passing it to the cat component in the template.\n\nLaunch your app now; you will discover who is the new Russian cat mafia employee of the month:\n\n![](Image00092.jpg)\n\n# How it works...\n\nNormally, after creating a component, it is inserted in the `template` as a simple tag. In some cases, you put some props or other attributes, but you don't put anything inside. With slots, you are expected to put stuff inside your component in their parent's template. We usually write the following:\n\n```", "```js\n\nHowever, since the `framed` component has a slot inside his template and we put some HTML inside it, it is as follows:\n\n```", "```js\n\nThe final render will contain the `framed` component with the `cat` component instead of the `slot.`\n\nActually, if we don't put anything inside, the default content will appear. The default content is defined inside the component, in the `slot` tag:\n\n```", "```js\n\nThis is what we see when we try not to put anything inside the `framed` component:\n\n![](Image00093.jpg)\n\nIt's also worth noting that while the cat component is a child of the framed component, it can use a variable for its prop from the main Vue instance. This is why it's in the scope of the Vue instance, since it's declared in the template of the Vue instance. It doesn't matter that it's not its direct child.\n\n# There\u2019s more\n\nIn actuality, there are two more interesting modes for `slots` to be used: named slots, when you have more than one slot and want to further customize how content should be distributed, and scoped slots, when you want to reference a child's variable in the parent.\n\n# Named slots\n\nWhen you want to have more than one `slot` , you can give a name to each one of them.\n\nTo make our point, we will\u00a0build an organization chart for \"Scratchy co\".\n\nThe main component has two `slot` s:\n\n```", "```js\n\nYou can see that we named the first `slot` \u00a0boss and the second `slot` employee .\n\nTo decorate our organization chart, we will use the following CSS:\n\n```", "```js\n\nThe composition with different `slot` s is all in the HTML:\n\n```", "```js\n\nThe cat component has not changed, so we can use the one we built in the recipe; the only modification is that we have to add the `slot` attribute. This attribute is also applied at the boss \u00a0`<div>` .\n\nRun the page to see organogram:\n\n![](Image00094.jpg)\n\n# Scoped slots\n\nIn Vue 2.1, a new feature was added that lets you pass data between the content of the `slot` and its parent component.\n\nThis is very useful when we have many `slot` s and many of them need different styling or even when we don't know the number of `slot` s to fill in advance.\n\nFirst of all, since we plan to use the `cat` component multiple times, let's make a small modification that will get a different cat image at every instantiation:\n\n```", "```js\n\nWe added the name of the cat at the end of the link; this way, since we pick a random cat every time, the image will also be picked at random. If we don't do this, the browser will see that the links are the same and use the same image taken from the cache.\n\nAlso, modify the organization chart to include the two top-ranked cats:\n\n```", "```js\n\nWe are passing the rank variable to the `slot` . It will be picked up by the new HTML template of the Vue instance:\n\n```", "```js\n\nInside the `organogram` component, we are wrapping everything inside the `template` tag. The `scope` attribute in this tag will give a name to an object that collects all the variables we passed from the `slot` s in the child component.\n\nThis way, we use `props.type` to reference the type of slot. We are using the `type` variable much like we used the `name` attribute for the named `slot` in the preceding\u00a0paragraph.\n\nIf the type is employee, we are also interested in the rank . We then concatenate the rank, which is a number, with the letter `r` and add it as a class.\n\nTo give it meaning, let's add the `r1` and `r2` classes to our CSS:\n\n```", "```js\n\nLaunching the app now, we should see something like this:\n\n![](Image00095.jpg)\n\n# Single file components with Webpack\n\nVue was a game changer mostly because it changed the way to partition responsibilities. It wasn't the first to do that, but it certainly extended on that. Earlier,\u00a0we used one file for HTML, one for CSS, and one for JavaScript. Little did we know that the three files were all about the same thing--components. Yet, they split several components vertically instead of horizontally. In Vue, we keep components well isolated in a single file with the help of tools such as\u00a0**Webpack** . In this recipe, you will learn how.\n\n# Getting ready\n\nThis recipe assumes that you already know how to register a component (the\u00a0*Creating and register a component* \u00a0recipe). We will also use npm\u00a0and vue-cli (the\u00a0*Choosing a development environment* recipe).\n\n\n\n# How do do it...\n\nWe're assuming that you already have `vue-cli` \u00a0installed in your terminal type:\n\n```", "```js\n\nYou will then be asked some questions; you can answer with whatever you like; at the end, you should be presented with something like this:\n\n![](Image00096.jpg)\n\nInstall the dependencies and run the development server with the following commands:\n\n```", "```js\n\nA browser should automatically open with a welcome page, such as the following screenshot:\n\n![](Image00097.jpg)\n\nNow any change you make in the source file will be picked up by the browser in real time.\n\nOpen the file in `my-component/src/App.vue` with your favorite text editor and delete everything inside the outermost `<div>` tag inside the template section.\n\nSave the file; you should see the browser page go blank instantly.\n\nAlso, delete everything inside the export default object and all the styles. The file will look like this:\n\n```", "```js\n\nThis is our empty canvas to build our component in one file. Thanks to hot reloading, we can see the result of what we are doing in the browser.\n\nJust to test it out, let's write our sample component. In the template, write the following script:\n\n```", "```js\n\nInside the script, write as follows:\n\n```", "```js\n\nLet's add a style just for fun:\n\n```", "```js\n\nWhile you write the code, you can save and see the changes in real time. If you don't see anything, keep an eye on the console because if there is some error, you will need to reload the page.\n\nThe final touch is to rename the file from `App.vue` to `MyComponent.vue` . After this, though, you will not be able to see the component in the browser anymore. That's because the `main.js` makes reference to the App component.\n\nOpen `main.js` and change all the occurrences of `App` with `MyComponent` . The file will look like this:\n\n```", "```js\n\nThis is the root Vue instance by the way. If we want two components instead of one, we can change the render function to this:\n\n```", "```js\n\n# How it works...\n\nIf you managed to follow along but some points were not so clear, that's probably because you are not too familiar with tools such as\u00a0Webpack or NPM; in this case, not everything you do with them seems obvious. I refer you to [Chapter 8](text00390.html) ,\u00a0*Organize + Automate + Deploy = Webpack* ,\u00a0for a close view of Webpack in particular.\n\nIt's probably useful to break down how the flow of data starts from the component we just wrote and goes down to `index.html` .\n\nWe have already seen how the `main.js` calls the component. The `index.html` looks like this:\n\n```", "```js\n\nSo, there is a reference to a `build.js` and not `main.js .` How does it work then? The `build.js` file is not found in the source code.\n\nTo find out, you have to open `webpack.config.js` and note that we are setting `build.js` as a path in the output property. This means that when we launch Webpack (with npm run dev ), we are building that file from `main.js` , which is the entry point of Webpack.\n\n# There\u2019s more\n\nYou have built a single page component. However,\u00a0this is only half of the trip. You should also package the component so that you can use it on other projects. In [Chapter 8](https://cdp.packtpub.com/vue_js_2_cookbook/wp-admin/post.php?post=377&action=edit#post_70) ,\u00a0 *Organize + Automate + Deploy = Webpack,* \u00a0the *Releasing your components to the public* \u00a0recipe, you do exactly that.\n\n# Loading your components asynchronously\n\nSometimes you need to load components while the app is already running. This can be because you have so many components that it will\u00a0be too cumbersome to load all of them or maybe the shape of some component is not known in advance. With Vue, you can load components only when they have to actually render. Next time the component will need to be rendered, it will be retrieved from cache.\n\n# Getting ready\n\nYou want to load your component asynchronously only when you already know how to make AJAX requests with Vue. In this recipe, though, we will\u00a0skip those, so you can follow along right away.\n\n# How to do it...\n\nLet's suppose that we have a big vase e-commerce. We have one component for every vase, but we can't give them all to the user at once. It will be too much data. We will\u00a0load the component from the Internet.\n\nAs only modification, we will\u00a0simulate the AJAX call with a simple `setTimeout` . Let's go back to our favorite online editor, JSFiddle:\n\n```", "```js\n\nOur Vue instance will hold only one variable to display the (simulated) loading of the component:\n\n```", "```js\n\nPut a little `loading` message along with the vase component and you're done:\n\n```", "```js\n\nWhen you load the page, you will see your component appear after 1 second, in which a real AJAX call will be happening. If it's Sunday, you will see a sorry message in the console; that will represent the case when the component can't be loaded because of network problems.\n\n# How it works...\n\nThe syntax for asynchronous component, therefore, is as follows:\n\n```", "```js\n\nInstead of passing an object as a second argument, we are actually passing a function with two arguments. The first is a function that you will have to call once the component (more precisely, the object that contains the properties of the component) is available. The second is another function that accepts a string. When Vue is not working in production mode, the string will be displayed in the console. You can have several reasons why the component is not working, such as\u00a0an actual timeout or a connection error:\n\n```", "```js\n\nAnother feature of our code is that while our components load, even if normally the operation should take less than a few hundreds of milliseconds, we would like a courtesy message or graphics to improve user experience.\n\nTo achieve that, we are emitting a loaded message when the component is mounted:\n\n```", "```js\n\nWhoever the parent is can now receive the message and act upon it (or not). In our case, we pick up the message and turn off the loading message:\n\n```", "```js\n\n# Having recursive components\n\nIf you are even a little into programming, one of the first things you'll hear is iteration versus recursion. Vue has both, and if you have some tree structured graphics or menus in your application, Vue's got you covered. In this recipe, we will\u00a0illustrate on this point by building a classification of animals in a recursive fashion.\n\n# Getting ready\n\nWe will\u00a0use a couple of props in this recipe, so ensure that you have the\u00a0*Passing data to your component with props* recipe completed before starting this one.\n\n# How to do it...\n\nFirst of all, let's write an empty Vue instance that we will\u00a0fill:\n\n```", "```js\n\nYou will\u00a0need some material to work with; by this, I mean a whole lot of animals to classify. You can copy maybe only a part of this code in your Vue instance data, but to give you some inspiration, here it comes, the longest listing in this whole book:\n\n```", "```js\n\nWe want to render all the animals and when we encounter a null, we will\u00a0stop traversing the tree.\n\nDeclare a new Vue component above our Vue instance and name it `taxon` :\n\n```", "```js\n\nInside its option, write the following template:\n\n```", "```js\n\nThis template is a list element with a little `+` \u00a0sign that we will\u00a0click on to expand the list that is inside. The\u00a0 `tree` and `taxon` variables, as you can see, are passed as props. Declare them with the following code:\n\n```", "```js\n\nThe `open` variable is retained internally in the data of the component:\n\n```", "```js\n\nWrite the `hasChildren` computed property to make your live easier in the template:\n\n```", "```js\n\nFinally, the `toggle` method will switch `open` on and off depending on its\u00a0previous state:\n\n```", "```js\n\nThe root of this tree is represented by the following HTML, which is the only bit you have to write:\n\n```", "```js\n\nYou can add this CSS rule to make your mouse change to a pointer hand when hovering over the little plus sign:\n\n```", "```js\n\nWhen you launch your app, you will have the full tree of life at your fingertips:\n\n![](Image00099.jpg)\n\n# How it works...\n\nThe structure of our application is recursive. We created a `taxon` component that is a `<li>` element. This element, in turn, contains another,\u00a0 `<ul>` , unordered list, of which the list items are taxon element themselves.\n\nSince the first list item must be inside a list, we wrote the root of our tree manually:\n\n```", "```js\n\nThe resulting rendered HTML, if you take a sneak peek at the browser, is like this:\n\n![](Image00100.jpg)\n\nIn the Vue dev tools, you will find this structure:\n\n![](Image00101.jpg)\n\n\n\n# Recursive component and local registration\n\nIn our recipe, we registered the component globally. This assigns a name to the component by default. Had we registered our component locally, our application would not work. If you register your component locally, you need to manually supply a name, as in the following highlighted line of code:\n\n```", "```js\n\nYou can then register the component normally:\n\n```", "```js\n\nIf you forget to give the name to the recursive component, Vue will complain with the following error:\n\n```", "```js\n\n# Avoiding a stack overflows!\n\nIn our recipe, we used `v-for` to ensure that if there are no more taxa present, the taxon component will not even render. You should ensure, using `v-if` or `v-for` , that there is an end to your recursion. However,\u00a0just for fun, you should make Vue explode at least once in your life.\n\nWrite the following component:\n\n```", "```js\n\nThen, put it in your Vue instance HTML:\n\n```", "```js\n\nYou should receive the satisfying message from Vue:\n\n```", "```js\n\n# Reusable component checklist\n\nIf you are building a component for others to use, there are certain principles that apply, such as high cohesion. In this recipe, you will build a toy component that will illustrate some principles of re-usability.\n\n# Getting ready\n\nThis recipe is a wrap up of good engineering techniques for building a component. It does not require specific skills but assumes that you already know a thing or two about components.\n\n# How to do it...\n\nYou will build a generic dialog box. Write the empty component first:\n\n```", "```js\n\nThe template will contain a slot for the icon, another slot for the message, and an optional cancel button:\n\n```", "```js\n\nThis way, any user of the dialog box can customize it with the content he wants and can also decide whether\u00a0the `Cancel` button is really necessary.\n\nThe props are then `cancellable` and `command` .\u00a0\u00a0The latter is a string which we\u2019ll return to the user to identify the dialog box:\n\n```", "```js\n\nThe `cancel` and `ok` methods don\u2019t have a fixed function but, in order for the component to be reusable, have to let the user decide what to do. We will, instead, launch generic events:\n\n```", "```js\n\nNow for the juicy part. How is the client supposed to use this component of ours? Here's the HTML of the Vue instance that uses our component:\n\n```", "```js\n\nWe also put an output mustache that will print the content of `msg` , a variable that we declare on the Vue instance JavaScript:\n\n```"]