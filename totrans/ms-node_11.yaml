- en: Organizing Your Work into Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Complexity must be grown from simple systems that already work."'
  prefs: []
  type: TYPE_NORMAL
- en: – Kevin Kelly, “Out of Control”
  prefs: []
  type: TYPE_NORMAL
- en: Node’s straightforward module management system encourages the development of
    code bases that grow and remain maintainable. The Node developer is blessed with
    a rich ecosystem of clearly defined packages with consistent interfaces that are
    easy to combine, delivered via npm. When developing solutions, the Node developer
    will find many pieces of the functionality they need ready-made, and can rapidly
    compose those open source modules into larger, but still consistent and predictable,
    systems. Node's simple and scalable module architecture has let the Node ecosystem
    grow rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the details of how Node understands modules and
    module paths, how modules are defined, how to use modules in the npm package repository,
    and how to create and share new npm modules. By following some simple rules, you
    will find it easy to shape the structure of your application, and help others
    work with what you’ve created.
  prefs: []
  type: TYPE_NORMAL
- en: '*Module* and *package* will be used interchangeably to describe the file or
    collection of files compiled and returned by `require()`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to load and use modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, take a look at these three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To install Node, you likely navigated your favorite web browser to [https://nodejs.org/en/](https://nodejs.org/en/),
    downloaded the appropriate installer app for your operating system, and clicked
    through some OK buttons. When you did this, you also got npm. However, npm updates
    quite frequently, so even if you've updated Node recently, you may not have the
    latest version of npm.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, downloading and installing a new Node installer will update Node,
    but doesn't always update npm, so use `npm install npm@latest -g` to ensure that
    you've got the most recent version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Node designers believe that most modules should be developed in userland—by
    developers, for developers. As such, an effort is made to limit the growth of
    the standard library. At the time of writing this, Node’s standard module library
    contains the following short list of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Network and I/O** | **Strings and Buffers** | **Utilities** |'
  prefs: []
  type: TYPE_TB
- en: '| TTY UDP/Datagram'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: Net
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs: []
  type: TYPE_NORMAL
- en: TLS/SSL
  prefs: []
  type: TYPE_NORMAL
- en: Readline
  prefs: []
  type: TYPE_NORMAL
- en: FileSystem | Path Buffer
  prefs: []
  type: TYPE_NORMAL
- en: Url
  prefs: []
  type: TYPE_NORMAL
- en: StringDecoder
  prefs: []
  type: TYPE_NORMAL
- en: QueryString | Utilities VM
  prefs: []
  type: TYPE_NORMAL
- en: Readline
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs: []
  type: TYPE_NORMAL
- en: Console
  prefs: []
  type: TYPE_NORMAL
- en: Assert |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encryption and Compression** | **Environment** | **Events and Streams**
    |'
  prefs: []
  type: TYPE_TB
- en: '| ZLIB Crypto'
  prefs: []
  type: TYPE_NORMAL
- en: PunyCode | Process OS
  prefs: []
  type: TYPE_NORMAL
- en: Modules | Child Processes Cluster
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs: []
  type: TYPE_NORMAL
- en: Stream |
  prefs: []
  type: TYPE_NORMAL
- en: Modules are loaded via the global `require` statement, which accepts the module
    name or path as a single argument. As a Node developer, you are encouraged to
    augment the module ecosystem by creating new modules or new combinations of modules
    of your own, and share them with the world.
  prefs: []
  type: TYPE_NORMAL
- en: The module system itself is implemented in the require (`module`) module.
  prefs: []
  type: TYPE_NORMAL
- en: The module object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Node module is simply a Javascript file. Reference functions (and anything
    else) that might be useful to outside code to exports, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a module that can be required by another file. Back in our main
    app, let''s use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note how it was not necessary to use the `.js` suffix. We’ll discuss how Node
    resolves paths shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our library a little bigger, growing it to three functions, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring assignment, brought to JavaScript with ES6, is a great way to
    assign many functions exported by a required module to their local variables in
    a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Modules, exports, and module.exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you inspect the code of Node modules you might see that some modules export
    their functionality using `module.exports`, while others simply use `exports`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Is there a difference? The short answer is no. You can for the most assign properties
    to either when building your code. Both methods given above will "do" the same
    thing -- the property 'foo' of the exported module will resolve to 'bar' in both
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The longer answer is that there is a subtle difference between them, having
    to do with how JavaScript references work. Consider how modules are wrapped in
    the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a module it is wrapped using the above code. That is how the
    "globals" of __dirname and of course exports are available to the script (content)
    being imported -- they are injected into your execution scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall the discussion on `vm` contexts in [Chapter 10](404d3cde-f615-4c63-b789-442e218a1263.xhtml),
    *Testing Your Application*? The `Module` constructor itself demonstrates how `exports`
    is simply an empty object literal on the `Module` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping up, we see that in the final compilation whatever `module.exports` contains
    is returned to `require`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize and simplify, when you are creating a module you are essentially
    defining its exports in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So `exports` is just a reference to `module.exports`, which is why setting
    foo on the `exports` object is the same as setting foo on `module.exports`. However,
    *if you set `exports` to something else* `module.exports` will **not** reflect
    that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we saw above it is only `module.exports` that is returned; `exports` is never
    returned. If `exports` overwrites its own reference to `module.exports` that value
    never escapes the compilation context. To be safe, just use `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: Node’s core modules are also defined using the standard `module.exports` pattern.
    You can see an example of this by browsing the source code defining console: [https://github.com/nodejs/node/blob/master/lib/console.js](https://github.com/nodejs/node/blob/master/lib/console.js).
  prefs: []
  type: TYPE_NORMAL
- en: Modules and caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules, once loaded, are cached. Modules are cached based on their resolved
    filename, resolved relative to the calling module. Subsequent calls to require
    (`./myModule`) will return the same (*cached*) object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, imagine that we''ve got three (poorly designed, in this
    case) modules, each of which require the other two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Without caching, requiring any of them will cause infinite loops. However,
    because Node doesn''t rerun an already loaded (or currently being loaded) module,
    it all works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that accessing the same module via a different relative path
    (such as `../../myModule`) will return a different object; think of the cache
    being keyed by relative module paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'A snapshot of the current cache can be fetched via `require(''module'')._cache`.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The module object itself contains several useful readable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module.filename`: The name of the file defining this module. You can see these
    paths in the preceding code block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module.loaded`: Whether the module is in the process of loading. Boolean true
    if loaded. In the preceding code, library1 has finished loading (true), while
    app is still loading (false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module.parent`: The module that required this one, if any. You can see how
    library1 knows that app required it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module.children`: The modules required by this one, if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can determine whether a module is being executed directly via `node module.js`
    or via `require('./module.js')` by checking `require.main === module`, which will
    return true in the former case.
  prefs: []
  type: TYPE_NORMAL
- en: How Node handles module paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As modular application composition is The Node Way, you will often see (and
    use) the require statement. You will have noticed that the argument passed to
    require can take many forms, such as the name of a core module or a file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudocode, taken from the Node documentation, is an ordered
    description of the steps taken when resolving module paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: File paths may be absolute or relative. Note that local relative paths will
    not be implicitly resolved and must be stated. For example, if you would like
    to require the `myModule.js` file from the current directory, it is necessary
    to at least prepend `./` to the filename; `– require('myModule.js')` will not
    work. Node will assume that you are referring to either a core module or a module
    found in the `./node_modules` folder. If neither exists, a `MODULE_NOT_FOUND`
    error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding pseudocode, this `node_modules` lookup ascends a directory
    tree beginning from the resolved path of the calling module or file. For example,
    if the file at `/user/home/sandro/project.js` called `require(''library.js'')`,
    Node would seek in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Organizing your files and/or modules into directories is always a good idea.
    Usefully, Node allows modules to be referenced through their containing folder
    in two ways. Given a directory, Node will first try to find a `package.json` file
    in that directory, alternatively seeking for an `index.js` file. We will discuss
    the use of `package.json` files in the next section. Here, we simply need to point
    out that if require is passed the `./myModule` directory, it will look for `./myModule/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve set the `NODE_PATH` environment variable, then Node will use that
    path information to do further searches if a requested module is not found via
    normal channels. For historical reasons, `$HOME/.node_modules`, `$HOME/.node_libraries`,
    and `$PREFIX/lib/node` will also be searched. `$HOME` represents a user’s home
    directory, and `$PREFIX` will normally be the location Node was installed to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned when discussing how Node does path lookups, modules may be contained
    within a folder. If you are developing a program that will work well as a module
    for someone else to use, you should organize that module within its own folder,
    and create a `package.json` file within that folder.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen throughout the examples in this book, a `package.json` file describes
    a module, usefully documenting the module’s name, version number, dependencies,
    and so forth. It must exist if you would like to publish your package via npm.
    In this section, we will outline only a few key properties of this file, and we
    will also provide more detail on some of the obscure ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try `$ npm help json` to fetch detailed documentation for all available package.json
    fields, or visit: [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).'
  prefs: []
  type: TYPE_NORMAL
- en: A `package.json` file must conform to the JSON specification. Properties and
    values must be double-quoted, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Easy init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create a package file by hand, or use the handy `$ npm init` command-line
    tool, which will ask some questions and generate a `package.json` file for you.
    Let’s run through some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: (Required) This string is what will be passed to `require()` in order
    to load your module. Make it short and descriptive, using only alphanumeric characters;
    this name will be used in URLs, command-line arguments, and folder names. Try
    to avoid using `js` or `node` in the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**version**: (Required) npm uses semantic versioning, where these are all valid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '>=1.0.2 <2.1.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on version numbers, visit: [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).'
  prefs: []
  type: TYPE_NORMAL
- en: '**description**: When people search `npmjs.org` for packages, this is what
    they will read. Make it short and descriptive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**entry** **point** (main): This is the file that should set `module.exports`;
    it defines where the module object definition resides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keywords**: A comma-separated list of keywords that will help others find
    your module in the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**license**: Node is an open community that likes permissive licenses. *MIT*
    and *BSD* are good ones here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might also want to set the `private` field to `true` while you are developing
    your module. This ensures that npm will refuse to publish it, avoiding accidental
    releases of not-yet-good or time-sensitive code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scripts to package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another advantage is that npm can also be used as a build tool. The `scripts`
    field in your package file allows you to set various build directives executed
    at some point following certain npm commands. For example, you might want to minify
    Javascript, or execute some other processes that build dependencies that your
    module will need whenever `npm install` is executed. The available directives
    are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prepublish`, `publish`, `postpublish`: Run by the `npm publish` command as
    well as on local `npm install` without any arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepublishOnly`: Run before published only on the `npm publish` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepare`: Run before the package is published and on `npm install ` without
    any arguments. Run after `prepublish`, but before `prepublishOnly`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepack`: Run before a tarball is packed via `npm pack` or `npm publish`,
    and when installing git dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postpack`: Run after a tarball has been generated and moved to its final location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preinstall`, `install`, `postinstall`: Run by the `npm install` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preuninstall`, `uninstall`, `postuninstall`: Run by the `npm uninstall` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preversion`, `version`, `postversion`: Run by the `npm version` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preshrinkwrap`, `shrinkwrap`, `postshrinkwrap`: Run by the `npm shrinkwrap` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pretest`, `test`, `posttest`: Run by the `npm test` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prestop`, `stop`, `poststop`: Run by the `npm stop` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prestart`, `start`, `poststart`: Run by the `npm start` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prerestart`, `restart`, `postrestart`: Run by the `npm restart` command. Note
    that `npm restart` will run the `stop` and `start` scripts if no `restart` script
    is provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be clear that pre- commands will run before, and post- commands will
    run after their primary command (such as `publish`) is executed.
  prefs: []
  type: TYPE_NORMAL
- en: npm as a build system using custom scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You aren''t limited to using only this predefined bag of default script commands.
    Extending the scripts collection in a package file with, for example, build instructions
    is a very common practice. Consider the following script definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When this command is run via `npm run dev` we start a hypothetical server in
    debug mode (--inspect), and expose the garbage collector so that we can track
    its impact on our application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also implies that npm scripts can in many cases completely replace more
    complex build systems like **gulp** or **webpack**. For example you might want
    to use **Browserify** to bundle your application for deployment, and that build
    step is easy to describe in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After executing `npm run build:browserify` Browserify will process the file
    at src/js/index.js, running it through a transformer (-t) that can compile React
    code (**babelify**) and output (-o) the result to build/app.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, npm scripts are running on the host system in the context of
    npm, so you are able to execute system commands and address locally installed
    modules. Another build step you might implement is JavaScript minification, moving
    compiled files into a target folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we use an OS command mkdir to create the target folder for compiled files,
    perform minification against all JavaScript files in a folder with the (locally
    installed) **uglify** module, and redirect the resulting minified script bundle
    to a single build file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add a general build command to our scripts collection, and simply
    use `npm run build` whenever we need to deploy a new build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Any number of steps can be chained in this manner. You might add tests, run
    a file watcher, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: For your next project consider using npm as a build system rather than complicating
    your stack with large and abstract systems that can be very hard to debug when
    they go wrong. The company **Mapbox**, for instance, uses npm scripts to manage
    a complex build/test pipeline: [https://github.com/mapbox/mapbox-gl-js/blob/master/package.json](https://github.com/mapbox/mapbox-gl-js/blob/master/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: Registering package dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is likely that a given module will itself depend on other modules. These
    dependencies are declared within a `package.json` file using four related properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dependencies`: The core dependencies of your module should reside here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies`: You may depend on some modules, while developing your module,
    that are not necessary to those who will use it. Typically, test suites are included
    here. This will save some space for those using your module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bundledDependencies`: Node is changing rapidly, as are npm packages. You may
    want to *lock* a certain bundle of dependencies into a single bundled file and
    have those published with your package, so that they will not change via the normal
    `npm update` process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optionalDependencies`: Contains modules that are optional. If these modules
    cannot be found or installed, the build process will not stop (as it will with
    other dependency load failures). You can then check for this module’s existence
    in your application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependencies are normally defined with a npm package name, followed by versioning
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, they can also point to a tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can point to a GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'They can even point to the shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These GitHub paths are also available to `npm install`, for example, `npm install
    sandro-pasquali/herder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, in cases where only those with proper authentication are able
    to install a module, the following format can be used to source secure repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By properly organizing your dependencies by type, and intelligently sourcing
    those dependencies, build requirements should be easy to accommodate using Node’s
    package system.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and managing NPM packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install Node, npm is installed natively, and it functions as the primary
    package manager for the Node community. Let’s learn how to set up an account on
    the npm repository, publish (and unpublish) modules, and work with GitHub as an
    alternative source target.
  prefs: []
  type: TYPE_NORMAL
- en: In order to publish to npm, you will need to create a user; `npm adduser` will
    trigger a series of prompts requesting your name, email, and password. You may
    then use this command on multiple machines to authorize the same user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reset your npm password, visit: [https://npmjs.org/forgot](https://npmjs.org/forgot).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have authenticated with npm, you will be able to publish your packages
    using the `npm publish` command. The easiest path is to run this command from
    within your package folder. You may also target another folder for publishing
    (remembering that a `package.json` file must exist in that folder).
  prefs: []
  type: TYPE_NORMAL
- en: You may also publish a gzipped tar archive containing a properly configured
    package folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the `version` field of the current `package.json` file is lower
    or equal to that of the existing, published package, npm will complain and refuse
    to publish. You can override this using the `--force` argument with `publish`,
    but you probably want to update the version and republish.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a package, use `npm unpublish <name>[@<version>]`. Note that once
    a package is published, other developers may come to depend on it. For this reason,
    you are strongly discouraged from removing packages that others are using. If
    you want to discourage the use of a version, use npm deprecate `<name>[@<version>]
    <message>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further assist collaboration, npm allows multiple owners to be set for a
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm owner ls <package name>`: Lists the users with access to a module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm owner add <user> <package name>`: The added owner will have full access,
    including the ability to modify the package and add other owners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm owner rm <user> <package name>`: Removes an owner and immediately revokes
    all privileges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All owners have equal privileges—special access controls are unavailable, such
    as being able to give write but not delete access.
  prefs: []
  type: TYPE_NORMAL
- en: Global installs and binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Node modules are useful as command-line programs. Rather than requiring
    something like `$ node module.js` to run a program, we might want to simply type
    `$ module` on the console and have the program execute. In other words, we might
    want to treat a module as an executable file installed on the system PATH and
    therefore is accessible from anywhere. There are two ways to achieve this using
    npm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and simplest way is to install a package using the `-g (global)`
    argument is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If a package is intended as a command-line application that should be installed
    globally, it is a good idea to set the `preferGlobal` property of your `package.json`
    file to `true`. The module will still install locally, but users will be warned
    about its global intentions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to ensure global access is by setting a package’s `bin` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When this module is installed, `aModule` will be understood as a global CLI
    command. Any number of such programs may be mapped to `bin`. As a shortcut, a
    single program can be mapped, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the name of the package itself (`aModule`) will be understood
    as the active command.
  prefs: []
  type: TYPE_NORMAL
- en: Other repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node modules are often stored in version control systems, allowing several
    developers to manage package code. For this reason, the `repository` field of
    `package.json` can be used to point developers to such a repository, should collaboration
    be desired. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you might want to point users to where bug reports should be filed
    using the bugs field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Lockfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ultimately, npm install is a command that takes a `package.json` and builds
    a `node_modules` folder from it. However, does it always product the same one?
    The answer is sometimes, and we will cover the details in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: If you've made a new project, or recently updated npm to version 5, you may
    have noticed a new file alongside the familiar `package.json`—`package-lock.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside, the contents looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Parts will immediately be familiar. Here are the npm packages your project
    depends upon. Dependencies of dependencies are nested appropriately: `align-text`
    doesn''t require anything, while `babel-core` needs `source-map`.'
  prefs: []
  type: TYPE_NORMAL
- en: The real usefulness beyond `package.json` is delivered by the resolved and integrity
    fields. Here, you can see the exact file the npm downloaded and unzipped to create
    the corresponding folder within `npm_modules`, and, even more importantly, the
    cryptographically-secure hash digest of that file.
  prefs: []
  type: TYPE_NORMAL
- en: With `package-lock.json`, you can now get an exact and `reproducable node_modules`
    folder. Committed into source control, you can see when a dependant module version
    has changed right in a diff during a code review. Also, with hashes everywhere,
    you can be more certain that the code your application depends upon hasn't been
    tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: '`package-lock.json` is here; it''s long, it''s filled with hash values, but
    actually, you can ignore it. The file''s appearance with npm 5 didn''t change
    the behavior of commands such as npm install and npm update that you''re used
    to. To explain how, and why, it''s helpful to expose two common questions (or
    exclamations) that developers commonly have when encountering the file:'
  prefs: []
  type: TYPE_NORMAL
- en: So this means my `node_modules` folder will be made from these hashes, right?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does my `package-lock.json` file keep changing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The answers are (1) no, and (2) that's why.
  prefs: []
  type: TYPE_NORMAL
- en: When npm finds a newer version of a package, it'll download it and update your
    `node_modules` folder, just as earlier. With npm 5, it'll also update `package-lock.json`,
    with the new version number and the new hash.
  prefs: []
  type: TYPE_NORMAL
- en: Also, most of the time, this is what you want it to do. If there's a newer version
    of a package the project you're developing depends upon, you probably want npm
    install to give you the most recent one.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if you want npm to not do this? What if you want it to get the
    modules with exactly these versions and exactly these hashes? The way to do this
    lies not in `package-lock.json`, but back in `package.json`, and deals with semantic
    version numbers. Take a look at these three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1.2.3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~1.2.3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^1.2.3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.2.3` means exactly that version, nothing earlier, and nothing later. `~1.2.3`
    matches that version, or anything more recent. The third example with the caret,
    `^1.2.3`, will bring in that version or something more recent, but stay in version
    1\. Caret is the default, and likely already written everywhere in your `package.json`
    files. It makes sense, as a change to the first number indicates a major version
    which might break compatibility with previous versions, in turn potentially breaking
    your preceding code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Far beyond these three common examples, there''s a whole language of comparators,
    operators, identifiers, tags, and ranges possible with semantic versioning and
    supported by npm. Curious readers can check it out at: [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).
    However, remember to keep it simple! Your current collaborators, and future self,
    will thank you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, npm is changing your `node_modules` folder, and `package-lock.json`, because
    you told it to, with `^` in `package.json`. You can remove all the carets to get
    npm to stick to the exact versions, but for the instances where you want to do
    that, there''s a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All npm's `shrinkwrap` command actually does is rename `package-lock.json` to
    `npm-shrinkwrap.json`. The significance comes in how npm uses the files later.
    When publishing to npm, `package-lock.json` stays behind, because it's likely
    changing as newer versions of the dependencies of what you're working on come
    out. On the other hand, `npm-shrinkwrap.json` is meant to get published with your
    module.
  prefs: []
  type: TYPE_NORMAL
- en: When npm acts on a project with a `npm-shrinkwrap.json` file, the `shrinkwrap`
    file and its exact versions and hashes, not `package.json` with its version ranges,
    determines how npm builds the `node_modules` folder. Like the cardboard box from
    a software store in a mall in the 1990s, you know that what's inside is unchanged
    from the factory by removing the plastic wrapping.
  prefs: []
  type: TYPE_NORMAL
