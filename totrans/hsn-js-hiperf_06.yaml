- en: Message Passing - Learning about the Different Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at Node.js and the base environment we need
    to create server-side applications. Now, we will look at how we can use the communication
    techniques we looked at previously to write scalable systems. Message passing
    is a great way for applications to be decoupled yet still work together. This
    means that we can create modules that work independently from each other, either
    through processes or threads, and still achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Local communication using the net module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick glance at HTTP/3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also take a look at the future of client/server communication while
    looking at the HTTP/3 standard that is being developed. Then, we will look at
    the implementation of the QUIC protocol, a protocol developed by Google that HTTP/3
    takes some of its ideas from.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll need the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: An IDE or code editor (VS Code is preferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running Node.js environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL or the ability to install Cygwin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local communication using the net module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While many applications can run on a single thread and utilize the event loop
    to run, when we are writing server applications we will want to try and utilize
    all of the cores that we have available to us. We can do this through the use
    of **processes** or **threads**. In most cases, we are going to want to use threads
    since they are lighter and faster to start.
  prefs: []
  type: TYPE_NORMAL
- en: We can find out whether we need a process or a thread based on whether we need
    to have the subsystem still running if the main system dies. If we don't care,
    we should utilize a thread, but if we need to have that subsystem still running
    even after the main process dies, we should utilize a decoupled process. This
    is only one way of thinking about when to use a process or a thread, but it is
    a good indicator.
  prefs: []
  type: TYPE_NORMAL
- en: In both the browser and Node.js, we have web workers that take the place of
    threads in traditional systems. While they have many of the same concepts as the
    threads of other languages, they are unable to share state (in our case, this
    is preferred).
  prefs: []
  type: TYPE_NORMAL
- en: There's a way to share state between workers. This can be done through `SharedArrayBuffer`.
    While we can utilize this to share state, we want to highlight that the event
    system and IPC are almost always fast enough to move state and coordinate between
    different pieces. Also, we don't have to deal with concepts such as locks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up a worker, we need to call `new Worker(<script here>)`. Let''s go
    over this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Main_Worker.js` and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `worker.js` and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this system is similar to the one in the browser. First, we import
    the worker from the `worker_threads` module. Then, we start it up. The thread
    will start, which means we post messages to it and listen for events, similar
    to the way we were able to with processes in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the `worker.js` file, we import the `parentPort` message channels
    from the `worker_threads` module. We listen and pass messages the same way as
    the parent does. Once we receive a message, we state that we received the message.
    The parent then terminates us and we print out that we have been terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this form of message passing is perfectly fine if we want to tightly couple
    all of our subsystems together. But what if we want different threads to have
    different jobs? We could have one that just caches data for us. Another one could
    potentially make requests for us. Finally, our main thread (the starting process)
    can move all of this data and take in data from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do all of this, we could simply use the built-in system. Alternatively,
    we could utilize the mechanism that we looked at in the previous chapter. Not
    only does this give us a highly scalable system, but it also allows us to change
    these various subsystems from threads into processes if we need to. This also
    allows us to write these separate subsystems in another language, if needed. Let''s
    go over this now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and make this system. We are going to create four files: `main.js`,
    `cache.js`, `send.js`, and `package.json`. Our `package.json` file should look
    something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code to the `cache.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is definitely not a foolproof mechanism for handling streaming data. `!!!BEGIN!!!`
    and other command messages could be chunked and we would never see them. While
    we are keeping this simple, remember that production-level streaming needs to
    handle all of these types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cache` submodule checks for different headers on the message. Depending
    on each type, we will do that type of action. This can be thought of as a simple
    way to do remote procedure calls. The following list describes what we do, depending
    on each event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!!!BEGIN!!!`: We need to start listening for more data on the line since this
    means we are going to store the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!!!END!!!`: Once we see this message, we can put all of this data together
    and store it, based on our count in the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!!!GET!!!`: We are going to try to get the file stored at the numbered location
    that''s supplied to us by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!!!DELETE!!!`: If the length of the message is as long as this string, this
    means we want to delete everything from the cache. Otherwise, we will try to delete
    the data at the location specified later in the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following code to the `send.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each of the submodules that we have, we handle specific commands that may
    come across the wire. As shown by the `send` submodule, we handle anything on
    the wire other than the `WHOIS` command, which tells the main application who
    is connected to it. We try to grab the file from the specified address and write
    it back to the main application so that it's stored in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: We also added our own *protocol* to send the data. While this system is not
    foolproof and we should add some type of locking (such as a Boolean, so that we
    don't try to take in any more data before fully sending out the current data),
    it does showcase how we can send data across our system. In [Chapter 7](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml),
    *Streams - Understanding Streams and Non-Blocking I/O*, we will look at a similar
    concept, but we will utilize streams so that we don't use so much memory per thread.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we're only importing the `https` module. This means that we are
    only allowed to make requests to addresses that are served over HTTPS. If we wanted
    to support HTTP, we would have to import the `http` module and then check the
    address that the user types in. In our case, we made it as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to send data, we send the `!!!BEGIN!!!` message to let the receiver
    know that we are about to send data that will not fit into a single frame. Then,
    we end our message with the `!!!END!!!` message.
  prefs: []
  type: TYPE_NORMAL
- en: If we can't read the endpoint that we are trying to grab or our connection times
    out (both of these will drop into the error condition), we will send a `!!!FALSE!!!`
    message to let the receiver know that we are unable to fully transmit the data.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of wrapping our data in *frames* is used in almost all data transmission
    systems. Without framing, we would have to send a header that says how large the
    data transmission is. However that would mean we need to know the size of the
    content before we send it. Framing gives us the option of not sending the length
    of messages, so we can process infinitely large messages.
  prefs: []
  type: TYPE_NORMAL
- en: Framing or even boxing the data is done everywhere. If we were to look at how
    packets are created, for example, the concept still applies. Understanding this
    concept is key to understanding lower levels of the communication stack. Another
    concept that is good to know about is that not all of this data is sent at once.
    It is sent in pieces. The amount that can be sent at one time is usually set at
    the operating system level. One of the only properties that we can set is the
    `highWaterMark` property on streams. This property allows us to say how much data
    we will hold in memory before we stop reading/writing.
  prefs: []
  type: TYPE_NORMAL
- en: The cache application acts similar to the send submodule, except it responds
    to more commands. If we get a `get` command, we can try and grab that item from
    the cache and send it back to the main module; otherwise, we just send back `null`.
    If we get a `delete` command, we will delete the entire cache if we get no other
    arguments; otherwise, we delete the item at that specific location. Finally, if
    we get the beginning or ending wrappers, we will process the data and cache it.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we infinitely increase our cache. We could easily add a concept of
    a certain time threshold that is allowed for data to stay in the cache (**Time
    To Live** or **TTL**) or only hold a certain number of records, usually by utilizing
    a **Least Recently Used** (**LRU**) destroy system. We will look at how to implement
    caching strategies in [Chapter 9](bbac23b7-12e2-412e-9aaa-f31b1c321dab.xhtml),
    *Practical Example - Building a Static Server*. Just note that these concepts
    are quite ubiquitous with caches and caching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heading back into the code, create `main.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create placeholders for our state variables. These correspond to the various
    states that our messages could be in and the data that is passing through the
    socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the method to handle data that comes in through our cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the method that will handle the messages from our `send` worker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two final helper methods. These will test the number of workers we have
    to know when we are ready to start and the other will add the method handlers
    to each worker socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final large method will handle all of the messages that we receive via
    the command-line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create the server and start the workers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Certain parts of the main file have been removed to shorten the amount of code
    in this book. The full example can be found in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a bunch of helpers that will handle messages from the cache and
    send subsystems. We also map the socket to our handler. The utilization of a `WeakMap`
    means that we don't need to clean up if these subsystems ever crash or are somehow
    removed. We also map the name of the subsystem to the socket so that we can easily
    send messages to the correct subsystem. Finally, we create a server and handle
    the incoming connections. In our case, we only want to check for two subsystems.
    Once we can see two, we start our program.
  prefs: []
  type: TYPE_NORMAL
- en: There are some flaws in the way we wrap our messages, and testing the number
    of connections to see whether we are ready is also not the best way to handle
    our program. However, this does allow us to create a somewhat complex application
    so that we can quickly test the ideas that can be seen here. With this application,
    we are now able to cache various files from a remote resource and grab them when
    we want them. This is a system that is similar to how some static servers work.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the preceding application, it is easy to see how we can utilize
    local connections to create a message-passing system with only the core Node.js
    system. What is also interesting is that we can replace the `listen` method's
    argument from a pipe name with a port number and we would be able to turn this
    application from utilizing named pipes/Unix domain sockets to utilizing TCP sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Before we had these worker threads inside of Node.js, we had to separate everything
    out with processes. In the beginning, we only had the fork system. This made some
    systems quite complex when we started creating more processes. To help us with
    this concept, the `cluster` module was created. With the `cluster` module, it's
    easier to manage processes in a master/slave architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the cluster module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the `cluster` module may not be used as much as it was in the past, since
    we have worker threads inside of Node.js, one concept still makes it powerful.
    We are able to share server connections between the various worker threads that
    are in our application. Our main process will use a strategy so that we only send
    requests to one of the slave processes. This allows us to handle quite a few simultaneous
    connections that are all running on the exact same address and port.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this concept, let''s implement the preceding program but by utilizing
    the `cluster` module. Now, we will ensure the send and cache subsystems are tied
    to the main process. Our child processes will be tied to handling requests that
    come over our server. One thing to remember is that if the parent process dies,
    our child processes will also die. If we don''t want this behavior, when we call
    the fork inside our main process, we can pass the `detached : true` option. This
    will allow the worker threads to still run. This is usually not a behavior that
    we want when we are using the `cluster` module, but it is good to know that it''s
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: We have split up the following program into more manageable chunks. To see the
    full program, head over to the code repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should be able to write a program that''s similar to our IPC program.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import all of the Node modules that are needed to implement
    our previous example in `cluster` mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the constants that we can use across our processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After, we add an `if/else` check to see whether we are the master process or
    whether we are a slave process. The same file is used for both types of processes,
    so we need a way to distinguish between the two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the master code. This will go into the first block of the `if/else`
    statement. Our master node needs to spin the slave nodes up, as well as initialize
    our cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that will handle each of the requests, just like we did in the
    previous example. Remember that if we stop our main process, it will destroy all
    of the slave processes. If we receive the `STOP` command, we will just kill the
    main process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `GRAB` case statement. To do this, utilize the `https` module to
    make the request for the resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write the slave code. All of this will be held in the `else` block.
    Remember that we can share the same server location and port between the slaves.
    We will also handle all incoming requests through the search parameters of the
    URL being passed to us. This is why we imported the `URL` class from the `url`
    module. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the slave code by starting an `HTTP` server. Remember that they will
    all share the same location and port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can handle the command that''s been passed to us. This will be similar
    to our previous example, except we will talk to the master process through **Inter-Process
    Communication** (**IPC**) and handle the requests through the HTTP/2 server. Only
    the `get` command is shown here; the rest can be found in this chapter''s GitHub
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that both of the workers create an `HTTP` server. While they
    are both creating separate objects, they are sharing the underlying port. This
    is completely hidden from us, but this is done with the `cluster` module. If we
    tried doing something similar to this with our own version while utilizing the
    `child_process` fork method, we would get an error stating `EADDRINUSE`.
  prefs: []
  type: TYPE_NORMAL
- en: If we request the data that we stored in HTML format, we'll see it come back
    as pure text. This is in relation to the `writeHead` method. We are telling the
    browser that we are writing `text/plain`. The browser takes this information and
    utilizes it to see how it needs to parse the data. Since it gets told that the
    data is plain, it will just display it on the screen. If we change that to `text/html`
    when we get HTML data, it will parse it and try to render it.
  prefs: []
  type: TYPE_NORMAL
- en: With these two methods, we are able to write programs that can fully utilize
    all of the cores on our system while still being able to work together. The first
    architecture gives us a nice decoupled system and is how most applications should
    be written, but the `cluster` module gives us a nice way to handle servers. By
    mixing these two methods, we can create a high throughput server. While building
    these client/server applications can be easy in Node.js, there are some things
    to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls for new developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While utilizing the Unix domain sockets/Windows named pipes are great, there
    are a couple of differences between the two systems. Node.js tries to hide these
    details so that we can focus on the applications that we want to write, but they
    still show up. Two of the most common causes that can trip up new developers are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows named pipes will automatically be destroyed when the application quits.
    Unix domain sockets will not. This means that when we exit our application, we
    should try to utilize the `fs` module and unlink the file through the `unlink`
    or `unlinkSync` methods. We should also check to see whether it exists when we
    start up, just in case we don't exit gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows' framing of data can be larger than the Unix domain sockets. This means
    an application can appear to work on Windows but will fail on Unix systems. This
    is why we created the framing system that we did. It is good to keep this in mind,
    especially when we might want to use external libraries to handle parts of building
    the IPC systems. Some of these systems do not keep this idea in mind, and bugs
    can easily creep up because of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js aims to be completely cross-operating system compatible, but these systems
    always have slight quirks when it comes to actually operating across systems.
    If we want to make sure that it works, just like we have to do if we can't guarantee
    what browser our end users will use, then we need to test it on all of our systems.
  prefs: []
  type: TYPE_NORMAL
- en: While developing server applications that span a single computer is common,
    we still need to hook all of these applications up. When we are no longer able
    to utilize a single computer, we will need to talk over the network. We'll take
    a look at these protocols next.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building applications that can talk among themselves on the same machine
    can be cool, eventually, we'll need to talk to external systems. Most of these
    systems will be browsers in our case, but they may be other servers. Since we
    can't use named pipes/Unix domain sockets over these channels, we need to use
    various protocols of a network.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we could still use the preceding two concepts across servers by
    utilizing shared drives/filesystem sharing, but this isn't a good idea. We've
    already shown that we can change the `listen` method from pointing to a file to
    pointing to a port. In the worst case, we can use a shared filesystem, but it
    is nowhere near optimal and it should be converted into utilizing one of the protocols
    we'll cover here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocols that we will focus on are the two low-level protocols known as
    **Transmission Control Protocol** (**TCP**) and **User** **Datagram** **Protocol**
    (**UDP**). We will also take a look at the higher-level protocol of the web: **Hyper
    Text Transfer Protocol** **version 2** (**HTTP/2**). With these protocols, we
    will be able to create highly available applications that can be accessed over
    a network.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP and UDP are the two low-level network protocols that we have access to in
    Node.js. Either of these allows us to send and receive messages, but they differ
    in a couple of key areas. First, TCP needs to have a receiver and sender for the
    connection. Because of this, we can't just broadcast on a channel and not care
    whether anybody is listening.
  prefs: []
  type: TYPE_NORMAL
- en: Second, on top of TCP needing the handshake process, it also gives us guaranteed
    transmission. This means that we know when we send data that it should get to
    the other end (obviously, there are ways for this to fail, but we aren't going
    to look at that). Finally, TCP guarantees the order of delivery. If we send data
    on a channel to a receiver, it will get the data in the order that we sent it.
    Because of these reasons, we utilize TCP when we need to guarantee delivery and
    ordering.
  prefs: []
  type: TYPE_NORMAL
- en: TCP actually doesn't necessarily need to send the data in order. Everything
    is sent in packets. They can actually go to different servers and the routing
    logic can mean that later packets arrive at the receiver earlier than later ones.
    However, our receiver's network card reorders them for us so that it looks like
    we are getting them sequentially. There are many other cool aspects that go into
    TCP, including the transmission of data, that are outside the scope of this book,
    but anyone can look up networking and look at more of these concepts and how they
    are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: This being said, TCP seems like something that we would always want to use.
    Why wouldn't we use something that guarantees delivery? Also, we don't necessarily
    need to broadcast if we can just loop through all of the current connections and
    send the data to everyone. However, because of all of these guarantees, this makes
    TCP heavier and slower. This isn't good for systems that we need to send data
    as fast as possible over. For this type of data transmission, we can utilize UDP.
    UDP gives us something called stateless transmission. Stateless transmission means
    we can send data on a channel and it will blast the data out and forget it. We
    don't need to connect to an address; instead, we can just send the data (as long
    as no one else is bound to that address and port). We can even set up a multicast
    system where anyone can listen to that address and it might pick up the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some areas where this type of transmission is wanted/needed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Send buy/sell orders for a stock exchange. Since the data moves fast, we only
    care about the latest information. Due to this, if we don't receive some of the
    buy/sell orders, it doesn't really matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player position data for video games. We can only update the game so fast. We
    can also interpolate or *infer* where a player is on the screen if we already
    know which direction they were moving and the speed that they were going at. Because
    of this, we can receive a player position at any rate and figure out where they
    should be (this is sometimes known as the tick rate of the server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telecommunication data does not necessarily care if we send all of the data
    as long as we sent most of it. We don't need to guarantee delivery of the full
    video/audio signal since we can still give a great picture with most of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are just a couple of the areas where UDP comes in handy. With an understanding
    of both these systems, we will take a look at them by building a highly simplified
    and impractical stock application. The behavior will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server will post new stock symbols and the amount of stock that is available.
    Then, it will blast the information on a known port to everyone over UDP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server will store all of the information related to a client's positions.
    This way, there is no way for a client to be able to manipulate how many shares
    they may have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A client will send a buy or sell order to the server. The server will figure
    out whether it can handle the request. All of this traffic will be over TCP since
    we need to guarantee that we know the server received our message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server will respond with an error or a success message, telling the client
    that their book has updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server will blast that a buy or sell happened for stock over the UDP channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This application looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the preceding program should be familiar, except for the new module
    that we are utilizing: the `dgram` module. This module allows us to send data
    while utilizing UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are creating a socket that is utilizing UDP4 (UDP over IPv4, or what
    we normally know as IP addresses). We also state that we are reusing the address
    and port. We''re doing this so that we can test this locally. We wouldn''t want
    this in any other scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We bind to port `3000` since that is where the server is going to send data.
    Then, we state that we want to add ourselves to the multicast address. For multicasting
    to work, the server needs to send data over a multicast address. These addresses
    are usually specific addresses that the OS has set up. Each OS can decide what
    addresses to use, but the one we have chosen should work on any OS.
  prefs: []
  type: TYPE_NORMAL
- en: Once we receive a message, we print it out. Again, this should look familiar.
    Node.js is based around events and streams and they are usually named the same
    thing for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The other pieces of this program handle user input and then send data over the
    TCP channel that we opened up when we created a new socket (this should look similar
    to our IPC program from before, except we pass a port and an IP address).
  prefs: []
  type: TYPE_NORMAL
- en: 'The server for this application is a bit more involved since it holds all of
    the logic of the stock application. We will break this down into several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `main.js` and import the `dgram` and `net` modules into
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some constants for our multicast address, the error message for bad input,
    and the `Maps` for our stock tickers and clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two servers. The first is used to listen for UDP messages,
    while the second is used to receive TCP messages. We will utilize the TCP server
    to process client requests. TCP is reliable, while UDP isn''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to set up a listener on the TCP server for any connections. Once
    we have a client connection, we will set them up with a temporary table so that
    we can store their portfolio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up a data listener for the client. When we receive data, we will parse
    the message according to the following format, `SELL/BUY <Ticker> <Number>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this parsing, we check to see whether the client can perform the action.
    If they can, we will change their portfolio and send them a message stating the
    change was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have told the client that we have processed their request, we can write
    to all of the clients through the UDP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to process new stock tickers from the server through our standard
    input. Once we have processed the request, we send the data out on the UDP server
    so that every client knows about the new stock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Almost all of the error logic has been removed for clarity, but you can find
    it in this book's GitHub repository. As shown in the preceding example, it is
    very simple to utilize all of the interfaces for sending data to various other
    points, be it other parts of our application or remote clients that are listening
    for data. They all use almost the exact same interface and only differ in slight
    implementation details. Just remember that if there needs to be a guarantee of
    delivery, TCP should be used; otherwise, UDP isn't a bad choice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the HTTP/2 standard and how the server system is a bit
    different in Node.js compared to the `net`, `dgram`, and `http`/`https` modules.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it was introduced in 2015, the adoption of the technology is slow. HTTP/2
    builds on the HTTP/1.1 protocol to allow for various features that caused issues
    for the previous system. This gives us the ability to use a single TCP connection
    to receive different requests. This wasn't possible with HTTP/1.1 and it caused
    an issue called head of line blocking. This meant that we could only really handle
    so many TCP connections and that if we had a long-running TCP connection, it could
    block all of the requests after it.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2 also gave us the ability to push server-side resources. This means that
    if a server knows that a resource is going to be needed by a browser, such as
    a CSS file, it could push it to the server before it was needed. Finally, HTTP/2
    gave us built-in streaming capabilities. This means we're able to use a connection
    and send data down as a stream instead of needing to send it all at once.
  prefs: []
  type: TYPE_NORMAL
- en: There are other benefits that HTTP/2 gives us, but these are the main ones.
    While the `http` and `https` modules will probably still be used for some time
    to come, the `http2` module in Node.js should be used for any new applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `http2` module in Node.js differs from the `http` and `https` modules in
    a few ways. While it doesn''t follow the standards that many of the other IPC/networking
    modules give us, it does give us some nice ways to send data over HTTP/2\. One
    of these allows us to stream files directly from the filesystem instead of needing
    to create a pipe for the file and send it to the sender. An example of some of
    these differences can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice that the server needs a private key and a public certificate.
    These are used to make sure that the connection that is set up is secure, meaning
    that no one can see what''s being sent. For us to be able to do this, we need
    a tool such as `openssl` to create these keys and certificates. With Windows 10
    and other Unix operating systems, we get this for free. Otherwise, we need to
    download Cygwin ([http://www.cygwin.com/](http://www.cygwin.com/)). With `openssl`,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates the necessary private key and public certificate for
    the server and clients to communicate securely. We won''t go into the details
    of how this is implemented here, but information on how this can be achieved with
    SSL/TLS can be found at: [https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/).'
  prefs: []
  type: TYPE_NORMAL
- en: With our certificate and key generated, we can read them in so that our server
    can start running. We will also notice that instead of responding to a message
    event or a request event, we respond to the stream event. HTTP/2 utilizes streams
    instead of trying to send all of the data at once. While Node.js wrapped the requests
    and responses in streams for us, this is not how it may be handled at the OS layer.
    HTTP/2 utilizes streaming right away. This is the reason why the event is called
    a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Next, instead of calling the `writeHead` method, we are just responding to the
    stream. When we want to send information, we utilize the `respond` method and
    send the headers this way. We will also notice that some of the headers are prefixed
    with a colon. This is specific to the `http2` module and if problems are found
    when sending specific headers, putting a colon in front may solve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than what we''ve talked about here, this should look quite similar to
    a normal HTTP(s) server that we write in Node.js. There are some other benefits
    that we get with the `http2` module, however, and one of them is responding with
    a file instead of having to read in that file and send it that way. This can be
    seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The program numbers are key points of interest, and they work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are reading information from the `package.json` file, just like we did in
    the previous chapter. We are also running this through the `npm run <script>`
    command. Check out the previous chapter to see how to do this and how we can use
    configuration data from the `package.json` file in our programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have set a specific configuration option for our server. If the client that
    connects to us can't use HTTP/2, then we will automatically convert everything
    back into the negotiated protocol, for example, HTTP/1.1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We grab the extension from the URL. This way, we can see whether we support
    that file type and send the appropriate file; otherwise, we will pass back a 400
    error message and state that it was a bad request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method allows us to pass a path in. Then, the core system will handle sending
    the file for us. All we need to do is make sure that we set the content type correctly
    so that the browser can interpret the data for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error at any point, such as the file not existing, we will respond
    with the correct status, such as a 404 or a 500 error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While what we've presented here is just a small fraction of the `http2` module,
    this showcases how the `http2` module is different and how we can set one up quite
    quickly. If need be, refer back to [https://Node.js.org/dist/latest-v12.x/docs/api/http2.html](https://nodejs.org/dist/latest-v12.x/docs/api/http2.html)
    to see how the `http2` module is different from `http` and all of the capabilities
    that come with it. Now, we will take a look at the future state of the web and
    take a look at HTTP/3 in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: A quick glance at HTTP/3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While what we have talked about is the present state of communicating among
    processes, threads, and other computers, there is a new way for information to
    be passed around. The new standard is called HTTP/3 and it differs from the previous
    two iterations significantly.
  prefs: []
  type: TYPE_NORMAL
- en: The QUIC protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quick UDP Internet Connections** (**QUIC**) was introduced by Google in 2012\.
    It is a protocol similar to the TCP, **Transport Layer Security** (**TLS**), and
    HTTP/2 protocols, but it is all transmitted over UDP. This means that a lot of
    the overhead that is built into TCP has been removed and replaced with a new method
    of sending data. On top of this, since TLS is built into the protocol, it means
    that the overhead of adding security to an already defined protocol has been removed.'
  prefs: []
  type: TYPE_NORMAL
- en: QUIC is currently used by Google for things such as YouTube. While QUIC never
    gained mass appeal, it helped spawn the group that would create the HTTP/3 standard
    committee and helped guide the committee to utilize UDP as the base layer for
    the protocol. It also showcased how security can be built into the protocol and
    has lead HTTP/3 to have it built into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other companies have started to implement the QUIC protocol while HTTP/3 is
    being developed. One notable inclusion to this list is Cloudflare. Their blogpost
    on implementing QUIC can be found here: [https://blog.cloudflare.com/the-road-to-quic/](https://blog.cloudflare.com/the-road-to-quic/).'
  prefs: []
  type: TYPE_NORMAL
- en: While HTTP/3 has not been added to Node.js, there are some packages that implement
    the QUIC protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A look at node-quic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While QUIC is not the easiest to work with right now and the only official implementation
    is written in the Chromium source, there have been other implementations that
    allow us to play around with this protocol. The `node-quic` module has been deprecated
    in favor of the QUIC implementation that is trying to be built into Node.js directly,
    but we can still use it to see how we might utilize QUIC or even HTTP/3 in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the module by running the `npm install node-quic`
    command. With this, we are able to write a simple client-server application. The
    client should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will notice that sending data is similar to how we would do so in the UDP
    system; that is, we can send data without actually needing to bind to the port
    and address. Other than this, the system runs similarly to how other applications
    would run when written with the `http` or `http2` module. One interesting thing
    to note here is that data is automatically converted into a string for us when
    we receive it from the `quic` stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'A server for the previous client would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Again, it should look familiar to the other applications that we have written.
    One of the major differences here is that this module was written with promises
    in mind. Other than this, the data we receive is a string, so we turn ourselves
    off if we receive `quit` by running the `stopListening` method. Otherwise, we
    write the data we want to send to the steam, similar to what we do with the HTTP/2
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stay on top of the implementation status for HTTP/3, it is recommended that
    you check out the following link and check it periodically: [https://quicwg.org/](https://quicwg.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is quite simple to utilize the QUIC protocol with this module.
    This may also be useful for internal applications. Just note that neither the
    QUC protocol nor the HTTP/3 standard has been fully finished and probably won't
    be for a few more years. This doesn't mean that you shouldn't utilize them—it
    just means that things can change quite quickly while the standard is in flux.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending data between different systems, be it threads, processes, or even other
    computers, is what we do as developers. There are many tools we can use to do
    this, and we have looked at most of them. Just remember that while one option
    can appear to make an application simple, that doesn't always mean it is the best
    choice. When it comes to breaking our systems up, we usually want to assign a
    specific job to a unit and use some form of IPC, such as named pipes, to communicate.
    If we need to move that task to another computer, we can always switch it out
    for TCP.
  prefs: []
  type: TYPE_NORMAL
- en: With these IPC and web protocols under our belt, we will be able to tackle most
    problems with ease in Node.js and to write both the client-side and server-side
    code when it comes to web applications. However, Node.js isn't just built for
    web applications. We can pretty much do anything that other languages can and
    even have most of the tools that these other languages have. This chapter should
    have helped to clarify that and helped solidify how Node.js can be built into
    an already developed application ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in mind, we will be looking at streaming and how we can implement
    our own streams in Node.js.
  prefs: []
  type: TYPE_NORMAL
