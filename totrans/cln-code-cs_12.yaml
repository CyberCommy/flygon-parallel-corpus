- en: Using Tools to Improve Code Quality
  prefs: []
  type: TYPE_NORMAL
- en: As a programmer, enhancing code quality is one of your chief concerns. Improving
    the quality of your code demands the utilization of various tools. Tools designed
    to improve your code and also speed up development include **code metrics**, **quick
    actions**, the **JetBrains dotTrace** profiler, **JetBrains ReSharper**, and **Telerik
    JustDecompile**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main thing that we''ll be doing in this chapter, with the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining good-quality code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing code cleanup and calculating code metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using quick actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JetBrains dotTrace profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JetBrains ReSharper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Telerik JustDecompile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have gained the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Using code metrics to measure software complexity and maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using quick actions to make changes using a single command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling your code and analyzing bottlenecks with JetBrains dotTrace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring code using JetBrains ReSharper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling code and generating a solution using Telerik JustDecompile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this book: [https://github.com/PacktPublishing/Clean-Code-in-C-](https://github.com/PacktPublishing/Clean-Code-in-C-)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 Community Edition or higher: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telerik JustDecompile: [https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains ReSharper Ultimate: [https://www.jetbrains.com/resharper/download/#section=resharper-installer](https://www.jetbrains.com/resharper/download/#section=resharper-installer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining good-quality code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good code quality is an essential software property. Financial loss, wasted
    time and effort, and even death can result from poor-quality code. High-standard
    code will have the qualities of **Performance, Availability, Security, Scalability,
    Maintainability, Accessibility, Deployability, and Extensibility** (**PASSMADE**).
  prefs: []
  type: TYPE_NORMAL
- en: Performant code is small, only does what it needs to do, and is very fast. Performant
    code will not grind a system to a halt. Things that grind a system to a halt are
    file **input/output** (**I/O**) operations, memory usage, and **central processing
    unit** (**CPU**) usage. Low-performing code is a candidate for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Availability refers to the software being continually available at the required
    level of performance. Availability is the ratio between the **time the software
    is functional** (**tsf**) to the **total time it is expected to function** (**ttef**)—for
    example, tsf=700; ttef =744\. 700 / 744 = 0.9409 = 94.09% availability.
  prefs: []
  type: TYPE_NORMAL
- en: Secure code is the code that properly validates input to protect against invalid
    data formats, an invalid range data, and malicious attacks and that fully authenticates
    and authorizes its users. Secure code is also code that is fault-tolerant. For
    example, if you are halfway through transferring money from one account to another
    and the system crashes, the operation should ensure the data remains intact, with
    no money taken from the account in question.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable code is code that can safely handle exponential growth in the number
    of users using the system without the system grinding to a halt. So, whether the
    software handles one request per hour or a million requests per hour, there is
    no degradation in the performance of the code and no downtime due to excessive
    load.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability refers to how easy it is to fix bugs and add new functionality.
    Maintainable code should be well organized and easy to read. There should be low
    coupling and high cohesion so that the code can be easily maintained and extended.
  prefs: []
  type: TYPE_NORMAL
- en: Accessible code is code that people with limited abilities find easy to modify
    and use according to their needs. Examples include user interfaces with high contrast,
    a narrator for dyslexic and blind people, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Deployability focuses on the users of the software—will the users be standalone,
    remote access, or local network users? Whatever type the user is, the software
    should be very easy to deploy without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility refers to how easy it is to extend an application by adding new
    features to it. Spaghetti code and highly coupled code with low cohesion make
    this very difficult and error-prone. Such code can be very hard to read and maintain
    and is not easy to extend. Therefore, extensible code is code that is easy to
    read, easy to maintain, and—thus—easy to add new features to.
  prefs: []
  type: TYPE_NORMAL
- en: From the PASSMADE requirements of good-quality code, you can easily infer the
    kinds of problems that could arise from failing to meet these requirements. Failure
    to meet these requirements would lead to poor-performing code that becomes frustrating
    and unusable. Clients would be annoyed by increased downtime. Hackers would be
    able to exploit vulnerabilities in code that is not secure. The software would
    degrade exponentially as more users are added to the system. Code would be hard
    to fix or extend, and in some cases impossible to fix or extend. Users with limited
    abilities would not be able to modify the software around their limitations, and
    deployment would be a configuration nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: Code metrics to the rescue. Code metrics enable developers to measure code complexity
    and maintainability and thus help us to identify code that is a candidate for
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: With Quick Actions, you can use a single command to refactor C# code, such as
    extracting code out into its own method. JetBrains dotTrace allows you to profile
    your code and find performance bottlenecks. Further, JetBrains ReSharper is a
    Visual Studio productivity extension that enables you to analyze code quality
    and detect code smells, enforce coding standards, and refactor code. And Telerik
    JustDecompile helps you to decompile existing code for troubleshooting, and to
    create **Intermediate Language** (**IL**), C#, and VB.NET projects from. This
    is particularly useful if you no longer have the source code and need to maintain
    or extend the compiled code. You can even generate debug symbols for the compiled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a deeper look at the tools mentioned, starting with code metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Performing code cleanup and calculating code metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at how to gather code metrics, we first need to know what they
    are and why they are useful to us. **Code metrics** are mainly concerned with
    software complexity and maintainability. They help us to see how we can improve
    the maintainability of our source code and reduce source code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code metrics that Visual Studio 2019 calculates for you consist of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability index**: Code maintainability is an essential component of **Application
    Lifecycle Management** (**ALM**). Until software reaches its end of life, it must
    be maintained. The harder the code base is to maintain, the shorter the lifespan
    of the source code before a complete replacement is required. Writing new software
    to replace an ailing system is far more work and is more expensive when compared
    to maintaining an existing system. The measurement for code maintainability is
    known as the maintainability index. This value is an integer value between 0 and
    100\. Here are the maintainability index ratings, their colors, and their meanings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any value from *20 and above* has a *green* rating for good maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moderately maintainable code is *between 10 and 19*, with a *yellow* rating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything *below 10* has a rating of *red*, meaning that it is hard to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclomatic complexity**: Code complexity, also known as cyclomatic complexity,
    refers to the various code paths through the software. The more paths there are,
    the more complex the software is. And the more complex the software is, the harder
    it is to test and maintain. Complex code can lead to more error-prone software
    releases and can make it hard to maintain and extend the software. Hence, it is
    advisable that code complexity should be kept to a minimum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth of Inheritance**: The Depth of Inheritance and class coupling metrics
    are affected by the popular programming paradigm called **Object-Oriented Programming** (**OOP**).
    With OOP, classes are able to inherit from other classes. A class that is inherited
    from is known as a base class. Classes that inherit from a base class are known
    as subclasses. The metric for the number of classes that inherit from each other
    is known as the Depth of Inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deeper the level of inheritance, the more chance you have of errors in derived
    classes if something is changed in one of the base classes. The ideal Depth of
    Inheritance is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class coupling**: OOP allows class coupling. Class coupling arises when a
    class is directly referenced by a parameter, a local variable, a return type,
    a method call, a generic or template instantiation, base classes, interface implementations,
    fields defined on extra types, and an attribute decoration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class coupling code metric determines the level of coupling between classes.
    To make code easier to maintain and extend, class coupling should be kept to an
    absolute minimum. In OOP, one way to achieve this is to use interface-based programming.
    This way, you avoid directly accessing a class. The benefit of this method of
    programming is that you can swap classes in and out, as long as they implement
    the same interface. Poor-quality code has high coupling and low cohesion, but
    good-quality code has low coupling and high cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, software should be highly cohesive with low coupling, because it makes
    programs easier to test, maintain, and extend.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines of source code**: The complete count of the lines of your source code,
    including blank lines, is measured by the lines of source code metric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines of executable code**: The measure of operations in executable code
    is measured by the lines of executable code metric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have a heads-up on what code metrics are and which measurements
    are available in Visual Studio 2019 version 16.4 onward, it''s time to see them
    in action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open any project you like within Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Analyze and Code Cleanup | **Run** Code Cleanup (Profile 1), as illustrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3084d347-1840-4623-b317-93e84e4a3333.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, select Calculate Code Metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the Code Metrics Results window appear, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0072829c-42dd-4d15-bdb7-62df99180ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the screenshot, all our classes, interfaces, and methods
    are marked with a *green* indicator. This means that the selected project is one
    that is maintainable. If any of these lines were marked yellow or red, then you
    would need to address them and refactor them to make them green. Well, we've covered
    code metrics, and so, naturally, we move on to cover code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Performing code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help developers identify potential problems with their source code, Microsoft
    provides the Code Analysis tool as part of Visual Studio. Code Analysis performs
    a static source code analysis. The tool will identify design flaws, issues with
    globalization, security problems, issues with performance, and interoperability
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the book solution, and select the CH11_AddressingCrossCuttingConcerns
    project. Then, from the Project menu, select Project | CH11_AddressingCrossCuttingConcerns | Properties
    from the menu. On the properties page for the project, select Code Analysis, as
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845a8cb0-51c3-4c8c-86aa-227357896190.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, if you see that the recommended analyzer
    package is not installed, click on Install to install it. Once installed, the
    version number will be displayed in the installed version box. For me, it is version
    2.9.6\. By default, the active rules are Microsoft Managed Recommended Rules.
    The location of this ruleset, as shown in the description, is C:\Program Files
    (x86)\Microsoft Visual Studio\2019\Professional\Team Tools\Static Analysis Tools\Rule
    Sets\MinimumRecommendedRules.ruleset. Open the file. It will open as a Visual
    Studio tool window, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e77dab0-0c68-4f3b-9cb3-e2c4c151e744.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, you can select and deselect rules.
    When you close the window, you will be prompted to save any changes. To run a
    code analysis, go to Analyze and Code Cleanup | Code Analysis. In order to view
    the results, you will need the Error List window to be open. You can open it from
    the View menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have run the code analysis, you will see a list of errors, warnings,
    and messages. You can address each and every one of them to improve the overall
    quality of your software. A sample of these can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce41fac1-0f57-4161-bdce-80454882fa47.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that the `CH10_AddressingCrossCuttingConcerns`
    project has *32 warnings and 13 messages*. If we were to work on the warnings
    and messages, we would get them down to 0 messages and 0 warnings. So, now that
    you have seen how to use code metrics to see how maintainable your software is
    and you've analyzed it to see what improvements you can make, it's now time to
    look at quick actions.
  prefs: []
  type: TYPE_NORMAL
- en: Using quick actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another handy tool that I like to use is the Quick Action tool. Appearing as
    a screwdriver ![](img/879fde26-23f4-46ce-a945-b990c87ea7b2.png), a lightbulb ![](img/e1db92fb-dc9b-4b31-8ab6-869d769ee72d.png),
    or an error light bulb ![](img/006b25b8-4e48-4dbb-9c13-708d087aa336.png) on a
    line of code, quick actions enable you to use a single command that will generate
    code, refactor code, suppress warnings, perform code fixes, and add `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `CH10_AddressingCrossCuttingConcerns` project had 32 warnings and
    13 messages, we can use this project to see the quick actions in action. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edbf7964-0014-4776-bd6c-5f535045eb67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the preceding screenshot, we see the lightbulb on line 10\. If we
    click on the lightbulb, the following menu pops up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/022c0406-d6cc-41eb-abaf-27bd8f8fe633.png)'
  prefs: []
  type: TYPE_IMG
- en: If we click on Add readonly modifier, the `readonly` access modifier is placed
    after the private access modifier. Have a go yourself at using quick actions to
    modify the code. It is fairly straightforward once you get the hang of it. Once
    you have had a play around with quick actions, move on to look at the JetBrains
    dotTrace profiling tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JetBrains dotTrace profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JetBrains dotTrace profiler is a part of JetBrains ReSharper Ultimate license.
    Since we will be looking at both tools, I recommend that you download and install
    JetBrains ReSharper Ultimate before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains does have a trial version available if you don't already own a copy.
    There are versions available for Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The JetBrains dotTrace profiling tool works with Mono, .NET Framework, and .NET
    Core. All application types are supported by the profiler, and you can use the
    profiler to analyze and track down performance issues with your code base. The
    profiler will help you to get to the bottom of such problems that cause 100% CPU
    usage, 100% of the disk I/O, maxing out the memory or running into overflow exception,
    and many other issues.
  prefs: []
  type: TYPE_NORMAL
- en: Many applications perform **HyperText Transfer Protocol** (**HTTP**) requests.
    The profiler will analyze how the application is processing these requests, and
    it will also do the same with **Structured Query Language** (**SQL**) queries
    on a database. Static methods and unit tests can be profiled, and you can view
    the results from within Visual Studio. There is also a standalone version that
    you can use.
  prefs: []
  type: TYPE_NORMAL
- en: There are four basic profiling options—Sampling, Tracing, Line-by-Line, and
    Timeline. The first time you start looking at the performance of an application,
    you may decide to use Sampling, which provides an accurate measurement of call
    time. Tracing and Line-by-Line offer more detailed profiling, but they do add
    more overhead (memory and CPU usage) to the program being profiled. Timeline is
    similar to sampling and collects application events over time. Between them, there
    is no problem that can't be tracked down and resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced profiling options include real-time performance counters, thread time,
    real-time CPU instructions, and thread cycle time. The real-time performance counters
    measure the time between method entry and exit. Thread time measures the thread
    running time. Based on the CPU register, the real-time CPU instructions provide
    an accurate time of method entry and exit.
  prefs: []
  type: TYPE_NORMAL
- en: The profiler can attach to running .NET Framework 4.0 (or later) or .NET Core
    3.0 (or later) applications and processes, profile local applications, and profile
    remote applications. These include standalone applications; .NET Core applications; **Internet
    Information Services** (**IIS**)-hosted web applications; IIS Express-hosted applications;
    .NET Windows Services, **Windows Communication Foundation** (**WCF**) services; Windows
    Store and **Universal Windows Platform** (**UWP**) applications; any .NET processes
    (started after you run the profiling session); desktop or console applications
    based on Mono; and Unity editor or standalone Unity applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the profiler in Visual Studio 2019 from the menu, select Extensions
    | ReSharper | Profile | Show Performance Profiler. In the following screenshot,
    you can see that nothing has been profiled yet. Also, the currently selected project
    to be profiled is set to Basic CH3, and the profiling type is set to Timeline.
    We will profile CH3 using Sampling to profile our project by expanding the Timeline
    drop-down functionality and selecting Sampling, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8647fbeb-0249-480f-b79c-7d4c03df2f1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to sample a different project, just expand the Project drop-down list
    and select the project that you want to profile. The project will be built, and
    the profiler started. Your project will then run and be shut down. The results
    will then be displayed in the dotTrace profiling application, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38f49eb2-a59e-4ae7-a6cb-90c767ffd1e4.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can see that the first of four threads are
    being shown. This is the thread for our program. The other threads are for the
    supporting processes that enable our program to run along with the finalizer thread
    that is responsible for exiting the program and cleaning up system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The All Calls menu items down the left-hand side comprise the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain List
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot Spots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The current option selected the Thread Tree. Let''s have a look at the expanded
    Call Tree in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97e6fb4a-a0e3-435d-a26d-d78c0396b512.png)'
  prefs: []
  type: TYPE_IMG
- en: The profiler shows you the complete Call Tree for your code, and that includes
    system code as well as your own code. You can see the percentage of time spent
    on making the call. This allows you to identify any long-running methods and address
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll look at the Plain List. As you can see with the Plain List view
    in the screenshot that follows, we can group it according to the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see the preceding criteria in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb7c40f-d8ac-4ced-9ae4-e0ddb8135d41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on an item in the list, you get to view the source code for
    the class where the method resides. This is useful, as you can see the code where
    the problem lies and what needs to be done. The last sampling profile screen we''ll
    look at is the Hot Spots view, illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e71a1ce2-79bd-485e-aedd-b7e3686de601.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The profiler is showing that the Main Thread, which is our code''s starting
    point, only takes 4.59% of the processing time. If you click on the root, 18%
    of the code is our user code, and 72% of the code is system code, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bba028e6-5545-492f-9e35-34bf7eb90b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: We have only touched the surface with this profiling tool. There is more to
    it, and I encourage you to try it out for yourself. The main purpose of this chapter
    is to introduce you to the tools that are available to you.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on how to use JetBrains dotTrace, I refer you to their
    online learning materials, at [https://www.jetbrains.com/profiler/documentation/documentation.html](https://www.jetbrains.com/profiler/documentation/documentation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we look at JetBrains ReSharper.
  prefs: []
  type: TYPE_NORMAL
- en: Using JetBrains ReSharper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we look at how JetBrains ReSharper can help you improve your
    code. ReSharper is quite an extensive tool, and just as with the profiler, which
    is a part of the Ultimate edition of ReSharper, we will only be touching the surface,
    but you will hopefully come to an appreciation of what the tool is and what it
    can do for you to improve your Visual Studio coding experience. Here are a few
    benefits of using ReSharper:'
  prefs: []
  type: TYPE_NORMAL
- en: With ReSharper, you can perform an analysis of your code quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will provide options to improve your code, remove code smells, and fix coding
    problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the navigation system, you are able to completely traverse your solution
    and jump to any item of interest. You have many different helpers that include
    extended IntelliSense, code reorganization, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring benefits from ReSharper's offerings that can be localized or solution-wide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also generate source code using ReSharper, such as base class and superclasses,
    and inline methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, code can be cleaned up in keeping with your company's coding policies
    to get rid of unused imports and other unused code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can visit the ReSharper menu from the Visual Studio 2019 Extensions menu.
    When in the code editor, right-clicking the mouse on a piece of code will bring
    up a context menu with the appropriate menu items. The ReSharper menu item in
    the context menu is Refactor This..., as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62d9b26f-b6e6-45f3-8575-106fddc2b60e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, from the Visual Studio 2019 menu, run Extensions | ReSharper | Inspect
    | Code Issues in Solution. ReSharper will process the solution and then display
    the Inspection Results window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/884a6f64-3229-4167-9489-7634b96632d4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, ReSharper found 527 issues with
    our code—436 of which are being displayed. These problems include common practices
    and code improvements, compiler warnings, constraint violations, language usage
    opportunities, potential code quality issues, redundancies in code, redundancies
    in symbol declarations, spelling issues, and syntax style.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we expand Compiler Warnings, we see that there are three problems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `_name` field is never assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `nre` local variable is never used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This `async` method lacks `await` operators and will run synchronously. Use
    the `await` operator to await non-blocking **Application Programming Interface**
    (**API**) calls, or `await TaskEx.Run(...)` to do CPU-bound work on a background
    thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These problems are variable declarations that don''t get assigned or used,
    and an `async` method lacking an `await` operator that will run synchronously.
    If you click on the first warning, it will take you to the line of code that is
    never assigned. Looking at the class, you can see that the string is declared
    and used, but it is never assigned. Since we check if the string contains `string.Empty`,
    we can assign that value to the declaration. Hence, the updated line will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `_name` variable still highlights, we can hover over it and see what
    the problem is. The Quick Action informs us that the `_name` variable can be marked
    read-only. Let''s add the `readonly` modifier. So, the line now becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we click on the refresh ![](img/39fdfd96-ae8b-4036-a5f8-76f71c793546.png) button,
    we will find that the number of issues found is now 526\. Yet, we fixed two problems.
    So, should the number be 525? Well, no. The second problem that we fixed was not
    a problem picked up by ReSharper, but an improvement picked up by Visual Studio
    Quick Actions. So, ReSharper is showing the correct number of issues it has detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the potential code quality issue for the `LooseCouplingB`
    class. ReSharper reports a possible `System.NullReferenceException` within this
    method. Let''s look at the code first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And sure enough, we do have `System.NullReferenceException` staring us in the
    face. We''ll look at the `LooseCouplingA` class, to confirm which members should
    be set to `null`. Also, the member to be set is `_name`, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `_name` is being checked for empty. And so, really, the code should
    be setting `_name` to `string.Empty`. So, our fixed constructor in `LooseCouplingB` becomes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we refresh the Inspection Results window, our list of issues has gone
    down by five, because apart from correctly assigning the `Name` property, we made
    use of the language usage opportunity to simplify our instantiation and initialization,
    which was detected by ReSharper. Have a play around with the tool and eliminate
    the problems found in the Inspection Results window.
  prefs: []
  type: TYPE_NORMAL
- en: 'ReSharper can also generate *dependency diagrams*. To generate a dependency
    diagram for our solution, select Extensions | ReSharper | Architecture | Show
    Project Dependency Diagram. This will display the project dependency diagram for
    our solution. The black container box called `CH06` is the namespace, and the
    gray/blue boxes prefixed with `CH06_` are projects, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dcecdbe-cc72-4c4b-b6ca-aeb80473c813.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the project dependency diagram in the `CH06` namespace,
    there is a project dependency between `CH06_SpecFlow` and `CH06_SpecFlow.Implementation`.
    Similarly, you can also generate type dependency diagrams using ReSharper. Select
    Extensions | ReSharper | Architecture | Type Dependencies Diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we generate the diagram for `ConcreteClass` in the `CH10_AddressingCrossCuttingConcerns`
    project, then the diagram will be generated, but only the `ConcreteComponent`
    class will be initially displayed. Right-click the `ConcreteComponent` box on
    the diagram and select Add All Referenced Types. You will see the addition of
    the `ExceptionAttribute` class and the `IComponent` interface. Right-click on
    the `ExceptionAttribute` class and select Add All Referenced Types, and you end
    up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea8e50b2-0ab3-4b5c-8110-b7ed7648b6ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What''s really wonderful about this tool is that you can order the diagram
    elements by namespace. This can be really useful for massive solutions with multiple
    large projects and deep-nested namespaces. Though it''s good that we can right-click
    on code and go to the item declaration, you can''t beat visually seeing the lay
    of the land in terms of the project that you are working on, and that is why this
    tool can be really useful. Here is an example of a typed dependencies diagram
    organized by namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ae67ae-8f3b-437b-9112-a5cf9be0fae3.png)'
  prefs: []
  type: TYPE_IMG
- en: Many a time, I could have really used a diagram such as this in my day-to-day
    work. This diagram is technical documentation that will help developers find their
    way around a complex solution. They will be able to see which namespaces are available
    and how everything is interlinked. This will empower developers with the correct
    knowledge as to where new classes, enums, and interfaces should be placed when
    performing new development, but also, they will know where to find objects if
    they are performing maintenance. This diagram is also good for finding duplicate
    namespaces, interfaces, and object names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at coverage. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Extensions | ReSharper | Cover | Cover Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Coverage Configuration dialog will be displayed, and the default selected
    option will be Standalone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can select a .NET app from the `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Coverage Configuration dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ad944a8-2edf-4546-8a32-e657aa46605f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Run button to start the application and collect profiling data. ReSharper
    will display the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/351aa848-072c-4355-8d75-fb92db9e3815.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application will then run. As the application is running, the coverage
    profiler will be collecting data. Our selected executable is a console application
    that displays the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34e40597-803e-4918-bb75-59127613b600.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the console window, and then press any key to exit. The coverage dialog
    will disappear, and storage will then be initialized. Finally, the Coverage Results
    Browser window will be displayed, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6678fcf-fbbc-47b2-872c-d69eec9cdf46.png)'
  prefs: []
  type: TYPE_IMG
- en: This window contains really useful information. It provides a visual indicator
    of code that was not called, marked in red. The code that was executed is marked
    in green. Using this information, you can see if the code is dead code that can
    be removed, or was not executed due to the path taken through the system but is
    still required, or was commented out for testing purposes, or was simply not called
    because the developer forgot to add the call in the correct place or a condition
    check was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'To go to the item of interest, you just have to double-click on the item, and
    then you will be taken to the specific code you are interested in. Our `Program`
    class only covers 33% of the code. So, let''s double-click `Program`, and see
    what''s the matter. The resulting output is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, the reason why some of our code was not covered
    is because calls to the code were commented out for testing purposes. We can leave
    the code as it is (which we will do in this case). However, you can also remove
    the dead code or reinstate the code by removing the comments. Now, you know why
    the code is not being covered.
  prefs: []
  type: TYPE_NORMAL
- en: Well, now that you've been introduced to ReSharper and had a look at tools to
    assist you in writing good, clean C# code, it is time to look at our next tool,
    called Telerik JustDecompile.
  prefs: []
  type: TYPE_NORMAL
- en: Using Telerik JustDecompile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have used Telerik JustDecompile on a number of occasions, for things such as
    tracking down bugs in third-party libraries, recovering essential project source
    code that has been lost, checking the strength of assembly obfuscation, and for
    learning purposes. It is a tool that I highly recommend, as over the years it
    has proven its worth many times.
  prefs: []
  type: TYPE_NORMAL
- en: The decompilation engine is open source and you can obtain the source code from [https://github.com/telerik/justdecompileengine](https://github.com/telerik/justdecompileengine),
    so you are free to contribute to the project and write your own extensions for
    it. You can download Windows Installer from the Telerik website, at [https://www.telerik.com/products/decompiler.aspx](https://www.telerik.com/products/decompiler.aspx).
    All source code is fully navigable. The decompiler is available as a standalone
    application or as a Visual Studio extension. You create VB.NET or C# projects
    from assemblies that you decompile, and you extract and save resources from the
    decompiled assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Telerik JustDecompile. We will then go through the decompilation
    process, and generate a C# project from an assembly. You may be prompted to install
    other tools during the installation process, but you can deselect the other offerings
    from Telerik.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Telerik JustDecompile standalone application. Find a .NET assembly
    and then drag it into the left pane of Telerik JustDecompile. It will decompile
    the code and display the code tree on the left. If you select an item on the left,
    the code is shown on the right, as you can see in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3aff607-0a76-4f69-a3c5-4aa285e08091.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the decompilation process is fast and it does a pretty good
    job of decompiling our assembly. The decompilation is not perfect, but in most
    cases, it does the job. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the dropdown to the right of the Plugins menu item, select C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on Tools | Create Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will sometimes be prompted to select the .NET version to target; other times,
    not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you will be asked where to save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project will then be written to that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then open the project in Visual Studio and work on it. Should you encounter
    any problems, Telerik logs the issues in your code and provides an email. You
    can always email them with any issues you encounter. They are good at responding
    to and fixing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have completed our look at the tools in this chapter, so now, let's
    look at what we have learned in summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how code metrics provide several measurements
    of code quality, and how easy it is to generate them. Code metrics include the
    number of lines—including blank lines—versus the number of executable lines of
    code, the cyclomatic complexity, the level of cohesion and coupling, and how maintainable
    your code is. The refactoring color codes are green for good, yellow for ideally
    needs refactoring, and red for definitely needs refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: You then saw how easy it is to provide a static code analysis of projects and
    view the results. Viewing and modifying rulesets that govern what gets analyzed
    and what doesn't get analyzed was also covered. Then, you experienced quick actions
    and saw how we can perform bug fixes, add using statements, and refactor code
    with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: We then used the JetBrains dotTrace profiler to measure our application's performance,
    track down bottlenecks, and identify hungry methods that take up the most processing
    time. The next tool we looked at was JetBrains ReSharper, which enables us to
    inspect code for various problems and potential improvements. We identified a
    couple of them and made the necessary changes, and saw how easy it was to improve
    the code with this tool. Then, we looked at creating architectural diagrams for
    dependencies and type dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at Telerik JustDecompile, a very useful tool that can be
    used to decompile assemblies and generate projects in either C# or VB.NET from
    them. This can be very useful when bugs are encountered or the program needs to
    be expanded, but you no longer have access to the existing source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapters that follow, we will mainly be looking at code, and how we can
    refactor it. But for now, test your knowledge with the following questions and
    further your reading with the links provided in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are code metrics, and why should we use them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name six code metric measurements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is code analysis, and why is it useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are quick actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JetBrains dotTrace used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JetBrains ReSharper used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why use Telerik JustDecompile to decompile assemblies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official Microsoft documentation on code metrics: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official Microsoft documentation on Quick Actions: [https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/quick-actions?view=vs-2019)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains dotTrace profiler: [https://www.jetbrains.com/profiler/](https://www.jetbrains.com/profiler/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
