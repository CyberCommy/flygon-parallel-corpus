- en: Chapter 10. The Microservices Development Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the **software development life cycle** (**SDLC**), it is important
    to understand the aspects of the microservice development life cycle processes
    for a successful implementation of the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: This final chapter will focus on the development process and practice of microservices
    with the help of BrownField Airline's PSS microservices example. Furthermore,
    this chapter will describe best practices in structuring development teams, development
    methodologies, automated testing, and continuous delivery of microservices in
    line with DevOps practices. Finally, this chapter will conclude by shedding light
    on the importance of the reference architecture in a decentralized governance
    approach to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing DevOps in the context of microservices development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the microservices life cycle and related processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices around the development, testing, and deployment of Internet-scale
    microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the microservice capability model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following microservices capabilities from the microservices
    capability model discussed in [Chapter 3](ch03.html "Chapter 3. Applying Microservices
    Concepts"), *Applying Microservices Concepts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps Tools**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference Architecture & Libraries**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing Tools (Anti-Fragile, RUM etc)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Reviewing the microservice capability model](img/B05447_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The new mantra of lean IT – DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the definition of DevOps in [Chapter 2](ch02.html "Chapter 2. Building
    Microservices with Spring Boot"), *Building Microservices with Spring Boot*. Here
    is a quick recap of the DevOps definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gartner defines DevOps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"DevOps represents a change in IT culture, focusing on rapid IT service delivery
    through the adoption of agile, lean practices in the context of a system-oriented
    approach. DevOps emphasizes people (and culture), and seeks to improve collaboration
    between operations and development teams. DevOps implementations utilize technology
    — especially automation tools that can leverage an increasingly programmable and
    dynamic infrastructure from a life cycle perspective."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: DevOps and microservices evolved independently. [Chapter 1](ch01.html "Chapter 1. Demystifying
    Microservices"), *Demystifying Microservices*, explored the evolution of microservices.
    In this section, we will review the evolution of DevOps and then take a look at
    how DevOps supports microservices adoption.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the era of digital disruption and in order to support modern business, IT
    organizations have to master two key areas: speed of delivery and value-driven
    delivery. This is obviously apart from being expert in leading technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: Many IT organizations failed to master this change, causing frustration to business
    users. To overcome this situation, many business departments started their own
    shadow IT or stealth IT under their control. Some smart IT organizations then
    adopted a lean IT model to respond to these situations.
  prefs: []
  type: TYPE_NORMAL
- en: However, many organizations still struggle with this transformation due to the
    large baggage of legacy systems and processes. Gartner coined the concept of a
    **pace-layered application strategy**. Gartner's view is that high speed is required
    only for certain types of applications or certain business areas. Gartner termed
    this a **system of innovation**. A system of innovation requires rapid innovations
    compared to a **system of records**. As a system of innovations needs rapid innovation,
    a lean IT delivery model is essential for such applications. Practitioners evangelized
    the lean IT model as DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key strategies used by organizations to adopt DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Some organizations positioned DevOps as a process to fill the gaps in their
    existing processes. Such organizations adopted an incremental strategy for their
    DevOps journey. The adoption path starts with Agile development, then incrementally
    adopts continuous integration, automated testing, and release to production and
    then all DevOps practices. The challenge in such organizations is the time to
    realize the full benefits as well as the mixed culture of people due to legacy
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many organizations, therefore, take a disruptive approach to adopt DevOps.
    This will be achieved by partitioning IT into two layers or even as two different
    IT units. The high-speed layer of IT uses DevOps-style practices to dramatically
    change the culture of the organization with no connection to the legacy processes
    and practices. A selective application cluster will be identified and moved to
    the new IT based on the business value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new mantra of lean IT – DevOps](img/B05447_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The intention of DevOps is not just to reduce cost. It also enables the business
    to disrupt competitors by quickly moving ideas to production. DevOps attacks traditional
    IT issues in multiple ways, as explained here.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing wastage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps processes and practices essentially speed up deliveries which improves
    quality. The speed of delivery is achieved by cutting IT wastage. This is achieved
    by avoiding work that adds no value to the business nor to desired business outcomes.
    IT wastage includes software defects, productivity issues, process overheads,
    time lag in decision making, time spent in reporting layers, internal governance,
    overestimation, and so on. By reducing these wastages, organizations can radically
    improve the speed of delivery. The wastage is reduced by primarily adopting Agile
    processes, tools, and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Automating every possible step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By automating the manually executed tasks, one can dramatically improve the
    speed of delivery as well as the quality of deliverables. The scope of automation
    goes from planning to customer feedback. Automation reduces the time to move business
    ideas to production. This also reduces a number of manual gate checks, bureaucratic
    decision making, and so on. Automated monitoring mechanisms and feedback go back
    to the development factory, which gets it fixed and quickly moved to production.
  prefs: []
  type: TYPE_NORMAL
- en: Value-driven delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps reduces the gap between IT and business through value-driven delivery.
    Value-driven delivery closely aligns IT to business by understanding true business
    values and helps the business by quickly delivering these values, which can give
    a competitive advantage. This is similar to the shadow IT concept, in which IT
    is collocated with the business and delivers business needs quickly, rather than
    waiting for heavy project investment-delivery cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, IT is partially disconnected from the business and works with
    IT KPIs, such as the number of successful project deliveries, whereas in the new
    model, IT shares business KPIs. As an example, a new IT KPI could be that IT helped
    business to achieve a 10% increase in sales orders or led to 20% increase in customer
    acquisition. This will shift IT's organizational position from merely a support
    organization to a business partner.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging development and operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, IT has different teams for development and operations. In many
    cases, they are differentiated with logical barriers. DevOps reduces the gap between
    the development and operations teams so that it can potentially reduce wastage
    and improve quality. Multidisciplinary teams work together to address problems
    at hand rather than throwing mud across the wall.
  prefs: []
  type: TYPE_NORMAL
- en: With DevOps, operations teams will have a fairly good understanding about the
    services and applications developed by development teams. Similarly, development
    teams will have a good handle on the infrastructure components and configurations
    used by the applications. As a result, operations teams can make decisions based
    exactly on service behaviors rather than enforcing standard organizational policies
    and rules when designing infrastructure components. This would eventually help
    the IT organization to improve the quality of the product as well as the time
    to resolve incidents and problem management.
  prefs: []
  type: TYPE_NORMAL
- en: In the DevOps world, speed of delivery is achieved through the automation of
    high-velocity changes, and quality is achieved through automation and people.
    Business values are achieved through efficiency, speed of delivery, quality, and
    the ability to innovate. Cost reduction is achieved through automation, productivity,
    and reducing wastage.
  prefs: []
  type: TYPE_NORMAL
- en: Meeting the trio – microservices, DevOps, and cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The trio—cloud, microservices, and DevOps—targets a set of common objectives:
    speed of delivery, business value, and cost benefit. All three can stay and evolve
    independently, but they complement each other to achieve the desired common goals.
    Organizations embarking on any of these naturally tend to consider the other two
    as they are closely linked together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meeting the trio – microservices, DevOps, and cloud](img/B05447_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many organizations start their journey with DevOps as an organizational practice
    to achieve high-velocity release cycles but eventually move to the microservices
    architecture and cloud. It is not mandatory to have microservices and cloud support
    DevOps. However, automating the release cycles of large monolithic applications
    does not make much sense, and in many cases, it would be impossible to achieve.
    In such scenarios, the microservices architecture and cloud will be handy when
    implementing DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: If we flip a coin, cloud does not need a microservices architecture to achieve
    its benefits. However, to effectively implement microservices, both cloud and
    DevOps are essential.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, if the objective of an organization is to achieve a high speed of
    delivery and quality in a cost-effective way, the trio together can bring tremendous
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud as the self-service infrastructure for Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main driver for cloud is to improve agility and reduce cost. By reducing
    the time to provision the infrastructure, the speed of delivery can be increased.
    By optimally utilizing the infrastructure, one can bring down the cost. Therefore,
    cloud directly helps achieve both speed of delivery and cost.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 9](ch09.html "Chapter 9. Managing Dockerized Microservices
    with Mesos and Marathon"), *Managing Dockerized Microservices with Mesos and Marathon*,
    without having a cloud infrastructure with cluster management software, it would
    be hard to control the infrastructure cost when deploying microservices. Hence,
    the cloud with self-service capabilities is essential for microservices to achieve
    their full potential benefits. In the microservices context, the cloud not only
    helps abstract the physical infrastructure but also provides software APIs for
    dynamic provisioning and automatic deployments. This is referred to as **infrastructure
    as code** or **software-defined infrastructure**.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps as the practice and process for microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservice is an architecture style that enables quick delivery. However,
    microservices cannot provide the desired benefits by themselves. A microservices-based
    project with a delivery cycle of 6 months does not give the targeted speed of
    delivery or business agility. Microservices need a set of supporting delivery
    practices and processes to effectively achieve their goal.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is the ideal candidate for the underpinning process and practices for
    microservice delivery. DevOps processes and practices gel well with the microservices
    architecture's philosophies.
  prefs: []
  type: TYPE_NORMAL
- en: Practice points for microservices development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a successful microservice delivery, a number of development-to-delivery
    practices need to be considered, including the DevOps philosophy. In the previous
    chapters, you learned the different architecture capabilities of microservices.
    In this section, we will explore the nonarchitectural aspects of microservice
    developments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding business motivation and value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices should not be used for the sake of implementing a niche architecture
    style. It is extremely important to understand the business value and business
    KPIs before selecting microservices as an architectural solution for a given problem.
    A good understanding of business motivation and business value will help engineers
    focus on achieving these goals in a cost-effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Business motivation and value should justify the selection of microservices.
    Also, using microservices, the business value should be realizable from a business
    point of view. This will avoid situations where IT invests in microservices but
    there is no appetite from the business to leverage any of the benefits that microservices
    can bring to the table. In such cases, a microservices-based development would
    be an overhead to the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the mindset from project to product development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Demystifying Microservices"),
    *Demystifying Microservices*, microservices are more aligned to product development.
    Business capabilities that are delivered using microservices should be treated
    as products. This is in line with the DevOps philosophy as well.
  prefs: []
  type: TYPE_NORMAL
- en: The mindset for project development and product development is different. The
    product team will always have a sense of ownership and take responsibility for
    what they produce. As a result, product teams always try to improve the quality
    of the product. The product team is responsible not only for delivering the software
    but also for production support and maintenance of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Product teams are generally linked directly to a business department for which
    they are developing the product. In general, product teams have both an IT and
    a business representative. As a result, product thinking is closely aligned with
    actual business goals. At every moment, product teams understand the value they
    are adding to the business to achieve business goals. The success of the product
    directly lies with the business value being gained out of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the high-velocity release cycles, product teams always get a sense
    of satisfaction in their delivery, and they always try to improve on it. This
    brings a lot more positive dynamics within the team.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, typical product teams are funded for the long term and remain
    intact. As a result, product teams become more cohesive in nature. As they are
    small in size, such teams focus on improving their process from their day-to-day
    learnings.
  prefs: []
  type: TYPE_NORMAL
- en: One common pitfall in product development is that IT people represent the business
    in the product team. These IT representatives may not fully understand the business
    vision. Also, they may not be empowered to take decisions on behalf of the business.
    Such cases can result in a misalignment with the business and lead to failure
    quite rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to consider a collocation of teams where business and IT
    representatives reside at the same place. Collocation adds more binding between
    IT and business teams and reduces communication overheads.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a development philosophy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different organizations take different approaches to developing microservices,
    be it a migration or a new development. It is important to choose an approach
    that suits the organization. There is a wide verity of approaches available, out
    of which a few are explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Design thinking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Design thinking is an approach primarily used for innovation-centric development.
    It is an approach that explores the system from an end user point of view: what
    the customers see and how they experience the solution. A story is then built
    based on observations, patterns, intuition, and interviews.'
  prefs: []
  type: TYPE_NORMAL
- en: Design thinking then quickly devises solutions through solution-focused thinking
    by employing a number of theories, logical reasoning, and assumptions around the
    problem. The concepts are expanded through brainstorming before arriving at a
    converged solution.
  prefs: []
  type: TYPE_NORMAL
- en: Once the solution is identified, a quick prototype is built to consider how
    the customer responds to it, and then the solution is adjusted accordingly. When
    the team gets satisfactory results, the next step is taken to scale the product.
    Note that the prototype may or may not be in the form of code.
  prefs: []
  type: TYPE_NORMAL
- en: Design thinking uses human-centric thinking with feelings, empathy, intuition,
    and imagination at its core. In this approach, solutions will be up for rethinking
    even for known problems to find innovative and better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The start-up model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More and more organizations are following the start-up philosophy to deliver
    solutions. Organizations create internal start-up teams with the mission to deliver
    specific solutions. Such teams stay away from day-to-day organizational activities
    and focus on delivering their mission.
  prefs: []
  type: TYPE_NORMAL
- en: Many start-ups kick off with a small, focused team—a highly cohesive unit. The
    unit is not worried about how they achieve things; rather, the focus is on what
    they want to achieve. Once they have a product in place, the team thinks about
    the right way to build and scale it.
  prefs: []
  type: TYPE_NORMAL
- en: This approach addresses quick delivery through production-first thinking. The
    advantage with this approach is that teams are not disturbed by organizational
    governance and political challenges. The team is empowered to think out of the
    box, be innovative, and deliver things. Generally, a higher level of ownership
    is seen in such teams, which is one of the key catalysts for success. Such teams
    employ just enough processes and disciplines to take the solution forward. They
    also follow a fail fast approach and course correct sooner than later.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile practice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most commonly used approach is the Agile methodology for development. In
    this approach, software is delivered in an incremental, iterative way using the
    principles put forth in the Agile manifesto. This type of development uses an
    Agile method such as Scrum or XP. The Agile manifesto defines four key points
    that Agile software development teams should focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Individuals and interaction over processes and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working software over comprehensive documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer collaboration over contract negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to change over following a plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 12 principles of Agile software development can be found at [http://www.agilemanifesto.org/principles.html](http://www.agilemanifesto.org/principles.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using the concept of Minimum Viable Product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Irrespective of the development philosophy explained earlier, it is essential
    to identify a **Minimum Viable Product** (**MVP**) when developing microservice
    systems for speed and agility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric Ries, while pioneering the lean start-up movement, defined MVP as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Minimum Viable Product is that version of a new product which allows a team
    to collect the maximum amount of validated learning about customers with the least
    effort."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The objective of the MVP approach is to quickly build a piece of software that
    showcases the most important aspects of the software. The MVP approach realizes
    the core concept of an idea and perhaps chooses those features that add maximum
    value to the business. It helps get early feedback and then course corrects as
    necessary before building a heavy product.
  prefs: []
  type: TYPE_NORMAL
- en: The MVP may be a full-fledged service addressing limited user groups or partial
    services addressing wider user groups. Feedback from customers is extremely important
    in the MVP approach. Therefore, it is important to release the MVP to the real
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Overcoming the legacy hotspot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand the environmental and political challenges in
    an organization before embarking on microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: It is common in microservices to have dependencies on other legacy applications,
    directly or indirectly. A common issue with direct legacy integration is the slow
    development cycle of the legacy application. An example would be an innovative
    railway reservation system relaying on an age-old **transaction processing facility**
    (**TPF**) for some of the core backend features, such as reservation. This is
    especially common when migrating legacy monolithic applications to microservices.
    In many cases, legacy systems continue to undergo development in a non-Agile way
    with larger release cycles. In such cases, microservices development teams may
    not be able to move so quickly because of the coupling with legacy systems. Integration
    points might drag the microservices developments heavily. Organizational political
    challenges make things even worse.
  prefs: []
  type: TYPE_NORMAL
- en: There is no silver bullet to solve this issue. The cultural and process differences
    could be an ongoing issue. Many enterprises ring-fence such legacy systems with
    focused attention and investments to support fast-moving microservices. Targeted
    C-level interventions on these legacy platforms could reduce the overheads.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing challenges around databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automation is key in microservices development. Automating databases is one
    of the key challenges in many microservice developments.
  prefs: []
  type: TYPE_NORMAL
- en: In many organizations, DBAs play a critical role in database management, and
    they like to treat the databases under their control differently. Confidentiality
    and access control on data is also cited as a reason for DBAs to centrally manage
    all data.
  prefs: []
  type: TYPE_NORMAL
- en: Many automation tools focus on the application logic. As a result, many development
    teams completely ignore database automation. Ignoring database automation can
    severely impact the overall benefits and can derail microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid such situations, the database has to be treated in the same
    way as applications with appropriate source controls and change management. When
    selecting a database, it is also important to consider automation as one of the
    key aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Database automation is much easier in the case of NoSQL databases but is hard
    to manage with traditional RDBMs. **Database Lifecycle Management** (**DLM**)
    as a concept is popular in the DevOps world, particularly to handle database automation.
    Tools such as DBmaestro, Redgate DLM, Datical DB, and Delphix support database
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing self-organizing teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important activities in microservices development is to establish
    the right teams for development. As recommended in many DevOps processes, a small,
    focused team always delivers the best results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing self-organizing teams](img/B05447_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As microservices are aligned with business capabilities and are fairly loosely
    coupled products, it is ideal to have a dedicated team per microservice. There
    could be cases where the same team owns multiple microservices from the same business
    area representing related capabilities. These are generally decided by the coupling
    and size of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Team size is an important aspect in setting up effective teams for microservices
    development. The general notion is that the team size should not exceed 10 people.
    The recommended size for optimal delivery is between 4 and 7\. The founder of
    Amazon.com, Jeff Bezos, coined the theory of two-pizza teams. Jeff's theory says
    the team will face communication issues if the size gets bigger. Larger teams
    work with consensus, which results in increased wastage. Large teams also lose
    ownership and accountability. A yardstick is that the product owner should get
    enough time to speak to individuals in the team to make them understand the value
    of what they are delivering.
  prefs: []
  type: TYPE_NORMAL
- en: Teams are expected to take full ownership in ideating for, analyzing, developing,
    and supporting services. Werner Vogels from Amazon.com calls this *you build it
    and you run it*. As per Werner's theory, developers pay more attention to develop
    quality code to avoid unexpected support calls. The members in the team consist
    of fullstack developers and operational engineers. Such a team is fully aware
    of all the areas. Developers understand operations as well as operations teams
    understand applications. This not only reduces the changes of throwing mud across
    teams but also improves quality.
  prefs: []
  type: TYPE_NORMAL
- en: Teams should have multidisciplinary skills to satisfy all the capabilities required
    to deliver a service. Ideally, the team should not rely on external teams to deliver
    the components of the service. Instead, the team should be self-sufficient. However,
    in most organizations, the challenge is on specialized skills that are rare. For
    example, there may not be many experts on a graph database in the organization.
    One common solution to this problem is to use the concept of consultants. Consultants
    are SMEs and are engaged to gain expertise on specific problems faced by the team.
    Some organizations also use shared or platform teams to deliver some common capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Team members should have a complete understanding of the products, not only
    from the technical standpoint but also from the business case and the business
    KPIs. The team should have collective ownership in delivering the product as well
    as in achieving business goals together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Agile software development also encourages having self-organizing teams. Self-organizing
    teams act as a cohesive unit and find ways to achieve their goals as a team. The
    team automatically align themselves and distribute the responsibilities. The members
    in the team are self-managed and empowered to make decisions in their day-to-day
    work. The team''s communication and transparency are extremely important in such
    teams. This emphasizes the need for collocation and collaboration, with a high
    bandwidth for communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing self-organizing teams](img/B05447_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, both **Microservice A** and **Microservice B** represent
    related business capabilities. Self-organizing teams treat everyone in the team
    equally, without too many hierarchies and management overheads within the team.
    The management would be thin in such cases. There won't be many designated vertical
    skills in the team, such as team lead, UX manager, development manager, testing
    manager, and so on. In a typical microservice development, a shared product manager,
    shared architect, and a shared people manager are good enough to manage the different
    microservice teams. In some organizations, architects also take up responsibility
    for delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Self-organizing teams have some level of autonomy and are empowered to take
    decisions in a quick and Agile mode rather than having to wait for long-running
    bureaucratic decision-making processes that exist in many enterprises. In many
    of these cases, enterprise architecture and security are seen as an afterthought.
    However, it is important to have them on board from the beginning. While empowering
    the teams with maximum freedom for developers in decision-making capabilities,
    it is equally important to have fully automated QA and compliance so as to ensure
    that deviations are captured at the earliest.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between teams is important. However, in an ideal world, it should
    be limited to interfaces between microservices. Integrations between teams ideally
    has to be handled through consumer-driven contracts in the form of test scripts
    rather than having large interface documents describing various scenarios. Teams
    should use mock service implementations when the services are not available.
  prefs: []
  type: TYPE_NORMAL
- en: Building a self-service cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key aspects that one should consider before embarking on microservices
    is to build a cloud environment. When there are only a few services, it is easy
    to manage them by manually assigning them to a certain predesignated set of virtual
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: However, what microservice developers need is more than just an IaaS cloud platform.
    Neither the developers nor the operations engineers in the team should worry about
    where the application is deployed and how optimally it is deployed. They also
    should not worry about how the capacity is managed.
  prefs: []
  type: TYPE_NORMAL
- en: This level of sophistication requires a cloud platform with self-service capabilities,
    such as what we discussed in [Chapter 9](ch09.html "Chapter 9. Managing Dockerized
    Microservices with Mesos and Marathon"), *Managing Dockerized Microservices with
    Mesos and Marathon*, with the Mesos and Marathon cluster management solutions.
    Containerized deployment discussed in [Chapter 8](ch08.html "Chapter 8. Containerizing
    Microservices with Docker"), *Containerizing Microservices with Docker*, is also
    important in managing and end to-end-automation. Building this self-service cloud
    ecosystem is a prerequisite for microservice development.
  prefs: []
  type: TYPE_NORMAL
- en: Building a microservices ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the capability model in [Chapter 3](ch03.html "Chapter 3. Applying
    Microservices Concepts"), *Applying Microservices Concepts*, microservices require
    a number of other capabilities. All these capabilities should be in place before
    implementing microservices at scale.
  prefs: []
  type: TYPE_NORMAL
- en: These capabilities include service registration, discovery, API gateways, and
    an externalized configuration service. All are provided by the Spring Cloud project.
    Capabilities such as centralized logging, monitoring, and so on are also required
    as a prerequisite for microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a DevOps-style microservice life cycle process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is the best-suited practice for microservices development. Organizations
    already practicing DevOps do not need another practice for microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the life cycle of microservices development.
    Rather than reinventing a process for microservices, we will explore DevOps processes
    and practices from the microservice perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we explore DevOps processes, let''s iron out some of the common terminologies
    used in the DevOps world:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**): This automates the application build and
    quality checks continuously in a designated environment, either in a time-triggered
    manner or on developer commits. CI also publishes code metrics to a central dashboard
    as well as binary artifacts to a central repository. CI is popular in Agile development
    practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous delivery** (**CD**): This automates the end-to-end software delivery
    practice from idea to production. In a non-DevOps model, this used to be known
    as **Application Lifecycle Management** (**ALM**). One of the common interpretations
    of CD is that it is the next evolution of CI, which adds QA cycles into the integration
    pipeline and makes the software ready to release to production. A manual action
    is required to move it to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous deployment**: This is an approach to automating the deployment
    of application binaries to one or more environments by managing binary movement
    and associated configuration parameters. Continuous deployment is also considered
    as the next evolution of CD by integrating automatic release processes into the
    CD pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Release Automation** (**ARA**): ARA tools help monitor and manage
    end-to-end delivery pipelines. ARA tools use CI and CD tools and manage the additional
    steps of release management approvals. ARA tools are also capable of rolling out
    releases to different environments and rolling them back in case of a failed deployment.
    ARA provides a fully orchestrated workflow pipeline, implementing delivery life
    cycles by integrating many specialized tools for repository management, quality
    assurance, deployment, and so on. XL Deploy and Automic are some of the ARA tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the DevOps process for microservices development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a DevOps-style microservice life cycle process](img/B05447_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now further explore these life cycle stages of microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: Value-driven planning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Value-driven planning is a term used in Agile development practices. Value-driven
    planning is extremely important in microservices development. In value-driven
    planning, we will identify which microservices to develop. The most important
    aspect is to identify those requirements that have the highest value to business
    and those that have the lowest risks. The MVP philosophy is used when developing
    microservices from the ground up. In the case of monolithic to microservices migration,
    we will use the guidelines provided in [Chapter 3](ch03.html "Chapter 3. Applying
    Microservices Concepts"), *Applying Microservices Concepts*, to identify which
    services have to be taken first. The selected microservices are expected to precisely
    deliver the expected value to the business. Business KPIs to measure this value
    have to be identified as part of value-driven planning.
  prefs: []
  type: TYPE_NORMAL
- en: Agile development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the microservices are identified, development must be carried out in an
    Agile approach following the Agile manifesto principles. The scrum methodology
    is used by most of the organizations for microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The continuous integration steps should be in place to automatically build the
    source code produced by various team members and generate binaries. It is important
    to build only once and then move the binary across the subsequent phases. Continuous
    integration also executes various QAs as part of the build pipeline, such as code
    coverage, security checks, design guidelines, and unit test cases. CI typically
    delivers binary artefacts to a binary artefact repository and also deploys the
    binary artefacts into one or more environments. Part of the functional testing
    also happens as part of CI.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once continuous integration generates the binaries, they are moved to the testing
    phase. A fully automated testing cycle is kicked off in this phase. It is also
    important to automate security testing as part of the testing phase. Automated
    testing helps improve the quality of deliverables. The testing may happen in multiple
    environments based on the type of testing. This could range from the integration
    test environment to the production environment to test in production.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuous release to production takes care of actual deployment, infrastructure
    provisioning, and rollout. The binaries are automatically shipped and deployed
    to production by applying certain rules. Many organizations stop automation with
    the staging environment and make use of manual approval steps to move to production.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous monitoring and feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The continuous monitoring and feedback phase is the most important phase in
    Agile microservices development. In an MVP scenario, this phase gives feedback
    on the initial acceptance of the MVP and also evaluates the value of the service
    developed. In a feature addition scenario, this further gives insight into how
    this new feature is accepted by users. Based on the feedback, the services are
    adjusted and the same cycle is then repeated.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the continuous delivery pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed the life cycle of microservices development.
    The life cycle stages can be altered by organizations based on their organizational
    needs but also based on the nature of the application. In this section, we will
    take a look at a sample continuous delivery pipeline as well as toolsets to implement
    a sample pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools available to build end-to-end pipelines, both in the open
    source and commercial space. Organizations can select the products of their choice
    to connect pipeline tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the XebiaLabs periodic table for a tool reference to build continuous
    delivery pipelines. It is available at [https://xebialabs.com/periodic-table-of-devops-tools/](https://xebialabs.com/periodic-table-of-devops-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: The pipelines may initially be expensive to set up as they require many toolsets
    and environments. Organizations may not realize an immediate cost benefit in implementing
    the delivery pipeline. Also, building a pipeline needs high-power resources. Large
    build pipelines may involve hundreds of machines. It also takes hours to move
    changes through the pipeline from one end to the other. Hence, it is important
    to have different pipelines for different microservices. This will also help decoupling
    between the releases of different microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Within a pipeline, parallelism should be employed to execute tests on different
    environments. It is also important to parallelize the execution of test cases
    as much as possible. Hence, designing the pipeline based on the nature of the
    application is important. There is no one size fits all scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The key focus in the pipeline is on end-to-end automation, from development
    to production, and on failing fast if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pipeline is an indicative one for microservices and explores
    the different capabilities that one should consider when developing a microservices
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating the continuous delivery pipeline](img/B05447_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The continuous delivery pipeline stages are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The development stage has the following activities from a development perspective.
    This section also indicates some of the tools that can be used in the development
    stage. These tools are in addition to the planning, tracking, and communication
    tools such as Agile JIRA, Slack, and others used by Agile development teams. Take
    a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**: The development team requires an IDE or a development environment
    to cut source code. In most organizations, developers get the freedom to choose
    the IDEs they want. Having said this, the IDEs can be integrated with a number
    of tools to detect violations against guidelines. Generally, Eclipse IDEs have
    plugins for static code analysis and code matrices. SonarQube is one example that
    integrates other plugins such as Checkstyle for code conventions, PMD to detect
    bad practices, FindBugs to detect potential bugs, and Cobertura for code coverage.
    It is also recommended to use Eclipse plugins such as ESVD, Find Security Bugs,
    SonarQube Security Rules, and so on to detect security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit test cases**: The development team also produces unit test cases using
    JUnit, NUnit, TestNG, and so on. Unit test cases are written against components,
    repositories, services, and so on. These unit test cases are integrated with the
    local Maven builds. The unit test cases targeting the microservice endpoints (service
    tests) serve as the regression test pack. Web UI, if written in AngularJS, can
    be tested using Karma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer-driven contracts**: Developers also write CDCs to test integration
    points with other microservices. Contract test cases are generally written as
    JUnit, NUnit, TestNG, and so on and are added to the service tests pack mentioned
    in the earlier steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mock testing**: Developers also write mocks to simulate the integration endpoints
    to execute unit test cases. Mockito, PowerMock, and others are generally used
    for mock testing. It is good practice to deploy a mock service based on the contract
    as soon as the service contract is identified. This acts as a simple mechanism
    for service virtualization for the subsequent phases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior driven design** (**BDD**): The Agile team also writes BDD scenarios
    using a BDD tool, such as Cucumber. Typically, these scenarios are targeted against
    the microservices contract or the user interface that is exposed by a microservice-based
    web application. Cucumber with JUnit and Cucumber with Selenium WebDriver, respectively,
    are used in these scenarios. Different scenarios are used for functional testing,
    user journey testing, as well as acceptance testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code repository**: A source control repository is a part and parcel
    of development. Developers check-in their code to a central repository, mostly
    with the help of IDE plugins. One microservice per repository is a common pattern
    used by many organizations. This disallows other microservice developers from
    modifying other microservices or writing code based on the internal representations
    of other microservices. Git and Subversion are the popular choices to be used
    as source code repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build tools**: A build tool such as Maven or Gradle is used to manage dependencies
    and build target artifacts—in this case, Spring Boot services. There are many
    cases, such as basic quality checks, security checks and unit test cases, code
    coverage, and so on, that are integrated as part of the build itself. These are
    similar to the IDE, especially when IDEs are not used by developers. The tools
    that we examined as part of the IDEs are also available as Maven plugins. The
    development team does not use containers such as Docker until the CI phase of
    the project. All the artifacts have to be versioned properly for every change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact repository**: The artifact repository plays a pivotal role in the
    development process. The artifact repository is where all build artifacts are
    stored. The artifact repository could be Artifactory, Nexus, or any similar product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database schemas**: Liquibase and Flyway are commonly used to manage, track,
    and apply database changes. Maven plugins allow interaction with the Liquibase
    or Flyway libraries. The schema changes are versioned and maintained, just like
    source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the code is committed to the repository, the next phase, continuous integration,
    automatically starts. This is done by configuring a CI pipeline. This phase builds
    the source code with a repository snapshot and generates deployable artifacts.
    Different organizations use different events to kickstart the build. A CI start
    event may be on every developer commit or may be based on a time window, such
    as daily, weekly, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The CI workflow is the key aspect of this phase. Continuous integration tools
    such as Jenkins, Bamboo, and others play the central role of orchestrating the
    build pipeline. The tool is configured with a workflow of activities to be invoked.
    The workflow automatically executes configured steps such as build, deploy, and
    QA. On the developer commit or on a set frequency, the CI kickstarts the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following activities take place in a continuous integration workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build and QA**: The workflow listens to Git webhooks for commits. Once it
    detects a change, the first activity is to download the source code from the repository.
    A build is executed on the downloaded snapshot source code. As part of the build,
    a number of QA checks are automatically performed, similarly to QA executed in
    the development environment. These include code quality checks, security checks,
    and code coverage. Many of the QAs are done with tools such as SonarQube, with
    the plugins mentioned earlier. It also collects code metrics such as code coverage
    and more and publishes it to a central database for analysis. Additional security
    checks are executed using OWASP ZAP Jenkins'' plugins. As part of the build, it
    also executes JUnit or similar tools used to write test cases. If the web application
    supports Karma for UI testing, Jenkins is also capable of running web tests written
    in Karma. If the build or QA fails, it sends out alarms as configured in the system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Packaging**: Once build and QA are passed, the CI creates a deployable package.
    In our microservices case, it generates the Spring Boot standalone JAR. It is
    recommended to build Docker images as part of the integration build. This is the
    one and only place where we build binary artifacts. Once the build is complete,
    it pushes the immutable Docker images to a Docker registry. This could be on Docker
    Hub or a private Docker registry. It is important to properly version control
    the containers at this stage itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integration tests**: The Docker image is moved to the integration environment
    where regression tests (service tests) and the like are executed. This environment
    has other dependent microservices capabilities, such as Spring Cloud, logging,
    and so on, in place. All dependent microservices are also present in this environment.
    If an actual dependent service is not yet deployed, service virtualization tools
    such as MockServer are used. Alternately, a base version of the service is pushed
    to Git by the respective development teams. Once successfully deployed, Jenkins
    triggers service tests (JUnits against services), a set of end-to-end sanity tests
    written in Selenium WebDriver (in the case of web) and security tests with OWASP
    ZAP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many types of testing to be executed as part of the automated delivery
    process before declaring the build ready for production. The testing may happen
    by moving the application across multiple environments. Each environment is designated
    for a particular kind of testing, such as acceptance testing, performance testing,
    and so on. These environments are adequately monitored to gather the respective
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In a complex microservices environment, testing should not be seen as a last-minute
    gate check; rather, testing should be considered as a way to improve software
    quality as well as to avoid last-minute failures. Shift left testing is an approach
    of shifting tests as early as possible in the release cycle. Automated testing
    turns software development to every-day development and every-day testing mode.
    By automating test cases, we will avoid manual errors as well as the effort required
    to complete testing.
  prefs: []
  type: TYPE_NORMAL
- en: CI or ARA tools are used to move Docker images across multiple test environments.
    Once deployed in an environment, test cases are executed based on the purpose
    of the environment. By default, a set of sanity tests are executed to verify the
    test environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover all the types of tests that are required in the
    automated delivery pipeline, irrespective of the environment. We have already
    considered some types of tests as part of the development and integration environment.
    Later in this section, we will also map test cases against the environments in
    which they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Different candidate tests for automation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will explore different types of tests that are candidates
    for automation when designing an end-to-end delivery pipeline. The key testing
    types are described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Automated sanity tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When moving from one environment to another, it is advisable to run a few sanity
    tests to make sure that all the basic things are working. This is created as a
    test pack using JUnit service tests, Selenium WebDriver, or a similar tool. It
    is important to carefully identify and script all the critical service calls.
    Especially if the microservices are integrated using synchronous dependencies,
    it is better to consider these scenarios to ensure that all dependent services
    are also up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Regression tests ensure that changes in software don't break the system. In
    a microservices context, the regression tests could be at the service level (Rest
    API or message endpoints) and written using JUnit or a similar framework, as explained
    earlier. Service virtualizations are used when dependent services are not available.
    Karma and Jasmine can be used for web UI testing.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where microservices are used behind web applications, Selenium WebDriver
    or a similar tool is used to prepare regression test packs, and tests are conducted
    at the UI level rather than focusing on the service endpoints. Alternatively,
    BDD tools, such as Cucumber with JUnit or Cucumber with Selenium WebDriver, can
    also be used to prepare regression test packs. CI tools such as Jenkins or ARA
    are used to automatically trigger regression test packs. There are other commercial
    tools, such as TestComplete, that can also be used to build regression test packs.
  prefs: []
  type: TYPE_NORMAL
- en: Automated functional testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Functional test cases are generally targeted at the UIs that consume the microservices.
    These are business scenarios based on user stories or features. These functional
    tests are executed on every build to ensure that the microservice is performing
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: BDD is generally used in developing functional test cases. Typically in BDD,
    business analysts write test cases in a domain-specific language but in plain
    English. Developers then add scripts to execute these scenarios. Automated web
    testing tools such as Selenium WebDriver are useful in such scenarios, together
    with BDD tools such as Cucumber, JBehave, SpecFlow, and so on. JUnit test cases
    are used in the case of headless microservices. There are pipelines that combine
    both regression testing and functional testing as one step with the same set of
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is much similar to the preceding functional test cases. In many cases,
    automated acceptance tests generally use the screenplay or journey pattern and
    are applied at the web application level. The customer perspective is used in
    building the test cases rather than features or functions. These tests mimic user
    flows.
  prefs: []
  type: TYPE_NORMAL
- en: BDD tools such as Cucumber, JBehave, and SpecFlow are generally used in these
    scenarios together with JUnit or Selenium WebDriver, as discussed in the previous
    scenario. The nature of the test cases is different in functional testing and
    acceptance testing. Automation of acceptance test packs is achieved by integrating
    them with Jenkins. There are many other specialized automatic acceptance testing
    tools available on the market. FitNesse is one such tool.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is important to automate performance testing as part of the delivery pipeline.
    This positions performance testing from a gate check model to an integral part
    of the delivery pipeline. By doing so, bottlenecks can be identified at very early
    stages of build cycles. In some organizations, performance tests are conducted
    only for major releases, but in others, performance tests are part of the pipeline.
    There are multiple options for performance testing. Tools such as JMeter, Gatling,
    Grinder, and so on can be used for load testing. These tools can be integrated
    into the Jenkins workflow for automation. Tools such as BlazeMeter can then be
    used for test reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Application Performance Management tools such as AppDynamics, New Relic, Dynatrace,
    and so on provide quality metrics as part of the delivery pipeline. This can be
    done using these tools as part of the performance testing environment. In some
    pipelines, these are integrated into the functional testing environment to get
    better coverage. Jenkins has plugins in to fetch measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Real user flow simulation or journey testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is another form of test typically used in staging and production environments.
    These tests continuously run in staging and production environments to ensure
    that all the critical transactions perform as expected. This is much more useful
    than a typical URL ping monitoring mechanism. Generally, similar to automated
    acceptance testing, these test cases simulate user journeys as they happen in
    the real world. These are also useful to check whether the dependent microservices
    are up and running. These test cases could be a carved-out subset of acceptance
    test cases or test packs created using Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Automated security testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is extremely important to make sure that the automation does not violate
    the security policies of the organization. Security is the most important thing,
    and compromising security for speed is not desirable. Hence, it is important to
    integrate security testing as part of the delivery pipeline. Some security evaluations
    are already integrated in the local build environment as well as in the integration
    environment, such as SonarQube, Find Security Bugs, and so on. Some security aspects
    are covered as part of the functional test cases. Tools such as BDD-Security,
    Mittn, and Gauntlt are other security test automation tools following the BDD
    approach. VAPT can be done using tools such as ImmuniWeb. OWASP ZAP and Burp Suite
    are other useful tools in security testing.
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Exploratory testing is a manual testing approach taken by testers or business
    users to validate the specific scenarios that they think automated tools may not
    capture. Testers interact with the system in any manner they want without prejudgment.
    They use their intellect to identify the scenarios that they think some special
    users may explore. They also do exploratory testing by simulating certain user
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing, canary testing, and blue-green deployments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When moving applications to production, A/B testing, blue-green deployments,
    and canary testing are generally applied. A/B testing is primarily used to review
    the effectiveness of a change and how the market reacts to the change. New features
    are rolled out to a certain set of users. Canary release is moving a new product
    or feature to a certain community before fully rolling out to all customers. Blue-green
    is a deployment strategy from an IT point of view to test the new version of a
    service. In this model, both blue and green versions are up and running at some
    point of time and then gracefully migrate from one to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Other nonfunctional tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: High availability and antifragility testing (failure injection tests) are also
    important to execute before production. This helps developers unearth unknown
    errors that may occur in a real production scenario. This is generally done by
    breaking the components of the system to understand their failover behavior. This
    is also helpful to test circuit breakers and fallback services in the system.
    Tools such as Simian Army are useful in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in production
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Testing in Production** (**TiP**) is as important as all the other environments
    as we can only simulate to a certain extend. There are two types of tests generally
    executed against production. The first approach is running real user flows or
    journey tests in a continuous manner, simulating various user actions. This is
    automated using one of the **Real User Monitoring** (**RUM**) tools, such as AppDynamics.
    The second approach is to wiretap messages from production, execute them in a
    staging environment, and then compare the results in production with those in
    the staging environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Antifragility testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Antifragility testing is generally conducted in a preproduction environment
    identical to production or even in the production environment by creating chaos
    in the environment to take a look at how the application responds and recovers
    from these situations. Over a period of time, the application gains the ability
    to automatically recover from most of these failures. Simian Army is one such
    tool from Netflix. Simian Army is a suite of products built for the AWS environment.
    Simian Army is for disruptive testing using a set of autonomous monkeys that can
    create chaos in the preproduction or production environments. Chaos Monkey, Janitor
    Monkey, and Conformity Monkey are some of the components of Simian Army.
  prefs: []
  type: TYPE_NORMAL
- en: Target test environments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The different test environments and the types of tests targeted on these environments
    for execution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development environment**: The development environment is used to test the
    coding style checks, bad practices, potential bugs, unit tests, and basic security
    scanning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration test environment**: Integration environment is used for unit
    testing and regression tests that span across multiple microservices. Some basic
    security-related tests are also executed in the integration test environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and diagnostics**: Performance tests are executed in the performance
    test environment. Application performance testing tools are deployed in these
    environments to collect performance metrics and identify bottlenecks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional test environment**: The functional test environment is used to
    execute a sanity test and functional test packs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UAT environment**: The UAT environment has sanity tests, automated acceptance
    test packs, and user journey simulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging**: The preproduction environment is used primarily for sanity tests,
    security, antifragility, network tests, and so on. It is also used for user journey
    simulations and exploratory testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production**: User journey simulations and RUM tests are continuously executed
    in the production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making proper data available across multiple environments to support test cases
    is the biggest challenge. Delphix is a useful tool to consider when dealing with
    test data across multiple environments in an effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuous deployment is the process of deploying applications to one or more
    environments and configuring and provisioning these environments accordingly.
    As discussed in [Chapter 9](ch09.html "Chapter 9. Managing Dockerized Microservices
    with Mesos and Marathon"), *Managing Dockerized Microservices with Mesos and Marathon*,
    infrastructure provisioning and automation tools facilitate deployment automation.
  prefs: []
  type: TYPE_NORMAL
- en: From the deployment perspective, the released Docker images are moved to production
    automatically once all the quality checks are successfully completed. The production
    environment, in this case, has to be cloud based with a cluster management tool
    such as Mesos or Marathon. A self-service cloud environment with monitoring capabilities
    is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster management and application deployment tools ensure that application
    dependencies are properly deployed. This automatically deploys all the dependencies
    that are required in case any are missing. It also ensures that a minimum number
    of instances are running at any point in time. In case of failure, it automatically
    rolls back the deployments. It also takes care of rolling back upgrades in a graceful
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible, Chef, or Puppet are tools useful in moving configurations and binaries
    to production. The Ansible playbook concepts can be used to launch a Mesos cluster
    with Marathon and Docker support.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once an application is deployed in production, monitoring tools continuously
    monitor its services. Monitoring and log management tools collect and analyze
    information. Based on the feedback and corrective actions needed, information
    is fed to the development teams to take corrective actions, and the changes are
    pushed back to production through the pipeline. Tools such as APM, Open Web Analytics,
    Google Analytics, Webalizer, and so on are useful tools to monitor web applications.
    Real user monitoring should provide end-to-end monitoring. QuBit, Boxever, Channel
    Site, MaxTraffic, and so on are also useful in analyzing customer behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Automated configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration management also has to be rethought from a microservices and DevOps
    perspective. Use new methods for configuration management rather than using a
    traditional statically configured CMDB. The manual maintenance of CMDB is no longer
    an option. Statically managed CMDB requires a lot of mundane tasks to maintain
    entries. At the same time, due to the dynamic nature of the deployment topology,
    it is extremely hard to maintain data in a consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: The new styles of CMDB automatically create CI configurations based on an operational
    topology. These should be discovery based to get up-to-date information. The new
    CMDB should be capable of managing bare metals, virtual machines, and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices development governance, reference architectures, and libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have an overall enterprise reference architecture and a standard
    set of tools for microservices development to ensure that development is done
    in a consistent manner. This helps individual microservices teams to adhere to
    certain best practices. Each team may identify specialized technologies and tools
    that are suitable for their development. In a polyglot microservices development,
    there are obviously multiple technologies used by different teams. However, they
    have to adhere to the arching principles and practices.
  prefs: []
  type: TYPE_NORMAL
- en: For quick wins and to take advantage of timelines, microservices development
    teams may deviate from these practices in some cases. This is acceptable as long
    as the teams add refactoring tasks in their backlogs. In many organizations, although
    the teams make attempts to reuse something from the enterprise, reuse and standardization
    generally come as an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make sure that the services are catalogued and visible in
    the enterprise. This improves the reuse opportunities of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the relationship between microservices and
    DevOps. We also examined a number of practice points when developing microservices.
    Most importantly, you learned the microservices development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we also examined how to automate the microservices delivery
    pipeline from development to production. As part of this, we examined a number
    of tools and technologies that are helpful when automating the microservices delivery
    pipeline. Finally, we touched base with the importance of reference architectures
    in microservices governance.
  prefs: []
  type: TYPE_NORMAL
- en: Putting together the concepts of microservices, challenges, best practices,
    and various capabilities covered in this book makes a perfect recipe for developing
    successful microservices at scale.
  prefs: []
  type: TYPE_NORMAL
