- en: '*Chapter 14*: Android Dialog Windows'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to present the user with a pop-up dialog
    window. We can then put all that we know into the first phase of our first app,
    **Note to Self**. We will then explore the latest Android and Java features in
    this chapter and the next four (up to [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)*,*
    *Localization*), and use our newly acquired knowledge to enhance the Note to Self
    app at each stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each chapter will also build a selection of smaller apps that are separate
    from this main app. So, what does this chapter hold in store for you? Well, we
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple app with a pop-up dialog box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `DialogFragment` class to begin the Note to Self app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding string resources in our projects instead of hardcoding text in our layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Android naming conventions for the first time to make our code more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing more complex dialog boxes to capture input from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2014).
  prefs: []
  type: TYPE_NORMAL
- en: Dialog windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On many occasions, in our apps, we will want to show the user some information
    or even ask for confirmation of an action in a pop-up window. This is known as
    a **dialog** window. If you quickly scan the palette in Android Studio, then you
    might be surprised to see that there is no mention whatsoever of dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Dialogs in Android are more advanced than a simple widget or even a whole layout.
    They are classes that can have layouts and other **User Interface** (**UI**) elements
    of their own.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to create a dialog window in Android is to use the `FragmentDialog`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fragments are a wide and vital topic in Android, and we will spend much of the
    second half of this book exploring and using them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a neat pop-up dialog (using `FragmentDialog`) for our user to interact
    with is a great introduction to fragments, and it's not overly complicated at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Dialog Demo project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously mentioned that the best way to create a dialog in Android is via
    the `FragmentDialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, create a new project in Android Studio using the Empty Activity
    template and call it `Dialog Demo`. As you have come to expect, the completed
    code for this project is in the [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Dialog
    Demo` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a DialogFragment class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class in Android Studio by right-clicking on the folder with the
    name of your package (the same one that has the `MainActivity.java` file). Select
    `MyDialog`. Press the *Enter* key to create the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to change the class declaration to extend `DialogFragment`.
    When you have done so, your new class should look similar to the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add code to this class, a little bit at a time, and explain what
    is happening at each step. Now, we need to import the `DialogFragment` class.
    You can do this by holding down the *Alt* key and then tapping on *Enter* or by
    adding the following line of highlighted code after the package declaration at
    the top of the `MyDialog.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Just like so many classes in the Android API, `DialogFragment` provides us with
    methods that we can override in order to interact with the different events that
    will occur with the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to override the `onCreateDialog` method.
    Study it carefully, and we will examine what is happening next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to import the `Dialog`, `Bundle`, and `AlertDialog` classes in
    the usual way or by adding the following highlighted code manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is still one error in the code because we are missing the `return` statement
    for the `onCreateDialog` method. We will add this later on when we have finished
    coding the rest of the method.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we first added the overridden `onCreateDialog` method.
    This will be called by Android when we later show the dialog to the user via code
    in the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the `onCreateDialog` method, we get our hands on a new class. We
    declare and initialize an object of the `AlertDialog.Builder` type, which needs
    a reference to `MainActivity` passed into its constructor. This is why we use
    the `getActivity()` method as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `getActivity` method is part of the `Fragment` class (and, therefore, `DialogFragment`
    too), and it returns a reference to `Activity`, which will create `DialogFragment`.
    In this case, that is our `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine what we can do with `builder` now that we have declared and initialized
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Using chaining to configure DialogFragment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we can use our `builder` object to do the remainder of the work. There is
    something slightly odd in the following code snippet. If you quickly scan the
    next three blocks of code, you will notice that there is a distinct lack of semicolons,
    `;`. These three blocks of code are, in fact, just one line to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen this before but in a less pronounced situation; that is, when we
    created a `Toast` message and added a `.show()` method to the end of it. This
    is called **chaining**. This is where we call more than one method, in sequence,
    on the same object. This is equivalent to writing multiple lines of code; it is
    just more succinct this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code (which uses chaining) inside the `onCreateDialog` method
    right after the previous code we added. Examine the new code, and we will discuss
    it next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you will need to import the `DialogInterface` class. Use the
    *Alt* | *Enter* technique, or add this line of code among the other `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation for each of the three parts of the code that we just
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first of the three blocks (which uses chaining), we call `builder.setMessage`.
    This sets the main message that the user will see in the dialog box. Additionally,
    note that it is fine to have comments between parts of the chained method calls
    since these are ignored by the compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add a button to our dialog with the `.setPositiveButton` method, and
    the first argument of this method sets the text of the button to `OK`. The second
    argument is an anonymous class, called `DialogInterface.OnClickListener`, which
    handles any clicks on the button. Notice that we are not going to add any code
    to the `onClick` method. Here, we just want to see this simple dialog; we will
    take things a step further in the next project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we call yet another method on the same `builder` object. This time, it's
    the `setNegativeButton` method. Again, the two arguments set `Cancel` as the text
    for the button and an anonymous class to listen for clicks. Again, for the purpose
    of this demonstration, we are not taking any action in the overridden `onClick`
    method. After the call to the `setNegativeButton` method, we finally see a semicolon
    marking the end of the line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will finally code the `return` statement to complete the method and remove
    the error that we have had from the start. Add the `return` statement, as shown
    in the following snippet, to the end (but inside the final curly brace) of the
    `onCreateDialog` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This last line of code has the effect of returning to the `MainActivity` class
    (which calls the `onCreateDialog` method in the first place) our new, fully configured,
    dialog window. We will examine and add this calling code later on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have our `MyDialog` class that extends `FragmentDialog`. All we need
    to do is to declare an instance of `MyDialog`, instantiate it, and call its overridden
    `createDialog` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DialogFragment class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we turn to the code, let''s add a button to our layout. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `activity_main.xml` tab and then switch to the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a `id` attribute is set to `button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `MyDialog` class is the key lesson for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now switch to the `MainActivity.java` tab, and we will handle a click on this
    new button by using an anonymous class just as we did in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228),
    *Anonymous Classes – Bringing Android Widgets to Life*, during the Widget Exploration
    app. We do it this way because we only have one button in the layout, and it seems
    sensible and more compact than implementing the more complicated `OnClickListener`
    interface alternative (as we did for the Java Meet UI demo app in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, in the following code block, that the anonymous class is exactly the
    same type that we previously implemented an interface for. Add this code to the
    `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `import` statements are needed for this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the only thing that happens in the code is that the `onClick` method
    creates a new instance of `MyDialog` and calls its `show` method. This, unsurprisingly,
    will show our dialog window just as we configured it in the `MyDialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show` method needs a reference to `FragmentManager`, which we can get
    with `getSupportFragmentManager`. This is the class that tracks and controls all
    `Fragment` instances for an activity. We also pass in an identifier: `"123"`.'
  prefs: []
  type: TYPE_NORMAL
- en: More details on the `FragmentManager` will be revealed when we look more closely
    at fragments. We will do so in the *Android Fragments* section in [*Chapter 20*](B16773_20_ePub_RK.xhtml#_idTextAnchor345),
    *Drawing Graphics*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason we use the `getSupportFragmentManager` method is that we are supporting
    older devices by extending `AppCompatActivity`. If we simply extended `Activity`,
    then we could use the `getFragmentManager` class. The downside is that the app
    wouldn't run on as many devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the app and admire our new dialog window, which appears when
    we click on the button in the layout. Notice that clicking on either of the buttons
    in the dialog window will close it. This is the default behavior. The following
    screenshot shows our dialog in action on the Pixel C tablet emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.01 – Dialog in action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.01 – Dialog in action
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will make two more classes that implement dialogs, as part of the first
    phase of our multi-chapter Note to Self app. We will learn that a dialog window
    can have almost any layout we choose and that we don't have to rely on simple
    layouts like those that the `Dialog.Builder` class gave us.
  prefs: []
  type: TYPE_NORMAL
- en: The Note to Self app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first of three major apps that we will implement in this book.
    When we carry out these projects, we will execute them more professionally than
    the smaller apps. We will use Android naming conventions, string resources, and
    proper encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, these things can be overkill when you are trying to learn a new Android/Java
    topic. However, they are useful, and it is important to start using them as soon
    as possible in real projects. Eventually, they become second nature, and the quality
    of our apps will benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Using naming conventions and string resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*, we talked about using string resources instead
    of hardcoding text in our layout files. There are a few benefits to doing things
    this way, but it is also relatively long-winded.
  prefs: []
  type: TYPE_NORMAL
- en: As this is our first real-world project, it would be a good time to do things
    the right way so that we can get the experience of doing so. If you want a quick
    refresher on the benefits of string resources, check back to [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure*.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions are the conventions or rules used for naming the variables,
    methods, and classes in our code. Throughout this book, we have loosely applied
    Android's naming conventions. As this is our first real-world app, we will be
    slightly stricter in applying these naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Most notably, when a variable is a member of a class, we will prefix the name
    with a lowercase `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Android's naming conventions and code styles
    at https://source.android.com/source/code-style.html.
  prefs: []
  type: TYPE_NORMAL
- en: How to get the code files for the Note to Self app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fully completed app, including all the code and resources, can be found
    in the [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note to self`
    folder within the download bundle. As we are implementing this app over the next
    five chapters, it will probably be useful to view the part-completed, runnable
    app at the end of every chapter as well. The part-completed runnable apps and
    all their associated code and resources can be found in their respective folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)`/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)`/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B16773_17_ePub_RK.xhtml#_idTextAnchor300)`/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)`/Note to self`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is no Note to Self code in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays Maps, and Random Numbers*. This is because, even though we will learn
    about topics we use in Note to Self, we won't make any changes until [*Chapter
    16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285), *Adapters and Recyclers*.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along and intend to build the Note to Self app from start
    to finish, we will build a project simply called `Note to self`. However, there
    is still nothing stopping you from dipping into the code files of the projects
    from each chapter to do a bit of copying and pasting at any time. Just be aware
    that at various points in the instructions, you will be asked to remove or replace
    the occasional line of code from a previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if you are copying and pasting more than you are typing in code, be
    sure to read the instructions in full, and refer to the code in the book for extra
    comments that might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: In each chapter, the code will be presented as if you have completed the last
    chapter in full, showing code from earlier chapters, where necessary, as useful
    context for our new code.
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter will not be solely devoted to the Note to Self app – we will learn
    about other, usually related, things and build some smaller/simpler apps as well.
    So, when we come to the Note to Self implementation, we will, in theory, be prepared
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: The completed app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following screenshots are from the completed app. It will, of course, look
    slightly different at the various stages of development. Where necessary, we will
    refer to more screenshots either as a reminder or to see the differences throughout
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed app will allow the user to tap on the floating action button
    in the lower-right corner of the app to open a dialog window to add a new note.
    The following screenshot shows this feature highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.02 – Floating action button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.02 – Floating action button
  prefs: []
  type: TYPE_NORMAL
- en: On the left, you can view the button to tap on, and on the right, you can view
    the dialog window where the user can add a new note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, as the user adds more notes, they will have a list of all the notes
    they have added on the main screen of the app, as shown in the following screenshot.
    The user can select whether the note is **Important**, an **Idea**, and/or a **Todo**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.03 – Notes on the main screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.03 – Notes on the main screen
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to scroll down the list and tap on a note to see it shown
    in another dialog window that is dedicated to that note. The following screenshot
    shows a dialog window displaying a note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.04 – Display of the selected note'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.04 – Display of the selected note
  prefs: []
  type: TYPE_NORMAL
- en: 'There will also be a simple (that is, very simple) **Settings** screen, which
    will be accessible from the menu. It will allow the user to configure whether
    the note list is formatted with a dividing line. Here is the **Settings** menu
    option in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.05 –Settings menu option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.05 –Settings menu option
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know exactly what we are going to build, we can go ahead and start
    to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create our new project now. Use the Basic Activity template. As we discussed
    in [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064), *Exploring Android
    Studio and the Project Structure*, this template will generate a simple menu and
    a floating action button, which are both used in this project. Call the project
    `Note to Self`.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the string resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create all the string resources that we will refer to from our
    layout files instead of hardcoding the `text` property of the UI widgets, which
    we have been doing up until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, open the `strings.xml` file from the `res/values` folder in
    the project explorer. You will see the autogenerated resources. Add the following
    highlighted string resources that we will use in our app throughout the rest of
    the project. Add the code before the closing `</resources>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, notice that each string resource has a `name` attribute
    that is unique and distinguishes it from all the others while also providing a
    meaningful and, hopefully, memorable clue as to the actual string value it represents.
    It is these name values that we will use to refer to from within our layout files.
  prefs: []
  type: TYPE_NORMAL
- en: We will not need to revisit this file for the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Note class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the fundamental data structure of the app. It is a class that we will
    write ourselves from scratch and has all the member variables we need to represent
    one of the user's notes. In [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays Maps, and Random Numbers*, we will learn some new Java in order to understand
    how we can let the user have dozens, hundreds, or even thousands of notes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the folder with the same name as your
    package. As expected, it is the one that also contains the `MainActivity.java`
    file. Select `Note`. Press the *Enter* key to create the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the new `Note` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our member variable names are prefixed with `m` as per the Android
    convention. Additionally, we don't want any other class to access these variables
    directly, so they are all declared `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will need a getter and a setter method for each of our members.
    Add the following getter and setter methods to the `Note` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot of code in this preceding list, but there is nothing complicated.
    Each of the methods has `public` access specified, so it can be used by any other
    class that has a reference to an object of the `Note` type. Furthermore, for each
    variable, there is a method with the name of `get...` and a method with the name
    of `set...`. The getters for the Boolean type variables are named `is...`. This
    is a logical name if you think about it because the returned answer will be either
    true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the getters simply returns the value of the related variable. And each
    of the setters sets the value of the related variable to whatever value is passed
    into the method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we should really enhance our setters a little to do a bit of checking
    to make sure that the values passed in are within reasonable limits. For example,
    we might want to check on and enforce a maximum or minimum length for `String
    mTtile` and `String mDescription`. This is left as an exercise for the reader
    to come back to.
  prefs: []
  type: TYPE_NORMAL
- en: Let's design the layout of the two dialog windows.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dialog designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will do something that we have done many times before, but this time,
    for a new reason. As we know, we will have two dialog windows: one for the user
    to enter a new note and one for the user to view a note of their choice.'
  prefs: []
  type: TYPE_NORMAL
- en: We can design the layouts of these two dialog windows in the same way that we
    designed all our previous layouts. When we come to create the Java code for the
    `FragmentDialog` classes, we will then learn how to incorporate these layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a layout for our "new note" dialog. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `dialog_new_note` for the **File name:** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on `ConstraintLayout` type, by default, as its root element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the target design, in the following diagram, as you follow the rest
    of these instructions. I have Photoshopped the finished layout, including the
    constraints that we will soon autogenerate, next to the layout with the constraints
    hidden for extra clarity:![Figure 14.06 – Finished layout for new note
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.06 – Finished layout for new note
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop a **Plain Text** widget (from the **Text** category) to the upper-left
    corner of the layout. Then, add another **Plain Text** widget below it. Don't
    worry about any of the attributes for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop three **CheckBox** widgets from the **Button** category, one below
    the other. Look at the earlier reference diagram for guidance. Again, don't worry
    about any attributes for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop two **Buttons** onto the layout. The first will go directly below
    the last **CheckBox** widget from the previous step; the second will fall horizontally,
    in line with the first **Button**, but to the right of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tidy up the layout so that it looks as close to the reference diagram as possible.
    Then, click on the **Infer Constraints** button to fix the positions you have
    chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can set up all of our `text`, `id`, and `hint` properties. You can
    do this by using the values from the following table. Remember that we are using
    our string resources for the `text` and `hint` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When you edit the first `id` property (which we will do next), you might be
    shown a pop-up window asking for a confirmation of your changes. Check the **Don''t
    ask again during this session** box and click on **Yes** to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.07 – Confirmation of changes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.07 – Confirmation of changes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16773_14_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have an organized layout that is ready for our Java code to display.
    Make sure that you keep the `id` property values of the different widgets in mind.
    We will see them in action when we write our Java code. The important thing is
    that our layout looks nice and has an `id` property value for every relevant item,
    so we can get a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the layout for the "show note" dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `dialog_show_note` for the **File name:** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on `ConstraintLayout` type as its root element by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the target design, in the following diagram, as you follow the rest
    of these instructions. I have Photoshopped the finished layout, including the
    constraints we will soon autogenerate, next to the layout with the constraints
    hidden for extra clarity:![Figure 14.08 – Finished layout for the show note dialog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_14.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.08 – Finished layout for the show note dialog
  prefs: []
  type: TYPE_NORMAL
- en: First of all, drag and drop three **TextView** widgets so that they are vertically
    aligned across the top of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag and drop another `TextView` widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another **TextView** widget just below the previous widget but over to the
    left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a **Button** horizontally in the center, but near the bottom of the
    layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tidy up the layout so that it looks as close to the reference diagram as possible,
    Then, click on the **Infer Constraints** button to fix the positions you have
    chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the attributes from the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B16773_14_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might want to tweak the final positions of some of the UI elements by dragging
    them about slightly since we adjusted their size and contents. First, click on
    `btnOK` to the button ID there might be a dialog box saying this ID already exist,
    click on **Continue** to ignore the pop up.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a layout that we can use to show a note to the user. Notice that
    we get to reuse some string resources. The bigger our apps get, the more beneficial
    it is to do things in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the dialog boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have a design for both of our dialog windows ("show note" and "new note"),
    we can use what we know about the `FragmentDialog` class to implement a class
    to represent each of the dialog windows that the user can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the "new note" screen.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the DialogNewNote class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the project folder that has all the
    `.java` files and choose `DialogNewNote`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change the class declaration and extend `DialogFragment`. Then, override
    the `onCreateDialog` method, which is where all the rest of the code in this class
    will go. To achieve this, make your code is the same as the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to add these new imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.fragment.app.DialogFragment;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.app.Dialog;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.os.Bundle;`'
  prefs: []
  type: TYPE_NORMAL
- en: We temporarily have an error in the new class because we need a `return` statement;
    however, we will get to that in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, first, we declare and initialize an `AlertDialog.Builder`
    object, in the same way we did earlier when creating dialog windows. However,
    this time, we will rely on this object far less than we previously did.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize a `LayoutInflater` object, which we will use to inflate
    our XML layout. By "inflate," we are simply referring to how we turn our XML layout
    into a Java object. Once this has been done, we can then access all our widgets
    in the usual way. We can think of the `inflater.inflate` method as replacing the
    `setContentView` method for our dialog. Then, in the second line, we do just that
    using the `inflate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the three lines of code that we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the new classes in the preceding three lines of code, you will need
    to add the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.appcompat.app.AlertDialog;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.LayoutInflater;`'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `View` object, called `dialogView`, that has all of the UI elements
    from our `dialog_new_note.xml` layout file.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately after the previous block of code, we will add the following block
    of code, which we explain next.
  prefs: []
  type: TYPE_NORMAL
- en: This code will get a reference to each of the UI widgets in the usual way. Many
    of the objects in the following code are declared as `final` because they will
    be used in an anonymous class, and as we learned previously, this is necessary.
    Remember that it is the reference that is `final` (that is, it cannot change);
    we can still change the objects on the heap to which they are a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code just after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` code statements to make the code that you just added
    error-free:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.CheckBox;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.EditText;`'
  prefs: []
  type: TYPE_NORMAL
- en: In the next code block, we will set the message of the dialog using `builder`,
    which is our builder instance. Then, we will write an anonymous class to handle
    clicks on the `btnCancel` button. In the overridden `onClick` method, we will
    simply call `dismiss()`, which is a public method of `DialogFragment`, to close
    the dialog window. This is just what we need if the user clicks on **Cancel**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will add an anonymous class to handle what happens when the user clicks
    on the `btnOK`).
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new `Note` instance, called `newNote`. Then, we set each
    of the member variables from `newNote` to the appropriate contents of the form.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we do something new. We create a reference to the `MainActivity`
    class using the `getActivity` method. Then, we use that reference to call the
    `createNewNote` method in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have not written this `createNewNote` method yet, and it will show
    up as an error until we do so later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The argument sent in this method is our newly initialized `newNote` object.
    This has the effect of sending the user's new note back to `MainActivity`. We
    will learn what to do with this later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `dismiss` to close the dialog window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code that we have been discussing after the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's our first dialog done. We haven't wired it up to appear in `MainActivity`
    yet, and we still need to implement the `createNewNote` method too. We will do
    this straight after we create the next dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the DialogShowNote class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on the project folder that contains all
    of the `.java` files and choose `DialogShowNote`.
  prefs: []
  type: TYPE_NORMAL
- en: First, change the class declaration and extend `DialogFragment`. Then, override
    the `onCreateDialog` method. As most of the code for this class goes in the `onCreateDialog`
    method, implement the signature and empty body, as shown in the following code
    snippet, and we will revisit it later.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we declare a member variable, `mNote`, of the `Note` type. Add the
    `sendNoteSelected` method and the one line of code that initializes `mNote`. This
    method will be called by `MainActivity`, and it will pass to the `Note` object
    the user has clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code we just discussed. Then, we can view and code the details of `onCreateDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will need to import the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.app.Dialog;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.os.Bundle;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.fragment.app.DialogFragment;`'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare and initialize an instance of `AlertDialog.Builder`. Additionally,
    as we did for the `DialogNewNote` class, we declare and initialize a `LayoutInflater`
    instance and then use it to create a `View` object that has the layout for the
    dialog. In this case, it is the layout from `dialog_show_note.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the following code, we get a reference to each of the UI widgets
    and set the `text` attributes to `txtTitle` and `textDescription` from the appropriate
    member variables of `mNote`, which was initialized in the `sendNoteSelected` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code that we just discussed to the `onCreateDialog` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` statements so that all of the classes in the preceding
    code are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.LayoutInflater;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.view.View;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.TextView;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import androidx.appcompat.app.AlertDialog;`'
  prefs: []
  type: TYPE_NORMAL
- en: The following code that we will add is also in the `onCreateDialog` method.
    It checks whether the note being shown is "important" and then shows or hides
    the `txtImportant TextView` accordingly. We then do the same for `txtTodo` and
    `txtIdea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous block of code while you are still in the `onCreateDialog`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do now is `dismiss` (close) the dialog window when the user clicks
    on the `onClick` method simply calls the `dismiss` method, which closes the dialog
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the `onCreateDialog` method after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Button` class using this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: We now have two dialog windows ready to roll. We just need to add some code
    to the `MainActivity` class to finish the job. First, let's do a bit of project
    housekeeping.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the unwanted autogenerated fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now tidy up the files and structure of our project. Remember that the
    Basic Activity template we used to generate this project has quite a few features.
    Some of these we need, while some we don't. We want the floating action button
    to be in the lower-right corner of the layout, and we want the main menu with
    the `content_main.xml` file, we will delete the reference to the fragment along
    with all of its navigation options.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `content_main.xml` layout file. In the `content_main.xml` file, find
    the **nav_host_fragment** element. Select it and then press the *Delete* key on
    the keyboard. Now, we have a cleaner UI that is ready for future development.
  prefs: []
  type: TYPE_NORMAL
- en: Showing our new dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.java` file. Add a new temporary member variable just
    after the `MainActivity` class declaration. This won''t be in the final app; it
    is so we can test our dialog windows as soon as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add this method to the `MainActivity` class so that we can receive a new
    note from the `DialogNewNote` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To send a note to the `DialogShowNote` method, we need to add a button with
    an ID of `button` to the `content_main.xml` layout file. Open the `content_main.xml`
    layout file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just so that it is clear what this button is for, we will change its `text`
    attribute to `Show Note`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a button onto the `content_main.xml` layout and configure the `id` property
    as `button` and the `text` property as `Show Note`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Infer Constraints** button so that the button stays where you
    put it. The exact position of this button is not important at this stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Just to clarify, this is a temporary button for testing purposes and will not
    be in the final app. At the end of development, we will be able to click on a
    note's title from a scrolling list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreate` method, we will set up an anonymous class to handle clicks
    on our temporary button. The code in the `onClick` method will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `DialogShowNote` instance that is simply called `dialog`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `sendNoteSelected` method on `dialog` to pass in `mTempNote` as a parameter,
    which is our `Note` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it will call `show`, which breathes life into our new dialog and reveals
    it to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the code that we just described to `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Button` class using this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now summon our `DialogShowNote` dialog window at the click of a button.
    Run the app and click on the `DialogShowNote` dialog with the `dialog_show_note.xml`
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.09 – DialogShowNote dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.09 – DialogShowNote dialog
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, this is not much to look at considering how much coding we have
    done in this chapter. However, when we get the `DialogNewNote` class working,
    we will be able to see how the `MainActivity` class interacts and shares data
    between the two dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make the `DialogNewNote` dialog useable.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the floating action button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is going to be easy. The floating action button is provided for us in the
    layout. As a reminder, the floating action button is the round icon with an envelope
    image on it, as pictured in the lower-right corner of the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is in the `activity_main.xml` file. This is the XML code that positions
    and defines its appearance. Notice that just before the code for the floating
    action button, there is a line of code (highlighted) that includes the `content_main.xml`
    file. This currently contains our **Show Note** button and will eventually contain
    our sophisticated scrolling list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Android Studio has even provided an anonymous class to handle any clicks on
    the floating action button. All we need to do is add some code to the `onClick`
    method of this already provided class, and we can use the `DialogNewNote` class.
  prefs: []
  type: TYPE_NORMAL
- en: The floating action button is usually used for a core action within an app.
    For example, in an email app, it would probably be used to start a new email.
    Alternatively, in a note-keeping app, it would probably be used to add a new note.
    So, let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainActivity.java` file, find the autogenerated code provided by Android
    Studio in the `MainActivity` class of the `onCreate` method. Here it is in its
    entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, note the highlighted line and delete it. Now,
    add the following code in place of the deleted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The new code creates a new dialog window of the `DialogNewNote` variety and
    then shows it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the app. Tap on the floating action button, and add a note that
    is similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Add new note'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.10 – Add new note
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can tap on the **Show Note** button in order to view it in a dialog
    window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Show note dialog window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.11 – Show note dialog window
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you add a second note, it will overwrite the first because we only
    have one `Note` object. We will need to learn some more Java in order to solve
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed and implemented a common UI design with dialog
    windows using the `DialogFragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went a step further and started the Note to Self app by implementing
    more complicated dialogs that can capture information from the user. We saw that
    the `DialogFragment` class enables us to have any UI we design inside a dialog
    box.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deal with the obvious problem that the user can
    only have one note. We will solve this problem by exploring Java arrays and their
    close cousin, `ArrayList`, along with another data-related Java class, `Map`.
  prefs: []
  type: TYPE_NORMAL
