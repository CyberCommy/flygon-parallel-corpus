- en: Chapter 1. Saying Hello!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 说你好！
- en: 'Let''s follow several steps to establish a development environment for the
    simplest application possible, to show you how easy it is to get a web application
    up and running with Angular 2 and Bootstrap 4\. At the end of the chapter, you
    will have a solid understanding of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照几个步骤来建立一个尽可能简单的应用程序的开发环境，向你展示使用Angular 2和Bootstrap 4轻松地启动和运行Web应用程序有多容易。在本章结束时，你将对以下内容有扎实的理解：
- en: How to set up your development environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置你的开发环境
- en: How TypeScript can change your development life
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript如何改变你的开发生活
- en: Core concepts of Angular and Bootstrap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular和Bootstrap的核心概念
- en: How to create a simple Angular component with Bootstrap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Bootstrap创建一个简单的Angular组件
- en: How to display some data through it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过它显示一些数据
- en: Setting up a development environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Let's set up your development environment. This process is one of the most overlooked
    and often frustrating parts of learning to program because developers don't want
    to think about it. Developers must know the nuances of how to install and configure
    many different programs before they start real development. Everyone's computers
    are different; as a result, the same setup may not work on your computer. We will
    expose and eliminate all of these problems by defining the various pieces of environment
    you need to set up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来设置你的开发环境。这个过程是学习编程中最容易被忽视和经常令人沮丧的部分之一，因为开发人员不想考虑它。开发人员必须了解如何安装和配置许多不同的程序，然后才能开始真正的开发。每个人的电脑都不一样；因此，相同的设置可能在你的电脑上无法工作。我们将通过定义你需要设置的各种环境的各个部分来暴露和消除所有这些问题。
- en: Defining a shell
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个shell
- en: The **shell** is a required part of your software development environment. We
    will use the shell to install software and run commands to build and start the
    web server to bring life to your web project. If your computer has the Linux operating
    system installed then you will use a shell called **Terminal** . There are many
    Linux-based distributions out there that use diverse desktop environments, but
    most of them use the equivalent keyboard shortcut to open Terminal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell** 是你的软件开发环境的必需部分。我们将使用Shell来安装软件并运行命令来构建和启动Web服务器，为你的Web项目注入生命。如果你的电脑安装了Linux操作系统，那么你将使用一个叫做**Terminal**的Shell。有许多基于Linux的发行版，它们使用不同的桌面环境，但大多数都使用相同的键盘快捷键来打开Terminal。'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use keyboard shortcut *Ctrl* + *Alt* + *T* to open Terminal in Ubuntu, Kali,
    and Linux Mint. If it doesn't work for you, please check the documentation for
    your version of Linux.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu、Kali和Linux Mint中使用键盘快捷键*Ctrl* + *Alt* + *T*来打开Terminal。如果对你不起作用，请查看你的Linux版本的文档。
- en: If you have a Mac computer with OS X installed, then you will use the Terminal
    shell as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Mac电脑安装了OS X，那么你也将使用Terminal shell。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use keyboard shortcut *command* + *space* to open the **Spotlight** , type Terminal
    to search and run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘快捷键*command* + *space*来打开**Spotlight**，输入Terminal进行搜索和运行。
- en: If you have a computer with a Windows operating system installed, you can use
    the standard **Command Prompt** , but we can do better. In a minute I will show
    you how can you install Git on your computer, and you will have Git Bash free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑安装了Windows操作系统，你可以使用标准的**命令提示符**，但我们可以做得更好。一会儿我会告诉你如何在你的电脑上安装Git，并且你将免费获得Git
    Bash。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can open a Terminal with the `Git Bash` shell program on Windows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Windows上使用`Git Bash` shell程序打开一个Terminal。
- en: I will use the Bash shell for all exercises in this book whenever I need to
    work in Terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我需要在Terminal中工作时，我会在本书的所有练习中使用Bash shell。
- en: Installing Node.js
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: '**Node.js** is technology we will use as a cross-platform runtime environment
    to run server-side web applications. It is a combination of a native, platform-independent
    runtime based on Google''s V8 JavaScript engine and a huge number of modules written
    in JavaScript. Node.js ships with different connectors and libraries help you
    use HTTP, TLS, compression, file system access, raw TCP and UDP, and more. You
    as a developer can write your own modules on JavaScript and run them inside the
    Node.js engine. The Node.js runtime makes it easy to build a network event-driven
    application servers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js**是我们将用作跨平台运行时环境来运行服务器端Web应用程序的技术。它是基于Google的V8 JavaScript引擎的本地、平台无关的运行时和大量用JavaScript编写的模块的组合。Node.js附带了不同的连接器和库，帮助您使用HTTP、TLS、压缩、文件系统访问、原始TCP和UDP等。作为开发人员，您可以在JavaScript中编写自己的模块，并在Node.js引擎内运行它们。Node.js运行时使构建网络事件驱动的应用服务器变得容易。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terms *package* and *library* are synonymous in JavaScript so we will use
    them interchangeably.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*package*和*library*在JavaScript中是同义的，因此我们将它们互换使用。
- en: Node.js is utilizing the **JavaScript Object Notation** ( **JSON** ) format
    widely in data exchanges between the server and client sides because it is readily
    expressed in several parse diagrams, notably without the complexities of XML,
    SOAP, and other data exchange formats.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js广泛利用**JavaScript对象表示法**（**JSON**）格式在服务器和客户端之间进行数据交换，因为它可以在几个解析图中轻松表达，特别是没有XML、SOAP和其他数据交换格式的复杂性。
- en: You can use Node.js for the development of service-oriented applications, doing
    something different than web servers. One of the most popular service-oriented
    applications is **node package manager** ( **npm** ), which we will use to manage
    library dependencies, deployment systems, and which underlies the many **platform-as-a-service**
    ( **PaaS** ) providers for Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Node.js开发面向服务的应用程序，做一些与Web服务器不同的事情。最受欢迎的面向服务的应用程序之一是**node package manager**（**npm**），我们将使用它来管理库依赖关系、部署系统，并为Node.js的许多**平台即服务**（**PaaS**）提供商提供基础。
- en: 'If you do not have Node.js installed on your computer, you should download
    the pre-build installer from [https://nodejs.org/en/download](https://nodejs.org/en/download)
    , or you can use the unofficial package managers from [https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager)
    . You can start to use Node.js immediately after installation. Open Terminal and
    type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上没有安装Node.js，您应该从[https://nodejs.org/en/download](https://nodejs.org/en/download)下载预构建的安装程序，或者您可以使用来自[https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager)的非官方包管理器。安装后，您可以立即开始使用Node.js。打开终端并键入：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Node.js will respond with the version number of the installed runtime:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js将以安装的运行时的版本号作出响应：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Bear in mind that the version of Node.js installed on my computer could be different
    from yours. If these commands give you a version number, you are ready to go with
    Node.js development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我计算机上安装的Node.js版本可能与您的不同。如果这些命令给您一个版本号，那么您已经准备好开始Node.js开发了。
- en: Setting up npm
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置npm
- en: 'The npm is a package manager for JavaScript. You can use it to find, share,
    and reuse packages of code from many developers across the world. The number of
    packages dramatically grows every day and now is more than 250K. The npm is a
    Node.js package manager and utilizes it to run itself. The npm is included in
    the setup bundle of Node.js and available just after installation. Open Terminal
    and type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: npm是JavaScript的包管理器。您可以使用它来查找、共享和重用来自世界各地许多开发人员的代码包。包的数量每天都在急剧增长，现在已经超过250K。npm是Node.js的包管理器，并利用它来运行自身。npm包含在Node.js的安装包中，并在安装后立即可用。打开终端并键入：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The npm must respond on your command with a version number:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: npm必须以版本号的形式响应您的命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'My Node.js comes with that particular version of npm. The npm gets updated
    quite frequently, so you''ll want to move to the latest version with the following
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的Node.js带有特定版本的npm。npm经常更新，所以您需要使用以下命令切换到最新版本：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may experience permission problems to search or install packages with npm.
    If that is the case, I recommend following the instructions from [https://docs.npmjs.com/getting-started/fixing-npm-permissions](https://docs.npmjs.com/getting-started/fixing-npm-permissions)
    and don't use superuser privileges to fix them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到使用npm搜索或安装软件包时的权限问题。如果是这种情况，我建议按照[https://docs.npmjs.com/getting-started/fixing-npm-permissions](https://docs.npmjs.com/getting-started/fixing-npm-permissions)上的说明操作，不要使用超级用户权限来修复它们。
- en: 'The following command gives us information about Node.js and the npm install:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为我们提供了有关Node.js和npm安装的信息：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are two ways to install npm packages: locally or globally. In cases when
    you would like to use the package as a tool, it''s better install it globally:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以安装npm软件包：本地安装或全局安装。在您希望将软件包用作工具时，最好进行全局安装：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you need to find the folder with globally installed packages you can use
    the next command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要找到全局安装软件包的文件夹，可以使用以下命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installation global packages are important, but best to avoid if not needed.
    Mostly you will install packages locally.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装软件包很重要，但最好在不需要时避免。大多数情况下，您会进行本地安装。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You may find locally installed packages in the `node_modules` folder of your
    project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的`node_modules`文件夹中找到本地安装的软件包。
- en: Installing Git
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Git
- en: If you're not familiar with Git then you're really missing out! Git is a distributed
    version control system and each Git working directory is a full-fledged repository.
    It keeps a complete history of changes and has full version tracking capabilities.
    Each repository is entirely independent of network access or a central server.
    You can keep Git repositories on your computer and share it with your mates, or
    you can take advantage of the many online VCS providers. The big guys you should
    look at closely are GitHub, Bitbucket, and Gitlab.com. Each has its own benefits,
    depending on your needs and project type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉Git，那您真的错过了很多！Git是一个分布式版本控制系统，每个Git工作目录都是一个完整的仓库。它保留了完整的更改历史，并具有完整的版本跟踪功能。每个仓库都完全独立于网络访问或中央服务器。您可以在计算机上保存Git仓库并与同事共享，或者利用许多在线VCS提供者。您应该仔细查看的大公司是GitHub、Bitbucket和Gitlab.com。每个都有自己的好处，取决于您的需求和项目类型。
- en: 'Mac computers comes with Git already installed into the operating system but
    usually the version of Git is not the same as the latest one. You can update or
    install Git on your computer via a set of pre-build installers available on the
    official website [https://git-scm.com/downloads](https://git-scm.com/downloads)
    . After installation, you can open Terminal and type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mac计算机已经安装了Git到操作系统中，但通常Git的版本与最新版本不同。您可以通过官方网站[https://git-scm.com/downloads](https://git-scm.com/downloads)上提供的一组预构建安装程序来更新或安装Git到您的计算机上。安装完成后，您可以打开终端并输入：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Git must respond with a version number:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git必须以版本号做出响应：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As I said, for developers who use computers with an installed Windows operation
    system, you now have Git Bash free on your system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，对于使用安装了Windows操作系统的计算机的开发人员，您现在可以在系统上免费使用Git Bash。
- en: Code editor
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器
- en: You can imagine how many programs for code editing exist, but we will talk today
    only about the free, open source, runs everywhere Visual Studio Code from Microsoft.
    You can use any program you prefer for development, but I will be using only Visual
    Studio code in our future exercises, so please install it from [http://code.visualstudio.com/Download](http://code.visualstudio.com/Download)
    .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: A TypeScript crash course
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is an open source programming language developed and maintained by
    Microsoft. Its initial public release was in October 2012 and was presented by
    Anders Hejlsberg, the lead architect of C# and creator of Delphi and Turbo Pascal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
    Any existing JavaScript is also valid TypeScript. It gives you type checking,
    explicit interfaces, and easier module exports. For now, it includes **ES5** ,
    **ES2015** , **ES2016** , and, in fact, it's a little like getting some of tomorrow's
    ECMAScripts early so that we can play with some of those features today.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relationship between ECMAScripts and TypeScript:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![A TypeScript crash course](Image00001.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Writing code using TypeScript is relatively straightforward if you already have
    a background in the JavaScript language. Try the TypeScript playground [http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)
    to play with IntelliSense, find references, and so on, directly from your browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript provides a static type checking operation that allows many bugs
    in the development cycle to be caught early. TypeScript enables type checking
    at compile time via type annotations. Types in TypeScript are always optional,
    so you can ignore them if you prefer the regular dynamic typing of JavaScript.
    It supports `number` , `boolean` , and `string` type annotations for primitive
    types and `any` for dynamically-typed structures. In the following example, I
    added type annotations to `return` and parameters for `function` :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In one moment of compilation, a TypeScript compiler can generate a declaration
    file which contains only signatures of the exported types. The resulting declaration
    file with the extension `.d.ts` along with a JavaScript library or module can
    be consumed later by a third-party developer. You can find a vast collection of
    declaration files for many popular JavaScript libraries at:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The **DefinitelyTyped** ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    )
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DefinitelyTyped** ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    )'
- en: The **Typings** registry ([https://github.com/typings/registry](https://github.com/typings/registry)
    )
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Typings** 注册表 ([https://github.com/typings/registry](https://github.com/typings/registry)
    )'
- en: Arrow function
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Functions in JavaScript are first class citizens, which means they can be passed
    around like any other values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的函数是头等公民，这意味着它们可以像其他任何值一样传递：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first parameter in `reduce` is an anonymous function. Anonymous functions
    are very useful in many scenarios but too verbose. TypeScript introduced new,
    less verbose syntax to define anonymous functions called **arrow function** syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 中的第一个参数是匿名函数。匿名函数在许多场景中非常有用，但太啰嗦了。TypeScript 引入了一种新的、不那么啰嗦的语法来定义匿名函数，称为
    **箭头函数** 语法：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or event less:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至更简洁：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When defining parameters, you can even omit parentheses if the parameters are
    just a single identifier. So the regular `map` method of array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义参数时，如果参数只是一个标识符，甚至可以省略括号。所以数组的常规 `map` 方法：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Could be much more concise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更加简洁：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both syntaxes `(x) => x * x` and `x => x * x` are allowed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法 `(x) => x * x` 和 `x => x * x` 都是允许的。
- en: 'Another important feature of arrow function is that it doesn''t shadow `this`
    and pick it up from the lexical scope. Let''s assume we have a constructor function
    `Counter` which increments the value of an internal variable `age` in timeout
    and prints it out:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的另一个重要特性是它不会遮蔽 `this`，而是从词法作用域中获取它。假设我们有一个构造函数 `Counter`，它在超时中增加内部变量 `age`
    的值并将其打印出来：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As result of using the arrow function, the `age` from the scope of `Counter`
    is available inside the callback function of `setTimeout` . Here is the converted
    to JavaScript ECMAScript 5 code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数的结果是，`Counter` 作用域中的 `age` 在 `setTimeout` 的回调函数中是可用的。以下是转换为 JavaScript
    ECMAScript 5 代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following variables are all lexical inside arrow functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量在箭头函数内部都是词法作用域的：
- en: '`arguments`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`'
- en: '`super`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super`'
- en: '`this`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`'
- en: '`new.target`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new.target`'
- en: Block scope variables
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块作用域变量
- en: 'All variables in ES5 declared with a `var` statement are function-scoped, and
    their scope belongs to enclosing functions. The result of the following code can
    be confusing because it returns `undefined` :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，使用 `var` 声明的所有变量都是函数作用域的，它们的作用域属于封闭函数。以下代码的结果可能令人困惑，因为它返回 `undefined`：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `x` is an inner variable of the `random` function and does not have any
    relation to the variable defined on the first line. The result of calling the
    `random` function at the last line returned `undefined` , because the JavaScript
    interprets the code in `random` function like that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 是 `random` 函数的内部变量，与第一行定义的变量没有任何关系。在最后一行调用 `random` 函数的结果返回 `undefined`，因为
    JavaScript 解释 `random` 函数中的代码如下：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This confusing code can be fixed in TypeScript with new block-scope variable
    declarations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，这段令人困惑的代码可以通过新的块作用域变量声明来修复：
- en: The `let` is a block-scope version of `var`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 是 `var` 的块作用域版本'
- en: The `const` is similar `let` but allows initialize variable only once
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` 类似于 `let`，但只允许初始化变量一次'
- en: 'The TypeScript compiler throws more errors with new block-scope variable declarations
    and prevents writing complicated and damaged code. Let''s change `var` to `let`
    in the previous example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器使用新的块作用域变量声明会抛出更多错误，并防止编写复杂和损坏的代码。让我们在前面的例子中将 `var` 改为 `let`：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And now our code works as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码按预期工作了。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using `const` and `let` to make the code cleaner and safer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 `const` 和 `let` 来使代码更清晰、更安全。
- en: Template literals
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文字
- en: 'If we need string interpolation, we usually combine the values of variables
    and string fragments such as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The TypeScript supports template literals--string literals allowing embedded
    expressions. You can use the string interpolation features of the template literals
    out of the box:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you need multiline string, the template literals can help again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last line prints results as follow:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend using template literals as a safer way of string interpolation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The for-of loop
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We usually use `for` statement or `forEach` method of `Array` to iterate over
    elements in JavaScript ES5:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each of these methods has its benefit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We can interrupt the `for` statement via `break` or`continue`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forEach` method is less verbose
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The TypeScript has `for-of` loop as a combination of both of them:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `for-of` loop supports `break` and `continue` and can use the `index` and
    `value` of each array via new `Array` method `entries` :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Default value, optional and rest parameters
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We quite often need to check the input parameters of functions and assign default
    values to them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The TypeScript has syntax to handle default values of parameters to make previous
    functions shorter and safer:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A default value of a parameter is assigned only by its `undefined` value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Each parameter of a function in JavaScript ES5 is optional, so an omitted one
    equals `undefined` . To make it strict, TypeScript expects a question mark at
    the end of parameters we want to be optional. We can mark the last parameter of
    the `square` function as optional and call the function with one or two parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any optional parameters must follow the required parameters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'In some scenarios, we need to work with multiple parameters as a group, or
    we may not know how many parameters a function takes. The JavaScript ES5 provides
    the `arguments` variable in the scope of functions to work with them. In TypeScript,
    we can use a formal variable to keep the rest of the parameters. The compiler
    builds an array of the arguments passed in with the name given after the ellipses
    so that we can use it in our function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Interfaces
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface is the way of defining contracts inside and outside the code
    of your project. We use the interface in TypeScript only to describe a type and
    the shape of data to help us keep our code error-free. In comparison with many
    other languages, the TypeScript compiler doesn''t generate any code for the interface
    so that it has not runtime cost. The TypeScript defines interfaces via the interface
    keyword. Let''s define a type `Greetable` :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是定义项目内外合同的方式。我们在TypeScript中使用接口只是为了描述类型和数据的形状，以帮助我们保持代码无误。与许多其他语言相比，TypeScript编译器不会为接口生成任何代码，因此它没有运行时成本。TypeScript通过interface关键字定义接口。让我们定义一个类型`Greetable`：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It has a member function called `greetings` that takes a string argument. Here
    is how we can use it as a type of parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`greetings`的成员函数，接受一个字符串参数。以下是我们如何将其用作参数类型：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Classes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'JavaScript has a prototype-based, object-oriented programming model. We can
    instantiate objects using the object literal syntax or constructor function. Its
    prototype-based inheritance is implemented on prototype chains. If you come from
    an object-oriented approach, you may feel uncomfortable when you try to create
    classes and inheritance based on prototypes. TypeScript allows for writing code
    based on an object-oriented class-based approach. The compiler translates the
    class down to JavaScript and works across all major web browsers and platforms.
    Here is the class `Greeter` . It has a property called `greeting` , a `constructor`
    , and a method `greet` :'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有基于原型的面向对象编程模型。我们可以使用对象文字语法或构造函数来实例化对象。它的基于原型的继承是在原型链上实现的。如果您来自面向对象的方法，当您尝试基于原型创建类和继承时，可能会感到不舒服。TypeScript允许基于面向对象的类的方法编写代码。编译器将类转换为JavaScript，并在所有主要的Web浏览器和平台上运行。这是类`Greeter`。它有一个名为`greeting`的属性，一个`constructor`和一个`greet`方法：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To refer to any member of the class we prepend `this` . To create an instance
    of the class we use the `new` keyword:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用类的任何成员，我们需要在前面加上`this`。要创建类的实例，我们使用`new`关键字：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can extend an existing class to create new ones via inheritance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过继承来扩展现有的类以创建新的类：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the class `EmailGreeter` , we demonstrate several features of inheritance
    in TypeScript:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在类`EmailGreeter`中，我们展示了TypeScript中继承的几个特性：
- en: We use `extends` to create a subclass
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`extends`来创建一个子类
- en: We must call `super` in the first line of the constructor to pass values into
    base class
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在构造函数的第一行调用`super`以将值传递给基类
- en: We call the `greet` method of the base class to create a subject for `mailto`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用基类的`greet`方法来创建一个`mailto`的主题
- en: The TypeScript classes support `public` , `protected` , and `private` modifiers
    to access the members that we declared throughout our programs. Each member of
    the class is public by default. There are not a requirement to labeled all `public`
    members with that keyword but you may mark them explicitly. Use protected modifier
    if you need to restrict access to members of the class from outside, but bear
    in mind that they are still available from deriving classes. You can mark the
    constructor as protected so that we cannot instantiate the class but we can extend
    it. The `private` modifier restricts access to member only on the class level.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类支持`public`、`protected`和`private`修饰符，以访问我们在整个程序中声明的成员。类的每个成员默认为public。不需要使用关键字标记所有`public`成员，但您可以显式标记它们。如果需要限制从外部访问类的成员，则使用protected修饰符，但请记住它们仍然可以从派生类中访问。您可以将构造函数标记为protected，以便我们无法实例化该类，但可以扩展它。`private`修饰符限制了仅在类级别上访问成员。
- en: 'If you look at constructors of `EmailGreeter` , we had to declare a private
    member `email` and a constructor parameter `emailAddr` . Instead, we can use parameter
    properties to let us create and initialize a member in one place:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看“EmailGreeter”的构造函数，我们必须声明一个私有成员“email”和一个构造函数参数“emailAddr”。相反，我们可以使用参数属性来让我们在一个地方创建和初始化成员：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can use any modifier in parameter properties.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在参数属性中使用任何修饰符。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use parameter properties to consolidate the declaration and assignment in one
    place.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数属性将声明和赋值 consoli在一个地方。
- en: 'TypeScript supports getters and setters to organize intercepting access to
    members of an object. We can change the original `Greeter` class with the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持使用getter和setter来组织拦截对象成员的访问。我们可以使用以下代码更改原始的“Greeter”类：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We check the `value` parameter inside the setter of `greeting` and modify it
    if necessary to empty string before assigning it to the private member.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“问候语”的setter中检查“value”参数，并在将其分配给私有成员之前，根据需要将其修改为空字符串。
- en: 'TypeScript supports class members via the static modifier as well. Here the
    class `Types` contains only static members:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还通过静态修饰符支持类成员。这里的“Types”类仅包含静态成员：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can access those values through prepending the name of the class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在类名前加上访问这些值：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'TypeScript gives us supreme flexibility via abstract classes. We cannot create
    instances of them, but we can use them to organize base classes from which each
    distinct class may be derived. We can convert the `greeting` class into abstract
    with just one keyword:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过抽象类为我们提供了极大的灵活性。我们无法创建它们的实例，但我们可以使用它们来组织基类，从而可以派生出每个不同的类。我们可以使用一个关键字将“greeting”类转换为抽象类：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method `greet` is marked as `abstract` . It doesn't contain an implementation
    and must be implemented in derived classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 方法“greet”被标记为“abstract”。它不包含实现，必须在派生类中实现。
- en: Modules
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: When we are writing the code, we usually divide it into functions and the blocks
    inside those functions. The size of a program can increase very quickly, and individual
    functions start to blend into the background. We can make such a program more
    readable if we split them into large units of an organization like modules. At
    the beginning of writing a program, you may not know how to structure it, and
    you can use structureless principles. When your code becomes stable you can put
    pieces of functionality into separate modules to make them easy to track, update,
    and share. We store modules of TypeScript in files, exactly one module per file
    and one file per module.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，通常将其分成函数和这些函数内部的块。程序的大小可能会迅速增加，个别函数开始混为一体。如果我们将它们分成像模块这样的大型组织单位，可以使这样的程序更易读。在编写程序的开始阶段，您可能不知道如何构造它，可以使用无结构的原则。当您的代码变得稳定时，可以将功能片段放入单独的模块中，以便跟踪、更新和共享。我们将TypeScript的模块存储在文件中，每个文件恰好一个模块，每个模块一个文件。
- en: The JavaScript ES5 doesn't have built-in support for modules and we used AMD
    or CommonJS syntax to work with them. TypeScript supports the concept of modules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript ES5没有内置对模块的支持，我们使用AMD或CommonJS语法来处理它们。TypeScript支持模块的概念。
- en: 'How do the scope and module depend on each other? The global scope of JavaScript
    doesn''t have access to the scope of executing modules. It creates its own scope
    for each individual execution module, so everything declared inside the module
    is not visible from outside. We need to explicitly export them to make them visible
    and import them to consume them. The relationship between modules is defined at
    the file level regarding exports and imports. Any file defines a top-level `export`
    or `import` and is considered a module. Here is a `string-validator.ts` file which
    contains the exported declaration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I have created another file `zip-validator.ts` with several members, but exported
    only one of them to hide another one from outside:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can re-export declarations if your module extends other modules. Here `validators.ts`
    contains a module, wraps other validator modules, and combines all their exports
    in one place:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can import validator modules using one of the import forms. Here is
    a single export from a module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To prevent a naming conflict we can rename an imported declaration:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can import an entire module into a single variable, and use it
    to access module exports:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Generics
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The authors of TypeScript put maximal effort into helping us to write reusable
    code. One of the tools that helps us to create code that can work with a variety
    of types rather than a single one is **generics** . The benefits of generics include:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to write code/use methods which are type-safe. An `Array<string>`
    is guaranteed to be an array of strings.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler can perform a compile-time check on code for type safety. Any attempt
    to assign the `number` into an array of strings causes an error.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster than using `any` type to avoid casting into a required reference type.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to write code which is applicable to many types with the same underlying
    behavior.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the class I have created to show you how useful generics can be:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This class keeps the single value of a particular type. To set or return it
    we can use corresponding getter and setter methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What are promises?
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A promise represents the final result of an asynchronous operation. There are
    a number of libraries that support the use of promises in TypeScript. But before
    starting to talk about this, let's talk a bit about the browser environment which
    executes your JavaScript code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Event loop
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each browser tab has an event loop and uses different tasks to coordinate events,
    user interactions, running scripts, rendering, networking, and so on. It has one
    or more queues to keep an ordered list of tasks. Other processes run around the
    event loop and communicate with it by adding tasks to its queue such as:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The timer waits after a given period and then adds a task to the queue
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can call a `requestAnimationFrame` function to coordinate DOM updates
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM elements can call event handlers
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser can request the parsing of an HTML page
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript can load an external program and perform computation on it
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many of the items in the list above are JavaScript code. They are usually small
    enough, but if we run any long-running computation it could block execution of
    other tasks, and as a result it freezes the user interface. To avoid blocking
    the event loop we can:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Use the **web worker API** to execute a long-running computation in a different
    process of the browser
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not wait for the result of a long-running computation synchronously and allow
    the task to inform us about results via events or callbacks asynchronously
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous results via events
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code uses an event-driven approach to convince us and adds event
    listeners to execute small code snippets inside:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The method `send` in the last line of code just adds another task to the queue.
    This approach is useful if you receive results multiple times, but this code is
    quite verbose for a single result.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous results via callbacks
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage asynchronous results via callbacks, we need to pass a callback function
    as a parameter into asynchronous function calls:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This approach is very easy to understand, but it has its disadvantages:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: It mixes up input and output parameters
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is complicated to handle errors especially in the code combined many callbacks
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is more complicated to return result from combined asynchronous functions
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous results via promises
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, the promise represents the final result of an asynchronous
    operation happening in the future. Promises have the following advantages:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: You write cleaner code without callback parameters
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not adapt the code of the underlying architecture for delivery results
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code handles errors with ease
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A promise may be in one of the following states:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending state** : The asynchronous operation hasn''t completed yet'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolved state** : The asynchronous operation has completed and the promise
    has a value'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected state** : The asynchronous operation failed and the promise has
    a reason which indicates why it failed'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The promise becomes immutable after resolving or rejecting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you write the code to return the promise from functions or methods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We use the `new` keyword with a function constructor to create the promise.
    We add a factory function with two parameters into the constructor, which does
    the actual work. Both parameters are callback functions. Once the operation has
    successfully completed the factory function calls the first callback with the
    result. If the operation fails it calls the second function with the reason.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned promise has several methods such as `.then` and `.catch` to inform
    us of the result of the execution so that we can act accordingly:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can call another operation returns promise to quickly transform the result
    of original one:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Angular 2 concepts
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Angular 2** is a development platform for building web, mobile, and desktop
    applications. It is based on web standards to make web development simpler and
    more efficient, and entirely different from the Angular JS 1.x. The architecture
    of Angular 2 builds on top of the web component standard so that we can define
    custom HTML selectors and program behavior for them. The Angular team develops
    Angular 2 to use in the ECMAScript 2015, TypeScript, and Dart languages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of Angular 2
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any web application built on Angular 2 consist of:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates with Angular-specific markup
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives and components managing the HTML templates
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services containing application logic
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special `bootstrap` function which helps to load and start the Angular application
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular 2 application is an assembly of many modules. Angular 2 itself
    is a set of modules with names beginning with the `@angular` prefix, combined
    into libraries:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The `@angular/core` is the primary Angular 2 library and contains all core public
    APIs
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@angular/common` is the library which restricts APIs to reusable components,
    directives, and form building
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@angular/router` is the library that supports navigation
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@angular/http` is the library that helps us work asynchronously via HTTP
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metadata is information we can attach to underlying definitions via TypeScript
    decorators to tell Angular how to modify them. Decorators play a significant role
    in Angular 2.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Directives are the fundamental building block of Angular 2 and allows you to
    connect behavior to an element in the DOM. There are three kinds of directive:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directive is a class with an assigned `@Directive` decorator.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attribute directive usually changes the appearance or behavior of an element.
    We can change several styles, or use it to render text bold or italic by binding
    it to a property.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structural directive changes the DOM layout by adding and removing other
    elements.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Component
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The component is a directive with a template. Every component is made up of
    two parts:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The class, where we define the application logic
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view, which is controlled by the component and interacts with it through
    an API of properties and methods
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component is a class with the assigned `@Component` decorator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Template
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The component uses the template to render the view. It is regular HTML with
    custom defined selectors and Angular-specific markups.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular 2 supports *data binding* to update parts of the template via the
    properties or methods of a component. The *binding markup* is part of data binding;
    we use it on the template to connect both sides.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Service
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular 2 has no definition of a service. Any value, function, or feature can
    be a service, but usually it is a class created for a distinct purpose with an
    assigned `@Injectable` decorator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency injection is a design pattern that helps configure objects by an
    external entity and resolve dependencies between them. All elements in the loosely
    coupled system know little or nothing about definitions of each other. We can
    replace almost any element with alternative implementation without breaking the
    whole system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS loader and JSPM package manager
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed TypeScript modules, so it's time to talk about tools we can
    use for loading modules in our scripts.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS Loader
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SystemJS** is a universal dynamic module loader. It hosts the source code
    on GitHub at the following address [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)
    . It can load modules in the web browser and Node.js in the following formats:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015 (ES6) or TypeScript
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AMD
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global scripts
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SystemJS loads modules with an exact circle reference, binding support, and
    assets through the module naming system such as CSS, JSON, or images. Developers
    can easily extend the functionality of the loader via plugins.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add SystemJS loader to our future project:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Via direct link to a  **Content Delivery Network** ( **CDN** )
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By installing via npm manager
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both scenarios, we include a reference to the SystemJS library in our code
    and configure it via the `config` method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will speak about installation via npm manager a bit later in this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: JSPM package manager
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The developers of the SystemJS followed the single-responsibility principle
    and implemented a loader for doing only one thing: loading the modules. To make
    modules available in your project, we need to use the package manager. We spoke
    about the npm package manager at the beginning, so now we will talk about the
    JSPM package manager sitting on top of SystemJS. It can:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Download modules from any registry such as npm and GitHub
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile modules into simple, layered, and self-executing bundles with a single
    command
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSPM package manager looks like an npm package manager, but it puts the
    browser loader first. It helps you organize a seamless workflow for installing
    and using libraries in the browser with minimum effort.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first application
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, when we have everything in place, it''s time to create our first project,
    which is actually an npm module. Open Terminal and create the folder `hello-world`
    . I intentionally follow the npm package naming conventions:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The package name length should be greater than zero and cannot exceed 214
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the characters in the package name must be lowercase
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name can consist of/include hyphens
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name must contain any URL-safe characters (since the name ends up
    being part of a URL)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name should not start with dot or underscore letters
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name should not contain any leading or trailing spaces
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name cannot be the same as a `node.js/io.js` core module or a reserved/blacklisted
    name like `http` , stream, `node_modules` , and so on.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Move the folder in and run the command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'npm will ask you several questions to create a `package.json` file. This file
    keeps important information about your package in JSON format:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Project information like name, version, author, and license
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set of packages the project depends on
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set of pre-configured commands to build and test the project
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how `package.js` could look:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are ready to configure our project.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript compile configuration
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the Visual Studio code and open the project folder. We need to create a configuration
    file which guides the TypeScript compiler on where to find the source folder and
    required libraries and how to compile the project. From the **File** menu create
    `tsconfig.json` file, and copy/paste the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s look closer at the `compilerOptions` :'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The `target` option specifies the ECMAScript version such `es3` , `es5` , or
    `es6` .
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `module` option specifies the module code generator from one of these:
    `none` , `commojs` , `amd` , `system` , `umd` , `es6` , or `es2015` .'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `moduleResolution` option determines how modules get resolved. Use `node`
    for `Node.js/io.js` style resolution or `classic` .
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sourceMap` flag tells the compiler to generate a corresponding `map` file.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `emitDecoratorMetadata` emits the design-type metadata for decorated declarations
    in source.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `experimentalDecorator` enables experimental support for ES7 decorators
    such iterators, generators and array comprehensions.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `removeComments` removes all comments except copyright header comments beginning
    with `/*!` .
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `noImplicitAny` raises an error on expressions and declarations with an
    implied `any` type.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the full list of compiler options here: [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    .'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript compiler needs type definition files of JavaScript libraries
    from `node_modules` of our project because it doesn''t recognize them natively.
    We help it with `typings.json` file. You should create the file and copy/paste
    the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We should provide enough information to typings tool to get any typings file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The registry dt is located in the DefinitelyTyped source. This value could be
    npm, git
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name in `DefinitelyTyped` source is the `es6-shim`
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are looking for the version `0.31.2` updated `2016.03.17 12:06:54`
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task automation and dependency resolution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it''s time to add the libraries into the `package.json` file that the
    application requires. Please update it accordingly:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our configuration includes `scripts` to handle common development tasks such:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The `postinstall` script runs after the package is installed
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `start` script runs by the npm `start` command
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arbitrary scripts `lite` , `tsc` , `tsc:w` , and `typings` are executed
    by the `npm run <script>` .
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more documentation on the following web page: [https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)
    .'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing the configuration let''s run `npm` manager to install the packages
    required. Go back to Terminal and enter the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'During installation, you may see warning messages in red starting with:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You should ignore them if the installation finishes successfully. After installation,
    the npm executes the `postinstall` script to run `typings` installation.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Creating and bootstrapping an Angular component
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular 2 application must always have a top-level component, where all
    other components and logic lie. Let''s create it. Go to the Visual Studio code
    and create a sub-folder `app` of the root directory where we will keep the source
    code. Create the file `app.component.ts` under `app` folder, and copy/paste the
    following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we have added metadata via `@Component` decorator to the class
    `AppComponent` . This decorator tells Angular how to process the class via configuration
    with the following options:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The `selector` defines the name of an HTML tag which our component will link
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass in any service in the `providers` property. Any service registered here
    becomes available to this component and its children
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We give away any number of style files to `styles` a particular component
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `template` property will hold the template of the component
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template `url` is a URL to an external file containing a template for the
    view
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to `export` the class `AppComponent` to make it visible from other modules
    and Angular can instantiate it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular application is a composition of multiple modules marked with `NgModule`
    decorator. Any application must have at least one root module, so let''s create
    `AppModule` in the `app.module.ts` file:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The WebBrowser is a collection of modules and providers specific for web browsers
    such as document DomRootRenderer, and so on. We import WebBrowser into the application
    module to make all of those providers and modules available in our application,
    thereby reducing the amount of boilerplate code-writing required. Angular contains
    the `ServerModule` : a similar module for the server side.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to start up our application. Let''s create `main.ts` file under
    `app` folder, and copy/paste the following:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Last but not least, we rely on the `bootstrap` function to load top-level components.
    We import it from `''@angular/platform-browser-dynamic''` . Angular has a different
    kind of `bootstrap` function for:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Web workers
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development on mobile devices
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the first page of an application on a server
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular does several tasks after instantiation of any component:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: It creates a shadow DOM for it
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loads the selected template into the shadow DOM
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates all the injectable objects configured with `'providers'` and `'viewProviders'`
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, Angular 2 evaluates all template expressions and statements against
    the component instance.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create `index.html` file in Microsoft Visual Studio code under the root
    folder with the following content:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Because we are referencing the `systemjs.config.js` file, let''s create it
    in the root folder with the code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compiling and running
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are ready to run our first application. Go back to Terminal and type:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This script runs two parallel Node.js processes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler in watch mode
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static `lite-server` loads `index.html` and refreshes the browser when the
    application file changes
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your browser you should see the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling and running](Image00002.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code in the `chapter_1/1.hello-world`  folder.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Adding user input
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need to include our text input and also, specify the model we want to
    use. When a user types in the text input, our application shows the changed value
    in the title. Also, we should import the `FormsModule` into the `AppModule` :'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is the updated version of `app.component.ts` :'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `ngModel` attribute declares a model binding on that element, and anything
    we type into the input box will be automatically bound to it by Angular. Obviously,
    this isn''t going to be displayed on our page by magic; we need to tell the framework
    where we want it echoed. To show our model on the page, we just need to wrap the
    name of it in double curly braces:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I popped this in place of World in our `<h1>` tag and refreshed the page in
    my browser. If you pop your name in the input field, you''ll notice that it''s
    automatically displayed in your heading in real time. Angular does all of this
    for us, and we haven''t written a single line of code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user input](Image00003.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'Now, while that''s great, it would be nice if we could have a default in place
    so it doesn''t look broken before a user has entered their name. What''s awesome
    is that everything in between those curly braces is parsed as an Angular expression,
    so we can check and see if the model has a value, and if not, it can echo `''World''`
    . Angular calls this an expression and it''s just a case of adding two pipe symbols
    as we would in TypeScript:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It's good to remember that this is TypeScript, and that's why we need to include
    the quotation marks here, to let it know that this is a string and not the name
    of a model. Remove them and you'll notice that Angular displays nothing again.
    That's because both the name and `World` models are undefined.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code into the `chapter_1/2.hello-input` . folder.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Bootstrap 4
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created our `Hello World` application, and everything is working
    as expected, it''s time to get involved with Bootstrap and add a bit of style
    and structure to our app. At the time of writing this book Bootstrap 4 was in
    alpha version, so bear in mind that the code and markup of your application might
    be slightly different. We need to add the Bootstrap 4 style sheet into the `index.html`
    file:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The application is currently misaligned to the left, and everything is looking
    cramped, so let''s sort that out first with a bit of scaffolding. Bootstrap comes
    with a great *mobile first* responsive grid system that we can utilize with the
    inclusion of a few `div` elements and classes. First, though, let''s get a container
    around our content to clean it up immediately:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mobile first is a way of designing/developing for the smallest screens first
    and adding to the design rather than taking elements away.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you resize your browser window, you should start to notice some of the responsiveness
    of the framework coming through and see it collapsing:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Bootstrap 4](Image00004.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: 'Now, I think it''s a good idea to wrap this in what Bootstrap calls a Jumbotron
    (in previous versions of Bootstrap this was a hero unit). It''ll make our headline
    stand out a lot more. We can do this by wrapping our `H1` and `input` tags in
    a new `div` with the `jumbotron` class:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Integrating Bootstrap 4](Image00005.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
- en: It's starting to look a lot better, but I'm not too happy about our content
    touching the top of the browser like that. We can make it look a lot nicer with
    a page header, but that input field still looks out of place to me.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s sort out that page header:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![Integrating Bootstrap 4](Image00006.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
- en: I've included the chapter number and title here. The `<small>` tag within our
    `<h2>` tag gives us a nice differentiation between the chapter number and the
    title. The page-header class itself just gives us some additional margin and padding
    as well as a subtle border along the bottom.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The utmost thing I think we could improve upon is that input box. Bootstrap
    comes with some cool input styles so let''s include those. First, we need to add
    the class of form-control to the text input. This will set the width to 100% and
    also bring out some beautiful styling such as rounded corners and glowing when
    we focus on the element:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![Integrating Bootstrap 4](Image00007.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: 'Much better, but to me it looks a little small when you compare it with the
    heading. Bootstrap provides two additional classes we can include that will either
    make the element smaller or larger: `form-control-lg` and `form-control-sm` respectively.
    In our case, the `form-control-lg` class is the one we want, so go ahead and add
    that to the input.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Integrating Bootstrap 4](Image00008.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code in the `chapter_1/3.hello-bootstrap` .
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app's looking great and working exactly how it should, so let's recap what
    we've learnt in the first chapter.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we saw just how to setup a working environment and finish the
    TypeScript crash course.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Hello World` app we''ve created, while being very basic, demonstrates
    some of Angular''s core features:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Component directives
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application bootstrapping
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way data binding
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this was possible without writing a single line of TypeScript, as the
    component we created was just to demonstrate two-way data binding.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: With Bootstrap, we utilized a few of the many available components such as the
    Jumbotron and the page-header classes to give our application some style and substance.
    We also saw the framework's new mobile first responsive design in action without
    cluttering up our markup with unnecessary classes or elements.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](text00023.html#page "Chapter 2. Working with Bootstrap Components")
    , *Working with Bootstrap Components* , we're going to explore more Bootstrap
    fundamentals and introduce the project we're going to be building over the course
    of this book.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
