- en: Chapter 2. Architecting the Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software development is a complex process. We can''t just start writing some
    code and expect that we will reach our goal. We need to plan and define the base
    of our application. In other words, before you dive into actual scripting, you
    have to architect the project. In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic layers of a Node.js application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the task runner and building system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model-View-Controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The REST API concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the basic layers of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we plan to build a house, we will probably want to start with a very good
    base. We simply can't build the first and second floor if the base of the building
    is not solid.
  prefs: []
  type: TYPE_NORMAL
- en: However, with software, it is a bit different. We can start developing code
    without the existence of a good base. We call this **brute-force-driven development**.
    In this, we produce feature after feature without actually caring about the quality
    of our code. The result may work in the beginning, but in the long term, it consumes
    more time and probably money. It's well-known that software is nothing but building
    blocks placed on top of one another. If the lower layers of our program are poorly
    designed, then the whole solution will suffer because of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about our project—the social network that we want to build with
    Node.js. We start with a simple code like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The very first thing that you may notice is that you served a text to the user,
    but you probably wanted to serve file content. Node.js is similar to PHP. However,
    there is one fundamental difference. PHP needs a server that accepts the requests
    and passes them to the PHP interpreter. Then, the PHP code is processed and the
    response is delivered to the user again by the server. In the Node.js world, we
    don't have a separate external server. Node.js itself plays that role. It is up
    to the developer to handle the incoming requests and decide what to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the preceding code and assume that we have `page.html` containing
    our basic HTML layout and the `styles.css` file holding the CSS styles, our next
    step will be as follows (check out the `planning` folder in the book''s code samples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will check the incoming request's URL. If we just open `http://127.0.0.1:1337/`,
    we will receive the code of `page.html` as a response. If we have a `<link>` tag
    in the `page.html` file that requests `style.css`, the browser will fire a request
    for that too. The URL is different, but it is again caught by the `if` clause
    and then the proper content is served.
  prefs: []
  type: TYPE_NORMAL
- en: This is fine for now, but we will probably need to serve not two but many files.
    We do not want to describe all of them. So, this process should be optimized.
    The first layer of every Node.js server usually deals with routing. It parses
    the request's URL and decides what to do. If we need to deliver static files,
    then we will end up placing logic for that in an external module that finds the
    files, reads them, and sends a response with the proper content type. This can
    be the second layer of our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the delivery of files, we will need to write some backend logic.
    This will be the third layer. Again, based on the URL, we will perform some actions
    related to the business logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that we returned the JSON data. So now, our Node.js server acts as an API.
    We will talk about this at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the three layers that we just talked about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the basic layers of the application](img/image00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These will be the main layers of our application. In the chapters that follow,
    we will work on them. But before that, let's see what other work we have to do
    before we reach that point.
  prefs: []
  type: TYPE_NORMAL
- en: The task runner and building system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the practice of running the Node.js server, there are other best
    practices pertaining to web development tasks that you can consider. We are building
    a web application. So, we have client-side JavaScript and CSS that has to be delivered
    in the best possible way. In other words, to increase the performance of our website,
    we need to merge all the JavaScript into a single file and compress it. The same
    is valid for the CSS style sheets. If you do this, the browser will make fewer
    requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is a common tool for command-line utilities, except for when you want
    to run web servers. There are many modules available for the packaging and optimizing
    of assets. It is great that there are task runners and build systems that help
    you manage these processes.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Grunt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grunt is one of the most popular task runners that are based on Node.js. It
    is available in the package manager registry and can be installed by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run that in the terminal, we will get a global `grunt` command at our
    disposal. We need to create a `Gruntfile.js` file in the root directory of the
    project, which is where we will define our tasks. By tasks, we mean actions such
    as concatenation and minification that we want to perform on specific files. Here
    is a simple `Gruntfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first chapter of this book, we saw how one can define Node.js modules.
    The configuration needed by Grunt is just a simple module. We export a function
    that accepts a `grunt` object containing all the public API functions of the runner.
    In the `initConfig` block, we place our actions, and with `registerTask`, we combine
    actions and tasks. There should be at least one task that is defined with the
    name `default`. This is what Grunt runs if we don't pass additional parameters
    in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last function used in the preceding example—`loadNpmTasks`. The
    real power of Grunt is the fact that we have hundreds of plugins available. The
    `grunt` command is an interface that you can use to control these plugins when
    the real job is done. Since they are all registered in the Node.js package manager,
    we need to include them in the `package.json` file. For the preceding code, we
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue by adding two other functionalities to our Grunt setup. Once
    we have the JavaScript concatenated, we will probably want a minified version
    of the compiled file; `grunt-contrib-uglify` is the module that does this job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We should mention that the `uglify` task should be run after the `concat` one
    because they depend on each other. There is also a shortcut—`<%= concat.javascript.dest
    %>`. We use such expressions to simplify the maintenance of the `Gruntfile.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have Grunt tasks to process our JavaScript. However, it will be too annoying
    if we have to go back to the console and run `grunt` every time we make a change.
    This is why there exists `grunt-contrib-watch`. It is a module that looks out
    for file changes and runs our tasks. Here is the updated `Gruntfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To get the script working, we have to additionally run `npm install grunt-contrib-watch
    grunt-contrib-uglify –save`. The command will install the modules and will update
    the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the result in the terminal looks like when
    we call the `grunt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Grunt](img/image00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can now see how our tasks run and the watching task starts. Once we save
    changes to a watched file, both the operations—concatenation and minification—are
    fired again.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gulp is a build system that automates common tasks. As in Grunt, we can compose
    our asset pipeline. However, there are a few differences between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: We still have a configuration file, but it is called `gulpfile.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp is a streaming-based tool. It doesn't store anything on the disc when it
    is working. Grunt needs to create temporary files in order to pass data from one
    task to another, but Gulp keeps the data in the memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp follows the **code-over-configuration** principle. In the `gulpfile.js`
    file, we write our tasks like a regular Node.js script. We will see a demonstration
    of this in a minute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use Gulp, we have to install it first. The following command will set up
    the tool globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use a few plugins—`gulp-concat`, `gulp-uglify`, and `gulp-rename`.
    After adding them to our `package.json` file, run `npm install` so that we can
    install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a new `gulpfile.js` file in the root directory of
    our project and run the `gulp` command. Let''s keep the same tasks from the previous
    section and translate them to Gulp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few `require` calls at the top of the file. We initialized the
    public API of Gulp (the `gulp` object) and the plugins needed for the operations
    that we want to perform. We need to add all these modules to our `package.json`
    file. Just after that, we define three tasks by using the (`task_name`, `callback_function`)
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`js`: This is the task that gets our JavaScript files, pipes them to the plugin
    that concatenates files, and saves the result. We continue by sending the data
    to the `uglify` module that minifies our code and in the end, we save a new file
    with a `.min` suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watchers`: With this task, we can monitor our JavaScript for changes and run
    the `js` task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: By default, Gulp runs that part of our file. We may specify the
    task by adding one more argument to the `gulp` call in the terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the preceding script should look like the following screenshot.
    Again, we can see how automation happens. The watching part is present, too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering Gulp](img/image00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test-driven development is a software development process in which automated
    tests drive the development cycle of a new product or functionality. It speeds
    up the development in the long run and tends to produce better code. Nowadays,
    many frameworks have tools that help you create automated tests. So as developers,
    we need to write and run tests first before writing any new code. We always check
    what the result of our work is. In web development, we usually open the browser
    and interact with our application to see how our code behaves. So, a major part
    of our time goes into testing. The good news is that we may optimize this process.
    It is possible to write code that does the job instead of us. Sometimes, relying
    on manual testing is not the best option, because it takes time. Here are a few
    benefits of having tests:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests improve the stability of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated testing saves time that can be spent in improving or refactoring the
    system's code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development tends to produce better code over time because it makes
    us think about better structuring and modular approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous testing helps us develop new features on an existing app since the
    automated tests will fail if we introduce a code that breaks an old feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests could be used as documentation, especially for developers who have
    just joined the team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the beginning of the process, we want our test to fail. After that, we implement
    step-by-step the required logic till the test passes. The following diagram shows
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development](img/image00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Very often, developers use tools that help them write tests. We are going to
    use a testing framework called **Mocha**. It is available for Node.js and the
    browser, and it is one of the most popular solutions when it comes to automated
    testing. Let''s install Mocha and see how TDD works. We will run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already did several times in the book, we will have the package globally
    installed. For the purpose of this example, we will assume that our application
    needs a module that reads external JSON files. Let''s create an empty folder and
    put the following content into a `test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` and `it` functions are Mocha-specific functions. They are global
    and we have them readily available. The `assert` module is a native Node.js module
    that we may use to perform checks. Some of the popular testing frameworks have
    their own assertion methods. Mocha does not have one, but it works well with libraries
    such as `Chai` or `Expect.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `describe` to form a series of tests and `it` to define logical blocks.
    We assume that there is a `JSONReader.js` file in the current directory and when
    the module inside is required, we have a public `read` method available. Now,
    let''s run our test with `mocha .\test.js`. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development](img/image00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, our test fails because there is no such file. If we create the file
    and place the following code in it, our test will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JSONReader` module exports an object with the help of the `read` public
    method. We will run `mocha .\test.js` again. However, this time, all the requirements
    listed in the test are covered. Now, the terminal should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test-driven development](img/image00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's assume that our `JSONReader` module has been becoming bigger and bigger.
    New methods have come in, and different developers have worked on the same file.
    Our test will still check if the module exists and if there is a `read` function.
    This is important because somewhere at the beginning of the project, the programmer
    has used the `JSONReader` module and expects it to have the `read` function available.
  prefs: []
  type: TYPE_NORMAL
- en: In our test, we added just a few assertions. However, in the real world, there
    will be many more `describe` and `it` blocks. The more cases the test covers,
    the better. Very often, companies rely on their test suites before releasing a
    new product version. If there is a test that has failed, they just don't publish
    anything. In the next few chapters of the book, we will often write tests.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s always difficult to start a new project or the implementation of a new
    feature. We just don''t know how to structure our code, what modules to write,
    and how they are going to communicate. In such cases, we often trust well-known
    practices—design patterns. Design patterns are reusable solutions to commonly
    occurring problems. For example, the **Model-View-Controller** pattern has proven
    to be one of the most effective patterns for web development due to its clear
    separation of the data, logic, and presentation layers. We will base our social
    network on a variation of this pattern. The traditional parts and their responsibilities
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Model-View-Controller pattern](img/image00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Model**: The **Model** is the part that stores the data or the state. It
    triggers an update on the **View** once there is a change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The **View** is usually the part that the user can see. It is a direct
    representation of the data or the state of the **Model**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: The user interacts with the help of the **Controller** (sometimes
    through the **View**). It can send commands to the **Model** to update its state.
    In some cases, it can also notify the **View** so that the user can see another
    representation of the **Model**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, in web development (especially the code that runs in the browser),
    the **View** and the **Controller** share the same functions. Very often, there
    is no strict distinction between the two. In this book, the controllers will also
    deal with UI elements. Let's start with the Node.js environment. To simplify the
    example, we will place our code in a file called `server.js`. Our application
    will do only one thing—it will update the value of a variable stored in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our context, the **View** will produce HTML markup. Later, that markup will
    be sent to the browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this code, there is a JavaScript object literal with only one `render` method.
    To construct proper content for the `h1` tag, we will use the model and its `status`
    variable. There are two links as well. The first one changes `model.status` to
    `true` and the second one changes it to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Model` object is fairly small. Like the **View**, it has only one method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that **Model** triggers the rendering of the view. It is important to mention
    here that the Model should not know about the representation of its data in the
    view layer. All it has to do is send a signal to the view to notify that it is
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of our pattern is the **Controller**. We may consider it as an
    entry point of our script. If we are building a Node.js server, this is the function
    that accepts the `request` and `response` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We cached the `response` parameter in a global variable so we that can access
    it from other functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the instance that occurred at the beginning of this chapter
    where we used the `request.url` property to control the flow of the application.
    The preceding code changes the state of the model when the user visits the `/on`
    or `/off` URLs. If it does not, then it simply triggers the `render` function
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller pattern fits Node.js well. As we saw, it can be easily
    implemented. Since it is really popular, there are modules and even frameworks
    that use this concept. In the next few chapters, we will see how the pattern works
    in large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the REST API concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer**. By definition, it
    is an architectural principle of the Web. In practice, it is a set of rules that
    simplify client-server communication. A lot of companies provide REST APIs because
    they are simple and highly scalable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what REST exactly means, let''s take a simple example.
    We have an online store and we want to manage the users in our system. We have
    the backend logic implemented in various controllers. We want to trigger functionalities
    there via HTTP requests. In other words, we need an application program interface
    for these controllers. We start by planning the URLs to access our server. If
    we follow the REST architecture, then we may have the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` requests to `/users` return a list of all the users in the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` requests to `/users` create new user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` requests to `/users/24` edit the data of a user with the unique identification
    number `24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` requests to `/users/24` delete the profile of a user with the unique
    identification number `24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a resource defined—**user**. The URL is what makes REST simple. The
    `GET` request is used to retrieve data, `POST` is for storing, `PUT` is for editing
    and `DELETE` is for removing records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some parts of our small social network will be based on the REST architecture.
    We will have controllers that handle the four types of requests and perform the
    necessary operations. However, before we reach that part of the book, let''s write
    a simple Node.js server that accepts `GET`, `POST`, `PUT`, and `DELETE` requests.
    The following code goes to a file called `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `req` object has a `method` property. It tells us about the type of the
    request. We may run the preceding server with `node .\server.js` and send different
    types of requests. In order to test it, we will use the popular `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the REST API concept](img/image00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try a more complex `PUT` request. The following example uses cURL. It
    is a command-line tool that helps you run requests. In our case, we will perform
    a `PUT` request to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the REST API concept](img/image00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We changed the request method with the `-X` option. Along with this, we passed
    a variable called `book` with the `Node.js by example` value. However, our server
    does not have code that processes parameters. We will add the following function
    to our `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code accepts the `req` object and a callback function because collecting
    the data is an asynchronous operation. The `body` variable is filled with the
    incoming data and once all the chunks are collected, we trigger the callback by
    passing the parsed body of the request. Here is the updated controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we called `return` in the `PUT` catch statement. We did this so that
    the application flow stops there and waits till the request is processed. This
    is the result in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the REST API concept](img/image00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developing of software is a complex task. Like every complex process, it
    needs planning. It needs a good base and a well-designed architecture. In this
    chapter, we saw a few different aspects of planning a big Node.js application.
    In the next chapter, we will learn how to manage our assets.
  prefs: []
  type: TYPE_NORMAL
