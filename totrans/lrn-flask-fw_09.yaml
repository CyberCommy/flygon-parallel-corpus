- en: Chapter 9. Excellent Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about enhancing our Flask install with some popular
    third-party extensions. Extensions allow us to add extra security or functionality
    with very little effort and can polish your blogging app nicely. We will investigate
    **Cross-Site Request Forgery** (**CSRF**) protection for your forms, Atom feeds
    so others can find your blog updates, adding syntax highlighting to the code that
    you use, caching to reduce the load when rendering templates, and asynchronous
    tasks so that your app doesn't become unresponsive when it is doing something
    intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection using Flask-SeaSurf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom feeds using werkzeug.contrib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax highlighting using Pygments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching using Flask-Cache and Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous task execution using Celery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SeaSurf and CSRF protection of forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF protection adds security to your site by proving that a POST submission
    came from your site, and not a carefully crafted web form on another site designed
    to maliciously exploit the POST endpoints on your blog. These malicious requests
    can even work around authentication if your browser still considers you logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The way we avoid this is to add a special hidden field to any form on the site
    that has a value in it, generated by the server. When the form is submitted, the
    value in the special field can then be checked against the values generated by
    the server and, if it matches, we can continue with the form submission. If the
    value does not match or is non-existent, the form has come from an invalid source.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What CSRF protection actually proves is that the template, with the CSRF field
    in it, was used to generate the form. This mitigates the most basic of CSRF attacks
    from other sites but isn't conclusive in validating that the form submission only
    came from our server. For example, a script could still screen-scrape the contents
    of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it would be simple to build CSRF protection ourselves and WTForms, which
    is typically used to generate our forms, has this already built-in. However, let''s
    have a look at SeaSurf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With SeaSurf installed and using WTForms, it is now really easy to integrate
    it into our app. Open your `app.py` file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply enables SeaSurf for your app. Now, to enable the CSRF in your forms,
    open `forms.py` and create the following Mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a simple CSRF Mixin that can be used optionally
    within all your forms. The decorators ensure that the method is run before a request,
    in order to add the `HiddenField` field to your forms with the value of the randomly
    generated CSRF token. To use this Mixin in your forms, in this instance your login
    form, update the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We need to make this change for all the forms we want to protect,
    which is usually all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Atom feeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A really useful feature for any blog is to have the ability for your readers
    to keep up-to-date with the latest content. This most commonly happens with an
    RSS reader client that polls your RSS subscription feed. While RSS is widely used,
    a better, more mature subscription format is available and is called Atom.
  prefs: []
  type: TYPE_NORMAL
- en: Both are files that can be requested by a client, and are standard and simple
    XML data structures. Fortunately, an Atom feed generator is built into Flask;
    or, more specifically, a contributed module is built into the WSGI interface that
    Flask uses called Werkzeug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting it up-and-running is simple, all we need to do is to get hold of our
    most recently published posts from the database. It may be best to create a new
    Blueprint for this; however, you can also do it within your `main.py`. We just
    need to make use of a few more modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And create a new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now run your Flask app and the Atom feed will be accessible from `http://127.0.0.1:5000/latest.atom`
  prefs: []
  type: TYPE_NORMAL
- en: Syntax highlighting using Pygments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, as coders, we want to be able to display code in a web page, and while
    it is a skill to read that code without syntax highlighting, a few colors can
    make the reading experience much more pleasant.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is always the way with Python, there is a module already available that
    is able to do that for you, and of course it can be installed easily by the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pygments only works with the known sections of code. So, if you want to display
    code snippets, we can do that. If, however, you want to highlight inline sections
    of the code, we either follow the next section on Markdown, or we need to use
    some online Javascript such as `highlight.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create code snippets, we need to first create a new blueprint. Let''s create
    a directory called `snippets`, then an `__init__.py` file, followed by a `blueprint.py`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we set up the Pygments template filter that allows
    a string of code to be converted into HTML code. We also sneakily make use of
    the entries templates that are perfectly adequate for our needs. We use our own
    `detail.html` because that is where the magic happens with Pygments. We need to
    create a templates directory within the snippets director and another directory
    called snippets within templates, this is where we store our detail.html. So now
    our directory structure looks like app/snippets/templates/snipperts/detail.html
    Let''s set up that file now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is mostly identical to the `detail.html` that we used earlier in the book,
    except that we now pass it through the Pygments filter that we created in the
    app .As the template filter we used earlier produces raw HTML, we also need to
    mark its output as safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update our CSS file for the blog as Pygments uses CSS selectors
    to highlight words rather than wastefully writing the output to the page. It also
    allows us to modify the colors if we want. To find out what our CSS should be
    like, open up a Python shell and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will now print out the example CSS that Pygments suggests
    and we can copy-and-paste it into our `.css` file in the `static` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this code is not a great deal different from the previous Entry
    objects. It simply allows you to create, update, and view snippets. You will notice
    that we are using a `SnippetForm` here that we will define in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also create a `models.py` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we must re-run the `create_db.py` script to create the new table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to create a new form so that the Snippets can be created.
    Within `forms.py,` add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to make sure that this blueprint is used by editing the `main.py`
    file and adding in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And, once we have added some code here using the `Snippet` model, the resulting
    code will render as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Syntax highlighting using Pygments](img/1709_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple editing with Markdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Markdown is a now widely used mark-up language on the web. It allows you to
    write plain text in a special format that can be programmatically converted to
    HTML. This can be especially useful when editing text from a mobile device where,
    for example, highlighting text to make it bold is significantly trickier than
    on a PC. You can see how to use the Markdown syntax at [http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One interesting thing to note with Markdown is that you can still use HTML as
    well as Markdown at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, to get this running is quick and simple in Python. We install it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can apply it to our blueprint or app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes a new filter available in our templates called `markdown` and that
    can be used when rendering your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now all you need to do is write and save your blog entry content in Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, you may also wish to prettify the code blocks; Markdown
    has this facility built-in, so we need to extend the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This can now render the Markdown code blocks using Pygments. However, as Pygments
    uses CSS to add color to the code, we need to generate our CSS from Pygments.
    However, this time the parent block used has a class called `codehilite` (earlier
    it was called highlight), so we need to accommodate for this. In a Python shell,
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the output to your `.css` file in the `static` directory. So, with
    your included CSS, your Markdown entry could now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple editing with Markdown](img/1709_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are lots of other Markdown extensions built-in that we could also use;
    you can check them out and just use their name as a string when initializing the
    Markdown object.
  prefs: []
  type: TYPE_NORMAL
- en: Caching with Flask-Cache and Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, (and I know it's hard to imagine) we put a lot of effort into our
    sites, building in and adding features, and often that means we end up having
    to do a lot of database calls or complex template rendering for a page that is
    simply a static blog entry. Now database calls should not be slow and a lot of
    template renderings should not be noticeable but, if you expand that to lots of
    users (which hopefully you are expecting), this may become an issue.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the site is mostly static why not store your response in a single, high-speed
    memory-based data store? No need for expensive database calls or complex template
    renderings; for the same input, or path, get the same content, and faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is becoming a kind of a catch-phrase by now, we can already do this in Python
    and it is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To get it running, add this to your app or your blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also want to install Redis of course, this can be done on Debian and
    Ubuntu systems quite simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Redis is not yet available in the Red Hat and CentOS packaging
    system. You can, however, download and compile Redis from their site at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://redis.io/download](http://redis.io/download)'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Redis is unsecured; as long as we don't expose it to our network
    this should be fine and we do not need any more configuration for Flask-Cache.
    If, however, you are looking to lock it down, check out the Flask-Cache configuration
    for Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use caching in our views (as well as any methods). This is as simple
    as using a decorator on a route. So, open a view and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will see here that the cached decorator is within the route and that we
    have a timeout value of 10 minutes, in seconds. This means that, however heavy
    the rendering of your homepage is, and however many database calls it may make,
    the response is going to be straight out of memory for that time period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, caching has a time and a place and can be quite an art. If you have
    a custom homepage for each user, then caching will be useless. However, what we
    can do is cache sections of our template, so common areas such as all the `<link>`
    elements in the `<head>` will very rarely change but the `url_for(''static'',
    ...)` filter doesn''t have to be regenerated each time. Look at the following
    code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code section says that the link element should be cached for 30
    minutes, in seconds. You may also want to do this for your references to the scripts
    as well. We could also use it for loading a list of the latest blog posts, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secure, stable versions of your site by creating static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One technique for a high-volume site with low-dynamic content is to create a
    site that is simply a static copy of the dynamic site. This works great for blogs
    as the content is generally static and updated, at the most, a couple of times
    a day. However, you are still doing a bunch of database calls and template renderings
    for the content that effectively doesn't change.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, there is a Flask extension that has this covered: Frozen-Flask.
    Frozen-Flask identifies the URLs in your Flask app and generates the content that
    should be there.'
  prefs: []
  type: TYPE_NORMAL
- en: So, for the pages it generates the HTML and, for static content such as JavaScript
    and images, it pulls them out into a base directory that is a static copy of your
    site and that can be served up by your web server as static content.
  prefs: []
  type: TYPE_NORMAL
- en: This has the added benefit of the site being much more secure since the *active*
    version of the site cannot be changed by using the Flask app or the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some drawbacks to this, of course. If you have dynamic content on
    your site—for example, comments—it is no longer possible to store and render them
    in the conventional way. Also, if you have multiple authors on your site, you
    need a way of sharing your database content so they don''t end up producing separate
    copies of the site. Solutions are suggested at the end of this section. But first,
    let us install Frozen-Flask as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will need to create a file called `freeze.py`. This is a simple script
    that automatically sets up Frozen-Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code uses all the defaults of Frozen-Flask and when run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: will create (or overwrite) the directory `build` that contains the static copy
    of your blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frozen-Flask is quite smart and will automatically find all your links, as
    long as they are hierarchically referenced from the root homepage; for blog posts
    this works quite well. However, if entries get dropped from your homepage and
    they are accessed by an archive page on another URL, you may need to give Frozen-Flask
    pointers as to where to find those. For example, add the following to the `freeze.py
    file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Frozen-Flask is smart and uses the `url_for` method provided by Flask to create
    the static files. This means that anything that is available to the `url_for method`
    is available to be used by Frozen-Flask, if it cannot be found through the normal
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting on a static site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, as you might have guessed, by creating a static site you lose out on some
    blogging fundamentals—the one area that encourages communication and debate. Fortunately,
    there is a simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: Blog comment hosting services such as Disqus and Discourse work much like a
    forum, with the exception that each topic is created by each blog post. You can
    use their services for free to run your discussion or, with Discourse, you can
    run their server on your own platform for free, as it is completely open source.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing multiple editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another issue with Frozen-Flask, one that a person running the blog won''t
    notice, is this: with multiple authors spread across a network, how do you manage
    the database where your posts are stored? Everyone will need the same up-to-date
    copy of the database; otherwise, when you generate the static copy of the site,
    it won''t be able to create all the content.'
  prefs: []
  type: TYPE_NORMAL
- en: If you all work in the same environment, one solution is to have a working copy
    of the blog running on a server within the network and, when it comes to publishing
    time, it will use that centralized database to create the published version of
    the blog.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you all work in disparate locations where a centralized database
    is not ideal or impossible to secure, the other solution is to use a file-system
    based database engine such as SQLite. Then, when an update is made to the database,
    that file can be spread to others via e-mail, Dropbox, Skype, and so on. They
    then have an up-to-date copy of the database that they can locally run Frozen-Flask
    from to create the publishable content.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous tasks with Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Celery is a library that allows you to run asynchronous tasks within Python.
    This is especially helpful in Python as Python runs single threaded and you may
    find that you have a long-running task that you wish to either start and discard;
    or you may wish to give the user of your website some feedback on the progress
    of the said task.
  prefs: []
  type: TYPE_NORMAL
- en: One such example is e-mail. A user may request an e-mail to be sent, for example
    a password reset request, and you don't want them waiting for the page to load
    while the e-mail is generated and sent. We can set this up as a start and discard
    operation and let the user know that the request is being dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: The way Celery is able to escape the single-threaded environment of Python is
    that we have to run a Celery broker instance separately which; this creates what
    Celery calls workers that do the actual work. Your Flask app and the workers then
    communicate with each other via the messaging broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'So obviously, we need to install Celery and I''m sure you can guess by now
    that the command you need is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we need a message broker server. There are plenty to choose from; check
    out Celery's website for the supported ones, but, however, since we have already
    set up Redis in the Flask-Cache setup, let's use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to tell Celery how to use the Redis server. Open up the Flask app
    configuration file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration tells your instance of Celery where to find the message
    broker that it needs to communicate with the Celery broker. Now we need to initialize
    the Celery instance in our app. In the `main.py file,` add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This creates an instance of `Celery` with configuration from the Flask configuration
    file so we can also access the `celery` object from the Celery broker and share
    the same setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need something for the Celery worker processes to do. At this point,
    we are going to make use of the Flask-Mail library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to need some configuration for this to run. Add the following
    parameters to your Flask configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This configuration tells Flask-Mail where your e-mail server is. It is likely
    that the defaults may be good enough for you, or you may need more options. Check
    out the Flask-Mail configuration for more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now lets create a new file called `tasks.py` and create some tasks to run as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a really simple message generation; we are just generating an e-mail
    message with the content saying what the new password is, where the e-mail is
    from (our mail server), who the e-mail is going to, and the e-mail address of
    the user whose account it supposedly is, and then sends; the message is then sent
    via the already set up mail instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to get our Flask app to make use of the new asynchronous ability.
    Let's create a view that listens for an e-mail address being POSTed to it. This
    could be in any of the blueprints to do with accounts or your main app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding view accepts a POSTed message from a browser that contains the
    e-mail of the user who is is claiming to have forgotten his password. We first
    look up the user by their e-mail address to see if the user does indeed exist
    in our database. Obviously, there's no point resetting the password on an account
    that doesn't exist. Of course, if they don't exist, the user will be given a message
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user account does exist, the first thing to do is to generate
    them a new password. We use a hard-coded example password here. That password
    is then updated in the database so that the user can use it to log in when they
    receive the e-mail. Once all of that is out of the way, we then run .delay on
    the `task` we created earlier with the arguments that we want to use. This instructs
    Celery to run the underlying method when it is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is not the best solution for doing password resets. It is just
    to illustrate how you may want to do it in a succinct way. Password rests are
    a surprisingly complicated area and there are lots of things you can do to improve
    the security and privacy of this facility such as checking the CSRF value, limiting
    how many times the method is called, and using a randomly generated URL for users
    to reset their passwords at rather than a hard-coded solution that is sent via
    e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to run the Celery broker when we run our Flask app; otherwise,
    very little is going to happen. Don''t forget, this broker is the process that
    starts all our asynchronous workers. The simplest thing we can do is run the following
    command from within your Flask app directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This quite simply starts the Celery broker and tells it to look for the celery
    configuration within the `main` app so that it can find the configuration and
    the tasks it is supposed to be running.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start our Flask app and send some e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating command line instructions with Flask-script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One really useful thing to do with Flask is to create a command-line interface
    so that, when others use your software, they can easily make use of the methods
    you provide, such as setting up the database, creating administrative users, or
    updating the CSRF secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 'One area where we already have a script resembling this and one that can be
    used in this way is the `create_db.py` script in [Chapter 2](ch02.html "Chapter 2. Relational
    Databases with SQLAlchemy"), *Relational Databases with SQLAlchemy*. To do this,
    there is again, a Flask extension. Just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the interesting thing with Flask-Script is that the commands work a lot
    like the routes and views in Flask. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that Flask-Script refers to itself as Manager, but that the
    manager also hooks itself into the Flask app. This means you can do anything with
    the Flask app just by using the `app` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we convert our `create_db.py` app into a Flask-Script app, we should
    create a file for this to work in. Let''s call it `manage.py` and insert from
    the file `create_db.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All this does is set up a decorator so that the `manage.py` with the argument
    `create_db` will run the method which was in `create_db.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run from the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://highlightjs.org/](https://highlightjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://pythonhosted.org/Flask-Markdown/](http://pythonhosted.org/Flask-Markdown/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://pythonhosted.org/Markdown/extensions](http://pythonhosted.org/Markdown/extensions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/Frozen-Flask/](https://pythonhosted.org/Frozen-Flask/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://disqus.com/](https://disqus.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.discourse.org](http://www.discourse.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://eviltrout.com/2014/01/22/embedding-discourse.html](http://eviltrout.com/2014/01/22/embedding-discourse.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://flask-script.readthedocs.org/en/latest/](http://flask-script.readthedocs.org/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/Flask-Mail/](https://pythonhosted.org/Flask-Mail/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have done a wide variety of things. You have seen how to
    create your own Markdown renderer, so editing becomes easier, and move commands
    so they are within Flask and more manageable. We have created Atom feeds so that
    our readers can find new content when it is posted, and created asynchronous tasks
    so that we don't lock up the user's browser while waiting for a page to load.
  prefs: []
  type: TYPE_NORMAL
- en: In our final chapter, we will learn how to turn our simple application into
    a fully deployed blog that has all the features discussed, secured, and ready
    to use.
  prefs: []
  type: TYPE_NORMAL
