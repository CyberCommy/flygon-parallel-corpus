- en: Reviewing Our Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, our final chapter, we will take a look back and compare the state and
    quality of our sample service now, after applying **dependency injection** (**DI**),
    with how it was when we started.
  prefs: []
  type: TYPE_NORMAL
- en: We will be taking a look at the improvements we have made, along with one final
    look at our dependency graph, and will discuss our improvements in test coverage
    and the testability of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will wrap up this chapter with a brief discussion of what we could
    have done if we had been starting a new service with DI instead of applying it
    to existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A review of the dependency graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A review of test coverage and testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new service with DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service, as introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    registration service*. This chapter also assumes that you have read [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml), *Dependency
    Injection with Monkey Patching*, through to [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection,* on the various DI methods and other various improvements we made along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions for obtaining the code and configuring the sample service are available
    in the README, which can be found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme)[.](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch12/acme)
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew, we made it. How do you think we did? Do you think the improvements were
    worth the effort? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: To see how far we have come, we should first recap where we started.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to
    the ACME Registration Service*, we had a small, simple, working service. It got
    the job done for our users, but it created many inconveniences for those of us
    that had to maintain and extend it.
  prefs: []
  type: TYPE_NORMAL
- en: Global singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest pains was undoubtedly the use of global public singletons.
    At first glance, they seemed to make the code more concise, but they were actually
    making it much harder for us to test.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `init()` functions to create variables meant that we either had to
    use the live versions (that is, on the database) or had to monkey patch the globals,
    which led to potential data races.
  prefs: []
  type: TYPE_NORMAL
- en: We started off with two public globals (`config` and `logger`) and one private
    global (the database connection pool). In [Chapter 5](5b999adb-130a-49ed-9294-841c5a1b8181.xhtml),
    *Dependency Injection with Monkey Patching*, we used monkey patching to give us
    the ability to test the code that relied on the database connection pool singleton.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection*, we finally managed to remove the `config` global, after first removing
    most of the direct access to it during the changes we made in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency
    Injection by Config*.
  prefs: []
  type: TYPE_NORMAL
- en: By removing direct access and defining local config interfaces, we were able
    to completely decouple our model and data layers from the config. This means that
    our code is portable, should we ever want to use it in another application.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps most importantly, this means that writing tests on this code is now
    far less work, and our tests can all run independently and concurrently. Without
    the link to the global instance, we don't have to monkey patch. Without the dependency
    link, we are left with a smaller, more focused `config` interface, which is much
    easier to mock, stub, and generally understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The global `logger` instance managed to survive our many refactorings, but
    the only place it is used is during the `config` loading code. So, let''s remove
    it now. Our `config` loading function currently looks like that shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s pretty safe to say that, if we fail to load the config, our service is
    not going to work. We can, therefore, change our errors to write directly to *standard
    error* directly. Our updated function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The logger is otherwise *passed in* using config injection. By using config
    injection, we were able to forget about common concerns (such as the `logger`)
    without detracting from the UX of our constructors. We are now also able to easily
    write tests that validate logging without any data race issues. While such tests
    might feel weird, consider this—logs are an output of our system, and we will
    often rely on them when something goes wrong and we need to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, there might be cases when it''s useful to ensure that we are creating
    logs as we expect to and continue to do so, despite any future refactoring. This
    is not something we will want to test often, but when we do, the test itself is
    as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the global instance of the database connection pool also remains; however,
    unlike `Config` and `Logger`, it is private, so any risks associated with it have
    a limited scope. In fact, by using **just**-**in**-**time** (**JIT**) DI, we were
    able to decouple our model layer tests from the data package entirely, without
    detracting from the UX of the model layer packages.
  prefs: []
  type: TYPE_NORMAL
- en: High coupling with the config package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we started in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml),
    *Introduction to the ACME Registration Service*, we had not used any interfaces
    at all, and as a result, all of our packages were very tightly coupled with one
    another. Because of this, our packages had a high resistance to change; none more
    so than the `config` package. This was our original `Config` struct and the global
    singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the combination of a global singleton, lack of interfaces, and the fact
    that almost every package referenced this package, any change we made to the `Config`
    struct had the potential to break everything. Similarly, if we had decided to
    change the config format from a flat JSON file to a more complicated structure,
    we would have been in for some pretty nasty shotgun surgery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare our original `Config` struct with what we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, we now have a lot more code. However, the extra code mostly
    comprises `getter` functions that implement the various config interfaces of the
    packages. These `getter` functions give us a layer of indirection that allows
    us to change how the config is loaded and stored, without having to impact the
    other packages.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of local `Config` interfaces into many of the packages,
    we were able to decouple those packages from our `config` package. While the other
    packages still indirectly use the `config` package, we have gained two benefits.
    Firstly, they can evolve separately. Secondly, the packages all *document* their
    requirements locally, giving us a smaller scope to work with when we are dealing
    with the package. This is especially helpful during testing when we are using
    mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Review of test coverage and testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we introduced our sample service, we identified several issues related
    to testing. The first of these issues was the *lack of isolation*, where tests
    for one layer were also indirectly testing all the layers below it, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a test in the REST layer, but because it calls the actual model, and
    therefore, the actual data layers, it is effectively testing everything. This
    makes it a reasonable integration test, as it ensures the layers work together
    appropriately. But is a poor unit test, because the layers are not isolated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our unit test now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is considered isolated because, instead of relying on the other layers,
    we are relying on an abstraction—in our case, a mock implementation called `*MockGetModel`.
    Let''s take a look at a typical mock implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the mock implementation is very simple; definitely simpler than
    the actual implementation of this dependency. Because of this simplicity, we are
    able to trust that it performs as we expect, and therefore, any problems that
    arise in the test will be caused by the actual code and not the mock. This trust
    can be further reinforced by the use of a code generator, such as Mockery (as
    introduced in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding
    for User Experience*), that generates reliable and consistent code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mock has also given us the ability to test other scenarios easily. We now
    have tests for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Happy path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing ID in the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid ID in the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency (model layer or below) failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requested record does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these situations were difficult to reliably test without the changes
    we made.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our test is isolated from the other layers, the test itself has a much
    smaller scope. This means we need to know less; all we need to know is the API
    contract for the layer we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, this means that we only need to worry about HTTP concerns such
    as extracting data from the request, outputting the correct status code, and rendering
    the response payload. Additionally, the manner in which the code we are testing
    can fail has been reduced. So, we ended up with less test setup, shorter tests,
    and more scenario coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second issue related to testing was *duplication of effort*. With the lack
    of isolation, our original tests were often somewhat superfluous. For example,
    the model layer test for the Get endpoint looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks alright on the surface, but when we consider the fact that this
    test scenario has already been covered by our `REST` package test, we actually
    gain nothing from this test. On the other hand, let''s look at one of the several
    tests we have now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This test is now 100% predictable, as it does not rely on the current state
    of the database. It doesn't test the database, nor how we interact with it, but
    instead tests how we interact with the *data loader* abstraction. This means that
    the data layer implementation is free to evolve or change without needing to revisit
    and update the test. This test also validates that, if we receive an error from
    the data layer, we appropriately transform this error as our API contract expects.
  prefs: []
  type: TYPE_NORMAL
- en: We still have tests at both layers, as before, but instead of the tests bringing
    us no value, they now bring significant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thirdly, another issue we encountered when testing was *test verbosity*. One
    of the many changes we made was the adoption of table-driven tests. The original
    service test for our register endpoint looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, consider how it looks in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I know what you are thinking, the test became more verbose, not less. Yes, this
    individual test did. However, in the originals, if we were to test for another
    scenario, the first step would have been to *copy and paste* almost the entire
    test, leaving us with approximately 10 lines of duplicated code and only a few
    lines that were unique to that test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our table-driven tests style, we have eight lines of shared code that
    execute for every scenario and are clearly visible as such. Each scenario is neatly
    specified as an object in a slice like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For us to add another scenario, all we have to do is add another item to the
    slice. This is both very simple, and quite neat and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if we ever need to make changes to the tests, perhaps because the API
    contract changed, we now have only one test to fix, instead of many.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth issue we encountered was *reliance on our upstream service*. This
    is one of my pet peeves. Tests are supposed to be reliable and predictable, and
    test failures should be an absolute indicator that there is a problem that needs
    fixing. When tests rely on a third party and an internet connection, anything
    could go wrong, and the tests can break for any reason. Thankfully, after our
    changes in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency
    Injection by Config*, all of our tests, except the external-facing boundary tests,
    now rely on an abstraction and a mock implementation of the upstream service.
    Not only are our tests reliable, but we can now easily test our error-handling
    conditions similar to how we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following test, we have removed and mocked calls to the `converter`
    package in order to test what happens to our registrations when we fail to load
    the currency conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You might remember that we still have tests in our exchange package. In fact,
    we have two types. We have *internal-facing boundary tests* that call a fake HTTP
    server that we created. These tests ensure that when the server gives a particular
    response, our code reacts as we expect, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But we also have *external-facing boundary tests*, which still call the upstream
    service. These tests help us validate that the upstream service performs as we
    need it to, in concert with our code. However, to ensure our tests are predictable,
    we do not run the external tests very often. We achieved this by adding a build
    tag to this file, allowing us an easy way to decide when to include the tests.
    Typically, I would only run these tests either when something went wrong, or in
    order to set up a special step in the build pipeline that runs only these tests.
    We could then decide how to proceed after any failures during these tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To talk about raw numbers for a moment, when we started, our service''s test
    coverage looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test coverage was somewhat low. With the difficulty in writing
    tests and our inability to mock or stub our dependencies, this is not surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'After our changes, our test coverage is improving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While a lot of the changes we made to our service make it easier to test, we
    didn't spend that much time on adding additional tests. The bulk of the improvements
    that we did achieve came from increased scenario coverage, mainly involving being
    able to test the non-happy path code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to improve the test coverage, the easiest way to find out where
    more tests are needed is to use the standard go tools to calculate the coverage
    and display it as HTML. To do this, we run the following commands in a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After running these commands, the coverage will open in your default browser.
    To find potential places to make improvements we then scanning through the files,
    look for blocks of red code. Code highlighted in red indicates a line that was
    not executed during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: It is not pragmatic to remove all the untested lines, especially as some errors
    are close to impossible to trigger—rather, the key is to examine the code and
    decide if it represents a scenario that should be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example (the lines not covered are bold)—we''ll examine
    it in closer detail now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, let''s talk about these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These lines handle the scenario where the upstream service fails to return HTTP
    `200` (OK). Given the nature of the internet and HTTP services, the scenario has
    a high chance of happening. We should, therefore, construct a test that ensures
    our code handles this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Do you know how `http.NewRequest()` can fail? After digging around in the standard
    library, it appears that it can fail if we specify a valid HTTP method or if the
    URL fails to parse. These are programmer mistakes, and mistakes that we are unlikely
    to make. Even if we did make them, the results would be obvious and caught by
    existing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, adding a test for these conditions would be difficult, and almost
    certainly detrimental to the cleanliness of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, our tests so far suffer from a *lack of end-to-end testing*. At the
    end of [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf
    Injection*, we added a small number of end-to-end tests. We initially used these
    tests to validate that Google Wire performed as we expected. In the long term,
    they will serve to protect our API from accidental regression. Changes to our
    service's public API, whether it's the URL, the inputs or the output payloads,
    have a high chance of causing our users' code to break. Changes will sometimes
    be necessary, and in those cases, these tests will also serve a reminder to us
    that we need to take other actions as well, such as informing our users or versioning
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the dependence on upstream service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection
    with Constructor Injection*, we used constructor injection to decouple our model
    layer from the `exchange` package. You may remember that the `exchange` package
    is a thin abstraction over our upstream currency converter service. Not only did
    this ensure that our model layer tests no longer required the upstream service
    to be working in order to pass, but it also gave us the ability to ensure we had
    adequately handled cases where the service was failing.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml), *Dependency Injection
    by Config*, we added boundary tests that further removed our dependence on the
    upstream service by giving us the ability to test the `exchange` package independently
    of the upstream service. After removing all dependence on the upstream service
    from our frequently run unit tests, we added an external-facing boundary that
    tests the external service. However, we protected this test with a build tag,
    giving us the ability to run it selectively and occasionally, thus providing us
    with protection from internet and upstream service issues.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping short and latency budgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency Injection
    with Method Injection*, we used method injection to introduce the `context` package
    and request-scoped dependencies. By using `context` as a request-scoped dependency,
    we were then able to implement latency budgets and *stopping short*. With these
    in place, we are able to reduce our resource usage during abnormal system behavior.
    For example, if retrieving data (from the upstream currency conversion service
    or the database) is taking so long that the client is no longer waiting for a
    response, we can cancel the request and stop any further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified dependency creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we started in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to the ACME Registration Service*, our `main()` function looks rather simple,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After applying several DI methods to our code, by [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml),
    *Just-in-Time Dependency Injection*, our `main()` function had become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it had become longer and more complicated. This is a common
    complaint regarding DI. So, in [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*, we reduced this cost by letting Wire do it for us.
    This brings us back to a nice concise `main()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in [Chapter 9](60fb3899-8e56-4a9f-95bf-7e3eb70fea4e.xhtml), *Just-in-Time
    Dependency Injection*, we recognized the fact that there would only ever be one
    live implementation of the data layer, and the only time we would inject anything
    different was during testing. We, therefore, decided not to make the data layer
    a constructor parameter, but instead to use JIT injection, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen here, this gives us simplified, local dependency creation without
    detracting from the UX of our constructors and without losing our ability to mock
    the data layer during testing.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling and extensibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all our changes, perhaps our most significant win is the decoupling of
    our packages. Wherever possible, our packages define and depend only on local
    interfaces. As a result of this, our unit tests are entirely isolated from other
    packages and validate our usage of our dependencies—the contract between our packages—without
    any dependence on them. This means a minimal scope of knowledge is required when
    working on our packages.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps more importantly, any changes or extensions we might want to make are
    likely to be contained to a single or small number of packages. For example, if
    we wanted to add a cache in front of our upstream currency conversion service,
    all of the changes would be made only to the `exchange` package. Similarly, if
    we wanted to reuse this package in another service, we could copy or extract it
    and use it without changes.
  prefs: []
  type: TYPE_NORMAL
- en: Review of the dependency graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we have used the dependency graph as a way to discover
    potential issues. Here is how it looked when we started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deda18e8-1200-451b-9c5e-549f7674c82f.png)'
  prefs: []
  type: TYPE_IMG
- en: For a small service with only three endpoints, it's kind of complicated. From
    this graph, we also noticed that there were a lot of arrows pointing to the `data`,
    `config`, and `logging` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working under the assumption that more arrows going into or coming out of a
    package meant the more risk, complexity, and coupling, we set about trying to
    reduce these relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The highest impact change was our adoption of the config injection, which included
    the definition of local `config` interfaces (as discussed in the previous section).
    This removed all of the arrows going into the config package, except for the one
    from `main()`, which we cannot remove.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, during our config injection work, we also removed all the references
    to the global logging instance, and instead injected the logger. This, however,
    did not change the graph. This was due to our decision to re-use the `Logger`
    interface defined in that package.
  prefs: []
  type: TYPE_NORMAL
- en: We could have defined a copy of this interface inside every package and removed
    this coupling, but decided not to, given that the logger definition was probably
    not going to change. Copying the interface everywhere would add code for no gain
    beyond removing arrows from the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of our refactoring and decoupling work, our dependency graph looks
    like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d2b5a97-95ca-4631-a7e2-1ecdb5f7277e.png)'
  prefs: []
  type: TYPE_IMG
- en: It's better, but sadly, it's still rather messy. To address this and the issue
    regarding the logging interface that we mentioned earlier, I have one more trick
    to show you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been generating the graphs with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the `logging` package from the chart by using Godepgraph''s exclusions
    feature, changing the command to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This finally gives us the nice clear pyramid of a graph that we had been aiming
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfda7ea1-d6bd-488c-aee5-15a924125867.png)'
  prefs: []
  type: TYPE_IMG
- en: You might be wondering if we can further flatten the graph by removing the links
    between the `REST` and `model` packages (`get`, `list`, and `register`).
  prefs: []
  type: TYPE_NORMAL
- en: We are currently injecting the model code into the `REST` package; however,
    the one remaining link between the two is the output format of the `model` packages.
    Let's take a look at this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our list model API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are returning a slice of the `*data.Person` type, which forces our local
    interface in the `REST` package to be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Given that `data.Person` is a **data transfer object** (**DTO**), I am inclined
    to be pragmatic and leave it. We could, of course, remove it. To do so, we would
    need to change our `ListModel` definition to expect a slice of `interface{}`,
    and then define an interface into which we could cast our `*data.Person` when
    we need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two major issues with this. Firstly, it's a lot of extra work that
    only removes one line from the dependency graph, but makes the code messier. Secondly,
    we are effectively bypassing the type system and creating a way for our code to
    fail at runtime, should the return type of our model layer become different from
    the `REST` package's expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new service with DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have applied DI to an existing service. While this
    is by far the most common situation we will find ourselves in, sometimes we will
    have the honor of starting a new project from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: So, what could we do differently?
  prefs: []
  type: TYPE_NORMAL
- en: The user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we should always do is stop and think about the problem we
    are trying to solve. Go back to the UX discovery survey ([Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml),
    *Coding for User Experience*). Ask yourselves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Who are our users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do our users want to achieve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are our users capable of?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do our users expect to use the system we are going to create?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that you were starting the ACME registration service, how would you
    answer these questions?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answers might be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Who are our users?**—The users of this service will be the mobile application
    and web developers responsible for registration frontends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What do our users want to achieve?**—They want to be able to create, view,
    and manage registrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are our users capable of?**—They are familiar with calling HTTP-based
    REST services. They are familiar with passing in and consuming JSON-encoded data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do our users expect to use the system we are going to create?**—Given
    their familiarity with JSON and REST, they expect to do everything via HTTP requests.
    With the first, most obvious set of users out of the way, we can move onto the
    second most important group: the development team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who are the users of our code?**—Myself and the rest of the development team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What do our users want to achieve?**—We want to build a fast, reliable system
    that is easy to manage and extend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are our users capable of?**—We are also familiar with HTTP, REST, and
    JSON. We are also familiar with MySQL and Go. We are also comfortable with the
    many forms of DI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do our users expect to use the code we are going to create?**—We would
    like to use DI to ensure our code is loosely coupled, and easy to test and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how by considering our users, we have already started to outline
    our service. We have determined that give that familiarity with HTTP, JSON, and
    REST from both users that this is the best choice for communications. Given the
    developers' familiarity with Go and MySQL, these are going to be the best choices
    concerning implementation technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armed with the framework provided by getting to know our users, we are ready
    to think about implementation and code structure.
  prefs: []
  type: TYPE_NORMAL
- en: Given we are making a standalone service, we are going to need a `main()` function.
    After that, the next thing I always add is an `internal` folder directly under
    `main()`. This adds a clean boundary between the code for this service and any
    code in the same repository.
  prefs: []
  type: TYPE_NORMAL
- en: When you are publishing a package or SDK for others to use, this is an easy
    way to ensure your internal implementation packages do not leak into the public
    API. If your team happens to use a mono-repo or multiple services in one repository,
    then it's a great way to ensure that you do not have package name collisions with
    other teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layers we had in our original service were relatively normal, so can reuse
    them here. These layers are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e317a542-b91a-4ae5-9814-0b7f4ea479c1.png)'
  prefs: []
  type: TYPE_IMG
- en: The main advantage of using this particular set of layers is that each layer
    represents a different aspect required when processing a request. The **REST**
    layer deals only with HTTP-related concerns; specifically, extracting data from
    the requests and rendering the responses. The **Business Logic** layer is where
    the logic from the business resides. It also tends to contain coordination logic
    related to calling the **External Services and Data** layer. The **External Services
    and Data** will handle interaction with external services and systems such as
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each layer has an entirely separate responsibility and perspective.
    Any system-level changes, such as changing a database or changing from JSON to
    something else, can be handled entirely in one layer and should cause no changes
    to the other layers. The dependency contracts between the layers will be defined
    as interfaces, and this is how we will leverage not only DI, but testing with
    mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: As the service grows, our layers will likely consist of many small packages,
    rather than one large package per layer. These small packages will export their
    own public APIs so that other packages in the layer can use them. This does, however,
    deteriorate the encapsulation of the layer. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have performance issues with our database and want to
    add a cache so that we can reduce the number of calls we make to it. It might
    look something like that shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, there is no need for the existence of this cache to be visible to the
    **Business Logic** layer. We can make sure that the encapsulation of data layer
    does not leak the `cache` package by adding another `internal` folder under the
    `data` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This change might seem unnecessary, and for small projects, that's a good argument.
    But as the project grows, the little cost of adding an extra `internal` folder
    will pay off and ensure that our encapsulation never leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that it's possible to deal with cross-cutting concerns, such as
    logging and configuration, in many different ways. It's advisable to decide on
    a strategy upfront and get your team to agree on it. Monkey patching, constructor
    injection, config injection, and JIT injection are all possible ways to either
    pass around or access config and logging singletons. The choice is entirely up
    to you and your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Designing from outside-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about applying DI from the start of a project is that
    it gives us the ability to defer decisions until we are better informed to make
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, after deciding to implement a HTTP REST service, we can then proceed
    to design our endpoints. When designing our Get endpoint, we could describe it
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The get endpoint returns a person object in JSON with the form {"id":1,"name":"John","phone":"0123456789","currency":"USD","price":100}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that this only describes what the user needs, and does nothing
    to specify where the data is coming from. We can then actually code our endpoint
    to achieve this exact goal. And it might even look a lot like this, from [Chapter
    10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml), *Off-the-Shelf Injection*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As `GetModel` is a locally defined abstraction, it also doesn't describe where
    or how the data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The same process could be applied to our implementation of `GetModel` in the
    business logic layer. It does not need to know how it's being called or where
    the data is stored, it only needs to know that it needs to coordinate the process
    and convert any response from the data layer to the format expected by the REST
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: At each step of the way, the scope of the problem is small. The interactions
    with layers below depend on abstractions and the implementations of each layer
    is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: And when all the layers of a function are implemented, we can use DI to wire
    it all together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the state and quality of our sample service after
    applying DI, and contrasted that with its original state, thereby reminding ourselves
    both why we made the changes, and what we gained from making them.
  prefs: []
  type: TYPE_NORMAL
- en: We took one final look at our dependency graph to get a visual perspective on
    just how well we managed to decouple our packages.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how our sample service was both significantly easier to test, and
    that our tests were much more focused after making our changes.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we also discussed how to approach starting a new
    service and how DI can help with that endeavor too.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have finished our examination of DI for Go. Thank you for taking
    the time to read this book—I hope that you have found it both pragmatic and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was the most important improvement made to our sample service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our dependency graph, why isn't the data package under `main`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would you do differently if you were starting a new service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
