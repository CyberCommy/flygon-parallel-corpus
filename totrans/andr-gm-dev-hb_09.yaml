- en: Chapter 9. Testing Code and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A bug free product is a myth" is a common phrase in the development industry.
    A problem-free and issue-free application or any other product is rationally not
    possible. However, the developer can always minimize the number of bugs and issues
    so that the game can run with the fewest possible problems and support the most
    platforms with the maximum possible efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the scope of various debugging aspects in Android game development
    through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Android AVDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android DDMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android device debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the memory footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategic placement of different debug statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in Android games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging for Android while working with cross-platform engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best testing practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android AVDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AVDs are the most significant and important part of debugging Android games.
    In the initial stages, the concept started with an emulator. There are a few predefined
    emulators that can be used to run the build on a development PC. An Android emulator
    provides an interface of a real-time-like device.
  prefs: []
  type: TYPE_NORMAL
- en: AVDs have a few features that virtually provide the device RAM, Android version,
    screen size, display dpi, keyboard, and different visual skins. Older AVDs mostly
    looked the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android AVDs](img/B05069_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the current version of Android Studio, most of the Android device categories
    are provided. Developers can create AVDs as per the target development platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The categories are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Android mobile phones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android tablets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android TVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android wearables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AVDs can be created or manipulated by the AVD manager tool provided within the
    Android SDK. Each and every attribute of AVD can be managed by the AVD manager.
    This tool can also help the developer to create a custom AVD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the attribute factors for each different AVD:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android version API level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android target version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware input options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended AVD settings and creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of the AVD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name is only to identify the AVD. Anything can assigned to it, and it can
    be changed later. Predefined AVD names can also be changed at the time of creation.
  prefs: []
  type: TYPE_NORMAL
- en: AVD resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AVD resolution is one of the most important factors for visibility. There are
    some predefined resolution standards, but they can also be changed. Nowadays,
    mostly, developers pick resolutions that are widely used on an actual hardware
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: One more use of resolution is to check and verify the display portability of
    games. Mostly, games are made in a target base resolution. Then, the game can
    be tested on various resolutions to check the compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, multiple resolutions would create any issues if the aspect ratio is
    the same. However, in the case of Android, we can find multiple aspect ratios
    for different devices. The resolution factor of AVD helps fit the game and check
    its compatibility for multiple aspect ratios as well.
  prefs: []
  type: TYPE_NORMAL
- en: AVD display size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the visible space or visible display area on an AVD. One high-resolution
    AVD can have a small display area. It directly implies that the AVD has a high
    dpi value, which means a higher display quality.
  prefs: []
  type: TYPE_NORMAL
- en: This section of AVD helps ensure the visual quality of the game. However, it
    is not always possible to set the actual display region in the development system
    as the development system has its own display limit.
  prefs: []
  type: TYPE_NORMAL
- en: Android version API level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While developing an Android game, the developer needs to limit the API usage
    to a certain version. The API version can be deprecated in future versions of
    Android or even discontinued. To check this factor, the developer can set an API
    version for AVD.
  prefs: []
  type: TYPE_NORMAL
- en: Android target version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the Android version that will be used to run the AVD. This can verify
    the manifest target Android version and minimum version range.
  prefs: []
  type: TYPE_NORMAL
- en: CPU architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android devices mainly use three types of CPU architecture: armeabi, armeabi-v7,
    and x86\. This does not have a direct impact on games. However, the processing
    speed and quality varies with CPU architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The developer should keep in mind that actual game performance on a real device
    with a different CPU architecture will always perform differently than an AVD.
    So, it may give the developer an idea of performance, but it needs to be tested
    on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: RAM amount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RAM amount specifies the total amount of memory that the AVD has, which can
    be used to check the memory consumption of the game at various levels.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to predict the memory overflow issue for various devices. By running
    multiple apps at a time, a real-time clone can be created with the AVD. The default
    value is set to 66 MB. The developer can set any value according to the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: External storage can be also defined as an SD card for a virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware input options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Android devices, there can be many types of hardware input distributed within
    a wide range of hardwires. The most common variations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Touch screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch pad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key pad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many hardware platforms have opted for a combination of these variants. An AVD
    creates a virtual system for all of these input systems.
  prefs: []
  type: TYPE_NORMAL
- en: Other options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other options that are readily available for manipulation. If
    the development system has a camera attached to it, then the AVD can also use
    a camera, both front and back.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, virtual accelerometers, sensors, and so on can be associated with
    an AVD.
  prefs: []
  type: TYPE_NORMAL
- en: Extended AVD settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom AVD can be made through a modern AVD manager tool. A developer can
    design a virtual device with a custom look and feel, and with complete custom
    hardware configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Android DDMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDMS can be used to analyze a running application for all run-time details such
    as memory consumption, process calls, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The main functions of Android DDMS are port providing, screen capture on a device,
    thread details, heap details, and Logcat processing. This service can be used
    for spoofing calls and messaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android DDMS is widely used for device debugging. Particularly in the game
    development procedure, it is often used as a line-by-line debugging system. This
    is very useful to identify unwanted loaded objects and assets, and to track runtime
    exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android DDMS](img/B05069_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android DDMS can be used to carry out the following activities.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting an Android device filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDMS can connect to a device filesystem and provide a file browser-based operation
    to copy, modify, or delete any file on the device through a PC. This method or
    feature, however, is not very important for Android game development.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting DDMS feature is profiling or tracing matrices of certain
    methods. It gives information on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Execution time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory use during execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending this feature, the developer can even gain control over profiling the
    data of a method by calling `startMethodTracing()` and `stopMethodTracing()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer needs to keep an eye on two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Up to Android 2.1, it is mandatory to have an SD card installed on the device
    with the application's permission to read/write on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Android 2.2 onward, the device can stream profiling data directly to the
    development PC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread information monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDMS provides details on each thread running for each process on a selected
    device. However, games mostly run on a single thread. As devices are getting better
    each day, games are also using the multithreading feature to support various operations
    such as rendering, processing, file I/O, and networking.
  prefs: []
  type: TYPE_NORMAL
- en: Heap information monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDMS provides heap usage at runtime for a running process. It is very useful
    for game developers to track the game process heap during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking memory allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very useful for tracking each and every memory allocation of runtime
    objects. This gives every detail on each specific object of each class. This means
    the developer can find out which class is taking exactly how much memory. This
    helps achieve memory optimization in a much more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and managing network traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Android 4.0 onwards, DDMS features a **Detailed Network Usage** tab to
    track when a game makes network requests. Using this feature, the developer can
    monitor network data transfer. This option can be very useful to optimize network
    development. It can distinguish between different traffic types by applying a
    "tag" to network sockets before use.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking log information using Logcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logs are the most useful debugging technique for tracking almost anything. It
    is a good practice to use logs properly to check the data or value of certain
    objects during runtime. It is very useful for logic development for games.
  prefs: []
  type: TYPE_NORMAL
- en: In game development, logical requirements will be different for different games.
    So, there must be a good amount of code that is written for the first time. Predefined
    test cases are not available. This deficiency can be overcome using Logcat from
    DDMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logcat provides log information in the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Verbose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating device operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed Android virtual devices earlier, DDMS can work upon AVDs as
    well. So, it becomes much easier to emulate a real-time scenario to debug the
    game being developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used emulations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Emulating an incoming phone call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating an incoming message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating network state change during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three are the most common scenarios at runtime. So, these situations can
    be checked without a physical device. Interruption handling has been difficult
    for Android devices since the beginning. As a matter of fact, this can be a nightmare
    for a programmer if interrupts are not handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: There are some common problems of crashing/freezing/restarting the game after
    an interrupt. Many times, some unnecessary services or processes can be interrupts,
    and they may change the game state during the interruption period. Emulating every
    possible interrupt on an AVD is always an added advantage to speed up the debugging
    or interrupt handling procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Android device testing and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android device debugging is the most important part for any Android game development
    process. Let''s divide this topic into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Device testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main challenge for a game developer is to run the game on a large number
    of different devices. These different devices include different displays, different
    resolutions, different Android operating system versions, different processors,
    and different memory capacities. Due to these reasons, Android device testing
    is important and has to be carried out with great effort and planning.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, in a game development cycle, first-point testing is carried out by
    the developer. This process makes sure that the game is running on devices.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the tester or a group of testers test the game on different devices from
    various aspects. This is the main part of device testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the main testing phases are divided into four parts according to
    game development stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Prototype test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full or complete test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release test or run test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, a similar kind of distribution in each category is termed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-alpha test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beta test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release candidate test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other testing procedures that may follow typical software testing.
    However, in game development, usually, these approaches are followed. Let's describe
    these stages in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The developer and designer together develop a playable stage of the basic game
    idea with an initial set of game rules. These rules and gameplay are tested during
    the phase of prototype testing.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, core gameplay is tested in this phase to analyze the feasibility, potential,
    and scope for the game concept.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype testing is probably the most important part of the game development
    process. This phase determines the future of the game concept and also helps in
    developing a meta game and monetization model for the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Full or complete testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, whenever the first few builds are submitted to testing in each phase,
    full testing is conducted. This reveals each and every possible issue with the
    game, including crashing, freezing, visual issues, playability, game rules, and
    design faults.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the issues are usually reported during this phase, which eventually
    implies the possible completion time and effort for that game build.
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regression testing comes after full testing. Developers, designers, and producers
    take a call on each and every issue reported during full test. They select issues
    for resolving, and after the issues are resolved, they are submitted back to the
    testing team for regression test.
  prefs: []
  type: TYPE_NORMAL
- en: In regression testing, a tester usually picks the issue and specifically checks
    whether it is actually solved or not. If the issue occurs in a fixed build, then
    the testers reopen the issue for the next regression cycle. This cycle continues
    until all the reported issues are addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Release testing or run testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is probably the most mechanical testing phase of game testing. In this
    phase, the tester runs the regression test passed builds on various target devices,
    just to check whether the game is running on that hardware or not. This is the
    reason this phase is often called a "run test".
  prefs: []
  type: TYPE_NORMAL
- en: As many physical devices as possible are used for this segment of testing for
    a compatibility check. The final device support list is created after this testing
    phase. It is almost impossible to arrange all the available devices and perform
    a run test on them. So, the developer groups the devices according to their configuration
    and performance. Devices that behave in a similar manner are put in the same category,
    and only one or two devices are actually arranged for run testing for the whole
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Device debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that device testing is mainly the job of a tester. Now,
    we will see that device debugging is basically the job of a developer. However,
    commonly, it is done by both developers and testers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the game industry, device debugging is mainly used to find out runtime crashes,
    freezes, memory issues, networking issues, and performance issues. Through device
    debugging, the developer gathers the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime maximum heap consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average FPS on various devices or multiple set of devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unnecessary loaded objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware button behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network request and response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breakpoints are very useful and handy in the case of device debugging. The game
    thread is paused at breakpoint, and the state info can be achieved through DDMS.
    Game programming is mostly about customized algorithms, which might produce some
    unusual behavior during runtime. Breakpoints come handy in this situation. The
    developer can debug the logic line by line after a breakpoint so that the root
    cause of the behavior is found and fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the memory footprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory footprints are the signs and ways of using memory during runtime. From
    the point of game memory usage optimization, monitoring the memory footprint is
    very important:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking heap updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking overall memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking log messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using log messages has been the most effective and immediate debugging technique.
    Message logs are very useful for tracking the program control flow and runtime
    object tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Dalvik message log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Dalvik message log is useful for tracking memory. Whenever garbage collection
    happens, the garbage collector can print the following information through Dalvik
    log messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Garbage collection reason**: This info reveals the reason for triggering
    garbage collection. The reasons can be `GC_CONCURRENT`, `GC_FOR_MALLOC`, `GC_HPROF_DUMP_HEAP`,
    `GC_EXPLICIT`, or `GC_EXTERNAL_ALLOC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amount of memory freed**: This section states the amount of memory freed
    by the garbage collector in KB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current heap memory status**: This shows the percentage of heap memory used
    and live objects memory/total heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External memory status**: There may be some operations that allocate memory
    externally. This section shows the allocated memory/garbage collection limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collector pause time**: Pause time is triggered twice, at the beginning
    of garbage collection and at its end. Normally, the pause time is higher in the
    case of a large heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ART message log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ART message log is also capable of showing or tracking memory footprints.
    However, it is not triggered unless explicitly requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the garbage collector pause time exceeds 5 ms or the garbage collector takes
    more than 100 ms to execute, then garbage collector logs are printed. In the case
    of ART, the following information can be shown as logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Garbage collection reason**: In ART log messages, the developer can have
    `Concurrent`, `Alloc`, `Explicit`, `NativeAlloc`, `CollectorTransition`, `HomogeneousSpaceCompact`,
    `DisableMovingGc`, or `HeapTrim` as the reason for collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name of garbage collector**: ART has few different garbage collectors that
    can be involved in a collection process. The name can be known by the field of
    the collection log. ART has these collectors: **Concurrent** **Mark Sweep** (**CMS**),
    **Concurrent** **Partial Mark Sweep** (**CPMS**), **Concurrent Sticky Mark Sweep**
    (**CSMS**), and Marksweep plus Semispace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count of objects freed**: This shows the total number of objects freed from
    memory by the garbage collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amount of memory freed**: This shows the total amount of memory freed by
    the garbage collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count of large objects freed**: This shows the number of objects freed from
    the large object scope. These objects are freed by the collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory amount freed from large objects**: This shows the amount of memory
    freed from the large object scope. This memory is freed by the collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current heap memory status**: This is the same as the one for Dalvik logs—live
    objects count/total heap memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GC pause time**: In the ART pause time section, this is directly proportional
    to the number of object references modified by the running garbage collector.
    Unlike Dalvik, the ART CMS garbage collector has only one pause time during the
    end of the collection process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking heap updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The developer can check the heap usage per update. It gives a clear picture
    of the memory footprint. Heaps can be monitored with the help of several tools.
    There are plenty of device memory monitors available in the market. DDMS device
    monitor is one of them. It is a powerful tool that observes heap usage during
    the game's runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Android SDK comes with an inbuilt device monitor at `<sdk>/tools/monitor`.
  prefs: []
  type: TYPE_NORMAL
- en: The memory monitor in Android Studio is useful for Android Studio users. Monitors
    can interact with the Android application to watch heap update with each garbage
    collection. Through this, the Android developer can know about exact memory usage
    for each segment of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, developers switch on/off methods to check exact heap usage. Thus,
    it becomes easier to optimize it further.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking memory allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is helpful for memory optimization. Memory allocation can be monitored
    through an **allocation tracker**.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation tracking is required after a certain stage of memory optimization.
    This helps identify each and every object's memory allocation. Often, many useless
    objects stay back in memory. The developer can identify these objects and remove
    them for greater memory optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation tracker is available with both Device Monitor in Android SDK
    and Allocation Tracker in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s not necessary to remove all allocations from performance-critical
    code paths; yet, the allocation tracker can help developers identify important
    issues in code. For instance, some apps might create a new `Paint` object on every
    draw. Moving this object into a global member is a simple fix that helps improve
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking memory allocation](img/B05069_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a quick look at the allocation information obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '**s1**: This is the object package currently being tracked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s2**: This shows the **Allocation** tab is selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s3**: This is used to start/stop tracking of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s4**: This updates the package allocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s5**: This shows the allocation details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In game development, the number of objects in memory is immense, so it is very
    difficult to keep track of allocation and deallocation of objects manually. This
    monitoring tool helps find out the hidden spots that could have been easily ignored
    during the optimization process.
  prefs: []
  type: TYPE_NORMAL
- en: Checking overall memory usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overall memory usage of an Android game is distributed in different segments
    in RAM. This creates a general idea about application performance and memory security.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, there are two types of allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Private RAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the dedicated memory portion used by the game during runtime. The Android
    operating system allocates this memory to the application. Private RAM is distributed
    in two segments:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dirty RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private dirty RAM is the most expensive one as it can only be used by specific
    applications (in our case, it is an Android game).
  prefs: []
  type: TYPE_NORMAL
- en: Proportional set size (PSS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This segment of RAM is used by multiple processes. It is basically shared memory.
    Any RAM pages that are unique to the application process directly contribute to
    its PSS, while pages that are shared with other processes contribute to the PSS
    value only in proportion to the amount of sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking memory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory leakage is a serious threat to software development. So, it is absolute
    necessary to track memory leakage and resolve it. When a process allocates memory
    and loses the reference pointer, then it is impossible to free the memory within
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: There are few debug tools that can do this job to track down memory leakage.
    However, there is another free and more effective solution. The developer can
    always monitor memory consumption at any given point of time. A game runs within
    an update loop. So, it is possible to track the memory peaks of different game
    cycles. If the peak keeps increasing, it means there are leaks in the allocation/deallocation
    of memory. Now, the developer can check the size of each object and hunt down
    the leakage. Another benefit of this process is finding unnecessary objects in
    memory alongside memory leakage.
  prefs: []
  type: TYPE_NORMAL
- en: Strategic placement of different debug statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A debug statement is the most important part of any development process. Anything
    and everything can be tracked and traced through debug statements. However, being
    a system printing call, each debug statement comes with a cost on performance,
    which has a direct effect on runtime FPS. This is why a strategy on the placement
    of debug statements is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the strategies related to following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking the object state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the program flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking object values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a game development object cycle, an object should be allocated once per initialization
    and deallocated on destruction. However, due to manual programming mistakes, developers
    forget to free the memory. In this case, the garbage collector cleans the memory
    when it is invoked by the system automatically. This way, a lag in performance
    is observed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as a strategic placement to trace such mistakes, two debug messages should
    be placed at the constructor and destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a debug statement after initializing each object ensures a successful
    initialization of the object. This can reveal the amount of memory it consumes.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the object state at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object can be initialized at any time during gameplay. Now, any external
    dependency in the initialization process can cause failure of allocation. So,
    the object goes into null state and might cause an exception if not handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: A successful debug statement and a failed debug statement (with reason) helps
    the developer rectify the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, a wrong deallocation also changes the state of the object. So, the
    debug statement identifies the spot. The developer can solve the issue with the
    help of debug statements both for objects and program flow.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the program flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A debug statement in every method clearly shows the call hierarchy and program
    flow. A modular program can be tested with this system. Then, the module set can
    be tested with one debug statement in each module start.
  prefs: []
  type: TYPE_NORMAL
- en: Any wrong or unnecessary calls can be removed or rectified through this process.
    Proper program flow ensures a certain frame rate during runtime. So, this approach
    can be used to optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking object values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even after a successful initialization of the object, the content may not be
    correct. So, putting a debug statement to check the loaded/initialized content
    is necessary to avoid future conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful when loading data from an external source. Debug statements
    are used to verify the loaded data after initialization. Any program module can
    be designed using an object-tracking method, resulting in a better programming
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in Android games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling may not be a part of debugging, but it helps reduce the number
    of exceptions and unnecessary application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in Android is the same as Java exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard Java syntax for exception handling is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The suspicious code should be put inside a `try` block, and the exception should
    be handled in a `catch` block. If the module requires some default task to execute,
    then put it in the `finally` block. The `catch` and `finally` blocks might not
    be defined always in exception handling. However, it is recommended that you process
    the exception in each `try` block failure, which is a good programming practice.
    This process requires you to analyze the module to find out any vulnerable chunk
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple example of handling exception along with other vulnerable default
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the initial program design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program should be written in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The developer should remember the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: A `try` block can be used only with a `catch` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `try` block can be used only with a `finally` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `try` block can be used with both `catch` and `finally` blocks in sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `try` block cannot be used alone anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested `try…catch` is possible but not recommended as a good programming practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are plenty of predefined exception scopes depending on the exception
    type and cause. However, the major exceptions handled in a game development process
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Null pointer exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index out of bound exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input/output exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null pointer exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is one of the most encountered exceptions in the case of game development.
    `NullPointerException` is thrown when any null object is referred to in the code.
    The developer should track the initialization and use of the object to rectify
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will throw an exception as `objA` has been initialized with null. Hence,
    this object is nowhere located in the memory, and a reference pointer does not
    exist. A modern smart compiler can detect this obvious exception during compile
    time, but the code might be like this, where we defined another class containing
    the `testFunc()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, most of the smart compilers cannot detect the upcoming exception.
    To handle this, the developer should add few more lines of code to the `testFunc()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Index out of bound exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exception is thrown when accessing an indexed address, which is supposed
    be a part of contiguous memory allocation, but is not. The most common one is
    `ArrayIndexOutOfBoundsException` in the case of game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if an array contains five fields and the program tries to access
    more than five fields, this exception will be thrown. Let''s consider this piece
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the exception will occur in the log statement, as `arrayNum[5]` means
    the sixth element in the array, which does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mathematical expression can signify an undefined value, but in the programming
    aspect, "undefined" cannot be defined. Hence, `ArithmeticException` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an interpreter tries to divide any value by zero, then the result
    becomes undefined, which is thrown as an exception. The same result can be seen
    when calculating the value of tan 90°.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple case might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Input/output exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input/output functionality of a computing system depends on its hardware.
    However, in the case of gaming, an input/output exception occurs during a read/write
    operation. Most games are data driven. The basic principal is to feed data to
    the game software to control the elements in the game. This data is usually stored
    in a separate binary, text, XML, or JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Being separate files located at a particular path, these files can go missing,
    especially when those data files are downloaded from some other location, because
    there may be a connection interruption and the file may not get saved. In this
    case, when the game software tries to load such files, then `IOException` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Network exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the age of multiplayer gaming, which requires a mandatory network connection.
    An application thus depends on the quality and connectivity of the existing network
    connection. However, the mobile network connection state may change at any point
    in time. Often, game developers ignore network errors, which causes crashing,
    freezing, or some malfunctioning in the running of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly handled exceptions are `HttpRetryException`, `UnresolvedAddressException`,
    and `NetworkErrorException`. If any HTTP request cannot be retired automatically,
    then `HttpRetryException` is thrown. If an application wants to connect to a certain
    address and the address is not found, then `UnresolvedAddressException` is thrown.
    `NetworkErrorException` is used to handle any sort of network mishap such as network
    lost/dropped, a network using the wrong protocol, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Custom exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is typically used for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Gameplay exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game support tool exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gameplay might create a logical exception during runtime. However, there is
    small scope for this exception in game development. This is not practiced by most
    Android developers.
  prefs: []
  type: TYPE_NORMAL
- en: Tool programming is also an important part of the game development process.
    So, the possible exception should be handled by a custom exception if required.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging for Android while working with cross-platform engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern day game programming does not generally target a single platform. Most
    games are cross-platform. A cross-platform game engine is very useful for this
    kind of development.
  prefs: []
  type: TYPE_NORMAL
- en: Most engines come with a built-in profiler and provide some features to debug
    the game. However, the profiler feature is completely dependent on the manufacturer
    of the specific game engine.
  prefs: []
  type: TYPE_NORMAL
- en: All native platforms provide complete debug information. Game engines create
    a wrapper to automatically switch from one platform configuration to another and
    display profiler details within a common user interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, these cross-platform debug tools cost some extra processing and memory.
    In a way, they limit game resource consumption to a certain level with an error
    margin.
  prefs: []
  type: TYPE_NORMAL
- en: Best testing practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many standards used in the Android game development industry for testing.
    Testing ensures correctness, stability, functional behavior, and durability after
    an application is published. The most common approach for Android game testing
    is manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, this process is definitely not the best. As an Android developer, a
    unit test is always a best practice to save time and get accurate test results.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several tools and Android APIs that can be used to carry out the testing
    procedure. Some of them are inbuilt, such as Android Test Support Library, Dumpsys,
    Monkeyrunner, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these testing tools can be triggered through the command line and run
    through Android Debug Bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Monkey tools create a virtual environment to populate user actions such
    as click, touch, swipe and so on to determine real-time result. Monkey can be
    run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Dumpsys provides status of the system during the runtime of an Android application.
    This can be triggered through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Dumpsys is able to provide information on running services, input system, network
    status, RAM uses, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Testing techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mostly, two types of testing techniques are used in the game industry: automated
    testing and manual testing. We have already discussed the manual testing procedure
    in brief. Let''s have a look at automated testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing requires tools and extra programming effort. Game UI, memory
    consumption, network connectivity, and input system testing can be automated.
    A separate test runs on a simulator or on an actual device to determine the test
    result, and it is saved at a given location of the development system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit test code can be written to verify the logic of an individual module of
    a game. A unit test can be used for testing the smallest possible component of
    the application program, such as elements, classes, and methods. Unit tests are
    further categorized into two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Local test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumented test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of unit test works on a local machine and runs on the JVM. This saves
    a lot of testing time. A local test has either no dependency on the Android framework
    or limited dependency that can be satisfied with dummy objects.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumented test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instrumented tests have full dependency on the Android framework and must run
    on an Android emulator or on an Android device. This testing technique is used
    to test the runtime behavior of an Android game. It can provide all system and
    debug information of the running application. However, this technique cannot be
    used easily with dummy objects. The developer needs to define the testing object
    data before it can run the test in an Android environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any development process is incomplete without quality and performance assurance.
    Testing is the phase of development where the game needs to be verified technically
    and logically to see whether it can perform in the real market.
  prefs: []
  type: TYPE_NORMAL
- en: The phases of testing, debugging, and profiling the game ensures the best possible
    quality of the game for the targeted Android platform range. Often, an Android
    game works on few Android devices but not on all targeted devices. The developer
    can identify and resolve the issues for some specific devices through a detailed
    testing procedure.
  prefs: []
  type: TYPE_NORMAL
