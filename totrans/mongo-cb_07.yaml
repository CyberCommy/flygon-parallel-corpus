- en: Chapter 7. Deploying MongoDB on the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and managing the MongoLab account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a sandbox MongoDB instance on MongoLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations on MongoDB from MongoLab GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MongoDB on Amazon EC2 without AMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MongoDB using the Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though explaining cloud computing is not in the scope for this book, I will
    explain it in just one paragraph. Any business, big or small, needs hardware infrastructure
    with different software installed on it. An operating system is the basic software
    needed along with different servers (from the software perspective) for storage,
    mail, web, database, DNS, and so on. The list of software frameworks/platforms
    that are needed would end up being large. The point of interest here is that the
    initial budget for this hardware and software platform is high, and so we are
    not even considering the real estate needed to host it. This is where cloud computing
    providers such as Amazon, Rackspace, Google, and Microsoft come into play. They
    have hosted the high-end hardware and software in different data centers across
    the globe and let us choose from different configurations to start an instance.
    This is then accessed remotely over the public network for management purposes.
    Literally, all our setting up is done in the cloud provider's data center and
    we just pay as we use. Shut down the instance and you stop paying for it. Not
    only small start-ups, but large enterprises often temporarily fall back to cloud
    servers for temporary rise in the computing resource demands. The prices offered
    by the providers are very competitive too, particularly AWS, and its popularity
    says it all.
  prefs: []
  type: TYPE_NORMAL
- en: The wiki page, [http://en.wikipedia.org/wiki/Cloud_computing](http://en.wikipedia.org/wiki/Cloud_computing),
    has a lot of details, perhaps a bit too much for someone new to the concept, but
    is a good read nevertheless. The article at [http://computer.howstuffworks.com/cloud-computing/cloud-computing.htm](http://computer.howstuffworks.com/cloud-computing/cloud-computing.htm)
    is pretty good and also recommended for you to read if you are not aware of the
    concept of cloud computing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will set up MongoDB instances on the cloud using MongoDB
    service providers and then by ourselves on **Amazon Web Service** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and managing the MongoLab account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will evaluate one of the vendors, MongoLab, that provides
    MongoDB as a service. This introductory recipe will introduce to you what MongoDB
    as a service is and then will demonstrate how to set up and manage an account
    in MongoLab ([https://mongolab.com/](https://mongolab.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: In all the recipes in the book so far, we have covered setting up, administering,
    monitoring, and developing the instances of MongoDB in the organizational/personal
    premises. This not only needs manpower with the appropriate skill set to manage
    the deployments, but also appropriate hardware to install and run Mongo servers.
    This needs large investments up front that might not be a viable solution for
    start-ups or even organizations who are not clear on adopting or migrating to
    this technology. They might want to evaluate it and see how it goes before moving
    full-fledged to this solution. What would be ideal is to have a service provider
    who takes care of hosting the MongoDB deployments, managing and monitoring the
    deployments, and providing support. The organizations opting for these services
    need not invest up front to set up the servers or recruit or outsource to consultants
    for the administration and monitoring of the instances. All that one needs to
    do is choose the hardware and software platforms and configurations and an appropriate
    MongoDB version, and then set up an environment from a user-friendly GUI. It even
    gives you an option to use your existing cloud provider's servers.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in brief what these vendor hosting services do and why they are needed;
    we will start this recipe by setting up an account with MongoLab and see some
    basic user and account management. MongoLab is by no means the only hosting provider
    for MongoDB. You can also look at [http://www.mongohq.com/](http://www.mongohq.com/)
    and [http://www.objectrocket.com/](http://www.objectrocket.com/). At the time
    of writing this book, MongoDB themselves started providing MongoDB as a service
    on the Azure cloud and is currently in the beta phase.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visit [https://mongolab.com/signup/](https://mongolab.com/signup/) to sign up
    if you don't have an account created; just fill in the relevant details and create
    one account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the account has been created, click on the **Account** link in the top
    right corner:![How to do it…](img/B04831_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Account Users** tab at the top; it should be selected by default:![How
    to do it…](img/B04831_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a new account, click on the **+ Add account user** button. One pop-up
    window will ask for the username, e-mail ID, and password. Enter the relevant
    details and click on the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the user, and you should be navigated to a page where you can change
    the username, e-mail ID, and password. You can transfer the administrative rights
    to the user by clicking on the **Change to admin** button on this screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, by clicking on your own user details, you have the option to change
    the username, e-mail ID, and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Set up two-factor authentication** button to activate the multifactor
    authentication using Google Authenticator. You need to have the Google Authenticator
    installed on your Android, iOS, or BlackBerry phone to proceed with the setting
    up of multifactor authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On clicking the button, we should see the QR code that can be scanned using
    Google Authenticator or, if scanning is not possible, click on the URL underneath
    the QR code, which should show the code. Set up a time-based account in the Google
    Authenticator manually. There are two types of Google Authenticator accounts,
    time-based and counter-based.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [http://en.wikipedia.org/wiki/Google_Authenticator](http://en.wikipedia.org/wiki/Google_Authenticator)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can delete users from the accounts page by clicking on the cross
    next to the user's row in **Account Users**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is not much to explain in this section. The setup process and user administration
    is pretty simple. Note that the users that we added here are not database users.
    These are the users that have access to the MongoLab account. **Account** can
    be the name of the organization and can be seen at the top of the screen. The
    multifactor authentication account setup in the Google Authenticator software
    on the handheld device should not be deleted as whenever the user logs in to the
    MongoLab account from the browser, he will be asked to enter the Google Authenticator
    account to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a sandbox MongoDB instance on MongoLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to set up an account on MongoLab and add
    users to the account. We still haven't seen how to fire up an instance on the
    cloud and use it to perform some simple operations. In this recipe, this is exactly
    what we will do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Setting up and managing MongoLab account*, to
    set up an account with MongoLab. We will set up a free sandbox instance. We will
    require some way to connect to this started `mongo` instance and thus will need
    a mongo shell that comes only with the complete mongo installation or you can
    choose to use a programming language of your choice in order to connect to the
    started `mongo` instance. Refer to [Chapter 3](ch03.html "Chapter 3. Programming
    Language Drivers"), *Programming Language Drivers* for recipes on connecting and
    performing operations using a Java or Python client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the home page, [https://mongolab.com/home](https://mongolab.com/home),
    and click on the **Create new** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cloud provider, for this example, we choose Amazon Web Services (AWS):![How
    to do it…](img/B04831_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Single-node (development)** and then, the **Sandbox** options.
    Do not change the location of the cloud server as the free sandbox instance is
    not available in all data centers. As this is a sandbox, we are okay with any
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add any name for your database; the name that I chose is `mongolab-test`. Click
    on **Create new MongoDB deployment** after entering the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should take you to the home page, and the database should now be visible.
    Click on the instance name. The page here shows the details of the MongoDB instance
    selected. The instruction to connect in the shell or programming language is given
    at the top of the page along with the public hostname of the started instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Users** tab and then the **Add database user** button. In the
    pop-up window, add the username and password as `testUser` and `testUser`, respectively
    (or any of your choice).![How to do it…](img/B04831_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the user added, start the mongo shell as follows, assuming that the name
    of the database is `mongolab-test` and the username and password is `testUser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On connecting, execute the following in the shell and check whether the database
    name is `mongolab-test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert one document in a collection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Query the collection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps executed are very simple, and we created one shared sandbox instance
    in the cloud. MongoLab themselves do not host the instances but use one of the
    cloud providers to do the hosting. MongoLab does not support sandbox instances
    for all providers. The storage with the sandbox instance is 0.5 GB and is shared
    with other instances on the same machine. Shared instances are cheaper than running
    on a dedicated instance but the price is paid in performance. The CPU and IO is
    shared with other instances and thus the performance of our shared instance is
    not necessarily in our control. For a production use case, a shared instance is
    not a recommended option. Similarly, we need to set up a replica set when running
    in production. If we look at the image in step 2, then we see another tab next
    to the **Single-node (development)** option. This is where you can choose the
    configuration for the machine in terms of RAM and disk capacity (and the price
    as well) and set up a replica set.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04831_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, you get to choose the version of MongoDB to use. Even if a new
    version of MongoDB gets released, MongoLab will not start supporting it immediately
    as they usually wait for a few minor versions to be rolled out before supporting
    them for production users. Additionally, when we choose a configuration, the default
    available option is two data nodes and one arbiter, which is sufficient for a
    majority of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The RAM and disk chosen depend completely on the nature of the data and how
    query- intensive or write-intensive it is. This sizing is something that we do
    irrespective of whether we are deploying on our own infrastructure or the cloud.
    The working set is something that is important to be known before we choose the
    RAM of the hardware. Proofing of concepts and experiments are done to deal with
    a subset of data and then the estimation can be done for the entire dataset. If
    IO activity is high and low IO latency is desired, you can even opt for SSD, as
    shown in the preceding image. Standalone instances are as good as replica sets
    in terms of scalability except for availability. Thus, we can choose standalone
    instances for such estimation and development purposes. Shared instances, both
    free and paid, are good candidates for development purposes. Note that shared
    instances cannot be restarted on demand as we can for dedicated instances.
  prefs: []
  type: TYPE_NORMAL
- en: What cloud provider do we choose? If you already have your application servers
    deployed in the cloud, then obviously it has to be the same vendor as your existing
    vendor. It is recommended that you use the same cloud vendor for the application
    server and database, and see that they are both deployed on the same location
    in order to minimize latency and improve on performance. If you are starting fresh,
    then invest some time in choosing the cloud provider. Look at all the other services
    that the application would need, such as the storage, compute, other services
    such as mail, notification services, and so on. All this analysis is outside the
    scope of this book, but once you are done with this and finalized with a provider,
    you can choose the provider to use accordingly in MongoLab. As far as the pricing
    goes, all the leading providers offer competitive pricing.
  prefs: []
  type: TYPE_NORMAL
- en: Performing operations on MongoDB from MongoLab GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to set up a simple sandbox instance for MongoDB
    in the cloud using MongoLab. In this recipe, we build on it and see what services
    MongoLab provides you with, from the management, administrative, monitoring, and
    backups perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Setting up a sandbox MongoDB instance on MongoLab*,
    on how to set up a sandbox instance in the cloud using MongoLab.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to [https://mongolab.com/home](https://mongolab.com/home); you should see
    the list of databases, servers, and clusters. If you have followed the last recipe,
    you should see one standalone database, `mongolab-test` (or whatever name you
    chose for the database). Click on the database name, which should take you to
    the database details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking on the **Collections** tab, which should be selected by default,
    we should see the list of collections present in the database. If the previous
    recipe was executed before this one, you should see one collection, messages,
    in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the name of the collection and we should get navigated to the collection
    details page as follows:![How to do it…](img/B04831_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Stats** option to view the stats of the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Documents** tab, we can query the collection. By default, we see all
    the documents with 10 documents shown per page, which can be changed from the
    records/page drop-down menu. A maximum value of 100 can be chosen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is another way to view the documents, as a table. Click on the **table**
    radio button in the **Display** mode and click on the link to create/edit table
    view. In the popup that is shown, enter the following document for the messages
    collection and click on **Submit**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On doing this, the display will change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04831_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the **--Start new search--** dropdown, select the **[new search]** option,
    as shown in the following image:![How to do it…](img/B04831_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new query, we see the following fields that let us enter the query
    string, sort order, and projections. Enter the query as `{"_id":1}` and fields
    as `{"message":1, "_id":0}`:![How to do it…](img/B04831_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose to save the query by clicking on the **Save this search** button
    and giving a name to the query to be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Individual documents can be deleted by clicking on the cross next to each record.
    Similarly, the **Delete all** button at the top will delete all the contents of
    the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, clicking on **+ Add document** will pop up an editor to type in the
    document that would be inserted into the collection. As MongoDB is schemaless,
    the document need not have a fixed set of fields; the application should make
    sense out of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `https://mongolab.com/databases/<your database name> (mongolab-test`,
    in this case), which can also be reached by clicking on the database name from
    the home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Stats** tab next to the **Users** tab. The content shown here
    in the table is the result of the `db.stats()` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, click on the **Backups** tab at the top next to the **Stats** tab.
    Here, we have options to take a recurring or one-time backup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on **Schedule recurring backup**, you get a pop-up window that
    lets you enter the details of the scheduling, such as the frequency of the backup,
    time of the day when the backup needs to be taken, and the number of backups to
    keep.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The backup location can be chosen as either MongoLab's own S3 bucket or the
    Rackspace cloud file. You can choose to use your own account's storage, in which
    case you will have to share the AWS access key/secret key or UserID/API key in
    case of Rackspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steps 1 to 5 are pretty straightforward. In step 6, we provided a JSON document
    to show the results in a tabular format. The format of the document is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is the name of the column to display and the value of the name of the
    field in the actual document whose value will be shown as the value of this column.
    To get a clear understanding, look at the document defined for the messages collection,
    and then take a look at the displayed tabular data. The following is the JSON
    document that we provided, which states the name of the column as the value of
    the key and the actual field in the document as the value of the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the field name and values of the JSON documents here are enclosed
    in quotes. The Mongo shell is lenient in this sense, where it allows us to give
    field names without quotes.
  prefs: []
  type: TYPE_NORMAL
- en: If we visit step 16 about backups, we see that the backups are stored either
    in MongoLab's AWS S3/Rackspace cloud file or your custom AWS S3 bucket /Rackspace
    cloud files. In the latter cases, you need to share your AWS/Rackspace credentials
    with MongoLab. If this is a concern and the credentials can potentially be used
    to access other resources, it is recommended that you create a separate account
    and use it for backup purposes from MongoLab. You can also use the backup created
    to create a new MongoDB server instance from MongoLab. Needless to say, if you
    have used your own AWS S3 bucket/Rackspace cloud files, storage charges are additional
    as they are not a part of MongoLab's charges.
  prefs: []
  type: TYPE_NORMAL
- en: There are some important points worth mentioning. MongoLab provides a REST API
    for various operations. The REST API can be used in place of the standard drivers
    to perform CRUD operations; however, using MongoDB client libraries is the recommended
    approach. One good reason to use the REST API right now over a language driver
    is if the client is connecting to the MongoDB server over a public network. The
    shell that we started on our local machine connecting to the MongoDB server on
    the cloud sends unencrypted data to the server, which makes it vulnerable. On
    the other hand, if REST APIs are used, the traffic is sent over a secure channel
    as HTTPS is used. MongoLab plans to support a secure channel for the communication
    between the client and server in future, but as of the writing of this book, this
    is not available. If the application and database are in the same data center
    of the cloud provider, you are safe and can depend on the security provided by
    the cloud provider for their local network, which generally is not a concern.
    However, there is nothing that you can do for secure communication other than
    ensuring that your data doesn't go over public networks.
  prefs: []
  type: TYPE_NORMAL
- en: One more scenario where MongoLab doesn't work is when you want the instances
    to be running on your own instance of a virtual machine rather than one chosen
    by MongoLab or we want the application to be in a virtual private cloud. Cloud
    providers do provide services such as Amazon VPC, where part of the AWS cloud
    can be treated as a part of your network. If you intend to deploy your MongoDB
    instance in such an environment, MongoLab cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB on Amazon EC2 manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous few recipes, we saw how to start MongoDB in the cloud using
    a hosted service provided by MongoLab that gave an alternative to set up MongoDB
    on all the leading cloud vendors. However, if we plan to host and monitor the
    instance ourselves for greater control or set up within our own virtual private
    cloud, we can do it ourselves. Though the procedure varies from cloud provider
    to provider, we will be demonstrating it using AWS. There are a couple of ways
    to do it, but in this recipe, we will use **Amazon Machine Image** (**AMI**).
    AMI is a template containing details such as the operating system, software that
    would be available on the started virtual machine, and so on. All this information
    would be used while booting up a new virtual machine instance on the cloud. To
    know more about AMI, refer to [http://en.wikipedia.org/wiki/Amazon_Machine_Image](http://en.wikipedia.org/wiki/Amazon_Machine_Image).
  prefs: []
  type: TYPE_NORMAL
- en: Talking about AWS EC2, which stands for Elastic Cloud Compute, it is a service
    that lets you create, start, and stop servers of different configurations in the
    cloud running on operating systems of your choice. (The prices differ accordingly.)
    Similarly, Amazon **Elastic Block Store** (**EBS**) is a service that provides
    persistent block storage with high availability and low latency. Initially, each
    instance has a store known as an ephemeral store attached to it. This is a temporary
    store and the data might be lost when the instance restarts. The EBS block storage
    is thus attached to the EC2 instance to maintain persistence even when the instance
    is stopped and then restarted. Standard EBS does not provide guaranteed minimum
    **IO operations per second** (**IOPS**). For a moderate workload, the default
    of about 100 IOPS is okay. However, for a high performance IO, EBS blocks with
    guaranteed IOPS are also available. The pricing is more as compared to the standard
    EBS block but is a good option to opt for if a low IO rate can be a bottleneck
    in the performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up a small micro instance that is good enough as
    a sandbox instance with one EBS block volume attached.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that you need to do is sign up for an AWS account. Visit [http://aws.amazon.com/](http://aws.amazon.com/)
    and click on **Sign up**. Log in if you have an Amazon account, or else, create
    a new one. You will have to give your credit card details although the recipes
    that we have here will use the free micro instance unless we explicitly mention
    otherwise. We will connect to the instance on the cloud using Putty. You can download
    Putty and install it on your machine if it is not already installed. It can be
    downloaded from [http://www.putty.org/](http://www.putty.org/).
  prefs: []
  type: TYPE_NORMAL
- en: For this specific recipe for the installation using AMI, we cannot use the micro
    instance and will have to use the Standard Large. You can get more details about
    the pricing of the EC2 instances in different regions at [https://aws.amazon.com/ec2/pricing/](https://aws.amazon.com/ec2/pricing/).
    Choose the appropriate region based on the geographical and financial factors.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that you need to do is create a key pair in case you have not
    created one already. The following steps from 1 to 5 are only to create the key
    pair. This key pair will be used to log in to the Unix instance started in the
    cloud from the Putty client. Skip to step 6 if the key pair has already been created
    and the `.pem` file is available for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to [https://console.aws.amazon.com/ec2/](https://console.aws.amazon.com/ec2/)
    and make sure that the region you have on the top right (as shown in the following
    image) is the same as the one in which you are planning to set up the instance.![Getting
    ready](img/B04831_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the region is selected, the page with the **Resources** heading will show
    you all the instances, key pairs, IP addresses, and so on for this region. Click
    on the **Key Pairs** link, which should direct you to the page where all the existing
    key pairs will be shown and you can create new ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create Key Pair** button, and in the pop-up window, type any
    name of your choice. Let's say that we call it `EC2 Test Key Pair`, and then click
    on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once created, a `.pem` file will be generated. Ensure that the file is saved
    as this would be needed for subsequent access to the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will next convert this `.pem` file to a `.ppk` file to be used with Putty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start puttygen; if it is not available already, it can be downloaded from [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04831_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the **SSH-2 RSA** option and click on the **Load** button. In the file
    dialog, select **All files** and then select the `.pem` file that was downloaded
    with the key pair, which was generated in the EC2 console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `.pem` file is imported, click the **Save private key** option and
    save the file with any name; the file this time is a `.ppk` file. Save this file
    for future logging in to the EC2 instance from putty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Mac OS X or Linux, you can use the `ssh-keygen` utility to
    generate the SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to [https://console.aws.amazon.com/ec2/](https://console.aws.amazon.com/ec2/)
    and click on the **Instances** option on the left and then the **Launch Instance**
    button:![How to do it…](img/B04831_07_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we want to start a free micro instance, check the **Free tier only** checkbox
    on the left. On the right-hand side, select the instance that we want to set up.
    We choose to use the **Ubuntu server**. Click on **Select** to navigate to the
    next window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the micro instance and click on **Review and Launch**. Ignore the security
    warning; the default security group that you will have is the one that will accept
    connections over port 22 from all the hosts on a public network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without editing any default settings, click on **Launch**. Upon launch, a popup
    will appear that lets you choose an existing key pair. If you proceed without
    a key pair, you will need the password or need to create a new key pair. In the
    previous recipe, we already created a key pair, which is what we will use here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Launch Instance** to start the new micro instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to steps 9 to 12 in the previous recipe on how to connect to the started
    instance using Putty. Note that we will be using the Ubuntu user instead of `ec2-user`,
    which we used in the last recipe, as this time, we are using Ubuntu instead of
    Amazon Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we add a MongoDB repository, we need to import the MongoDB public key
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command in the operating system shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the local database by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command to create the required directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the `mongod` process as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the server process is up and running, execute the following
    command in the shell and we should see the following in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the mongo shell as follows and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of steps are self-explanatory. It is recommended that you at least go
    through the previous recipe as a lot of concepts are explained there. Most concepts
    explained in the preceding recipe apply here. A few things that are different
    are explained in this section. For the installation, we chose Ubuntu as against
    Amazon Linux, which is the standard when you set up the server using AMI. Different
    operating systems have different steps for installation. Refer to [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/)
    for steps on how to install MongoDB on different platforms. Steps 7 to 9 in this
    recipe are specific for the installation of MongoDB on Ubuntu. Refer to [https://help.ubuntu.com/12.04/serverguide/apt-get.html](https://help.ubuntu.com/12.04/serverguide/apt-get.html)
    for more details on the `apt-get` command that we executed here to install MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we chose to have the data, journal, and log folder on the same
    EBS volume. This is because what we set up is a `dev` instance. In case of a `prod`
    instance, there are different EBS volumes with provisioned IOPS for optimum performance.
    This setup allows us to gain advantage of the fact that these different volumes
    have different controllers and thus concurrent write operations are possible.
    EBS volumes with provisioned volumes are backed by the SSD drives. The production
    deployment notes at [http://docs.mongodb.org/manual/administration/production-notes/](http://docs.mongodb.org/manual/administration/production-notes/)
    states that MongoDB deployment should be backed by the RAID-10 disks. When deploying
    on AWS, prefer PIOPS over RAID-10\. For instance, if 4000 IOPS is desired, then
    choose an EBS volume with 4000 IOPS rather than a RAID-10 setup with a 2 X 2000
    IOPS or 4 X 1000 IOPS setup. This not only eliminates unnecessary complexity,
    but also makes snapshotting a single disk possible as against dealing with multiple
    disks in a RAID-10 setup. Speaking of snapshotting, the journal log and data are
    written to separate volumes in majority of the production deployments. This is
    the scenario where snapshotting doesn't work. We need to flush the DB writes,
    lock the data for further writes until the backup is complete, and then release
    the lock. Refer to [http://docs.mongodb.org/manual/tutorial/backup-with-filesystem-snapshots/](http://docs.mongodb.org/manual/tutorial/backup-with-filesystem-snapshots/)
    for more details on snapshottiing and backups.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://docs.mongodb.org/ecosystem/platforms/](http://docs.mongodb.org/ecosystem/platforms/)
    for more details on deployment on different cloud providers. There is a section
    specifically for backups on the Amazon EC2 instances. Prefer using AMIs to set
    up the MongoDB instances for production deployments as demonstrated in the previous
    recipe over manually setting up the instances. A manual setup is okay for small
    development purposes, where a large instance with EBS volumes with provisioned
    IOPS is an overkill.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud formation is a way where you can define templates and automate your instance
    creation for the EC2 instances. You can know more what cloud formation is at [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/)
    and refer to [https://mongodb-documentation.readthedocs.org/en/latest/ecosystem/tutorial/automate-deployment-with-cloudformation.html](https://mongodb-documentation.readthedocs.org/en/latest/ecosystem/tutorial/automate-deployment-with-cloudformation.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another alternative is using Mongo''s cloud service: [https://docs.cloud.mongodb.com/tutorial/nav/add-servers-through-aws-integration/](https://docs.cloud.mongodb.com/tutorial/nav/add-servers-through-aws-integration/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can know more on RAID by referring to these two URLs on Wikipedia: [http://en.wikipedia.org/wiki/Standard_RAID_levels](http://en.wikipedia.org/wiki/Standard_RAID_levels)
    and [http://en.wikipedia.org/wiki/Nested_RAID_levels](http://en.wikipedia.org/wiki/Nested_RAID_levels).
    The description given here is quite comprehensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up MongoDB using the Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The container movement, as I like to call it, has touched almost all the aspects
    of information technology. Docker, being the tool of choice, is integral to the
    creating and managing of containers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will install Docker on the Ubuntu (14.04) server and run
    MongoDB in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install Docker on our Ubuntu server, which can be done by
    running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Docker service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that Docker is running as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetch the default MongoDB image from Docker Hub as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s confirm that the images are installed with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the MongoDB server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, you can also run the `docker ps` command to check the list of running
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the IP of this container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to our new container using the mongo client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a directory on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new MongoDB container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the IP of this new container as mentioned in Step 4, and connect using
    the Mongo client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make another directory for our final container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a new MongoDB container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s connect to this container via localhost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by downloading the default MongoDB image from DockerHub ([https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/)).
    A Docker image is a self-sustaining OS image that is customized for the application
    that it is supposed to run. All Docker containers are isolated executions of these
    images. This is very similar to how an OS template is used to create virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: The image download operation defaults to fetching the latest stable MongoDB
    image, but you can specify your version of choice by mentioning the tag, for example,
    `docker pull mongo:2.8`.
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the image was downloaded by running the `docker images` command,
    which will list all the images installed on the server. In step 3, we start a
    container in the detached (`-d`) mode with the name, `mongo-server-1`, using our
    mongo image. Describing the container internals may be out of the scope of this
    cookbook, but, in short, we now have an isolated `docker pseudo-sever` running
    inside our Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: By default, each Docker container gets an RFC 1918 (non-routable) IP address
    space assigned by the docker server. In order to connect to this container, we
    fetch the IP address in step 4 and connect to the `mongodb` instance in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: However, each Docker container is ephemeral and hence, destroying the container
    would mean losing the data. In step 6, we create a local directory that can be
    used to store our mongo database. We start a new container in step 7; it is similar
    to our earlier command with the addition of the Volumes (`-v`) switch. In our
    example, we are exposing the `/data/db2` directory to the mongo container namespace
    as `/data/db`. This is similar to NFS-like file mounting but within the confines
    of the kernel namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we want external systems to connect to this container, we bind the
    container's ports to that of the host machine. In step 9, we use the Port (-p)
    switch to bind the TCP `9999` port on the Ubuntu server to TCP `27017` of this
    container. This ensures that any external systems connecting to the server's port
    `9999` will be routed to this particular container.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also try to link two containers using the Link (`-l`) command line parameter
    of the docker command.
  prefs: []
  type: TYPE_NORMAL
- en: For more information visit [http://docs.docker.com/userguide/dockerlinks/](http://docs.docker.com/userguide/dockerlinks/).
  prefs: []
  type: TYPE_NORMAL
