- en: Deciphering Error Messages and Performance Leaks
  prefs: []
  type: TYPE_NORMAL
- en: Of course, no good language is complete without a means to detect and diagnose
    problems in your code. JavaScript provides rich error messages that are incredibly
    powerful and intuitive, but there are a few caveats and tips as you tiptoe through
    bug-ridden code.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know, finding a problem in your own code (a "bug") is one of
    the most frustrating events to occur to a developer. We pride ourselves on our
    code's ability to do its task, but sometimes we don't account for edge and corner
    cases. Additionally, error messages give us important information as we're in
    the process of coding by giving us important diagnostic information. Luckily,
    there are tools that can help us understand what's going on in our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Error object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debuggers and other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accommodating JavaScript's performance limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be prepared to work through the `Chapter-9` examples from GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-9/](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-9/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be working with the developer tools in the browser, and for the purposes
    of illustration, the instructions and screenshots will be from Google Chrome.
    If you're familiar with tools in another browser, however, the concepts are similar.
    You may also want to have a JSON parsing extension added to Chrome if you haven't
    already done so.
  prefs: []
  type: TYPE_NORMAL
- en: There are no specific hardware requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Error object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-9/error-object](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-9/error-object).
    Open the `index.html` file and examine the JavaScript console. The first function,
    `typoError`, is invoked and throws a wonderful error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4597e545-02f8-409c-9027-fb7668083c61.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 - Error console
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for our function in `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'OK! It''s a simple typo, as we''ve all done: it should be `console.error` instead
    of `cnosole.error`. If you''ve never made a typo in code… you''re a unicorn. The
    error message we see in the console makes it easy to see what the error is and
    on what line of code it lives: line 2\. Now, something interesting to note is
    that after calling `typoError()` toward the end of the file, we also have an invocation
    to another function *but it doesn''t fire.* We know this because (spoiler alert)
    it also throws errors, but we don''t see them. An Uncaught ReferenceError is a
    **blocking error**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, some errors, called blocking errors, will halt the execution
    of the code. Others, called **non-blocking errors**, are mitigated in such a way
    that the code can continue to execute even if the problem isn''t resolved. There
    are a few ways of dealing with errors, and you should do so when faced with potential
    vectors for errors. Do you remember [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml),
    *Events, Event-Driven Design, and APIs*, where we used a `.catch()` block in our
    `fetch()` call to gracefully handle Ajax errors? The same principle applies here.
    This is obviously a very contrived example, but let''s go ahead and mitigate our
    error, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using a `try/catch` block for a typo is overkill, but let's pretend it was something
    more serious, such as an asynchronous call or a dependency from another library.
    If we take a look at our console output now, we'll see that our second function,
    `fetchAttempt`, has fired and it is also producing errors. Open the `index-mitigated.js`
    file and the accompanying `index-mitigated.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see this in the console of `index-mitigated.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ebf1d3e2-50a3-4680-b6fa-0ed70f4143c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 - Non-blocking error
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that our code does not stop at the typo; we''ve made it into a
    non-blocking error with our try/catch. We see that our `fetchAttempt` function
    is firing and giving us a different kind of error: `404 Not Found`. Since we entered
    a non-existent URL (ending in `undefined` on purpose), we receive another error
    after that: a `SyntaxError` from our promise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this error may be difficult to understand, as it is explicitly
    talking about an unexpected character in the JSON. In [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml),
    *Events, Event-Driven Design, and APIs,* we worked with the Star Wars API: `https://swapi.dev/`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the JSON of the example response from `https://swapi.dev/api/people/1/`.
    This could be a good time to ensure you have a JSON parsing extension in your
    browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/deb08f36-98ab-4536-86c9-fef988c42ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 - JSON from https://swapi.dev/api/people/1/
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s well-formed JSON, so even though our error specifies Syntax Error, it''s
    not actually the syntax of the response data that''s the problem. We''ll need
    to look deeper. Let''s look at what we''re getting from our `fetchAttempt` call
    in the Chrome JavaScript debugger. Let''s click the link for the second error
    in our code here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/dca8ad30-ba0b-4013-a321-232dbe29b63b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 - Following the trail of the 404...
  prefs: []
  type: TYPE_NORMAL
- en: 'We then see this panel, with the red squiggly underlines and red markers to
    indicate errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2cff2d02-d8e7-4831-b252-eba0e743201d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 - Errors in the debugger
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. If you hover over the red X on line 20, the tooltip advises
    us of the 404 error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Network tab. This tool tracks incoming and outbound HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the call named undefined and then into the Headers panel, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/be0217f8-ae58-43b4-901c-2c96ba1fdfb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 - The Headers tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Aha! Now we see what the problem is: the JSON error is helpful, but steered
    us in the wrong direction. The error isn''t with the JSON itself, but rather,
    the error means that the response *isn''t JSON at all*! It is an HTML 404 error,
    so there is no JSON data. Our problem is confirmed to be in the URL fetching a
    non-existent address, and so an error page is rendered, which makes no sense to
    the JSON parser of `fetch`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's spend some more time with debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using debuggers and other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web developers choose to use Google Chrome as their browser of choice as
    it provides a wealth of developer tools out of the box. If Chrome is not your
    browser of choice, here are a few browsers that have developer tools that are
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: Safari
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Safari ships with developer mode off by default, so if you use Safari, toggle
    the Develop menu in the Advanced pane in the preferences at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/55a1a874-2b1b-403b-85de-b7e8d75fa686.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 - Adding the Develop Menu to Safari
  prefs: []
  type: TYPE_NORMAL
- en: Now, you'll have a Develop menu with tools that may render error messages slightly
    differently than Chrome, but that are still accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer and Microsoft Edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all sincerity and only a little bit of prejudice, I would recommend *not*
    using Internet Explorer or Microsoft Edge for JavaScript development. It is important
    to test your code cross-browser, but I find the developer tools provided in IE
    and Edge to be lacking. For example, let''s take a look at the exact same page
    in Edge''s developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0f6bef7a-8ab0-40ac-9750-869749e6bb52.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 - Edge JavaScript Console
  prefs: []
  type: TYPE_NORMAL
- en: Even though we mitigated our error with a try/catch block, Edge still treats
    the typo as a blocking error. There are other idiosyncrasies of the Microsoft
    browsers as well, which date back to the browser wars we learned about before,
    so a good rule of thumb is to develop in Chrome and then test in a Microsoft browser
    to ensure cross-browser compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: While there are development tools in all major browsers, the examples used here
    will be from Chrome. Let's take a closer look at the JavaScript console itself.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The console is not only a place to see errors but it can be used to execute
    code as well. This is useful for quick debugging, especially on a page that may
    have another library of code incorporated within it. The console has *scope* to
    all JavaScript loaded on the page, as long as it's accessible from the top-level
    `window` object. We wouldn't expect to have access to a function's internal variables,
    but if the browser can access the data, we can access it in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `fetch.html` and `fetch.js` files in the `debugger` folder and take
    a look. Here''s the `fetch.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a bare-bones `fetch` request with the URL to be fetched as a parameter
    to our function. In the console of our HTML page, we can actually execute this
    function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2fc08cba-7e2f-4d1a-ba78-fd9ff7195646.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 - Executing code in the console
  prefs: []
  type: TYPE_NORMAL
- en: As you typed in `fetchAttempt('http://httpstat.us/500')`, did you notice that
    the console gave you autocomplete code hints? This is another useful tool for
    determining whether you have access to the functions and variables at the level
    at which you are working. Now we see that we can execute code in the console without
    having to alter our JavaScript file. What did we learn from our console? Our `data.status`
    was indeed `500`, so we threw the console error from line 7\. From line 9, we
    got our response data, which explicitly states `500`. It may go without saying
    but the `console.log`, `console.error`, and `console.info` functions can be invaluable
    as you debug JavaScript. Use them frequently, but do remember to remove them before
    pushing your code to a production-level environment, as they can degrade site
    performance if you log large objects or log too frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tricky things about JavaScript is that you may be dealing with hundreds
    of lines of code, sometimes from a third party. Luckily, the tooling of most browsers
    allows setting *breakpoints* in the code, which halt the execution of the code
    at specified points. Let''s take a look at our previous file in the console and
    set a few breakpoints. If we click the error for line 7, the Sources panel is
    displayed. If you click a line number, you will set a breakpoint, as so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b98499a-4057-4475-91fe-8b2d90b2cf9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 - Note the arrow marker on line 6
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s often useful to set breakpoints before the line on which the browser
    complained in order to more thoroughly trace through the variables being passed
    to our code. Let''s run our code again with a page refresh and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Set breakpoints on lines 6 and 7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the console and execute our previous command: `fetchAttempt(''http://httpstat.us/500'')`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The browser will pull up the Sources tab again and we should see something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/94a2092e-2886-47e6-95b1-64569f3d69ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 - Result of the breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that in the Scope tab, we get a listing of the variables defined
    in the context within which we are executing code. If we then use the Step button,
    as shown in the screenshot, we can keep moving through our breakpoints and execute
    subsequent lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f193063-65a3-4dc1-a12c-b71bf1e23a1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 - The Step button
  prefs: []
  type: TYPE_NORMAL
- en: As we step through the breakpoints, the Scope panel will update to show our
    current context, which gives us more information than an explicit `console.log`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look now at some ideas for how to improve your JavaScript code
    for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Accommodating JavaScript's performance limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any language, there are ways to write JavaScript and better ways to
    write it. What is not as obvious in other languages, however, is the direct implications
    of your code for the user experience of a website. Complicated, inefficient code
    can clog up a browser, eat CPU cycles, and, in some cases, even crash the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this simple four-line snippet by Talon Bragg from [https://hackernoon.com/crashing-the-browser-7d540beb0478](https://hackernoon.com/crashing-the-browser-7d540beb0478):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning**: do *not* attempt to run this in a browser! If you''re curious
    about what this does, it will eventually create an out-of-memory exception in
    the browser that will kill the tab with a message that the page has become unresponsive.
    Why is this? Our `while` loop has a simple truthy value for its condition, so
    it will continue adding `"a"` to the string text until the memory allocated to
    that browser process is exhausted. Depending on the behavior of your browser,
    it may crash the tab, the whole browser, or worse. We all have experience with
    unstable programs (the Windows Blue Screen of Death, anyone?) but a browser failure
    can usually be avoided. Apart from coding best practices, such as minimizing loops
    and avoiding reassigning variables, there are ideas specific to JavaScript to
    point out. W3Schools has a few examples that are handy at [https://www.w3schools.com/js/js_performance.asp](https://www.w3schools.com/js/js_performance.asp)
    and I''d like to underscore one specifically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most memory-intensive operations in a standard JavaScript application
    is DOM access. A line as simple as `document.getElementById("helloWorld")` is
    actually a fairly expensive operation. As a best practice, if you''re going to
    use a DOM element more than once in your code, you should save it to a variable
    and act on that variable instead of going back to DOM traversal. If you think
    back to [Chapter 6](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml): *The Document
    Object Model (DOM)*, we stored the sticky note DOM element as a variable: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-6/stickies/solution-code/script.js#L13](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-6/stickies/solution-code/script.js#L13).'
  prefs: []
  type: TYPE_NORMAL
- en: The Memory panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without getting into too much detail about how computers allocate memory, suffice
    it to say that an improperly written program can cause a memory leak by not properly
    releasing and recycling memory, which can cause the program to crash. As opposed
    to some lower-level languages, JavaScript is supposed to automatically garbage
    collect: the practice of automatic memory management that releases memory by destroying
    unneeded pieces of data. However, there are cases when improperly written code
    can cause a memory leak that garbage collection doesn''t handle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since JavaScript runs client-side, it can be hard to decipher exactly what''s
    going on in your program. Luckily, there are tools to help. Let''s work through
    an example of a program that will allocate a lot of memory. Take a look at this
    example: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-9/memory-leak/index.html.](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-9/memory-leak/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the included JavaScript file, you''ll see it''s very simple,
    yet very powerful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect our code and see what happens when we work with this simple
    script. Note that some of these instructions may be different depending on your
    browser and OS version:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `index.html` page in Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the More tools menu, select Performance monitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eb551f2d-5a1e-483e-b680-3d3a26ad2734.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 - Investigating the Performance monitor
  prefs: []
  type: TYPE_NORMAL
- en: You will see a panel with a moving timeline: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-9/memory-leak/memory-leak.gif.](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-9/memory-leak/memory-leak.gif)
  prefs: []
  type: TYPE_NORMAL
- en: Now, click the Grow button several times. You should see an increase in the
    JavaScript heap size, perhaps to the 13 MB range. However, as you keep clicking,
    the heap size shouldn't increase past where it already is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is this? In modern browsers, it's actually gotten a little more difficult
    to accidentally create a memory leak. In this case, Chrome is smart enough to
    do some trickery with memory and not cause a large increase in memory as we repeat
    the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, now start clicking the Log button several times. You''ll see the output
    in the Console as well as an increase in the heap size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6b77278a-ca50-4a47-8fca-ef7259a0ee72.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 - Memory heap investigation
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the graph increases in size. However, over time, the memory allocation
    will actually drop if you stop clicking Log. This is an example of Chrome's intelligent
    garbage collection at work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all make mistakes when coding, and knowing how to find, diagnose, and debug
    those problems is a key skill in any language. In this chapter, we've taken a
    look at how the Error object and the console provide us with rich diagnostic information
    on where an error occurred, what details are piggybacking on the object, and how
    to read them. Don't forget that, sometimes, the error may look one way on the
    surface (our JSON error in *The Error Object* section), and don't be afraid to
    experiment with tracing through your code with console statements and breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Since JavaScript runs client-side, it's important to keep in mind the performance
    capacity of your users. There are many best practices when writing JavaScript,
    such as reusing variables (especially DOM-related ones), so always be sure to
    keep your code **DRY** (**Don't Repeat Yourself**).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll wrap up working with the frontend and understand
    how JavaScript truly is the ruler of the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the root cause of memory problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The variables in your program are global.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inefficient code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaScript's performance limitations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hardware inadequacies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using DOM elements, you should store references to them locally versus
    always accessing the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True when using them more than once
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaScript is pre-processed on the server side, and thus more efficient than
    Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting breakpoints can't find memory leaks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a good idea to store all variables in the global namespace as they're more
    efficient to reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can use the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Isolating Memory Leaks with Chrome''s Allocation Timeline: [https://blog.logrocket.com/isolating-memory-leaks-with-chromes-allocation-timeline-244fa9c48e8e/](https://blog.logrocket.com/isolating-memory-leaks-with-chromes-allocation-timeline-244fa9c48e8e/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Garbage Collection: [https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Performance: [https://www.w3schools.com/js/js_performance.asp](https://www.w3schools.com/js/js_performance.asp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory Problems: [https://developers.google.com/web/tools/chrome-devtools/memory-problems](https://developers.google.com/web/tools/chrome-devtools/memory-problems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node.js Memory Leak Detection: [https://medium.com/tech-tajawal/memory-leaks-in-nodejs-quick-overview-988c23b24dba](https://medium.com/tech-tajawal/memory-leaks-in-nodejs-quick-overview-988c23b24dba)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
