- en: Using the GPIO to Connect to the Outside World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will start unlocking the real power behind the Raspberry
    Pi—the GPIO, or General Purpose Input Output. The GPIO allows you to connect your
    Raspberry Pi to the outside world through the use of pins that may be set to input
    or output, and are controlled through code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python libraries for the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Raspberry Pi’s GPIO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we start by exploring Raspberry Pi-specific libraries for Python.
    We will demonstrate these with a few examples by using the Raspberry Pi camera
    module and Pibrella HAT. We will try a few coding examples with the Sense Hat
    emulator before moving on to designing a physical circuit using the Fritzing program.
    Using a breadboard, we will set up this circuit and connect it to our Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: We will finish off this chapter by building a Morse code generator that transmits
    weather data in Morse code from the class we created in [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. This chapter should take an afternoon
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is required to complete this project:'
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi Model 3 (2015 model or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi camera module (optional)—[https://www.raspberrypi.org/products/camera-module-v2/](https://www.raspberrypi.org/products/camera-module-v2/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pribrella HAT (optional)—[www.pibrella.com](http://www.pibrella.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Sense HAT (optional, as we will be using the emulator in this chapter)—[https://www.raspberrypi.org/products/sense-hat/a](https://www.raspberrypi.org/products/sense-hat/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-female jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python libraries for the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will turn our attention to the Python libraries or packages that come pre-installed
    with Raspbian. To view these packages from Thonny, click on Tools | Manage Packages.
    After a short delay, you should see many packages listed in the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8e2919c-6c5f-4f6b-b422-44c9bad7d1ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's explore a few of these packages.
  prefs: []
  type: TYPE_NORMAL
- en: picamera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The camera port, or CSI, on the Raspberry Pi allows you to connect the specially
    designed Raspberry Pi camera module to your Pi. This camera can take both photos
    and videos, and has functionality to do time-lapse photography and slow-motion
    video recording. The `picamera` package gives us access to the camera through
    Python. The following is a picture of a Raspberry Pi camera module connected to
    a Raspberry Pi 3 Model B through the camera port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/60d9b712-4c92-452c-9930-4b35240bbf9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect your Raspberry Pi camera module to your Pi, open up Thonny, and type
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code imports the `picamera` and `time` packages, and then creates a `picamera`
    object called `picam`. From there, we start the preview and then sleep for `10`
    seconds, before stopping the preview and then closing the camera. After running
    the program, you should see a `10` second preview from the camera on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: Pillow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pillow package is used for image processing with Python. To test this out,
    download an image to the same directory as your project files. Create a new file
    in Thonny and type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should see the format and size of the image (in brackets) printed at the
    commandline that follows.
  prefs: []
  type: TYPE_NORMAL
- en: sense-hat and sense-emu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sense HAT is a sophisticated add-on board for the Raspberry Pi. The Sense
    HAT is the main component in the Astro Pi kit, part of a program to have young
    students program a Raspberry Pi for the International Space Station.
  prefs: []
  type: TYPE_NORMAL
- en: The Astro Pi competition was officially opened in January of 2015 to all primary
    and secondary school-aged children in the United Kingdom. During a mission to
    the International Space Station, British astronaut Tim Peake deployed Astro Pi
    computers on board the station.
  prefs: []
  type: TYPE_NORMAL
- en: The winning Astro Pi competition code was loaded onto an Astro Pi while in orbit.
    The data generated was collected and sent back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sense HAT contains an array of LEDs that can be used as a display. The
    Sense HAT also has the following sensors onboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnetometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barometric pressure sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can access the sensors and LEDs on the Sense HAT through the `sense-hat` package.
    For those that do not have a Sense HAT, the Sense HAT emulator in Raspbian may
    be used instead. We use the `sense-emu` package to access the emulated sensors
    and LED display on the Sense HAT emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in Thonny and name it `sense-hat-test.py`, or something similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Load the Sense HAT Emulator program from Application Menu | Programming | Sense
    HAT Emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Arrange your screen so that you can see the LED display of the Sense HAT emulator
    and the full window of Thonny (see the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/366ddf47-8fe3-40c4-ae0a-3eadd23b99ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Run current script** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the `Hello World!` message scroll across the LED display of the
    Sense HAT emulator one letter at a time (see the previous screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing Raspberry Pi's GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through the GPIO, we are able to connect to the outside world. Here is a diagram
    of the Raspberry Pi GPIO pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79dbd754-d3e8-462d-83c5-4eba89aed7ac.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an explanation of these pins:'
  prefs: []
  type: TYPE_NORMAL
- en: Red pins represent power coming out of the GPIO. The GPIO provides 3.3 Volts
    and 5 Volts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Black pins represent pins used for electrical ground. As you can see, there
    are 8 ground pins on the GPIO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue pins are used for Raspberry Pi **Hardware Added on Top** (**HATs**). They
    allow communication between the Raspberry Pi and the HAT's **Electrical Erasable
    Programmable Read-Only Memory** (**EEPROM**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green pins represent the input and output pins that we may program for. Please
    note that some of the green GPIO pins double up with additional functionality.
    We will not be covering the additional functionality for this project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPIO is what lies at the heart of the Raspberry Pi. We can connect LEDs,
    buttons, buzzers, and so on to the Raspberry Pi through the GPIO. We can also
    access the GPIO through HATs designed for the Raspberry Pi. One of those, called `Pibrella`,
    is what we will use next to explore connecting to the GPIO through Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 1 Models A and B only have the first 26 pins (as shown by the dotted
    line). Models since then, including Raspberry Pi 1 Models A+ and B+, Raspberry
    Pi 2, Raspberry Pi Zero and Zero W, and Raspberry Pi 3 Model B and B+, have 40
    GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: Pibrella
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pibrella is a relatively inexpensive Raspberry Pi HAT that makes connecting
    to the GPIO easy. The following are the components on-board of Pibrella:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 yellow LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 green LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro USB power connector for delivering more power to the outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pibrella was designed for early Raspberry Pi models and thus only has a 26-pin
    input. It can, however, be connected to later models through the first 26 pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Pibrella Hat, line up the pin connectors on the Pibrella with
    the first 26 pins on the Raspberry Pi, and push down. In the following picture,
    we are installing Pibrella on a Raspberry Pi 3 Model B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0cdda19-675f-4dd9-8be8-92b39e77bb6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pibrella should fit snugly when installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4db07f13-e208-4307-9997-1d85ee2adc90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The libraries needed to connect to Pibrella do not come pre-installed with
    Raspbian (as of the time of writing), so we have to install them ourselves. To
    do that, we will use the `pip3` command from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the Terminal by clicking on it on the top tool bar (fourth icon from the
    left). At the Command Prompt, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the package load from the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/98d08ff7-12f1-4e83-8cad-e317d2db3e8d.png)'
  prefs: []
  type: TYPE_IMG
- en: With the `Pibrella` library, there is no need to know the GPIO pin numbers in
    order to access the GPIO. The functionality is wrapped up in the `Pibrella` object
    we import into our code. We will do a short demonstration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in Thonny called `pibrella-test.py`, or name it something
    similar. Type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by clicking on the Run current script button. If you typed everything
    in correctly, you should see the red light on the Pibrella board turn on for `5`
    seconds before a short melody is played over the speaker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, you have now crossed the threshold into the world of physical
    computing.
  prefs: []
  type: TYPE_NORMAL
- en: RPi.GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard Python package for accessing the GPIO is called `RPi.GPIO`. The
    best way to describe how it works is with some code (this is for demonstration
    purposes only; we will be running code to access the GPIO in the upcoming section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this code seems a little bit confusing. We will step through
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `RPi.GPIO` and `time` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the mode to `BCM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In BCM mode, we access the pin through GPIO numbers (the ones shown in our Raspberry
    Pi GPIO graphic). The alternative is to access the pins through their physical
    location (`GPIO.BOARD`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set GPIO pin `18` to an output, we use the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set GPIO `18` to `HIGH` for `5` seconds before setting it to `LOW`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we had set up the circuit and run the code, we would see our LED light for
    `5` seconds before turning off, similar to the Pibrella example.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO zero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to `RPi.GPIO` is the GPIO Zero package. As with `RPi.GPIO`, this
    package comes pre-installed with Raspbian. The zero in the name refers to zero
    boilerplate or setup code (code that we are forced to enter every time).
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish the same task of turning an LED on and off for `5` seconds, we
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with our `RPi.GPIO` example, this code is for demonstration purposes only
    as we haven't set up a circuit yet. It's obvious that the GPIO Zero code is far
    simpler than the `RPi.GPIO` example. This code is pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will start building a physical circuit on a breadboard
    with an LED, and use our code to turn it on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pibrella HAT gave us a simple way of programming the GPIO, however, the
    ultimate goal of Raspberry Pi projects is to create a customized working circuit.
    We will now take the steps to design our circuit, and then create the circuit
    using a breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to design our circuit on the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Fritzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fritzing is a free circuit design software available for Windows, macOS, and
    Linux. There is a version in the Raspberry Pi store that we will install on our
    Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Application Menu, choose Preferences | Add / Remove Software. In the
    Search box, type in `Fritzing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/732813b5-525b-4bad-aac3-de11bd72da0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Select all three boxes and click on Apply, and then OK. After installation,
    you should be able to load Fritzing from Application Menu | Programming | Fritzing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Breadboard tab to access the breadboard design screen. A full size
    breadboard dominates the middle of the screen. We will make it smaller as our
    circuit is small and simple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the breadboard. In the Inspector box, you will see a heading called
    Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Size dropdown and select Mini.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a Raspberry Pi to our circuit, type in `Raspberry Pi` in the search box.
    Drag a Raspberry Pi 3 under our breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we may drag and drop components onto our breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an LED and 330 Ohm resistor to our breadboard, shown in the following diagram.
    We use the resistor to protect both the LED and Raspberry Pi from excessive currents
    that may cause damage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d26a7e02-67c4-48f9-9591-588675500457.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that as we hover our mouse over each pin on our Raspberry Pi
    component, a yellow tip will pop up with the pin's BCM name. Click on GPIO 18
    and drag a line over to the positive leg of our LED (the longer one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same to drag a GND connection to the left-hand side of the resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the circuit we will build for our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Building our circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build our physical circuit, start by inserting components into our breadboard.
    Referring to our diagram from before, we can see that some of the holes are green.
    This indicates continuity in the circuit. For example, we connect the negative
    leg of the LED to the 330 Ohm resistor through the same vertical column. Thus,
    the two component legs are connected together through the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We take this into account as we start to place our components on the breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4d79016-46de-4fd7-9baa-94beaf95042d.png)'
  prefs: []
  type: TYPE_IMG
- en: Insert the LED into our breadboard, as shown in the preceding picture. We are
    following our Fritzing diagram and have the positive leg in the lower hole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow our Fritzing diagram and wire up the 330 Ohm resistor. Using female-to-male
    jumper wires, connect the Raspberry Pi to our breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to our Raspberry Pi GPIO diagram to find GPIO 18 and GND on the Raspberry
    Pi board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a good practice to have the Raspberry Pi powered off when connecting jumpers
    to the GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following image, the complete circuit resembles our Fritzing
    diagram (only our breadboard and Raspberry Pi are turned sideways):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df8f25c1-4ead-4c0a-a641-2146ccb891ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Connect the Raspberry Pi back up to the monitor, power supply, keyboard, and
    mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to program our first real GPIO circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Hello LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will jump right into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in Thonny, and call it `Hello LED.py` or something similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following code and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Blink LED using gpiozero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wired up our circuit and typed in our code correctly, we should see our
    LED blink for 10 seconds in 1 second intervals. The blink function in the `gpiozero
    LED` object allows us to set `on_time` (the length of time in seconds that the
    LED stays on), `off_time` (the length of time in seconds that the LED is turned
    off for), `n` or the number of times the LED blinks, and `background` (set to
    `True` to allow other code to run while the LED is flashing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blink` function call with its default parameters looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Without parameters passed into the function, the LED will blink non-stop at
    1 second intervals. Notice how we do not need to import the `time` library like
    we did when we used the `RPi.GPIO` package for accessing the GPIO. We simply pass
    a number into the `blink` function to represent the time in seconds we want the
    LED on or off.
  prefs: []
  type: TYPE_NORMAL
- en: Morse code weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml), *Writing Python
    Programs Using Raspberry Pi*, we wrote code that simulates calls to a web service
    that supplies weather information. Taking what we learned in this chapter, let's
    revisit that code and give it a physical computing upgrade. We will use our LED
    to flash a Morse code representation of our weather data.
  prefs: []
  type: TYPE_NORMAL
- en: Many of us believe that the world only started to become connected in the 1990s
    with the World Wide Web. Little do we realize that we already had such a world
    beginning in the 19th century with the introduction of the telegraph and trans-world
    telegraph cables. The language of this so-called Victorian Internet was Morse
    code, with the Morse code operator as its gate keeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps for flashing Morse code representation of our weather
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first start by creating a `MorseCodeGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After importing the `gpiozero` and `time` libraries into our `MorseCodeGenerator`
    class, we define GPIO 18 as our LED with the line `led=LED(18)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the duration of how long a `dot` lasts with the line `dot_duration =
    0.3`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define the duration of the dash and spacing between words based on the
    `dot_duration`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To speed up or slow down our Morse code transmutation, we may adjust `dot_duration`
    accordingly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a Python dictionary with the name `MORSE_CODE`. We use this dictionary
    to translate letters to Morse code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `transmit_message` function steps through each letter of the message, and
    then each character in the Morse code, which is equivalent to using the `dash_dot`
    variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The magic of our class happens in the `dot` and `dash` methods by using the
    `blink` function from the `gpiozero` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the `dot` method, we can see that we turn the LED on for the duration set
    in `dot_duration`, and then we turn it off for the same amount of time. We only
    blink it once as set it by the number `1` in the `blink` method call. We also
    set the background parameter to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This last parameter is very important, as if we leave it to the default of `True`,
    the code will continue to run before the LED has a chance to blink on and off.
    Basically, the code won't work unless the background parameter is set to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: We forgo the usual `Hello World` for our test message and instead use the standard
    `SOS`, which is familiar to the most casual of Morse code enthusiasts. We may
    test our class by clicking on the Run button and, if all is set up correctly,
    we will see the LED blink SOS in Morse code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s revisit our `CurrentWeather` class from [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. We will make a few minor modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing our `MorseCodeGenerator` class (make sure that both files
    are in the same directory). As we do not have a Morse code equivalent of `/`,
    we take out the km/h in the `weather_data` data set. The rest of the class remains
    the same as it did in [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. In our test section, we instantiate
    both a `CurrentWeather` class and a `MorseCodeGenerator` class. Using the `CurrentWeather`
    class, we pass the weather conditions for Toronto into the `MorseCodeGenerator`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: If there aren't any mistakes made in entering the code, we should see our LED
    blink `partly sunny` in Morse code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot was covered in this chapter. By the end of it, you should be feeling pretty
    good about developing applications on the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The `picamera`, `Pillow`, and `sense-hat` libraries make it easy to communicate
    with the outside world with your Raspberry Pi. Using the Raspberry Pi camera module
    and `picamera`, we open up a whole new world of possibilities with our Pi. We
    only touched on a small part of what `picamera` can do. Additionally, we only
    scratched the surface of image processing with the `Pillow` library. The Sense
    HAT emulator allowed us to save spending money on buying the actual HAT and test
    out our code. With `sense-hat` and the Raspberry Pi Sense HAT, we truly expand
    our reach into the physical world.
  prefs: []
  type: TYPE_NORMAL
- en: The inexpensive Pibrella HAT provided an easy way to jump into the physical
    computing world. By installing the `pibrella` library, we are giving our Python
    code access to an assortment of LEDs, a speaker, and a button, all neatly packaged
    into a Raspberry Pi HAT.
  prefs: []
  type: TYPE_NORMAL
- en: However, the true ultimate goal with physical computing is to build electronic
    circuits that bridge the gap between our Raspberry Pi and the outside world. We
    started our journey of building electronic circuits with the Fritzing circuit
    builder, available from the Raspberry Pi store. From there, we built our first
    circuit on a breadboard with an LED and resistor.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by creating a Morse code generator with our Raspberry
    Pi and LED circuit. In a twist of old meets new, we were able to transmit weather
    data in Morse code via a blinking LED.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](626664bb-0130-46d1-b431-682994472fc1.xhtml), *Subscribing to
    Web Services*, we will incorporate web services into our code, thereby connecting
    the internet world with the real world in a concept called the Internet of Things.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the name of the Python package that allows you access to the Raspberry
    Pi camera module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? A Raspberry Pi with code written by students was deployed on
    the international space station.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the sensors included with Sense HAT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? We do not need to buy a Raspberry Pi Sense HAT for development,
    as an emulator of this HAT exists in Raspbian.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many ground pins are there on the GPIO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? Raspberry Pi's GPIO has pins that supply both 5V and 3.3V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Pibrella?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? You may only use a Pibrella on early Raspberry Pi computers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does BCM mode mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? BOARD is the alternative to BCM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the Zero in `gpiozero` refer to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? Using Fritzing, we are able to design a GPIO circuit for our
    Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default background parameter in the `gpiozero` LED `blink` function
    set to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? It is far easier to use the `gpiozero` library to access the
    GPIO than it is to use the `RPi.GPIO` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Victorian Internet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of concepts were covered in this chapter, with the assumption that the
    skills needed were not beyond the average developer and tinkerer. To further solidify
    understanding of these concepts, please Google the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install the Raspberry Pi camera module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the Fritzing circuit design software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For those of you that are as fascinated about technology of the past as I am,
    the following is a great book to read on the age of the Victorian Internet: *The
    Victorian Internet*, by Tom Standage.'
  prefs: []
  type: TYPE_NORMAL
