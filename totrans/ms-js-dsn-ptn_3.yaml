- en: Part II. Other Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Programming
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming
  prefs: []
  type: TYPE_NORMAL
- en: Application Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Web Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Messaging Patterns
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs: []
  type: TYPE_NORMAL
- en: Patterns for Testing
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Patterns
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript-2015/2016 Solutions Today
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1 we focused on patterns originally identified in the GoF book that
    were the original impetus behind patterns in software design. In this part of
    the book we'll expand beyond those patterns to look at patterns that are related
    to functional programming, large-scale patterns for structuring an entire application,
    patterns which are specific to the Web, and messaging patterns. In addition, we'll
    look at patterns for testing and some rather interesting advanced patterns. Finally,
    we'll look at how we can get many of the features of the next version of JavaScript
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a different approach to development than the heavily
    object oriented approach that we have focused on so far. Object oriented programming
    is a fantastic tool for solving a great number of problems but it has some issues.
    Parallel programming within an object oriented context is difficult as the state
    can be changed by various different threads with unknown side effects. Functional
    programming does not permit state or mutable variables. Functions act as primary
    building blocks in functional programming. Places where you might have used a
    variable in the past will now use a function.
  prefs: []
  type: TYPE_NORMAL
- en: Even in a single threaded program, functions can have side-effects that change
    global state. This means that, when calling an unknown function, it can alter
    the whole flow of the program. This makes debugging a program quite difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is not a functional programming language but we can still apply
    some functional principles to our code. We''ll look at a number of patterns in
    the functional space:'
  prefs: []
  type: TYPE_NORMAL
- en: Function passing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters and pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional functions are side-effect-free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core tenant of functional programming is that functions should not change
    state. Values local to the function may be set but nothing outside the function
    may change. This approach is very useful for making code more maintainable. There
    need no longer be any concern that passing an array into a function is going to
    play havoc with its contents. This is especially a concern when using libraries
    that are not under your control.
  prefs: []
  type: TYPE_NORMAL
- en: There is no mechanism within JavaScript to prevent you from changing global
    state. Instead you must rely on developers to write side-effect-free functions.
    This may be difficult or not, depending on the maturity of the team.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be desirable to put all the code from your application into functions,
    but separating as much as possible is desirable. There is a pattern called command
    query separation that suggests that methods should fall into two categories. Either
    they are a function that reads a value or they are a command that sets a value.
    Never the twain should meet. Keeping methods categorized like this eases in debugging
    and in code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: One of the consequences of side effect-free functions is that they can be called
    any number of times with the same inputs and the result will be the same. Furthermore,
    because there are no changes to state, calling the function many times will not
    cause any ill side effects, other than making it run slower.
  prefs: []
  type: TYPE_NORMAL
- en: Function passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming languages, functions are first class citizens. Functions
    can be assigned to variables and passed around just like you would with any other
    variable. This is not entirely a foreign concept. Even languages such as C had
    function pointers that could be treated just like other variables. C# has delegates
    and, in more recent versions, lambdas. The latest release of Java has also added
    support for lambdas as they have proven to be so useful.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript allows for functions to be treated as variables and even as objects
    and strings. In this way JavaScript is functional in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of JavaScript''s single threaded nature, callbacks are a common convention
    and you can find them pretty much everywhere. Consider calling a function at a
    later date on a web page. This is done by setting a timeout on the window object
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The arguments for the set timeout function are a function to call and a time
    to delay in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Irrespective of the JavaScript environment in which you''re working, it is
    almost impossible to avoid functions in the shape of callbacks. Node.js'' asynchronous
    processing model is highly dependent on being able to call a function and pass
    in something to be completed at a later date. Making calls to external resources
    in a browser is also dependent on a callback to notify the caller that some asynchronous
    operation has completed. In basic JavaScript this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that we assign the `onreadystatechange` function before we even
    send the request. This is because assigning it later may result in a race condition
    in which the server responds before the function is attached to the ready state
    change. In this case, we''ve used an inline function to process the returned data.
    Because functions are first class citizens we can change this to look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is typically a cleaner approach and avoids performing complex processing
    in line with another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you might be more familiar with the jQuery version of this, which
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the boiler plate of dealing with ready state changes is handled
    for you. There is even convenience provided for you if the request for data fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've passed an object into the `ajax` call which defines a number
    of properties. Amongst these properties are function callbacks for success and
    failure. This method of passing numerous functions into another suggests a great
    way of providing expansion points for classes.
  prefs: []
  type: TYPE_NORMAL
- en: Likely you've seen this pattern in use before without even realizing it. Passing
    functions into constructors as part of an options object is a commonly used approach
    to providing extension hooks in JavaScript libraries. We saw some treatment of
    functions in the previous chapter, [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , when passing function into the observer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Westeros the tourism industry is almost non-extant. There are great difficulties
    with bandits killing tourists and tourists becoming entangled in regional conflicts.
    Nonetheless, some enterprising folks have started to advertise a grant tour of
    Westeros in which they will take those with the means on a tour of all the major
    attractions. From King's Landing to Eyrie, to the great mountains of Dorne - the
    tour will cover it all. In fact, a rather mathematically inclined member of the
    tourism board has taken to calling it a Hamiltonian tour as it visits everywhere
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HamiltonianTour` class provides an options object which allows the definition
    of an options object. This object contains the various places to which a callback
    can be attached. In our case the interface for it would look something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The full `HamiltonianTour` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in the highlighted code how we check the options and then execute
    the callback as needed. This can be used by simply doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running this code would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Passing functions is a great approach to solving a number of problems in JavaScript
    and tends to be used extensively by libraries such as jQuery and frameworks such
    as express. It is so commonly adopted that using it provides added barriers to
    your code's readability.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re at all familiar with the Unix command line or, to a lesser extent,
    the Windows command line, then you''ll have probably made use of pipes. A pipe,
    which is represented by the `|` character is shorthand for "take the output of
    program A and put it into program B". This relatively simple idea makes the Unix
    command line incredibly powerful. For instance, if you wanted to list all the
    files in a directory and then sort them and filter for any which start with either
    the letters `b` or `g` and end with an `f` then the command might look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ls` command lists all files and directories, the `sort` command sorts
    them, and the `grep` command matches file names against a regular expression.
    Running this command in the `etc` directory on an Ubuntu box in `/etc` would give
    a result which looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Some functional programming languages such as F# offer a special syntax for
    piping between functions. In F#, filtering a list for even numbers can be done
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is very nice-looking, especially when used for long chains of functions.
    As an example, taking a number, casting it to a float, square rooting it, and
    then rounding it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a clearer syntax than the C-style syntax that would look more like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, there is no ability to write pipes in JavaScript using a nifty
    F# style syntax, but we can still improve upon the normal method shown in the
    preceding code by using method chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in JavaScript is an object, which means that we can have some real
    fun adding functionality to existing objects to improve their look. Operating
    on collections of objects is a space in which functional programming provides
    some powerful features. Let's start by adding a simple filtering method to the
    array object. You can think of these queries as being like SQL database queries
    written in a functional fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We would like to provide a function that performs a match against each member
    of the array and returns a set of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The rather simple looking function allows us to quickly filter an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we return is also an object, an array object in this case. We can continue
    to chain methods onto it like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The result of this is an array containing only the number 6, as it is the only
    number between 1 and 10 which is both even and divisible by three. This method
    of returning a modified version of the original object without changing the original
    is known as a fluent interface. By not changing the original item array, we've
    introduced a small degree of immutability into our variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another function to our library of array extensions, we can start
    to see how useful these pipes can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This extension allows for projections of the original items based on an arbitrary
    projection function. Given a set of objects which contain IDs and names, we can
    use our fluent extensions to array to perform complex operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will build a new array which contains only children with even IDs
    and instead of full objects, the array will contain only their names: `Sansa`
    and `Brandon` . For those familiar with .Net these functions may look very familiar.
    The **Language Integrated Queries** ( **LINQ** ) library on .Net provides similarly
    named functional inspired functions for the manipulation of collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chaining functions in this manner can be both easier to understand and easier
    to build than alternatives: temporary variables are avoided and the code made
    terser. Consider the preceding example re-implemented using loops and temporary
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A number of JavaScript libraries such as d3 are constructed to encourage this
    sort of programming. At first it seems like the code created following this convention
    is bad due to very long line length. I would argue that this is a function of
    line length not being a very good tool to measure complexity rather than an actual
    problem with the approach.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at some simple array functions which add filtering and pipes to
    arrays. Another useful tool is the accumulator. Accumulators aid in building up
    a single result by iterating over a collection. Many common operations such as
    summing up the elements of an array can be implemented using an accumulator instead
    of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is popular within functional programming languages and many of them
    actually offer an optimization called "tail call optimization". A language that
    supports this provides optimizations for functions using recursion in which the
    stack frame is reused. This is very efficient and can easily replace most loops.
    Details on whether tail call optimization is supported in any JavaScript interpreter
    are sketchy. For the most part it doesn't seem like it is but we can still make
    use of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with `for` loops is that the control flow through the loop is mutable.
    Consider this rather easy-to-make mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you spot the error? It took me several attempts to get a working version
    of this code I could break. The problem is in the loop counter in the second loop,
    it should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Obviously this could be somewhat mitigated through better variable naming but
    we would like to avoid the problem altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Instead we can make use of an accumulator, a tool for combining multiple values
    from a collection into a single value. We've rather missed Westeros for a couple
    of patterns so let's get back to our mythical example land. Wars cost a great
    deal of money but fortunately there are a great number of peasants to pay taxes
    and finance the lords in their games for the throne.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our peasants are represented by a simple model which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Over this set of peasants we have an accumulator which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code takes a list of items, an accumulator value, and a function that projects
    the value to be integrated into the accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projection function looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to prime this function, we simply need to pass in an initial value
    for the accumulator along with the array and projection. The priming value will
    vary but more often than not it will be an identity; an empty string in the case
    of a string accumulator and a 0 or 1 in the case of mathematical ones.
  prefs: []
  type: TYPE_NORMAL
- en: Each pass through the accumulator shrinks the size of the array over which we
    are operating. All this is done without a single mutable variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner accumulation can really be any function you like: string appending,
    addition, or something more complicated. The accumulator is somewhat like the
    visitor pattern except that modifying values in the collection inside an accumulator
    is frowned upon. Remember that functional programming is side-effect-free.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not to be confused with memorization, memoization is a specific term for retaining
    a number of previously calculated values from a function.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, side-effect-free functions can be called multiple times without
    causing problems. The corollary to this is that a function can also be called
    fewer times than needed. Consider an expensive function which does some complex
    or, at least, time-consuming math. We know that the result of the function is
    entirely predicated on the inputs to the function. So the same inputs will always
    produce the same outputs. Why, then, would we need to call the function multiple
    times? If we saved the output of the function, we could retrieve that instead
    of redoing the time-consuming math.
  prefs: []
  type: TYPE_NORMAL
- en: Trading off space for time is a classic computing science problem. By caching
    the result, we make the application faster but we will consume more memory. Deciding
    when to perform caching and when to simply recalculate the result is a difficult
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros, learned men, known as Maesters, have long had a fascination
    with a sequence of numbers which seems to reappear a great deal in the natural
    world. In a strange coincidence they call this sequence the Fibonacci sequence.
    It is defined by adding the two previous terms in the sequence to get the next
    one. The sequence is bootstrapped by defining the first few terms as 0, 1, 1\.
    So to get the next term we would simply add 1 and 1 to get 2\. The next term would
    add 2 and 1 to get 3 and so forth. Finding an arbitrary member of the sequence
    requires finding the two previous members, so it can end up being a bit of calculation.
  prefs: []
  type: TYPE_NORMAL
- en: In our world we have discovered a closed form that avoids much of this calculation
    but in Westeros no such discovery has been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naïve approach is to simply calculate every term like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This solution works very quickly for small numbers such as 10\. However, for
    larger numbers, say greater than 40, there is a substantial slow-down. This is
    because the base case is called 102,334,155 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if we can improve things by memoizing some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have just memoized every item we encounter. As it turns out for this algorithm
    we store *n+1* items, which is a pretty good trade-off. Without memoization, calculating
    the 40th fibonacci number took 963ms while the memoization version took only 11ms.
    The difference is far more pronounced when the functions become more complex to
    calculate. Fibonacci of 140 took 12 ms for the memoization version while the naïve
    version took… well, it is has been a day and it is still running.
  prefs: []
  type: TYPE_NORMAL
- en: The best part of this memoization is that subsequent calls to the function with
    the same parameter will be lightning-fast as the result is already computed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example only a very small cache was needed. In more complex examples
    it is difficult to know how large a cache should be or how frequently a value
    will need to be recomputed. Ideally your cache will be large enough that there
    will always be room to put more results in. However, this may not be realistic
    and tough decisions will need to be made about which members of the cache should
    be removed to save space. There is a plethora of methods for performing cache
    invalidation. It has been said that cache invalidation is one of the toughest
    problems in computing science, the reason being that we're effectively trying
    to predict the future. If anybody has perfected a method of telling the future,
    it is likely they are applying their skills in a more important domain than cache
    invalidation. Two options are to prey on the least recently used member of the
    cache or the least frequently used member. It is possible that the shape of the
    problem may dictate a better strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a fantastic tool for speeding up calculations which need to be
    performed multiple times or even calculations which have common sub-calculations.
    One can consider memoization as just a special case of caching, which is a commonly
    used technique when building web servers or browsers. It is certainly worthwhile
    exploring in more complex JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the cornerstones of functional programming is that so called variables
    can be assigned only once. This is known as immutability. ECMAScript 2015 supports
    a new keyword, `const` . The `const` keyword can be used in the same way as `var`
    except that variables assigned with `const` will be immutable. For instance, the
    following code shows a variable and a constant that are both manipulated in the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the results for the constant and variable are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using an older browser without support, then `const` won''t be available
    to you. A possible workaround is to make use of the `Object.freeze` functionality
    which is more widely adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax here is not very user-friendly. Also an issue is
    that attempting to assign to an already assigned `const` simply fails silently
    instead of throwing an error. Failing silently in this fashion is not at all a
    desirable behavior; a full exception should be thrown. If you enable strict mode,
    a more rigorous parsing mode is added in ECMAScript 5, and an exception is actually
    thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is the `object.Create` syntax we spoke about earlier. When creating
    properties on the object, one can specify `writable: false` to make the property
    immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, even in strict mode no exception is thrown when attempting to write
    to a non-writable property. Thus I would claim that the `const` keyword is not
    perfect for implementing immutable objects. You're better off using freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go into a higher-end coffee shop and place an order for some overly complex
    beverage (Grande Chai Tea Latte, 3 Pump, Skim Milk, Lite Water, No Foam, Extra
    Hot anybody?) then that beverage is going to be made on-the-fly and not in advance.
    Even if the coffee shop knew which orders were going to come in that day, they
    would still not make all the beverages up front. First, because it would result
    in a large number of ruined, cold beverages, and second, it would be a very long
    time for the first customer to get their order if they had to wait for all the
    orders of the day to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead coffee shops follow a just-in-time approach to crafting beverages. They
    make them when they're ordered. We can apply a similar approach to our code through
    the use of a technique known as lazy instantiation or lazy initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an object which is expensive to create; that is to say that it takes
    a great deal of time to create the object. If we are unsure if the object's value
    will be needed, we can defer its full creation until later.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump into an example of this. Westeros isn''t really big on expensive
    coffee shops but they do love a good bakery. This bakery takes requests for different
    bread types in advance and then bakes them all at once should they get an order.
    However, creating the bread object is an expensive operation so we would like
    to defer that until somebody actually comes to pick up the bread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating a list of bread types to be created as needed. This list
    is appended to by ordering a bread type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This allows for breads to be rapidly added to the required bread list without
    paying the price for each bread to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when `pickUpBread` is called we''ll actually create the breads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we call a series of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the collection of actual breads is left until after the pickup
    has been requested.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation can be used to simplify asynchronous programming. Promises
    are an approach to simplifying callbacks which are common in JavaScript. Instead
    of building up complicated callbacks, a promise is an object which contains a
    state and a result. When first called, the promise is in an unresolved state;
    once the `async` operation completes, the state is updated to complete and the
    result is filled in. You can think of the result as being lazily instantiated.
    We'll look at promises and promise libraries in more detail in [Chapter 9](text00080.html#ch09
    "Chapter 9. Web Patterns") , *Web Patterns* .
  prefs: []
  type: TYPE_NORMAL
- en: Being lazy can save you quite a bit of time in creating expensive objects that
    end up never being used.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although callbacks are the standard way of dealing with asynchronous methods
    in JavaScript they can get out of hand easily. There are a number of approaches
    to solving this spaghetti code: promise libraries provide a more fluent way of
    handling callbacks and future versions of JavaScript may adopt an approach similar
    to the C# `async/await` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: I really like accumulators but they can be inefficient in terms of memory use.
    The lack of tail recursion means that each pass through adds another stack frame,
    so this approach may result in memory pressure. All things are a trade-off in
    this case between memory and code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is not a functional programming language. That is not to say that
    it isn't possible to apply some of the ideas from functional programming to it.
    These approaches enable cleaner, easier to debug code. Some might even argue that
    the number of issues will be reduced although I have never seen any convincing
    studies on that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we looked at six different patterns. Lazy instantiation, memoization,
    and immutability are all creational patterns. Function passing is a structural
    pattern as well as a behavioral one. Accumulators are also behavioral in nature.
    Filters and pipes don't really fall into any of the GoF categories so one might
    think of them as a style pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll look at a number of patterns for dividing the logic
    and presentation in applications. These patterns have become more important as
    JavaScript applications have grown.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I once read a book that suggested that Newton came up with the idea for calculus
    when he was observing the flow of a river around a reed. I've never been able
    to find any other source which supports that assertion. It is, however, a nice
    picture to hold in your mind. Calculus deals with understanding how the state
    of a system changes over time. Most developers will rarely have to deal with calculus
    in their day to day work. They will, however, have to deal with systems changing.
    After all, having a system which doesn't change at all is pretty boring.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years a number of different ideas have arisen in the area
    of treating change as a stream of events – just like the stream that Newton supposedly
    observed. Given a starting position and a stream of events it should be possible
    to figure out the state of the system. Indeed, this is the idea behind using an
    event store. Instead of keeping the final state of an aggregate in a database
    we instead keep track of all the events which have been applied to that aggregate.
    By replaying this series of events we can recreate the current state of the aggregate.
    This seems like a roundabout way of storing the state of an object but it is actually
    very useful for a number of situations. For example, a disconnected system, like
    a cell phone application when the phone isn't connected to the network, which
    uses an event store can be merged with other events much more easily than simply
    keeping the end state. It is also stunningly useful for audit scenarios as it
    is possible to pull the system back to the state it was in at any point in time
    by simply halting the replay at a time index. How frequently have you been asked,
    "why is the system in this state?", and you've been unable to reply? With an event
    store the answer should be easy to ascertain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Application state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams for multiplexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within an application we can think of all the events happening as a similar
    stream of events. The user clicks on a button? Event. The user''s mouse enters
    some region? Event. A clock ticks? Event. In both front and backend applications,
    events are the things which trigger changes in state. You''re likely already using
    events for event listeners. Consider attaching a click handler to a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this code we have attached a handler to the `click` event. This is fairly
    simple code but think about how rapidly the complexity of this code increases
    when we add conditions like "ignore additional click for 500ms once a click is
    fired to prevent people double-clicking" and "Fire a different event if the *Ctrl*
    key is being held when the button is clicked". Reactive programming or functional
    reactive programming provides a simple solution to these complex interaction scenarios
    through use of streams. Let's explore how your code can benefit from leveraging
    reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to think of an event stream is not to think of the streams
    you''ve probably used before in programming, input reader streams, but to think
    of arrays. Let''s say that you have an array with a series of numbers in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you want to filter this array to only show you even numbers. In modern
    JavaScript this is easily done through the use of the `filter` function on the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A graphical representation can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams](Image00032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The filtering function here remains the same should we have ten items in the
    array or ten thousand items in the array. Now, what if the source array had new
    items being appended to it all the time? We would like to keep our dependent array
    up-to-date by inserting any new items which are even, into it. To do this we could
    hook into the `add` function on the array using a pattern-like decorator. Using
    a decorator we could call the filter method and, if a match was found, we would
    add it to the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are, in effect, an observable on a collection of future events. There
    are a number of interesting problems which can be solved using operations on streams.
    Let''s start with a simple problem: handling clicks. This problem is so simple
    that, on the surface, it doesn''t seem like there is any advantage to using streams.
    Don''t worry we''ll make it more difficult as we go along.'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part this book avoids making use of any specific JavaScript libraries.
    The idea is that patterns should be able to be implemented with ease without a
    great deal of ceremony. However, in this case we're actually going to make use
    of a library because streams have a few nuances to their implementation for which
    we'd like some syntactic niceties. If you're looking to see how to implement a
    basic stream, then you can base it on the observer pattern outlined in [Chapter
    5](text00044.html#page "Chapter 5. Behavioral Patterns") , *Behavioral Patterns*
    .
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of stream libraries in JavaScript Reactive.js, Bacon.js,
    and RxJS to name a few. Each one has various advantages and disadvantages but
    the specifics are outside the purview of this book. In this book we'll make use
    of Reactive Extensions for JavaScript, the source code for which can be found
    on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a brief piece of HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To this, let''s add a quick click counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see we''re creating a new stream of events from the `click` event
    on the button. The newly created stream is commonly referred to as a metastream.
    Whenever an event is emitted from the source stream it is automatically manipulated
    and published, as needed, to the metastream. We subscribe to this stream and increment
    a counter. If we wanted to react to only the even numbered events, we could do
    so by subscribing a second function to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that we're applying a filter to the stream such that the counter
    is distinct from the function which updates the screen. Keeping a counter outside
    of the streams like this feels dirty, though, doesn't it? Chances are that incrementing
    every other click isn't the goal of this function anyway. It is much more likely
    that we would like to run a function only on double click.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is difficult to do with traditional methods, however these sorts of complex
    interactions are easy to achieve using streams. You can see how we might approach
    the problem in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we take the click stream and buffer the stream using a debounce to generate
    the boundaries of the buffer. Debouncing is a term from the hardware world which
    means that we clean up a noisy signal into a single event. When a physical button
    is pushed, there are often a couple of additional high or low signals instead
    of the single point signal we would like. In effect we eliminate repeated signals
    which occur within a window. In this case we wait `250` ms before firing an event
    to move to a new buffer. The buffer contains all the events fired during the debouncing
    and passes on a list of them to the next function in the chain. The map function
    generates a new stream with the list length as the contents. Next, we filter the
    stream to show only events with a value of 2 or more, that''s two clicks or more.
    The stream of events look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Performing the same logic as this using traditional event listeners and call-backs
    would be quite difficult. One could easily imagine a far more complex workflow
    that would spiral out of control. FRP allows for a more streamlined approach to
    handling events.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the preceding section, it is possible to filter a stream of events
    and, from it produce a new stream of events. You might be familiar with being
    able to filter items in an array. ES5 introduced a number of new operators for
    arrays such as **filter** and **some** . The first of these produces a new array
    containing only elements which match the rule in the filter. `Some` is a similar
    function which simply returns `true` if any element of the array matches. These
    same sorts of functions are also supported on streams as well as functions you
    might be familiar with from functional languages such as First and Last. In addition
    to the functions which would make sense for arrays, there are a number of time
    series based functions which make much more sense when you consider that streams
    exist in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen debounce which is an example of a time based filter. Another
    very simple application of debounce is to prevent the annoying bug of users double-clicking
    a submit button. Consider how much simpler the code for that is using a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You might also find it that functions like Sample – which generates a set of
    events from a time window. This is a very handy function when we're dealing with
    observables which may produce a large number of events. Consider an example from
    our example world of Westeros.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Westeros is quite a violent place where people seem to die in
    unpleasant ways. So many people die that we can't possibly keep an eye on each
    one so we'd like to just sample the data and gather a few causes of death.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate this incoming stream, we will start with an array, something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see we're using an array to simulate a stream of events. This can be
    done with any stream and is a remarkably easy way to perform testing on complex
    code. You can build a stream of events in an array and then publish them with
    appropriate delays giving an accurate representation of anything from a stream
    of events from the filesystem to user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make our array into a stream of events. Fortunately, there are
    some shortcuts for doing that using the `from` method. This will simply return
    a stream which is immediately executed. What we''d like is to pretend we have
    a regularly distributed stream of events or, in our rather morbid case, deaths.
    This can be done by using two methods from RxJS: `interval` and `zip` . `interval`
    creates a stream of events at a regular interval. `zip` matches up pairs of events
    from two streams. Together these two methods will emit a new stream of events
    at a regular interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this code we zip together the deaths array with an interval stream which
    fires every `500` ms. Because we're not super interested in the interval event
    we simply discard it and project the item from the array onwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can sample this stream by simply taking a sample and then subscribing
    to it. Here we''re sampling every `1500` ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have as many subscribers to a stream as you like so if you wanted to
    perform some sampling, as well as perhaps some aggregate functions like simply
    counting the events, you could do so by having several subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Merging streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen the `zip` function that merges events one-to-one to create
    a new stream but there are numerous other ways of combining streams. A very simple
    example might be a page which has several code paths which all want to perform
    a similar action. Perhaps we have several actions all of which result in a status
    message being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see how the various streams are passed into the merge function
    and the resulting merged stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging streams](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While useful, this code doesn't seem to be particularly better than simply calling
    the event handler directly, in fact it is longer than necessary. However, consider
    that there are more sources of status messages than just button pushes. We might
    want to have asynchronous events also write out information. For instance, sending
    a request to the server might also want to add status information. Another fantastic
    application may be with web workers which run in the background and communicate
    with the main thread using messaging. For web based JavaScript applications this
    is how we implement multithreaded applications. Let's see how that would look.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we can create a stream from a worker role. In our example the worker
    simply calculates the fibonacci sequence. We''ve added a fourth button to our
    page and have it trigger the worker process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can subscribe to the merged stream and combine it with all the previous
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This all looks really nice but we don''t want to clobber the users with dozens
    of notifications at a time. We can throttle the stream of events so that only
    a single toast shows up at a time by using the same interval zip pattern we saw
    earlier. In this code we''ve replaced our `appendToOutput` method with a call
    to a toast display library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the code for this functionality is short and easy to understand
    yet it contains a great deal of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Streams for multiplexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One does not rise to a position of power on the King''s council in Westeros
    without being a master at building networks of spies. Often the best spy is one
    who can respond the quickest. Similarly, we may have some code which has the option
    of calling one of many different services which can fulfill the same task. A great
    example would be a credit card processor: it doesn''t really matter which processor
    we use as they''re pretty much all the same.'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can kick off a number of HTTP requests to each of the services.
    If we take each of the requests and put them into a stream, we can use it to select
    the fastest to respond processor and then perform the rest of the actions using
    that processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With RxJS this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You could even include a timeout in the `amb` call which would be called to
    handle the eventuality that none of the processors responded in time.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a large number of different functions that can be applied to streams.
    If you happen to decide on the RxJS library for your FRP needs in JavaScript,
    many of the most common functions have been implemented for you. More complex
    functions can often be written as a chain of the included functions so try to
    think of a way to create the functionality you want by chaining before writing
    your own functions.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, asynchronous calls across the network in JavaScript fail. Networks
    are unreliable, mobile networks doubly so. For the most part when the network
    fails, our application fails. Streams provide an easy fix to this by allowing
    you to easily retry failed subscriptions. In RxJS this method is called `Retry`
    . Slotting it into any observable chain makes it more resilient to network failures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional reactive programming has many uses in different applications both
    on the server and on the client. On the client side it can be used to wrangle
    a large number of events together into a data flow enabling complex interactions.
    It can also be used for the simplest of things such as preventing a user from
    double-clicking a button. There is no huge cost to simply using streams for all
    of your data changes. They are highly testable and have a minimal impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the nicest thing about FRP is that it raises the level of abstraction.
    You have to deal with less finicky process flow code and can, instead, focus on
    the logical flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Application Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far we have spent a great deal of time examining patterns that are used
    to solve local problems, that is; problems that span only a handful of classes
    and not the whole application. These patterns have been narrow in scope. They
    frequently only relate to two or three classes and might be used but a single
    time in any given application. As you can imagine there are also larger scale
    patterns that are applicable to the application as a whole. You might think of
    "toolbar" as a general pattern that is used in many places in an application.
    What's more, it is a pattern that is used in a great number of applications to
    give them a similar look and feel. Patterns can help guide how the whole application
    is assembled.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we're going to look at a family of patterns which I've taken
    to calling the MV* family. This family includes MVC, MVVM, MVP, and even PAC.
    Just like their names, the patterns themselves are pretty similar. The chapter
    will cover each of these patterns and show how, or if, we can apply them to JavaScript.
    We'll also pay special attention to how the patterns differ from one another.
    By the end of the chapter you should be able to thrill guests at a cocktail party
    with an explanation of the nuances of MVP versus MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: History of Model View patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Presenter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View ViewModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, some history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Separating concerns inside an application is a very important idea. We live
    in a complex and ever-changing world. This means that not only is it nearly impossible
    to formulate a computer program which works in exactly the way users want, but
    that what users want is an ever-shifting maze. Couple this with the fact that
    an ideal program for user A is totally different from an ideal program for user
    B and we''re guaranteed to end up in a mess. Our applications need to change as
    frequently as we change our socks: at least once a year.'
  prefs: []
  type: TYPE_NORMAL
- en: Layering an application and maintaining modularity reduces the impact of a change.
    The less each layer knows about the other layers the better. Maintaining simple
    interfaces between the layers reduces the chances that a change to one layer will
    percolate to another layer.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever taken a close look at a high quality piece of nylon (from a hot
    air balloon, parachute, or expensive jacket) you may have noticed that that the
    fabric seems to form tiny squares. This is because, every few millimeters, a thick
    reinforcing thread is added to the weave to form a crosshatch pattern. If the
    fabric is ripped, then the rip will be stopped or at least slowed by the reinforcement.
    This limits the damage to a small area and prevents it from spreading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers and modules in an application are exactly the same: they limit the spread
    of damage from a change.'
  prefs: []
  type: TYPE_NORMAL
- en: In the early chapters of this book, we talked a bit about the seminal language,
    Smalltalk. It was the language which made classes famous. Like many of these patterns,
    the original MV* pattern, **Model View Controller** ( **MVC** ), was used long
    before it was ever identified. Although difficult to prove it seems that MVC was
    originally suggested in the late 1970s by Trygve Reenskaug, a Norwegian computer
    scientist, during a visit to the legendary Xerox PARC. Through the 1980s the pattern
    became heavily used in Smalltalk applications. However, it was not until 1988
    that the pattern was more formally documented in an article entitled, *A Cookbook
    for Using the Model-View-Controller User Interface Paradigm* by Glenn E. Krasner
    and Stephen T. Pope.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVC is a pattern that is useful for creating rich, interactive user interfaces:
    just the sort of interfaces which are becoming more and more popular on the web.
    The astute amongst you will have already figured out that the pattern is made
    up of three major components: model, view, and controller. You can see how information
    flows between the components in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](Image00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the relationship between the three components in
    MVC.
  prefs: []
  type: TYPE_NORMAL
- en: The model contains the state of the program. In many applications this model
    is contained in some form, in a database. The model may be rehydrated from a persistent
    store such as the database or it can be transient. Ideally the model is the only
    mutable part of the pattern. Neither the view nor the controller has any state
    associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple login screen the model might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that not only do we have fields for the inputs shown to the user
    but also for the state of the login. This would not be apparent to the user but
    it is still part of the application state.
  prefs: []
  type: TYPE_NORMAL
- en: The model is usually modeled as a simple container for information. Typically,
    there are no real functions in the model. It simply contains data fields and may
    also contain validation. In some implementations of the MVC pattern the model
    also contains meta-data about the fields such as validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Naked Object pattern is a deviation from the typical MVC pattern. It augments
    the model with extensive business information as well as hits about the display
    and editing of data. It even contains methods for persisting the model to storage.
  prefs: []
  type: TYPE_NORMAL
- en: The views in the Naked Object pattern are generated from these models automatically.
    The controller is also automatically generated by examining the model. This centralizes
    the logic for displaying and manipulating application states and saves the developer
    from having to write their own views and controllers. So while the view and controller
    still exist, they are not actual objects but are dynamically created from the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Several systems have been successfully deployed using this pattern. Some criticism
    has emerged around the ability to generate an attractive user interface from just
    the models as well as how to properly coordinate multiple views.
  prefs: []
  type: TYPE_NORMAL
- en: In a foreword to the PhD thesis, *presenting Naked Objects* by Reenskaug, he
    suggests that the naked objects pattern is actually closer to his original vision
    for MVC than most of the derivations of MVC in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Updates to the model are communicated to the view whenever the state changes.
    This is typically done through the use of an observer pattern. The model does
    not typically know about either the controller or the view. The first is simply
    the thing telling it to change and the second is only updated through the observer
    pattern so the model doesn't have direct knowledge of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view does pretty much what you would expect: communicate the model state
    to a target. I hesitate to suggest that the view must be a visual or graphical
    representation of the model as frequently the view is being communicated to another
    computer and may be in the form of XML, JSON, or some other data format. In most
    cases, especially those related to JavaScript, the view will be a graphical object.
    In a web context this will typically be HTML which is rendered by the browser.
    JavaScript is also gaining popularity on phones and on the desktop, so the view
    could also be a screen on a phone or on the desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The view for the model presented in the preceding paragraph might look like
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In cases, where the observer pattern is not used, then the view may poll the
    model at some interval looking for changes. In this case the view may have to
    keep a representation of the state itself or at least a version number. It is
    important that the view not unilaterally update this state without passing the
    updates to the controller, otherwise the model and the copy in the view will get
    out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the state of the model is updated by the controller. The controller
    usually contains all the logic and business rules for updating fields on the model.
    A simple controller for our login page might look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The controller knows about the existence of the model and is typically aware
    of the view's existence as well. It coordinates the two of them. A controller
    may be responsible for initializing more than one view. For instance, a single
    controller may provide a list view of all the instances of a model as well as
    a view that simply provides details. In many systems a controller will have create,
    read, update, and delete (CRUD) operations on it that work over a model. The controller
    is responsible for choosing the correct view and for wiring up the communication
    between the model and the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is a need for a change to the application then the location of the
    code should be immediately apparent. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Change | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Elements don''t appear well spaced on the screen, change spacing. | View
    |'
  prefs: []
  type: TYPE_TB
- en: '| No users are able to log in due to a logical error in password validation.
    | Controller |'
  prefs: []
  type: TYPE_TB
- en: '| New field to be added. | All layers |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Presentation-Abstraction-Control** ( **PAC** ) is another pattern that makes
    use of a triad of components. In this case its goal is to describe a hierarchy
    of encapsulated triples that more closely match how we think of the world. The
    control, similar to an MVC controller, passes interactions up in the hierarchy
    of encapsulated components allowing for information to flow between components.
    The abstraction is similar to a model but may represent only a few fields that
    are important for that specific PAC instead of the entire model. Finally, the
    presentation is effectively the same as a view.'
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchical nature of PAC allows for parallel processing of the components,
    meaning that it can be a powerful tool in today's multiprocessor systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that the last one there requires a change in all layers of
    the application. These multiple locations for responsibility are something that
    the Naked Objects pattern attempts to address by dynamically creating views and
    controllers. The MVC pattern splits code into locations by dividing the code by
    its role in user interaction. This means that a single data field lives in all
    the layers as is shown in this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some might call this a cross-cutting concern but really it doesn't span a sufficient
    amount of the application to be called such. Data access and logging are cross-cutting
    concerns as they are pervasive and difficult to centralize. This pervasion of
    a field through the different layers is really not a major problem. However, if
    it is bugging you then you might be an ideal candidate for using the Naked Objects
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step into building some code to represent a MVC in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: MVC code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple scenario for which we can apply MVC. Unfortunately,
    Westeros has very few computers, likely due to the lack of electricity. Thus applying
    application structuring patterns using Westeros as an example is difficult. Sadly
    we'll have to take a step back and talk about an application which controls Westeros.
    Let's assume it to be a web application and implement the entirety of MVC on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to implement MVC by splitting the model, view and controller
    between client and server. Typically, the controller would sit on the server and
    provide an API which is known by the view. The model serves as a communication
    method both to the view which resides on the web browser and to the data store,
    likely a database of some form. It is also common that the controller be split
    between the server and the client in cases where some additional control is required
    on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example we would like to create a screen that controls the properties
    of a castle. Fortunately, you''re lucky that this is not a book on designing user
    interfaces with HTML as I would certainly fail. We''ll stick to a picture in place
    of the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVC code](Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the most part, the view simply provides a set of controls and data for
    the end user. In this example the view will need to know how to call the save
    function on the controller. Let''s set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the constructor for this view contains both a reference to
    the document and to the controller. The document contains both HTML and styling,
    provided by CSS. We can get away with not passing in a reference to the document
    but injecting the document in this fashion allows for easier testability. We'll
    look at testability more in a later chapter. It also permits reusing the view
    multiple times on a single page without worrying about the two instances conflicting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor also contains a reference to the model which is used to add
    data to fields on the page as needed. Finally, the constructor also references
    a collection of errors. This allows for validation errors from the controller
    to be passed back to the view to be handled. We have set the validation result
    to be a wrapped collection that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The only functionality here is that the button's `onclick` method is bound to
    calling save on the controller. Instead of passing in a large number of parameters
    to the `saveCastle` function on the controller, we build a lightweight object
    and pass that in. This makes the code more readable, especially in cases where
    some of the parameters are optional. No real work is done in the view and all
    the input goes directly to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller contains the real functionality of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The controller here does a number of things. The first thing is that it has
    a `setView` function which instructs the browser to set the given view as the
    current one. This is likely done through the use of a template. The mechanics
    of how that works are not important to the pattern so I'll leave that up to your
    imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the controller implements a `validate` method. This method checks to make
    sure that the model is valid. Some validation may be performed on the client,
    such as testing the format of a postal code, but other validation requires a server
    trip. If a username must be unique then there is no reasonable way to test that
    on the client without communicating with the server. In some cases, the validation
    functionality may exist on the model rather than in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for setting up various different views are also found in the controller.
    In this case we have a bit of a workflow with a view for creating a castle then
    views for both success and failure. The failure case just returns the same view
    with a collection of validation errors attached to it. The success case returns
    a whole new view.
  prefs: []
  type: TYPE_NORMAL
- en: The logic to save the model to some sort of persistent storage is also located
    in the controller. Again the implementation of this is less important than to
    see that the logic for communicating with the storage system is located in the
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final letter in MVC is the model. In this case, it is a very light weight
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all it does is keep track of the variables that make up the
    state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Concerns are well separated in this pattern allowing for changes to be made
    with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Presenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Model View** **Presenter** ( **MVP** ) pattern is very similar to MVC.
    It is a fairly well known pattern in the Microsoft world and is generally used
    to structure WPF and Silverlight applications. It can be used in pure JavaScript
    as well. The key difference comes down to how the different parts of the system
    interact and where their responsibility ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference is that, with the presenter, there is a one to one mapping
    between presenter and view. This means that the logic that existed in the controller
    in the MVC pattern, which selected the correct view to render, doesn''t exist.
    Or rather it exists at a higher level outside the concern of the pattern. The
    selection of the correct presenter may be handled by a routing tool. Such a router
    will examine the parameters and provide the best choice for the presenter. The
    flow of information in the MVP pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Presenter](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The presenter is aware of both the view and the model but the view is unaware
    of the model and the model unaware of the view. All communication is passed through
    the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: The presenter pattern is often characterized by a great deal of two-way dispatch.
    A click will fire in the presenter and then the presenter will update the model
    with the change and then the view. The preceding diagram suggests that the input
    first passes through the view. In a passive version of the MVP pattern, the view
    has little to no interaction with the messages as they are passed onto the presenter.
    However, there is also a variation called active MVP that allows the view to contain
    some additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: This active version of MVP can be more useful for web situations. It permits
    adding validation and other simple logic to the view. This reduces the number
    of requests that need to pass from the client back to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update our existing code sample to use MVP instead of MVC.
  prefs: []
  type: TYPE_NORMAL
- en: MVP code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start again with the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the constructor for the view no longer takes a reference to the
    model. This is because the view in MVP doesn't have any idea about what model
    is being used. That information is abstracted away by the presenter. The reference
    to presenter remains in the constructor to allow sending messages back to the
    presenter.
  prefs: []
  type: TYPE_NORMAL
- en: Without the model there is an increase in the number of public setter and getter
    methods. These setters allow the presenter to make updates to the state of the
    view. The getters provide an abstraction over how the view stores the state and
    gives the presenter a way to get the information. The `saveCastle` function no
    longer passes any values to the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presenter''s code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the view is now referenced in a persistent fashion in the presenter.
    The `saveCastle` method calls into the view to get its values. However, the presenter
    does make sure to use the public methods of the view instead of referencing the
    document directly. The `saveCastle` method updates the model. If there are validation
    errors, then it will call back into the view to update the `IsValid` flag. This
    is an example of the double dispatch I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the model remains unchanged from before. We've kept the validation
    logic in the presenter. At which level the validation is done, model or presenter,
    matters less than being consistent in where the validation is done through your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The MVP pattern is again a fairly useful pattern for building user interfaces.
    The larger separation between the view and the model creates a stricter API allowing
    for better adaptation to change. However, this comes at the expense of more code.
    With more code comes more opportunity for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Model View ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final pattern we''ll look at in this chapter is the Model View ViewModel
    pattern, more commonly known as MVVM. By now this sort of pattern should be getting
    quite familiar. Again you can see the flow of information between components in
    this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View ViewModel](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see here that many of the same constructs have returned but that the
    communication between them is somewhat different.
  prefs: []
  type: TYPE_NORMAL
- en: In this variation, what has previously been the controller and presenter is
    now the view model. Just like with MVC and MVP, the majority of the logic is held
    within the central component, in this case the view model. The model itself is
    actually very simple in MVVM. Typically, it acts as an envelope that just holds
    data. Validation is done within the view model.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with MVP, the view is totally unaware of the existence of the model.
    The difference is that, with MVP, the view was aware that it was talking to some
    intermediate class. It called methods rather than simply setting values. In MVVM
    the view believes that the view model is its view. Instead of calling operations
    like `saveCastle` and passing in data or waiting for data to be requested, the
    view updates fields on the view model as they change. In effect, the fields on
    the view are bound to the view model. The view model may proxy these values through
    to the model or wait until a commit-like operation like save is called to pass
    the data along.
  prefs: []
  type: TYPE_NORMAL
- en: Equally, changes to the view model should be reflected at once in the view.
    A single view may have a number of view models. Each of these view models may
    push updates to the view or have changes pushed to it via the view.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a really rudimentary implementation of this and then we'll
    discuss how to make it better.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The naïve view implementation is, frankly, a huge mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It is highly repetitive and each property must be proxied back to `ViewModel`
    . I''ve truncated most of this code but it adds up to a good 70 lines. The code
    inside the view model is equally terrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'One look at this code should send you running for the hills. It is set up in
    a way that will encourage copy and paste programming: a fantastic way to introduce
    errors into a code base. I sure hope there is a better way to transfer changes
    between the model and the view.'
  prefs: []
  type: TYPE_NORMAL
- en: A better way to transfer changes between the model and the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not have escaped your notice that there are a number of MVVM-style frameworks
    for JavaScript in the wild. Obviously they would not have been readily adopted
    if they followed the approach that we described in the preceding section. Instead
    they follow one of two different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is known as dirty checking. In this approach, after every
    interaction with the view model we loop over all of its properties looking for
    changes. When changes are found, the related value in the view is updated with
    the new value. For changes to values in the view change, actions are attached
    to all the controls. These then trigger updates to the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can be slow for large models as it is expensive to iterate over
    all the properties of a large model. The number of things which can cause a model
    to change is high and there is no real way to tell if a distant field in a model
    has been changed by changing another without going and validating it. On the upside,
    dirty checking allows you to use plain old JavaScript objects. There is no need
    to write your code any differently than before. The same is not true of the other
    approach: container objects.'
  prefs: []
  type: TYPE_NORMAL
- en: With a container object a special interface is provided to wrap existing objects
    so that changes to the object may be directly observed. Basically this is an application
    of the observer pattern but applied dynamically so the underlying object has no
    idea it is being observed. The spy pattern, perhaps?
  prefs: []
  type: TYPE_NORMAL
- en: 'An example might be helpful here. Let us say that we have the model object
    we''ve been using up until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of `model.name` being a simple string, we would wrap some function
    around it. In the case of the Knockout library this would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted code, the various properties of the model are being wrapped
    with an observable. This means that they must now be accessed differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This approach obviously adds some friction to your code and makes changing frameworks
    quite involved.
  prefs: []
  type: TYPE_NORMAL
- en: Current MVVM frameworks are split on their approach to container objects versus
    dirty checking. AngularJS uses dirty checking while Backbone, Ember, and Knockout
    all make use of container objects. There is currently no clear winner.
  prefs: []
  type: TYPE_NORMAL
- en: Observing view changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, the pervasiveness of MV* patterns on the web and the difficulties
    with observing model changes has not gone unnoticed. You might be expecting me
    to say that this will be solved in ECMAScript-2015 as is my normal approach. Weirdly,
    the solution to all of this, `Object.observe` , is a feature under discussion
    for ECMAScript-2016\. However, at the time of writing, at least one major browser
    already supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Having this simple interface to monitor changes to objects removes much of the
    logic provided by large MV* frameworks. It will be easier to roll your own functionality
    for MV* and there may, in fact, be no need to use external frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The different layers of the various MV* patterns need not all be on the browser,
    nor do they all need to be written in JavaScript. Many popular frameworks allow
    for maintaining a model on the server and communicating with it using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.observe` may not be available on all browsers yet, but there are polyfills
    that can be used to create a similar interface. The performance is not as good
    as the native implementation, but it is still usable.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separating concerns to a number of layers ensures that changes to the application
    are isolated like a ripstop. The various MV* patterns allow for separating the
    concerns in a graphical application. The differences between the various patterns
    come down to how the responsibilities are separated and how information is communicated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll look at a number of patterns and techniques to improve
    the experience of developing and deploying JavaScript to the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Web Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rise of Node.js has proven that JavaScript has a place on web servers, even
    very high throughput servers. There is no denying that JavaScript's pedigree remains
    in the browser for client side programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we're going to look at a number of patterns to improve the performance
    and usefulness of JavaScript on the client. I'm not sure that all of these can
    be thought of as patterns in the strictest sense. They are, however, important
    and worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts we''ll examine in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back-off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Communicating JavaScript to the client seems to be a simple proposition: so
    long as you can get the code to the client it doesn''t matter how that happens,
    right? Well not exactly. There are actually a number of things that need to be
    considered when sending JavaScript to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Way back in [Chapter 2](text00019.html#page "Chapter 2. Organizing Code") ,
    *Organizing Code* , we looked at how to build objects using JavaScript, although
    opinions on this vary. I consider it to be good form to have a one-class-to-one-file
    organization of my JavaScript or really any of my object oriented code. By doing
    this, it makes finding code easy. Nobody needs to hunt through a 9000 line long
    JavaScript file to locate that one method. It also allows for a hierarchy to be
    established again allowing for good code organization. However, good organization
    for a developer is not necessarily good organization for a computer. In our case
    having a lot of small files is actually highly detrimental. To understand why,
    you need to know a little bit about how browsers ask for and receive content.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you type a URL into the address bar of a browser and hit *Enter* , a cascading
    series of events happens. The first thing is that the browser will ask the operating
    system to resolve the website name to an IP address. On both Windows and Linux
    (and OSX) the standard C library function `gethostbyname` is used. This function
    will check the local DNS cache to see if the mapping from name to address is already
    known. If it is, then that information is returned. If not, then the computer
    makes a request to the DNS server one step up from it. Typically, this is the
    DNS server provided by the ISP but on a larger network it could also be a local
    DNS server. The path of a query between DNS servers can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining files](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a record doesn't exist on that server then the request is propagated up a
    chain of DNS servers in an attempt to find one that knows about the domain. Eventually
    the propagation stops at the root servers. These root servers are the stopping
    point for queries – if they don't know who is responsible for DNS information
    for a domain then the lookup is deemed to have failed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the browser has an address for the site it opens up a connection and sends
    a request for the document. If no document is provided, then a */* is sent. Should
    the connection be a secure one, then negotiation of SSL/TSL is performed at this
    time. There is some computational expense to setting up an encrypted connection
    but this is slowly being fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will respond with a blob of HTML. As the browser receives this HTML
    it starts to process it; the browser does not wait for the entire HTML document
    to be downloaded before it goes to work. If the browser encounters a resource
    that is external to the HTML it will kick off a new request to open another connection
    to the web server and download that resource. The maximum number of connections
    to a single domain is limited so that the web server isn''t flooded. It should
    also be mentioned that setting up a new connection to the web server carries overhead.
    The flow of data between a web client and server can be seen in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining files](Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connections to the web server should be limited to avoid paying the connection
    setup costs repeatedly. This brings us to our first concept: combining files.'
  prefs: []
  type: TYPE_NORMAL
- en: If you've followed the advice to leverage namespaces and classes in your JavaScript,
    then putting all of your JavaScript together in a single file is a trivial step.
    One need only concatenate the files together and everything should continue to
    work as normal. Some minor care and attention may need to be paid to the order
    of inclusion, but not typically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code we''ve written has been pretty much one file per pattern.
    If there is a need for multiple patterns to be used, then we could simply concatenate
    the files together. For instance, the combined builder and factory method patterns
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The question may arise as to how much of your JavaScript should be combined
    and loaded at once. It is a surprisingly difficult question to answer. On one
    hand it is desirable to front load all the JavaScript for the entire site when
    users first arrive at the site. This means that users will pay a price initially
    but will not have to download any additional JavaScript as they travel about the
    site. This is because the browser will cache the script and reuse it instead of
    downloading it from the server again. However, if users only visit a small subset
    of the pages on the site then they will have loaded a great deal of JavaScript
    that was not needed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, splitting up the JavaScript means that additional page visits
    incur a penalty for retrieving additional JavaScript files. There is a sweet spot
    somewhere in the middle of these two approaches. Script can be organized into
    blocks that map to different sections of the website. This can be a place where
    using proper name spacing will come in handy once again. Each namespace can be
    combined into a single file and then loaded as users visit that part of the site.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the only approach that makes sense is to maintain statistics about
    how users move about the site. Based on this information an optimal strategy for
    finding the sweet spot can be established.
  prefs: []
  type: TYPE_NORMAL
- en: Minification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining JavaScript into a single file solves the problem of limiting the number
    of requests. However, each request may still be large. Again we come to a schism
    between what makes code fast and readable by humans and what makes it fast and
    readable by computers.
  prefs: []
  type: TYPE_NORMAL
- en: We humans like descriptive variable names, bountiful whitespace, and proper
    indentation. Computers don't care about descriptive names, whitespace, or proper
    indentation. In fact, these things increase the size of the file and thus decrease
    the speed at which the code can be read.
  prefs: []
  type: TYPE_NORMAL
- en: Minification is a compile step that transforms the human readable code into
    smaller, but equivalent, code. External variables' names remain the same, as the
    minifier has no way to know what other code may be relying on the variable names
    remaining unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we start with the composite code from [Chapter 4](text00035.html#page
    "Chapter 4. Structural Patterns") , *Structural Patterns* , the minified code
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that all the spacing has been removed and that any internal variables
    have been replaced with smaller versions. At the same time, you can spot some
    well-known variable names have remained unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Minification saved this particular piece of code 40%. Compressing the content
    stream from the server using gzip, a popular approach, is lossless compression.
    That means that there is a perfect bijection between compressed and uncompressed.
    Minification, on the other hand, is a lossy compression. There is no way to get
    back to the unminified code from just the minified code once it has been minified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about gzip compression at [http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/](http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: If there is a need to return to the original code, then source maps can be used.
    A source map is a file that provides a translation from one format of code to
    another. It can be loaded by the debugging tools in modern browsers to allow you
    to debug the original code instead of unintelligible minified code. Multiple source
    maps can be combine to allow for translation from, say, minified code to unminified
    JavaScript to TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous tools which can be used to construct minified and combined
    JavaScript. Gulp and Grunt are JavaScript-based tools for building a pipeline
    which manages JavaScript assets. Both these tools call out to external tools such
    as Uglify to do the actual work. Gulp and Grunt are the equivalent to GNU Make
    or Ant.
  prefs: []
  type: TYPE_NORMAL
- en: Content Delivery Networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final delivery trick is to make use of **Content Delivery Networks** ( **CDNs**
    ). CDNs are distributed networks of hosts whose only purpose is to serve out static
    content. In much the same way that the browser will cache JavaScript between pages
    on the site, it will also cache JavaScript that is shared between multiple web
    servers. Thus, if your site makes use of jQuery, pulling jQuery from a well-known
    CDN such as [https://code.jquery.com/](https://code.jquery.com/) or Microsoft's
    ASP.net CDN may be faster as it is already cached. Pulling from a CDN also means
    that the content is coming from a different domain and doesn't count against the
    limited connections to your server. Referencing a CDN is as simple as setting
    the source of the script tag to point at the CDN.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, some metrics will need to be gathered to see whether it is better
    to use a CDN or simply roll libraries into the JavaScript bundle. Examples of
    such metrics may include the added time to perform additional DNS lookup and the
    difference in the download sizes. The best approach is to use the timing APIs
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The long and short of distributing JavaScript to the browser is that experimentation
    is required. Testing a number of approaches and measuring the results will give
    the best result for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a great number of really impressive JavaScript libraries in the wild.
    For me the library that changed how I look at JavaScript was jQuery. For others
    it may have been one of the other popular libraries such as MooTool, Dojo, Prototype,
    or YUI. However, jQuery has exploded in popularity and has, at the time of writing,
    won the JavaScript library wars. 78.5% of the top ten thousand websites, by traffic,
    on the internet make use of some version of jQuery. None of the rest of the libraries
    even breaks 1%.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers have seen fit to implement their own libraries on top of these
    foundational libraries in the form of plugins. A plugin typically modifies the
    prototype exposed by the library and adds additional functionality. The syntax
    is such that, to the end developer, it appears to be part of the core library.
  prefs: []
  type: TYPE_NORMAL
- en: How plugins are built varies depending on the library you're trying to extend.
    Nonetheless, let's take a look at how we can build a plugin for jQuery and then
    for one of my favourite libraries, d3\. We'll see if we can extract some commonalities.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At jQuery''s core is the CSS selector library called `sizzle.js` . It is sizzle
    that is responsible for all the really nifty ways jQuery can select items on a
    page using CSS3 selectors. Use jQuery to select elements on a page like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a jQuery object is returned. The jQuery object acts a lot like, although
    not completely like, an array. This is achieved by creating a series of keys on
    the jQuery object numbered 0 through to n-1 where n is the number of elements
    matched by the selector. This is actually pretty smart as it enables array like
    accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: While providing a bunch of additional functions, the items at the indices are
    plain HTML Elements and not wrapped with jQuery, hence the use of the second `$()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'For jQuery plugins, we typically want to make our plugins extend this jQuery
    object. Because it is dynamically created every time the selector is fired we
    actually extend an object called `$.fn` . This object is used as the basis for
    creating all jQuery objects. Thus creating a plugin that transforms all the text
    in inputs on the page into uppercase is nominally as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin is particularly useful for posting to bulletin boards and for whenever
    my boss fills in a form. The plugin iterates over all the objects selected by
    the selector and converts their content to uppercase. It also returns this. By
    doing so we allow for chaining of additional functions. You can use the function
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It does rather depend on the `$` variable being assigned to jQuery. This isn't
    always the case as `$` is a popular variable in JavaScript libraries, likely because
    it is the only character that isn't a letter or a number and doesn't already have
    special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, we can use an immediately evaluated function in much the same
    way we did way back in [Chapter 2](text00019.html#page "Chapter 2. Organizing
    Code") , *Organizing Code* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The added advantage here is that, should our code require helper functions or
    private variables, they can be set inside the same function. You can also pass
    in any options required. jQuery provides a very helpful `$.extend` function that
    copies properties between objects, making it ideal for extending a set of default
    options with those passed in. We looked at this in some detail in a previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jQuery plugin documentation recommends that the jQuery object be polluted
    as little as possible with plugins. This is to avoid conflicts between multiple
    plugins that want to use the same names. Their solution is to have a single function
    that has different behaviours depending on the parameters passed in. For instance,
    the jQuery UI plugin uses this approach for dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'I would much rather call these like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With dynamic languages there really isn't a great deal of difference but I would
    much rather have well named functions that can be discovered by tooling than magic
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: d3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'd3 is a great JavaScript library that is used for creating and manipulating
    visualizations. For the most part, people use d3 in conjunction with scalable
    vector graphics to produce graphics such as this hexbin graph by Mike Bostock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![d3](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: d3 attempts to be non-opinionated about the sorts of visualizations it creates.
    Thus there is no built-in support for creating such things as bar charts. There
    is, however, a collection of plugins that can be added to d3 to enable a wide
    variety of graphs including the hexbin one shown in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more, the jQuery d3 places emphasis on creating chainable functions. For
    example, this code is a snippet that creates a column chart. You can see that
    all the attributes are being set through chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The core of `d3` is the `d3` object. Off that object hang a number of namespaces
    for layouts, scales, geometry, and numerous others. As well as whole namespaces,
    there are functions for doing array manipulation and loading data from external
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a plugin for `d3` starts with deciding where we''re going to plug
    into the code. Let''s build a plugin that creates a new color scale. A color scale
    is used to map a domain of values to a range of colors. For instance, we might
    wish to map the domain of the following four values onto a range of four colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![d3](Image00044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s plug in a function to provide a new color scale, in this case one that
    supports grouping elements. A scale is a function that maps a domain to a range.
    For a color scale, the range is a set of colors. An example might be a function
    that maps all even numbers to red and all odd to white. Using this scale on a
    table would result in zebra striping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply attach this plugin to the existing `d3.scale` object. This can be
    used by simply giving an array of arrays as a domain and an array as a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This simple plugin extends the functionality of d3's scale. We could have replaced
    existing functionality or even wrapped it such that calls into existing functionality
    would be proxied through our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins are generally not that difficult to build but they do vary from library
    to library. It is important to keep an eye on the existing variable names in libraries
    so we don't end up clobbering them or even clobbering functionality provided by
    other plugins. Some suggest prefixing functions with a string to avoid clobbering.
  prefs: []
  type: TYPE_NORMAL
- en: If the library has been designed with it in mind there may be additional places
    into which we can hook. A popular approach is to provide an options object that
    contains optional fields for hooking in our own functions as event handlers. If
    nothing is provided the function continues as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Doing two things at once – multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doing two things at once is hard. For many years the solution in the computer
    world was to use either multiple processes or multiple threads. The difference
    between the two is fuzzy due to implementation differences on different operating
    systems but threads are typically lighter-weight versions of processes. JavaScript
    on the browser supports neither of these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, there has been no real need for multithreading on a browser. JavaScript
    was used to manipulate the user interface. When manipulating a UI, even in other
    languages and windowing environments, only one thread is permitted to act at a
    time. This avoids race conditions that would be very obvious to users.
  prefs: []
  type: TYPE_NORMAL
- en: However, as JavaScript grows in popularity, more and more complicated software
    is being written to run inside the browser. Sometimes that software could really
    benefit from performing complex calculations in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Web workers provide a mechanism for doing two things at once in a browser. Although
    a fairly recent innovation, web workers now have good support in mainstream browsers.
    In effect a worker is a background thread that can communicate with the main thread
    using messages. Web workers must be self-contained in a single JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of web workers is fairly easy. We''ll revisit our example from
    a few chapters ago when we looked at the fibonacci sequence. The worker process
    listens for messages like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here we start a new instance of `fib` any time we get a `startCalculation` message.
    `fib` is simply the naive implementation from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main thread loads the worker process from its external file and attaches
    a number of listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start the calculation, all that is needed is to send a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we pass the number of the term in the sequence we want to calculate. While
    the calculation is running in the background the main thread is free to do whatever
    it likes. When the message is received back from the worker it is placed in the
    normal event loop to be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Doing two things at once – multithreading](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Web workers may be useful to you if you have to do any time consuming calculations
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you're making use of server-side JavaScript through the use of Node.js then
    there is a different approach to doing more than one thing at a time. Node.js
    offers the ability to fork child processes and provides an interface not dissimilar
    to the web worker one to communicate between the child and parent processes. This
    method forks an entire process though, which is much more resource intensive than
    using lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: Some other tools exist that create lighter-weight background workers in Node.js.
    These are probably a closer parallel to what exists on the web side than forking
    a child process.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Systems, even the best designed systems, fail. The larger and more distributed
    a system, the higher the probability of failure. Many large systems such as Netflix
    or Google have extensive built-in redundancies. The redundancies don't decrease
    the chance of a failure of a component but they do provide a backup. Switching
    to the backup is frequently transparent to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern is a common component of a system that provides
    this sort of redundancy. Let's say that your application queries an external data
    source every five seconds, perhaps you're polling for some data that you're expecting
    to change. What happens when this polling fails? In many cases the failure is
    simply ignored and the polling continues. This is actually a pretty good behaviour
    on the client side as data updates are not always crucial. In some cases, a failure
    will cause the application to retry the request immediately. Retrying server requests
    in a tight loop can be problematic for both the client and the server. The client
    may become unresponsive as it spends more time in a loop requesting data.
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, a system that is attempting to recover from a failure is
    being slammed every five seconds by what could be thousands of clients. If the
    failure is due to the system being overloaded, then continuing to query it will
    only make matters worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit breaker pattern stops attempting to communicate with a system that
    is failing once a certain number of failures have been reached. Basically, repeated
    failures result in the circuit being broken and the application ceasing to query.
    You can see the general pattern of a circuit breaker in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Circuit breaker pattern](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the server, having the number of clients drop off as failures pile up allows
    for some breathing room to recover. The chances of a storm of requests coming
    in and keeping the system down is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: Of course we would like the circuit breaker to reset at some point so that service
    can be restored. The two approaches for this are that, either the client polls
    periodically (less frequently than before) and resets the breaker, or that the
    external system communicates back to its clients that service has been restored.
  prefs: []
  type: TYPE_NORMAL
- en: Back-off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variation on the circuit breaker pattern is to use some form of back-off instead
    of cutting out communication to the server completely. This is an approach that
    is suggested by many database vendors and cloud providers. If our original polling
    was at five second intervals, then when a failure is detected change the interval
    to every 10 seconds. Repeat this process using longer and longer intervals.
  prefs: []
  type: TYPE_NORMAL
- en: When requests start to work again then the pattern of changing the time interval
    is reversed. Requests are sent closer and closer together until the original polling
    interval is resumed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the status of the external resource availability is a perfect place
    to use background worker roles. The work is not complex but it is totally detached
    from the main event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Again this reduces the load on the external resource giving it more breathing
    room. It also keeps the clients unburdened by too much polling.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example using jQuery''s `ajax` function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the highlighted section retries the query.
  prefs: []
  type: TYPE_NORMAL
- en: This style of back-off is actually used in Ethernet to avoid repeated packet
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Degraded application behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is likely a very good reason that your application is calling out to external
    resources. Backing off and not querying the data source is perfectly reasonable
    but it is still desirable that users have some ability to interact with the site.
    One solution to this problem is to degrade the behavior of the application.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if your application shows real-time stock quote information, but
    the system for delivering stock information is broken, then a less than real time
    service could be swapped in. Modern browsers have a whole raft of different technologies
    that allow for storing small quantities of data on the client computer. This storage
    space is ideal for caching old versions of some data should the latest versions
    be unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Even in cases where the application is sending data to the server, it is possible
    to degrade behaviour. Saving the data updates locally and then sending them altogether
    when the service is restored is generally acceptable. Of course, once a user leaves
    a page, then any background works will terminate. If the user never again returns
    to the site, then whatever updates they had queued to send to the server will
    be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word of warning: if this is an approach you take it might be best to warn
    users that their data is old, especially if your application is a stock trading
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Promise pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I said earlier that JavaScript is single threaded. This is not entirely accurate.
    There is a single event loop in JavaScript. Blocking this event loop with a long
    running process is considered to be bad form. Nothing else can happen while your
    greedy algorithm is taking up all the CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you launch an asynchronous function in JavaScript, such as fetching data
    from a remote server, then much of this activity happens in a different thread.
    The success or failure handler functions are executed in the main event thread.
    This is part of the reason that success handlers are written as functions: it
    allows them to be easily passed back and forth between contexts.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus there are activities which truly do happen in an asynchronous, parallel
    fashion. When the `async` method has completed then the result is passed into
    the handler we provided and the handler is put into the event queue to be picked
    up next time the event loop repeats. Typically, the event loop runs many hundreds
    or thousands of times a second, depending on how much work there is to do on each
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically, we write the message handlers as functions and hook them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This is reasonable if the situation is simple. However, if you would like to
    perform some additional asynchronous actions with the results of the callback
    then you end up with nested callbacks. If you need to add error handling that
    too is done using callbacks. The complexity of waiting for multiple callbacks
    to return and orchestrating your response rises quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The promise pattern provides some syntactic help to clean up the asynchronous
    difficulties. If we take a common asynchronous operation such as retrieving data
    over XMLHttp Request using jQuery, then the code takes both an error and a success
    function. It might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a promise instead would transform the code to look more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the `$.ajax` method returns a promise object that contains a value
    and a state. The value is populated when the async call completes. The status
    provides some information about the current state of the request: has it completed,
    was it successful?'
  prefs: []
  type: TYPE_NORMAL
- en: The promise also has a number of functions called on it. The `then()` function
    takes a success and an error function and it returns an additional promise. Should
    the success function run synchronously, then the promise returns as already fulfilled.
    Otherwise it remains in a working state, known as pending, until the asynchronous
    success has fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my mind, the method in which jQuery implements promises is not ideal. Their
    error handing doesn''t properly distinguish between a promise that has failed
    to be fulfilled and a promise that has failed but has been handled. This renders
    jQuery promises incompatible with the general idea of promises. For instance,
    it is not possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the error has been handed and a new promise returned, processing
    will discontinue. It would be much better if the function could be written as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There has been much discussion about the implementation of promises in jQuery
    and other libraries. As a result of this discussion the current proposed promise
    specification is different from jQuery's promises and is incompatible. Promises/A+
    are the certification that is met by numerous promise libraries such as `when.js`
    and Q. It also forms the foundation of the promises specification that came with
    ECMAScript-2015.
  prefs: []
  type: TYPE_NORMAL
- en: Promises provide a bridge between synchronous and asynchronous functions, in
    effect turning the asynchronous functions into something that can be manipulated
    as if it were synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'If promise sounds a lot like the lazy evaluation pattern we saw some chapters
    ago then you''re exactly correct. Promises are constructed using lazy evaluation,
    the actions called on them are queued inside the object rather than being evaluated
    at once. This is a wonderful application of a functional pattern and even enables
    scenarios like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Promises greatly simplify asynchronous programming in JavaScript and should
    certainly be considered for any project that is heavily asynchronous in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 2015 promises are well supported on most browsers. Should you need
    to support an older browser then there are some great shims out there that can
    add the functionality with a minimum of overhead.
  prefs: []
  type: TYPE_NORMAL
- en: When examining the performance of retrieving JavaScript from a remote server,
    there are tools provided in most modern browsers for viewing a timeline of resource
    loading. This timeline will show when the browser is waiting for scripts to be
    downloaded and when it is parsing the scripts. Using this timeline allows for
    experimenting to find the best way to load a script or series of scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a number of patterns or approaches that improve
    the experience of developing JavaScript. We looked at a number of concerns around
    delivery to the browser. We also looked at how to implement plugins against a
    couple of libraries and extrapolated general practices. Next we took a look at
    how to work with background processes in JavaScript. Circuit breakers were suggested
    as a method of keeping remote resource-fetching sane. Finally, we examined how
    promises can improve the writing of asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll spend quite a bit more time looking at messaging patterns.
    We saw a little about messing with web workers but we'll expand quite heavily
    on them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. Messaging Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Smalltalk, the first real object oriented programming language, was first
    developed, the communication between classes was envisioned as being messages.
    Somehow we've moved away from this pure idea of messages. We spoke a bit about
    how functional programming avoids side effects, well, much the same is true of
    messaging-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging also allows for impressive scalability as messages can be fanned out
    to dozens, or even hundreds, of computers. Within a single application, messaging
    promotes low-coupling and eases testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we're going to look at a number of patterns related to messaging.
    By the end of the chapter you should be aware of how messages work. When I first
    learned about messaging I wanted to rewrite everything using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What's a message anyway?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish-subscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fan out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dead letter queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message replay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes and filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a message anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the simplest definition a message is a collection of related bits of data
    that have some meaning together. The message is named in a way that provides some
    additional meaning to it. For instance, both an `AddUser` and a `RenameUser` message
    might have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: User ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the fact that the fields exist inside a named container gives them different
    meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are usually related to some action in the application or some action
    in the business. A message contains all the information needed for a receiver
    to act upon the action. In the case of the `RenameUser` message, the message contains
    enough information for any component that keeps track of a relationship between
    a user ID and a username to update its value for username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many messaging systems, especially those that communicate between application
    boundaries, also define an **envelope** . The envelope has metadata on it that
    could help with message auditing, routing, and security. The information on the
    envelope is not part of the business process but is part of the infrastructure.
    So having a security annotation on the envelope is fine, as security exists outside
    of the normal business workflow and is owned by a different part of the application.
    The contents on the envelope look like the one shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s a message anyway?](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Messages should be sealed so that no changes can be made to them once they have
    been created. This makes certain operations like auditing and replaying much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging can be used to communicate inside a single process or it can be used
    between applications. For the most part there is no difference to sending a message
    within an application and between applications. One difference is the treatment
    of synchronicity. Within a single process, messages can be handled in a synchronous
    fashion. This means that the main processing effectively waits for the handling
    of the message to complete before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: In an asynchronous scenario, the handling of the message may occur at a later
    date. Sometimes the later date is far in the future. When calling out to an external
    server, asynchronous will certainly be the correct approach – this is due to the
    inherit latency associated with network I/O. Even within a single process, the
    single threaded nature of JavaScript encourages using asynchronous messaging.
    While using asynchronous messaging, some additional care and attention needs to
    be taken as some of the assumptions made for synchronous messaging cease to be
    safe. For instance, assuming the messages will be replied to in the same order
    in which they were sent is no longer safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different flavors of messages: commands and events. Commands
    instruct things to happen while events notify about something which has happened.'
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A command is simply an instruction from one part of a system to another. It
    is a message so it is really just a simple data transfer object. If you think
    back to the command pattern introduced in [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , this is exactly what it uses.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of convention, commands are named using the imperative. The format
    is usually `<verb><object>` . Thus a command might be called `InvadeCity` . Typically,
    when naming a command, you want to avoid generic names and focus on exactly what
    is causing the command.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a command that changes the address of a user. You might
    be tempted to simply call the command `ChangeAddress` but doing so does not add
    any additional information. It would be better to dig deeper and see why the address
    is being changed. Did the person move or was the original address entered incorrectly?
    Intent is as important as the actual data changes. For instance, altering an address
    due to a mistake might trigger a different behavior from a person who has moved.
    Users that have moved could be sent a moving present, while those correcting their
    address would not.
  prefs: []
  type: TYPE_NORMAL
- en: Messages should have a component of business meaning to increase their utility.
    Defining messages and how they can be constructed within a complex business is
    a whole field of study on its own. Those interested might do well to investigate
    **domain driven** **design** ( **DDD** ).
  prefs: []
  type: TYPE_NORMAL
- en: Commands are an instruction targeted at one specific component giving it instructions
    to perform a task.
  prefs: []
  type: TYPE_NORMAL
- en: Within the context of a browser you might consider that a command would be the
    click that is fired on a button. The command is transformed into an event and
    that event is what is passed to your event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Only one end point should receive a specific command. This means that only one
    component is responsible for an action taking place. As soon as a command is acted
    upon by more than one end point any number of race conditions are introduced.
    What if one of the end points accepts the command and another rejects it as invalid?
    Even in cases where several near identical commands are issued they should not
    be aggregated. For instance, sending a command from a king to all his generals
    should send one command to each general.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is only one end point for a command it is possible for that end
    point to validate and even cancel the command. The cancellation of the command
    should have no impact on the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: When a command is acted upon, then one or more events may be published.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An event is a special message that notifies that something has happened. There
    is no use in trying to change or cancel an event because it is simply a notification
    that something has happened. You cannot change the past unless you own a Delorian.
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention for events is that they are written in the past tense.
    You might see a reversal of the ordering of the words in the command, so we could
    end up with `CityInvaded` once the `InvadeCity` command has succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike commands, events may be received by any number of components. There are
    not real race conditions presented by this approach. As no message handler can
    change the message nor interfere with the delivery of other copies of the message,
    each handler is siloed away from all others.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be familiar with events from having done user interface work. When
    a user clicks a button then an event is "raised". In effect the event is broadcast
    to a series of listeners. You subscribe to a message by hooking into that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The events in browsers don't quite meet the definition of an event I gave in
    the preceding paragraph. This is because event handlers in the browser can cancel
    events and stop them from propagating to the next handler. That is to say, when
    there are a series of event handlers for the same message one of them can completely
    consume the message and not pass it on to subsequent handlers. There is certainly
    utility to an approach like this but it does introduce some confusion. Fortunately
    for UI messages, the number of handlers is typically quite small.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some systems, events can be polymorphic in nature. That is to say that if
    I had an event called `IsHiredSalary` that is fired when somebody is hired in
    a salaried role, I could make it a descendant of the message `IsHired` . Doing
    so would allow for both handlers subscribed to `IsHiredSalary` and `IsHired` to
    be fired upon receipt of an `IsHiredSalary` event. JavaScript doesn''t have polymorphism
    in the true sense, so such things aren''t particularly useful. You can add a message
    field that takes the place of polymorphism but it looks somewhat messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this case I've used `__` to denote fields that are part of the envelope.
    You could also construct the message with separate fields for message and envelope,
    it really doesn't matter all that much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple operation like creating a user so we can see
    how commands and events interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here a user enters data into a form and submits it. The web server takes in
    the input, validates it and, if it is correct, creates a command. The command
    is now sent to the command handler. The command handler performs some action,
    perhaps writes to a database, it then publishes an event that is consumed by a
    number of event listeners. These event listeners might send confirmation e-mails,
    notify system administrators, or any number of things.
  prefs: []
  type: TYPE_NORMAL
- en: All of this looks familiar because systems already contain commands and events.
    The difference is that we are now modeling the commands and events explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Request-reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest pattern you'll see with messaging is the request-reply pattern.
    Also known as request-response, this is a method of retrieving data that is owned
    by another part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases the sending of a command is an asynchronous operation. A command
    is fired and the application flow continues on. Because of this, there is no easy
    way to do things like lookup a record by ID. Instead one needs to send a command
    to retrieve a record and then wait for the associated event to be returned. A
    normal workflow looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request-reply](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most events can be subscribed to by any number listeners. While it is possible
    to have multiple event listeners for a request-response pattern, it is unlikely
    and is probably not advisable.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a very simple request-response pattern here. In Westeros there
    are some issues with sending messages in a timely fashion. Without electricity,
    sending messages over long distances rapidly can really only be accomplished by
    attaching tiny messages to the legs of crows. Thus we have a Crow Messaging System.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with building out what we''ll call the **bus** . A bus is simply
    a distribution mechanism for messages. It can be implemented in process, as we''ve
    done here, or out of process. If implementing it out of process, there are many
    options from 0mq, a lightweight message queue, to RabbitMQ, a more fully featured
    messaging system, to a wide variety of systems built on top of databases and in
    the cloud. Each of these systems exhibit some different behaviors when it comes
    to message reliability and durability. It is important to do some research into
    the way that the message distribution systems work as they may dictate how the
    application is constructed. They also implement different approaches to dealing
    with the underlying unreliability of applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: One thing which is a potential trip-up is that the order in which messages are
    received back on the client is not necessarily the order in which they were sent.
    To deal with this it is typical to include some sort of a correlation ID. When
    the event is raised it includes a known ID from the sender so that the correct
    event handler is used.
  prefs: []
  type: TYPE_NORMAL
- en: This bus is a highly naïve one as it has its routing hard coded. A real bus
    would probably allow the sender to specify the address of the end point for delivery.
    Alternately, the receivers could register themselves as interested in a specific
    sort of message. The bus would then be responsible for doing some limited routing
    to direct the message. Our bus is even named after the messages it deals with
    – certainly not a scalable approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we''ll implement the requestor. The requestor contains only two methods:
    one to send a request and the other to receive a response from the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The process message function currently just logs the response but it would likely
    do more in a real world scenario such as updating the UI or dispatching another
    message. The correlation ID is invaluable for understanding which sent message
    the reply is related to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the responder simply takes in the message and replies to it with another
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything in our example is synchronous but all it would take to make it asynchronous
    is to swap out the bus. If we''re working in node then we can do this using `process.nextTick`
    which simply defers a function to the next time through the event loop. If we''re
    in a web context, then web workers may be used to do the processing in another
    thread. In fact, when starting a web worker, the communication back and forth
    to it takes the form of a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach now allows other code to run before the message is processed.
    If we weave in some print statements after each bus send, then we get output like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the print statements are executed before the message processing
    as that processing happens on the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Publish-subscribe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've alluded to the publish-subscribe model elsewhere in this chapter. Publish-subscribe
    is a powerful tool for decoupling events from processing code.
  prefs: []
  type: TYPE_NORMAL
- en: At the crux of the pattern is the idea that, as a message publisher, my responsibility
    for the message should end as soon as I send it. I should not know who is listening
    to messages or what they will do with the messages. So long as I am fulfilling
    a contract to produce correctly formatted messages, the rest shouldn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: It is the responsibility of the listener to register its interest in the message
    type. You'll, of course, wish to register some sort of security to disallow registration
    of rogue services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update our service bus to do more, to do a complete job of routing and
    sending multiple messages. Let''s call our new method `Publish` instead of `Send`
    . We''ll keep `Send` around to do the sending functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Publish-subscribe](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The crow mail analogy we used in the previous section starts to fall apart here
    as there is no way to broadcast a message using crows. Crows are too small to
    carry large banners and it is very difficult to train them to do sky writing.
    I'm unwilling to totally abandon the idea of crows so let's assume that there
    exists a sort of crow broadcast centre. Sending a message here allows for it to
    be fanned out to numerous interested parties who have signed up for updates. This
    centre will be more or less synonymous with a bus.
  prefs: []
  type: TYPE_NORMAL
- en: We'll write our router so that it works as a function of the name of the message.
    One could route a message using any of its attributes. For instance, a listener
    could subscribe to all the messages called `invoicePaid` where the `amount` field
    is greater than $10000\. Adding this sort of logic to the bus will slow it down
    and make it far harder to debug. Really this is more the domain of business process
    orchestration engines than a bus. We'll continue on without that complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to set up is the ability to subscribe to published messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `Subscribe` function just adds a message handler and the name of a message
    to consume. The responders array is simply an array of handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a message is published we loop over the array and fire each of the handlers
    that have registered for messages with that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution here is deferred to the next tick. This is done using a closure
    to ensure that the correctly scoped variables are passed through. We can now change
    our `CrowMailResponder` to use the new `Publish` method instead of `Send` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Instead of allowing the `CrowMailRequestor` object to create its own bus as
    earlier, we need to modify it to accept an instance of `bus` from outside. We
    simply assign it to a local variable in `CrowMailRequestor` . Similarly, `CrowMailResponder`
    should also take in an instance of `bus` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of this we simply need to create a new bus instance and
    pass it into the requestor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ve also passed in two other responders that are interested in knowing
    about `KingdomInvaded` messages. They look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will now get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the messages are sent using `Send` . The responder or handler
    does its work and publishes a message that is passed onto each of the subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some great JavaScript libraries which make publish and subscribe
    even easier. One of my favorites is Radio.js. It has no external dependencies
    and its name is an excellent metaphor for publish subscribe. We could rewrite
    our preceding subscribe example like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then publish a message using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Fan out and in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fantastic use of the publish subscribe pattern is allowing you to fan out
    a problem to a number of different nodes. Moore's law has always been about the
    doubling of the number of transistors per square unit of measure. If you've been
    paying attention to processor clock speeds you may have noticed that there hasn't
    really been any significant change in clock speeds for a decade. In fact, clock
    speeds are now lower than they were in 2005.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that processors are "slower" than they once were. The work
    that is performed in each clock tick has increased. The number of cores has also
    jumped up. It is now unusual to see a single core processor; even in cellular
    phones dual core processors are becoming common. It is the rule, rather than the
    exception, to have computers that are capable of doing more than one thing at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, cloud computing is taking off. The computers you purchase
    outright are faster than the ones available to rent from the cloud. The advantage
    of cloud computing is that you can scale it out easily. It is nothing to provision
    a hundred or even a thousand computers to form a cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing software that can take advantage of multiple cores is the great computing
    problem of our time. Dealing directly with threads is a recipe for disaster. Locking
    and contention is far too difficult a problem for most developers: me included!
    For a certain class of problems, they can easily be divided up into sub problems
    and distributed. Some call this class of problems "embarrassingly parallelizable".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Messaging provides a mechanism for communicating the inputs and outputs from
    a problem. If we had one of these easily parallelized problems, such as searching,
    then we would bundle up the inputs into one message. In this case it would contain
    our search terms. The message might also contain the set of documents to search.
    If we had 10,000 documents then we could divide the search space up into, say,
    four collections of 2500 documents. We would publish five messages with the search
    terms and the range of documents to search as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fan out and in](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different search nodes will pick up the messages and perform the search. The
    results will then be sent back to a node that will collect the messages and combine
    them into one. This is what will be returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is a bit of an over simplification. It is likely that the receiving
    nodes themselves would maintain a list of documents over which they had responsibility.
    This would prevent the original publishing node from having to know anything about
    the documents over which it was searching. The search results could even be returned
    directly to the client that would do the assembling.
  prefs: []
  type: TYPE_NORMAL
- en: Even in a browser, the fan out and in approach can be used to distribute a calculation
    over a number of cores through the use of web workers. A simple example might
    take the form of creating a potion. A potion might contain a number of ingredients
    that can be combined to create a final product. It is quite computationally complicated
    combining ingredients so we would like to farm the process out to a number of
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a combiner that contains a `combine()` method as well as a `complete()`
    function that is called once all the distributed ingredients are combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to keep track of the number of workers outstanding, we use a simple
    counter. Because the main section of code is single threaded we have no risk of
    race conditions. Once the counter shows no remaining workers we can take whatever
    steps are necessary. The web worker looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In this case we simply put in a timeout to simulate the complex calculation
    needed to combine ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: The sub problems that are farmed out to a number of nodes don't have to be identical
    problems. However, they should be sufficiently complicated that the cost savings
    of farming them out are not consumed by the overhead of sending out a message.
  prefs: []
  type: TYPE_NORMAL
- en: Dead letter queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how hard I try I have yet to write any significant block of code that
    does not contain any errors. Nor have I been very good at predicting the wide
    range of crazy things users do with my applications. Why would anybody click that
    link 73 times in a row? I'll never know.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with failures in a messaging scenario is very easy. The core of the
    failure strategy is to embrace errors. We have exceptions for a reason and to
    spend all of our time trying to predict and catch exceptions is counter-productive.
    You'll invariably spend time building in catches for errors that never happen
    and miss errors that happen frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an asynchronous system, errors need not be handled as soon as they occur.
    Instead, the message that caused an error can be put aside to be examined by an
    actual human later. The message is stored in a dead letter, or error, queue. From
    there the message can easily be reprocessed after it has been corrected or the
    handler has been corrected. Ideally the message handler is changed to deal with
    messages exhibiting whatever property caused the errors. This prevents future
    errors and is preferable to fixing whatever generates the message as there is
    no guarantee that other messages with the same problem aren''t lurking somewhere
    else in the system. The workflow of a message through the queue and error queue
    can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dead letter queues](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As more and more errors are caught and fixed, the quality of the message handlers
    increases. Having an error queue of messages ensures that nothing important, such
    as a `BuySimonsBook` message is missed. This means that getting to a correct system
    becomes a marathon instead of a sprint. There is no need to rush a fix into production
    before it is properly tested. Progress towards a correct system is constant and
    reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Using a dead letter queue also improves the catching of intermittent errors.
    These are errors that result from an external resource being unavailable or incorrect.
    Imagine a handler that calls out to an external web service. In a traditional
    system, a failure in the web service guarantees failure in the message handler.
    However, with a message based system, the command can be moved back to the end
    of the input queue and tried again whenever it reaches the front of the queue.
    On the envelope we write down the number of times the message has been dequeued
    (processed). Once this dequeue count reaches a limit, like five, only then is
    the message moved into the true error queue.
  prefs: []
  type: TYPE_NORMAL
- en: This approach improves the overall quality of the system by smoothing over the
    small failures and stopping them from becoming large failures. In effect, the
    queues provide failure bulkheads to prevent small errors from overflowing and
    becoming large errors that might have an impact on the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Message replay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developers are working with a set of messages that produce an error, the
    ability to reprocess messages is also useful. Developers can take a snapshot of
    the dead letter queue and reprocess it in debug mode again and again until they
    have correctly processed the messages. A snapshot of a message can also make up
    a part of the testing for a message handler.
  prefs: []
  type: TYPE_NORMAL
- en: Even without there being an error, the messages sent to a service on a daily
    basis are representative of the normal workflows of users. These messages can
    be mirrored to an audit queue as they enter into the system. The data from the
    audit queue can be used for testing. If a new feature is introduced, then a normal
    day's workload can be played back to ensure that there has been no degradation
    in either correct behavior or performance.
  prefs: []
  type: TYPE_NORMAL
- en: Of course if the audit queue contains a list of every message, then it becomes
    trivial to understand how the application arrived at its current state. Frequently
    people implement history by plugging in a lot of custom code or by using triggers
    and audit tables. Neither of these approaches do as good of a job as messaging
    at understanding not only which data has changed, but why it has changed. Consider
    again the address change scenario, without messaging we will likely never know
    why an address for a user is different from the previous day.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a good history of changes to system data is storage intensive but
    that cost is easily paid by allowing auditors to see how and why each change was
    made. Well-constructed messages also allow for the history to contain the intent
    of the user making the change.
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to implement this sort of messaging system, in a single
    process it is difficult. Ensuring that messages are properly saved in the event
    of errors is difficult, as the entire process that deals with messages may crash,
    taking the internal message bus with it. Realistically if the replaying of messages
    sounds like something worth investigating then external message busses are the
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes and filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned earlier that messages should be considered immutable. This is not
    to say that messages cannot be rebroadcast with some properties changed or even
    broadcast as a new type of message. In fact, many message handlers may consume
    an event and then publish a new event after having performed some task.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you might consider the workflow for adding a new user to a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipes and filters](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the `CreateUser` command triggers a `UserCreated` event. That
    event is consumed by a number of different services. One of these services passes
    on user information to a select number of affiliates. As this service runs, it
    publishes its own set of events, one for each affiliate that receives the new
    user''s details. These events may, in turn, be consumed by other services which
    could trigger their own events. In this way changes can ripple through the entire
    application. However, no service knows more than what starts it and what events
    it publishes. This system has very low coupling. Plugging in new functionality
    is trivial and even removing functionality is easy: certainly easier than a monolithic
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: Systems constructed using messaging and autonomous components are frequently
    referred to as using **Service Oriented Architecture** ( **SOA** ) or Microservices.
    There remains a great deal of debate as to the differences, if indeed there are
    any, between SOA and Microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The altering and rebroadcasting of messages can be thought of as being a pipe
    or a filter. A service can proxy messages through to other consumers just as a
    pipe would do or can selectively republish messages as would be done by a filter.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As systems evolve, the information contained in a message may also change. In
    our user creation example, we might have originally been asking for a name and
    e-mail address. However, the marketing department would like to be able to send
    e-mails addressed to Mr. Jones or Mrs. Jones so we need to also collect the user's
    title. This is where message versioning comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a new message that extends the previous message. The message
    can contain additional fields and might be named using the version number or a
    date. Thus a message like `CreateUser` might become `CreateUserV1` or `CreateUser20140101`
    . Earlier I mentioned polymorphic messages. This is one approach to versioning
    messages. The new message extends the old so all the old message handlers still
    fire. However, we also talked about how there are no real polymorphic capabilities
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use upgrading message handlers. These handlers will take
    in a version of the new message and modify it to be the old version. Obviously
    the newer messages need to have at least as much data in them as the old version
    or have data that permits converting one message type to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a v1 message that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider a v2 message that extended it adding a user title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we would be able to write a very simple upgrader or downgrader that looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we simply modify the message and rebroadcast it.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messages create a well-defined interface between two different systems. Defining
    messages should be done by members of both teams. Establishing a common language
    can be tricky especially as terms are overloaded between different business units.
    What a sales department considers a customer may be totally different from what
    a shipping department considers a customer. Domain driven design provides some
    hints as to how boundaries can be established to avoid mixing terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a huge preponderance of queue technologies available. Each of them
    have a bunch of different properties around reliability, durability, and speed.
    Some of the queues support reading and writing JSON over HTTP: ideal for those
    interested in building JavaScript applications. Which queue is appropriate for
    your application is a topic for some research.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging and the associated patterns are large topics. Delving too deeply into
    messages will bring you in contact with **domain driven design** ( **DDD** ) and
    **command query responsibility segregation** ( **CQRS** ) as well as touching
    on high performance computing solutions.
  prefs: []
  type: TYPE_NORMAL
- en: There is substantial research and discussion ongoing as to the best way to build
    large systems. Messaging is one possible solution that avoids creating a big ball
    of mud that is difficult to maintain and fragile to change. Messaging provides
    natural boundaries between components in a system and the messages themselves
    provide for a consistent API.
  prefs: []
  type: TYPE_NORMAL
- en: Not every application benefits from messaging. There is additional overhead
    to building a loosely coupled application such as this. Applications that are
    collaborative, ones where losing data is especially undesirable, and those that
    benefit from a strong history story are good candidates for messaging. In most
    cases a standard CRUD application will be sufficient. It is still worthwhile to
    know about messaging patterns, as they will offer alternative thinking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we've taken a look at a number of different messaging patterns
    and how they can be applied to common scenarios. The differences between commands
    and events were also explored.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll look at some patterns for making testing code a little
    bit easier. Testing is jolly important so read on!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems like no book on programming these days is complete without at least
    some mention of microservices. For fear that this book could be singled out for
    ridicule as a non-conformant publication, a chapter has been included on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices are billed as the solution to the problems of monolithic applications.
    Likely every application you''ve dealt with has been a monolith: that is, the
    application has a single logical executable and is perhaps split into layers such
    as a user interface, a service or application layer, and a data store. In many
    applications these layers might be a web page, a server side application, and
    a database. Monoliths have their issues as I''m sure you''ve encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a monolithic application quickly becomes an exercise in limiting
    the impact of change. Frequently in such applications a change to one, seemingly
    isolated, corner of the application has an unintended effect on some other part
    of the application. Although there are many patterns and approaches to describe
    well isolated components, these often fall by the wayside inside a monolith. Often
    we take shortcuts which may save time now but will return to make our lives terrible
    down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic applications are also difficult to scale. Because we tend to have
    only three layers, we are limited to scaling each one of those layers. We can
    add more application servers if the middle tier is becoming slow or more web servers
    if the web tier is laggy. If the database is slow then we can increase the power
    of the database server. These scaling approaches are very large operations. If
    the only part of the application which is slow is signing up new users, then we
    really have no way to simply scale that one component. This means that components
    which are not frequently used (one might call these cold or cool components) must
    be able to scale as the whole application scales. This sort of scaling doesn't
    come for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that scaling from a single web server to multiple web servers introduces
    the problem of sharing sessions between many web servers. If we were, instead,
    to divide our application into a number of services, of which each acts as the
    canonical source of truth for a piece of data, then we could scale these sections
    independently. A service for logging users in, another service for saving and
    retrieving their preferences, yet another for sending out reminder e-mails about
    abandoned shopping carts, each one responsible for its own functions and own data.
    Each service stands alone as a separate application and may run on a separate
    machine. In effect we have taken our monolithic application and sharded it into
    many applications. Not only does each service have an isolated function but it
    also has its own datastore and could be implemented using its own technology.
    The difference between a monolith and microservices can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applications are written more by composing services than by writing singular
    monolithic applications. The UI of an application can even be created by asking
    a number of services to provide visual components to be slotted into a composite
    UI by some form of composing service.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js' lightweight approach to building applications with just the required
    components makes it an ideal platform to build lightweight microservices. Many
    microservice deployments make heavy use of HTTP to communicate between services
    while others rely more heavily on messaging systems such as **RabbitMQ** or **ZeroMQ**
    . These two communication methods may be mixed in deployments. One might split
    the technology used along the lines of using HTTP against services which are query-only,
    and messaging against services which perform some action. This is because messaging
    is more reliable (depending on your messaging system and configuration) than sending
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem that we've introduced a great deal of complexity into the
    system it is a complexity that is easier to manage with modern tooling. Very good
    tooling exists for managing distributed log files and for monitoring the performance
    of applications for performance issues. Isolating and running many applications
    with virtualization is more approachable than ever with containerization technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices may not be the solution to all our maintenance and scalability
    issues but they are certainly an approach that is viable for consideration. In
    this chapter we''ll explore some of the patterns that may assist in using microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message upgrader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because microservices are a relatively new development, there are likely to
    be many more patterns which emerge as more and more applications are created with
    the microservice approach. There is some similarity between the Microservices
    approach and **Service Oriented** **Architecture** ( **SOA** ). This means that
    there are likely some patterns from the SOA world which will be applicable in
    the microservices world.
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel that you recognize the name of this pattern, then you're correct.
    We discussed this pattern way back in [Chapter 4](text00035.html#page "Chapter 4. Structural
    Patterns") , *Structural Patterns* . In that application of the pattern we created
    a class which could direct the actions of a number of other classes providing
    a simpler API. Our example was that of an admiral who directed a fleet of ships.
    In the microservices world we can simply replace the concept of classes with that
    of services. After all, the functionality of a service is not that different from
    a microservice – they both perform a single action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might make use of a façade to coordinate the use of a number of other services.
    This pattern is a base pattern for many of the other patterns listed in this chapter.
    Coordinating services can be difficult, but by putting them behind a façade we
    can make the entire application much simpler. Let us consider a service which
    sends e-mails. Sending e-mails is quite a complex process which may involve a
    number of other services: a username to e-mail address translator, an anti-malware
    scanner, a spam checker, a formatter to message the e-mail body for various e-mail
    clients, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most clients who want to send e-mail don''t want to concern themselves with
    all of these other services so a façade e-mail-sending service can be put in place
    which holds the responsibility of coordinating other services. The coordination
    pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Service selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along the same lines as a façade we have the service selector pattern. In this
    pattern we have a service which fronts a number of other services. Depending on
    the message which arrives, a different service could be selected to respond to
    the initial request. This pattern is useful in upgrade scenarios and for experimentation.
    If you''re rolling out a new service and want to ensure that it will function
    correctly under load then you could make use of the service selector pattern to
    direct a small portion of your production traffic to the new service while monitoring
    it closely. Another application might be for directing specific customers or groups
    of customers to a different service. The distinguishing factor could be anything
    from directing people who have paid for your service toward faster end points,
    to directing traffic from certain countries to country-specific services. The
    service selector pattern can be seen in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service selector](Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aggregate services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data in a microservice architecture is owned by a single service, but there
    are many times when we might need to retrieve data from a number of different
    sources at once. Consider, again, a member of the Small Council in the land of
    Westeros. They may have a number of informants from whom they gather information
    about the workings of the kingdom. You can consider each informant to be its own
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Informants are a fantastic metaphor for microservices as each one is independent
    and holds its own data. Services may also fail from time to time just as informants
    may be captured and terminated. Messages are passed between informants just as
    they are among a collection of microservices. Each informant should know very
    little about how the rest of the informants work, and even, who they are – an
    abstraction which works for microservices too.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the aggregate service pattern, we ask each one of a collection of nodes
    to perform some action or return some piece of data. This is a fairly common pattern
    even outside the microservice world and is a special case of the façade or even
    adapter pattern. The aggregator requests information from a number of other services
    and then waits for them to return. Once all the data has been returned, then the
    aggregator may perform some additional tasks such as summarizing the data or counting
    records. The information is then passed back to the caller. The aggregator can
    be seen in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Aggregate services](Image00057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This pattern may also have some provision for dealing with slow-to-return services
    or failures of services. The aggregator service may return partial results or
    return data from a cache in the event that one of the child services reaches a
    timeout. In certain architectures, the aggregator could return a partial result
    and then return additional data to the caller when it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipeline is another example of a microservice connecting pattern. If you
    have made use of the shell on a *NIX system, then you have certainly piped the
    output of one command to another command. The programs on a *NIX system such as
    ls, sort, uniq, and grep are designed to perform just one task; their power comes
    from the ability to chain the tools together to build quite complex workflows.
    For instance, this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This command will list all the unique file extensions in the current directory.
    It does this by taking the list of files, then cutting them and taking the extension;
    this is then sorted and finally passed to `uniq` which removes duplicates. While
    I wouldn't suggest having a microservice for such trivial actions as sorting or
    deduplicating, you might have a series of services which build up more and more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a query service that returns a collection of company records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This record is returned by our company lookup service. Now we can pass this
    record onto our sales accounting service which will add a sales total to the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that record can be passed onto a sales estimate service, which further
    enhances the record with an estimate of 2017 sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This sort of progressive enhancement could be reversed too by a service that
    stripped out information which shouldn''t be presented to the users. The record
    might now become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have dropped the company identifier because it is an internal identifier.
    A microservice pipeline should be bidirectional so that a quantum of information
    is passed into each step in the pipeline and then passed back out again through
    each step. This affords services the opportunity to act upon the data twice, manipulating
    it as they see fit. This is the same approach used in many web servers where modules
    such as PHP are permitted to act upon the request and the response. A pipeline
    can be seen illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline](Image00058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Message upgrader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the highest-risk activities with some monolithic applications is upgrading.
    To do so you basically need to upgrade the entire application at once. With even
    a medium-sized application there are far too many aspects to reasonably test.
    Thus at some point you simply need to cut over from the old system to the new
    system. With a microservice approach, the cutover can be done for each individual
    service. Smaller services mean that the risk can be spread out over a long time
    and, should something go wrong, the source of the error can be more quickly pinpointed:
    the singular new component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At issue are the services which are still talking to the old version of the
    upgraded service. How can we continue to serve these services without having to
    update all those services too? If the interface to the service remains unchanged,
    say our service calculates the distance between two points on the earth and we
    change it from using a simple Pythagorean approach to using haversine (a formula
    to find the distance between two spots on a sphere), then there may be no need
    to make changes to the input and output formats. Frequently, however, this approach
    isn''t available to us as the message format must change. Even in the previous
    example there is a possibility of changing the output message. Haversine is more
    accurate than a Pythagorean approach so we could have more significant digits
    requiring a larger data type. There are two good approaches to deal with this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue to use the old version of our service and the new version. We can
    then slowly move the client services over to the new service as time permits.
    There are problems with this approach: we now need to maintain more code. Also,
    if the reason we change the service out was one which would not permit us to continue
    to run it (a security problem, termination of a dependent service, and so on)
    then we are at something of an impasse.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade messages and pass them on. In this approach we take the old message
    format and upgrade it to the new format. This is done by, you guessed it, another
    service. This service's responsibility is to take in the old message format and
    emit the new message format. At the other end you might need an equivalent service
    to downgrade messages back to the expected output format for older services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upgrader services should have a limited lifespan. Ideally we would want to
    make updates to the services which depend on deprecated services as quickly as
    possible. The small code footprint of microservices, coupled with the ability
    to rapidly deploy services, should make these sorts of upgrade much easier than
    those used to a monolithic approach might expect. An example message upgrader
    service can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message upgrader](Image00059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Failure patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already touched upon some of the ways of dealing with failures in microservices
    in this chapter. There are, however, a couple of more interesting approaches we
    should consider. The first of these is service degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Service degradation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern could also be called graceful degradation and is related to progressive
    enhancement. Let us hark back to the example of replacing the Pythagorean distance
    function with the haversine equivalent. If the haversine service is down for some
    reason, the less demanding function could be used in its place without a huge
    impact on users. In fact, they may not notice it at all. It isn't ideal that users
    have a worse version of the service but it is certainly more desirable than simply
    showing the user an error message. When the haversine service returns to life
    then we can stop using the less desirable service. We could have multiple levels
    of fallback allowing several different services to fail while we continue to present
    a fully functional application to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Another good application of this form of degradation is to fall back to more
    expensive services. I once had an application that sent SMS messages. It was quite
    important that these messages actually be sent. We used our preferred SMS gateway
    provider the majority of the time but, if our preferred service was unavailable,
    something we monitored closely, then we would fail over to using a different provider.
  prefs: []
  type: TYPE_NORMAL
- en: Message storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already drawn a bit of a distinction between services which are query-only
    and those which actually perform some lasting data change. When one of these updating
    services fails there is still a need to run the data change code at some point
    in the future. Storing these requests in a message queue allows them to be run
    later without risk of losing any of the ever-so important messages. Typically,
    when a message causes an exception it is returned to the processing queue where
    it can be retried.
  prefs: []
  type: TYPE_NORMAL
- en: There is an old saying that insanity is doing the same thing over again and
    expecting a different outcome. However, there are many transient errors which
    can be solved by simply performing the same action over again. Database deadlocks
    are a prime example of this. Your transaction may be killed to resolve a deadlock,
    in which case performing it again is, in fact, the recommended approach. However,
    one cannot retry messages ad infinitum so it is best to choose some relatively
    small number of retry attempts, three or five. Once this number has been reached
    then the message can be sent to a dead letter or poison message queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Poison messages, or dead letters as some call them, are messages which have
    actual legitimate reasons for failing. It is important to keep these messages
    around not only for debugging purposes but because the messages may represent
    a customer order or a change to a medical record: not data you can afford to lose.
    Once the message handler has been corrected these messages can be replayed as
    if the error never happened. A storage queue and message reprocessor can be seen
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message storage](Image00060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Message replay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not a real production pattern, a side-effect of having a message-based
    architecture around all the services which change data is that you can acquire
    the messages for later replay outside of production. Being able to replay messages
    is very handy for debugging complex interactions between numerous services as
    the messages contain almost all the information to set up a tracing environment
    identical to production. Replay capabilities are also very useful for environments
    where one must be able to audit any data changes to the system. There are other
    methods to address such audit requirements but a very solid message log is simply
    a delight to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Indempotence of message handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final failure pattern we'll discuss is idempotence of message handling.
    As systems grow larger it is almost certain that a microservices architecture
    will span many computers. This is even more certain due to the growing importance
    of containers, which can, ostensibly, be thought of as computers. Communicating
    between computers in a distributed system is unreliable; thus, a message may end
    up being delivered more than once. To handle such an eventuality one might wish
    to make messaging handling idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more about the unreliability of distributed computing, I cannot recommend
    any paper more worth reading than *Falacies of Distributed Computing Explained*
    by Arnon Rotem-Gal-Oz at [http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Idempotence means that a message can be processed many times without changing
    the outcome. This can be harder to achieve than one might realize, especially
    with services which are inherently non-transactional such as sending e-mails.
    In these cases, one may need to write a record that an e-mail has been sent to
    a database. There are some scenarios in which the e-mail will be sent more than
    once, but a service crashing in the critical section between the e-mail being
    sent and the record of it being written is unlikely. The decision will have to
    be made: is it better to send an e-mail more than once or not send it at all?'
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you think of a microservice as a class and your microservice web as an application,
    then it rapidly becomes apparent that many of the same patterns we've seen elsewhere
    in the book are applicable to microservices. Service discovery could be synonymous
    with dependency injection. Singleton, decorator, proxy; all of them could be applicable
    to the microservice world just as they are within the boundaries of a process.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that many of these patterns are somewhat chatty,
    sending significant data back and forth. Within a process there is no overhead
    to passing around pointers to data. The same is not true of microservices. Communicating
    over the network is likely to incur a performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a fascinating idea and one which is more likely to be realized
    in the next few years. It is too early to tell if this is simply another false
    turn on the way to properly solving software engineering or a major step in the
    right direction. In this chapter we've explored a few patterns which may be of
    use should you embark upon a journey into the microservices world. Because we're
    only on the cusp of microservices becoming mainstream, it is likely that, more
    than any other chapter of this book, the patterns here will quickly become dated
    and found to be suboptimal. Remaining vigilant with regard to developments and
    being aware of the bigger picture when you're developing is highly advisable.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12. Patterns for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book we've been pushing the idea that JavaScript is no longer
    a toy language with which we can't do useful things. Real world software is being
    written in JavaScript right now and the percentage of applications using JavaScript
    is only likely to grow over the next decade.
  prefs: []
  type: TYPE_NORMAL
- en: With real software comes concerns about correctness. Manually testing software
    is painful and, weirdly, error-prone. It is far cheaper and easier to produce
    unit and integration tests that run automatically and test various aspects of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless tools available for testing JavaScript, from test runners
    to testing frameworks; the ecosystem is a rich one. We'll try to maintain a more
    or less tool-agnostic approach to testing in this chapter. This book does not
    concern itself with which framework is the best or friendliest. There are overarching
    patterns that are common to testing as a whole. It is those that we'll examine.
    We will touch on some specific tools but only as a shortcut to having to write
    all our own testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We computer programmers are, as a rule, highly analytical people. This means
    that we're always striving to categorize and understand concepts. This has led
    to our developing some very interesting global techniques that can be applied
    outside computer programming. For instance, agile development has applications
    in general society but can trace its roots back to computing. One might even argue
    that the idea of patterns owes much of its popularity to it being used by computer
    programmers in other walks of life.
  prefs: []
  type: TYPE_NORMAL
- en: 'This desire to categorize has led to the concept of testing code being divided
    up into a number of different types of tests. I''ve seen as many as eight different
    categories of tests from unit tests, right the way up to workflow tests and GUI
    tests. This is, perhaps, an overkill. It is much more common to think about having
    three different categories of test: unit, integration, and user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The testing pyramid](Image00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unit tests form the foundation of the pyramid. They are the most numerous,
    the easiest to write, and the most granular in the errors they give. An error
    in a unit test will allow you to find the individual method that has an error
    in it. As we move up the pyramid, the number of tests falls along with the granularity
    while the complexity of each test increases. At a higher level, when a test fails
    we might only be able to say: "There is an issue with adding an order to the system".'
  prefs: []
  type: TYPE_NORMAL
- en: Testing in the small with unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To many, unit testing is a foreign concept. This is understandable as it is
    a topic which is poorly taught in many schools. I know that I've done six years
    of higher education in computing science without it being mentioned. It is unfortunate
    because delivering a quality product is a pretty important part of any project.
  prefs: []
  type: TYPE_NORMAL
- en: For those who know about unit testing, there is a big barrier to adoption. Managers,
    and even developers, frequently see unit testing, and automated testing as a whole,
    as a waste of time. After all you cannot ship a unit test to your customer nor
    do most customers care whether their product has been properly unit tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is notoriously difficult to define. It is close enough to integration
    testing that people slip back and forth between the two easily. In the seminal
    book; *The Art of Unit Testing* , *Roy Osherove* , the author defines a unit test
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A unit test is an automated piece of code that invokes a unit of work in the
    system and then checks a single assumption about the behavior of that unit of
    work.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exact size of a unit of work is up for some debate. Some people restrict
    it to a single function or a single class, while others allow a unit of work to
    span multiple classes. I tend to think that a unit of work that spans multiple
    classes can actually be broken into smaller, testable units.
  prefs: []
  type: TYPE_NORMAL
- en: The key to unit testing is that it tests a small piece of functionality and
    it quickly tests the functionality in a repeatable, automated fashion. Unit tests
    written by one person should be easily runnable by any other member of the team.
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing we want to test small pieces of functionality because we believe
    that if all the components of a system work correctly then the system as a whole
    will work. This is not the whole truth. The communication between modules is just
    as likely to fail as a function within the unit. This is why we want to write
    tests on several levels. Unit tests check that the code we're writing right now
    is correct. Integration testing tests entire workflows through the application
    and will uncover problems in the interaction of units.
  prefs: []
  type: TYPE_NORMAL
- en: The test-driven development approach suggests writing tests at the same time
    as we write code. While this gives us great confidence that the code we're writing
    is correct, the real advantage is that it helps drive good architecture. When
    code has too many interdependencies it is far harder to test than well-separated
    modular code. A lot of the code that developers write goes unread by anybody ever
    again. Unit tests provide a useful way of keeping developers on the right path
    even in cases where they know that nobody will ever see their code. There is no
    better way to produce a quality product than to tell people they are going to
    be checked on it, even if the checker happens to be an automated test.
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be run both while developing new code and in an automatic fashion
    on the build machines. If every time a developer checks in a change, the entire
    project is built and tested, then some reassurance can be provided that the newly
    checked-in code is correct. From time to time the build will break and that will
    be a flag that something that was just added was in error. Often the code that
    is broken may not even be proximal to the code changed. An altered return value
    may percolate through the system and manifest itself somewhere wholly unexpected.
    Nobody can keep anything more than the most trivial system in their mind at any
    one time. Testing acts as a sort of second memory, checking and rechecking assumptions
    made previously.
  prefs: []
  type: TYPE_NORMAL
- en: Failing the build as soon as an error occurs shortens the time it takes between
    an error being made in the code and it being found and fixed. Ideally the problem
    will still be fresh in the developer's mind so the fix can easily be found. If
    the errors were not discovered until months down the road, the developer will
    certainly have forgotten what s/he was working on at the time. The developer may
    not even be around to help solve the problem, throwing somebody who has never
    seen the code in to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange-Act-Assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building tests for any piece of code, a very common approach to follow
    is that of Arrange-Act-Assert. This describes the different steps that take place
    inside a single unit test.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is set up a test scenario (arrange). This step can consist
    of a number of actions and may involve putting in place fake objects to simulate
    real objects as well as creating new instances of the subject under test. If you
    find that your test setup code is long or involved, it is likely a smell and you
    should consider refactoring your code. As mentioned in the previous section, testing
    is helpful for driving not just correctness but also architecture. Difficult-to-write
    tests are indicative that the architecture is not sufficiently modular.
  prefs: []
  type: TYPE_NORMAL
- en: Once the test is set up then the next step is to actually execute the function
    we would like to test (act). The act step is usually very short, in many cases
    no more than a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The final part is to check to make sure that the result of the function or the
    state of the world is as you would expect (assert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple example of this might be a castle builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'This class simply builds a new castle of a specific size. We want to make sure
    that no shenanigans are going on and that when we build a castle of size `10`
    we get a castle of size `10` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that in the last example we made use of a function called
    `assertEquals` . An assert is a test that, when it fails, throws an exception.
    There is currently no built-in assert functionality in JavaScript, although there
    is a proposal in the works to add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, building an assert is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: It is helpful to mention, in the error, the actual value as well as the expected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: There is a great number of assertion libraries in existence. Node.js ships with
    one, creatively called `assert.js` . If you end up using a testing framework for
    JavaScript it is likely that it will also contain an assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think of the interdependencies between objects in an application as a
    graph it becomes quickly apparent that there are a number of nodes that have dependencies
    on, not just one, but many other objects. Attempting to place an object with a
    lot of dependencies under test is challenging. Each of the dependent objects must
    be constructed and included in the test. When these dependencies interact with
    external resources such as the network or file system, the problem becomes intractable.
    Pretty soon we're testing the entire system at a time. This is a legitimate testing
    strategy, known as **integration testing** , but we're really just interested
    in ensuring that the functionality of a single class is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing tends to be slower to execute than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subject of a test can have a large dependency graph that makes testing
    it difficult. You can see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fake objects](Image00062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to find a way to isolate the class under test so that we don''t have
    to recreate all the dependencies, including the network. We can think of this
    approach as adding bulkheads to our code. We will insert bulkheads to stop tests
    from flowing over from one class to many. These bulkheads are similar to how oil
    tankers maintain separation to limit the impact of spills and maintain weight
    distribution as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fake objects](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Image courtesy of [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To this end we can use fake objects that have a limited set of functionalities
    in place of the real objects. We'll look at three different methods of creating
    fake objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the, rather niftily named, test spy.
  prefs: []
  type: TYPE_NORMAL
- en: Test spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spy is an approach that wraps all the methods of an object and records the
    inputs and outputs from that method as well as the number of calls. By wrapping
    the calls, it is possible to examine exactly what was passed in and what came
    out of the function. Test spies can be used when the exact inputs into a function
    are not known beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: In other languages, building test spies requires reflection and can be quite
    complicated. We can actually get away with making a basic test spy in no more
    than a couple of lines of code. Let's experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll need a class to intercept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we would like to spy on this function. Because functions are first class
    objects in JavaScript we can simply rejigger the `SpyUpon` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we take the existing function and give it a new name. Then we create a
    new function that calls the renamed function and also records some things. After
    the function has been called we can examine the various properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code in node gets us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Using this technique, it is possible to get all sorts of insight into how a
    function is used. There are a number of libraries that support creating test spies
    in a more robust way than our simple version here. Some provide tools for recording
    exceptions, the number of times called, and the arguments for each call.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stub** is another example of a fake object. We can use stubs when we have
    some dependencies in the subject under test that need to be satisfied with an
    object that returns a value. They can also be used to provide a bulkhead to stop
    computationally expensive or I/O reliant functions from being run.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs can be implemented in much the same way that we implemented spies. We
    just need to intercept the call to the method and replace it with a version that
    we wrote. However, with stubs we actually don't call the replaced function. It
    can be useful to keep the replaced function around just in case we need to restore
    the functionality of the stubbed out class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an object that depends on another object for part of its
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This knight object takes a `credentialFactory` argument as part of its constructor.
    By passing in the object we exteriorize the dependency and remove the responsibility
    for creating `credentialFactory` from the knight. We've seen this sort of inversion
    of control previously and we'll look at it in more detail in the next chapter.
    This makes our code more modular and testing far easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we want to test the knight without worrying about how a credential
    factory works, we can use a fake object, in this case a stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This stub is a very simple one that simply returns a standard new credential.
    Stubs can be made quite complicated if there need to be multiple calls to it.
    For instance, we could rewrite our simple stub as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the stub returns a different sort of credential every time
    it is called. On the third call it returns null. As we set up the class using
    an inversion of control, writing a test is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Because there is no hard typing system in JavaScript, we can build stubs without
    worrying about implementing interfaces. There is also no need to stub an entire
    object but only the function in which we're interested.
  prefs: []
  type: TYPE_NORMAL
- en: Mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final type of fake object is a **mock** . The difference between a mock
    and a stub is where the verification is done. With a stub, our test must check
    if the state is correct after the act. With a mock object, the responsibility
    for testing the asserts falls to the mock itself. Mocks are another place where
    it is useful to leverage a mocking library. We can, however, build the same sort
    of thing, simply, ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This `mockCredentialsFactory` class takes on the responsibility of verifying
    the correct functions were called. This is a very simple sort of approach to mocking
    and can be used as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This is a static mock that keeps the same behavior every time it is used. It
    is possible to build mocks that act as recording devices. You can instruct the
    mock object to expect certain behaviors and then have it automatically play them
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this is taken from the documentation for the mocking library;
    Sinon. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen a number of methods for creating fake objects in JavaScript. When
    creating the spy, we made use of a method called **monkey patching** . Monkey
    patching allows you to dynamically change the behavior of an object by replacing
    its functions. We can use this sort of approach without having to revert to full
    fake objects. Any existing object can have its behavior changed in isolation using
    this approach. This includes built-in objects such as strings and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of the JavaScript in use today is used on the client and is used
    to interact with elements that are visible on the screen. Interacting with the
    page flows through a model of the page known as **Document Object Model** ( **DOM**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Every element on the page is represented in the DOM. Whenever a change is made
    to the page, the DOM is updated. If we add a paragraph to the page, then a paragraph
    is added to the DOM. Thus if our JavaScript code adds a paragraph, checking that
    it does so is simply a function of checking the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this requires that a DOM actually exists and that it is formed
    in the same way that it is on the actual page. There are a number of approaches
    to testing against a page.
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most naïve approach is to simply automate the browser. There are a few projects
    out there that can help with this task. One can either automate a fully-fledged
    browser such as Firefox, Internet Explorer, or Chrome, or one can pick a browser
    that is headless. The fully-fledged browser approach requires that a browser be
    installed on the test machine and that the machine be running in a mode that has
    a desktop available.
  prefs: []
  type: TYPE_NORMAL
- en: Many Unix-based build servers will not have been set up to show a desktop as
    it isn't needed for most build tasks. Even if your build machine is a Windows
    one, the build account frequently runs in a mode that has no ability to open a
    window. Tests using full browsers also have a tendency to break, to my mind. Subtle
    timing issues crop up and tests are easily interrupted by unexpected changes to
    the browser. It is a frequent occurrence that manual intervention will be required
    to unstick a browser that has ended up in an incorrect state.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, efforts have been made to decouple the graphical portions of a
    web browser from the DOM and JavaScript. For Chrome this initiative has resulted
    in PhantomJS and for Firefox SlimerJS.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the sorts of test that require a full browser require some navigation
    of the browser across several pages. This is provided for in the headless browsers
    through an API. I tend to think of tests at this scale as integration tests rather
    than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical test using PhantomJS and the CasperJS library that sits on top of
    the browser might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This would test that entering a value into the search box on Google changes
    the `aria-haspopup` property from `false` to `true` .
  prefs: []
  type: TYPE_NORMAL
- en: Testing things this way puts a great deal of reliance on the DOM not changing
    too radically. Depending on the selectors used to find elements on the page, a
    simple change to the style of the page could break every test. I like to keep
    tests of this sort away from the look of that page by never using CSS properties
    to select elements. Instead make use of IDs or, better yet, data-* attributes.
    We don't necessarily have the luxury of that when it comes to testing existing
    pages but certainly for new pages it is a good plan.
  prefs: []
  type: TYPE_NORMAL
- en: Faking the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much of the time, we don't need a full page DOM to perform our tests. The page
    elements we need to test are part of a section on the page instead of the entire
    page. A number of initiatives exist that allow for the creation of a chunk of
    the document in pure JavaScript. `jsdom` for instance is a method for injecting
    a string of HTML and receiving back a fake window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, modified slightly from their README, they create some HTML
    elements, load JavaScript, and test that it returns correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: If your JavaScript is focused on a small section of the page, perhaps you're
    building custom controls or web components, then this is an ideal approach.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final approach to dealing with graphical JavaScript is to stop interacting
    directly with elements on the page. This is the approach that many of the more
    popular JavaScript frameworks of today use. One simply updates a JavaScript model
    and this model then updates the page through the use of some sort of MV* pattern.
    We looked at this approach in some detail some chapters ago.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in this case becomes quite easy. Our complicated JavaScript can simply
    be tested by building a model state prior to running the code and then testing
    to see if the model state after running the code is as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example we could have a model that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code for it might look as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: As everything on the page is manipulated, through the bindings to the model,
    we can be confident that changes in the model are correctly updating the page.
  prefs: []
  type: TYPE_NORMAL
- en: Some would argue that we've simply shifted the problem. Now the only place for
    errors is if the binding between the HTML and the model is incorrect. So we also
    need to test if we have bindings correctly applied to the HTML. This falls to
    higher-level testing that can be done more simply. We can cover far more with
    a higher-level test than with a lower-level one, although at the cost of knowing
    exactly where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: You're never going to be able to test everything about an application but the
    smaller you can make the untested surface, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have seen tests where people split up the Arrange-Act-Assert by putting in
    place comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: You're going to wear your fingers to the bone typing those comments for every
    single test. Instead I just split them up with a blank line. The separation is
    clear and anybody who knows Arrange-Act-Assert will instantly recognize what it
    is that you're doing. You'll have seen the example code in this chapter split
    up in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless JavaScript testing libraries available to make your life
    easier. Choosing one may depend on your preferred style. If you like a gherkin-style
    syntax then cuumber.js might be for you. Otherwise try mocha, either on its own,
    or with the chai BDD style assertion library , which is is fairly nice. There
    are also testing frameworks such as Protractor which are specific to Angular apps
    (although you can use it to test other frameworks with a bit of work). I'd suggest
    taking a day and playing with a few to find your sweet spot.
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests, I tend to name them in a way that makes it obvious that
    they are tests and not production code. For most JavaScript I follow camel case
    naming conventions such as `testMapping` . However, for test methods I follow
    an underscored naming pattern `When_building_a_castle_size_should_be_correctly_set`
    . In this way the test reads more like a specification. Others have different
    approaches to naming and there is no "right" answer, so feel free to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing a quality product is always going to require extensive and repeated
    testing; this is exactly the sort of thing computers are really good at. Automate
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Testing JavaScript code is an up-and-coming thing. The tooling around, mocking
    out objects, and even the tools for running tests are undergoing constant changes.
    Being able to use tools such as Node.js to run tests quickly and without having
    to boot up an entire browser is stunningly helpful. This is an area that is only
    going to improve over the next few years. I am enthused to see what changes come
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll take a look at some advanced patterns in JavaScript
    that you might not want to use every day but are very handy.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13. Advanced Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hesitated when naming this chapter, *Advanced Patterns* . This isn't really
    about patterns that are more complicated or sophisticated than other patterns.
    It is about patterns that you wouldn't use very frequently. Frankly, coming from
    a static programming language background, some of them seem crazy. Nonetheless
    they are completely valid patterns and are in use within big name projects everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live post processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the topics we've been talking about continuously during this book is
    the importance of making your code modular. Small classes are easier to test,
    provide better reuse, and promote better collaboration for teams. Modular, loosely
    coupled code is easier to maintain, as changes can be limited. You may remember
    the example of a ripstop we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: With modular code of this sort we see a lot of inversion of control. Classes
    have functionality inserted into them through passing additional classes by their
    creators. This moves the responsibility for how some portions of the child class
    work to the parent. For small projects, this is a pretty reasonable approach.
    As projects get more complicated and dependency graphs get more complicated, manually
    injecting the functionality becomes more and more difficult. We are still creating
    objects all over the code base, passing them into created objects so the coupling
    problem still exists, we've just shifted it up a level.
  prefs: []
  type: TYPE_NORMAL
- en: If we think of object creation as a service, then a solution to this problem
    presents itself. We can defer the object creation to a central location. This
    allows us to change the implementations for a given interface in one place, simply
    and easily. It also allows us to control object lifetime so that we can reuse
    objects or recreate them every time they are used. If we need to replace one implementation
    of an interface with another implementation, then we can be confident that we
    need to only change it in one location. Because the new implementation still fulfils
    the contract, that is the interface, then all the classes that make use of the
    interface can remain ignorant of the change.
  prefs: []
  type: TYPE_NORMAL
- en: What's more is that by centralizing object creation it becomes easier to construct
    objects that depend on other objects. If we look at a dependency graph for a module
    such as the `UserManager` variable, it is clear that it has a number of dependencies.
    These dependencies may have additional dependencies and so forth. To build a `UserManager`
    variable, we not only need to pass in the database, but also `ConnectionStringProvider`
    , `CredentialProvider` , and `ConfigFileConnectionStringReader` . Goodness, that
    is going to be a lot of work to create instances of all of these. If we, instead,
    register implementations of each of these interfaces in a registry, then we need
    only go to the registry to look up how to make them. This can be automated and
    the dependencies automatically get injected to all dependencies without a need
    to explicitly create any of them. This method of solving dependencies is commonly
    referred to as 'solving the transitive closure'.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency injection framework handles the responsibility of constructing
    objects. On application set up the dependency injection framework is primed with
    a combination of names and objects. From this, it creates a registry or a container.
    When constructing an object through the container, the container looks at the
    signature of the constructor and attempts to satisfy the arguments on the constructor.
    Here is an illustration of a dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency injection](Image00064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In more statically typed languages such as C# or Java, dependency injection
    frameworks are commonplace. They usually work by using reflection, a method of
    using code to extract structural information from other code. When building the
    container, one specifies an interface and one or more concrete classes that can
    satisfy the interface. Of course using interfaces and reflection to perform dependency
    injection requires that the language support both interfaces and introspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no way to do this in JavaScript. JavaScript has neither direct introspection
    nor a traditional object inheritance model. A common approach is to use variable
    names to solve the dependency problem. Consider a class that has a constructor
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes two arguments that are very specifically named. When we
    construct this class through the dependency injection, these two arguments are
    satisfied by looking through the names registered with the container and passing
    them into the constructor. However, without introspection how can we extract the
    names of the parameters so we know what to pass into the constructor?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is actually amazingly simple. The original text of any function
    in JavaScript is available by simply calling `toString` on it. So, for the constructor
    given in the preceding code, we can do just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Now we can parse the string returned to extract the names of the parameters.
    Care must be taken to parse the text correctly, but it is possible. The popular
    JavaScript framework, Angular, actually uses this method to do its dependency
    injection. The result remains relatively preformat. The parsing really only needs
    to be done once and the results cached, so no additional penalty is incurred.
  prefs: []
  type: TYPE_NORMAL
- en: I won't go through how to actually implement the dependency injection, as it
    is rather tedious. When parsing the function, you can either parse it using a
    string-matching algorithm or build a lexer and parser for the JavaScript grammar.
    The first solution seems easier but it is likely a better decision to try to build
    up a simple syntax tree for the code into which you're injecting. Fortunately,
    the entire method body can be treated as a single token, so it is vastly easier
    than building a fully-fledged parser.
  prefs: []
  type: TYPE_NORMAL
- en: If you're willing to impose a different syntax on the user of your dependency
    injection framework then you can even go so far as to create your own syntax.
    The Angular 2.0 dependency injection framework, `di.js` , supports a custom syntax
    for denoting both places where objects should be injected and for denoting which
    objects satisfy some requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using it as a class into which some code needs to be injected, looks like this
    code, taken from the `di.js` examples page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CoffeeMaker` instance might look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: You might have also noticed that this example makes use of the `class` keyword.
    This is because the project is very forward looking and requires the use of `traceur.js`
    to provide for ES6 class support. We'll learn about `traceur.js` file in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Live post processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be apparent now that running `toString` over a function in JavaScript
    is a valid way to perform tasks. It seems odd but, really, writing code that emits
    other code is as old as Lisp or possibly older. When I first came across how dependency
    injection works in AngularJS, I was both disgusted at the hack and impressed by
    the ingenuity of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is possible to do dependency injection by interpreting code on the fly,
    then what more could we do with it? The answer is: quite a lot. The first thing
    that comes to mind is that you could write domain specific languages.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about DSLs in [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , and even created a very simple one. With
    the ability to load and rewrite JavaScript, we can take advantage of a syntax
    that is close to JavaScript but not wholly compatible. When interpreting the DSL,
    our interpreter would write out additional tokens needed to convert the code to
    actual JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the nice features of TypeScript that I''ve always liked is that parameters
    to the constructors that are marked as public are automatically transformed into
    properties on the object. For instance, the TypeScript code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiles to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We could do something similar in our DSL. Starting with the `Axe` definition
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: We've used a comment here to denote that `headHeight` should be public. Unlike
    the TypeScript version, we would like our source code to be valid JavaScript.
    Because comments are included in the `toString` function this works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to actually emit new JavaScript from this. I''ve taken
    a naïve approach and used regular expressions. This approach would quickly get
    out of hand and probably only works with the well-formed JavaScript in the `Axe`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Here we extract the parameters to the function and check for those that have
    the `public` annotation. The result of this function can be passed back into eval
    for use in the current object or written out to a file if we're using this function
    in a pre-processor. Typically use of eval in JavaScript is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: There are tons of different things that can be done using this sort of processing.
    Even without string post-processing there are some interesting programming concept
    we can explore by just wrapping methods.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modularity of software is a great feature, the majority of this book has been
    about modularity and its advantages. However, there are some features of software
    that span the entire system. Security is a great example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to have similar security code in all the modules of the application
    to check that people are, in fact, authorized to perform some action. So if we
    have a function of the sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is a fair bit of code in place to check if a user is
    authorized. This same boilerplate code is used elsewhere in the application. In
    fact, with this being a high security application, the security checks are in
    place in every public function. All is well until we need to make a change to
    the common security code. This change needs to take place in every single public
    function in the application. We can refactor our application all we want, but
    the truth remains: we need to have at least some code in each of the public methods
    to perform a security check. This is known as a cross-cutting concern.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other instances of cross-cutting concerns in most large applications.
    Logging is a great example, as is database access and performance instrumenting.
    **Aspect oriented programming** ( **AOP** ) presents a way to minimize the repeated
    code through a process known as **weaving** .
  prefs: []
  type: TYPE_NORMAL
- en: 'An aspect is a piece of code that can intercept method calls and change them.
    On the .Net platform there is a tool called PostSharp that does aspect weaving
    and, on the Java platform, one called AspectJ. These tools hook into the build
    pipeline and modify the code after it has been transformed into instructions.
    This allows code to be injected wherever needed. The source code appears unchanged
    but the compiled output now includes calls to the aspect. Aspects solve the cross
    cutting concern by being injected into existing code. Here you can see the application
    of an aspect to a method through a weaver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Aspect oriented programming](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course we don't have the luxury of a design-time compile step in most JavaScript
    workflows. Fortunately, we've already seen some approaches that would allow us
    to implement cross cuts using JavaScript. The first thing we need is the wrapping
    of methods that we saw in the testing chapter. The second is the `tostring` abilities
    from earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are some AOP libraries already in existence for JavaScript that may be
    a good bet to explore. However, we can implement a simple interceptor here. First
    let's decide on the grammar for requesting injection. We'll use the same idea
    of comments from earlier to denote methods that require interception. We'll just
    make the first line in the method a comment that reads `aspect(<name of aspect>)`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll take a slightly modified version of our same `GoldTransfer`
    class from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve stripped out all the security stuff that used to exist in it and added
    a console log so we can see that it actually works. Next we''ll need an aspect
    to weave into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'For this we use a simple class that has a `BeforeCall` and `AfterCall` method,
    one which is called before and one which is called after the original method.
    We don''t need to use eval in this case so the interceptions are safer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: This interceptor can easily be modified to a shortcut and return something before
    the main method body is called. It can also be changed so that the output of the
    function can be modified by simply tracking the output from the wrapped method
    and then modifying it in the `AfterCall` method.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly lightweight example of AOP. There are some frameworks in existence
    for JavaScript AOP, but perhaps the best approach is to make use of a precompiler
    or macro language.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw much earlier in this book, the inheritance pattern for JavaScript
    is different from the typical pattern seen in languages like C# and Java. JavaScript
    uses prototype inheritance that allows adding functions to a class quite easily
    and from multiple sources. Prototype inheritance allows for adding methods from
    multiple sources in a similar fashion to the much-maligned multiple-inheritance.
    The primary criticism of multiple inheritance is that it is difficult to understand
    which overload of a method will be called in a situation. This problem is somewhat
    alleviated in a prototype inheritance model. Thus we can feel comfortable using
    the approach of adding functionality from several sources, which is known as mixins.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a chunk of code which can be added to existing classes to expand
    their functionality. They make the most sense in scenarios where the functions
    need to be shared between disparate classes where an inheritance relationship
    is too strong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a scenario where this sort of functionality would be handy.
    In the land of Westeros, death is not always as permanent as in our world. However,
    those who return from the dead may not be exactly as they were when they were
    alive. While much of the functionality is shared between `Person` and `ReanimatedPerson`
    , they are not close enough to have an inheritance relationship. In this code
    you can see the `extend` function of underscore used to add mixins to our two
    people classes. It is possible to do this without `underscore` but, as mentioned
    earlier, there are some complex edge cases around `extends` which make using a
    library handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Mixins provide a mechanism to share functionality between diverse objects but
    do pollute the prototype structure.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preprocessing code through macros is not a new idea. It was, and probably still
    is, very popular for C and C++. In fact, if you take a look at some of the source
    code for the Gnu utilities for Linux they are written almost entirely in macros.
    Macros are notorious for being hard to understand and debug. For a time, newly-created
    languages like Java and C# did not support macros for exactly this reason.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, even more recent languages like Rust and Julia have brought
    the idea of macros back. These languages were influenced by the macros from the
    Scheme language, a dialect of Lisp. The difference between C macros and Lisp/Scheme
    macros is that the C versions are textual while the Lisp/Scheme ones are structural.
    This means that C macros are just glorified find/replace tools while Scheme macros
    are aware of the **abstract syntax tree** ( **AST** ) around them, allowing them
    to be much more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The AST for Scheme is a far simpler construct than that of JavaScript. Nonetheless,
    there is a very interesting project called `Sweet.js` that tries to create structural
    macros for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sweet.js` plugs into the JavaScript build pipeline and modified JavaScript
    source code using one or more macros. There are a number of fully-fledged JavaScript
    transpilers, that is compilers that emit JavaScript. These compilers are problematic
    for sharing code between multiple projects. Their code is so different that there
    is no real way to share it. `Sweet.js` supports multiple macros being expanded
    in a single step. This allows for much better code sharing. The reusable bits
    are a smaller size and more easy to run together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of `Sweet.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The macro here provides ECMAScript-2015-style deconstructors that split an array
    into tree fields. The macro matches an array assignment and also regular assignment.
    For regular assignment the macro simply returns the identity, while for assignment
    of an array it will explode the text and replace it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you run it over the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: This is just one example macro. The power of macros is really quite spectacular.
    Macros can create an entirely new language or change very minor things. They can
    be easily plugged in to fit any sided requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using name-based dependency injection allows for conflicts between names. In
    order to avoid conflicts it may be worth prefacing your injected arguments with
    a special character. For instance, AngularJS uses the `$` sign to denote an injected
    term.
  prefs: []
  type: TYPE_NORMAL
- en: Several times in this chapter I've mentioned the JavaScript build pipeline.
    It may seem odd that we have to build an interpreted language. However, there
    are certain optimizations and process improvements that may result from building
    JavaScript. There are a number of tools that can be used to help building JavaScript.
    Tools such as Grunt and Gulp are specifically designed to perform JavaScript and
    web tasks but you can also make use of traditional build tools such as Rake, Ant,
    or even Make.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered a number of advanced JavaScript patterns. Of these
    patterns it's my belief that dependency injection and macros are the most useful
    to us. You may not necessarily want to use them on every project. When approaching
    problems simply being aware of the possible solutions may change your approach
    to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book I have talked extensively about the next versions of JavaScript.
    However, you don't need to wait until some future time to make use of many of
    these tools. Today, there are ways to compile newer versions of JavaScript down
    to the current version of JavaScript. The final chapter will explore a number
    of these tools and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14. ECMAScript-2015/2016 Solutions Today
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I cannot count the number of times I have mentioned upcoming versions of JavaScript
    in this book, rest assured that it's a large number. It is somewhat frustrating
    that the language is not keeping pace with the requirements of application developers.
    Many of the approaches we've discussed become unnecessary with a newer version
    of JavaScript. There are, however, some ways to get the next version of JavaScript
    working today.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at a couple of these, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Typescript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BabelJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no shortage of languages that compile to JavaScript. CoffeeScript is
    perhaps the best known example of one of these languages, although the Google
    web toolkit that compiles Java to JavaScript was also once very popular. Never
    ones to be left behind or use somebody else's solution, Microsoft released a language
    called TypeScript in 2012\. It is designed to be a superset of JavaScript in the
    same way that C++ is a superset of C. This means that all syntactically valid
    JavaScript code is also syntactically valid TypeScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft itself is making heavy use of TypeScript in some of its larger web
    properties. Both Office 365 and Visual Studio Online have significant code bases
    written in TypeScript. These projects actually predate TypeScript by a significant
    margin. The transition from JavaScript to TypeScript was reportedly quite easy
    due to the fact that it is a superset of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: One of the design goals for TypeScript was to make it as compatible as possible
    with ECMAScript-2015 and future versions. This means that TypeScript supports
    some, although certainly not all, of the features of ECMAScript-2016, as well
    as a healthy chunk of ECMAScript-2015\. Two significant features from ECMAScript-2016
    which are partially supported by Typescript are decorators and async/await.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an earlier chapter we explored **aspect oriented programming** ( **AOP**
    ). With AOP we wrap function with interceptors. Decorators offer an easy way of
    doing this. Let''s say that we have a class which dispatches messages in Westeros.
    Obviously there are no phones or internet there, so messages are dispatched via
    crows. It would be very helpful if we could spy on these messages. Our `CrowMessenger`
    class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'You may note the `@spy` annotation on the `SendMessage` method. This is simply
    another function which intercepts and wraps the function. Inside of the spy we
    have access to the function descriptor. As you can see in the following code,
    we take the descriptor and manipulate it to capture the argument sent to the `CrowMessenger`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Spys would obviously be very useful for testing functions. Not only can we
    spy on the values here but we could replace the input and output to the function.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Decorators can be used for purposes other than AOP. For instance, you could
    annotate the properties on an object as serializable and use the annotations to
    control custom JSON serialization. It is my suspicion that decorators will become
    more useful and powerful as decorators become supported. Already Angular 2.0 is
    making extensive use of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 7](text00067.html#page "Chapter 7. Reactive Programming") , *Reactive
    Programming* , we spoke about how the callback nature of JavaScript programming
    makes code very confusing. Nowhere is this more apparent than trying to chain
    together a series of asynchronous events. We rapidly fall into a trap of code,
    which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only is this code difficult to read, it is nearly impossible to understand.
    The async/await syntax, which is borrowed from C#, allows for writing your code
    in a much more succinct fashion. Behind the scenes generators are used (or abused,
    if you like) to create the impression of true async/await. Let''s look at an example.
    In the preceding code we made use of the geolocation API which returns the location
    of a client. It is asynchronous as it performs some IO with the user''s machine
    to get a real world location. Our specification calls for us to get the user''s
    location, post it back to the server, and then get an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now introduce async/await, this can become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This code assumes that all `async` responses return promises which are a construct
    that contains a status and a result. As it stands, most `async` operations do
    not return promises but there are libraries and utilities to convert callbacks
    to promises. As you can see, the syntax is much cleaner and easier to follow than
    the callback mess.
  prefs: []
  type: TYPE_NORMAL
- en: Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as the ECMAScript-2016 features we''ve mentioned in the preceding section,
    TypeScript has a rather intriguing typing system incorporated into it. One of
    the nicest parts of JavaScript is that it is a dynamically typed language. We''ve
    seen, repeatedly, how, not being burdened by types has saved us time and code.
    The typing system in TypeScript allows you to use as much or as little typing
    as you deem to be necessary. You can give variables a type by declaring them with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a variable has a type assigned to it, the TypeScript compiler will use
    that not only to check that variable''s usage, but also to infer what other types
    may be derived from that class. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the TypeScript compiler will know that `unknown` is a number. If you
    attempt to use it as something else, say as the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Then the compiler will throw an error. However, you don't need to assign a type
    to any variable. This means that you can tune the degree to which the type checking
    is run. While it sounds odd, it is actually a brilliant solution for introducing
    the rigour of type checking without losing the pliability of JavaScript. The typing
    is only enforced during compilation, once the code is compiled to JavaScript,
    any hint that there was typing information associated with a field disappears.
    As a result, the emitted JavaScript is actually very clean.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in typing systems and know words like contravariant and
    can discuss the various levels of gradual typing, then TypeScript's typing system
    may be well worth your time to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this book were originally written in TypeScript and then
    compiled to JavaScript. This was done to improve the accuracy of the code and
    generally to save me from messing up quite so frequently. I'm horribly biased
    but I think that TypeScript is really well done and certainly better than writing
    pure JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: There is no support for typing in future versions of JavaScript. Thus, even
    with all the changes coming to future versions of JavaScript, I still believe
    that TypeScript has its place in providing compile time type checking. I never
    cease to be amazed by the number of times that the type checker has saved me from
    making silly mistakes when writing TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: BabelJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to TypeScript is to use the BabelJS compiler. This is an open
    source project ECMAScript-2015 and beyond to the equivalent ECMAScript 5 JavaScript.
    A lot of the changes put in place for ECMAScript-2015 are syntactic niceties,
    so they can actually be represented in ECMAScript 5 JavaScript, although not as
    succinctly or as pleasantly. We've seen that already using class-like structures
    in ES 5\. BabelJS is written in JavaScript, which means that the compilation from
    ECMAScript-2015 to ES 5 is possible directly on a web page. Of course, as seems
    to be the trend with compilers, the source code for BabelJS makes use of ES 6
    constructs, so BabelJS must be used to compile BabelJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the list of ES6 functions that are supported by BabelJS
    are extensive:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed property names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators and for of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property method assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object initializer shorthand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BabelJS is multi-purpose JavaScript compiler, so compiling ES-2015 code is simply
    one of the many things it can do. There are numerous plugins which provide a wide
    array of interesting functionality. For instance, the "Inline environmental variable"
    plugin inserts compile time variables, allowing for conditional compilation based
    on environments.
  prefs: []
  type: TYPE_NORMAL
- en: There is already a fair bit of documentation available on how each of these
    features work so we won't go over all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up Babel JS is a fairly simple exercise if you already have node and
    npm installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a BabelJS binary which can do compilation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: For most use cases you'll want to investigate using build tools such as Gulp
    or Grunt, which can compile many files at once and perform any number of post-compilation
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you should be getting sick of reading about different ways to make classes
    in JavaScript. Unfortunately for you I'm the one writing this book so let's look
    at one final example. We'll use the same castle example from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Modules within files are not supported in BabelJS. Instead, files are treated
    as modules, which allows for dynamic loading of modules in a fashion not unlike
    `require.js` . Thus we'll drop the module definition from our castle and stick
    to just the classes. One other feature that exists in TypeScript and not ES 6
    is prefacing a parameter with `public` to make it a public property on a class.
    Instead we make use of the `export` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve made these changes, the source ES6 file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting ES 5 JavaScript looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Right away it is apparent that the code produced by BabelJS is not as clean
    as the code from TypeScript. You may also have noticed that there are some helper
    functions employed to handle inheritance scenarios. There are also a number of
    mentions of `"use strict";` . This is an instruction to the JavaScript engine
    that it should run in strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict mode prevents a number of dangerous JavaScript practices. For instance,
    in some JavaScript interpreters it is legal to use a variable without declaring
    it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'This will throw an error if `x` has not previously been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Duplicating properties in objects is disallowed, as well as double declaring
    a parameter. There are a number of other practises that `"use strict";` will treat
    as errors. I like to think of `"use strict";` as being similar to treating all
    warnings as errors. It isn't, perhaps, as complete as `–Werror` in GCC but it
    is still a good idea to use strict mode on new JavaScript code bases. BabelJS
    simply enforces that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a huge feature but a real nicety in ES 6 is the introduction of default
    parameters. It has always been possible to call a function in JavaScript without
    specifying all the parameters. Parameters are simply populated from left to right
    until there are no more values and all remaining parameters are given undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default parameters allow setting a value other than undefined for parameters
    that aren''t filled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code produced is actually very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Template literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the surface, template literals seem to be a solution for the lack of string
    interpolation in JavaScript. In some languages, such as Ruby and Python, you can
    inject substitutions from the surrounding code directly into a string without
    having to pass them into some sort of string formatting function. For instance,
    in Ruby you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This will bind the `${name}` parameter to the name from the surrounding scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 supports template literals that allow something similar in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be difficult to see but that string is actually surrounded by backticks
    and not quotation marks. Tokens to bind to the scope are denoted by `${}` . Within
    the braces you can put complex expressions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The BabelJS compiled version of this code simply substitutes appending strings
    for the string interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Template literals also solve a number of other problems. New line characters
    inside of a template literal are legal, meaning that you can use template literals
    to create multiline strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the multiline string idea in mind, it seems like template literals might
    be useful for building domain specific languages: a topic we''ve seen a number
    of times already. The DSL can be embedded in a template literal and then values
    from outside plugged in. An example might be using it to hold HTML strings (certainly
    a DSL) and inserting values in from a model. These could, perhaps, take the place
    of some of the template tools in use today.'
  prefs: []
  type: TYPE_NORMAL
- en: Block bindings with let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scoping of variables in JavaScript is weird. If you define a variable inside
    a block, say inside an `if` statement, then that variable is still available outside
    of the block. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: This code will print `9` , even though the variable outside is clearly out of
    scope. At least it is out of scope if you assume that JavaScript is like other
    C-syntax languages and supports block level scoping. The scoping in JavaScript
    is actually function level. Variables declared in code blocks like those found
    attached to `if` and `for` loop statements are hoisted to the beginning of the
    function. This means that they remain in scope for the entirety of the function.
  prefs: []
  type: TYPE_NORMAL
- en: ES 6 introduces a new keyword, `let` , which scopes variables to the block level.
    This sort of variable is ideal for use in loops or to maintain proper variable
    values inside an `if` statement. Traceur implements support for block scoped variables.
    However, the support is experimental at the moment due to performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the inner variable is replaced with a renamed one. Once outside
    the block, the variable is no longer replaced. Running this code will report that
    inside is undefined when the `console.log` method occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BabelJS is a very powerful tool for replicating many of the structures and features
    of the next version of JavaScript today. However, the code generated is never
    going to be quite as efficient as having native support for the constructs. It
    may be worth benchmarking the generated code to ensure that it continues to meet
    the performance requirements of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two excellent libraries for working with collections functionally
    in JavaScript: Underscore.js and Lo-Dash. Used in combination with TypeScript
    or BabelJS they have a very pleasant syntax and provide immense power.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, finding all the members of a collection that satisfy a condition
    using Underscore looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: This code will find all the items where the ID is greater than `3` .
  prefs: []
  type: TYPE_NORMAL
- en: Either of these libraries is one of the first things I add to a new project.
    Underscore is actually bundled with backbone.js, an MVVM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks for Grunt and Gulp exist for compiling code written in TypeScript or BabelJS.
    There is, of course, also good support for TypeScript in much of Microsoft's development
    tool chain, although BabelJS is currently not supported directly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the functionality of JavaScript expands, the need for third party frameworks
    and even transpilers starts to drop off. The language itself replaces many of
    these tools. The end game for tools like jQuery is that they are no longer required
    as they have been absorbed into the ecosystem. For many years the velocity of
    web browsers has been unable to keep pace with the rate of change of people's
    desires.
  prefs: []
  type: TYPE_NORMAL
- en: There is a large effort behind the next version of AngularJS but great efforts
    are being made to align the new components with the upcoming web component standards.
    Web components won't fully replace AngularJS but Angular will end up simply enhancing
    web components.
  prefs: []
  type: TYPE_NORMAL
- en: Of course the idea that there won't be a need for any frameworks or tools is
    ridiculous. There is always going to be a new method of solving a problem and
    new libraries and frameworks will show up. The opinions of people on how to solve
    problems is also going to differ. That's why there is space in the market for
    the wide variety of MVVM frameworks that exist.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JavaScript can be a much more pleasant experience if you make use
    of ES6 constructs. There are a couple of possible approaches to doing so, which
    of these is best suited to your specific problem is a matter for closer investigation.
  prefs: []
  type: TYPE_NORMAL
