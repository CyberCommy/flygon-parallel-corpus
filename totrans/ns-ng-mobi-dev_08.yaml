- en: Building an Audio Recorder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建音频录音机
- en: Recording audio is the most performance-intensive operation our app must handle.
    It is also the one feature where having access to native APIs will be the most
    rewarding. We want our users to be able to record with the lowest latency possible
    for the mobile device in order to achieve the highest fidelity of sound. Additionally,
    this recording should optionally happen over the top of an existing mix of pre-recorded
    tracks all playing in sync .
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 录制音频是我们的应用必须处理的性能最密集的操作。这也是唯一一个访问原生API将最有回报的功能。我们希望用户能够以移动设备可能的最低延迟录制，以实现最高保真度的声音。此外，这种录制应该可以选择地发生在现有预先录制的音轨的顶部，所有音轨都在同步播放。
- en: Since this phase of our app development will dive the deepest into platform-specific
    native APIs, we will split our implementations into two phases. We will first
    build out the iOS-specific details of the recording features, followed by Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用开发的这个阶段将深入到特定平台的原生API，我们将把我们的实现分为两个阶段。我们将首先构建出录音功能的iOS特定细节，然后是Android。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Building a feature rich cross-platform audio recorder for iOS and Android with
    a consistent API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS和Android构建一个功能丰富的跨平台音频录音机，具有一致的API
- en: Integrating iOS framework libraries, such as AudioKit ([http://audiokit.io](http://audiokit.io)),
    which was built entirely with Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成iOS框架库，比如完全使用Swift构建的AudioKit（[http://audiokit.io](http://audiokit.io)）
- en: How to convert Swift/Objective C methods to NativeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Swift/Objective C方法转换为NativeScript
- en: Building custom reusable NativeScript view components based on native APIs,
    as well as how to use them inside Angular
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于原生API构建自定义可重复使用的NativeScript视图组件，以及如何在Angular中使用它们
- en: Configuring a reusable Angular Component that can both be used via routing and opened
    via a popup modal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个可重复使用的Angular组件，既可以通过路由使用，也可以通过弹出式模态框打开
- en: Integrate Android Gradle libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Android Gradle库
- en: How to convert Java methods to NativeScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Java方法转换为NativeScript
- en: Using multiple item templates with NativeScript's ListView
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NativeScript的ListView和多个项目模板
- en: Phase 1 – Building an audio recorder for iOS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一阶段 - 为iOS构建音频录音机
- en: The audio capabilities of the iOS platform are impressive, to say the least.
    A group of wonderfully talented audiophiles and software engineers have collaborated
    on building an open source framework layer on top of the platform's audio stack. This
    world class engineering effort is the awe inspiring AudioKit ([http://audiokit.io/](http://audiokit.io/)),
    led by the fearless Aurelius Prochazka, a true pioneer in audio technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: iOS平台的音频功能令人印象深刻，不得不说。一群才华横溢的音频爱好者和软件工程师合作构建了一个开源框架层，位于该平台的音频堆栈之上。这个世界级的工程努力是令人敬畏的AudioKit（[http://audiokit.io/](http://audiokit.io/)），由无畏的Aurelius
    Prochazka领导，他是音频技术的真正先驱。
- en: The AudioKit framework is written entirely with Swift, which introduces a couple
    of interesting surface-level challenges when integrating with NativeScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit框架完全使用Swift编写，这在与NativeScript集成时引入了一些有趣的表面层挑战。
- en: Challenge detour – Integrate Swift based library into NativeScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战绕道 - 将基于Swift的库集成到NativeScript中
- en: "At the time of this writing, NativeScript can work with Swift if the codebase properly\
    \ exposes the classes and types to Objective-C via what's called a **bridging\
    \ header**, allowing both the languages to be mixed or matched. You can learn\
    \ more about what a bridging header is here: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html).\
    \ [](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)\
    \ This bridging header is auto generated when the Swift codebase is compiled into\
    \ a framework. Swift offers rich language features, some of which do not have\
    \ a direct correlation to Objective C. Full featured support for the latest Swift\
    \ language enhancements will likely come to NativeScript eventually however at\
    \ the time of this writing there are a couple considerations to keep in mind.\uFEFF"
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，如果代码库通过所谓的**桥接头文件**正确地将类和类型暴露给Objective-C，NativeScript可以与Swift一起工作，从而允许两种语言混合或匹配。您可以在这里了解有关桥接头文件的更多信息：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)。[](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)
    当Swift代码库编译为框架时，将自动生成此桥接头文件。Swift提供了丰富的语言功能，其中一些与Objective C没有直接对应关系。最新的Swift语言增强功能的全面支持可能最终会到NativeScript，但是在撰写本文时，有一些需要牢记的考虑。
- en: 'AudioKit utilizes the best of what the Swift language has to offer, including
    enriched **enum** capabilities. You can learn more about the expanded enum features
    in the Swift language here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit利用了Swift语言所提供的最佳功能，包括丰富的**枚举**功能。您可以在这里了解Swift语言中扩展的枚举功能：
- en: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
- en: 'In particular, there is this from the documentation: "t*hey adopt many features
    traditionally supported only by classes, such as computed properties to provide
    additional information about the enumeration’s current value, and instance methods
    to provide functionality related to the values the enumeration represents.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，文档中有这样的内容："*它们采用了传统上仅由类支持的许多功能，例如计算属性以提供有关枚举当前值的附加信息，以及实例方法以提供与枚举表示的值相关的功能。*”
- en: Such *enums* are foreign to Objective C and, therefore, cannot be made available
    in the bridging header. Any code that uses Swift's exotic *enums* will be simply
    ignored when the bridging header is generated at compile time, resulting in Objective
    C not being able to interact with those sections of the code. This means you will
    not be able to use a method from a Swift codebase in NativeScript which utilizes
    these enhanced constructs out of the box (*at the time of this writing*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的*枚举*对Objective C来说是陌生的，因此无法在桥接头文件中使用。在编译时生成桥接头文件时，任何使用Swift的奇异*枚举*的代码都将被简单地忽略，导致Objective
    C无法与代码的这些部分进行交互。这意味着您将无法在NativeScript中使用Swift代码库中的方法，该方法使用了这些增强的构造（*在撰写本文时*）。
- en: 'To remedy this, we will fork the AudioKit framework and flatten the exotic
    enums used in the `AKAudioFile` extension files, which provide a powerful and
    convenient export method we will want to use to save our recorded audio files.
    The exotic *enum* we need to modify looks like this ([https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将fork AudioKit框架，并展平`AKAudioFile`扩展文件中使用的奇异枚举，这些文件提供了一个强大和方便的导出方法，我们将要用来保存我们录制的音频文件。我们需要修改的奇异*enum*看起来像这样（[https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is unlike any *enum* you may be familiar with; as you can see, it includes
    properties in addition to what enums have. When this code is compiled and the
    bridging header is generated to mix or match with Objective-C, the bridging header will
    then exclude any code that uses this construct. We will flatten this out to look
    like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您可能熟悉的任何*enum*都不同；正如您所看到的，它包括除枚举之外的属性。当这段代码被编译并生成桥接头文件以与Objective-C混合或匹配时，桥接头文件将排除使用此结构的任何代码。我们将将其展平，使其看起来像以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will then adjust the portions of the `AKAudioFile` extension to use our flattened
    properties. This will allow us to manually build `AudioKit.framework` we can use
    in our app, exposing the method we want to use: `exportAsynchronously`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将调整`AKAudioFile`扩展的部分，以使用我们展平的属性。这将允许我们手动构建`AudioKit.framework`，我们可以在我们的应用程序中使用，暴露我们想要使用的方法：`exportAsynchronously`。
- en: We won't go over the details of manually building `AudioKit.framework`, as it
    is well documented here: [https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift).
    With our custom-built framework, we are now ready to integrate it into our app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍手动构建`AudioKit.framework`的细节，因为这在这里有很好的文档记录：[https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)。有了我们定制的框架，我们现在可以将其集成到我们的应用程序中。
- en: Integrating a custom-built iOS framework into NativeScript
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义构建的iOS框架集成到NativeScript
- en: 'We can now create an internal plugin to integrate this iOS framework into our
    app. Take the custom `AudioKit.framework` we have built and create a `nativescript-audiokit` directory
    at the root of our app. We then add a `platforms/ios` folder inside to drop the
    framework into. This will let NativeScript know how to build these iOS-specific
    files into the app. As we want this internal plugin to be treated like any standard
    npm plugin, we will also add `package.json` directly inside the `nativescript-audiokit`
    folder with the following contents:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个内部插件，将这个iOS框架集成到我们的应用程序中。拿着我们构建的自定义`AudioKit.framework`，在我们应用程序的根目录下创建一个`nativescript-audiokit`目录。然后在里面添加一个`platforms/ios`文件夹，将框架放进去。这样就可以让NativeScript知道如何将这些iOS特定的文件构建到应用程序中。由于我们希望这个内部插件被视为任何标准的npm插件，我们还将在`nativescript-audiokit`文件夹内直接添加`package.json`，内容如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now use the following command to add it to our app (NativeScript will
    look locally first and find the **nativescript-audiokit** plugin):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用以下命令将其添加到我们的应用程序中（NativeScript将首先在本地查找并找到**nativescript-audiokit**插件）：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will properly add the custom-built iOS framework into our app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确地将自定义构建的iOS框架添加到我们的应用程序中。
- en: 'However, we need two more very important items:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们还需要两个非常重要的项目：
- en: 'Since AudioKit is a Swift-based framework, we want to ensure our app includes
    the proper supporting Swift libraries. Add a new file, `nativescript-audiokit/platforms/ios/build.xcconfig`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于AudioKit是一个基于Swift的框架，我们希望确保我们的应用程序包含适当的支持Swift库。添加一个新文件，`nativescript-audiokit/platforms/ios/build.xcconfig`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we will be engaging with the user''s microphone, we will want to ensure
    the microphone usage is indicated in our app''s property list. We will also take
    this opportunity to add two additional property settings to enhance our app''s
    abilities. So, in total, we will add three property keys for the following purposes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要使用用户的麦克风，我们希望确保麦克风的使用在我们应用程序的属性列表中得到了指示。我们还将利用这个机会添加两个额外的属性设置来增强我们应用程序的能力。因此，总共我们将为以下目的添加三个属性键：
- en: Let the device know our app needs access to the microphone and ensure the user's
    permission is requested on first access.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让设备知道我们的应用程序需要访问麦克风，并确保在第一次访问时请求用户的权限。
- en: Continue playing audio if the app is placed into the background.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序被放入后台时继续播放音频。
- en: Provide the ability to see the app's `documents` folder in iTunes when the phone
    is connected to a computer. This will allow you to view recorded files right inside
    of iTunes via the app's Documents. This could be useful for integration into a
    desktop audio editing software.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在连接到计算机时能够在iTunes中看到应用程序的`documents`文件夹的能力。这将允许您通过应用程序的文档在iTunes中直接查看录制的文件。这对于集成到桌面音频编辑软件中可能会有用。
- en: 'Add a new file, `nativescript-audiokit/platforms/ios/Info.plist`, with the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新文件，`nativescript-audiokit/platforms/ios/Info.plist`，其中包含以下代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a screenshot to better illustrate the internal plugin structure in
    our app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个屏幕截图，更好地说明了我们应用程序中的内部插件结构：
- en: '![](../images/00036.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: 'Now, when NativeScript builds the iOS app, it will ensure `AudioKit.framework`
    is included as a library and merge the contents of `build.xcconfig` and `Info.plist`
    into our app''s configuration. Any time we make changes to the files inside this
    internal plugin folder (`nativescript-audiokit`), we want to ensure our app picks
    up those changes. To do so, we can simply remove and add the plugin back, so let''s
    do that now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当NativeScript构建iOS应用程序时，它将确保`AudioKit.framework`被包含为一个库，并将`build.xcconfig`和`Info.plist`的内容合并到我们应用程序的配置中。每当我们对这个内部插件文件夹（`nativescript-audiokit`）中的文件进行更改时，我们希望确保我们的应用程序能够接收到这些更改。为了做到这一点，我们可以简单地删除并重新添加插件，所以现在让我们这样做：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to build our audio recorder using the AudioKit API for iOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用iOS的AudioKit API构建我们的音频录制器。
- en: Setting up native API type checking and generate AudioKit TypeScript definitions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地API类型检查并生成AudioKit TypeScript定义。
- en: 'The first thing we want to do is install `tns-platform-declarations`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是安装`tns-platform-declarations`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we create a new file in the root of the project called `references.d.ts`
    with the following contents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录中创建一个名为`references.d.ts`的新文件，其中包含以下内容：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This provides us with full type checking and intellisense support for iOS and
    Android APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了对iOS和Android API的完整类型检查和智能感知支持。
- en: 'We now want to generate typings for the AudioKit framework itself. We can execute
    this command to generate the typings for the included `AudioKit.framework`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要为AudioKit框架本身生成类型定义。我们可以执行以下命令来为包含的`AudioKit.framework`生成类型定义：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are setting the environment variable `TNS_TYPESCRIPT_DECLARATIONS_PATH` to
    the present working directory (`pwd`) with a folder prefix of `typings`. When
    NativeScript creates the iOS build, it will also generate type definition files
    for all the native APIs available to our app, including third-party libraries.
    We will now see a `typings` folder appear in our project, containing two folders:
    `i386` and `x86_64`. One is for the Simulator architecture and the other the device.
    Both will contain the same output, so we can just focus on one. Open the `i386`
    folder and you will find an `objc!AudioKit.d.ts` file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将环境变量`TNS_TYPESCRIPT_DECLARATIONS_PATH`设置为当前工作目录（`pwd`），并添加一个名为`typings`的文件夹前缀。当NativeScript创建iOS构建时，它还将为我们的应用程序提供的所有原生API以及第三方库生成类型定义文件。现在我们将在项目中看到一个`typings`文件夹，其中包含两个文件夹：`i386`和`x86_64`。一个是模拟器架构，另一个是设备。两者都将包含相同的输出，因此我们只需关注一个。打开`i386`文件夹，你会找到一个`objc!AudioKit.d.ts`文件。
- en: 'We want to use only that file, so move it to the root of the `typings` folder:
    `typings/objc!AudioKit.d.ts`. We can then remove both the `i386` and `x86_64` folders,
    as we will no longer need them (the other API definition files are provided via
    `tns-platform-declarations`). We just generated these typings to get TypeScript
    definitions for the AudioKit library. This is a one-time thing, done to integrate
    easily with this native library, so you are safe to add this custom `typings`
    folder to source control.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想使用那个文件，所以将它移动到`typings`文件夹的根目录：`typings/objc!AudioKit.d.ts`。然后我们可以删除`i386`和`x86_64`文件夹，因为我们将不再需要它们（其他API定义文件通过`tns-platform-declarations`提供）。我们只是生成这些类型定义文件以获得AudioKit库的TypeScript定义。这是一次性的事情，用于轻松集成这个本地库，所以您可以放心将这个自定义`typings`文件夹添加到源代码控制中。
- en: 'Double-check `tsconfig.json` and ensure you have the `"skipLibCheck": true`
    option enabled. We can now modify our `references.d.ts` file to include the additional
    types for the AudioKit library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '仔细检查`tsconfig.json`，确保已启用`"skipLibCheck": true`选项。现在我们可以修改我们的`references.d.ts`文件，以包含AudioKit库的附加类型：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project structure should now look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目结构现在应该是这样的：
- en: '![](../images/00037.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: Build recorder with AudioKit
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AudioKit构建录音机
- en: We will begin by creating a model around our interaction with AudioKit's recording
    APIs. You could just start writing directly against these APIs right from your
    Angular component or service, but since we want to provide a consistent API across
    iOS and Android, there's a smarter way to architect this. Instead, we will abstract a
    simple API, usable across both platforms, which will tap into the correct native
    implementations under the hood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个围绕与AudioKit录音API交互的模型。你可以直接从你的Angular组件或服务中开始直接编写针对这些API的代码，但是由于我们希望在iOS和Android上提供一致的API，因此有一种更聪明的方法来设计这个。相反，我们将抽象出一个简单的API，可在两个平台上使用，并在底层调用正确的本地实现。
- en: 'There will be a lot of interesting details related to AudioKit going on here,
    but create `app/modules/recorder/models/record.model.ts` with the following and
    we will explain some of the bits in a moment:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将会有很多与AudioKit相关的有趣细节，但是创建`app/modules/recorder/models/record.model.ts`并包含以下内容，我们将在稍后解释其中的一些部分：
- en: Later, we will add the `.ios.ts` suffix to this model, since it will contain
    iOS-specific implementation details. However, here in Phase 1, we will use the
    model directly (omitting the platform suffix) while we develop our iOS recorder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将在这个模型中添加`.ios.ts`后缀，因为它将包含iOS特定的实现细节。然而，在第一阶段，我们将直接使用模型（省略平台后缀）来开发我们的iOS录音机。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`RecordModel` will behave a bit like a state machine, where the only states
    it could be in are the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`将表现得有点像一个状态机，它可能处于以下状态之一：'
- en: '`readyToRecord`: Default starting state. Must be in this state to enter the
    recording state.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToRecord`：默认的起始状态。必须处于此状态才能进入录音状态。'
- en: '`recording`: Quiet in the studio! Recording in process.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recording`：工作室安静！录音进行中。'
- en: '`readyToPlay`: User has stopped recording and now has a recorded file to play
    back with the mix.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToPlay`：用户已停止录音，现在有一个录制文件可以与混音一起播放。'
- en: '`playing`: User is playing back the recorded file with the mix.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing`：用户正在用混音回放录制的文件。'
- en: '`saved`: User chose to save the recording, that should kick off actions to
    save the new track with the active composition.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saved`：用户选择保存录音，这应该启动保存新轨道与活动组合的操作。'
- en: '`finish`: Once the save actions are complete, the recorder should shut down.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish`：一旦保存操作完成，记录器应该关闭。'
- en: We then define the shape of the events the recorder will provide with `IRecordEvents`.
    In this case, we will have a single event, `stateChange`, which will notify any
    listeners when the state changes (*see the state setter*). Our model will extend
    NativeScript's `Observable` class (hence, `RecordModel extends Observable`), which
    will provide us with the notify API to dispatch our events.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`IRecordEvents`定义记录器将提供的事件的形状。在这种情况下，我们将有一个单一的事件`stateChange`，当状态改变时（*参见状态设置器*）将通知任何监听器。我们的模型将扩展NativeScript的`Observable`类（因此，`RecordModel
    extends Observable`），这将为我们提供通知API来分发我们的事件。
- en: 'We then set up several references to the various AudioKit bits we will use.
    Most of what is designed is directly from this AudioKit example on recording:
    [https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift).
    We even use the same state enum setup (with a few extras). In their example, AudioKit''s `AKAudioPlayer`
    is used for playback; but, with our design, we will load our recorded files into our
    multitrack player design to play them back with our mix. We could work `AKAudioPlayer`
    into `TrackPlayerModel` for iOS; but, `TNSPlayer` (from the **nativescript-audio**
    plugin) is cross-platform compatible and will work just fine. We''ll cover the
    details of how we load these new recorded files into our design shortly, but notifying
    listeners of the recorder''s state will provide us all the flexibility we need
    to handle all that when we get there.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了对我们将使用的各种AudioKit部分的几个引用。大部分设计直接来自于AudioKit的录音示例：[https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift)。我们甚至使用相同的状态枚举设置（带有一些额外的内容）。在他们的示例中，AudioKit的`AKAudioPlayer`用于播放；但是，根据我们的设计，我们将加载我们的录制文件到我们的多轨播放器设计中，以便用我们的混音回放它们。我们可以在iOS的`TrackPlayerModel`中使用`AKAudioPlayer`；但是，`TNSPlayer`（来自**nativescript-audio**插件）是跨平台兼容的，也可以正常工作。我们将很快介绍如何将这些新录制的文件加载到我们的设计中的细节，但是通知记录器状态的监听器将为我们提供处理所有这些的灵活性。
- en: 'You may wonder why we type-cast this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们要进行类型转换：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Good question. AudioKit provides Extensions to Core Foundation classes such
    as `AVAudioFile`. These were known as `Categories` in Objective C: [https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html);
    however, in Swift, they are referred to as `Extensions`: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we generated TypeScript definitions for AudioKit; but, we only
    kept the `objc!AudioKit.d.ts` file to reference. If we had looked in the foundation
    definitions, we would have seen the extension to `AVAudioFile`. However, since
    we did not keep those definitions around and instead are relying on the default
    `tns-platform-declarations` definitions, this `Extension` is not known to our
    TypeScript compiler, so we simply type-cast it, as we know AudioKit provides this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also critical `RecordModel` sets the audio session to `PlayAndRecord`,
    as this will allow us to record while playing our mix at the same time:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may also be curious why some classes use `init()` and others `init(null)`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some of the initializers for AudioKit's classes take an optional argument, for
    example, `AKMixer` takes an optional `NSArray` of `AVAudioNode` to connect. However,
    our TypeScript definitions have those defined as required, so we are just passing
    `null` to that argument and instead using the `connect` node API directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: How to convert Swift/ObjC methods to NativeScript
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last point of interest from `RecordModel` might be the `save` method, which
    will export our recording from the app''s `tmp` directory to the app''s `documents`
    folder while converting it to the smaller filesize `.m4a` audio format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Long method name, right? Yes, indeed; some Swift/ObjC parameterized method
    names collapse to become very long. That particular method in Swift is defined
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we had the TypeScript definitions generated for AudioKit, they helped
    us out here. However, sometimes, you don't have that luxury. A Swift/ObjC method
    with various parameters for arguments collapse into each other while adding `With` in
    between the start of the method name and the start of the parameter argument names,
    while capitalizing the first character upon collapsing each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Building custom reusable NativeScript view for native audio Waveform display
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of creating an Angular Component for our Waveform display, we will create
    a custom NativeScript view component, that taps into native APIs, that we can
    then register with Angular to use in our components. The reason for doing this
    is due to NativeScript's powerful `view` base class that we can extend, which
    provides a nice API when using underlying native APIs for the `view`. This Waveform
    display will work in tandem with the `RecordModel` we just created to bring to
    life our real-time Waveform feedback display of the device's microphone. It would
    also be amazing to reuse this Waveform display as a static audio file waveform
    rendering on our track list, as an alternate view for our main composition view.
    AudioKit provides classes and APIs to do all this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to be able to use this anywhere in our app, we will create it
    inside the shared module directory; however, keep in mind that it could live anywhere.
    It doesn't matter so much here, since this is not an Angular component that needs
    to be declared in `NgModule`. Additionally, since this will specifically work
    with native APIs, let's create it inside a new `native` folder to potentially
    house other NativeScript-specific view components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/shared/native/waveform.ts` with the following contents,
    which we will explain in a moment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are creating several properties using NativeScript's `Property` class, which
    will add great conveniences when exposing native view properties through the view
    binding properties. One such convenience in defining these properties with the
    `Property` class, these setters will only be called when `nativeView` is defined,
    avoiding double invoked property setters (one via a pure JS property setter, which
    is the alternative, and potentially another for when the underlying `nativeView`
    is ready).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: When wanting to expose native view properties that could be bound via your custom
    component, define several `Property` classes for them, referencing the name you'd
    like to use for the view binding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By setting up these `Property` instances, we can now do this in our view component
    class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will only be invoked once `nativeView` is ready, which is exactly what
    we want. You can read more about this particular syntax and notation in this draft
    written by core team member Alex Vakrilov:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property](https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, at the bottom of our class (after it''s defined), we register the class
    with the `Property` instances:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay, with that explained, let's look at some other elements to this implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also introducing a helpful interface here, which we will apply to `RecordModel`
    in a moment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will help define a shape for other models to implement, ensuring they
    conform to an API the Waveform display expects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: Defines the key input to be used with the native class.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispose()`: Each model should provide this method to handle any clean up when
    the view is destroyed.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the custom NativeScript 3.x View Life cycle call execution order:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`createNativeView()`: `AnyNativeView;`  // Create your native view.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`initNativeView()`: `void;`  // Init your native view.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`disposeNativeView()`: `void;`  // Clean up your native view.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `createNativeView` method overridden from NativeScript''s `View` class
    is likely the most interesting:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we allow the `type` property to determine which type of Waveform display
    it should render.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `mic`, we utilize AudioKit's `AKNodeOutputPlot` (which actually
    extends `EZAudioPlot` under the hood) to initialize a waveform (that is, `audioplot`)
    using our model's target, which will end up being our RecordModel's microphone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `file`, we utilize AudioKit's `EZAudioPlot` directly to create
    a static waveform representing an audio file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The `initNativeView` method, also overridden from NativeScript's `View` class,
    is called second in its life cycle and provides a way to initialize your native
    view. You might find it interesting that we call the setters again here. The setters
    are called first when the component bindings are set via the XML and the class
    instantiates, which is *before* `createNativeView` and `initNativeView` are called.
    This why we cache the values in private references. However, we also want these
    setters to modify `nativeView` with Angular's view bindings (when changed dynamically),
    which is why we also have `if (this.nativeView)` inside the setters to change
    `nativeView` dynamically when available.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The `disposeNativeView` method (you guessed it, also overridden from the `{N}`
    of the `View` class) is called when `View` gets destroyed, which is where we call
    the model's `dispose` method if available.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Integrate a custom NativeScript view into our Angular app
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use our NativeScript Waveform view within Angular, we need to first register
    it. You can do this in the root module, root app component, or another place that
    is initialized at boot time (usually, not in a lazy-loaded module). To be tidy,
    we will register it within `SharedModule` in the same directory, so add the following
    in `app/modules/shared/shared.module.ts`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `registerElement` method allows us to define the name of the Component we
    want to use within Angular components as the first argument, and takes a resolver
    function that should return the NativeScript `View` class to use for it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use our new `IWaveformModel` and clean up some of `RecordModel` to
    use it, as well as prepare to create our Android implementation next. Let's refactor
    a couple things out of `RecordModel` into a common file to share code between
    our iOS and Android (coming soon!) models.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/recorder/models/record-common.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This contains most of what was at the top of `RecordModel`, with the addition
    of the `IRecordModel` interface, which extends `IWaveformModel`. Since we built
    out our iOS implementation, we now have a model shape we would like our Android
    implementation to adhere to. Abstracting that shape into an interface will provide
    us a clear path to follow when we move to Android momentarily.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, let''s also create an index for our models, which would also
    expose this common file, in `app/modules/recorder/models/index.ts`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now modify `RecordModel` to import these common items, as well as implement
    this new `IRecordModel` interface. Since this new interface also *extends* `IWaveformModel`,
    it will immediately tell us we need to implement the `readonly target`getter and
    the `dispose()`method, as required to be used with our Waveform view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `target` of `RecordModel` will be the microphone that the Waveform view
    will use. Our `dispose` method will stop the AudioKit engine while doing reference
    clean up, as well as ensuring to clean out any temporary files created while recording.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Recorder View layout
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user taps on Record in the top right corner of the app, it prompts
    the user to authenticate, after which the app routes to the record view. Additionally,
    it would be nice to reuse this record view in a modal popup to show when the composition
    contains tracks, so the user doesn't feel like they are leaving the composition
    while recording. However, when the composition is new, it's fine to navigate to
    the record view via routing. We will show how this can be done, but let's first
    set up our layout using the new fancy Waveform view and our powerful new `RecordModel`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to `app/modules/recorder/components/record.component.html`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using `FlexboxLayout` because we want our Waveform view to stretch to
    cover the full available vertical space, leaving only the recorder's controls
    positioned at the bottom. `FlexboxLayout` is a very versatile layout container,
    which provides most of the same CSS styling attributes found with the the flexbox
    model on the web.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, we show a Cancel button inside a `GridLayout` container only
    when displayed as a modal, since we need a way to close the modal. ActionBars
    are ignored and not displayed when the view is opened via a modal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: ActionBars are ignored when the view is opened via a modal, so they are not
    displayed in the modal. `ActionBar` is shown on navigated views only.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our `ActionBar` setup is rather interesting here and is one of
    the areas of NativeScript view layouts where iOS and Android differ the most.
    On iOS, `NavigationButton` has a default behavior, that automatically pops the
    view from the stack and animates back to the previous view. Additionally, any
    tap events on `NavigationButton` on iOS are completely ignored, whereas on Android,
    the tap event is triggered on `NavigationButton`. Because of this crucial difference,
    we want to completely ignore `NavigationButton` of `ActionBar` by using `visibility="collapsed"`
    to ensure it is never shown. Instead, we use `ActionItem` with an explicit tap
    event to ensure the correct logic is triggered on our component for both platforms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigationButton` behavior on iOS and Android is different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS**: `NavigationButton` ignores (tap) events, and this button appears by
    default when navigating to a view.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android**: `NavigationButton` (tap) events are triggered.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see our Waveform (the custom NativeScript) view in use here. We use
    Angular's binding syntax when binding the model, since it's an object. For the
    other properties, we specify their values directly, since they are primitive values.
    We could, however, use Angular's binding syntax on those as well if we wanted
    to change those values dynamically via user interaction. For example, we could
    show a fun color picker, which would allow the user to change the color (`plotColor`)
    of the waveform on the fly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll provide a component-specific stylesheet for our record component, `app/modules/recorder/components/record.component.css`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some of these CSS properties may look familiar if you''ve used the flexbox
    model on the web. A great and fun resource to learn more about flexbox styling
    is Flexbox Zombies by Dave Geddes: [http://flexboxzombies.com](http://flexboxzombies.com.).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our CSS is starting to grow and we could clean things up a lot
    with SASS. We will do exactly that, coming up soon, so hang in there!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the Component at `app/modules/recorder/components/record.component.ts`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Starting from the bottom of that file, you'll probably wonder what the heck
    `invokeOnRunLoop` is*.* This is a handy way to ensure thread safety in conditions
    where the thread might rear its ugly head. In this case, AudioKit's engine is
    started from the UI thread in `RecordModel`, since NativeScript marshals native
    calls on the UI thread. However, when our record view closes (whether it be from
    a modal our navigating back), some background threads are invoked. Wrapping our
    handling of closing this view with `invokeOnRunLoop` helps solve this transient
    exception. It's the answer to how to use iOS `dispatch_async(dispatch_get_main_queue(…))`
    with NativeScript.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Working our way up the file, we''ll encounter `this.recorderService.state$.subscribe((state:
    number) => …`. In a moment, we''ll be implementing a way to observe the recording
    `state$` as an observable, so our view can simply react to its state changes.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Also of note, it is a handy way to collapse `RecordState enum` into properties
    we can use as view bindings to compare against the current state (`this.state
    = state;`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: When the component is constructed, `recorderService.setupNewRecording()` will
    prepare our service for a brand new recording each time this view appears.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, take note of the injection of `@Optional()private params: ModalDialogParams`*.*
    Earlier, we mentioned that *it would be nice to reuse this record view in a modal
    popup*. The interesting part is that `ModalDialogParams` is only provided to a
    component when it is opened in a modal. In other words, Angular''s dependency
    injection doesn''t know anything about a `ModalDialogParams` service unless the
    component is explicitly opened via NativeScript''s `ModalService`, so this would
    break our ability to route to this component as we had originally set up, since
    Angular''s DI would fail to recognize such a provider by default. In order to
    allow this component to continue working as a routing component, we will simply
    mark that argument as `@Optional()`, which will just set its value to null when
    not available instead of throwing a dependency injection error.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This will allow our component to be routed to, as well as be opened in a modal!
    Reuse in full swing!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In order to conditionally navigate to this component via routing, or open it
    in a modal, we can make a few small adjustments, bearing in mind that `RecorderModule`
    is lazy loaded, so we'll want to lazily load the module before opening it as a
    modal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/mixer/components/action-bar/action-bar.component.ts` and
    make the following modifications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we conditionally emit an event using `EventEmitter` with a Component
    `Output` decorator if the composition contains tracks; otherwise we navigate to
    the record view. We then adjust `Button` in the view template to use the method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now modify `app/modules/mixer/components/mixer.component.html` to use
    `Output` by its name as a normal event:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now for the fun part. Since we'd love to be able to open any component in a
    modal, whether it's part of a lazy loaded module or not, let's add a new method
    to `DialogService` that can be used anywhere.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes to `app/modules/core/services/dialog.service.ts`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we inject `ModalDialogService` and `NgModuleFactoryLoader` (which is actually `NSModuleFactoryLoader`,
    since, if you recall, we provided for in [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d),
    *Routing and Lazy Loading*) to load any module on demand to open a Component (declared
    in that lazy loaded module) in a modal. *It also works for components that do
    not need to be lazy loaded*. In other words, it will optionally lazily load any
    module by its path, if provided, and then use its `NgModuleFactory` to get a module
    reference, which we can pass along as an option (via the `moduleRef` key) to `this.modalService.showModal`
    to open a Component declared in that lazily-loaded module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'This will come in handy again later; however, let''s put it to use now by making
    the following changes to `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will lazily load `RecorderModule` and then open `RecordComponent` in a
    popup modal. Cool!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Finishing implementation with RecorderService
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s finish this implementation with `RecorderService` in `app/modules/recorder/services/recorder.service.ts`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The pinnacle of our recording service is its ability to react to the model''s
    state changes. This, in turn, emits an Observable stream notifying observers (our
    `RecordComponent`) when the state changes, as well as internally doing the work
    necessary to control `RecordModel` along with `PlayerService`. The critical key
    to our design is we want our active composition''s tracks to play in the background
    while we record, so we can play along with the mix. This case is important:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When `RecordModel` is `readyToPlay`, we know that a recording has been created
    and is now ready to play. We stop the playing mix, get a reference to the recorded
    file''s path. Then, we update `PlayerService` to queue up this new track to be
    played back. We will show the updated `PlayerService` in a moment, which handles
    adding the new file to the mix, but it adds a new `TrackPlayer` like everything
    else in our mix. However, the file points to a temporary recorded file at the
    moment, as we don''t want to save the composition until the user decides to officially
    commit and save the recording. The recording session will allow the user to re-record
    again if they are not happy with the recording. This is why we hold a reference
    to `_trackId`. If a recording had already been added to the mix, we use that `_trackId`
    to exclude it when re-recording, since we would not want to hear back the recording
    we are re-recording over:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also use it to clean up after ourselves if the user chose to cancel instead
    of saving:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s take a look at the modifications to `PlayerService` we need to make
    in order to support our recording:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These changes will support our recorder's ability to interact with the active
    composition.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Considerations when reusing a Component to lazy load in a modal as well
    as allow lazy loading via routing.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular services must be provided *only* at the *root* level *if they are intended
    to be singletons* shared across all lazy loaded modules, as well as the root module.
    `RecorderService` is lazy loaded with `RecordModule` when it is navigated to,
    as well as being opened in a modal. Since we are now injecting `PlayerService`
    into our `RecorderService` (which is lazily loaded) and `PlayerService` now injects
    `MixerService` (which is also lazily loaded as the root route in our app), we
    will have to create a problem where our services are no longer singletons. In
    fact, you may even see an error like this if you were to try and navigate to `RecordComponent`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'JS: ERROR Error: Uncaught (in promise): Error: No provider for PlayerService!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we will drop the providers from `PlayerModule` and `MixerModule`
    (since those modules are both lazily loaded) and instead provide those services
    only in our `CoreModule`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `app/modules/player/player.module.ts` is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The modified `app/modules/mixer/mixer.module.ts` is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Updated to provide these services as true singletons from `CoreModule` only,
    the code for `app/modules/core/core.module.ts` is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is how you can solve these types of issues; but, this is exactly the reason
    why we recommend using Ngrx in  [Chapter 10](https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&action=edit#post_361), *@ngrx/store
    + @ngrx/effects for State Management*, coming up soon, as it can help alleviate
    these dependency injection issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our setup works nicely; but, it can be greatly improved and even
    simplified when we start integrating ngrx for a more Redux-style architecture.
    We have done a few reactive things here, such as our `RecordComponent` reacting
    to our service's `state$` observable; but, we needed to inject `MixerService`
    into `PlayerService`, which feels slightly wrong architecturally, since `PlayerModule`
    should not really have a dependency on anything `MixerModule` provides. Again,
    *this technically works just fine,* but when we start working with ngrx in [Chapter
    10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d), *@ngrx/store + @ngrx/effects
    for State Management*, you'll see how we can reduce our dependency mixing throughout
    the whole codebase.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a moment though, relax, and pat ourselves on the back, as this
    has been an impressive amount of work. Take a look at what the fruits of our labor
    are producing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Phase 2 – Building an audio recorder for Android
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Believe it or not we''ve actually done most of the heavy lifting to make this
    work on Android already! That''s the beauty of NativeScript. Designing an API
    that makes sense, as well as an architecture that can plug/play underlying native
    APIs, is key to NativeScript development. At this point, we just need to plug
    in the Android pieces into the shape we have designed. So, to summarize, we now
    have the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '`RecorderService` that works in tandem with `PlayerService` to coordinate our
    multitrack handling abilities'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Waveform view that is flexible and ready to provide an Android implementation
    under the hood
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecordModel` that should tap into the appropriate underlying target platform
    APIs and be ready for Android details to be plugged into'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built interfaces defining the shape of the model, for Android models to simply
    implement to know which API they should define
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to rename `record.model.ts` to `record.model.ios.ts`, since it''s specific
    to iOS, but before doing so, we will want a TypeScript definition file (`.d.ts`)
    for it, so our codebase can continue importing as `''record.model''`. There are
    several ways this could be done, including just manually writing one out. However,
    the tsc compiler has a handy `-d` flag, which will generate definition files for
    us:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will spit out a ton of TypeScript warnings and errors; but, it doesn't
    matter in this case, since our definition file will be generated correctly. We
    don't need to generate JavaScript, just the definition, so you can ignore the
    wall of issues that results.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two new files:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`record-common.model.d.ts` (*you can delete this as we won''t need it*)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`record.model.d.ts`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `record-common.model` file is imported by `RecordModel`, which is why a
    definition was generated for it as well; but, you can *delete* that. Now, we have
    the definition file, but we want to modify it slightly. We don''t need any of
    the `private` declarations and/or any native types it included; you would notice
    it contained the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since those are iOS-specific, we''ll want to type those as *any*, so it''s
    applicable to both iOS and Android. This is what things look like with our modifications:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Perfect, now rename `record.model.ts` to `record.model.ios.ts`. We have now
    finalized our iOS implementation, as well as ensured maximum code reuse to turn
    our focus to Android. NativeScript will use the target platform suffix files at
    build time, so you don't ever need to worry that iOS-only code would end up on
    Android and vice versa.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The `.d.ts` definition file we generated previously will be used at JavaScript
    transpilation time by the TypeScript compiler, whereas the runtime will use the
    platform-specific JS files (without the extension).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now create `app/modules/recorder/models/record.model.android.ts`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This may look a whole lot like the iOS side, and that's because it will be nearly
    the same! In fact, this setup works great, so now we just want to fill in the
    Android specifics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Using nativescript-audio's TNSRecorder for Android in our RecordModel
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could use some fancy Android APIs and/or libraries for our recorder, but
    in this case, the **nativescript-audio** plugin we''re using for our cross-platform
    multitrack player also provides a cross-platform recorder. We could have even
    used it with iOS, but we wanted to specifically work with AudioKit''s powerful
    APIs there. However, here on Android, let''s use the recorder from the plugin
    and make the following modifications to `record.model.android.ts`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wow! Okay, a lot of interesting things going on here. Let''s get one necessary
    thing out of the way for Android and ensure for API level 23+ that permissions
    are properly handled. For this, you can install the permissions plugin:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We also want to ensure our manifest file contains the proper permission key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/App_Resources/Android/AndroidManifest.xml` and add the following
    in the correct place:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use the nativescript-audio plugin's `TNSRecorder` as our implementation and
    wire things up accordingly to its API. `AudioRecorderOptions` provides a `metering`
    option, allowing the ability to monitor the microphone's meters via an interval.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: What is most versatile about our overall design is that our model's target can
    literally be anything. In this case, we create a RxJS Subject observable as `_target$`,
    which is then returned as our target getter. This allows us to emit the microphone's
    meter value through the `Subject` observable for consumption by our Waveform.
    You will see in a moment how we will take advantage of this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move on to our Waveform implementation for Android.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Just like we did for the model, we will want to refactor the common bits into
    a shared file and handle the suffix.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `app/modules/shared/native/waveform-common.ts`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, just adjust `app/modules/shared/native/waveform.ts` to use it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before renaming our waveform to contain an `.ios` suffix, let''s generate a
    TypeScript definition file for it first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You may again see TypeScript errors or warnings, but we don''t need to worry
    about those, as it should have still generated a `waveform.d.ts` file. Let''s
    simplify it slightly to contain only the parts that are applicable to both iOS
    and Android:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Okay, now, rename `waveform.ts` to `waveform.ios.ts` and create `app/modules/shared/native/waveform.android.ts`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Okay, excellent! This is the barebones setup we will need, *but what native
    Android view should we use?*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking around for open source Android libs, you may come across
    a group of very talented developers with **Yalantis**, a fantastic mobile development
    company based out of Ukraine. Roman Kozlov and his team created an open source
    project, **Horizon**, which provides beautiful audio visualizations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Yalantis/Horizon](https://github.com/Yalantis/Horizon)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/](https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like for iOS, we also want to prepare for a multifaceted Waveform view
    that can also render a static waveform for just a file. Looking further through
    the open source options, we may come across another wonderfully talented team
    with **Semantive**, based in Warsaw, the sprawling capital of Poland. They created
    an incredibly powerful Waveform view for Android:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Semantive/waveform-android](https://github.com/Semantive/waveform-android)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Let's integrate both of these libraries for our Android Waveform integration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to how we integrated AudioKit for iOS, let''s create a folder in the
    root called `android-waveform-libs` with the following setup, that provides `include.gradle`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)Why deviate from the `nativescript-` prefix when including
    native libs?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The prefix is a good way to go if you plan to refactor the internal plugin into
    an open source plugin published via npm for the community down the road, using
    [https://github.com/NathanWalker/nativescript-plugin-seed](https://github.com/NathanWalker/nativescript-plugin-seed)
    for instance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you just need to integrate several native libs for a specific platform,
    as we are in this case, so we don't really need the `nativescript-` prefix on
    our folder.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'We make sure to add `package.json`, so we can add these native libs like we
    would any other plugin:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we simply add them as a plugin to our project:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are now ready to integrate these libs into our Waveform view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the following modifications to the `app/modules/shared/native/waveform.android.ts` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We begin our Android implementation by defining the `const` references to the
    various packaged classes we need to access, to alleviate having to reference the
    fully qualified package location each time in our Waveform. Just like on the iOS
    side, we design a dual-purpose Waveform by allowing the type (`'mic'` or `'file'`)
    to drive which rendering to use. This allows us to reuse this with our record
    view for real-time microphone visualization and the other to statically render
    our tracks as Waveforms (more on that soon!).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The Horizon lib utilizes Android''s `GLSurfaceView` as the primary rendering,
    hence:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: During development, we found that `GLSurfaceView` requires at least a height
    to constrain it, otherwise it would render at full screen height. Therefore, we
    explicitly set a reasonable `height` of `200` to the custom NativeScript view,
    which will automatically handle measuring the native view for us. Interestingly,
    we also found that sometimes our model setter would fire *before* `initNativeView`
    and other times *after*. Because the model is a critical binding for initializing
    our Horizon view, we designed a custom internal `_initView` method with the appropriate
    conditional, which could be called from `initNativeView`, as well as after our
    model setter fired. The condition (`!this._initialized && this.nativeView && this.model`)
    ensures it's only ever initialized once though. This is the way to handle any
    potential race conditions around the sequence of these method calls.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The native `Horizon.java` class provides an `update` method that expects a
    Java byte array with a signature:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What we do in NativeScript for this is retain a reference to a construct that
    will represent this native Java byte array with the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Utilizing Android's `android.media.AudioRecord` class, in conjunction with the
    various recorder settings that we set up, we are able to gather an initial `bufferSize`,
    that we use to initialize our byte array size.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'We then take advantage of our overall versatile design, wherein our model''s
    target in this implementation is an rxjs Subject Observable, allowing us to subscribe
    to its event stream. For the `''mic''` type, this stream will be the metering
    value changes from the recorder, which we use to fill our byte array and in turn
    update the `Horizon` view:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This provides our recorder a nice visualization, which will animate as the
    input level changes. Here''s a preview; however, the style is still a little ugly,
    since we have not applied any CSS polish just yet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: For our static audio file waveform rendering, we initialize `WaveformView` with
    the Android context. We then use its API to configure it for our use during construction
    in `createNativeView`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'During initialization, we create an instance of `CheapSoundFile` as required
    by `WaveformView`, and interestingly, we use `setSoundFile` inside `setTimeout`,
    alongside a call to `this.nativeView.invalidate()`, which is calling invalidate
    on `WaveformView`. This causes the native view to update with the processed file,
    as follows (again, we will address the styling polish later):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced a wealth of powerful concepts and techniques on
    how to work with native APIs on iOS and Android. Knowing how to work with open
    source native libraries is fundamental to getting the most out of your app development
    and achieving the feature set you are after. Direct access to these APIs right
    from TypeScript gives you the luxury of never leaving your preferred development
    environment, as well as engaging with the languages you love in a fun and accessible
    way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, learning solid practices around how/when to create custom NativeScript
    views and interworking them throughout your Angular app are among the key elements
    to leverage the most of this tech stack.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will provide some extra goodies by empowering our track
    list view with more bells and whistles, leveraging some of what you've learned
    here.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
