- en: Chapter 2. App Development with Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn C++ app development with Code::Blocks. We'll begin
    with a simple Hello World app. Subsequently concept of project and workspace will
    be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first app with Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple Hello World app, which essentially prints out "Hello
    World" to console. Launch Code::Blocks to begin and as shown in the following
    screenshot click on the new button in main toolbar and then click on the **File**
    menu option. The following screenshot represents the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first app with Code::Blocks](img/3415_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **C/C++ source** option in the next window and then on the **Go**
    button. A wizard will be presented. Click on the **Next** button on the first
    page of the wizard. Choose the **C++** option and click on the **Next** button.
    Choose file path and name in the next window and click on the **Finish** button
    to complete wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then type the following code in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code::Blocks will automatically add an empty line at the end of the file if
    there isn't any, this is a Code::Blocks feature. GCC expects an empty line at
    the end of source code, and it will throw warning if an empty line is missing.
    Thus you may notice an empty line is being added automatically by Code::Blocks.
  prefs: []
  type: TYPE_NORMAL
- en: After the code is typed in the editor window Code::Blocks will look similar
    to the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first app with Code::Blocks](img/3415_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now click on the save button in main toolbar to save this file (navigate to
    **File** | **Save** from the dropdown menu bar). Alternatively *Ctrl* + *S* key
    combination can be used to save a file. We can see that Code::Blocks has applied
    syntax highlighting to the code and it has made the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the build button in the Compiler toolbar or hit *Ctrl* + *F9*
    key combination to compile it. If everything goes well Code::Blocks will look
    similar to the previous screenshot. Now click on the run button in Compiler toolbar.
    Code::Blocks will now run the program. As seen in the following screenshot our
    first program has run successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first app with Code::Blocks](img/3415_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows that the program execution has been completed
    and it is waiting for user input to close the window. This is a Code::Blocks feature
    which stops after the execution is completed in order to allow the users to study
    program output.
  prefs: []
  type: TYPE_NORMAL
- en: Our first assignment is successful. However, this approach has several drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Code::Blocks applies global compiler/linker flags during compilation of individual
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code::Blocks behaves purely as a text editor (imagine Notepad) and most features
    can't be used to compile individual files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also management of large projects comprising of individual files is cumbersome.
    So the concept of **Project** has evolved. In the next section we'll learn more
    about projects in Code::Blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Project in Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project is an important concept in Code::Blocks. A project can be described
    as a collection of source files and build targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project in Code::Blocks](img/3415_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A build target can be defined as a label or a tag for each source file, which
    contains separate set of build (compiler, linker and resource compiler) options.
    Each build target contains a set of build options and during compilation of a
    project Code::Blocks selects currently active target. All files of that target
    is then compiled using that build target's build options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project in Code::Blocks](img/3415_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A project requires a minimum of one target and one source file to compile. A
    source file may be part of all or none of the targets. Build targets can be dependent
    upon other targets, which in turn helps to maintain a relationship between different
    source files. We'll explain a bit more on importance of build targets in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before doing that let''s create a project and develop an app. Perform the
    following steps for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the new button in the main toolbar, then click on the **Project** menu
    option. A wizard will be presented, as shown in the following screenshot. Now
    select **Console application** and click on the **Go** button:![Project in Code::Blocks](img/3415_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button on the first page of the wizard. Then choose **C++**
    and click on the **Next** button as shown in the following screenshot:![Project
    in Code::Blocks](img/3415_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following screenshot enter **Project title** (app name) as `App1`
    and choose a folder to create `App1` project. Now, click on the **Next** button
    to continue.![Project in Code::Blocks](img/3415_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button in the **Console application** window as shown
    in the following screenshot and the project will be generated with a default code:![Project
    in Code::Blocks](img/3415_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows the **Management** window that has been populated
    with the newly created project files. Double-click on the `main.cpp` item on the
    tree to open the Code::Blocks editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project in Code::Blocks](img/3415_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s replace the default code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have replaced earlier `HelloWorld` code with a code using **Object Oriented
    Programming** (**OOP**) concepts of C++. We have used C++ classes to achieve the
    same goal of printing "Hello World!" text.
  prefs: []
  type: TYPE_NORMAL
- en: C++ classes are specific data types that can be defined as a collection of data
    structure and member functions that operate on these data structures. All member
    functions and base classes are `private` by default. Classes can contain overloaded
    operator which allows customized operations associated with a particular class.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can also be defined with a `struct` keyword. However, all members, that
    is, functions and base classes are `public` by default if a class is defined with
    a `struct` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze our code. We have defined a class named `HelloWorld`. We have
    also defined a `constructor` function `HelloWorld()` and a `destructor` function
    `~HelloWorld()`. We have a publicly accessible function named `Print()` to print
    out `"Hello World!"` text. In the `main()` function we created an object named
    `hello` of class `HelloWorld` and then we have used it to call `Print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *F9* key to build and then run this project. A console window will pop up
    displaying "Hello World!" text.
  prefs: []
  type: TYPE_NORMAL
- en: Project with multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we'll learn about C++ app development comprising of multiple
    files. We'll develop a class, called `Vector`, which implements a dynamic array.
    This class is similar to the `std::vector` class offered by **Standard Template
    Library** (**STL**) and has a very limited set of features compared to STL class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and name it `App2`. Navigate to **File** | **New** | **File…**
    menu option and then choose **C/C++ header** option and follow the wizard to add
    a new file to `App2` project. Add the following code in a new file under `App2`
    and name it `vector.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Header file `vector.h` declares the `Vector` class structure. We have a pre-processor
    macro `DATA_TYPE` that defines the data type that this class holds. We have a
    constructor (with a default parameter) and a destructor function. These functions
    will allocate and de-allocate a pointer `m_data` that holds array of elements.
    A member variable `m_size` will be used to hold size of array that will assist
    us in bound-checking.
  prefs: []
  type: TYPE_NORMAL
- en: There are several member functions that operate on the member variables. The
    `GetCount()` function returns number array size, `Set()` function assigns a value
    to an element in array. An operator `[]` has been overloaded to access array data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vector` class has been implemented in the `vector.cpp` file. Create and
    add this new file to `App2` project and then copy the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The line `m_size(size)` defines an initializer list. where member variables
    are initialized as per the order they have been declared. We have used new operator
    to allocate an array of size given by user. The `memset()` function initializes
    that array with zeroes. In destructor internal array is checked for null pointer
    and then de-allocated with `delete []` keyword and assigned a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Null pointers have a value (typically `0`) that is reserved to indicate that
    it doesn't point to any valid object. Any operation on null pointers will lead
    to a segmentation fault or access violation. In such a case, app will die instantly.
    C++ 11 defines a separate `nullptr` constant to define a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: There are two member functions, `Set()` and `GetCount()` that operate on the
    internal array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, replace code inside the `main.cpp` file with the following code. It
    creates an object of `Vector` class and subsequently uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the **Management** window will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with multiple files](img/3415_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll define a pre-processor define to ensure that the **Vector** class is
    compiled as an array of integers. Navigate to **Project** | **Build options…**
    menu option and the **Project build options** window will be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with multiple files](img/3415_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we intend to apply the settings throughout the project click on the root
    of the project tree in that window. Now, click on the **Compiler settings** |
    **#defines** tab and add the line as per the preceding screenshot. Further, click
    on the **OK** button to close that dialog box. Now compile and run this project.
    This will produce result as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with multiple files](img/3415_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our code we have a pre-processor macro `DATA_TYPE` that defines the data
    type that this class holds. If we intend to use it as an array of `double` we
    have to recompile this app.
  prefs: []
  type: TYPE_NORMAL
- en: Do note that pre-processor macros work by simple text substitution and no type
    checking is performed on them during substitution. This can introduce other bugs
    in the program if it is used incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we learned about app development with multiple files, tweaking
    of compiler options.
  prefs: []
  type: TYPE_NORMAL
- en: Debug versus release target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We noticed that in `App1` and `App2`, there are two build targets in each project—namely
    **debug** and **release**. In this section we'll learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Code::Blocks defines two default build targets—debug and release at the time
    of a project creation.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests a debug target is suitable for app debugging. Appropriate
    compiler options are added to generate debugging symbols in the compiled app.
    It also disables all program optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find in the following screenshot (navigate to **Project** | **Build
    options…** menu option) a **Debug** target has a compiler option **Produce debugging
    symbols**. This instructs compiler to generate debugging symbols, which allows
    app debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug versus release target](img/3415_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A **Release** target disables generation of debugging symbols. It also defines
    appropriate compiler options to optimize the program. Thus this is suitable for
    code to be used in production. The following screenshot shows typical compiler
    flags in a release target.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug versus release target](img/3415_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These two targets are quite important as it is difficult to debug a program
    that has been compiled with compiler optimization flags enabled. It is highly
    recommended that the program is compiled without optimization in debug target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this problem we''ll use the following code snippet, then compile
    and debug it. Note that we will use command-line tools to avoid abstraction of
    any error message by Code::Blocks UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now compile it in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use GNU debugger `gdb` to debug and understand the flow of execution.
    Launch `gdb` and follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We asked `gdb` to load `app4.exe` in memory. Then we asked `gdb` to set two
    **breakpoints** by issuing command `b` and specifying the line number. We asked
    `gdb` to run the program. As instructed by breakpoints the execution is paused
    at each breakpoint. Subsequently the program completes without any error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we turn optimizations on. We''ll compile it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now debug this app again following earlier steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is evident from the preceding output that compiler has optimized our source
    code and made a number of changes to the code. The function `add()` seems to have
    been expanded inline. As a result breakpoint on line `return (a + b)` of `main.cpp`
    file is never hit during execution.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the side effects of optimization on debugging process. Code::Blocks
    creates two default targets to avoid similar situation. It is highly recommended
    that this is followed in project development.
  prefs: []
  type: TYPE_NORMAL
- en: Project with external library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we'll develop an app with an external library. External libraries
    are used in almost every project written in any language. They allow code reuse
    resulting faster project cycle. We'll learn how to configure an external library
    with a Code::Blocks project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have printed `Hello World!` text to console. How about printing text in
    color? We can use a library called `conio2` ([http://conio.sourceforge.net/](http://conio.sourceforge.net/))
    to print text in color and do other text manipulations. A compiled copy of `conio2`
    library is provided together with the book. Consider the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example we have included `conio2.h` file in second line. This will expose
    pre-defined functions in `conio2` library to our app. We have defined couple of
    variables namely `screenWidth`, `msg`, and `textInfo` inside `main()` function.
    We have then retrieved current console text settings using `gettextinfo()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line we have saved current screen width to `screenWidth` variable.
    Subsequently we have assigned `YELLOW` foreground color and `RED` background color.
    We have used the `cputsxy()` function to print desired text. We have then restored
    text colors in the subsequent two lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up external library navigate to **Projects** | **Build options…**
    menu option and click on the **Search directories** tab as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with external library](img/3415_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Add `conio2\include` path (relative to project path) as shown in the preceding
    screenshot. We can also use full path if `conio2` library is installed in another
    location. This will instruct compiler to also search this directory for any header
    files referred in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Next click on the **Linker** tab as shown in the following screenshot and add
    the `conio2\lib` relative path as per the following screenshot. This will instruct
    linker to also search static library in this path.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with external library](img/3415_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Linker settings** tab and add `libconio.a` as per the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with external library](img/3415_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this step is completed our app is ready for compilation. Now compile
    and run it. We''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project with external library](img/3415_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our app is now using an external C/C++ library. We can use other external libraries
    in a similar manner for our app development.
  prefs: []
  type: TYPE_NORMAL
- en: Workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workspace in Code::Blocks is a collection of projects. Workspace acts as a container
    of projects and also maintains project dependencies. So if project 2 is dependent
    upon project 1, then project 2 will be compiled before compilation of project
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following snippets. Create a static library project named `libcalc`
    by navigating to **File** | **New** | **Project…** and select **Static library**
    wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then replace code of project''s `main.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next create a console project named `App6` and then replace its `main.cpp`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Management** window now shows two projects in one workspace. Workspace
    has been renamed to `App6` in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Workspace](img/3415_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This workspace can be saved by navigating to **File** | **Save workspace as…**
    menu option. Right-click on the **App6** project in project tree and click on
    the Screenshot menu option. Next click on the **Project''s dependencies** button.
    The following window will be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Workspace](img/3415_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Close** button to close this window and then the **OK** button
    to close **Project/target options** window. Now `App6` is dependent upon `libcalc`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Now navigate to **Project** | **Build options…** menu option and add `..\libcalc\libcalc.a`
    to **Link libraries** in **Linker settings** tab.
  prefs: []
  type: TYPE_NORMAL
- en: To compile these two projects navigate to the **Build** | **Build workspace**
    menu option. Code::Blocks will now build `App6` taking care of its dependent project.
  prefs: []
  type: TYPE_NORMAL
- en: It is now quite clear that we can use workspace to manage sub-projects in a
    large project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learned to create project in Code::Blocks. We understood
    the importance of build targets. We also learned to use external libraries in
    our project. Finally, we learned to create and use a workspace.
  prefs: []
  type: TYPE_NORMAL
- en: With this we conclude our introduction to projects in Code::Blocks. We'll discuss
    debugging in the next chapter.
  prefs: []
  type: TYPE_NORMAL
