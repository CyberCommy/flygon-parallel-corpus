- en: Understanding PHP Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP array is one of the most used data types in PHP. Most of the time we
    use it without considering the impact of PHP arrays in our developed code or application.
    It is so easy to use and dynamic in nature; we love to use PHP arrays for almost
    any purpose. Sometimes we do not even want to explore if there are other available
    solutions which can be used instead of PHP array. In this chapter, we are going
    to explore the positives and negatives of PHP arrays, along with how to use arrays
    in different data structure implementations along with boosting performances.
    We will start with explaining different types of arrays in PHP followed by creating
    fixed sized arrays. Then we are going to see the memory footprints for PHP array
    elements and how can we improve them along with some data structure implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP arrays in a better way
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHP arrays are so dynamic and flexible that we have to think about whether
    it is a regular array, an associative array, or a multidimensional array, as in
    some other languages. We do not need to define the size and data type of the array
    we are going to use. How can PHP do that, while other languages like C and Java
    cannot do the same? The answer is very simple: the array concept in PHP is not
    actually the real array, it is actually a **HashMap** . In other words, a PHP
    array is not the plain and simple array concept we have from other languages.
    A simple array will look like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00017.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: 'But, we can definitely do that with PHP. Let us check with an example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line shows how a typical array should look. Similar types of data have
    a sequential index (starting from 0 to 4) to access the values. So who says a
    PHP array is not a typical array? Let us explore some more examples. Consider
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is a PHP array that we use on a daily basis; we do not define the size and
    we are storing integers, a floating point number, a string, and even another array.
    Does it sound odd or is it just a super power of PHP? We can look at the definition
    from [http://php.net](http://php.net) .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: An array in PHP is actually an **ordered map** . A map is a type that associates
    values to keys. This type is optimized for several different uses; it can be treated
    as an array, list (vector), hash table (an implementation of a map), dictionary,
    collection, stack, queue, and probably more. As array values can be other arrays,
    trees and multidimensional arrays are also possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: So a PHP array has got real super powers and it can be used for all possible
    data structures such as list/vector, hash table, dictionary, collection, stack,
    queue, doubly linked list, and so on. It seems that the PHP array has been built
    in such a way that it is either optimized for everything or it is not optimized
    for anything. We will explore that in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to categorize the array, then there are mainly three types of arrays:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Numeric array
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional array
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to explore each type of array with some examples and explanations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Numeric array
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A numeric array does not mean it only holds numeric data. In fact, it means
    the indexes will be numbers only. In PHP they can either be sequential or non-sequential
    but they have to be numeric. In numeric arrays, values are stored and accessed
    in a linear way. Here are some examples of PHP numeric array:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will have the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a very simple example where we have an array defined and indexes are
    autogenerated from 0 and incremented with the value of the array. When we add
    a new element in the array using `$array[]` , it actually increments the index
    and assigns the value in the new index. That is why value 70 has the index 5 and
    80 has the index 6.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: If our data is sequential, we can always use a `for` loop without any problem.
    When we say sequential, we do not mean just 0,1,2,3....,*n* . It can be 0,5,10,15,20,......,*n*
    where *n* is a multiple of 5\. Or it can be 1,3,5,7,9......,*n* where *n* is odd.
    We can create hundreds of such sequences to make the array numeric.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'A big question can be, if the indexes are not sequential, can''t we construct
    a numeric array? Yes definitely we can. We just have to adopt a different way
    to iterate. Consider the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we look at the indexes, they are not sequential. They are having random
    indexes such as `10` followed by `21` , `29` , and so on. Even at the end we have
    the index `71` , which is much smaller than the previous one of `1001` . So, should
    the last index show in between 29 and 500? Here is the output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Couple of things to notice here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We are iterating the array the way we entered the data. There is no internal
    sorting of the indexes at all, though they are all numeric.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting fact is that the size of the array `$array` is only `6`
    . It is not `1002` like C++, Java, or other languages where we need to predefine
    the size of the array before using it, and the max index can be *n-1* where *n*
    is the size of the array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Associative array
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An associative array is accessed by a key which can be any string. In an associative
    array, values are stored against the key instead of a linear index. We can use
    an associative array to store any type of data, just like the numeric array. Let
    us create a student array where we will store student information:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the output of the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we are using each key to hold one piece of data. We can add as many keys
    as we need without any problem. This gives us the flexibility to represent a data
    structure similar to structure, map, and dictionary using a PHP associative array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional array
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A multidimensional array contains multiple arrays in it. In other words, it
    is an array of array(s). In this book, we will be using multidimensional arrays
    in different examples as they are one of the most popular and efficient ways of
    storing data for graphs and other tree-type data structures. Let us explore the
    PHP multidimensional array using an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The example we just saw is an example of a two-dimensional array. As a result,
    we are using two `foreach` loops to iterate the two-dimensional array. Here is
    the output of the code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can create n-dimensional arrays using PHP as per our needs, but we have
    to remember one thing: the more dimensions we add, the more complex the structure
    becomes. We as humans usually visualize three dimensions, so in order to have
    more than three-dimensional arrays, we must have a solid understanding of how
    an array works in multiple dimensions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We can use both a numeric array and an associative array as a single array in
    PHP. But in such a case, we have to be very cautious to choose the right way to
    iterate through the array elements. In such cases, `foreach` will be a better
    choice than a `for` or `while` loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Using an array as flexible storage
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen a PHP array as a dynamic, hybrid data structure for storing
    any type of data. This gives us a lot more freedom to utilize an array as a flexible
    storage container for our data. We can mix different data types and different
    dimensions of data in a single array. We do not have to even define the size or
    type of array we are going to use. We can grow, shrink, and modify data to and
    from an array whenever we need to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does PHP allows us to create dynamic arrays, but it also provides
    us with lots of built-in functionalities for arrays. For example: `array_intersect`
    , `array_merge` , `array_diff` , `array_push` , `array_pop` , `prev` , `next`
    , `current` , `end` , and many more.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Use of multi-dimensional arrays to represent data structures
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In coming chapters, we will talk about many different data structures and algorithms.
    One of the key data structures we are going to focus is the graph. We already
    know the definition of graph data structures. Most of the time we will be using
    PHP multidimensional arrays to represent that data as an adjacency matrix. Let
    us consider the following graph diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00018.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Now if we consider each node of the graph to be a value of an array, we can
    represent the nodes as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But this will only give us node names. We cannot connect or create a relationship
    between nodes. In order to do that, we need to construct a two-dimensional array
    where the node names will be keys, and values will be 0 or 1 based on the interconnectivity
    of two nodes. Since there is no direction provided in the graph, we do not know
    if *A* connects to *C* or if Connects to *A* . So we will assume both are connected
    to each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an array for the graph and initialize each node of
    the two-dimensional arrays as 0\. The following code will exactly do that:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us print the array using the following code so that we see how it looks
    actually before defining the connectivity between nodes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As no connection between the nodes has been defined, all cells are showing
    0\. So the output looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we will define the connectivity of the nodes in such a way that a connection
    between the two nodes will be expressed as a value of 1, just like the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As there is no direction given in the graph diagram, we will consider it as
    the undirected graph and hence we are setting two values to 1 for each connection.
    For the connection between *A* and *B* , we are setting both `$graph["A"]["B"]`
    and `$graph["B"]["A"]` to `1` . We will learn more about defining connectivity
    between nodes and why we are doing it in later chapters. For now we are just focusing
    on how to use multidimensional arrays for data structures. We can reprint the
    matrix and this time, the output looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will be much more fun and interesting to find out more about graphs and their
    operations in [Chapter 9](text00202.html) , *Putting Graphs into Action* .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Creating fixed size arrays with the SplFixedArray method
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explored PHP arrays and we know, we do not define the size of
    the arrays. PHP arrays can grow or shrink as per our demand. This flexibility
    comes with a great inconvenience regarding memory usage. We are going to explore
    that in this section. For now, let us focus on creating fixed size arrays using
    the SPL library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need a fixed size array? Does it have any added advantage? The answer
    is that when we know we only need a certain number of elements in an array, we
    can use a fixed array to reduce the memory usage. Before going to the memory use
    analysis, let us have some examples of using the `SplFixedArray` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we are creating a new `SplFixedArray` object with a defined size of
    10\. The remaining lines actually follow the same principle which we use in regular
    PHP array value assignment and retrieval. If we want to access an index which
    is out of the range (here it is 10), it will throw an exception:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The basic difference between a PHP array and `SplFixedArray` are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`SplFixedArray` must have a fixed defined size'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indexes of `SplFixedArray` must be integers and within the range of 0 to
    *n* , where *n* is the size of the array we defined
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SplFixedArray` method can be very handy when we have a lot of defined arrays
    with known size or have an upper limit for the maximum required size of the array.
    But if we do not know the array size, then it is better to use a PHP array.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Performance comparison between a regular PHP array and SplFixedArray
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key questions we encountered in the last section was, why should
    we use `SplFixedArray` instead of PHP arrays? We are now ready to explore the
    answer. We came across the concept that PHP arrays are actually not arrays rather
    than hash maps. Let us run a small example code in PHP 5.x version to see the
    memory usage of a PHP array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create an array with 100,000 unique PHP integers. As I am running a
    64 bit machine, I expect each integer to take 8 bytes each. So we will have around
    800,000 bytes of memory consumed for the array. Here is the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we run this code in our command prompt, we will see an output of 14,649,040
    bytes. Yes, it is correct. The memory usage is almost 18.5 times more than what
    we have planned for. That means, for each element in the array an overhead of
    144 bytes (18 * 8 bytes) for one PHP array. Now, where does this extra 144 bytes
    come from and why does PHP utilize so much extra memory for each array element?
    Here is an explanation of the extra bytes used by a PHP array:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00019.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'This diagram shows how a PHP array works internally. It stores data in a bucket
    to avoid collision and to accommodate more data. To manage this dynamic nature,
    it implements both a doubly linked list and hash table internally for array. Eventually,
    it costs lots of extra memory space for each individual elements in the array.
    Here is the breakdown of the memory consumption of each element based on the PHP
    array implementation code (C code):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **32 bit** | **64 bit** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| zval | 16 bytes | 24 bytes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| + cyclic GC info | 4 bytes | 8 bytes |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| + allocation header | 8 bytes | 16 bytes |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| zval (value) total | 28 bytes | 48 bytes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| bucket | 36 bytes | 72 bytes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| + allocation header | 8 bytes | 16 bytes |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| + pointer | 4 bytes | 8 bytes |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| bucket (array element) total | 48 bytes | 96 bytes |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| Grand total (bucket+zval) | 76 bytes | 144 bytes |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: 'In order to understand the internal structure of a PHP array, we need to study
    in depth about PHP internals. It is beyond the scope of this particular book.
    A good recommended read is: [https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html](https://nikic.github.io/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new PHP 7 version, there is a very big improvement in the PHP array
    and how it is constructed internally. As a result, the 144 bytes overhead on each
    element has come down to 36 bytes only. That is a big improvement and it is applicable
    for both 32 bit and 64 bit OS. A comparison chart, having a range of 100,000 items
    in an array, is shown as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| **$array = Range(1,100000)** | **32 bit** | **64 bit** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| PHP 5.6 or below | 7.4 MB | 14 MB |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| PHP 7 | 3 MB | 4 MB |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: 'So, in other words, PHP 7 has an improvement factor of 2.5 times for 32 bit
    and 3.5 times for 64 bit system for array storage. That is a really good improvement.
    But this was all about a PHP array, what about `SplFixedArray` ? Let us run the
    same example using `SplFixArray` in both PHP 7 and PHP 5.x:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have written the memory consumption functionality of a `SplFixedArray` here.
    If we just change the line `$array = new SplFixedArray($items);` to `$array =
    [];` , we will have the same code running as for a PHP array.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The benchmark result can vary from machine to machine as there can be different
    OS, memory size, debugger on/off, and so on. It is always suggested to run the
    codes in your own machines to generate a similar benchmark for comparisons.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a comparison of memory consumption of a PHP array and `SplFixedArray`
    for an array with 100,000 integers in a 64 bit system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '| **100,000 items** | **Using PHP array** | **SplFixedArray** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| PHP 5.6 or below | 14 MB | 6 MB |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| PHP 7 | 5 MB | 2 MB |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: Not only in memory usage, `SplFixedArray` is also faster in execution compared
    to general PHP array operations such as accessing value, assigning value, and
    so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Though we use the `SplFixedArray` object with [] just like the array, PHP array
    functions will not be applicable for `SplFixedArray.` We cannot directly apply
    any PHP array functions such as `array_sum` , `array_filter` , and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: More examples using SplFixedArray
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `SplFixedArray` has a good performance boost indicator, we can utilize
    it instead of a regular PHP array in most of our data structures and algorithms.
    Now we will explore some more examples of using `SplFixedArray` in different scenarios.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Changing from a PHP array to SplFixedArray
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how we can create a `SplFixedArray` with a fixed length. What
    if I want to create an array to `SplFixedArray` during runtime? The following
    code block shows how to achieve it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here we are constructing a `SplFixedArray` from an existing array `$array`
    using the static method `fromArray` of the `SplFixedArray` class. Then we are
    printing the array using the PHP `print_r` function. It will show an output like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see the array has been now converted to an `SplFixedArray` and it maintained
    the index number exactly as it was in the actual array. Since the actual array
    did not have 0 index defined, here index 0 is kept as null. But if we want to
    ignore the indexes from the previous array and assign them new indexes, then we
    have to change the second line of the previous code to this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now if we print the array again, we will have the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we want to convert an array to a fixed array during runtime, it is a better
    idea to unset the regular PHP array if it is not being used later on. It will
    save memory usage if it is a big array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Converting a SplFixedArray to a PHP array
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might also need to convert a `SplFixedArray` to a regular PHP array to apply
    some predefined array functions from PHP. Like the previous example, this is also
    a very simple thing to do:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will produce the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Changing the SplFixedArray size after declaration
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are defining the array size at the beginning, we may require changing
    the size later on. In order to do that, we have to use the `setSize()` method
    of the `SplFixedArray` class. An example is shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating a multidimensional array using SplFixedArray
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might also require creating two or more dimensional arrays using `SplFixedArray`
    . In order to do that, it is recommended to follow this example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are actually creating another `SplFixedArray` inside each array indexes.
    We can add as many dimensions as we want. But we have to remember that, with dimensions,
    we are multiplying the size of the array. So it can grow really big very quickly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Understanding hash tables
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming language, a hash table is a data structure which is used to
    make an array associative. It means we can use keys to map values instead of using
    an index. A hash table must use a hash function to compute an index into an array
    of buckets or slots, from which the desired value can be found:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00020.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'As we have mentioned several times, a PHP array is actually a hash table and
    hence it supports associative arrays. We need to remember one thing: that we do
    not need to define a hash function for the associative array implementation. PHP
    does it internally for us. As a result, when we create an associative array in
    PHP, we are actually creating a hash table. For example, the following code can
    be considered as the hash table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a matter of fact, we can directly invoke any keys with only **O(1)** complexity.
    The key will always refer to the same index inside the bucket, as PHP will use
    the same hash function to calculate the index.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Implementing struct using a PHP array
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know, a struct is a complex data type where we define multiple
    properties as a group so that we can use it as a single data type. We can write
    a struct using a PHP array and class. Here is an example of a struct using a PHP
    array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is simply an associative array with keys as string. A complex struct can
    be constructed using single or more constructs as its properties. For example
    using the player struct, we can use a team struct:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we have seen both ways of defining a struct, we have to choose either
    one of them to implement a struct. While creating an object might look more convenient,
    it is slower compared to array implementation. Where an array has an added advantage
    of speed, it also has a disadvantage as it takes more memory space compared to
    an object. Now we have to make the decision based on our preference.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sets using a PHP array
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A set is a simply a collection of values without any particular order. It can
    contain any data type and we can run different set operations such as union, intersection,
    complement, and so on. As a set only contains values, we can construct a basic
    PHP array and assign values to it so that it grows dynamically. The following
    example shows two sets that we have defined; one contains some odd numbers and
    the other one has some prime numbers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to check the existence of a value inside the set along with union,
    intersection, and complement operation, we can use the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'PHP has many built-in functions for such operations and we can utilize them
    for our set operations. But we have to consider one fact: since the set is not
    ordered in any particular way, searching using the `in_array()` function might
    have the complexity of **O(n)** in worst case scenario. Same goes for the `array_merge()`
    function, as it will check each value from one array with another array. In order
    to speed things up, we can modify our code a little bit and make it efficient:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we analyze this code, we can see that we are using an index or key to define
    the set. Since a PHP array index or key lookup have a complexity of **O(1),**
    it makes the searching much faster. As a result, all the lookup, union, intersect,
    and complement operations will take lesser time compared to the previous example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Best usage of a PHP array
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though a PHP array consumes more memory, the flexibility of using a PHP array
    is much more important for many data structures. As a result, we will use a PHP
    regular array as well as `SplFixedArray` in many of our data structure implementations
    and algorithms. If we just consider a PHP array as a container for our data, it
    will be easier for us to utilize its immensely powerful features in many data
    structure implementations. Along with built-in functions, a PHP array is definitely
    a must use data structure for programming and developing applications using PHP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: PHP has some built-in sorting functions for an array. It can sort using keys
    and values along with keeping association while sorting. We are going to explore
    these built-in functions in [Chapter 7](text00165.html) , *Using Sorting Algorithms*
    .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: PHP array, is it a performance killer?
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in this chapter how each element in a PHP array has a very big
    overhead of memory. Since it is done by the language itself, there is very little
    we can do over here, except that we use `SplFixedArray` instead of a regular array
    where it is applicable. But if we move from our PHP 5.x version to the new PHP
    7, then we can have a huge improvement in our application, whether we use regular
    PHP array or `SplFixedArray` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 7, the internal implementation of a hash table has been changed drastically
    and it is not built for efficiency. As a result, the overhead memory consumption
    for each element has gone down significantly. Though we can argue that less memory
    consumption does not make a code speedy, we can have a counter argument that if
    we have less memory to manage, we can focus more on execution rather than memory
    management. As a result, we have some impact on the performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: So far from the discussion, we can easily say the newly improved array in PHP
    7 is definitely a recommended choice for developers to solve complex and memory
    efficient applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从讨论中可以很容易地得出结论，PHP 7中新改进的数组绝对是开发人员解决复杂和内存高效应用程序的推荐选择。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have focused our discussion on PHP arrays and what can be
    done using a PHP array as a data structure. We are going to continue our exploration
    of array features in the coming chapters. In the next chapter, we are going to
    focus on linked list data structures and different variants of linked list. We
    are also going to explore different types of practical examples regarding linked
    lists and their best usages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于讨论PHP数组以及使用PHP数组作为数据结构可以做什么。我们将在接下来的章节中继续探讨数组的特性。在下一章中，我们将专注于链表数据结构和不同变体的链表。我们还将探索关于链表及其最佳用法的不同类型的实际示例。
