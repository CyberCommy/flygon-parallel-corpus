- en: Debugging Tools for Memory Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We humans (we assume a human is reading this book and not some form of AI, though,
    who knows nowadays) are good at many intricate, complex tasks; but, we're also
    terrible at many mundane ones. That's why we invented computers—with the software
    to drive them!
  prefs: []
  type: TYPE_NORMAL
- en: 'Well. We''re not really great at spotting details buried deep inside C (or
    assembly) code—memory bugs are a prime example of cases where we humans can use
    help. So, guess what: we''ve invented software tools to help us—they do the mundane,
    boring job of instrumenting and checking millions and billions of lines of our
    code and binaries, and are getting really effective at catching our bugs. Of course,
    when all is said and done, the best tool is still your brain, but nevertheless
    one might well ask: Who and what will debug the tools that one uses for debugging? The
    answer, of course, is more tools, and you, the human programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the reader will learn to use two of the best-in-class memory
    debug tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind's Memcheck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizer tools (ASan)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful tables summarizing and comparing their features are provided. Also, glibc's
    malloc tuning via `mallopt(3)` is seen.
  prefs: []
  type: TYPE_NORMAL
- en: This particular chapter has no source code of it's own; instead, we use the
    source code from the preceding chapter, [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux
    Memory Issues. *Our `membugs` program test cases will be tried and tested under
    both Valgrind and ASan to see if they can catch the memory bugs that our *memugs* program's
    test cases work hard to provide. Thus, we definitely suggest you look over the
    previous chapter, and the `membugs.c` source code, to regain familiarity with
    the test cases we will be running.
  prefs: []
  type: TYPE_NORMAL
- en: Tool types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Broadly speaking, within the scope of these areas, there are two kinds of tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic analysis tools work essentially by instrumenting the runtime process.
    Thus, to gain the most out of them, a lot of attention must be devoted to ensuring
    that the tools actually run over all possible code paths; done by carefully and
    painstakingly writing test cases to ensure complete code coverage*.* This is a
    key point and will be mentioned again (Importantly, [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points). While very powerful,
    dynamic analysis tools usually result in a significant runtime performance hit
    and more memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis tools, on the other hand, work upon source code; in this sense,
    they are similar to the compiler. They often go well beyond the typical compiler,
    aiding the developer in uncovering all kinds of potential bugs. Perhaps the original
    Unix *lint* program could be considered the precursor to today's powerful static
    analyzers. Nowadays, very powerful commercial static analyzers (with fancy GUI
    frontends) exist, and are worth the money and time one spends on them. The downside
    is that these tools might raise a lot of false positives; the better ones let
    the programmer perform useful filtering. We won't cover static analyzers in this
    text (see the *Further reading* section on the GitHub repository, for a list of
    static analyzers for C/C++).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check out some modern-day memory debug tools; they all fall into
    the dynamic analysis tools class. Do learn how to use them effectively—they're
    a necessary weapon against all kinds of **Undefined Behavior** (**UB**).
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Valgrind (pronounced as *val-grinned*) is an instrumentation framework for
    a suite of powerful tools. It is **open source software** (**OSS**), released
    under the terms of the GNU GPL ver. 2; it was originally developed by Julian Seward.
    Valgrind is an award-winning suite of tools for memory debugging and profiling.
    It has evolved to become a framework for creating dynamic analysis tools. In fact,
    it''s really a virtual machine; Valgrind uses a technology called **dynamic binary
    instrumentation** (DBI) to instrument code. Read more on its homepage: [http://valgrind.org/](http://valgrind.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tremendous upside of Valgrind is its tool suite—primarily the **Memory
    Checker** tool ( **Memcheck**). There are several other checker and profiling
    tools as well, enumerated in the following table (in alphabetical order):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Valgrind tool name** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| cachegrind | CPU cache profiler. |'
  prefs: []
  type: TYPE_TB
- en: '| callgrind | Extension to cachegrind; provides more callgraph info. KCachegrind
    is a good GUI visualizer for cachegrind/callgrind. |'
  prefs: []
  type: TYPE_TB
- en: '| drd | Pthreads bug detector. |'
  prefs: []
  type: TYPE_TB
- en: '| helgrind | Data Race detector for multithreaded applications (mostly Pthreads).
    |'
  prefs: []
  type: TYPE_TB
- en: '| massif | Heap profiler (heap usage graphing, max allocations tracking). |'
  prefs: []
  type: TYPE_TB
- en: '| Memcheck | Memory bugs detector; includes **out-of-bounds** (**OOB**) accesses
    (read&#124;write under&#124;overflow), uninitialized data accesses, UAF, UAR,
    memory leakage, double free, and overlapping memory region bugs. This is the default
    tool. |'
  prefs: []
  type: TYPE_TB
- en: Note that some of the lesser used tools (such as lackey, nulgrind, none), and
    some of the experimental tools (exp-bbv, exp-dhat, exp-sgcheck) have not been
    shown in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Select a tool for Valgrind to run via the `--tool=` option (giving any of the
    preceding as the parameter). In this book, we focus on Valgrind's Memcheck tool
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Using Valgrind's Memcheck tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcheck is Valgrind's default tool; you do not need to pass it explicitly,
    but can do so with the `valgrind --tool=memcheck <program-to-execute with params>`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a trivial example, let''s run Valgrind on the `df(1)` utility (on an Ubuntu
    box):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Valgrind literally takes over and runs the `df` process within it, instrumenting
    all dynamic memory accesses. It then prints its report. In the preceding code,
    the lines are prefixed with `==1577==`; that's just the PID of the `df` process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As no runtime memory bugs were found, no output appears (you will see the difference
    soon when we run our `membugs` program under Valgrind''s control). In terms of
    memory leakage, the report states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All these are zero values, so it's fine. If the values under `definitely lost`
    were positive, then this would indeed indicate a memory leakage bug that must
    be further investigated and fixed. The other labels—`indirectly`/`possibly lost`,
    `still reachable`—are often due to complex or indirect memory handling within
    the code base (in effect, they are usually false positives one can ignore).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `still reachable` usually signifies that, at process exit, some memory
    blocks were not explicitly freed by the application (but got implicitly freed
    when the process died). The following statements show this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In use at exit**: 3,577 bytes in 213 blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total heap usage**: 447 allocs, 234 frees, 25,483 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of a total of 447 allocs, only 234 frees were done, leaving 447 - 234 =
    213 blocks left unfreed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now for the interesting bit: let''s run our `membugs` program test cases
    (from the preceding [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux
    Memory Issues*) under Valgrind and see if it catches the memory bugs that the
    test cases work hard to provide.'
  prefs: []
  type: TYPE_NORMAL
- en: We definitely suggest you look over the previous chapter, and the `membugs.c`
    source code, to regain familiarity with the test cases we will be running.
  prefs: []
  type: TYPE_NORMAL
- en: The membugs program has a total of 13 test cases; we shall not attempt to display
    the output of all of them within the book; we leave it as an exercise to the reader
    to try running the program with all test cases under Valgrind and deciphering
    its output report.
  prefs: []
  type: TYPE_NORMAL
- en: It would be of interest to most readers to see the summary table at the end
    of this section, showing the result of running Valgrind on each of the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #1: Uninitialized memory access**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For readability, we remove parts of the output shown as follows and truncate
    the program pathname.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now under Valgrind''s control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, Valgrind has caught the uninitialized memory access bug! The text highlighted
    in bold clearly reveals the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice that though Valgrind can show us the call stack—including the
    process pathname—it seems to be unable to show us the line number in the source
    code where the offending bug is present. Hang on, though. We can achieve precisely
    this by running Valgrind with the debug-enabled version of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Common GCC flags used for debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'See the `gcc(1)` man page for details. Briefly:`-g`: Produce sufficient debugging
    information such that a tool such as the **GNU Debugger** (**GDB**) has to debug
    symbolic information to work with (modern Linux would typically use the DWARF
    format).'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ggdb`: Use the most expressive format possible for the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-gdwarf-4`: Debug info is in the DWARF-<version> format (ver. 4 is appropriate).'
  prefs: []
  type: TYPE_NORMAL
- en: '`-O0` : Optimization level `0`; good for debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we retry running Valgrind with the debug-enabled version
    of our binary executable, `membugs_dbg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As usual, read the call stack in a bottom-up fashion and it will make sense!
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: Please note that, unfortunately, it''s quite possible that the precise
    line numbers shown in the output as follows may not precisely match the line number
    in the latest version of the source file in the book''s GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the the source code (the `nl` utility is used here to show the code
    with all lines numbered):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can now see that Valgrind has indeed perfectly captured the buggy case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #5:** read overflow on compile-time memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Would you look at that!? Valgrind fails to catch the read overflow memory bug.
    Why? It''s a limitation: Valgrind can only instrument, and therefore catch, UB
    (bugs) on dynamically allocated memory. The preceding test case used static compile-time
    allocated memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try the same test, but this time using dynamically allocated memory;
    that''s precisely what test case #6 is designed to do.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #6:** read overflow on dynamic memory (for readability, we truncated
    some of the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Well, this time, plenty of errors were caught with precise call stack locations
    revealing the exact point in the source (as we have compiled with `-g`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #8:** **UAF** (**use-after-free**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8edb68da-2b47-4a7d-884a-5184c6a8bbe9.png)'
  prefs: []
  type: TYPE_IMG
- en: A (partial) screenshot of the action when Valgrind catches the UAF bugs
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind does catch the UAF!
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #8:** **UAR** (**use-after-return**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whoops! Valgrind does not catch the UAR bug!
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Case #13:** Memory leak case #3—lib API leak. We run the memory leak
    test case #3 by selecting 13 as the parameter to *membugs*. It''s useful to note
    that only when run with the `--leak-check=full` option does Valgrind display the
    origin of the leak (via the displayed call stack):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Valgrind man page recommends setting `--leak-resolution=high` and `--num-callers=` 
    to 40 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: The man page on `valgrind(1)` covers the many options it provides (such as logging
    and tool (Memcheck) options); take a look to gain a deeper understanding of this
    tool's usage.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind summary table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With respect to our test cases (incorporated into our `membugs` program), here
    is Valgrind''s report card and memory bugs given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test case #** | **Test case** | **Detected by Valgrind?** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **Uninitialized memory read** (**UMR**) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **Out-of-bounds **(**OOB**): write overflow [on compile-time memory]
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | OOB: write overflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | OOB: write underflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | OOB: read overflow [on compile-time memory] | No |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | OOB: read overflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | OOB: read underflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | UAF, also known as dangling pointer | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | UAR, also known as **use-after-scope **(**UAS**) | No |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Double free | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Memory leak test case 1: simple leak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Memory leak test case 1: lib API leak | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Valgrind pros and cons : a quick summary'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Valgrind pros*:*
  prefs: []
  type: TYPE_NORMAL
- en: Catches common memory bugs (UB) on dynamically allocated memory regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uninitialized variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-after-free / use-after-return (out-of-scope) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No modification to source code required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No recompile required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No special compiler flags required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Valgrind cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance: target software may run up to 10 to 30 times slower when run under
    Valgrind.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory footprint: each allocation within the target program requires Valgrind
    to make a memory allocation as well (making running Valgrind on highly-resource-constrained
    embedded Linux systems difficult).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot catch bugs on statically (compile-time) allocated memory regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to see the call stack with line-number information, a recompile/build
    with the `-g` flag is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact is, Valgrind remains a powerful weapon in one's armory against bugs.
    There are many real-world projects that use Valgrind; check out the long list
    at [http://valgrind.org/gallery/users.html](http://valgrind.org/gallery/users.html)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'There is always more to learn and explore: Valgrind provides a  GDB monitor
    mode allowing you to do advanced debugging on your program via the **GNU debugger**
    (**GDB**). This is particularly useful for using Valgrind on programs that never
    terminate (daemons being the classic case).'
  prefs: []
  type: TYPE_NORMAL
- en: The third chapter of Valgrind's manual is very helpful in this regard: [http://valgrind.org/docs/manual/manual-core-adv.html](http://valgrind.org/docs/manual/manual-core-adv.html)
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sanitizers are a suite of open source tools from Google; like other memory
    debug tools, they tackle the usual common memory bugs and UB issues, including
    OOB (out-of-bounds accesses: read/write under/over-flow), UAF, UAR, double free,
    and memory leakage. One of the tools also handles data races in C/C++ code.'
  prefs: []
  type: TYPE_NORMAL
- en: A key difference is that the sanitizer tools introduce instrumentation into
    the code via the compiler. They use a technology called **Compile-time instrumentation**
    (CTI) as well as shadow memory techniques. As of this writing, ASan is a part
    of and supports GCC ver 4.8 and LLVM (Clang) ver. 3.1 and above.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizer toolset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use a given tool, compile the program with the flag(s) shown in the Usage column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sanitizer tool (short name)** | **Purpose** | **Usage (compiler flags)**
    | **Linux platforms [+comments]** |'
  prefs: []
  type: TYPE_TB
- en: '| **AddressSanitizer** (**ASan**) | Detecting generic memory errors [heap&#124;stack&#124;global
    buffer over&#124;under-flow, UAF, UAR, init order bugs] | `-fsanitize=address`
    | x86, x86_64, ARM, Aarch64, MIPS, MIPS64, PPC64\. [Cannot combine with TSan]
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Kernel AddressSanitizer** (**KASAN**) | ASan for Linux kernel-space | `-fsanitize=kernel-address`
    | x86_64 [kernel ver >=4.0], Aarch64 [kernel ver >= 4.4] |'
  prefs: []
  type: TYPE_TB
- en: '| **MemorySanitizer** (**MSan**) | UMR detector | `-fsanitize=memory -fPIE
    -pie [-fno-omit-frame-pointer]`  | Linux x86_64 only |'
  prefs: []
  type: TYPE_TB
- en: '| **ThreadSanitizer** (**TSan**) | Data Races detector | `-fsanitize=thread`
    | Linux x86_64 only. [Cannot combine with ASan or LSan flags] |'
  prefs: []
  type: TYPE_TB
- en: '| **LeakSanitizer** (**LSan**) (a subset of ASan) | Memory leakage detector
    | `-fsanitize=leak` | Linux x86_64 and OS X [cannot combine with TSan] |'
  prefs: []
  type: TYPE_TB
- en: '| **UndefinedBehaviorSanitizer** (**UBSan**) | UB detector | `-fsanitize=undefined`
    | x86, x86_64, ARM, Aarch64, PPC64, MIPS, MIPS64 |'
  prefs: []
  type: TYPE_TB
- en: 'Additional DocumentationGoogle maintains a GitHub page with documentation for
    the sanitizer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/google/sanitizers/wiki](https://github.com/google/sanitizers/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are links leading to each of the tool's individual wiki (documentation)
    pages. It's recommended you read them in detail when using a tool (for example,
    each tool might have specific flags and/or environment variables that the user
    can make use of).
  prefs: []
  type: TYPE_NORMAL
- en: The man page on `gcc(1)` is a rich source of information on the intricacies
    of the `-fsanitize=` sanitizer tool gcc options. Interestingly, most of the sanitizer
    tools are supported on the Android (>=4.1) platform as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clang documentation also documents the use of the sanitizer tools: [https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we focus on using the ASan tool.
  prefs: []
  type: TYPE_NORMAL
- en: Building programs for use with ASan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the preceding table shows, we need to compile our target application membugs with
    the appropriate compiler flag(s). Also, instead of using `gcc` as the compiler,
    it's recommended we use `clang`.
  prefs: []
  type: TYPE_NORMAL
- en: '`clang` is considered a compiler frontend for several programming languages,
    including C and C++; the backend is the LLVM compiler infrastructure project.
    More information on Clang is available on its Wikipedia page.'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to ensure that the Clang package is installed on your Linux box;
    using your distribution's package manager (`apt-get`, `dnf`, `rpm`) would be the
    easiest way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet from our Makefile shows how we use `clang` to compile the membugs
    sanitizer targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the test cases with ASan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To refresh our memory, here is the help screen from our membugs program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The membugs program has a total of 13 test cases; we shall not attempt to display
    the output of all of them in this book; we leave it as an exercise to the reader
    to try out building and running the program with all test cases under ASan and
    deciphering its output report. It would be of interest to readers to see the summary
    table at the end of this section, showing the result of running ASan on each of
    the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #1:** UMR'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the very first one—the uninitialized variable read test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It did not catch the bug! Yes, we have hit upon ASan''s limitation: AddressSanitizer
    cannot catch UMR on statically (compile-time) allocated memory. Valgrind did.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that''s taken care of by the MSan tool; its specific job is to catch
    UMR bugs. The documentation states that MSan can only catch UMR on dynamically
    allocated memory. We found that it even caught a UMR bug on statically allocated
    memory, which our simple test case uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It has caught the bug; however, this time, though we have used a debug binary
    executable, built with the `-g -ggdb` flags, the usual `filename:line_number`
    information is missing in the stack trace. Actually, a method to obtain this is
    demonstrated in the next test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, no matter: this gives us a chance to learn another useful debug technique:
    `objdump(1)` is one of the toolchain utilities that can greatly help here (we
    can achieve similar results with tools such as `readelf(1)` or `gdb(1)`). We''ll
    disassemble the binary executable with `objdump(1)` (`-d` switch, and, with source
    via the `-S` switch), and look within its output for the address where the UMR
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As the output of `objdump` is quite large, we truncate it showing only the
    relevant portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The closest match in the `objdump` output to the address provided by MSan as
    the `0x496eb8` error point is `0x496eb4`. That''s fine: just look at the preceding
    for the first source line of code; it''s the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. That's exactly where the UMR occurred!
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Case #2: **write overflow [on compile-time memory]'
  prefs: []
  type: TYPE_NORMAL
- en: We run the `membugs` program, both under Valgrind and ASan, only invoking the `write_overflow_compilemem()`
    function to test the out-of-bounds write overflow memory errors on a compile-time
    allocated piece of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1:** Using Valgrind'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how Valgrind does not catch the out-of-bounds memory bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is because Valgrind is limited to working with only dynamically allocated
    memory; it cannot instrument and work with compile time allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2**: Address Sanitizer'
  prefs: []
  type: TYPE_NORMAL
- en: 'ASan does catch the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/073b0391-40f5-447a-b292-fab3db12592d.png)'
  prefs: []
  type: TYPE_IMG
- en: AddressSanitizer (ASan) catches the OOB write-overflow bug
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar textual version is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice, however, that within the stack backtrace, there is no `filename:line#
    information`. That's disappointing. Can we obtain it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes indeed—the trick lies in ensuring a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the application with the `-g` switch (to include debug symbolic info;
    we do this for all the *_dbg versions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the Clang compiler, a tool called `llvm-symbolizer` must be installed
    as well. Once installed, you must figure out its exact location on the disk and
    add that directory to the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At runtime, the `ASAN_OPTIONS` environment variable must be set to the `symbolize=1` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we rerun the buggy case with `llvm-symbolizer` in play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now the `filename:line# information` shows up!
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, ASan can and does instrument compile-time allocated as well as dynamically
    allocated memory regions, and thus catches both memory-type bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as we saw, it displays a call stack (read it from bottom to top of course).
    We can see the call chain is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The AddressSanitizer also displays, "Shadow bytes around the buggy address:";
    here, we do not attempt to explain the memory-shadowing technique used to catch
    such bugs; if interested, please see the *Further reading* section on the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #3:** write overflow (on dynamic memory)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, ASan catches the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With `llvm-symbolizer` in the path, the `filename:line# information` again shows
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to compile for sanitizer instrumentation (via the `-fsanitize=`
    GCC switches) and trying to run the binary executable over Valgrind is not supported;
    when we try this, Valgrind reports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Case #8: **UAF (use-after-free). Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Super. ASan not only reports the UAF bug, it even reports exactly where the
    buffer was allocated and freed! Powerful stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #9:** UAR'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this example, let''s say we compile the `membugs` program
    in the usual manner, using `gcc`. Run the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ASan, as such, does not catch this dangerous UAR bug! As we saw earlier, neither
    does Valgrind. But, the compiler does emit a warning!
  prefs: []
  type: TYPE_NORMAL
- en: 'Hang on, though: the Sanitizers documentation mentions that ASan can indeed
    catch this UAR bug, if:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clang` (ver r191186 onward) is used to compile the code (not gcc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special flag, `detect_stack_use_after_return` is set to `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we recompile the executable via Clang (again, we assume the Clang package
    is installed). In reality, our Makefile does make use of `clang` for all the `membugs_dbg_*`
    builds. So, ensure we rebuild with Clang as the compiler and retry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It does work. As we showed in *Test case #1: UMR*, one can further make use
    of `objdump(1)` to tease out the exact place where the bug hits. We leave this
    as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: More information on how ASan detects stack UAR can be found at [https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn](https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn).
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #10:** double free'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test case for this bug is kind of interesting (refer to the `membugs.c` source);
    we perform `malloc`, `free` the pointer, then perform another `malloc` with such
    a large value (`-1UL`, which becomes unsigned and thus too big) that it''s guaranteed
    to fail. In the error-handling code, we (deliberately) free the pointer we already
    freed earlier, thus generating the double free test case. In simpler pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Importantly, this kind of coding reveals another really crucial lesson: developers
    often do not pay sufficient attention to error-handling code paths; they may or
    may not write negative test cases to test them thoroughly. This could result in
    serious bugs!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this via ASan instrumentation does not, at first, have the desired
    effect: you will see that because of the glaringly enormous `malloc` failure,
    ASan actually aborts process-execution; hence, it does not detect the real bug
    we''re after—the double free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, but, notice the preceding line of output that says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we tell ASan this? An environment variable, `ASAN_OPTIONS`, makes it
    possible to pass runtime options; looking them up (recall we have provided the
    documentation links to the sanitizer toolset), we use it like so (one can pass
    more than one option simultaneously, separating options with a `:`; for fun, we
    also turn on the verbosity option, but trim the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This time, ASan continues even though it hits an allocation failure, and thus
    finds the real bug—the double free.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #11:** memory leak test case 1—simple leak. Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It does find the leak, and pinpoints it. Also notice that LeakSanitizer (LSan)
    is effectively a subset of ASan.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case #13****:** memory leak test case 3—libAPI leak'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot showcasing the action when ASan (under the hood, LSan)
    catches the leak:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80eaeb0d-0528-4af7-90d0-e96605c81481.png)'
  prefs: []
  type: TYPE_IMG
- en: Well caught!
  prefs: []
  type: TYPE_NORMAL
- en: AddressSanitizer (ASan) summary table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With respect to our test cases (incorporated into our `membugs` program), here
    is ASan''s report card:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test case #** | **Test case** | **Detected by Address Sanitizer?** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | UMR  | No[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | OOB (out-of-bounds): write overflow [on compile-time memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | OOB (out-of-bounds): write overflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | OOB (out-of-bounds): write underflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | OOB (out-of-bounds): read overflow [on compile-time memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | OOB (out-of-bounds): read overflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | OOB (out-of-bounds): read underflow [on dynamic memory] | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | UAF (use-after-free) also known as dangling pointer | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | UAR also known as UAS (use-after-scope) | Yes[2] |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Double free | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Memory leak test case 1: simple leak | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Memory leak test case 1: lib API leak | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4: AddressSanitizer and Memory Bugs'
  prefs: []
  type: TYPE_NORMAL
- en: '[1]The **MemorySanitizer** (**MSan**) fulfills exactly this purpose - it does
    detect UMR.However, there are two things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: UMR is detected by MSan only on dynamically allocated memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using MSan successfully necessitates using the Clang compiler (it did not work
    with GCC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2]This works with the caveat that the code is compiled with Clang and the
    `detect_stack_use_after_return=1` flag is passed via `ASAN_OPTIONS`.'
  prefs: []
  type: TYPE_NORMAL
- en: AddressSanitizer pros and cons – a quick summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASan pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Catches common memory bugs (UB) on both statically (compile-time) and dynamically
    allocated memory regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-bounds (OOB) memory accesses (read/write underflow/overflow bugs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-after-free (UAF) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-after-return (UAR) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leakage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is far superior to other tools (such as Valgrind); the worst case
    performance drop seems to be a factor 2x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No modification to source code required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully supports multithreaded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASan cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ASan cannot detect some types of bugs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UMR (as mentioned earlier, with some caveats, MSan can)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not detect all UAF bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IOF (Integer Underflow/Overflow) bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a certain tool at a time; cannot always combine multiple sanitizer tools
    (see the preceding table); this implies that often, separate test cases must be
    written for ASan, TSan, LSan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compiler:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, the program is required to be recompiled with the LLVM frontend Clang
    and appropriate compiler flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to see the call stack with line number information, a recompile/build
    with the `-g` flag is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we''ve combined the preceding two tables. Refer to the following table,
    memory bugs - a quick comparison between Valgrind and Address Sanitizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test case #** | **Test case** | **Detected by Valgrind?** | **Detected
    by Address Sanitizer?** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | UMR | Yes | No[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | OOB (out-of-bounds): write overflow [on compile-time memory] | No | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | OOB (out-of-bounds): write overflow [on dynamic memory] | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | OOB (out-of-bounds): write underflow [on dynamic memory] | Yes | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | OOB (out-of-bounds): read overflow [on compile-time memory] | No | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | OOB (out-of-bounds): read overflow [on dynamic memory] | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | OOB (out-of-bounds): read underflow [on dynamic memory] | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | UAF (use-after-free) also known as dangling pointer | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | UAR (use-after-return) also known as UAS (use-after-scope) | No | Yes[2]
    |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Double free | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Memory leak test case 1: simple leak | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Memory leak test case 1: lib API leak | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '[1]MSan fulfills exactly this purpose—it does detect UMR (also see caveats).'
  prefs: []
  type: TYPE_NORMAL
- en: It works with the caveats that the code is compiled with Clang and the `detect_stack_use_after_return=1`
    flag is passed via `ASAN_OPTIONS`.
  prefs: []
  type: TYPE_NORMAL
- en: Glibc mallopt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes useful to programmers, glibc provides a means to change the malloc
    engine''s defaults thanks to its ability to pass some specific parameters. The
    API is `mallopt(3)` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the man page on `mallopt(3)` for all the gory details (available
    at [http://man7.org/linux/man-pages/man3/mallopt.3.html](http://man7.org/linux/man-pages/man3/mallopt.3.html)).
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting example, one of the parameters that can be tweaked is **`M_MMAP_THRESHOLD`**;
    recall, in the earlier [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml),
    *Linux Memory Issues*, we covered the fact that on modern glibc, malloc does not
    always get memory blocks from the heap segment. If the size of the allocation
    request is above or equal to `MMAP_THRESHOLD`, the request is serviced under the
    hood via the powerful `mmap(2)` system call (which sets up  an arbitrary region
    of virtual address space of the size requested). The default value of `MMAP_THRESHOLD`
    is 128 KB; this can be changed via the `M_MMAP_THRESHOLD` parameter using `mallopt(3)`!
  prefs: []
  type: TYPE_NORMAL
- en: Again, this does not imply you should change it; only that you could. The default
    value is carefully arrived at and probably best suited to most application workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful parameter is `M_CHECK_ACTION`; this parameter determines how
    glibc reacts when memory errors are detected (say, a write overflow or a double
    free). Also note that the implementation does *not* detect all types of memory
    errors (leakage goes unnoticed, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, glibc interprets these three **least significant bits** (**LSB**)
    of the parameter''s value to determine how to react:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit 0**: If set, print a one-line error message to `stderr` providing detailed
    information regarding the cause; the error-line format is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Bit 1**: If set, after printing the error message, `abort(3)` is invoked
    causing the process to terminate. Depending on the version of the library, the
    stack trace and the relevant portion of the process memory map (via proc) may
    also be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit 2**: If set, and if bit 0 set, simplify the error message format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From glibc ver. 2.3.4, the `M_CHECK_ACTION` default value is 3 (implying binary
    011; earlier it was 1).
  prefs: []
  type: TYPE_NORMAL
- en: Setting `M_CHECK_ACTION` to a nonzero value can be very useful as it will cause
    a buggy process to crash at the point the bug is hit, and display useful diagnostics.
    If it were zero, the process would probably enter an undefined state (UB) and
    crash at some arbitrary point in the future, making debugging a lot harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reckoner, here are some useful values for `M_CHECK_ACTION` and their
    meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 (001b): Print a detailed error message but continue execution (process is
    now in UB!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3 (011b): Print a detailed error message, call stack, memory mappings, and
    abort execution [default].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5 (101b): Print a simple error message and continue execution (process is now
    in UB!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7 (111b): Print a simple error message, call stack, memory mappings, and abort
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The man page on `mallopt(3)` helpfully provides a C program example of using
    `M_CHECK_ACTION`.
  prefs: []
  type: TYPE_NORMAL
- en: Malloc options via the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A useful feature: instead of programmatically using the `mallopt(3)` API, the
    system allows us to tune some allocation parameters conveniently via environment
    variables. Most useful, perhaps, from the viewpoint of debug and testing, the
    `MALLOC_CHECK_` variable is the environment variable corresponding to the `M_CHECK_ACTION`
    parameter described earlier; thus, we can just set the value, run our application,
    and see the result for ourselves!'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples follow, using our usual membugs application to check out some
    test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case # 10:** double free with `MALLOC_CHECK_` set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, with the value of `MALLOC_CHECK_` being 1, the error message, is
    printed but the process is not aborted; this is what happens when the value of
    the environment variable is set to `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test case # 7:** out-of-bounds (read underflow) with `MALLOC_CHECK_` set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Test c****ase # 11:** memory leak test case 1—simple leak with `MALLOC_CHECK_`
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice how a leakage bug test case is not detected.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples were executed on an Ubuntu 17.10 x86_64 box; for some
    reason, interpretation of `MALLOC_CHECK_` on a Fedora 27 box did not seem to work
    as advertised.
  prefs: []
  type: TYPE_NORMAL
- en: Some key points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered some powerful memory debug tools and techniques, but at the end
    of the day, by itself these tools are not enough. Today's developer must keep
    alert—there are some remaining key points to mention briefly, which will serve
    to round off this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage while testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key point to remember using dynamic analysis tools (we covered using Valgrind's
    Memcheck tool and ASan/MSan) is that it only really helps the effort if complete
    code coverage is achieved when running the tool(s) over the test cases!
  prefs: []
  type: TYPE_NORMAL
- en: This point cannot be stressed enough. What use is running a fantastic tool or
    compiler instrumentation, such as the Sanitizers, over your program if the buggy
    part of the code does not actually run! The bugs remain dormant, uncaught. As
    developers and testers, we have to discipline ourselves to write rigorous test
    cases that actually perform complete code coverage, such that all code—including
    project code in libraries—is actually tested via these powerful tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not easy: remember, anything worth doing is worth doing well.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the modern C/C++ developer to do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the face of so much UB potential in complex software projects written on
    C/C++, the concerned developer might well ask, What are we to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://blog.regehr.org/archives/1520](https://blog.regehr.org/archives/1520).
    Here is a snippet from the excellent blog article, Undefined Behavior in 2017,
    by Cuoq and Regehr.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the modern C or C++ developer to do?**'
  prefs: []
  type: TYPE_NORMAL
- en: Be comfortable with the easy UB tools—the ones that can usually be enabled just
    by adjusting a makefile, such as compiler warnings and ASan and UBSan. Use these
    early and often, and (crucially) act upon their findings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be familiar with the hard UB tools—those such as TIS Interpreter that typically
    require more effort to run—and use them when appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invest in broad-based testing (track code coverage, use fuzzers) in order to
    get maximum benefit out of dynamic UB detection tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform UB-aware code reviews: build a culture where we collectively diagnose
    potentially dangerous patches and get them fixed before they land.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be knowledgeable about what’s actually in the C and C++ standards since these
    are what compiler writers are going by. Avoid repeating tired maxims such as C
    is a portable assembly language and trust the programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mention of the malloc API helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of `malloc `API helper routines. These can be useful when debugging
    a difficult scenario; it's a good idea to be aware of what's available.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an Ubuntu Linux system, we check with man for a match to the keyword `malloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite a few of these `malloc` APIs (reminder: the number three within parentheses,(3),
    implies it''s a library routine) deal with the concept of malloc hooks. The essential
    idea: one can replace the library `malloc(3)`, `realloc(3)`, `memalign(3)` and
    `free(3)` APIs with one''s own `hook` function, which will be invoked when the
    application calls the API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will not be delving further into this area; why not? Recent versions
    of glibc document the fact that these hook functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Not MT-Safe (covered in [Chapter 16](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml),
     *Multithreading with Pthreads Part III*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated from glibc ver. 2.24 onward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, it might be obvious, but we would prefer to call this out explicitly:
    one must realize that using these tools serves a purpose only in testing environments;
    they are not meant to be used in production! Some studies have revealed security
    vulnerabilities that can be exploited when running ASan in production; see the *Further
    reading *section on the GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have attempted to show the reader several key points, tools
    and techniques; among them:'
  prefs: []
  type: TYPE_NORMAL
- en: Humans will make mistakes; this is especially true with memory unmanaged languages
    (C, C++).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a real need for powerful memory debug tools on nontrivial codebases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We covered two of these best in class dynamic analysis tools in detail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valgrind's Memcheck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizers (primarily ASan)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glibc allows some tuning of malloc via the `mallopt(3)` API, as well as via
    environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring complete code coverage when building test cases is absolutely crucial
    to the success of a project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter is related to the essentials aspects of file I/O which is essential
    for a component reader to know. It introduces you to performing efficient file
    I/O on the Linux platform. We would request the readers to go through this chapter
    which is available here: [https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf).
    We highly recoomend the readers to read Open at the system call layer, The file
    descriptor and I/O – the read/write system calls which can help in easy understanding
    the next chapter that is, [Chapter 7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process
    Credentials*.
  prefs: []
  type: TYPE_NORMAL
