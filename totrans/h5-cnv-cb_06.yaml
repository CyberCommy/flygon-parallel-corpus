- en: 'Chapter 6. Interacting with the Canvas: Attaching Event Listeners to Shapes
    and Regions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Events class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with canvas mouse coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching mouse event listeners to regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching touch event listeners to regions on a mobile device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching event listeners to images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging-and-dropping shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging-and-dropping images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image magnifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a drawing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned how to draw on the canvas, work with images and video,
    and create fluid animations. This chapter focuses on canvas interactivity. Until
    now, all of our canvas projects have been very unresponsive and disengaged from
    the user. Although the HTML5 canvas API doesn't provide us with a means for attaching
    event listeners to shapes and regions, we can certainly achieve this functionality
    by extending the API. According to the HTML5 specification, once a shape is drawn,
    we have no access to it as an object like we do with DOM elements in an HTML document.
    Until the HTML5 canvas specification includes methods for attaching event listeners
    to shapes and regions, (hopefully it will some day), we'll need to construct our
    own Events class which will enable us to do so. Our class will enable us to attach
    event listeners to regions which wrap one or more shapes, similar to attaching
    event listeners to DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: '*This is quite a powerful notion because it enables us to draw shapes in the
    canvas that users can interact with. Our Events class will support* **mousedown**,
    **mouseup**, **mouseover**, **mouseout**, **mousemove**, **touchstart**, **touchend**,
    and **touchmove** events.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although most of the recipes in this chapter utilize mouse events, they can
    also be modified to support mobile touch events by replacing `mousedown` with
    `touchstart`, `mouseup` with `touchend`, and `mousemove` with `touchmove`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Events class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to [Chapter 5](ch05.html "Chapter 5. Bringing the Canvas to Life with
    Animation"), *Bringing the Canvas to Life with Animation*, where we created a
    custom class to handle animations, in this chapter we'll create a custom class
    to handle canvas events.
  prefs: []
  type: TYPE_NORMAL
- en: 'As canvas shapes are not accessible as objects (bummer!), there''s nothing
    for us to attach event listeners to like we would with a div element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So what can we do? If we follow the pattern of the canvas API, in which the
    beginning of a shape is defined with `beginPath()` , and the end of the shape
    is defined by `closePath()` , we can extend this idea one step further by introducing
    the concept of regions, which encapsulate multiple shapes. Furthermore, it would
    be really nice if we could add event listeners to a region in a similar manner
    that we add event listeners to DOM elements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The goal of the Events class is to do just that by extending the canvas API
    to support canvas events by introducing regions which can be attached with desktop
    event listeners such as `mousedown`, `mouseup`, `mouseover`, `mouseout`, and `mousemove`,
    and also mobile event listeners such as `touchstart`, `touchend`, and `touchmove`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than typing out the Events class by hand, you may consider downloading
    the class from the online resources for this book at [www.html5canvastutorials.com/cookbook](http://www.html5canvastutorials.com/cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an Events class which will enable us to attach
    event listeners to shapes and regions on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Events` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getContext()` method which returns the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getCanvas()` method which returns the canvas DOM element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `clear()` method which clears the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getCanvasPos()` method which returns the canvas position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setStage()` method which sets the `stage()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `reset()` method which sets the mouse position and the touch position,
    resets the region index, calls the `stage()` function, and then resets the event
    flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `listen()` method which adds event listeners to the canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getMousePos()` method which returns the mouse position for desktop
    applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getTouchPos()` method which returns the touch position for mobile
    applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setMousePos()` method which sets the mouse position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `setTouchPos()` method which sets the touch position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `beginRegion()` method which is used to define a new region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `addRegionEventListener()` method which is used to add an event
    listener to a region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `closeRegion()` method which is used to close a region and determine
    if an event has occurred with respect to the current region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though the HTML5 canvas API doesn''t provide a way for us to easily handle
    event listeners, it does provide one key method that will make it possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `isPointInPath()` method returns true if the given coordinates reside within
    *any* path drawn on the canvas. As the canvas is a bitmap, the concept of layers
    and shapes has no meaning here, so we'll have to figure out a way to leverage
    the `isPointInPath()` method for determining whether or not a given coordinate,
    in particular the mouse coordinates, resides within a specific region of the canvas.
    Once we can detect whether or not the mouse cursor is on top of a particular region,
    we can add additional logic to handle `mouseover`, `mousemove`, `mouseout`, `mousedown`,
    `mouseup`, `touchstart`, `touchend`, and `touchmove` events.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting in any deeper, let's make up an example and formulate a procedure
    for simulating region events, and then use what we've learned to lay out the methods
    we'll need to create the `Events` class. Let's say that we want to draw a triangle,
    a rectangle, and a circle on the canvas, and then we want to alert some text when
    the user places their cursor over the circle. We could first draw the triangle,
    and then see whether the mouse coordinates reside within the current path using
    `isPointInPath()`. If the method returns false, we know that the mouse cursor
    is somewhere outside of the triangle. Next, we could draw the rectangle, and again
    check whether the mouse coordinates reside within any path, which at this point
    includes the triangle and the rectangle. If `isPointInPath()` still returns false,
    we now know that the mouse cursor is somewhere outside of the triangle and the
    rectangle. Finally, we can draw the circle, and once again check whether the mouse
    coordinates reside within any path on the canvas, which now includes the triangle,
    rectangle, and circle. If the method returns true, then the mouse is indeed over
    the circle. If it returns false, then the mouse cursor is somewhere outside the
    triangle, rectangle, and circle.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this only works if we assume that the cursor is already positioned
    somewhere on the canvas before the elements are actually drawn. The only way that
    we can detect whether the mouse cursor is on top of an element after the cursor
    has moved is to redraw our elements each time an event is triggered, and then
    check whether the mouse coordinates exist within a shape after drawing each element.
    We can accomplish this by defining the `stage()` function with the `setStage()`
    method of the `Events` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a way to define the beginning and the end of a region. We can
    create a `beginRegion()` method which defines a new `Region` object. The `Region`
    object can have eight properties: `mouseover`, `mouseout`, `mousemove`, `mousedown`,
    `mouseup`, `touchstart`, `touchend`, and `touchmove`, all of which are user-defined
    functions. Next, we can create a method called `addRegionEventListener()` which
    can be used to attach region events which require an event type and the function
    to be called when the event occurs. Since we have a method that begins a new region,
    we also need to create a `closeRegion()` method. This method contains most of
    the logic required to determine if one of the eight events has occurred. Finally,
    we can create a `listen()` method which adds event listeners to the canvas element
    in order to appropriately handle the region events.'
  prefs: []
  type: TYPE_NORMAL
- en: The Events class described in this recipe works by defining regions with the
    `beginRegion()` and `closeRegion()` methods, and then redrawing the regions each
    time an event is triggered in order to detect which which region the event belongs
    to. The advantage of this approach is that it's easy to implement and that we
    only need one canvas element.
  prefs: []
  type: TYPE_NORMAL
- en: Although, this approach works beautifully for canvas applications that have
    a reasonable number of regions with attached event listeners, it may not be the
    best approach for applications using a large number of regions. Applications that
    require thousands of regions, each with their own event listeners, may run into
    performance issues due to the number of shapes being redrawn each time the mouse
    moves.
  prefs: []
  type: TYPE_NORMAL
- en: For such applications, a more complex approach can be used by assigning each
    region its own canvas and then stacking the canvases on top of each other so that
    the regions don't have to be redrawn each time an event is triggered. One great
    example of this approach is the KineticJS library ([http://www.kineticjs.com](http://www.kineticjs.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Working with canvas mouse coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get our feet wet with the `Events` class, we'll keep it simple by getting
    the mouse coordinates of the cursor using the `getMousePos()` method from the
    `Events` class and then displaying it in the top-left corner of the canvas. The
    `getMousePos()` method returns the mouse coordinates relative to the canvas, which
    takes into account the offset position of the canvas relative to the page, and
    also the scroll position of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with canvas mouse coordinates](img/1369_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get the canvas mouse coordinates and display them in
    the upper-left corner of the canvas each time the mouse cursor moves:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user mouses out of the canvas, clear the canvas and then write out
    the message "Mouseover me!":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user moves his/her mouse in the canvas, clear the canvas, and then
    write out the mouse position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start listening for events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the initial message before the user begins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the page loads, we can instantiate an `Events` object so that we have access
    to the `getMousePos()` method. Next, we can attach a `mouseout` event listener
    to the `canvas` object which sets the event display to "Mouseover me!", and also
    attach a `mousemove` event listener to the `canvas` object that gets the mouse
    position using the `getMousePos()` method and then writes out the coordinates.
    Finally, we can start listening for events using the `listen()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching mouse event listeners to regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll get to the meat of the `Events` class by defining regions
    and adding event listeners to them. We'll draw a triangle, attach a `mouseout`
    and `mousemove` event listener to it, we'll draw a rectangle with no event listeners,
    and finally we'll draw a circle and attach a `mouseover`, `mouseout`, `mousedown`,
    and `mouseup` event listener to try out each of the different desktop event listeners
    supported by the `Events` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching mouse event listeners to regions](img/1369_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to draw a triangle, a rectangle, and a circle, and then
    attach mouse event listeners to each shape:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin defining the `stage()` function which starts by clearing the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region with `beginRegion()` and then draw a blue triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `mousemove` and `mouseout` event listeners to the triangle and close the
    region with `closeRegion()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw a yellow rectangle with no event listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region and draw a red circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach `mousedown`, `mouseup`, `mouseover`, and `mouseout` event listeners
    to the circle, and close the region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Write out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attach events to the three shapes in this recipe, we first need to initialize
    an `Events` object and then set the `stage()` function. Inside the `stage()` function,
    we can define a new region using `beginRegion()`, draw the blue triangle, attach
    events using `addRegionEventListener()`, and then close the region using `closeRegion()`.
    Next, we can draw the yellow rectangle without defining a region because we aren't
    attaching any events to it. Finally, we can define a second region, draw the red
    circle, attach event listeners, and then close the region, completing the `stage()`
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attaching touch event listeners to regions on a mobile device*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching touch event listeners to regions on a mobile device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those of you crying "What about mobile devices? Desktops and laptops are
    a thing of the past!" – this recipe is just for you. As Internet surfers migrate
    away from their giant tethered desktops and begin consuming Internet content from
    mobile devices, it's becoming more evident every day that the future of the Web,
    including canvas, will reside mostly in the mobile space.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike web applications running on desktops and laptops, where user interactions
    are detected using the mouse from `mousedown`, `mouseup`, `mouseover`, `mouseout`,
    and `mousemove` events, web applications running on mobile devices are interacted
    with touch events from `touchstart`, `touchend`, and `touchmove` events.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a mobile version of the previous recipe by adding
    touch event listeners to the triangle and circle.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, any of the recipes in this chapter could be modified to
    support mobile devices by adding touch event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching touch event listeners to regions on a mobile device](img/1369_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to draw a triangle, a rectangle, and a circle, and then
    attach mobile touch events to each shape:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a viewport meta tag inside the header tag to set the mobile device width,
    set the initial scale, and disable user scaling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate a new `Events` object and get the canvas and context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin defining the `sStage()` function which starts by clearing the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region with `beginRegion()` and then draw a blue triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `touchmove` event listener to the triangle and close the region with
    `closeRegion()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw a yellow rectangle with no event listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region and draw a red circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach `touchstart` and `touchend` event listeners to the circle and close
    the region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Write out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous recipe, in this recipe we'll attach event listeners
    to the triangle and the circle, except this time we'll attach touch event listeners
    so that the demo can be run on a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Touch events on mobile devices are actually quite simple, and work in much the
    same way as desktop events. The mobile equivalent of `mousedown` is `touchstart`,
    the equivalent of `mouseup` is `touchend`, and the equivalent of `mousemove` is
    `touchmove`. As mobile devices can't detect if your finger is hovering over a
    region, mobile devices don't have an equivalent for `mouseover` or `mouseout`,
    I wouldn't be surprised if sometime in the future mobile devices *could* detect
    when fingers are close to the screen but not quite touching it.
  prefs: []
  type: TYPE_NORMAL
- en: To show the touch coordinates for the blue triangle, we can use the `touchmove`
    event listener, and to detect when the red circle is being touched or released,
    we can use the `touchstart` and `touchend` events.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing a rectangle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and
    Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing a circle* in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with custom shapes and fill styles* in [Chapter 2](ch02.html "Chapter 2. Shape
    Drawing and Composites")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attaching mouse event listeners to regions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching event listeners to images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll attach event listeners to images. As we can only attach
    event listeners to paths with our `Events` class, and as images drawn on the canvas
    aren't classified as paths, we can create a rectangular region that overlays an
    image in order to attach event listeners to the rectangular region, and consequently
    attach event listeners to the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Attaching event listeners to images](img/1369_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to draw two different images and then attach `mouseover`,
    `mouseout`, `mousedown`, and `mouseup` event listeners to them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an image loader that loads a set of images and then calls a `callback`
    function whenever all of the images have loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawImages()` function which instantiates a new `Events` object
    and begins defining the `stage()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region, draw the left image, define a rectangular region that represents
    the image path, attach event listeners to the rectangular region, and then close
    the region. Repeat these steps for the right image as well, and then write out
    a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads create a hash of image sources and then pass it off to
    the `loadImages()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the page loads, we can use an image loader function to load two images.
    When both images have loaded, the `drawImages()` function is called and an `Events`
    object is instantiated. Inside the `stage()` function, we can begin a new region
    with `beginRegion()`, draw the first image, draw a rectangular path to define
    the image path, attach events using `addRegionEventListener()`, and then close
    the region. Next, we can repeat this process to create the second image with its
    own set of event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging-and-dropping shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll tackle the holy grail of event listeners—drag-and-drop.
    Without the `Events` class or some other lightweight JavaScript library, drag-and-drop
    operations can be quite cumbersome to develop. We can use the `Events` class to
    attach a `mouseover`, `mousedown`, `mousemove`, `mouseup`, and `mouseout` event
    listener to the rectangle to handle different phases of the drag-and-drop operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dragging-and-dropping shapes](img/1369_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to drag-and-drop a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, instantiate a new `Events` object, define the starting
    position of the rectangle that will be dragged-and-dropped, and define `draggingRect`,
    `draggingRectOffsetX`, and `draggingRectOffsetY` for the drag-and-drop operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `stage()` function, begin by setting the coordinates of the rectangle
    based on the coordinates of the mouse if the `draggingRect` Boolean is true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the canvas, write out a message, begin a new region, draw the rectangle,
    attach events, and then close the region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drag-and-drop is handled with three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Detect a `mousedown` event over a shape which begins the operation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the shape according to the mouse coordinates using the `mousemove`
    event listener
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the shape when the mouse button is released (`mouseup`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `stage()` function, we can set the position of the rectangle relative
    to the position of the mouse if the `draggingRect` Boolean is true. We can then
    begin a new region with `beginRegion()`, draw the rectangle, and then attach event
    listeners using the `addRegionEventListener()` method. We can add a `mousedown`
    event listener that sets the `draggingRect` Boolean to true, and then calculates
    the `draggingRectOffsetX` and `draggingRectOffsetY` variables which account for
    the position offset between the mouse and the top-left corner of the rectangle.
    Next, we can add a `mouseup` event listener that sets the `draggingRect` Boolean
    to false, completing the drag-and-drop operation. We can also attach a `mouseover`
    event listener to turn the cursor into a hand to show that the element can be
    interacted with, and we can also attach a `mouseout` event listener to restore
    the cursor image back to the default pointer to indicate that the mouse cursor
    is no longer over the element.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dragging-and-dropping images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging-and-dropping images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe essentially combines the concepts from the previous two recipes
    to demonstrate how we can drag-and-drop an image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to drag-and-drop an image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `writeMessage()` function which writes out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawImage()` function which begins by instantiating a new `Events`
    object and setting the initial position of the rectangular region that overlays
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `stage()` function which begins by setting the position of the image
    based on the coordinates of the mouse if the `draggingRect` Boolean is true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the canvas and write out a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new region, draw the image, draw a rectangular region to define the
    image path, attach event listeners, and close the region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, load the image and then call the `drawImage()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To drag-and-drop an image, we can draw an invisible rectangular path on top
    of the image to provide a path for the image, and we can attach the `mousedown`,
    `mouseup`, and `mousemove` events similar to the previous recipe to handle the
    three phases of drag-and-drop.
  prefs: []
  type: TYPE_NORMAL
- en: When the user drags-and-drops an image, he/she is essentially dragging and dropping
    both the image and its corresponding rectangular path.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dragging-and-dropping shapes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image magnifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a really neat image magnifier by cropping out a
    section of a large image based on the mouse coordinates of a small image and then
    displaying the result on top of the small image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an image magnifier](img/1369_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an image magnifier that renders a magnified portion
    of an image when the user mouses over it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an image loader that will load the small and large image and then call
    a callback function when the images have loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawMagnifier()` function which draws the magnified image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawImages()` function which begins by instantiating a new `Events`
    object and defines the magnifier properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `stage()` function which draws the small image and then calls `drawMagnifier()`
    to draw the magnified image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an event listener to the canvas element which redraws the stage if the
    user mouses out of the canvas in order to remove the magnified image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, build a hash of image sources, and pass it on to the image
    loader function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Embed the canvas inside the body of the HTML document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an image magnifier, we'll need two images, one small and one large.
    The small image will be the image that's always visible on the canvas, and the
    large image will be used as a buffer image to draw the magnifier. Once the page
    loads, and both images are loaded, we can instantiate an `Events` object and begin
    defining the `stage()` function.
  prefs: []
  type: TYPE_NORMAL
- en: After drawing the small image centered on the canvas, we can draw the magnified
    image by calculating the `sourceX`, `sourceY`, `destX`, and `destY` parameters
    of the `drawImage()` method which will crop out the magnified section of the large
    image, and then display the result on top of the smaller image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get `sourceX` and `sourceY`, we can get the mouse coordinates relative to
    the small image by taking the difference between the mouse position and the position
    of the top-left corner of the small image, and then we can get the corresponding
    coordinates for the large image by multiplying the result by the magnification
    (which is the large image width divided by the small width), and then subtracting
    half the size of the magnified window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To center the magnified image on the mouse cursor, we can set `destX` equal
    to the x position of the mouse offset by half the magnifier width, and we can
    set `destY` equal to the y position of the mouse offset by half the magnifier
    height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cropping an image* in [Chapter 3](ch03.html "Chapter 3. Working with Images
    and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a drawing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a nifty drawing application so users can draw pictures
    right in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a drawing application](img/1369_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a simple drawing application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Style the toolbar, inputs, and buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Link to the `Events` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `addPoint()` function which adds a point to the points array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawPath()` function which clears the canvas, redraws the canvas
    drawing before the path was started, and then draws the drawing path using the
    points in the points array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `updateColorSquare()` function which updates the color of the toolbar
    color square:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `getCanvasImg()` method which returns an image object of the canvas
    drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page loads, instantiate a new `Events` object, define the `isMouseDown`
    flag, get the canvas image, and initialize the drawing color, and size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the color square whenever a new color input is entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the canvas when the clear button is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When the **Save** button is pressed, convert the canvas drawing into a data
    URL and open the drawing as an image in a new window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user `mousedowns` on the canvas, get the drawing position, color,
    and size, set the path style, add the first point to the points array, and then
    set the `isMouseDown` flag to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user `mouseups` from the canvas, set the `isMouseDown` flag to false,
    draw the path, and then save the current image drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user’s mouse leaves the canvas, simulate a `mouseup` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `stage()` function which continuously adds new points to the current
    drawing path if the mouse is down and moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct the toolbar and add the canvas element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drawing applications typically have the following core features:'
  prefs: []
  type: TYPE_NORMAL
- en: A `mousedown` event starts a drawing path, and a `mouseup` event ends a drawing
    path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line widths can be set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colors can be set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawing can be cleared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawing can be saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, if you wanted to create a Photoshop or Gimp-like drawing application
    on the Web, there are hundreds of other features you could add, but here we are
    nailing down just the basics to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first bullet in the preceding list is clearly the most important – we need
    to figure out a way that users can draw lines on the screen. The most straight
    forward way to do this is to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user `mousedowns` somewhere on the canvas, set the path style and add
    the mouse position coordinate to an array of points to define the beginning point
    of the drawing path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user moves the mouse, get the mouse position and add another point
    to the array of points, and then redraw the path with the new point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user `mouseups`, set a flag indicating that the path is and save the
    current drawing image to be used with the next drawing path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep things simple, we can let the user set the line width with a text input,
    and we can let the user set the color with three text inputs (the red, green,
    and blue components of a color).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can create a clear button that clears the canvas with the `clear()`
    method of the `Events` object, and we can create a save button that converts the
    canvas drawing into a data URL using the to `DataURL()` method of the canvas context,
    and then opens a new window with the data URL. From there, the user can right-click
    on the image to save it to their computer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some more ideas if you''re creating a more complex drawing application:'
  prefs: []
  type: TYPE_NORMAL
- en: Until the color picker input is supported by all of the major browsers, you
    could create a custom color picker widget that lets users choose a color graphically
    instead of inputting the red, green, and blue components of the color that they
    want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could create a slider bar using the HTML5 range input for the paint brush
    size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could create layer support by dynamically creating a new canvas element
    for each layer. Similar to Photoshop and Gimp, you could provide an ability to
    delete layers and merge layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application supports layering, you could also add an opacity control
    for each layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could enhance the save feature by saving the drawing in local storage or
    in an offline database (see *Converting a canvas drawing into a data URL* in [Chapter
    3](ch03.html "Chapter 3. Working with Images and Videos"))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide pre-built drawing shapes such as lines, rectangles, and circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow shapes to be scaled and rotated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to import images into their drawings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully this recipe further sparks your interest in canvas and gets you thinking
    about other possibilities. I think it's safe to say that someone will eventually
    create a full-blown image editing web application powered entirely by canvas and
    give Adobe a run for their money. Maybe it will be you!
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing a spiral* in [Chapter 1](ch01.html "Chapter 1. Getting Started withPaths
    and Text")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting a canvas drawing into a data URL in* [Chapter 3](ch03.html "Chapter 3. Working
    with Images and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Saving a canvas drawing as an image in* [Chapter 3](ch03.html "Chapter 3. Working
    with Images and Videos")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with canvas mouse coordinates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
