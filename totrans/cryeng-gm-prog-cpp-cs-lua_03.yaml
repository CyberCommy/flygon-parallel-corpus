- en: Chapter 3. Creating and Utilizing Custom Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE entity system provides the means for creating everything from
    simple physicalized objects to complex weather simulation managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Elaborate on the basic concept and implementation of the entity system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our first custom entity in Lua, C#, and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the game object system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the entity system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entity system exists to spawn and manage entities in the game world. Entities
    are logical containers, allowing drastic changes in behavior at runtime. For example,
    an entity can change its model, position, and orientation at any point in the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this; every item, weapon, vehicle, and even player that you have interacted
    with in the engine is an entity. The entity system is one of the most important
    modules present in the engine, and is dealt regularly by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The entity system, accessible via the `IEntitySystem` interface, manages all
    entities in the game. Entities are referenced to using the `entityId` type definition,
    which allows 65536 unique entities at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: If an entity is marked for deletion, for example, `IEntity::Remove(bool bNow
    = false)`, the entity system will delete this prior to updating at the start of
    the next frame. If the `bNow` parameter is set to true, the entity will be removed
    right away.
  prefs: []
  type: TYPE_NORMAL
- en: Entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities are simply instances of an entity class, represented by the `IEntityClass`
    interface. Each entity class is assigned a name that identifies it, for example,
    SpawnPoint.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can be registered via `IEntityClassRegistry::RegisterClass`, or via
    `IEntityClassRegistry::RegisterStdClass` to use the default `IEntityClass` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `IEntity` interface is used to access the entity implementation itself.
    The core implementation of `IEntity` is contained within `CryEntitySystem.dll`,
    and cannot be modified. Instead, we are able to extend entities using game object
    extensions (have a look at the *Game object extensions* section in this chapter)
    and custom entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: entityId
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each entity instance is assigned a unique identifier, which persists for the
    duration of the game session.
  prefs: []
  type: TYPE_NORMAL
- en: EntityGUID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the `entityId` parameter, entities are also given globally unique identifiers,
    which unlike `entityId` can persist between game sessions, in the case of saving
    games and more.
  prefs: []
  type: TYPE_NORMAL
- en: Game objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When entities need extended functionality, they can utilize game objects and
    game object extensions. This allows for a larger set of functionality that can
    be shared by any entity.
  prefs: []
  type: TYPE_NORMAL
- en: Game objects allow the handling of binding entities to the network, serialization,
    per-frame updates, and the ability to utilize existing (or create new) game object
    extensions such as Inventory and AnimatedCharacter.
  prefs: []
  type: TYPE_NORMAL
- en: Typically in CryENGINE development, game objects are only necessary for more
    important entity implementations, such as actors. The actor system is explained
    more in depth in [Chapter 5](ch05.html "Chapter 5. Creating Custom Actors"), *Creating
    Custom Actors*, along with the `IActor` game object extension.
  prefs: []
  type: TYPE_NORMAL
- en: The entity pool system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entity pool system allows "pooling" of entities, allowing efficient control
    of entities that are currently being processed. This system is commonly accessed
    via flowgraph, and allows the disabling /enabling groups of entities at runtime
    based on events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pools are also used for entities that need to be created and released frequently,
    for example, bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Once an entity has been marked as handled by the pool system, it will be hidden
    in the game by default. Until the entity has been prepared, it will not exist
    in the game world. It is also ideal to free the entity once it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a group of AI that only needs to be activated when
    the player reaches a predefined checkpoint trigger, this can be set up using `AreaTrigger`
    (and its included flownode) and the `Entity:EntityPool` flownode.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned the basics of the entity system, it's time to create
    our first entity. For this exercise, we'll be demonstrating the ability to create
    an entity in Lua, C#, and finally C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity using Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lua entities are fairly simple to set up, and revolve around two files: the
    entity definition, and the script itself. To create a new Lua entity, we''ll first
    have to create the entity definition in order to tell the engine where the script
    is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simply save this file as `MyLuaEntity.ent` in the `Game/Entities/` directory,
    and the engine will search for the script at `Scripts/Entities/Others/MyLuaEntity.lua`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can move on to creating the Lua script itself! To start, create the
    script at the path set previously and add an empty table with the same name as
    your entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When parsing the script, the first thing the engine does is search for a table
    with the same name as the entity, as you defined it in the `.ent` definition file.
    This main table is where we can store variables, Editor properties, and other
    engine information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add our own property by adding a string variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to create property categories by adding subtables within the
    Properties table. This is useful for organizational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the changes done, you should see the following screenshot when spawning
    an instance of your class in the Editor, via **RollupBar** present to the far
    right of the Editor by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an entity using Lua](img/5909_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Common Lua entity callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The script system provides a set of callbacks that can be utilized to trigger
    specific logic on entity events. For example, the `OnInit` function is called
    on the entity when it is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating an entity in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third-party extension, **CryMono** allows the creation of entities in .NET,
    which leads us to demonstrate the capability of creating our very own entity in
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open the `Game/Scripts/Entities` directory, and create a new file
    called `MyCSharpEntity.cs`. This file will contain our entity code, and will be
    compiled at runtime when the engine is launched.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open the script (`MyCSharpEntity.cs`) IDE of your choice. We'll be using
    Visual Studio in order to provide **IntelliSense** and code highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Once opened, let's create a basic skeleton entity. We'll need to add a reference
    to the CryENGINE namespace, in which the most common CryENGINE types are stored.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save the file and start the Editor. Your entity should now appear in **RollupBar**,
    inside the **Default** category. Drag **MyEntity** into the viewport in order
    to spawn it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an entity in C#](img/5909_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use the entity attribute (`[Entity]`) as a way of providing additional information
    for the entity registration progress, for example, using the `Category` property
    will result in using a custom Editor category, instead of **Default**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Adding Editor properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Editor properties allow the level designer to supply parameters to the entity,
    perhaps to indicate the size of a trigger area, or to specify an entity's default
    health value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In CryMono, this can be done by decorating supported types (have a look at
    the following code snippet) with the `EditorProperty` attribute. For example,
    if we want to add a new `string` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now when you start the Editor and drag **MyCSharpEntity** into the viewport,
    you should see **MyProperty** appear in the lower part of **RollupBar**.
  prefs: []
  type: TYPE_NORMAL
- en: The `MyProperty` string variable in C# will be automatically updated when the
    user edits this via the Editor. Remember that Editor properties will be saved
    with the level, allowing the entity to use Editor properties defined by the level
    designer even in pure game mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Editor properties](img/5909_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Property folders
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with Lua scripts, it is possible for CryMono entities to place Editor properties
    in folders for organizational purposes. In order to create folders, you can utilize
    the `Folder` property of the `EditorProperty` attribute as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You now know how to create entities with custom Editor properties using CryMono!
    This is very useful when creating simple gameplay elements for level designers
    to place and modify at runtime, without having to reach for the nearest programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an entity in C++ is slightly more complex than making one using Lua
    or C#, and can be done differently based on what the entity is required for. For
    this example, we'll be detailing the creation of a custom entity class by implementing
    `IEntityClass`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom entity class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Entity classes are represented by the `IEntityClass` interface, which we will
    derive from and register via `IEntityClassRegistry::RegisterClass(IEntityClass
    *pClass)`.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, let's create the header file for our entity class. Right-click
    on your project in Visual Studio, or any of its filters, and go to **Add** | **New
    Item** in the context menu. When prompted, create your header file (`.h`). We'll
    be calling `CMyEntityClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the generated `MyEntityClass.h` header file, and create a new class
    which derives from `IEntityClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the class set up, we'll need to implement the pure virtual
    methods we inherit from `IEntityClass` in order for our class to compile successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the methods, we can simply return a null pointer, zero, or an empty
    string. However, there are a couple of methods which we have to handle for the
    class to function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Release()`: This is called when the class should be released, should simply
    perform "delete this;" to destroy the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetName()`: This should return the name of the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetEditorClassInfo()`: This should return the `ClassInfo` struct, containing
    Editor category, helper, and icon strings to the Editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetEditorClassInfo()`: This is called when something needs to update the Editor
    `ClassInfo` explained just now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEntityClass` is the bare minimum for an entity class, and does not support
    Editor properties yet (we will cover this a bit further later).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To register an entity class, we need to call `IEntityClassRegistry::RegisterClass`.
    This has to be done prior to the `IGameFramework::CompleteInit` call in `CGameStartup`.
    We''ll be doing it inside `GameFactory.cpp`, in the `InitGameFactory` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a property handler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to handle Editor properties, we'll have to extend our `IEntityClass`
    implementation with a new implementation of `IEntityPropertyHandler`. The property
    handler is responsible for handling the setting, getting, and serialization of
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new header file named `MyEntityPropertyHandler.h`. Following
    is the bare minimum implementation of `IEntityPropertyHandler`. In order to properly
    support properties, you'll need to implement `SetProperty` and `GetProperty`,
    as well as `LoadEntityXMLProperties` (the latter being required to read property
    values from the `Level` XML).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a new class which derives from `IEntityPropertyHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for the new class to compile, you''ll need to implement the pure virtual
    methods defined in `IEntityPropertyHandler`. Methods crucial for the property
    handler to work properly can be seen as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadEntityXMLProperties`: This is called by the Launcher when a level is being
    loaded, in order to read property values of entities saved by the Editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetPropertyCount`: This should return the number of properties registered
    with the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetPropertyInfo`: This is called to get the property information at the specified
    index, most importantly when the Editor gets the available properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetProperty`: This is called to set the property value for an entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetProperty`: This is called to get the property value of an entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetDefaultProperty`: This is called to retrieve the default property value
    at the specified index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make use of the new property handler, create an instance of it (passing the
    requested properties to its constructor) and return the newly created handler
    inside `IEntityClass::GetPropertyHandler()`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a basic entity class implementation, which can be easily extended
    to support Editor properties. This implementation is very extensible, and can
    be used for vast amount of purposes, for example, the C# script seen later has
    simply automated this process, lifting the responsibility of so much code from
    the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Entity flownodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the flowgraph system, as well as the creation
    of flownodes. You may have noticed that when right-clicking inside a graph, one
    of the context options is **Add Selected Entity**. This functionality allows you
    to select an entity inside a level, and then add its entity flownode to the flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the entity flownode doesn't contain any ports, and will therefore
    be mostly useless as shown to the right.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can easily create our own entity flownode that targets the entity
    we selected in all three languages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Entity flownodes](img/5909_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an entity flownode in Lua
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By extending the entity we created in the *Creating an entity using Lua* section,
    we can add its very own entity flownode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating an entity flownode in Lua](img/5909_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just created an entity flownode for our `MyLuaEntity` class. If you start
    the Editor, spawn your entity, select it and then click on **Add Selected Entity**
    in your flowgraph, you should see the node appearing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity flownode using C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating an entity flownode in C# is very simple due to being almost exactly
    identical in implementation as the regular flownodes. To create a new flownode
    for your entity, simply derive from `EntityFlowNode<T>`, where `T` is your entity
    class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating an entity flownode using C#](img/5909_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just created an entity flownode in C#. This allows us to easily use what
    we learned from the previous chapter and utilize `TargetEntity` in our new node's
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity flownode in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section assumes that you read *Creating a custom node in C++* section from
    [Chapter 2](ch02.html "Chapter 2. Visual Scripting with Flowgraph"), *Visual Scripting
    with Flowgraph*.
  prefs: []
  type: TYPE_NORMAL
- en: In short, entity flownodes are identical in implementation to regular nodes.
    The difference being the way the node is registered, as well as the prerequisite
    for the entity to support `TargetEntity` (refer to the previous chapter for more
    information).
  prefs: []
  type: TYPE_NORMAL
- en: Registering the entity node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We utilize same methods for registering entity nodes as before, the only difference
    being that the category has to be entity, and the node name has to be the same
    as the entity it belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The final code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, from what we''ve learned now and in the previous chapter, we can easily
    create our first entity flownode in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the start of the chapter, game objects are used when more advanced
    functionality is required of an entity, for example, if an entity needs to be
    bound to the network.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of implementing game objects, one being by registering the
    entity directly via `IGameObjectSystem::RegisterExtension` (and thereby having
    the game object automatically created on entity spawn), and the other is by utilizing
    the `IGameObjectSystem::CreateGameObjectForEntity` method to create a game object
    for an entity at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Game object extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to extend game objects by creating extensions, allowing the developer
    to hook into a number of entity and game object callbacks. This is, for example,
    how actors are implemented by default, something we'll be covering in [Chapter
    5](ch05.html "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*.
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating our game object extension in C++. The CryMono entity we
    created earlier in the chapter was made possible by a custom game object extension
    contained in `CryMono.dll`, and it is currently not possible to create further
    extensions via C# or Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game object extension in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryENGINE provides a helper class template for creating a game object extension,
    called `CGameObjectExtensionHelper`. This helper class is used to avoid duplicating
    common code that is necessary for most game object extensions, for example, basic
    RMI functionality (we'll cover them in [Chapter 8](ch08.html "Chapter 8. Multiplayer
    and Networking"), *Multiplayer and Networking*).
  prefs: []
  type: TYPE_NORMAL
- en: To properly implement `IGameObjectExtension`, simply derive from the `CGameObjectExtensionHelper`
    template, specifying the first template argument as the class you're writing (in
    our case, `CMyEntityExtension`) and the second as `IGameObjectExtension` you're
    looking to derive from.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, the second argument is `IGameObjectExtension`, but it can be different
    for specific implementations such as `IActor` (which in turn derives from `IGameObjectExtension`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you''ve derived from `IGameObjectExtension`, you''ll need to implement
    all its pure virtual methods to spare yourself from a bunch of unresolved externals.
    Most can be overridden with empty methods that return nothing or false, while
    more important ones have been listed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Init: This is called to initialize the extension. Simply perform `SetGameObject(pGameObject)`;
    and then return true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetSerialize`: This is called to serialize things over the network. This will
    be covered in [Chapter 8](ch08.html "Chapter 8. Multiplayer and Networking"),
    *Multiplayer and Networking*, but for now, it will simply return true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You''ll also need to implement `IGameObjectExtensionCreatorBase` in a new class
    that will serve as an extension factory for your entity. When the extension is
    about to be activated, our factory''s `Create()` method will be called in order
    to obtain the new extension instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you''ve created both your game object extension implementation, as
    well as the game object creator, simply register the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By passing the entity class description to `IGameObjectSystem::RegisterExtension`,
    you're telling it to create a dummy entity class for you. If you have already
    done so, simply pass the last parameter `pEntityCls` as `NULL` to make it use
    the class you registered before.
  prefs: []
  type: TYPE_NORMAL
- en: Activating our extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to activate your game object extension, you'll need to call `IGameObject::ActivateExtension`
    after the entity is spawned. One way to do this is using the entity system sink,
    `IEntitySystemSink`, and listening to the `OnSpawn` events.
  prefs: []
  type: TYPE_NORMAL
- en: We've now registered our own game object extension. When the entity is spawned,
    our entity system sink's `OnSpawn` method will be called, allowing us to create
    an instance of our game object extension.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how the core entity system is implemented and
    exposed and created our own custom entity.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be aware of the process of creating accompanying flownodes for
    your entities, and be aware of the working knowledge surrounding game objects
    and their extensions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be covering existing game object extensions and entity implementations
    in latter chapters, for example, by creating our very own actor and implementing
    basic AI.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get more familiar with the entity system, why not try and create
    a slightly more complex entity on your own?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the game rules system.
  prefs: []
  type: TYPE_NORMAL
