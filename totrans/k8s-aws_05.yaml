- en: Managing Complex Applications with Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you started to learn how to build and deploy the configuration
    needed to run different applications on your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Once you move beyond deploying the simplest of applications, you will discover
    that your applications often have one or more components that work in unison.
    For example, you might have a web application that displays information from a
    database that also uses a scheduled job to update that information on a regular
    basis. In order for this application to function correctly, both of these components
    need to be deployed and functioning correctly. Furthermore, these two components
    likely share some configuration, such as credentials for the backend database.
  prefs: []
  type: TYPE_NORMAL
- en: One other problem we might encounter when deploying applications to our Kubernetes
    cluster is one of reusability. Perhaps we need to run the same tool or application
    in multiple contexts or environments. For example, many organizations have a staging
    environment for testing new versions of software.
  prefs: []
  type: TYPE_NORMAL
- en: When maintaining multiple environments, we ideally want the configuration in
    each environment to match as closely as possible, but of course, some differences
    in configuration are required. Maintaining multiple copies of Kubernetes manifests
    for each of your environments can be error prone, and gives you no guarantees
    that an application that worked in one environment will work in another.
  prefs: []
  type: TYPE_NORMAL
- en: Helm is a popular tool in the Kubernetes ecosystem that solves these problems.
    It gives us a way of building packages (known as charts) of related Kubernetes
    objects that can be deployed in a cohesive way to a cluster. It also allows us
    to parameterize these packages, so they can be reused in different contexts and
    deployed to the varying environments that the services they provide might be needed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Like Kubernetes, development of Helm is overseen by the Cloud Native Computing
    Foundation. As well as Helm (the package manager), the community maintains a repository
    of standard charts for a wide range of open source software you can install and
    run on your cluster. From the Jenkins CI server to MySQL or Prometheus, it's simple
    to install and run complex deployments involving many underlying Kubernetes resources
    with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install the `helm` command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install Helm's in-cluster component, Tiller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can deploy a service to your cluster using a community-maintained chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About the syntax you will need to know when creating charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to host your own chart repository in order to share your charts within your
    organization, or more widely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies for integrating Helm charts into your own deployment processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have already set up your own Kubernetes cluster and have correctly configured
    `kubectl` on your machine, then it is simple to install Helm.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On macOS, the simplest way to install the Helm client is with Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Linux and Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every release of Helm includes prebuilt binaries for Linux, Windows, and macOS.
    Visit [https://github.com/kubernetes/helm/releases](https://github.com/kubernetes/helm/releases)
    to download the version you need for your platform.
  prefs: []
  type: TYPE_NORMAL
- en: To install the client, simply unpack and copy the binary onto your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on a Linux machine you might do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing Tiller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have the Helm CLI tool installed on your machine, you can go about
    installing Helm's server-side component, Tiller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm uses the same configuration as `kubectl`, so start by checking which context
    you will be installing Tiller onto:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will be installing Tiller into the cluster referenced by the Minikube
    context. In this case, this is exactly what we want. If your `kubectl` is not
    currently pointing to another cluster, you can quickly switch to the context you
    want to use like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are still not sure that you are using the correct context, take a quick
    look at the full config and check that the cluster server field is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `minify` flag removes any config not referenced by the current context.
    Once you are happy that the cluster that `kubectl` is connecting to is the correct
    one, we can set up Helm''s local environment and install Tiller on to your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `kubectl` to check that Tiller is indeed running on our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have verified that Tiller is correctly running on the cluster, let''s
    use the `version` command. This will validate that we are able to connect correctly
    to the API of the Tiller server and return the version number of both the CLI
    and the Tiller server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Installing a chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by installing an application by using one of the charts provided
    by the community.
  prefs: []
  type: TYPE_NORMAL
- en: You can discover applications that the community has produced Helm charts for
    at [https://hub.kubeapps.com/](https://hub.kubeapps.com/). As well as making it
    simple to deploy a wide range of applications to your Kubernetes cluster, it's
    a great resource for learning some of the best practices the community uses when
    packaging applications for Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Helm charts can be stored in a repository, so it is simple to install them by
    name. By default, Helm is already configured to use one remote repository called
    **Stable**.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it simple for us to try out some commonly used applications as soon
    as Helm is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you install a chart, you will need to know three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the chart you want to install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name you will give to this release (If you omit this, Helm will create a
    random name for this release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace on the cluster you want to install the chart into (If you omit
    this, Helm will use the default namespace)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm calls each distinct installation of a particular chart a release. Each
    release has a unique name that is used if you later want to update, upgrade, or
    even remove a release from your cluster. Being able to install multiple instances
    of a chart onto a single cluster makes Helm a little bit different from how we
    think about traditional package managers that are tied to a single machine, and
    typically only allow one installation of a particular package at once. But once
    you have got used to the terminology, it is very simple to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: A **chart** is the package that contains all the information about *how* to
    install a particular application or tool to the cluster. You can think of it as
    a template that can be reused to create many different instances or releases of
    the packaged application or tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **release** is a named installation of a chart to a particular cluster. By
    referring to a release by name, Helm can make upgrades to a particular release,
    updating the version of the installed tool, or making configuration changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **repository** is an HTTP server storing charts along with an index file.
    When configured with the location of a repository, the Helm client can install
    a chart from that repository by downloading it and then making a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before you can install a chart onto your cluster, you need to make sure that
    Helm knows about the repository that you want to use. You can list the repositories
    that are currently in use by running the `helm repo list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By default, Helm is configured with a repository named stable pointing at the
    community chart repository and local repository that points at a local address
    for testing your own local repository. (You need to be running `helm serve` for
    this.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a Helm repository to this list is simple with the `helm repo add` command.
    You can add my Helm repository that contains some example applications related
    to this book by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to pull the latest chart information from the configured repositories,
    you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with one of the simplest applications available in my Helm repository,
    `kubeslate`. This provides some very basic information about your cluster, such
    as the version of Kubernetes you are running and the number of pods, deployments,
    and services in your cluster. We are going to start with this application, since
    it is very simple and doesn't require any special configuration to run on Minikube,
    or indeed any other cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing a chart from a repository on your cluster couldn''t be simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should see a lot of output from the `helm` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you will see some metadata about the release, such as its name, status,
    and namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you should see some information about the resources that Helm has instructed
    Kubernetes to create on the cluster. As you can see, a single service and a single
    deployment have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a section with some notes that have been provided by the
    chart''s author to give us some information about how to start using the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notes**:'
  prefs: []
  type: TYPE_NORMAL
- en: To access `kubeslate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First start the kubectl proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**kubectl proxy**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the following URL in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**http://localhost:8001/api/v1/namespaces/default/services/my-slate-kubeslate:http/proxy**`'
  prefs: []
  type: TYPE_NORMAL
- en: Please try reloading the page if you see `ServiceUnavailable / no endpoints
    available for service`, as pod creation might take a few moments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try following these instructions yourself and open Kubeslate in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1121fe40-b439-47de-9d2a-0dbd132b0d97.png)Kubeslate deployed with
    Helm'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use Helm to make a release of a chart, there are certain attributes
    that you might need to change, or configuration you might need to provide. Luckily,
    Helm provides a standard way for users of a chart to override some or all of the
    configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at how, as the user of a chart, you might
    go about supplying configuration to Helm. Later in the chapter, we are going to
    look at how you can create your own charts and use the configuration passed in
    to allow your chart to be customized.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we invoke `helm install`, there are two ways we can provide configuration
    values: passing them as command-line arguments, or by providing a configuration
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: These configuration values are merged with the default values provided by a
    chart. This allows a chart author to provide a default configuration to allow
    users to get up and running quickly, but still allow users to tweak important
    settings, or enable advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing a single value to Helm on the command line is achieved by using the
    set flag. The `kubeslate` chart allows us to specify additional labels for the
    pod(s) that it launches using the `podLabels` variable. Let''s make a new release
    of the kubeslate chart, and then use the `podLabels` variable to add an additional
    `hello` label with the value `world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have run this command, you should be able to prove that the extra
    variable you passed to Helm did indeed result in the pods launched by Helm having
    the correct label. Using the `kubectl get pods` command with a label selector
    for the label we applied using Helm should return the pods that have just been
    launched with Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As well as being able to pass a configuration to Helm when we create a new release,
    it is also possible to update the configuration in a pre-existing release using
    the upgrade command. When we use Helm to update a configuration, the process is
    much the same as when we updated deployment resources in the last chapter, and
    a lot of those considerations still apply if we want to avoid downtime in our
    services. For example, by launching multiple replicas of a service, we can avoid
    downtime, as a new version of a deployment configuration is rolled out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also upgrade our original kubeslate release to include the same `hello:
    world pod` label that we applied to the second release. As you can see, the structure
    of the `upgrade` command is quite similar to the `install` command. But rather
    than specifying the name of the release with the `--name` flag, we pass it as
    the first argument. This is because when we install a chart to the cluster, the
    name of the release is optional. If we omit it, Helm will create a random name
    for the release. However, when performing an upgrade, we need to target a pre-existing
    release to upgrade, and thus this argument is mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run `helm ls`, you should see that the release named `my-slate`
    has been upgraded to Revision 2\. You can test that the deployment managed by
    this release has been upgraded to include this pod label by repeating our `kubectl
    get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can now see that four pods, two from each of our releases, now match the
    label selector we passed to `kubectl get`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing variables on the command line with the `set` flag is convenient when
    we just want to provide values for a few variables. But when we want to pass more
    complex configurations, it can be simpler to provide the values as a file. Let''s
    prepare a configuration file to apply several labels to our kubeslate pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `helm` command to apply this configuration file to our
    release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating your own charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have a little experience with Helm and can use the command-line tool
    to install a chart from a community repository, we are going to take a look at
    how you can leverage Helm to build charts for your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will walk through using Helm to deploy the versions application that we manually
    deployed in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing
    Change in Your Applications*. The aim here is for us to replicate the deployments
    we made in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing
    Change in Your Applications*, but this time to encapsulate the configuration in
    a Helm chart so it is simple to make configuration changes, deploy new versions
    of our code, and even deploy the same configuration multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm makes it very easy to build a chart and deploy it to your cluster. The
    Helm command-line tool has some commands that will get us started very quickly.
    The `helm create` command will create a skeleton for our new chart that we can
    quickly fill in with the configuration for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at each of the files created by Helm, and then look at the configuration
    we will need to add to deploy our versioned web service from [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml),
    *Managing Change in Your Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Chart.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file contains some basic metadata about this chart, such as its name, a
    description, and a version number. This file is required.
  prefs: []
  type: TYPE_NORMAL
- en: values.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file contains the default configuration values for this chart. These are
    the values that will be used when rendering the templated resources when installing
    the chart, unless overrides are provided.
  prefs: []
  type: TYPE_NORMAL
- en: templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This directory contains the templates that will be rendered to produce the definitions
    of the resources that this chart provides. When we run the `helm new` command,
    several skeleton template files are created for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`NOTES.txt` is a special file that is used to provide a post-install message
    to users of your chart. You saw an example of this earlier in the chapter when
    we installed the kube-ops-dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: As with the YAML resources we created by hand in earlier chapters, Helm doesn't
    attach any significance to the filenames we give to our resources. It is up to
    you to decide how to organize resources within the templates directory. The skeleton
    chart we created just now comes with a few files to get us started, but if you
    need to create more resources, you may just add additional files to the templates
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`deployment.yaml` contains a simple manifest for a deployment, `service.yaml`
    contains a simple service manifest for this deployment, and `_helpers.tpl` contains
    some predefined helper functions that you can reuse throughout your chart.'
  prefs: []
  type: TYPE_NORMAL
- en: When you ran `helm new`, some other files may have been created. These are optional
    files used for some more advanced functionality, and we can ignore them for now,
    but if you wish, you can safely remove them altogether from your chart.
  prefs: []
  type: TYPE_NORMAL
- en: There are some standard ways of working with the templates directory that are
    followed in the community charts repository. You might like to review these, as
    they do help to keep your work organized. But unless you are planning to try getting
    your chart published to the community repository, there is no need to stick rigidly
    to these guidelines: [https://docs.helm.sh/chart_best_practices](https://docs.helm.sh/chart_best_practices).
  prefs: []
  type: TYPE_NORMAL
- en: Making it your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the steps that we will take to edit this chart in order to
    deploy our own application. Start by taking a look at the generated `deployment.yaml`
    file. You will notice that it looks very similar to the manifest that we produced
    in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing Change in
    Your Applications*, but with one important difference: all of the specific configuration
    values have replaced will calls to variables. Look, for example, at the line where
    the image for the container is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that when a reference to a variable is inserted into the template,
    it is surrounded by two curly braces, like this: `{{ variable }}`. Secondly, you
    will also notice the dot notation used to access nested attributes on objects.
    The `.Values` object refers to all of the values, either supplied (by default)
    from the `values.yaml` file within the chart, or overridden from the command line
    when the chart is deployed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to configure the source for the image we want to use in our deployment,
    let''s start by editing the `values.yaml` file. Find the section where the image
    is configured and edit to pull the versions application we deployed in [Chapter
    4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing Change in Your Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are editing the `values.yaml` file, let''s also edit the values used
    to configure the service that Helm created for our deployment. We need to change
    the port that our container exposes from `80` to `3000`, and we should change
    the name of our service from `nginx` to something more descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we go back and look at `deployment.yaml` and `service.yaml`, we can see one
    of the advantages of being able to inject variables into our Kubernetes resources
    with templates.
  prefs: []
  type: TYPE_NORMAL
- en: By changing the value of `service.internalPort` in the `values.yaml` file, we
    have a single source of truth; in this case, the port that our container exposes.
    This single source of truth then gets used three times within `deployment.yaml`
    and then again in `service.yaml`. Of course, with a simple example like this,
    we could have edited these files manually, but it makes the cost of maintaining
    the configuration that little bit higher, having to search through several resources,
    and understanding how different configuration values interact.
  prefs: []
  type: TYPE_NORMAL
- en: When I am building a Helm chart, I try to imagine my future self using the chart.
    My aim is to expose enough variables to make the chart flexible enough to reuse
    and redeploy in several environments without having to change or even look at
    the templates. To achieve this, it is important to choose descriptive variable
    names, and provide clear documentation for the use of those variables in the
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to deploy our chart using the Helm command-line client, rather
    than referring to the name of a chart within a remote repository (for example,
    `stable/kube-ops-view`). We can run our Helm commands by pointing to the chart
    directory on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the chart has been installed on to our cluster, let''s test that it''s
    working correctly. The simplest way to do this is to run `kubectl proxy` to set
    up a local proxy to the kubernetes API, and use the service endpoint to view our
    service. The chart that Helm created for us creates a service with a name formed
    by combining the name of the release with the name of the chart. So, assuming
    that the `kubectl proxy` started on port `8001`, we should be able to view our
    service at the following URL: `http://localhost:8001/api/v1/namespaces/default/services/happy-bear-version-app:80/`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a901776-31e6-4663-b202-ffb5ef66f25a.png)'
  prefs: []
  type: TYPE_IMG
- en: Developing and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our charts become more complex and we leverage more of the power of the templating
    language that Helm provides to build our own abstractions on top of the Kubernetes
    resources, you might notice that it becomes harder to reason about errors returned
    by Kubernetes. Because we can no longer see the resources directly that we are
    submitting to Kubernetes, it can become harder to work out the source of a bug
    or misconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Helm has some options that will help us debug our charts as we develop
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`--dry-run`**: This option allows us to submit our chart to the Tiller server,
    where it will be validated in exactly the same way as when we deploy our chart
    without actually submitting the resources to Kubernetes. This lets us see and
    understand any errors with our chart quickly without having to use resources on
    our cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--debug`: This option allows us to see a lot of useful debugging information;
    in fact, so much that it can be a little overwhelming at first. Firstly, we see
    some logging information marked `[debug]`. This includes some details about how
    the Helm client is connecting to Tiller and the chart that is being deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is followed by the release metadata. This is made up from the chart metadata
    from `Chart.yaml` and computed information about the release, such as its number
    and the date and time that it was made.
  prefs: []
  type: TYPE_NORMAL
- en: The next section, `COMPUTED VALUES`, shows the exact values that Helm will be
    using as it renders the templates to produce the resources for this release. If
    you are not passing any extra variables when you make your release, this should
    be identical to the contents of `values.yaml`, but is very useful if you are trying
    to understand exactly what variables are being used by the templates if you are
    providing overrides when you invoke Helm. The `HOOKS` section shows the resources
    that will be created by the Helm hooks mechanism. You will learn a little about
    hooks later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `MANIFEST` section lists out the computed resources, as they will
    be submitted to Kubernetes. When you are developing chart templates, this is invaluable,
    for quickly seeing how your chart behaves given different values. You will find
    that using both these options together with a call to `helm install` or `helm
    upgrade` is very useful in debugging your charts, as well as for validating your
    work and building confidence that changes to your chart or values have the desired
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Templating language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm's templating language is based on the Go templating language. Essentially,
    Helm provides the standard templating language from the Go programming language,
    plus some additional functions and the mechanism for making variables available
    inside of your templates.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen how to use the templating language to place information
    into YAML formatted Kubernetes resources. Calls to functions provided by Helm
    are surrounded by double curly braces, like `{{ this }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply want to include a variable into our template, we can just refer
    to it by name. Helm namespaces its variables inside of a number of objects that
    are exposed to the template. You will have already noticed that the values from
    our `values.yaml` file (as amended by any overwritten variables passed in on the
    command line) are available in the `.Values` object. In addition to this object,
    Helm makes further objects available within the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Release`: This object describes the release itself, and includes a number
    of attributes that can be used to customize your resources to their parent release.
    Commonly, you will use these values to ensure that the resources from this release
    do not conflict with the resources from another release of the same chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.Name`: This is the name of the release. It can be passed to `helm
    install` with the `--name` flag, or it might be automatically generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.Time.Seconds`: This is the time when the release was created as a
    UNIX-style timestamp. It can be useful if you need to add a unique value to a
    resource name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.Namespace`: This indicates the Kubernetes namespace of this release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.Service`: This indicates the service that made the release. Currently,
    this is always Tiller, but if there was an alternative implementation of Helm,
    perhaps it would populate this attribute differently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.Revision`: This is a number used to track updates to the release.
    It begins with 1 and increases each time the release is upgraded via `helm upgrade`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Release.IsUpgrade` and `.Release.IsInstall`: These are Boolean values that
    indicate if the operation producing this release is a new install of the chart,
    or an upgrade of an existing release. These might be utilized to only carry out
    actions at a particular point in the chart''s life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Chart`: The chart object contains the fields from `Chart.yaml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Files`: This object allows you to access the contents of non-template files
    included in the chart. It exposes two functions, `.Get` and `.GetBytes`, that
    allow you to read contents of files as text or indeed as bytes. This can be useful
    for providing static config files or other data that is not included in your container
    images as part of your chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Capabilities`: This object provides information about the cluster that Tiller
    is running on. It can be useful to query this information if you want to produce
    a chart that will work with more than one version of Kubernetes. You will see
    an example of this later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Template`: This object provides a `.Name` and a `.BasePath` attribute that
    includes the filename and directory of the template currently being rendered by
    Helm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm's templating language provides over 60 functions that can manipulate and
    format the data we pass to our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these functions are part of the Go templating language, but most are
    part of the Sprig templating language.
  prefs: []
  type: TYPE_NORMAL
- en: When you begin using Helm, it can be useful to have the documentation to hand
    so you can find the function that you need.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://godoc.org/text/template](https://godoc.org/text/template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://godoc.org/github.com/Masterminds/sprig](https://godoc.org/github.com/Masterminds/sprig)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two ways to invoke a template function in the Helm templating language.
    The first of these involves calling a function, and passing a value as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `{{ upper "hello" }}` will produce the output `HELLO`.
  prefs: []
  type: TYPE_NORMAL
- en: The second way to invoke a function is as a pipeline. You can think of a pipeline
    a little like a UNIX pipe; it provides a concise way to pass the result of one
    function to another. This lets us compose together several functions to get at
    the result we want.
  prefs: []
  type: TYPE_NORMAL
- en: We could rewrite our first example as `{{ "hello" | upper }}` and the result
    would be exactly the same. The advantage of this form comes when we want to apply
    several functions to a value. When we use the pipeline operator, the result of
    the previous function is passed into the next as the last argument. This allows
    us to also call functions that take more than one argument, and is the reason
    that most of the functions in Helm are optimized to take the value to be operated
    on as the last argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, for example, form a pipeline with the `trunc` function to truncate
    our string to a certain number of characters and then use the `upper` function
    to uppercase the result, like this: `{{ "hello" | trunc 4 | upper }}`. The result,
    of course, would be `HELL.`'
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already get a lot of value from Helm by being able to take a single value
    from a chart and include it in a number of places throughout a chart, like the
    example earlier in the chapter, where we referred to the same port number in several
    related places. You might also use this technique, for example, to ensure a system
    with a number of different components provided by different containers are always
    deployed to the same version number.
  prefs: []
  type: TYPE_NORMAL
- en: Another important way that we can use variables in our Helm charts is to provide
    a signal to our template to change our configuration or even turn whole features
    into optional extras that might not always be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three constructs that allow us to construct really powerful abstractions
    using Helm templates: `if...else`, `range`, and `with`.'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the `if...else` construct in Helm should be very familiar to
    anyone who has used a programming language. We use the `if` keyword to test a
    variable or expression. If the test passes, we do the action in the first branch;
    if not, we fall back to the action indicated by the `else` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example you might use to provide a custom message in the `NOTES.txt`
    template, depending on the value of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`if` functions can be nested within the `else` branch to provide more complex
    behavior. In this example, the `Capabilities` object is queried so the templated
    resource can use a correct API version for a `CronJob` resource. This kind of
    capability is useful since it lets you make changes to your configuration to support
    a newer version of Kubernetes, but maintain backwards compatibility. If both of
    our tests for a supported version fail, then we explicitly throw an error that
    will halt the installation of the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Providing toggles like this around configuration based on feature flags or even
    version numbers is a very useful tool to manage change in your configuration.
    It allows you to add an option to your chart, test it out in safety, and then
    only enable it when you are happy to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The `range` keyword is used to loop over a collection. It can loop over simple
    lists or collections with a key value structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a list of values to our `values.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the `range` keyword to loop over the data in our list, and
    use values in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the `|-` marker, which is part of YAML. It indicates
    that the usernames string is multi-line. This will result in each username being
    available in the `ConfigMap` separated by new lines.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, when we use the range function on a list, on each iteration,
    the special `.` variable is replaced by the value from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'When rendered, this template produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this next example, we are going to assign the result of the range function
    to two variables. When we do this with a list, the first variable includes an
    index, and you will notice that when we assign a variable, we prefix its name
    with a `$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this template when rendered looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When using the range function to loop over a key value structure, we can also
    use variables to capture the key and the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following data in our `values.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have some key value data in the users variable, let''s use it to configure
    some environment variables for a pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When we use the range keyword to loop over a key value structure, the key becomes
    the first variable returned and the value becomes the second. By nesting loops,
    as in this case, it becomes possible to use quite complex data structures in the
    values file.
  prefs: []
  type: TYPE_NORMAL
- en: The type of some variables in Kubernetes resources is important. In the preceding
    example, the value in an environment variable must always be a string, so we have
    used the `quote` pipeline function to ensure that values of other types (like
    numbers) are of the correct string type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When rendered, this template produces a pod manifest, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using Helm to help us generate the resources our applications
    need to be submitted to Kubernetes. In the ideal world, this would be all that
    we would need a tool like Helm to do. Kubernetes aims to be declarative; in other
    words, we submit resources describing what we want the state of the cluster to
    look like, and Kubernetes handles the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in the real world, sometimes we still need to explicitly take
    some actions to get our applications running correctly. Perhaps when you install
    your application, you need to run a script to initialize a database schema or
    set up some default users. Perhaps when you install a new version of an application,
    you need to run a script to migrate the schema of your database to be compatible
    with the new version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides a hook mechanism that allows us to take actions at eight specific
    points in the life cycle of a release. In order to define a hook in your Helm
    chart, you add the `helm.sh/hook` annotation to a resource. You can use the hook
    annotation on any resource to ensure that it is created at the appropriate time.
    But typically, it is very useful to create resources of the job type. If your
    resource is of the job type, Tiller will block until the job has successfully
    run to completion. This means that if you are using one of the `pre-` hooks then
    your application can depend on that job having run.
  prefs: []
  type: TYPE_NORMAL
- en: '`pre-install`: This action runs after Tiller has rendered the templates in
    a chart, but before any resources have been submitted to the Kubernetes API. This
    action runs when a new release is created by installing a chart. If you also need
    a hook to run when a release is upgraded, you should combine this hook with the
    `pre-upgrade` hook. You might make use of this hook to initialize resources that
    will be used by your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post-install`: This action runs after all the resources have been submitted
    to the Kubernetes API. You might, for example, use this to run a script that provides
    notifications to a chatroom or to register the new instance of the chart with
    a monitoring tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre-delete`: This hook runs before any resources are deleted from Kubernetes
    when a deletion request is made. This could be useful, for example, if you needed
    to make a backup of data stored by your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post-delete`: This hook runs after Helm has deleted the resources created
    as part of a release. You might utilize this hook to clean up any external resources
    that your application uses that are not managed by Helm or Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre-upgrade`: This hook provides the same functionality as the `pre-install`
    hook, but runs each time a release is upgraded. You might use this hook to run
    a database migration script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post-upgrade`: This hook provides the same functionality as the `post-install`
    hook, but runs each time a release is upgraded. Again, this might be used for
    notification purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pre-rollback`: This hook runs before changes to rollback an upgrade of a release
    is submitted to the Kubernetes API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post-rollback`: This hook runs after a request to rollback an upgrade of the
    release has been submitted to Kubernetes. Depending on the expectations of your
    application, you might run scripts to roll back database changes here or in the
    `pre-rollback` hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example, where we will be using a hook to run a setup script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Everything about the definition of this job is the same as the standard Kubernetes
    resource definition that we looked at in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml),
    *Managing Change in Your Applications*. It is the annotation added to the job
    metadata that enables Helm to treat this definition as a hook rather than a managed
    part of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single resource can be used to implement multiple hooks. For example, if
    you wanted the setup script to be run each time the release is updated as well
    as when it is first installed, we could change the hook annotation to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Helm allows you to create any Kubernetes resource using the hook mechanism.
    This might be useful if, for example, a job created using a hook depends on a
    `ConfigMap` or `Secret`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple hook resources that need to be created in a specific order,
    you can use the `helm.sh/hook-weight` annotation. This weight can be any positive
    or negative integer number. When Helm evaluates a particular hook, the resources
    will be sorted by these weights in ascending order. Since annotations can only
    hold strings, it is important to quote the number used in a hook weight.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a resource with the annotation `"helm.sh/hook-weight": "-5"` would
    be run before `"helm.sh/hook-weight": "5"`, but would be run after a resource
    with the annotation `"helm.sh/hook-weight": "-10"`.'
  prefs: []
  type: TYPE_NORMAL
- en: There is one wrinkle in Helm's hook system that can be quite confusing at first,
    but luckily, once you understand it, there are some simple ways to work around
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Helm keeps track of nearly all of the resources you create with your templates.
    This means that when you upgrade a release, Helm can update all of the resources
    managed by the release, and when a release is deleted, Helm can remove all of
    the resources that it created. The one exception to this is the resources created
    by hooks. Once they are created, Helm no longer manages them and Kubernetes takes
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can cause two different issues when using them in your charts:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, when a chart is deleted, the resources created by hooks won't be deleted.
    This can unexpectedly use up resources in your cluster unless the resources are
    manually deleted. Secondly, if you are using a hook that can be called more than
    once in the life of a chart release, the names of your resources can clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our example job, to run a setup script if we had updated the hook annotation
    to `"helm.sh/hook": pre-install,pre-upgrade`, we would have found that the job
    would run correctly when the chart was installed, but when we come to upgrade
    the release, Helm would try to create a new job with the same name as the job
    already created in the `pre-install` hook. This would cause an error, which would
    prevent the upgrade from proceeding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to work around this issue would be to include the release revision
    number in the name of job, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: While this does prevent job names from colliding, it does mean that each upgrade
    of a release will create a new resource, all of which may need to be cleaned up
    manually when they are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides one more annotation to assist us with this issue. The `helm.sh/hook-delete-policy`
    allows us to instruct Helm to delete a resource after it has been successfully
    executed, or after it fails, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The annotation `"helm.sh/hook-delete-policy": hook-succeeded` is useful for
    the majority of use cases, such as the setup script job example. If the job runs
    successfully, it is deleted, cleaning up the resource ready for a new instance
    to be created with the same name the next time the chart is upgraded. If the job
    fails, it is left as is on the Kubernetes server so it could be inspected for
    debugging purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Helm as part of an automated workflow, where it is important
    to ensure all of the resources created by installing a chart are deleted, whatever
    the outcome, you might want to use the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"helm.sh/hook-delete-policy": hook-succeeded,hook-failed`'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we are developing our chart, it is simple to use the Helm CLI to deploy
    our chart straight from the local filesystem. However, Helm also allows you to
    create your own repository in order to share your charts.
  prefs: []
  type: TYPE_NORMAL
- en: A Helm repository is a collection of packaged Helm charts, plus an index stored
    in a particular directory structure on a standard HTTP web server.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are happy with your chart, you will want to package it so it is ready
    to distribute in a Helm repository. This is simple to do with the `helm package`
    command. When you start to distribute your charts with a repository, versioning
    becomes important. The version number of a chart in a Helm repository needs to
    follow the SemVer 2 guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build a packaged chart, start by checking that you have set an
    appropriate version number in `Chart.yaml`. If this is the first time you have
    packaged your chart, the default will be OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test a packaged chart without uploading it to a repository by using
    the `helm serve` command. This command will serve all of the packaged charts found
    in the current directory and generate an index on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now try installing your chart by using the local repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can test building an index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Helm repository is just a collection of packaged charts stored in a directory.
    In order to discover and search the charts and versions available in a particular
    repository, the Helm client downloads a special `index.yaml` that includes metadata
    about each packaged chart and the location it can be downloaded from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate this index file, we need to copy all the packaged charts
    that we want in our index to the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to generate the `index.yaml` file, we use the `helm repo index`
    command. You will need to pass the root URL where the packaged charts will be
    served from. This could be the address of a web server, or on AWS, you might use
    a S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The chart index is quite a simple format, listing the name of each chart available,
    and then providing a list of each version available for each named chart. The
    index also includes a checksum in order to validate the download of charts from
    the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The generated `index.yaml` file for our new chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the `index.yaml` file, it is simply a question of copying
    your packaged charts and the index file to the host you have chosen to use. If
    you are using S3, this might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In order for Helm to be able to use your repository, your web server (or S3)
    needs to be correctly configured.
  prefs: []
  type: TYPE_NORMAL
- en: The web server needs to serve the `index.yaml` file with the correct content
    type header (`text/yaml` or `text/x-yaml`).
  prefs: []
  type: TYPE_NORMAL
- en: The charts need to be available at the URLs listed in the index.
  prefs: []
  type: TYPE_NORMAL
- en: Using your repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have set up the repository, you can configure Helm to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you add a repository, Helm validates that it can indeed connect to the
    URL given and download the index file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this by searching for your chart by using `helm search`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Organizational patterns for Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within an organization using Kubernetes to deploy its own applications, there
    are a few strategies that you might want to consider in order to produce and maintain
    charts to manage deploying the applications that you use.
  prefs: []
  type: TYPE_NORMAL
- en: Chart per application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to use Helm within your organization is to create a new chart
    for each application that you want to deploy to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: When you have an application that might be deployed to a number of different
    contexts, such as testing, staging, and production environments, this can make
    sure that you have parity between each environment while making it simple to provide
    overrides for the configuration that might be environment-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Helm charts for your applications can help in larger organizations
    where applications might need to be deployed to a number of different environments
    without the help of the team that builds and manages the application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, mobile app or frontend web developers might deploy a backend API
    application developed by another team to a testing or development environment
    using Helm. If the team that develops the backend provides a Helm chart, they
    make it simple for other teams to deploy without needing in-depth knowledge of
    how to install and configure the app.
  prefs: []
  type: TYPE_NORMAL
- en: If the same Helm chart is used to deploy to production as well as the testing
    and development environments, it is simpler to reduce the otherwise inevitable
    drift between production and development environments.
  prefs: []
  type: TYPE_NORMAL
- en: It is simple to use the control flow features of the Helm templating language
    to provide different configurations where appropriate. For example, in staging
    or production environments, your application might rely on saving data to an EBS
    volume, whereas on development machines, the application might simply save to
    a local volume.
  prefs: []
  type: TYPE_NORMAL
- en: You might need to override some values when your chart is deployed. For example,
    you might want to run many more replicas of a pod in a production environment,
    whereas on a development machine, a single replica might be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: If your application can be scaled horizontally by adding more replicas of a
    pod, it makes sense to provide the same memory and CPU limits in all environments
    and then scale up for production traffic by adding additional pods, rather than
    giving each pod greater resource limits. This makes it much simpler to debug issues
    with applications being killed due to out-of-memory errors or being starved of
    CPU resources, since a single pod will have the same resources on your development
    and production clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Shared charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your organization maintains a service or micro-service based system, it is
    common to maintain some level of standardization between the different services
    that you deploy.
  prefs: []
  type: TYPE_NORMAL
- en: One way of maintaining a consistent pattern of deployment between each of your
    applications is to provide a Helm chart that can be used to deploy all of your
    services.
  prefs: []
  type: TYPE_NORMAL
- en: If you do this, you will find that the configuration you need to provide to
    the chart and the templates themselves becomes more complex. But the advantage
    of working this way is it lets you quickly apply new configuration best practices
    to all of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the simpler Helm chart, we provided a new template for each pod that would
    form part of our application. When a chart is to be reused by a number of applications,
    there might be different pods required by each one.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one application might require a web server and a batch job to run
    every hour, while another service provides an admin interface and a worker for
    processing background jobs from a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to deploy two different applications with these different sorts of
    pods using one chart, you need to produce a template—not for each pod in your
    application, but for each type of pod that your service contract supports.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might have one template for long-running pods that are managed
    with Kubernetes Deployment Resources, and another template for managing batch
    jobs with the `CronJob` resource. To then enable and configure each of these templates,
    you can provide a list of each of the pods that your application requires in the
    values passed when you deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: I have made an example chart that takes this approach. It is available at [https://github.com/errm/charts/tree/master/app](https://github.com/errm/charts/tree/master/app).
  prefs: []
  type: TYPE_NORMAL
- en: Library charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your organization has configuration and deployment patterns that you want
    to share between different applications, but the shared chart approach doesn't
    provide enough flexibility or results in overly complex logic in your templates,
    one alternative is to provide library charts that include templates or functions
    that can be used as dependencies of your application to provide common components
    or configuration to each chart that needs them.
  prefs: []
  type: TYPE_NORMAL
- en: This can provide you with some of the benefits of both approaches through being
    able to tailor your chart to a specific application, whilst still being able to
    use shared functionality, to reduce duplication of configuration or to enforce
    best practices or other organization-wide deployment patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is so powerful because it lets you build your own abstractions over a group
    of Kubernetes resources with very little extra effort. You might need to spend
    a little time learning how to use the templating language and how to integrate
    building and updating charts and making and updating releases with your development
    and release procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Helm can be used for a wide range of scenarios where you want to deploy resources
    to a Kubernetes cluster, from providing a simple way for others to install an
    application you have written on their own clusters, to forming the cornerstone
    of an internal Platform as a Service within a larger organization. Beyond what
    is included in this chapter, there is a lot more for you to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Helm has excellent documentation that can be accessed at [https://docs.helm.sh/](https://docs.helm.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: Another great source for learning how to use Helm effectively is the community-maintained
    charts repository at [https://github.com/helm/charts](https://github.com/helm/charts).
    You will find that there a lot of techniques and best practices you can learn
    by looking at the charts available there.
  prefs: []
  type: TYPE_NORMAL
