- en: Chapter 7. Advanced Procmail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have got the basics of Procmail under our belt, we can move on and
    start putting together a more complete mail-handling system. The advanced techniques
    in this chapter are required only if you need a very specialized handling for
    your mail and are not needed for setting up a basic e-mail server. You may wish
    to skip this chapter and return to it once your server is fully configured and
    operational.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a number of more advanced Procmail capabilities in this chapter.
    This chapter will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between delivering and non-delivering recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usage of variables, substitutions, and pseudo-variables in advanced recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking and the use of various flags to control execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How conditions can be applied to test various parts of a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced actions to forward, save, or pass a message on to an external program
    for processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Procmail macros to simplify e-mail header analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed analysis of some advanced recipes with a number of example recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a useful tool chest of routines
    for putting together your own set of Procmail recipes and getting your mail under
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering and non-delivering recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have covered only those recipes that either do a final delivery of
    the mail to a program or a file, or forward a message to another mail user. There
    is another option available, and to quote from the Procmail documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of recipes—delivering and non-delivering recipes. If a delivering
    recipe is found to match, Procmail considers the mail (you guessed it) delivered
    and will cease processing the `.procmailrc` file after having successfully executed
    the action line of the recipe. If a non-delivering recipe is found to match, processing
    of the `.procmailrc` file will continue after the action line of this recipe has
    been executed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Non-delivering example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced an example in the previous chapter that was intended to make backups
    of mail items, in case a recipe that is being tested deletes all mails. This is
    a very useful non-delivering recipe example and may be found in the Procmail manual
    page `procmailex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are fairly new to Procmail and plan to experiment a little, it often
    helps to have a safety net of some sort. Inserting the two recipes mentioned before,
    all other recipes will make sure that the last 32 arriving mail messages will
    always be preserved. In order to make this work as intended, we have to create
    a directory named `backup` in `$MAILDIR` prior to inserting these two recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second recipe uses several features of Procmail, which we will be exploring
    in more detail in later sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If we work step by step through this recipe, we will end up with a useful archive
    utility that records the last 32 mail items to be received and allows us to manually
    recover mail if we ever create a recipe that ends up destroying mail rather than
    storing it. On a busy mail server, it might be prudent to increase this number
    to keep a larger archive of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first recipe performs a simple backup operation by delivering a copy or
    clone of the mail into the `backup` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before adding the second recipe, create the above recipe in the `.procmailrc`
    file and send a couple of mail messages to yourself. We can see that each mail
    item is stored in the backup directory (provided it exists and has the correct
    permissions).
  prefs: []
  type: TYPE_NORMAL
- en: The second recipe is just as simple, but uses some more complex features of
    Linux system commands to delete all but the mail items in the `backup` directory,
    except the most recent 32 items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how this recipe works. Firstly, we will see the rule flags and
    their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | Ignore the return code of the subsequent pipeline command |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Clone or copy the incoming data so that the original data is not affected
    |'
  prefs: []
  type: TYPE_TB
- en: The `|` instructs Procmail to pass the data matched to the following pipeline
    command. Each of these commands performs a specific action.
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cd backup` | Moves to the `backup` directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `ls -t msg.*` | Obtains a list of files beginning with `msg` and sorts them
    in to time order. |'
  prefs: []
  type: TYPE_TB
- en: '| `sed -e 1,32d` | Deletes all but the last 32 lines—that is, the 32 most recent
    mail items. |'
  prefs: []
  type: TYPE_TB
- en: '| `rm -f dummy...` | The parameter `dummy` is to stop error messages in case
    there are no files to be deleted, and then the `rm` command continues to remove
    the files listed by the `sed` filter. |'
  prefs: []
  type: TYPE_TB
- en: These two recipes are examples of unconditional recipes that are run on every
    incoming mail message. The fact that there are no conditional lines, that is,
    the lines beginning with an asterisk symbol (*), infers that the recipes are unconditional.
    As both the recipes include a `c` flag in the recipe, they are also defined as
    non-delivering recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have collected a number of Procmail recipes, we will find that the order
    in which the recipes are processed can be important. By setting the order of processing
    correctly, we can improve performance and reduce the time taken to process incoming
    mails. We can also make sure that more critical rules are applied to important
    messages before the more general rules that are intended to act on bulk messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical scenario could be to apply rules in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Process daemon or server messages first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mailing lists should be handled as early as possible, but after the server messages,
    as we want our services handled first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply `kill file` to block any known spammers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not send vacation replies before we have handled mailing lists to prevent
    annoying vacation replies to mailing lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save private messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for **Unsolicited Bulk E-Mail** (**UBE**)—spam. This avoids the high overhead
    of processing spam checks on known valid e-mail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Formail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Formail** is an external utility program (from Procmail) that is nearly always
    available on systems where Procmail is installed. Its function is to process mail
    messages and extract information from within the headers of the messages. It acts
    as a filter that can be used to force mail into a format suitable for storing
    in a Linux mail system. It can also perform a number of other useful functions
    such as ''From'' escaping, generating auto-replying headers, simple header extracting,
    or splitting up a mailbox/digest/articles file.'
  prefs: []
  type: TYPE_NORMAL
- en: The input data mail/mailbox/article contents need to be provided using the standard
    input. Therefore, `formail` is ideally suited for use in pipeline command chains.
    Output data is provided on the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go into the subtleties of `formail` in this chapter, but
    as it is a useful tool, we will make reference to some of its functionality in
    some of our examples. More information can be obtained from the system manual
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced recipe analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we have a much more complicated recipe that implements a form of vacation
    service to inform senders that you are away and unable to reply to e-mails. At
    first thought this could be a simple non-delivering recipe to send a message back
    to all messages received. However, this is not ideal as some people may end up
    receiving multiple delivery confirmation messages and you may also end up sending
    messages back to system utilities that have no way of understanding your well-meant
    reply.
  prefs: []
  type: TYPE_NORMAL
- en: The example is based on the "vacation example" from the Procmail `procmailex`
    manual page.
  prefs: []
  type: TYPE_NORMAL
- en: The `vacation.cache` file is maintained by Formail. It maintains a vacation
    database by extracting the name of the sender and inserting it in the `vacation.cache`
    file. This ensures that it always contains the most recent names. The size of
    the file is limited to a maximum of approximately 8192 bytes. If the name of the
    sender is new, an auto reply will be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recipe implements a vacation auto reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will come back to this recipe at the end of this section and work through
    creating a slightly updated version using some of the things we have learned about
    Procmail. For now, the example will help as a reference to understand some of
    the concepts we explore in the following breakdown of a general recipe structure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation or adding comments to our rules and recipes is always an important
    task. All comments begin with a `#` character and continue till the end of the
    line. In most cases, it is useful to place comments at the beginning of a line
    or with one or two tabs after a single line that we wish to document.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one section of the rule file where comments *must* be included
    on their own lines and that is in the *Conditions* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Assigning variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to keep track of settings, results from tests, default values, and
    so on, we can store this information in variables. The assignment operation is
    simple and follows the same format as other Linux scripting languages. The basic
    format is `VARIABLENAME=VALUE.`
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There must be no spaces within the variable name. If there are spaces within
    the value being assigned, the whole of the variable should be stored between double
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to access a variable is by enclosing the `VARIABLENAME` within
    braces `{}`, and prefixing it all with a dollar ($) sign. It is quite acceptable
    to use variables within other assignments. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the previous example that `${HOME}` takes the value of the shell environment
    setting as it was set when the process was started.
  prefs: []
  type: TYPE_NORMAL
- en: Careful use of variables and their naming can make a recipe much easier to read
    and also to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Performing substitutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes it will be necessary or useful to be able to replace a literal element
    with a variable that can be calculated or evaluated only at run time. Procmail
    allows the author to replace most literal elements with variable substitutions
    or command substitutions in most places. The simplest way to use a variable is
    to make use of the `$varname` format, which is common to a number of scripting
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable/Command | Substitution |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$VAR` | Wherever `$VAR` occurs in the recipe, replace it with the value
    held by this variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `${VAR}iable *` | When we need to concatenate a variable with literal text,
    use `{}` to enforce the fact that the name is `${VAR}` and not `$VARiable`. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it is necessary to combine variables with fixed text or values, the `{}`
    elements allow absolute definition of the variable name to be established. Notice
    that this will not happen in condition lines unless we include the `$` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning variable with default values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Procmail borrows some standard shell syntax for variable initialization.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to be able to assign a default value to a variable to be used in
    cases where the variable has not been set or could not be calculated for some
    reason, it is possible to use the or `:-` separator. If we wish to apply an alternative
    value where the variable has been set or is non null, use the `+` or `:+` separator.
  prefs: []
  type: TYPE_NORMAL
- en: '| Separator | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `${VAR:-value}` | If `VAR` is unset or null, the expansion of `value` is
    substituted; otherwise, the value of `VAR` is substituted. |'
  prefs: []
  type: TYPE_TB
- en: '| `${VAR-value}` | If `VAR` is unset, the expansion of `value` is substituted;
    otherwise, the value of `VAR` is substituted. |'
  prefs: []
  type: TYPE_TB
- en: '| `${VAR:+value}` | If `VAR` is set or non-null, the expansion of `value` is
    substituted; otherwise, the value of `VAR` is substituted. |'
  prefs: []
  type: TYPE_TB
- en: '| `${VAR+value}` | If `VAR` is set, the expansion of `value` is substituted;
    otherwise, the value of `VAR` is substituted. |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assigning command output to variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is possible to assign the output of a command to a variable by use of the
    (back tick) ` operator—the back tick (`) is ASCII value 96 and not a normal apostrophe
    ('), which has the ASCII value 39.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example will assign the output from the pipeline between the two back ticks
    to the variable or inline in the code as applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of special variables or pseudo-variables assigned directly
    by Procmail. Changing some of these values can actually change the way Procmail
    operates.
  prefs: []
  type: TYPE_NORMAL
- en: Mailbox variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following variables are used by Procmail to determine where it will store
    any delivered mail.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MAILDIR` | The default value for `MAILDIR` is taken from the value of the
    `$HOME` environment variable. It is also the value used for the current working
    directory for Procmail during execution. Unless the output file names include
    a path component, they will be created in this default directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `MSGPREFIX` | This option is used when we want files to be written sequentially
    to a directory. The `MSGPREFIX` is prefixed to the name of the file created using
    this option. The default prefix is `msg.`, so the file will be named `msg.xyz`.
    The option is not used when delivering to a `maildir` or an `MH` directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `DEFAULT` | This is the location of the default mail storage area on our
    system. Normally we would not modify this variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `ORGMAIL` | This is used as a disaster recovery location for cases where
    `DEFAULT` is unavailable for any reason. This should definitely not be modified.
    |'
  prefs: []
  type: TYPE_TB
- en: Program variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Procmail has reasonable defaults written in at the compile time. Mostly these
    do not need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SHELL` | This is a standard environment variable that specifies the shell
    environment within which Procmail needs to invoke sub-processes. The value assigned
    to it should be Bourne shell-compatible such as `/bin/sh`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHELLFLAGS` | This specifies any optional flags that should be passed to
    the `SHELL` when starting it. |'
  prefs: []
  type: TYPE_TB
- en: '| `SENDMAIL` | This instructs Procmail where to find the `sendmail` program
    used for sending mail on to other users. (Usually not to be fiddled with). |'
  prefs: []
  type: TYPE_TB
- en: '| `SENDMAILFLAGS` | Like `SHELLFLAGS`, this specifies any flags or command-line
    arguments that should be passed to the `SENDMAIL` program when it is executed.
    |'
  prefs: []
  type: TYPE_TB
- en: System interaction variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the execution of recipes, Procmail may need to run external commands,
    handle errors, or create files. These variables control how Procmail interacts
    with the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `UMASK` | This gives the file permissions mode used when creating any files.
    See `man umask` for details. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHELLMETAS` | The shell pipeline is compared with the contents of `SHELLMETAS`
    before execution. If any characters from `SHELLMETAS` are found in the pipeline
    command, the command is considered too complicated for Procmail to manage itself
    and a sub-shell process is spawned. If we know that a particular pipeline will
    always be simple enough for Procmail to manage itself but contains characters
    held in `SHELLMETAS`, we can temporarily assign an empty string to `SHELLMETAS`
    while processing the pipeline and then restore `SHELLMETAS`. This will avoid the
    overhead of spawning a sub‑shell. |'
  prefs: []
  type: TYPE_TB
- en: '| `TRAP` | Here we can assign a code segment to be executed at the end of execution
    of Procmail. A use of it, for example, could be to delete temporary files created
    during execution of the recipes.`TEMPORARY=$HOME/tmp/pmail.$$``TRAP="/bin/rm -f
    $TEMPORARY"` |'
  prefs: []
  type: TYPE_TB
- en: '| `EXITCODE` | This value is given back to the process that started Procmail,
    when Procmail exits. Typically the value of `0` is returned for success and non-zero
    values indicate some form of failure. By modifying the `EXITCODE` value, we can
    return specific information about the processing performed.The exit code of a
    program started by Procmail is stored in the variable `$?` |'
  prefs: []
  type: TYPE_TB
- en: Logging variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The verbosity and location of any log output required during recipe execution
    is controlled by the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LOGFILE` | This specifies the location to which Procmail should write all
    its logging and debugging information. If this value is empty, output is sent
    to the **standard error output**, which means it will be lost unless the program
    is running interactively or `stderr` is redirected somewhere. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOG` | If we wish to write something directly to the log file ourselves,
    we can assign a value to the `LOG` variable, and it will be appended to `LOGFILE`.
    If we want to format the output and include a blank line after our log message,
    we must remember to include a blank line in the message that is output.`LOG="Procmail
    is great"` |'
  prefs: []
  type: TYPE_TB
- en: '| `VERBOSE` | This allows the output to be the basic default or provide detailed
    information. Setting `VERBOSE=1` will include detailed logging information that
    will aid in debugging our recipes. To reduce the amount of output information,
    remember to set `VERBOSE=0` after the recipe has been run. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOGABSTRACT` | If `LOGABSTRACT` is set to `all`, all the deliveries will
    have information regarding the sender, subject, and size of the mail delivered.
    If you wish to stop this logging, set `LOGABSTRACT=no`. |'
  prefs: []
  type: TYPE_TB
- en: '| `COMSAT` | If set to `yes`, Procmail will generate comsat/biff notifications.
    For more information, see the `comsat` and `biff` manual pages. |'
  prefs: []
  type: TYPE_TB
- en: Procmail's state variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During the processing of a recipe, Procmail updates the following variables
    with the current state of the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PROCMAIL_OVERFLOW` | If Procmail finds any lines in the Procmail recipe
    file that are longer than the buffer size while reading the file at startup, it
    will set the value of `PROCMAIL_OVERFLOW` as `yes`. If the line being read is
    a condition or action line, the action will be considered to have failed. However,
    if it is a variable assignment or recipe start, Procmail will stop reading the
    file and exit with an abnormal termination. |'
  prefs: []
  type: TYPE_TB
- en: '| `HOST` | This holds the name of the host on which the process is running.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELIVERED` | If the mail message was delivered successfully, this is set
    to `yes` and the calling process will be informed by Procmail. If we manually
    set this to `yes` *and* the message is not delivered, it will be lost without
    trace but the calling process will still believe that it was successfully delivered.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LASTFOLDER` | This gives the name of the last file or directory to which
    a message was written. |'
  prefs: []
  type: TYPE_TB
- en: '| `MATCH` | This holds the information extracted by the last regular expression
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `$=` | This holds the result of the latest scoring recipe. See the*procmailsc*
    manual page for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| `$1, $2, ...; $@; $#` | Just like the standard shell, this specifies the
    command-line arguments that Procmail was started with.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1` is the first command-line argument, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$@` contains all arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$#` contains the number of arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also see the `SHIFT` pseudo-variable. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `$$` | This holds the current process ID. This can be useful for creating
    temporary files unique to the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `$?` | This holds the exit code of the previous shell command. |'
  prefs: []
  type: TYPE_TB
- en: '| `$_` | This holds the name of the current Procmail file that is being processed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$-` | This is an alias for `LASTFOLDER`.`$=` and `$@` can''t be used directly;
    we have to assign the value to another variable before it can be used for anything
    useful. |'
  prefs: []
  type: TYPE_TB
- en: Message content variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main use for these variables is to access data held in the appropriate section
    but where the recipe has a flag that restricts the processing to the other part
    of the message. By using `HB`, we can access information across the whole of the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | This holds the header information for the message being currently processed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | This holds the body of the message being currently processed. |'
  prefs: []
  type: TYPE_TB
- en: Locking variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each of the variables in the following table control the names of any lock files
    and how long the recipe should wait for a lock to become free.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCKFILE` | Assigning a value to this variable creates a global lock file
    that remains until `LOCKFILE` is assigned another value. This value may be either
    the name of another lock file to create or a null value to remove any lock. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCKEXT` | Assigning a value to this allows us to override the extension
    used as part of the lock filename. This can be useful in identifying the process
    that has created the lock file. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCKSLEEP` | If Procmail wants to create a lock on a file that is already
    locked by another process, it will go into a `retry` loop. The `LOCKSLEEP` variable
    specifies the number of seconds to sleep and wait before retrying to obtain the
    lock. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCKTIMEOUT` | This specifies an age in seconds that the lock file must
    be of before it will be assumed that the lock file is invalid and will be overridden.
    If the value is `0` then the lock file will never be overridden. The default value
    is `1024` seconds. |'
  prefs: []
  type: TYPE_TB
- en: Error-handling variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the event of an error in our recipe, we can decide what action to take by
    using any of these variables.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TIMEOUT` | This specifies how long to wait for a child before telling the
    child process to terminate. The default is `960` seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `SUSPEND` | This specifies how long to wait between `NORESRETRY` retries.
    Default is `16` seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `NORESRETRY` | The number of times Procmail will retry before giving up when
    a serious system resource shortage occurs, such as out of disk space or the system
    has reached the maximum number of processes. The default value is `4` and, if
    the number is negative, Procmail will retry forever. If the resources do not become
    available during the retry period, the message will be discarded and classified
    as undeliverable. |'
  prefs: []
  type: TYPE_TB
- en: Miscellaneous variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following table contains information about various Procmail variables that
    may be of use within our recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LINEBUF` | This sets a limit for the length of recipe lines that Procmail
    is ready to cope with. If we need to process very large regular expressions or
    store lots of data into `MATCH`, increase this value. |'
  prefs: []
  type: TYPE_TB
- en: '| `SHIFT` | This is similar to the `shift` feature in normal shell processing.
    Assigning a positive number to this variable moves down Procmail''s command-line
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `INCLUDERC` | This instructs Procmail to load another file containing Procmail
    recipes. This new file is loaded and processed before Procmail continues processing
    the current file. |'
  prefs: []
  type: TYPE_TB
- en: '| `DROPPRIVS` | This ensures that no root privileges are available when Procmail
    is executing as `setuid` or `setgid`. Setting this value to `yes` will make Procmail
    drop all its special privileges. |'
  prefs: []
  type: TYPE_TB
- en: Printing Procmail variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following example will print most of the environment settings in response
    and will provide some information that could be helpful while trying to debug
    problems with Procmail. It is not expected that this is included in any production
    files, otherwise our log file could grow to be extremely large very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `rc.dump` in the same directory as the other Procmail
    recipe files and place the following lines in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the quotes (") that appear at the start and end of the next
    example are required to ensure that the recipe operates correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procmail recipes follow a simple format. However, there are a number of ways
    that Procmail can be instructed to interpret or implement the instructions in
    the rules based on a number of flags and the way that the rules and recipes are
    written.
  prefs: []
  type: TYPE_NORMAL
- en: Colon line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have already discovered, all rules so far have started with a `:0` followed
    by one or more flags and instructions. Historically a number followed the colon
    (`:`) to specify the number of conditions that were present in the rule. Current
    versions of Procmail determine the number of conditions automatically, and hence
    the value `0` is always used.
  prefs: []
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have already discussed that we need to use a locking mechanism in order to
    stop more than one process trying to write to the same file at the same time.
    Of course this requirement varies with the type of process that the filter is
    attempting to invoke. For example, a filter that merely changes or assigns a value
    has no affect on any physical file and so no locking is required. Similarly, a
    filter that merely forwards the data on to another process or another recipient
    inherently does not need a lock to be applied. In most cases, automatic locking
    will be applied when Procmail realizes that it is writing to a file and will provide
    locking of the file itself. In some cases, it may be necessary to explicitly lock
    a resource.
  prefs: []
  type: TYPE_NORMAL
- en: To give some insight into when locking is applied automatically, not required
    at all, or requires manual locking to be enforced, here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic locking
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Any rule that begins with `:0:` will apply automatic file locking. In this case,
    Procmail will automatically determine the name of the file that the mail is being
    delivered to and create a lock file. If the lock file already exists, it will
    wait for a period of time and retry to create the lock. When it finally creates
    the lock file, it will continue with processing. If it is unable to create the
    lock file, it will report an error and continue with the next rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rule uses automatic locking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enforced locking
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There may be a time, especially when processing mail by an external script,
    where enforced locking is required. In most cases, Procmail will determine the
    name of the file that the ultimate data is being written to by examining the process
    command line and looking where output is directed to. However, if the script takes
    care of choosing the output location itself, or if it relies on a file that may
    be altered by another Procmail process, a lock file must be specifically requested
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You are unlikely to need to enforce locking in most of the scripts you write.
  prefs: []
  type: TYPE_NORMAL
- en: No locking
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When forwarding to a pipeline that performs its own file or record-locking
    processes, such as storing a problem report in a database, no record locking is
    required. Similarly if the message is being forwarded to another user, the final
    delivery will take care of the record locking. The simple rule definition is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the examples we have looked at so far, we have allowed the default settings
    of Procmail to take effect. However, there are a number of flags that may be set
    to control how Procmail works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flags](img/8648_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default flags
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If no flags are stated on the colon line of the recipe, Procmail will assume
    that the following flags (`H, hb`) have been used as default values.
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | Only mail headers are scanned. |'
  prefs: []
  type: TYPE_TB
- en: '| `hb` | Action line is passed both, headers and body of the mail data. |'
  prefs: []
  type: TYPE_TB
- en: 'Scope of matching: HB'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Normally, matching will take place across the whole of the mail package including
    both, the headers and the body of the mail. If the mail body could potentially
    be large and we know that we require the matches to be made against just the headers,
    it would be sensible to use the `H` flag to restrict the scope of the matching
    action to be across the headers only.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, it may sometimes be that we are looking for items of information,
    perhaps a repeated footer or signature that appears only in the body of the document,
    in which case we can use the `B` flag to restrict matching to the body only.
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | Performs matching only across the mail headers. |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | Performs matching only across the mail body. |'
  prefs: []
  type: TYPE_TB
- en: '| `HB` | Performs matching across the whole of the mail item including headers
    and body. |'
  prefs: []
  type: TYPE_TB
- en: 'Scope of action: hb'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By default, the action line processes the whole e-mail item including the headers
    and body. If it is required to process only one part of the mail data, it is possible
    to specify which part is passed to the action line.
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Pass only the headers to the action line for processing. |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Pass only the body of the message to the action line for processing.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hb` | Pass both, the headers and the message body, for processing. This
    is the default scope. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to notice the difference between "scope of matching" and "scope
    of action". The value of the flag in the first case determines which part of the
    mail—header, body, or the entire mail—has to be scanned for matching. The value
    of the flag in the second case determines which part of the mail needs to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flow control: aAeEc'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is probably the most complex set of flags to understand of all the Procmail
    flags. Examples later in the chapter will explain various ways of using these
    flags. Briefly the following may be assumed about each of the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | The recipe will be processed only if the conditions of the previous
    recipe were met. |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | The recipe will be processed if the previous recipe''s conditions were
    met and the operation was completed without error. |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | This is the opposite of `A`. The recipe will be processed if the previous
    recipe conditions were not met. |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | The recipe will be processed if the previous recipe conditions were
    met but the processing did not complete successfully. |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | This instructs the recipe to create a copy or clone of the original
    message and process this copy with any actions in a subprocess. The parent process
    continues processing the original copy of the message. |'
  prefs: []
  type: TYPE_TB
- en: The `c` flag should be read as `Clone` or `Copy`. It is a common misconception
    that this flag should be interpreted as `Continue`. The `Clone` or `Copy` operation
    creates a separate copy of the data and a separate flow of execution is created
    to process that data, sometimes as a totally separate child process. When this
    clone recipe is complete, the parent continues execution with the original data
    intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case sensitivity: D'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Diehard Linux users are very much aware of case sensitivity and always view
    `Capitals` as being entirely different to `capitals`. However, the default operation
    of Procmail is to be case insensitive when matching strings. This means, for Procmail
    `Capitals` and `capitals` are identical, unless it is told that case sensitivity
    should be applied by means of the `D` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution mode: fwWir'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can instruct Procmail how to process or execute the recipe and what actions
    to take if errors are encountered during the processing. Errors might not occur
    for smaller mail messages when the processing takes place only on the first few
    lines of data. However, for larger messages, the Linux shell may believe there
    is an error when the pipeline has read only a part of the available data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Filtering Mode** of execution is important to understand. This terminology
    could be confusing as all that Procmail is designed to do is to filter mail. Think
    of the execution mode "filter" in the following way: The mail message we are processing
    would be piped through whatever is on the action line before it is actually piped
    on to Procmail (or at least the rest of our recipe). Another way of viewing the
    filter mode is as a conversion mode where the data is modified in some way and
    returned back to the controlling Procmail recipe for further execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Pass the message contents through the recipe to an external pipeline
    process for processing and then take the output of the process line ready to replace
    the original message contents. |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | If a Linux pipeline process reads only part of its input and then terminates,
    the shell will send a `SIGPIPE` error signal to the Procmail program—the `i` flag
    instructs Procmail to ignore this signal. This should be used where it is expected
    that the pipeline process will return after processing only a part of the message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | The data passed to the pipeline process should be passed just as it
    is without any modifications. |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | By default, the Procmail process will spawn off a subprocess and continue
    its own processing. The `w` flag instructs Procmail to wait for the subprocess
    pipeline to complete before continuing with its own processing. |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | This works the same as `w`, but also hides any error or other output
    messages from the pipeline process. |'
  prefs: []
  type: TYPE_TB
- en: Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of condition types that could be applied to decide if a given
    recipe applies to a particular mail item. The idea of applying conditions correctly
    is to reduce the amount of unnecessary processing that is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Condition lines always begin with an asterisk (*) character followed by one
    or more spaces. It is possible to apply multiple condition lines within a recipe,
    but they must all be grouped together on consecutive lines. The logical operation
    of the grouping is to perform an `AND` operation such that all the conditions
    must be applied before the action is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Applying a rule unconditionally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It may be required that a rule has to be applied to all messages regardless
    of any conditions. Such a rule could, for example, make a backup copy of the mail
    message to a mail folder or archive all mail for legal or corporate policy reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The unconditional rule is implied by the lack of a conditional line. That is,
    the rule will always match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The unconditional rule is often used at the end of a nested chain of recipes
    to perform a final default action if the recipe has not delivered the mail. Remember
    that processing stops once a message has been delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Tests with regular expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Those of us that are familiar with simple pattern-matching operations such as
    `?` or `*` used commonly in matching of files in a file listing operation, may
    wonder if it is possible to create similar tests to match parts of a mail header
    or body. The good news is that there is an excellent feature known as **regular
    expressions** or **regex** for short. These provide a mechanism for very complex
    pattern-matching operations to be performed. In general, this feature matches
    very closely with the `egrep` command-line regular expressions. However, there
    are some important differences that experienced `regex` users should definitely
    be aware of, in order to understand how to write expressions tailored for Procmail
    operation. There is a complete section on writing `regex` later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions may be run against the data portion of the mail message
    (header, body, or both) as defined by the flags or may be used to test a previously
    assigned variable.
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `* regex` | Tests the part of the message passed according to the flags against
    the regular expression. Normally this will process just the headers unless a `B`
    flag is given to indicate that the scope of matching was to process the body of
    the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `* variable ?? regex` | This is to compare the assigned variable against
    the `regex` for comparison. |'
  prefs: []
  type: TYPE_TB
- en: Various pseudo-variables were listed earlier in the chapter and represent ways
    to access information that is contained within the Procmail application. These
    pseudo-variables can be compared in the same way as normal variables.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will make a copy of all the mail items that contain a
    key phrase in the message body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a quick explanation of the operation of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: We specify `:0cB:` to make sure that we search only through the body, and to
    make a copy so we still get the original message processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If anywhere in the body there is a phrase that has one or more numbers followed
    by a`<SPACE>Linux Rules<SPACE>` followed by either `o, k`, or `!`, then a copy
    will be stored in the `linuxrules` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and unsetting the `VERBOSE` option before a rule is processed allows
    just that rule to be displayed in the log in more detail, which means less log
    file to search through while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the size of a message part
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, we may not want large messages to be processed by a recipe. In
    this situation, we can set a limit that the recipe will not match messages over
    a certain size. If we have users that use a slow data connection, perhaps using
    connectivity over a mobile phone connection, it can be useful to move all large
    items of mail into a separate folder for retrieval when the users are back at
    a better Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `* > number` | Will return `true` if the message size is larger than the
    given number of bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `* < number` | Will return `true` if the message size is smaller than the
    given number of bytes. |'
  prefs: []
  type: TYPE_TB
- en: Testing the exit code of an external program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If an external program is run to provide a part of the processing, the exit
    code may need to be checked to make sure that the process completed correctly
    or to perform a secondary operation to complete the overall processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `?` instructs Procmail to pass the current message data to the Linux command
    line as standard input. The condition is successfully met if the command line
    exits with a zero exit code. While the command line is a pipeline of several processes,
    the exit code returned is that of the last program in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Any output printed to standard error by the pipeline is displayed in the log.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the body of the message is passed to the command pipeline and,
    if the phrase is found in exactly the third line (exit code 0), the message is
    filed in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: The action of lines between the `VERBOSE=1` and the `VERBOSE=0` will be logged,
    but all lines outside this range will not be logged. This allows us to control
    the amount of logging taking place, and hence makes it easier to follow the log
    file activity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Negation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it is useful to be able to check if a particular condition does not
    exist in order to continue processing in a certain way. The **Exclamation** (!),
    or **Bang** as it is sometimes referred to, is used to reverse the value of the
    condition so that false becomes true and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This tests for a negative result in the condition and returns `true` if the
    condition is not met.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are looking for any item that was not sent directly to us and will be
    stored in a folder for later viewing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Variable substitution in conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Multiple `$` flags may be used to force multiple substitution passes to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `$` instructs Procmail to process the condition with the normal `sh` rules
    to perform variable and back tick substitution before actually evaluating the
    condition. The substitution process will resolve variables (`$VAR`) into their
    values rather than processing them as literals. Any quoted strings will have their
    quotes removed and all other shell meta characters will also be evaluated. To
    have any of these characters passed through this substitution process, they should
    be escaped using the standard backslash (\) escape mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is taken from the *procmailex* manual page, and even
    there it is described as being rather exotic, but it does serve as an example.
    Suppose you have a file in your home directory called `.urgent`, and the (one)
    person named in that file is the sender of an incoming mail. You would like that
    mail to be stored in `$MAILDIR/urgent` instead of in any of the normal mail folders
    it would have been sorted in. Then this is what you could do (beware, the file
    length of `$HOME/.urgent` should be well below `$LINEBUF`; increase `LINEBUF`
    if necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Action line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the line that does all of the processing activity. In most cases, this
    will mean writing to a physical file or folder. But it can also include forwarding
    mail to other users, passing data to a command or pipeline of commands or, in
    some cases, a number of successive actions to be performed as part of a compound
    recipe. If you want to perform more than one action, you can't just stack them
    one after the other—you need multiple recipes (possibly unconditional, and/or
    grouped in a pair of braces) and a colon line (and optionally conditions, of course)
    for each.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that flags that affect the action line are not actually taking effect
    until the action is actually attempted. In particular, a `c` flag doesn't generate
    a clone of the message until its conditions have all been met.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding to other addresses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Global forwarding of all messages for a user account to another user account
    is a process that can be handled much more efficiently by Postfix itself. However,
    if some logic needs to be applied to decide what or where to send the message,
    then Procmail can assist.
  prefs: []
  type: TYPE_NORMAL
- en: Most mail transports will allow us to pass multiple e-mail addresses for onward
    transmission.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The above action is functionally the same as passing the message to the following
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a special case for forwarding mail and instructs Procmail to extract
    the list of recipients from the original message''s actual headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we will forward mail to our support team rather than handle it ourselves.
    The mail includes the phrase **support** in the subject line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Feeding to a shell or command pipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Procmail allows a virtually unlimited amount of freedom in what can be done
    to an e‑mail. One of the more powerful features of working with Procmail is its
    ability to forward an e-mail based on given criteria to an application program
    or script. A possible example would be to track support requests and have the
    entries stored directly into a database system where they can be tracked within
    a dedicated application.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline process is responsible for saving its output. The recipe's flags
    are able to tell Procmail to expect something else. By using the`>>` syntax, Procmail
    can determine a lock file to use. It is important to always use locking when writing
    to a file so as to avoid two operations writing to the same file at the same time
    and corrupting each other's data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to have the output of the command pipeline stored in a variable.
    This, by its own action, makes the recipe a non-delivering recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this syntax is allowed only on the action line. For the same
    result in a plain assignment, we could use back tick (`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Saving to a folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This saves the output to a plain file. If only a filename is provided, the file
    will be created in the directory specified in the `MAILDIR` setting. Always make
    sure that you use some form of locking when writing to a plain file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When saving to a directory, files will be created with sequentially numbered
    files within the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using a trailing (/) slash at the end of the path name instructs Procmail to
    store the item in a `maildir` formatted folder. The subfolders, `cur, new`, and
    `tmp` are created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using `/`. at the end of the path name instructs Procmail to store the item
    in an `MH` formatted folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we want to store the data into several `MH` or `maildir` folders, we can
    list them all at the same time. The result will be that only one file will actually
    be written, the rest will be created as hard links.
  prefs: []
  type: TYPE_NORMAL
- en: Compound recipes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we want to perform a number of conditional processes or actions on a matched
    item, then instead of a single action line we can specify a block of recipes to
    be used using the `{` and `}` characters. There must be at least one space after
    the `{` and before the `}` characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The code between the braces can be any valid Procmail construct.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that an action that is a variable assignment always has to go inside a
    set of braces: `{ VAR=value }`. Using just `VAR=value` without the braces would
    result in the data being saved to a folder named `VAR=value`.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want a recipe that does not actually do any processing, perhaps as part
    of an `if…else` operation, we can use an empty set of `{ }`, but the rules regarding
    the whitespace still apply and we need to ensure that there is at least one whitespace
    character between the two braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example takes the previous example and modifies it slightly so
    that only one test is performed and then a series of unconditional tests are run
    if the test passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Procmail implements a form of regular expressions that operates slightly differently
    than other UNIX utilities. Here we cover the basic differences and guide the new
    user into the powerful world of regular expressions, their meanings, implementations,
    and uses.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen that Procmail matches are case insensitive unless the `D`
    flag is used. This is also true for regular expressions. Procmail also uses multiline
    matches by default.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New users to the world of Linux and programming in general, may not be aware
    of the powerful features that regular expressions bring to processing data. In
    its simplest form, regular expressions can be understood as searching for a phrase
    or pattern anywhere in a body of data. The following simple example shows how
    we can match all mail items where the header and/or body contains the phrase `mystical
    monsters` and place the mail in a relevant folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this filter would not match items that contained the phrase `mystical
    monster` or `mystical-monsters`, for example. So, the real power of regular expressions
    can be seen in the ability to describe text or data patterns in a simplified format
    and then search for matches to those patterns in a body of data. However, you
    should be careful not to be misled by the word *simplified*. The majority of regular
    expressions that you will come across in real life may well be anything but simple
    to read if written in the native format. Take the following example, which is
    intended to determine if a mail item is MIME encoded and store it in a suitable
    folder if it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The characters `., [, ^, ;, ], +, ?, \, /`, and`"` are special instructions
    rather than the literal ASCII character they normally portray. To understand these
    characters and their meanings, we will take a whirlwind tour through the most
    important examples.
  prefs: []
  type: TYPE_NORMAL
- en: The dot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the simplest and most common form of regular expression and simply
    means match any single character, (excluding a newline character, which is considered
    a special case). Consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This would match any of the following phrases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In fact, it will match any phrase with a three-character word between `Dragons`
    and `mystical`. If we wanted to match any length of word with three or more characters
    between `Dragons` and `mystical`, we could use the `?` or quantifier operation.
  prefs: []
  type: TYPE_NORMAL
- en: In case we want to match a literal '.' or more than one '.', we can escape any
    character that has special significance to a regular expression string by preceding
    it by a backslash '\' so that '\.' will literally match a '.' (period) and '\\'
    will literally match a '\' (backslash) character.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifier operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The question mark indicates that the preceding character should be matched
    zero times or one time only. So, the following lines of code will meet our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This expression could be read as, "Match any word consisting of three or more
    characters followed by nothing or any one character".
  prefs: []
  type: TYPE_NORMAL
- en: 'The character preceding the `?` may also be a simple ASCII character in which
    case the expression would match as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This could be read as, "Any two characters followed by either nothing or a letter
    `d.`" Therefore this would match both `an` and `and` but not `are.`
  prefs: []
  type: TYPE_NORMAL
- en: The asterisk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The asterisk modifier works in a way similar to the quantifier operator, but
    means match zero or more of the preceding character except, of course, a newline.
    The `.*` is a very common sequence that you will find in a large number of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will match all the messages that include the word `choose`
    followed by some other words followed by the word `online:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example will look for "anything" (.*) followed by two or more exclamation
    marks (!!) and (!*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The plus sign
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The plus sign is very similar to the `*` except that it requires that there
    must be at least one instance of the character preceding the `+` in the regular
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider our previous example, the next example will look for "anything"
    `.*` followed by two `!!` and at least one more (!+) exclamation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This would now give us a more restricted output where at least three `!` in
    a row would be required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Restrictive matches using parentheses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, the matching patterns that we have been able to create are powerful
    but work in a rather unfocused way. For example, we can easily write a rule to
    find any three-letter word ending in `t` but cannot limit the matches to only
    a given set of words ending in `t`. To overcome this, we can replace the`.` or
    single character with a group of characters or sets of groups of characters in
    a list and then apply the quantifier operations to say exactly how many times
    these can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: By careful use of the parentheses `( )`, we can create groups of strings that
    we will use in the pattern matching rules. For instance, let us assume we are
    trying to split e-mails that are sent by a system script on a frequent basis.
    The script formats the subject line to have one of the following phrases in the
    subject line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The following regular expression will match the specific string we are looking
    for by matching any string that has one or more occurrences of the phrase `is
    only one` between `there` and `problem`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to filter a list of words or phrases, we would need to use the
    **Alternation** feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `|` character separates lists of words that could be used to match against
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The following simple spam filter uses the alternation feature to search for
    text substitutions regularly used in a bid to avoid the simple word-based filters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple spam filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the growing number of spam messages that we receive every day, I am sure
    that some of you reading so far will have figured out that we could start to filter
    some of the regular messages that we receive on a daily basis. There are a number
    of specific spam filters that are designed to work closely with Procmail and offer
    a far larger set of tests and coverage for spam filtering. One such application,
    SpamAssassin, is covered in [Chapter 8](ch08.html "Chapter 8. Busting Spam with
    SpamAssassin").
  prefs: []
  type: TYPE_NORMAL
- en: Take for example online casinos—a popular subject for spammers who encourage
    us to explore them. It is something that we are not usually interested in, and
    so we feel happy to filter all messages that contain the words "Online" and "Casinos"
    into a separate folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Part of the challenge for spammers is to write subject lines that we can read
    while spam filters find difficult to process. A simple way of doing this is to
    substitute commonly mistyped characters such as Zero (`0`) for letter `O` or letter
    `o, 1` for `L` or `l`, and `4` for `A` or `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we could progress and write the rule as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The final iteration of this recipe is shown next where we are specifically looking
    for subject lines that contain both the words "online" and "casino" but to include
    the occasions where the word may be in different order each word is tested separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While this would work quite well, it is not really efficient to have rules that
    work in this way and, as this sort of substitution is a common requirement for
    regular expressions, there is a special way of expressing these terms in the **Character
    classes**.
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any sequence of characters contained in square brackets `[ ]` indicates that
    the listed characters are each to be checked in the expression. For common occurrences
    of sequences of characters such as the letters of the alphabet or a range of numbers,
    it is possible to use `[a-z]` or `[0-9]:`
  prefs: []
  type: TYPE_NORMAL
- en: '`[a-e]` means match all the letters `a, b, c, d, e` inclusive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1,3,5-9]` means match any of the numbers `1, 3, 5, 6, 7, 8`, or `9`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example will find messages that embed numbers `0` and `1` within
    text strings so that they look like `O` and `L` or `I`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Start of line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to match all of a wide range of characters and not match a small
    number of ranges, it is easier to specify the negative match using the `^` character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This means to match any string that begins with anything that is not a number
    between `0` and `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to add a start of line anchor to patterns we are searching for
    when we know that the pattern should start the line. For example, all headers
    must start on the beginning of the line, so searching for the following phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'would also match headers that begin with a phrase such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop this, we can add the **Start of Line Anchor character** (^) and change
    the regular expression to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: End of Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we are planning to match strings that we know we should terminate, we
    can add the **End of Line Anchor character**, `$`, to the pattern to ensure that
    we match right to the end of the string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will match any subject line that ends in the word `now`.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions are an enormous subject, but well worth learning as they
    are used by a large number of Linux tools and applications. There are many online
    resources related to regular expressions. Here are a few links to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we briefly covered in the previous chapter, Procmail has a number of useful
    "pre-prepared" regular expressions or macros that provide a range of matches that
    are commonly used in Procmail recipes.
  prefs: []
  type: TYPE_NORMAL
- en: ^TO and ^TO_
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`^TO` was the original Procmail macro for handling "To" addresses. This has
    been superseded by the newer `^TO_` macro that was introduced in Procmail version
    3.11pre4.'
  prefs: []
  type: TYPE_NORMAL
- en: This catchall includes most headers that can include your address in them, such
    as `To:, Apparently-To:, Cc:, Resent-To:`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you should use the `^TO_` option as it has much better coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it would seem logical to have a similar macro to cover the source address
    details, note that there is *no* corresponding `^FROM` or `^FROM_` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the regular expression string from the Procmail source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: ^FROM_MAILER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This macro recognizes a wide range of mail generation programs and is a useful
    catchall. However, new programs are being created all the time, so additional
    filters will nearly always be required.
  prefs: []
  type: TYPE_NORMAL
- en: Procmail expands this short macro into the following regular expression as taken
    from the Procmail source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ^FROM_DAEMON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This takes a similar approach to the `^FROM_MAILER` but is intended to identify
    messages from the more common Linux daemons and system processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expression string from Procmail source code is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The following example will store the daemon messages received in a folder that
    includes the year and month as part of the path. These variables `${YY}` and `${MM}`
    are assigned previously in the Procmail file and the necessary directories are
    also created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Advanced recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are going to assemble the various items of Procmail capability into
    a few useful recipes that we can use as the basis for tools within our own organization.
    The first example is based on the traditional `Vacation` recipe that informs senders
    of the e-mail that may not be read by the recipient for some time. The second
    shows how to create the support to automatically file messages based on the date
    and the possible time of being processed. Finally, we will complete the rule started
    in the previous chapter to inform the user of large mail items that have been
    filtered into a separate folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a vacation auto reply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is based upon the vacation example given in `man procmailex` and
    referred to briefly earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed, blindly and automatically responding to an e-mail
    is a very bad idea and has significant ramifications. First we must decide whether
    to send an auto reply. To do this, we need to make sure that conditions make sense
    and are satisfied. If so, headers (signified by the `h` flag) of the current message
    are fed to `formail`, a utility program that is part of the Procmail suite of
    utilities. `formail` then checks the `vacation.cache` file to find out if the
    sender has already received an auto reply. This is to make sure we are not sending
    multiple reports to a user. While this part of the processing is going on, our
    recipe will create a lock as `vacation.lock`.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for this is to avoid clashes when updating the cache, which
    could result in corruption of the cache information.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe actually comprises two individual recipes. The first one provides
    the checks and recording of replies sent to ensure that we don't send duplicate
    or repetitive replies.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe `W`, waits for a return from `formail`. Without the `c`, Procmail
    would stop processing after completing this recipe because it is a delivery recipe.
    It delivers headers to `formail`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to the `TO_` and `^FROM_DAEMON` conditions than what meets the
    eye.
  prefs: []
  type: TYPE_NORMAL
- en: '`TO_ $<logname>` is satisfied if the user''s login name appears in any recipient
    header **To:, Cc:, Bcc:**. This avoids sending auto replies to messages that were
    addressed to an alias or mail list, but not explicitly to our user.'
  prefs: []
  type: TYPE_NORMAL
- en: '`!^FROM_DAEMON` makes sure we do not auto reply to messages from any of the
    wide variety of daemons.'
  prefs: []
  type: TYPE_NORMAL
- en: '`!^X-Loop: $RECIPIENT` avoids replying to our own auto reply; notice that this
    `X-Loop` header is inserted into the auto replies we send out.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the recipe takes place if the first one did not find a match
    in the cache. There are two reasons that the address may not have been found—either
    it has never been seen and so no reply has been sent, or it was seen so long ago
    that the entry has been forced out of the cache. In either case, a copy of the
    vacation message will be sent. The sender will never receive an automatic reply
    for every single message that they send—something that can really upset a prolific
    mail writer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Due to `e`, the previous recipe is executed if the preceding one returns an
    error status. In this case, it is not really an error, it is just the signal from
    `formail` that the address didn't exist in the cache file and we can go ahead
    with the auto reply. Notice that if in the preceding recipe the conditions are
    not met causing the `formail` cache check to be skipped, Procmail is clever enough
    to skip this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The headers of the current message are fed to the `formail` in this recipe,
    in order to construct the headers for the auto reply.
  prefs: []
  type: TYPE_NORMAL
- en: The `c` in this recipe causes the entire current message to be processed after
    this recipe. Typically, this means that it will be processed with no further recipes
    and that is how we get a copy in our mailbox. There is no need for a lock while
    executing this recipe, so none is used.
  prefs: []
  type: TYPE_NORMAL
- en: All that is required to send back to the sender of the original message is a
    copy of the message, and that is held in the file `.vacation_message` in the user's
    home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the message information outside the Procmail recipe makes it easy to
    allow your system users to easily update the message that they send out without
    risk of them breaking the actual recipe itself.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing mail by date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may not want to delete mail that you feel may be useful one day. This can
    easily lead to gigabytes of data being stored in a variety of locations. It is
    possible to filter some or all of our incoming mails into folders based on a combination
    of the year, month, and topic so that they can be tracked down easily.
  prefs: []
  type: TYPE_NORMAL
- en: A generic rule that is applied to every mail process ensures that the necessary
    directory structure exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would prefer slightly more control over the output format or location,
    you may use these rules instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Informing users about large mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced a very simple rule that stored all incoming
    mail over 100 KB in size in a `largemail` folder. This was useful in keeping the
    size of individual incoming mail folders from growing too large, but meant that
    a special check had to be made regularly to see if any mail had been filtered.
  prefs: []
  type: TYPE_NORMAL
- en: In this rule, we will now extract the headers and subject line, plus the first
    few lines of the original large e-mail message, and create a new message with
    a modified subject line. This modified message will be stored in the user's inbox
    at the same time as filtering the large original item into its separate `largemail`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main part of the test will be applied only if the size of the message is
    over 100,000 bytes in size, so we will need a structure similar to the following
    recipe to do the initial testing and decide if this is a large item or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we do have a large item, we need to make a copy of the message
    using the `c` flag and store this copy in the `largemail` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Extracting the first part of the body of the message comes next and this can
    be done using a variety of options. In this case, we are going to strip off the
    first 1024 bytes of the message by waiting for the results of passing only the
    body of the message only to the system head command and telling it to return only
    the first 1024 bytes. The flags used here tell Procmail to wait for the results
    of the command-line process and to ignore any pipeline errors as the head command
    will only read part of the data being offered to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to rewrite the subject line, which is done using the `formail` program.
    This time, we pass just the headers to the command line and wait for the response.
  prefs: []
  type: TYPE_NORMAL
- en: In this case though, we need to obtain the current subject line so that we can
    pass it to the `formail` program as part of the modified subject line. We do this
    by doing a simple match on the subject contents and then passing the `$MATCH`
    variable, which now holds the subject line contents as an argument to the `formail`
    program. For neatness, we add the `{* -BIG- *}` wording before the original subject
    line to make it easy to sort and identify these messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Normal delivery of the message will then take place and the new shorter message
    will be stored in the inbox.
  prefs: []
  type: TYPE_NORMAL
- en: If we put all of this together, we end up with the following complete recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Procmail Module Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As part of a community effort to avoid reinventing the wheel, the Procmail
    Module Library provides a collection of useful recipes contributed by Procmail
    users. The following introduction from the Procmail Module Library [http://freshmeat.net/projects/procmail-lib](http://freshmeat.net/projects/procmail-lib)
    describes the package as:'
  prefs: []
  type: TYPE_NORMAL
- en: Procmail Module Library is a collection of many plug-in modules for the Procmail
    mail processing utility. The modules allow common tasks like parsing dates, times,
    MIME, and email addresses, forwarding mail, dealing with POP3, spam shielding,
    running email cron jobs, handling daemon messages, and more.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Each of the modules, or Procmail included files, are comprehensively documented
    and show example usage. They can be used as supplied, with various configurable
    options or used as a basis of your own recipes. Many of the techniques we have
    illustrated in this chapter are used in the library along with some more sophisticated
    filtering methods based on the type of content within a message.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a wide range of topics in this chapter, which we can now pull
    together. The following examples use each of the techniques shown in this chapter
    and are commonly used for e-mail processing. I hope that you find it useful in
    creating your own mail filtering strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a structure to base your own rules upon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping related aspects of the Procmail rules and configuration will make your
    installation easier to maintain and less likely to create problems when making
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Within the main Procmail directory, create individual files following a consistent
    naming convention such as `rc.main, rc.spam, rc.lists`, and so on. Then include
    each of these into your main `.procmailrc` file as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now for each of the listed `include` files, create the file as named and include
    the rules related to the container in that file. It then becomes a matter of commenting
    an `INCLUDERC` reference for temporarily isolating a section of processing for
    incoming mail. Be careful not to blindly cut and paste these examples without
    checking if each recipe performs as expected, especially in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Rc.system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'File informational system and daemon messages in a dated folder structure can
    be given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Rc.lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Save all our subscribed mailing lists in dated folders for reading later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Rc.killspam
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Delete any mail from senders that match an address in our kill file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Rc.vacation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our holiday auto reply recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Rc.largefiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid clogging up our inbox with large messages, we file the large message
    in a folder and send ourselves a notification that we have received an oversized
    message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Rc.viruses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anything with an e-mail header indicating the message as a virus, file in a
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Rc.spamfilter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anything with an e-mail header indicating the message is spam, file in a folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have explored Procmail to discover a large number of services
    and a large amount of functionality that it can provide to help with getting our
    mail under control. Using the advanced features of Procmail we have discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between delivering and non-delivering recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to order each recipe to avoid slow delivery times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of Procmail variables and condition flags to control delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions for sophisticated pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The large number of available Procmail macros and their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, a number of example recipes to manage our mail effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we have covered a lot, there is still a lot to be learned and there are
    a large number of resources available on the Web dedicated to this one particular
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you will now have a strong grasp of the core functionality of Procmail,
    how to implement it, and also how to go about exploring your real-life needs,
    and creating recipe sets that you can combine to create your own unique mail filtering
    strategy.
  prefs: []
  type: TYPE_NORMAL
