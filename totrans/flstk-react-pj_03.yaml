- en: Building a Backend with MongoDB, Express, and Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development of most web applications, there are common tasks, basic
    features, and implementation code repeated across the process. The same is true
    for the MERN applications developed in this book. Taking these similarities into
    consideration, we will first lay the foundations for a skeleton MERN application
    that can be easily modified and extended to implement a variety of MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics and start with the backend
    implementation of the MERN skeleton, using Node, Express, and MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: User CRUD and auth in a MERN application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests with an Express server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Mongoose schema for a user model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs for user CRUD and auth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auth with JWT for protected routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running backend code and checking APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skeleton application overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The skeleton application will encapsulate rudimentary features and a workflow
    repeated for most MERN applications. We will build the skeleton essentially as
    a basic but fully functioning MERN web application with user **cr**eate, **u**pdate,
    **d**elete (**CRUD**), and **auth**entication-**auth**orization (**auth**) capabilities,
    which will also lay out how to develop, organize, and run code for general web
    applications built using this stack. The aim is to keep the skeleton as simple
    as possible so it is easy to extend, and can be used as a base application for
    developing different MERN applications.
  prefs: []
  type: TYPE_NORMAL
- en: Feature breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the skeleton application, we will add the following use cases with user
    CRUD and auth functionality implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sign up**: Users can register by creating a new account using an email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User list**: Any visitor can see the list of all registered users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**: Registered users can sign in and sign out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected user profile**: Only registered users can view individual user
    details after signing in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorized user edit and delete**: Only a registered and authenticated user
    can edit or remove their own user account details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus of this chapter – the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on building a working backend for the skeleton
    application with Node, Express, and MongoDB. The completed backend will be a standalone
    server-side application that can handle HTTP requests to create a user, list all
    users, and view, update, or delete a user in the database while taking user authentication
    and authorization into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: User model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user model will define user details to be stored in the MongoDB database,
    and also handle user-related business logic such as password encryption and user
    data validation. The user model for this skeletal version will be basic with support
    for the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field name** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | String | Required field to store user''s name |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | String | Required unique field to store user''s email and identify
    each account (only one account allowed per unique email) |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | String | Required field for authentication, the database will
    store the encrypted password and not the actual string for security purposes |'
  prefs: []
  type: TYPE_TB
- en: '| `created` | Date | Automatically generated timestamp when a new user account
    is created |'
  prefs: []
  type: TYPE_TB
- en: '| `updated` | Date | Automatically generated timestamp when existing user details
    are updated |'
  prefs: []
  type: TYPE_TB
- en: API endpoints for user CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable and handle user CRUD operations on the user database, the backend
    will implement and expose API endpoints that the frontend can utilize in the views,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **API route** | **HTTP method** |'
  prefs: []
  type: TYPE_TB
- en: '| Create a user | `/api/users` | `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| List all users | `/api/users` | `GET` |'
  prefs: []
  type: TYPE_TB
- en: '| Fetch a user | `/api/users/:userId` | `GET` |'
  prefs: []
  type: TYPE_TB
- en: '| Update a user | `/api/users/:userId` | `PUT` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete a user | `/api/users/:userId` | `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: '| User sign-in | `/auth/signin` | `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| User sign-out (optional) | `/auth/signout` | `GET` |'
  prefs: []
  type: TYPE_TB
- en: Some of these user CRUD operations will have protected access, which will require
    the requesting client to be either authenticated, authorized, or both. The last
    two routes are for authentication and will allow the user to sign in and sign
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Auth with JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To restrict and protect access to the user API endpoints according to the skeleton
    features, the backend will need to incorporate authentication and authorization
    mechanisms. There are a number of options when it comes to implementing user auth
    for web applications. The most common and time tested option is the use of sessions
    to store user state on both the client and server side. But a newer approach is
    the use of **JSON Web Token** (**JWT**) as a stateless authentication mechanism
    that does not require storing user state on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches have strengths for relevant real-world use cases. However, for
    the purpose of keeping the code simple in this book, and because it pairs well
    with the MERN stack and our example applications, we will use JWT for auth implementation.
    Additionally, the book will also suggest security enhancement options in future
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How JWT works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user successfully signs in using their credentials, the server side
    generates a JWT signed with a secret key and a unique user detail. Then, this
    token is returned to the requesting client to be saved locally either in `localStorage`,
    `sessionStorage`, or a cookie in the browser, essentially handing over the responsibility
    of maintaining user state to the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fd35db0d-22fd-4aa9-8206-3e51089ada4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For HTTP requests made following a successful sign-in, specially requests for
    API endpoints that are protected and have restricted access, the client side has
    to attach this token to the request. More specifically, the `JSON Web Token` must
    be included in the request `Authorization` header as a `Bearer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When the server receives a request for a protected API endpoint, it checks the
    `Authorization` header of the request for a valid JWT, then verifies the signature
    to identify the sender and ensures the request data was not corrupted. If the
    token is valid, the requesting client is given access to the associated operation
    or resource, otherwise an authorization error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the skeleton application, when a user signs in with email and password, the
    backend will generate a signed JWT with the user's ID and with a secret key available
    only on the server. This token will then be required for verification when a user
    tries to view any user profiles, update their account details, or delete their
    user account.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user model to store and validate user data, then integrating
    it with APIs to perform CRUD operations based on auth with JWT, will produce a
    functioning standalone backend. In the rest of the chapter, we will look at how
    to achieve this in the MERN stack and setup.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the skeleton backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start developing the backend part of the MERN skeleton, we will first set
    up the project folder, install and configure the necessary npm modules, and then
    prepare the run scripts to aid development and run the code. Then, we will go
    through the code step by step to implement the user model, API endpoints, and
    JWT-based auth to meet the specifications we defined earlier for the user-oriented
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The code discussed in this chapter, and for the complete skeleton application
    is available on GitHub in the repository at [github.com/shamahoque/mern-skeleton](https://github.com/shamahoque/mern-skeleton). The
    code for just the backend is available at the same repository in the branch named
    `mern-skeleton-backend`. You can clone this code and run the application as you
    go through the code explanations in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Folder and file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following folder structure only shows the files that are relevant for the
    MERN skeleton backend. With these files, we will produce a functioning, standalone
    server-side application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This structure will be further expanded in the next chapter, where we complete
    the skeleton application by adding a `React` frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the development environment is already set up, we can initialize the MERN
    project to start developing the backend. First, we will initialize `package.json`
    in the project folder, configure and install development dependencies, set configuration
    variables to be used in the code, and update `package.json` with run scripts to
    help develop and run the code.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need a `package.json` file to store meta information about the project,
    list the module dependencies with version numbers, and to define run scripts.
    To initialize a `package.json` file in the project folder, go to the project folder
    from the command line and run `npm init`, then follow the instructions to add
    the necessary details. With `package.json` created, we can proceed with setup
    and development, and update the file as more modules are required throughout code
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Development dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to begin with development and to run the backend server code, we will
    configure and install Babel, Webpack, and Nodemon as discussed in [Chapter 2](844f64fb-8fc2-47a1-94a4-dea6bc8f5665.xhtml)*,*
    *Preparing the Development Environment*, with some minor adjustments for just
    the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be using ES6 to write the backend code, we will configure and
    install Babel modules to convert ES6.
  prefs: []
  type: TYPE_NORMAL
- en: First, we configure Babel in the `.babelrc` file with presets for the latest
    JS features and some stage-x features not currently covered under `babel-preset-env`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we install the Babel modules as `devDependencies` from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the module installations are done, you will notice that the `devDependencies`
    list has been updated in the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need Webpack to compile and bundle the server-side code using Babel,
    and for configuration we can use the same `webpack.config.server.js` discussed
    in [Chapter 2](844f64fb-8fc2-47a1-94a4-dea6bc8f5665.xhtml), *Preparing the Development
    Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, run the following command to install `webpack`, `webpack-cli`,
    and the `webpack-node-externals` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Webpack modules and update the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To automatically restart the Node server as we update the code during development,
    we will use Nodemon to monitor the server code for changes. We can use the same
    installation and configuration guidelines discussed in [Chapter 2](844f64fb-8fc2-47a1-94a4-dea6bc8f5665.xhtml),
    *Preparing the Development Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Config variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `config/config.js` file, we will define some server-side configuration
    related variables that will be used in the code, but should not be hardcoded as
    a best practice, as well as for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/config/config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The config variables defined are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: To differentiate between development and production mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: To define the listening port for the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jwtSecret`: The secret key to be used to sign JWT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongoUri`: The location of the MongoDB database for the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the server as we develop the code for only the backend, we can start
    with the `npm run development` script in the `package.json` file. For the complete
    skeleton application, we will use the same run scripts defined in [Chapter 2](844f64fb-8fc2-47a1-94a4-dea6bc8f5665.xhtml),
    *Preparing the Development Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run development`: Running this in the command line from your project folder
    will basically start Nodemon according to the configuration in `nodemon.js`. The
    configuration instructs Nodemon to monitor the server files for updates, and on
    update to build the files again, then restart the server so the changes are immediately
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will integrate Express, Node, and MongoDB to run a completely
    configured server before we start implementing the user specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Express, we will first install Express, then add and configure it in
    the `server/express.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, run the following command to install the `express` module with
    the `--save` flag, so the `package.json` file is automatically updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once Express is installed, we can import it into the `express.js` file, configure
    as required, and make it available to the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle HTTP requests and serve responses properly, we will use the following
    modules to configure Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body-parser`: Body parsing middleware to handle the complexities of parsing
    streamable request objects, so we can simplify browser-server communication by
    exchanging JSON in the request body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the `body-parser` module: `npm install body-parser --save`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure Express: `bodyParser.json()` and `bodyParser.urlencoded({ extended:
    true })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookie-parser`: Cookie parsing middleware to parse and set cookies in request
    objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the `cookie-parser` module: `npm install cookie-parser --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`compression`: Compression middleware that will attempt to compress response
    bodies for all requests that traverse through the middleware:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the `compression` module: `npm install compression --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`helmet`: A collection of middleware functions to help secure Express apps
    by setting various HTTP headers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the `helmet` module: `npm install helmet --save`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cors`: Middleware to enable **CORS** (**Cross-origin resource sharing**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `cors` module: `npm install cors --save`
  prefs: []
  type: TYPE_NORMAL
- en: After the preceding modules are installed, we can update `express.js` to import
    these modules and configure the Express app before exporting it for use in the
    rest of the server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `mern-skeleton/server/express.js` code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Starting the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Express app configured to accept HTTP requests, we can go ahead and
    use it to implement the server to listen for incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `mern-skeleton/server/server.js` file, add the following code to implement
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We first import the config variables to set the port number that the server
    will listen on, and then the configured Express app to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: To get this code running and continue development, you can now run `npm run
    development` from the command line. If the code has no errors, the server should
    start running with Nodemon monitoring for code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mongoose and connecting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the `Mongoose` module to implement the user model in this skeleton,
    and also all future data models for our MERN applications. Here, we will start
    by configuring Mongoose, and utilizing it to define a connection with the MongoDB
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to install the `mongoose` module, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, update the `server.js` file to import the `mongoose` module, configure
    it to use native ES6 promises, and finally use it to handle the connection to
    the MongoDB database for the project.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you have the code running in development, saving this update should restart
    the server that is now integrated with Mongoose and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose is a MongoDB object modeling tool that provides a schema-based solution
    to model application data. It includes built-in type casting, validation, query
    building, and business logic hooks. Using Mongoose with this backend stack provides
    a higher layer over MongoDB with more functionality including mapping object models
    to database documents. Thus, making it simpler and more productive to develop
    with a Node and MongoDB backend. To learn more about Mongoose, visit [mongoosejs.com](http://mongoosejs.com).
  prefs: []
  type: TYPE_NORMAL
- en: Serving an HTML template at a root URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a Node, Express, and MongoDB enabled server now running, we can extend
    it to serve an HTML template in response to an incoming request at the root URL
    `/`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `template.js` file, add a JS function that returns a simple HTML document
    that will render `Hello World` on the browser screen.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/template.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To serve this template at the root URL, update the `express.js` file to import
    this template, and send it in the response to a GET request for the `'/'` route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this update, opening the root URL in a browser should show Hello World
    rendered on the page.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running the code on your local machine, the root URL will be `http://localhost:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: User model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement the user model in the `server/models/user.model.js` file,
    using Mongoose to define the schema with the necessary user data fields, to add
    built-in validation for the fields and to incorporate business logic such as password
    encryption, authentication, and custom validation.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by importing the `mongoose` module and use it to generate a `UserSchema`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `mongoose.Schema()` function takes a schema definition object as a parameter
    to generate a new Mongoose schema object that can be used in the rest of the backend
    code.
  prefs: []
  type: TYPE_NORMAL
- en: User schema definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user schema definition object needed to generate the new Mongoose schema
    will declare all the user data fields and associated properties.
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `name` field is a required field of type `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `email` field is a required field of type `String`, which must match a valid
    email format and must also be `unique` in the user collection.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Created and updated timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fields `created` and `updated` are `Date` values that will be programmatically
    generated to record timestamps for a user being created and updated.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Hashed password and salt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hashed_password` and `salt` fields represent the encrypted user password
    that we will use for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The actual password string is not stored directly in the database for security
    purposes and is handled separately.
  prefs: []
  type: TYPE_NORMAL
- en: Password for auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The password field is very crucial for providing secure user authentication
    in any application, and it needs to be encrypted, validated, and authenticated
    securely as a part of the user model.
  prefs: []
  type: TYPE_NORMAL
- en: As a virtual field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `password` string provided by the user is not stored directly in the user
    document. Instead, it is handled as a `virtual` field.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the `password` value is received on user creation or update, it is encrypted
    into a new hashed value and set to the `hashed_password` field, along with the
    `salt` value in the `salt` field.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The encryption logic and salt generation logic, which are used to generate the
    `hashed_password` and `salt` values representing the `password` value, are defined
    as `UserSchema` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the `authenticate` method is also defined as a `UserSchema` method,
    which is used when a user supplied password must be authenticated for sign-in.
  prefs: []
  type: TYPE_NORMAL
- en: The `crypto` module in Node is used to encrypt the user-provided password string
    into a `hashed_password` with a randomly generated `salt` value. The `hashed_password`
    and the salt is stored in the user document when the user details are saved to
    the database on a create or update. Both the `hashed_password` and `salt` values
    are required in order to match and authenticate a password string provided during
    user sign-in, using the `authenticate` method defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: Password field validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add validation constraints on the actual password string selected by the
    end user, we will need to add custom validation logic and associate it with the
    `hashed_password` field in the schema.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that a password value is indeed provided, and has a length of at least
    six characters when a new user is created or existing password is updated, custom
    validation is added to check the password value before Mongoose attempts to store
    the `hashed_password` value. If validation fails, the logic will return the relevant
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `UserSchema` is defined, and all the password related business logic
    is added as discussed previously, we can finally export the schema at the bottom
    of the `user.model.js` file, in order to use it in other parts of the backend
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/models/user.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Mongoose error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The validation constraints added to the user schema fields will throw error
    messages, if violated when user data is saved to the database. To handle these
    validation errors and other errors that the database may throw when we make queries
    to it, we will define a helper method to return a relevant error message that
    can be propagated in the request-response cycle as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the `getErrorMessage` helper method in the `server/helpers/dbErrorHandler.js`
    file. This method will parse and return the error message associated with the
    specific validation error or other error that occurred while querying MongoDB
    using Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Errors that are not thrown because of a Mongoose validator violation will contain
    an error code and in some cases need to be handled differently. For example, errors
    caused due to a violation of the unique constraint will return a different error
    object than Mongoose validation errors. The unique option is not a validator but
    a convenient helper for building MongoDB unique indexes, and thus we will add
    another `getUniqueErrorMessage` method to parse the unique constraint related
    error object and construct an appropriate error message.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/helpers/dbErrorHandler.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By using the `getErrorMessage` function exported from this helper file, we will
    add meaningful error messages when handling errors thrown by Mongoose operations
    performed for user CRUD.
  prefs: []
  type: TYPE_NORMAL
- en: User CRUD API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user API endpoints exposed by the Express app will allow the frontend to
    do CRUD operations on the documents generated according to the user model. To
    implement these working endpoints, we will write Express routes and corresponding
    controller callback functions that should be executed when HTTP requests come
    in for these declared routes. In this section, we will look at how these endpoints
    will work without any auth restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: The user API routes will be declared using Express router in `server/routes/user.routes.js`,
    and then mounted on the Express app we configured in `server/express.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: User routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user routes defined in the `user.routes.js` file will use `express.Router()`
    to declare the route paths with relevant HTTP methods, and assign the corresponding
    controller function that should be called when these requests are received by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will keep the user routes simple, by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/users` for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing users with GET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new user with POST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/users/:userId` for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching a user with GET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a user with PUT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a user with DELETE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting `user.routes.js` code will look as follows (without the auth considerations
    that need to be added for protected routes).
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: User controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `server/controllers/user.controller.js` file will contain the controller
    methods used in the preceding user route declarations as callbacks when a route
    request is received by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user.controller.js` file will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The controller will make use of the `errorHandler` helper to respond to the
    route requests with meaningful messages when a Mongoose error occurs. It will
    also use a module called `lodash` when updating an existing user with changed
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '`lodash` is a JavaScript library which provides utility functions for common
    programming tasks including manipulation of arrays and objects. To install `lodash`,
    run `npm install lodash --save` from command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the controller functions defined previously are related to a route request,
    and will be elaborated on in relation to each API use case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to create a new user is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a POST request at `'/api/users'`, it calls the `create`
    function defined in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a new user with the user JSON object received in the POST
    request from the frontend within `req.body`. The `user.save` attempts to save
    the new user into the database after Mongoose does a validation check on the data,
    consequently an error or success response is returned to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to fetch all the users is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a GET request at `'/api/users'`, it executes the `list`
    controller function.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `list` controller function finds all the users from the database, populates
    only the name, email, created and updated fields in the resulting user list, and
    then returns this list of users as JSON objects in an array to the requesting
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a user by ID to read, update, or delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All three API endpoints for read, update, and delete require a user to be retrieved
    from the database based on the user ID of the user being accessed. We will program
    the Express router to do this action first before responding to the specific request
    to read, update, or delete.
  prefs: []
  type: TYPE_NORMAL
- en: Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the Express app receives a request to a route that matches a path containing
    the `:userId` param in it, the app will first execute the `userByID` controller
    function before propagating to the `next` function specific to the request that
    came in.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `userByID` controller function uses the value in the `:userId` param to
    query the database by `_id`, and load the matching user's details.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If a matching user is found in the database, the user object is appended to
    the request object in the `profile` key. Then, the `next()` middleware is used
    to propagate control to the next relevant controller function. For example, if
    the original request was to read a user profile, the `next()` call in `userById`
    would go to the `read` controller function.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to read a single user's data is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a GET request at `'/api/users/:userId'`, it executes
    the `userByID` controller function to load the user by the `userId` value in the
    param, and then the `read` controller function.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `read` function retrieves the user details from `req.profile` and removes
    sensitive information, such as the `hashed_password` and `salt` values, before
    sending the user object in the response to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to update a single user is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a PUT request at `'/api/users/:userId'`, similar to
    the `read`, it first loads the user with the `:userId` param value, and then the
    `update` controller function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `update` function retrieves the user details from `req.profile`, then uses
    the `lodash` module to extend and merge the changes that came in the request body
    to update the user data. Before saving this updated user to the database, the
    `updated` field is populated with the current date to reflect the last updated
    at timestamp. On successful save of this update, the updated user object is cleaned
    by removing the sensitive data, such as `hashed_password` and `salt`, before sending
    the user object in the response to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to delete a user is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a DELETE request at `'/api/users/:userId'`, similar
    to the read and update, it first loads the user by ID, and then the `remove` controller
    function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/user.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `remove` function retrieves the user from `req.profile` and uses the `remove()`
    query to delete the user from the database. On successful deletion, the requesting
    client is returned the deleted user object in the response.
  prefs: []
  type: TYPE_NORMAL
- en: With the implementation of the API endpoints so far, any client can perform
    CRUD operations on the user model, but we want to restrict access to some of these
    operations with authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: User auth and protected routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To restrict access to user operations such as user profile view, user update,
    and user delete, we will implement sign-in authentication with JWT, then protect
    and authorize the read, update, and delete routes.
  prefs: []
  type: TYPE_NORMAL
- en: The auth-related API endpoints for sign-in and sign-out will be declared in
    `server/routes/auth.routes.js` and then mounted on the Express app in `server/express.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Auth routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two auth APIs are defined in the `auth.routes.js` file using `express.Router()`
    to declare the route paths with relevant HTTP methods, and assigned corresponding
    auth controller functions that should be called when requests are received for
    these routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The auth routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''/auth/signin''`: POST request to authenticate the user with email and password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''/auth/signout''`: GET request to clear the cookie containing a JWT that
    was set on the response object after sign-in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting `mern-skeleton/server/routes/auth.routes.js` file will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Auth controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The auth controller functions in `server/controllers/auth.controller.js` will
    not only handle requests to the sign-in and sign-out routes, but also provide
    JWT and `express-jwt` functionality to enable authentication and authorization
    for protected user API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auth.controller.js` file will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The four controller functions are elaborated on in the following to show how
    the backend implements user auth using JSON Web Tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Sign-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to sign in a user is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/auth.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a POST request at `'/auth/signin'`, it executes the
    `signin` controller function.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `POST` request object receives the email and password in `req.body`. This
    email is used to retrieve a matching user from the database. Then, the password
    authentication method defined in the `UserSchema` is used to verify the password
    received in the `req.body` from the client.
  prefs: []
  type: TYPE_NORMAL
- en: If the password is successfully verified, the JWT module is used to generate
    a JWT signed using a secret key and the user's `_id` value.
  prefs: []
  type: TYPE_NORMAL
- en: Install the `jsonwebtoken` module to make it available to this controller in
    the import by running `npm install jsonwebtoken --save` from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the signed JWT is returned to the authenticated client along with user
    details. Optionally, we can also set the token to a cookie in the response object
    so it is available to the client side if cookies is the chosen form of JWT storage.
    On the client side, this token must be attached as an `Authorization` header when
    requesting protected routes from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Sign-out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoint to sign out a user is declared in the following route.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/auth.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When the Express app gets a GET request at `'/auth/signout'`, it executes the
    `signout` controller function.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `signout` function clears the response cookie containing the signed JWT.
    This is an optional endpoint and not really necessary for auth purposes if cookies
    are not used at all in the frontend. With JWT, user state storage is the client's
    responsibility, and there are multiple options for client-side storage besides
    cookies. On sign-out, the client needs to delete the token on the client side
    to establish that the user is no longer authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting routes with express-jwt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To protect access to the read, update, and delete routes, the server will need
    to check that the requesting client is actually an authenticated and authorized
    user.
  prefs: []
  type: TYPE_NORMAL
- en: To check if the requesting user is signed in and has a valid JWT when a protected
    route is accessed, we will use the `express-jwt` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `express-jwt` module is middleware that validates JSON Web Tokens. Run `npm
    install express-jwt --save` from the command line to install `express-jwt`.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring sign-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `requireSignin` method in `auth.controller.js` uses `express-jwt` to verify
    that the incoming request has a valid JWT in the `Authorization` header. If the
    token is valid, it appends the verified user's ID in an `'auth'` key to the request
    object, otherwise it throws an authentication error.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can add `requireSignin` to any route that should be protected against unauthenticated
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing signed in users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some of the protected routes such as update and delete, on top of checking
    for authentication we also want to make sure the requesting user is only updating
    or deleting their own user information. To achieve this, the `hasAuthorization`
    function defined in `auth.controller.js` checks if the authenticated user is the
    same as the user being updated or deleted before the corresponding CRUD controller
    function is allowed to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/controllers/auth.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `req.auth` object is populated by `express-jwt` in `requireSignin` after
    authentication verification, and the `req.profile` is populated by the `userByID`
    function in the `user.controller.js`. We will add the `hasAuthorization` function
    to routes that require both authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting user routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add `requireSignin` and `hasAuthorization` to the user route declarations
    that need to be protected with authentication and also authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Update the read, update, and delete routes in `user.routes.js` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/routes/user.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The route to read a user's information only needs authentication verification,
    whereas the update and delete routes should check for both authentication and
    authorization before these CRUD operations are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Auth error handling for express-jwt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the auth-related errors thrown by `express-jwt` when it tries to
    validate JWT tokens in incoming requests, we need to add the following error-catching
    code to the Express app configuration in `mern-skeleton/server/express.js`, near
    the end of the code, after the routes are mounted and before the app is exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`express-jwt` throws an error named `UnauthorizedError` when the token cannot
    be validated for some reason. We catch this error here to return a `401` status
    back to the requesting client.'
  prefs: []
  type: TYPE_NORMAL
- en: With user auth implemented for protecting routes, we have covered all the desired
    features of a working backend for the skeleton MERN application. In the next section,
    we will look at how we can check if this standalone backend is functioning as
    desired without implementing a frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the standalone backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of options when it comes to selecting tools to check backend
    APIs, ranging from the command-line tool curl ([https://github.com/curl/curl](https://github.com/curl/curl))
    to Advanced REST Client ([https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo))—a
    Chrome extension app with an interactive user interface.
  prefs: []
  type: TYPE_NORMAL
- en: To check the APIs implemented in this chapter, first have the server running
    from the command line, and use either of these tools to request the routes. If
    you are running the code on your local machine, the root URL is `http://localhost:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ARC, we will showcase the expected behavior for five use cases of checking
    the implemented API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new user with the `/api/users` POST request, and pass
    name, email, and password values in the request body. When the user is successfully
    created in the database without any validation errors, we will see a 200 OK success
    message as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a33bc049-08a1-4fc9-b5ae-33f3f08a4ce1.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching the user list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see if the new user is in the database by fetching a list of all users
    with a `GET` request to `/api/users`. The response should contain an array of
    all the user objects stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9f44f9e-5f75-4c8e-875b-0c9eeedf7308.png)'
  prefs: []
  type: TYPE_IMG
- en: Trying to fetch a single user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will try to access a protected API without signing in first. A `GET`
    request to read any one of the users will return a 401 Unauthorized, such as in
    the following example, a `GET` request to `/api/users/5a1c7ead1a692aa19c3e7b33`
    returns a 401:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d089bdf-7f14-480c-97b3-4217eeac894b.png)'
  prefs: []
  type: TYPE_IMG
- en: Signing in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to access the protected route, we will sign in using the credentials
    of the user created in the first example. To sign in, a POST request is sent at
    `/auth/signin` with the email and password in the request body. On successful
    sign-in, the server returns a signed JWT and user details. We will need this token
    to access the protected route for fetching a single user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f5444db-3e39-4a3f-8f8e-fd0ef0976303.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching a single user successfully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the token received after sign-in, we can now access the protected route
    that failed before. The token is set in the `Authorization` header in the Bearer
    scheme when making the GET request to `/api/users/5a1c7ead1a692aa19c3e7b33`, and
    this time the user object is returned successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93af55fd-9288-4870-9250-549a0df79e08.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we developed a fully functioning standalone server-side application
    using Node, Express, and MongoDB, covering the first part of the MERN skeleton
    application. In the backend, we implemented the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A user model for storing user data, implemented with Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User API endpoints to perform CRUD operations, implemented with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User auth for protected routes, implemented with JWT and `express-jwt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also set up the development flow by configuring Webpack to compile ES6 code,
    and Nodemon to restart the server when the code changes. Finally, we checked the
    implementation of the APIs using the Advanced Rest API Client extension app for
    Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to extend this backend application code in the following chapter,
    to add the React frontend and complete the MERN skeleton application.
  prefs: []
  type: TYPE_NORMAL
