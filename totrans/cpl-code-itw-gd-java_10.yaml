- en: '*Chapter 8*:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and Dynamic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers one of the favorite topics of interviewers: Recursion and
    Dynamic Programming. Both work hand in hand, so you must be able to cover both.
    Commonly, the interviewer expects to see a plain recursive solution. However,
    they may ask you to provide some optimization hints or even to code an optimized
    version of your code. In other words, your interviewer will want to see Dynamic
    Programming at work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Programming in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to implement a wide range of recursive
    algorithms. You''ll have a significant number of recursive patterns and approaches
    you can use to recognize and implement recursive algorithms in minutes in your
    toolbelt. Let''s start with the first topic of our agenda: recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code presented in this chapter on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method that calls itself directly/indirectly is called recursion. This method
    is known as a recursive method. The famous Fibonacci numbers problem can be implemented
    recursively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important parts in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case**: Returns a value without subsequent recursive calls. For special
    input(s), the function can be evaluated without recursion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fibonacci()` method calls itself, we have a recursive method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing a recursive problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we try to solve a problem via a recursive algorithm, we must recognize
    it as a good candidate for such an algorithm. Most of the recursive problems used
    in interviews are famous, so we recognize them by name. For example, problems
    such as Fibonacci numbers, summing a list of numbers, greatest common divisor,
    the factorial of a number, recursive Binary Search, reversing a string, and so
    on are well-known recursive problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what do all these problems have in common? Once we know the answer to this
    question, we will be able to recognize other recursive problems as well. The answer
    is quite simple: all these problems can be built off of sub-problems. In other
    words, we say that we can express the value returned by a method in terms of other
    values returned by that method.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When a problem can be built off sub-problems, it is a good candidate for being
    solved recursively. Typically, such problems include the words *list top/last
    n ..., compute the n*th *or all..., count/find all solutions that ..., generate
    all cases that ...*, and so on. In order to compute *the n*th*...*, we must compute
    *n*th-1*, n*th-2, and so on so that we can divide the problem into sub-problems.
    In other words, computing f(*n*) requires computing f(*n*-1), f(*n*-2), and so
    on.*Practice* is the keyword in recognizing and solving recursive problems. Solving
    a lot of recursive problems will help you recognize them just as easily as you
    blink.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll highlight the main aspects of Dynamic Programming and learn how
    to optimize plain recursion via Dynamic Programming.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Programming in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about optimizing recursion, we talk about Dynamic Programming.
    This means that solving recursive problems can be done using plain recursive algorithms
    or Dynamic Programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s apply Dynamic Programming to the Fibonacci numbers, starting with
    the plain recursive algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The plain recursive algorithm for the Fibonacci numbers has a runtime of O(2n)
    and a space complexity of O(n) – you can find the explanation in [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*. If we set *k*=7 and represent the call stack as
    a tree of calls, then we obtain the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Tree of calls (plain recursion)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Tree of calls (plain recursion)
  prefs: []
  type: TYPE_NORMAL
- en: If we check the Big O chart from [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*, then we'll notice that O(2n) is far from being
    efficient. Exponential runtimes fit the **Horrible** area of the Big O chart.
    Can we do this better? Yes, via the *Memoization*approach.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization (or Top-Down Dynamic Programming)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a recursive algorithm has repeated calls for the same inputs, this indicates
    that it performs duplicate work. In other words, a recursive problem may have
    overlapping sub-problems, so the road to the solution involves solving the same
    sub-problem multiple times. For example, if we redraw the tree of calls for Fibonacci
    numbers and we highlight the overlapping problems, then we obtain the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Tree of calls (duplicate work)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Tree of calls (duplicate work)
  prefs: []
  type: TYPE_NORMAL
- en: It is obvious that more than half of the calls are duplicate calls.
  prefs: []
  type: TYPE_NORMAL
- en: '*Memoization* is a technique that''s used to remove duplicate work in a method.
    It guarantees that a method is called for the same input only once. To achieve
    this, *Memoization* caches the results of the given inputs. This means that, when
    the method should be called to compute an input that has already been computed,
    *Memoization* will avoid this call by returning the result from the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses *Memoization* to optimize the plain recursive algorithm
    for the Fibonacci numbers (the cache is represented by the `cache` array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we redraw the tree of calls from the preceding code, then we obtain the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Tree of calls (Memoization)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Tree of calls (Memoization)
  prefs: []
  type: TYPE_NORMAL
- en: Here, it is obvious that *Memoization* has drastically reduced the number of
    recursive calls. This time, the `fibonacci()` method take advantage of cached
    results. The runtime was reduced from O(2n) to O(n), so from exponential to polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '*Memoization* is also referred to as a *Top-Down*approach. The *Top-Down* approach
    is not very intuitive because we start developing the final solution immediately
    by explaining how we develop it from smaller solutions. This is like saying the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I wrote a book. How? I wrote its chapters. How? I wrote the sections of each
    chapter. How? I wrote the paragraphs of each section*.'
  prefs: []
  type: TYPE_NORMAL
- en: The space complexity remains O(n). Can we improve it? Yes, via the *Tabulation*
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Tabulation (or Bottom-Up Dynamic Programming)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Tabulation*, or the *Bottom-Up*approach, is more intuitive than *Top-Down*.
    Essentially, a recursive algorithm (often) starts from the end and works backward,
    while a *Bottom-Up* algorithm starts right from the beginning. The *Bottom-Up*
    approach avoids recursion and improves space complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tabulation* is commonly referred to as a *Bottom-Up* approach. Going bottom-up
    is an approach that avoids recursion and is quite natural. It''s like saying the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I wrote the paragraphs of each section. And? And I wrote the sections of each
    chapter. And? And I wrote all the chapters. And? And I wrote a book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bottom-Up* reduces the memory cost imposed by recursion when it builds up
    the call stack, which means that *Bottom-Up* eliminates the vulnerability of getting
    stack overflow errors. This may happen if the call stack gets too large and runs
    out of space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we compute `fibonacci(k)` via the recursive approach, we
    start with *k* and continue with *k*-1, *k*-2, and so on until 0\. With the *Bottom-Up*
    approach, we start with 0 and continue with 1, 2, and so on until *k*. As shown
    in the following code, this is an iterative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime of this algorithm is still O(n), but the space complexity was brought
    down from O(n) to O(1). So, to recap the Fibonacci numbers algorithms, we have
    that the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **plain recursion** algorithm has a runtime of O(2n) and a space complexity
    of O(n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Memoization recursion** algorithm has a runtime of O(n) and a space complexity
    of O(n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **T****abulation** algorithm has a runtime of O(n) and a space complexity
    of O(1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to practice some coding challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following 15 coding challenges, we will exploit recursion and Dynamic
    Programming. These problems have been carefully crafted to help you understand
    and cover a wide range of problems from this category. By the end of this coding
    challenge session, you should be able to recognize and solve recursive problems
    in the context of an interview.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Robot grid (I)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: We have an *m* x *n* grid. A robot is placed at the top-left corner
    of this grid. The robot can only move either right or down at any point in time,
    but it is not allowed to move in certain cells. The robot''s goal is to find a
    path from the top-left corner to the bottom-right corner of the grid.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, we need to set some conventions of the *m* x *n* grid.
    Let''s assume that the bottom-right corner has the coordinates (0, 0), while the
    top-left corner has the coordinates (*m, n*), where *m* is the row and *n* is
    the column of the grid. So, the robot starts from (*m, n*) and must find a path
    to (0, 0). If we try to sketch an example for a 6x6 grid, then we can obtain something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Determining the moving pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Determining the moving pattern
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the robot can go from one cell (*m, n*) to an adjacent
    cell, which can be (*m*-1*, n*) or (*m, n*-1). For example, if the robot is placed
    at (5, 5), then it can go to (4, 5) or (5, 4). Furthermore, from (4, 5), it can
    go to (3, 5) or (4, 4), while from (5, 4), it can go to (5, 3) or (4, 4).
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a problem that can be divided into sub-problems. We must find the
    final path for the cells (the problem), which we can do if we are able to find
    the path to an adjacent cell (sub-problem). This sounds like a recursive algorithm.
    In recursion, we approach the problem from top to down, so we start from (*m,
    n*) and move back to the origin (0, 0), as shown in the preceding diagram. This
    means that from cell (*m, n*), we try to go into (*m, n*-1) or (*m*-1*, n*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into code can be done as follows (the `maze[][]` matrix is a `boolean`
    matrix that has values of `true` for cells that we are not allowed to go in –
    for example, `maze[3][1] = true` means that we are not allowed in cell (3,1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The returned path is stored as a `LinkedHashSet<Point>`. Each path contains
    *m+n* steps and there are only two valid choices we can make at each step; therefore,
    the runtime is O(2m+n). But we can reduce this runtime to O(mn) if we cache the
    cells that failed (returned `false`). This way, the *Memoization* approach saves
    the robot from trying to go in a failed cell multiple times. The complete application
    is called *RobotGridMaze*. It also contains the *Memoization* code.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular problem of using a robot is as follows. Let's say we have an
    *m* x *n* grid. A robot is placed at the top-left corner of this grid. The robot
    can only move either right or down at any point in time. The robot's goal is to
    find all the unique paths from the top-left corner to the bottom-right corner
    of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: The plain recursive solution and *Bottom-Up* approach are available in the *RobotGridAllPaths*
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Tower of Hanoi
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: This is a classical problem that can occur in an interview at
    any time. The Tower of Hanoi is a problem with three rods (*A,* *B,* and *C*)
    and *n* disks. Initially, all the disks are placed in ascending order on a single
    rod (the largest disk is on the bottom (disk *n*), a smaller one sitting on it
    (*n*-1), and so on (*n*-2*, n*-3*, ...*) until the smallest disk is on the top
    (disk 1). The aim is to move all the disks from this rod to another rod while
    respecting the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one disk can be moved at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move means to slide the upper disk from one rod to another rod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A disk cannot be placed on top of a smaller disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Trying to solve such problems means that we need to visualize
    some cases. Let''s consider that we want to move the disks from rod *A* to rod
    *C*. Now, let''s put *n* disks on rod *A*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For *n=*1: Having a single disk, we need to move one disk from rod *A* to *C*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For *n=*2: We know how to move a single disk. To move two, we need to complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move disk 1 from *A* to *B* (rod *B* acts as an intermediate for disk 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 2 from *A* to *C* (disk 2 goes directly in its final place).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 1 from *B* to *C* (disk 1 can be moved on top of disk 2 on rod *C*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *n=*3: Let''s get some help from the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Tower of Hanoi (three disks)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Tower of Hanoi (three disks)
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to *n=*2, we know how to move the top two disks from *A* (origin) to *C*
    (target). In other words, we know how to move the top two disks from one rod to
    another rod. Let''s move them from *A* to *B*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Move disk 1 from *A* to *C* (this time, we use *C* as the intermediate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 2 from *A* to *B.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 1 from *C* to *B.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK, so this is something that we''ve done before. Next, we can move disks 2
    and 3 onto *C*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Move disk 3 from *A* to *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 1 from *B* to *A* (we use *A* as the intermediate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move disk 2 from *B* to *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, move disk 3 from *A* to *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continuing with this logic, we can intuit that we can move four disks because
    we know how to move three, we can move five disks because we know how to move
    four, and so on. With rod *A* as the origin, rod *B* as the intermediate, and
    rod *C* as the target, we can conclude that we can move *n* disks by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the top *n* - 1 disks from the origin to the intermediate, using the target
    as an intermediate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the top *n* - 1 disks from the intermediate to the target, using the origin
    as an intermediate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, it is clear that we have a problem that can be divided into
    sub-problems. Based on the preceding two bullets, we can code this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *HanoiTowers*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Josephus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon, Google, Adobe, Microsoft, Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a group of *n* men arranged in a circle (1, 2, 3, ...,
    *n*). Every *k*th man will be killed around the circle until only one survivor
    remains. Write an algorithm that finds the *k* position of this survivor. This
    is known as the Josephus problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Remember that we had a note previously saying that when a problem
    contains the words *compute the n*thand similar expressions, then it is possibly
    a good candidate for being solved via recursion. Here, we have *find the k position*,
    which is a problem that can be divided into sub-problems and be solved via recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider *n*=15 and *k*=3\. So, there are 15 men and every third man
    will be eliminated from the circle until only one remains. Let''s visualize this
    via the following diagram (this is very useful for figuring out the pattern of
    killings):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Josephus for n=15 and k=3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Josephus for n=15 and k=3
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have five rounds until we find the survivor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Round 1: The first elimination is position 3; next, 6, 9, 12, and 15 are eliminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 2: The first elimination is position 4 (1 and 2 are skipped, since position
    15 was the last eliminated in round 1); next, 8 and 13 are eliminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 3: The first elimination is position 2 (14 and 1 are skipped, since position
    13 was the last eliminated in round 2); next, 10 and 1 are eliminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 4: The first elimination position is 11, followed by position 7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 5: 14 is eliminated and 5 is the survivor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trying to identify a pattern or a recursive call can be done based on the following
    observations. After the first man (*k*th) is eliminated, *n*-1 men are left. This
    means that we call `josephus(n – 1, k)` to get the position of the *n*-1th man.
    However, notice that the position returned by `josephus(n – 1, k)` will take into
    account the position starting from *k%n* + 1\. In other words, we have to adjust
    the position returned by `josephus(n – 1, k)` to obtain (`josephus(n - 1, k) +
    k - 1) % n + 1`. The recursive method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find this approach quite tricky, then you can try an iterative approach
    based on a queue. First, fill up the queue with *n* men. Next, loop the queue
    and, for each man, retrieve and remove the head of this queue (`poll()`). If the
    retrieved man is not the *k*th, then insert this man back in the queue (`add()`).
    If this is the *k*th man, then break the loop and repeat this process until the
    queue''s size is 1\. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Josephus*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Color spots
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an *r* x *c* grid where *r* stands for rows and *c* stands
    for columns. Each cell has a color represented by a number *k* (for example, for
    three colors, *k*=3). We define the connected set of a cell (or a color spot)
    as the total cells in which we can go from the respective cell by successive displacements
    on the row or the column, thus keeping the color. The goal is to determine the
    color and the number of cells of the maximum connected set. In other words, we
    need to determine the biggest color spot.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider a 5x5 grid and three colors, where we have *r=c=*5
    and *k=*3\. Next, let''s represent the grid as shown in the following diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on image (a). Here, we can see that moving from a cell to another
    cell can be done in a maximum of four directions (up, down, left, and right).
    This means that, from a cell (*r,c*), we can try to go to (*r*-1, *c*), (*r*+1,
    *c*), (*r*, *c*-1), and (*r*, *c*+1). We cannot perform a move if we risk falling
    from the grid or the targeted cell has another color than the current cell. So,
    by iterating each cell ((0, 0), (0, 1), ... (*r*, *c*)), we can determine the
    size of the connected set of that cell (the size of the color spot) by visiting
    each allowed cell and counting it. In image (a), we have four spots that are color
    1 whose sizes are 1, 1, 1, and 2\. We also have six spots that are color 2 whose
    sizes are 1, 1, 2, 1, 1, and 1\. Finally, we have three spots that are color 3
    whose sizes are 11, 1, and 1\.
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can conclude that the biggest color spot has a size of 11 and
    a color of 3\. Mainly, we can consider that the color spot of the first cell is
    the maximum spot and that each time we find a color spot bigger than this one,
    we replace this one with the one we found.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus on image (b). Why do we have negative values? Because when
    we visit a cell, we switch its *color* value to *-color*. This is a convenient
    convention that's used to avoid computing the same connected set of a cell multiple
    times. It is like saying that we mark this cell as visited. By convention, we
    cannot move in a cell that has a negative value for a color, so we will not compute
    the size of the same color spot twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, gluing these observations together to make a recursive method leads to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While the preceding recursive method, `computeColorSpot()`, can compute the
    size of a color spot, starting from the given cell, the following method determines
    the biggest color spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BiggestColorSpot*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Coins
  prefs: []
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an amount of *n* cents. Count the ways you can change
    this amount using any number of quarters (25 cents), dimes (10 cents), nickels
    (5 cents), and pennies (1 cent).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s imagine that we have to change 50 cents. Right from the
    start, we can see that changing 50 cents is a problem that can be solved via sub-problems.
    For example, we can change 50 cents using 0, 1, or 2 quarters. Or we can do it
    using 0, 1, 2, 3, 4, or 5 dimes. We can also do it using 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, or 10 nickels. Finally, we can do it using 0, 1, 2, 3, ..., 50 pennies.
    Let''s assume that we have 1 quarter, 1 dime, 2 nickels, and 5 pennies. We can
    use our quarter to say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(50) = 1 quarters + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is like saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(25) = 0 quarters + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have more quarters; therefore, we add a dime:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(25) = 0 quarters + 1 dimes + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be reduced, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have any more dimes. We add the nickels:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + 2 nickel + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since we don''t have more nickels, we add the pennies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + 5 pennies**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*calculateChange***(0) = 0 quarters + 0 dimes + 0 nickel + 0 pennies**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to represent all the possible reductions, we obtain the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this reducible algorithm can be done via recursion, as shown in
    the following code. Notice that we are using *Memoization* to avoid changing the
    same amount multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Coins*. It also contains the plain recursive
    approach (without *Memoization*).
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Five towers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider a 5x5 grid with five defensive towers spread across the
    grid. To provide an optimal defense for the grid, we have to build a tower on
    each row of the grid. Find all the solutions for building these towers so that
    none of them share the same column and diagonal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We know that, on each row, we must build a tower and that it
    is not important in what order we build them on the grid. Let''s sketch a solution
    and a failure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9(a) – Failure and solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9(a)_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9(a) – Failure and solution
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the solution and start from the first row: row 0\. We can build
    a tower on this row in any column; therefore, we can say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9(b): Part 1 of the logic to build the towers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9(b)_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9(b): Part 1 of the logic to build the towers'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we continue with the same logic, then we can say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9(c): Part 2 of the logic to build the towers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9(c)_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9(c): Part 2 of the logic to build the towers'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we start from the first row and build the first tower on (0,0). We go to
    the second row and try to build the second tower so that we don''t share the column
    or diagonal with the first tower. We go to the third row and try to build the
    third tower so that we don''t share the column or diagonal with the first two
    towers. We follow the same logic for the fourth and fifth towers. This is our
    solution. Now, we repeat this logic – we build the first tower at (0,1) and continue
    building until we find the second solution. Next, we build the first tower at
    (0, 2), (0, 3) and finally at (0,4) while we repeat the process. We can write
    this recursive algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *FiveTowers*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Magic index
  prefs: []
  type: TYPE_NORMAL
- en: '**Adobe, Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a sorted array of *n* elements that allows duplicates.
    An index *k* is magic if *array*[*k*] = *k*. Write a recursive algorithm that
    finds the first magic index.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, let''s quickly draw two sorted arrays containing 18 elements,
    as shown in the following diagram. The array at the top of the image contains
    no duplicates, while the array at the bottom contains duplicates. This way, we
    can observe the influence of these duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Sorted array of 18 elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Sorted array of 18 elements
  prefs: []
  type: TYPE_NORMAL
- en: If we halve the array with no duplicates, then we can conclude that the magic
    index must be on the right-hand side because *array*[8] < 8\. This is true since
    the magic index is 11, so *array*[11] = 11.
  prefs: []
  type: TYPE_NORMAL
- en: If we halve the array with duplicates, we cannot get the same conclusion we
    received previously. The magic index can be on both sides. Here, we have *array*[5]
    = 5 and *array*[12] = 12\. We must find the first magic index, so we should search
    the left-hand side first.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we find it? The most obvious approach consists of looping the array
    and checking if *array*[*i*] = *i*. While this works for any ordered array, it
    will not impress the interviewer since it is not recursive, so we need another
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*, Big O Analysis
    of Algorithms*, you saw an example of searching in a sorted array via the Binary
    Search algorithm. This algorithm can be implemented via recursion since, at each
    step, we halve the previous array and create a sub-problem. Since the indexes
    of an array are ordered, we can adapt the Binary Search algorithm. The main issue
    that we face is that duplicated elements complicate the search. When we halve
    the array, we cannot say that the magic index is on the left or the right, so
    we have to search in both directions, as shown in the following code (first, we
    search the left-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MagicIndex*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – The falling ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider an *m* x *n* grid where each (*m, n*) cell has an elevation
    represented by a number between 1 and 5 (5 is the highest elevation). A ball is
    placed in a cell of the grid. This ball can fall into another cell, as long as
    that cell has a smaller elevation than the ball cell. The ball can fall in four
    directions: north, west, east, and south. Display the initial grid, as well as
    the grid after the ball falls on all possible paths. Mark the paths with 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Always pay attention to the problem requests. Notice that we
    must display the solved grid, not list the paths or count them. The easiest way
    to display a grid is to use two loops, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s sketch a 5x5 grid and view an input and its output. The following
    image shows the initial grid in the form of a 3D model, along with a possible
    path and the solved grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The falling ball'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – The falling ball
  prefs: []
  type: TYPE_NORMAL
- en: 'I think we have enough experience to intuit that this problem can be solved
    via recursion. Mainly, we move the ball in all acceptable directions and mark
    each visited cell with 0\. When we have the ball in the (*i, j*) cell, we can
    go in (*i*-1*, j*), (*i+*1*, j*), (*i, j*-1), and (*i, j+*1) directions, as long
    those cells have smaller elevations. In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *TheFallingBall*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – The highest colored tower
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider *n* boxes of different widths (*w*1...n), heights (*h*1...n),
    and colors (*c*1...n). Find the highest tower of boxes that respects the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot rotate the boxes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot place two successive boxes of the same color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each box is strictly larger than the box above it in terms of their width and
    height.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Let''s try to visualize this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12(a) – The highest colored tower'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12(a) – The highest colored tower
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seven boxes of different sizes and colors. We can imagine that the
    highest tower will contain all these boxes, *b*1...*b*7\. But we have several
    constraints that don''t allow us to simply stack the boxes. We can choose one
    of the boxes as the base box and place another allowed box on top of it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12(b) The logic to select the boxes to build the highest tower'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12(b)_The_logic_to_select_the_boxes_to_build_the_highest_tower.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12(b) The logic to select the boxes to build the highest tower
  prefs: []
  type: TYPE_NORMAL
- en: So, we identified a pattern. We choose a box as the base, and we try to see
    which of the remaining boxes can go on top as the second level. We do the same
    for the third level and so on. When we are done (we cannot add more boxes or no
    boxes are left), we store the size of the highest tower. Next, we repeat this
    scenario with another base box.
  prefs: []
  type: TYPE_NORMAL
- en: Since every box must be larger in terms of width and height than the box above
    it, we can sort the boxes by width or height in descending order (it is not important
    which one we choose). This way, for any tower of *b*0*,...b*k*, k < n* boxes,
    we can find the next valid box by searching the *b*k+1...*n* interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we can avoid recalculating the best solution for the same base box
    by caching the best solutions via *Memoization*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *HighestColoredTower*. The code also contains
    the plain recursion approach to this problem (without *Memoization*).
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – String permutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Write an algorithm that computes all the permutations of a string
    and accommodates the following two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The given string can contain duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned list of permutations should not contain duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Like in any recursive problem, the key consists of recognizing
    the relationship and patterns between the different sub-problems. Right away,
    we can intuit that permuting a string with duplicates should be more complicated
    than permuting a string with unique characters. This means that we must understand
    the permutations of a string with unique characters first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most natural way of permuting the characters of a string can follow a simple
    pattern: each character of the string will become the first character of the string
    (swap their positions) and then permute all the remaining letters using a recursive
    call. Let''s delve into the general case. For a string containing a single character,
    we have a single permutation:'
  prefs: []
  type: TYPE_NORMAL
- en: P(*c*1) = *c*1
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another character, then we can express the permutations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: P(*c*1*c*2) = *c*1*c*2 and *c*2*c*1
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another character, then we must express the permutations using *c*1*c*2\.
    Each permutation of *c*1*c*2*c*3 represents an ordering of *c*1*c*2, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*1*c*2 -> *c*1*c*2*c*3,*c*1*c*3*c*2,*c*3*c*1*c*2'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*2*c*1 -> *c*2*c*1*c*3,*c*2*c*3*c*1,*c*3*c*2*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace *c*1*c*2*c*3 with ABC. Next, we represent P(ABC) as a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Permuting ABC'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Permuting ABC
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another character, then we must express the permutations using *c*1*c*2*c*3*c*4\.
    Each permutation of *c*1*c*2*c*3*c*4 represents an ordering of *c*1*c*2*c*3, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*1*c*2*c*3 -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*4*c*2*c*3,*c*4*c*1*c*2*c*3'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*1*c*3*c*2 -> *c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*3*c*2,*c*4*c*1*c*3*c*2'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*3*c*1*c*2 -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*4*c*1*c*2,*c*4*c*3*c*1*c*2'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*2c1*c*3 -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*4*c*1*c*3,*c*4*c*2*c*1*c*3'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*2*c*3*c*1 -> *c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*3*c*1,*c*4*c*2*c*3*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*3*c*2*c*1 -> *c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*2*c*1,*c*4*c*3*c*2*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: We can continue like this forever, but I think it is quite clear what pattern
    can be used for generating *P*(*c*1, *c*2, ..., *c*n).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is the right moment to take our logic a step further. Now, it is time
    to ask the following questions: if we know how to compute all the permutations
    for strings of *k*-1 characters (*c*1*c*2...*c*k-1), then how we can use this
    information to compute all the permutations for strings of *k* characters (*c*1*c*2...*c*k-1*c*k)?
    For example, if we know how to compute all the permutations for the *c*1*c*2*c*3
    string, then how we can express all the permutations of the *c*1*c*2*c*3*c*4 string
    using *c*1*c*2*c*3 permutations? The answer is to take each character from the
    *c*1*c*2...*c*k string and append the *c*1*c*2...*c*k-1 permutation to it, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: P(*c*1*c*2*c*3*c*4) = [*c*1 + P(*c*2*c*3*c*4)] + [*c*2 + P(*c*1*c*3*c*4)] +
    [*c*3 + P(*c*1*c*2*c*4)] + [*c*4 + P(*c*1*c*2*c*3)]
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*1 + P(*c*2*c*3*c*4)] -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*2*c*3,*c*1*c*4*c*3*c*2'
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*2 + P(*c*1*c*3*c*4)] -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*1*c*3,*c*2*c*4*c*3*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*3 + P(*c*1*c*2*c*4)] -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*1*c*2,*c*3*c*4*c*2*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*4 + P(*c*1*c*2*c*3)] -> *c*4*c*1*c*2*c*3,*c*4*c*1*c*3*c*2,*c*4*c*2*c*1*c*3,*c*4*c*2*c*3*c*1,*c*4*c*3*c*1*c*2,*c*4*c*3*c*2*c*1'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue to add another character and repeat this logic so that we have
    a recursive pattern that can be expressed in terms of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code will work fine. Because we use a `Set` (not a `List`), we respect
    the requirement stating that *the returned list of permutations should not contain
    duplicates*. However, we do generate duplicates. For example, if the given string
    is *aaa*, then we generate six identical permutations, even if there is only one.
    The only difference is that they are not added to the result since a `Set` doesn't
    accept duplicates. This is far from being efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid generating duplicates in several ways. One approach starts by
    counting the characters of a string and storing them in a map. For example, for
    the given string *abcabcaa*,the key-value map can be *a*=4, *b*=2, and *c*=2\.
    We can do this via a simple helper method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we choose one of these characters as the first character and find all
    the permutations of the remaining characters. We can express this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*2*,c=*2) *=* [*a +* P(*a=*3*,b=*2*,c=*2)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*1)]
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*3*,b=*2*,c=*2) *=* [*a +* P(*a=*2*,b=*2*,c=*2)] *+* [*b +* P(*a=*3*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*3*,b=*2*,c=*1)]
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*1*,c=*1*) =* [*a +* P(*a=*3*,b=*1*,c=*1)] *+* [*b +* P(*a=*4*,b=*0*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*1*,c=*0)]
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*2*,c=*1*) =* [*a +* P(*a=*3*,b=*2*,c=*1)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*0)]
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*2*,b=*2*,c=*2) *=* [*a +* P(*a=*1*,b=*2*,c=*2)] *+* [*b +* P(*a=*2*,b=*1*,c=*2)]
    *+* [*c +* P(*a=*2*,b=*2*,c=*1)]
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*3*,b=*1*,c=*1) *= ...*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue writing until there are no remaining characters. Now, it should
    be quite simple to put this into lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Permutations*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Knight tour
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a chessboard (an 8x8 grid). Place a knight on this board
    and print all its unique movements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As you''ve already seen, the best way to tackle such problems
    is to take a piece of paper and a pen and sketch the scenario. A picture is worth
    a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Knight tour'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Knight tour
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, a knight can move from a (*r*, *c*) cell into a maximum of eight
    other valid cells; that is, (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1,*c*+2), (*r*-2,
    *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1). So,
    in order to obtain the path from 1 to 64 (as shown in the right-hand side of the
    preceding diagram), we can start from a given location and recursively try to
    visit each valid movement. If the current path doesn't represent a solution or
    we've tried all eight cells, then we backtrack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be as efficient as possible, we consider the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from a corner of the chessboard: This way, the knight can initially
    go in only two directions instead of eight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We check for valid cells in a fixed sequence: Maintaining a circular path will
    help us find a new move faster than picking one randomly. The counterclockwise
    circular path from (*r*, *c*) is (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1, *c*+2),
    (*r*-2, *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We compute the circular path using two arrays: We can move from (*r*, *c*)
    to (*r* + *ROW*[*i*]*,c + COL*[*i*]) with *i* in [0, 7]:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*COL*[] = {1,2,2,1,-1,-2,-2,-1,1};'
  prefs: []
  type: TYPE_NORMAL
- en: '*ROW*[] = {2,1,-1,-2,-2,-1,1,2,2};'
  prefs: []
  type: TYPE_NORMAL
- en: We avoid cycles in paths and duplicate work (for example, visiting the same
    cell multiple times) by storing the visited cells in an *r* x *c* matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By gluing everything together in terms of code, we obtain the following recursive
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *KnightTour*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Curly braces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Print all the valid combinations of *n* pairs of curly braces.
    A valid combination is when the curly braces are properly opened and closed. For
    *n*=3, the valid combinations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '{{{}}},{{}{}},{{}}{},{}{{}},{}{}{}'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The valid combination for *n*=1 is {}.'
  prefs: []
  type: TYPE_NORMAL
- en: For *n=2*, we immediately see the combination as {}{}. However, another combination
    consists of adding a pair of curly braces to the previous combination; that is,
    {{}}.
  prefs: []
  type: TYPE_NORMAL
- en: Going one step further, for *n*=3, we have the trivial combination {}{}{}. Following
    the same logic, we can add a pair of curly braces to combinations for *n*=2, so
    we obtain {{{}}}, {{}}{}, {}{{}}, {{}{}}.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, this is what we obtain after we remove or ignore duplicates. Let''s
    sketch the case for the *n*=3 build based on *n*=2, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Curly braces duplicate pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Curly braces duplicate pairs
  prefs: []
  type: TYPE_NORMAL
- en: So, if we add a pair of curly braces inside each existing pair of curly braces
    and we add the trivial case ({}{}...{}) as well, then we obtain a pattern that
    can be implemented via recursion. However, we have to deal with a significant
    number of duplicate pairs, so we need additional checks to avoid having duplicates
    in the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s consider another approach, starting with a simple observation. For
    any given *n*, a combination will have 2**n* curly braces (not pairs!). For example,
    for *n*=3, we have six curly braces (three left curly braces ({{{) and three right
    curly braces (}}})) arranged in different, valid combinations. This means that
    we can try to build the solution by starting with zero curly braces and add left/right
    curly braces to it, as long as we have a valid expression. Of course, we keep
    track of the number of added curly braces so that we don''t exceed the maximum
    number, 2**n.* The rules that we must follow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add all left curly braces in a recursive manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the right curly braces in a recursive manner, as long as the number of
    right curly braces doesn't exceed the number of left curly braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, the key to this approach is to track the number of left and
    right curly braces that are allowed. As long as we have left curly braces, we
    insert a left curly brace and call the method again (recursion). If there are
    more right curly braces remaining than there are left curly braces, then we insert
    a right curly brace and call the method (recursion). So, let''s get coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Braces*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Staircase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: A person walks up a staircase. They can hop either one step, two
    steps, or three steps at a time. Count the number of possible ways they can reach
    the top of the staircase.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, let''s set what hopping one, two, or three steps means.
    Consider that hopping one step means to go up the staircase step by step (we land
    on each step). To hop two steps means to jump over a step and land on the next
    one. Finally, to hop three steps means to jump over two steps and land on the
    third one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we consider a staircase with three steps, then we can go from
    step 0 (or, no step) to step 3 in four ways: step by step (we land on each step),
    we jump over step 1 and land on step 2 and walk on step 3, we walk on step 1 and
    jump over step 2, thereby landing on step 3, or we jump directly on step 3, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Staircase (how to reach step 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Staircase (how to reach step 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'By going one step further in our logic, we may ask ourselves how to reach step
    *n*. Mainly, the *n*th step can be reached if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n*-1 step and hop 1 step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n*-2 step and hop 2 steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n*-3 step and hop 3 steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, reaching any of these steps – *n-*1, *n-*2, or *n-*3 – is possible
    if we follow the preceding bullets. For example, we can reach the *n-*1 step if
    we are on *n-*2 and hop 1 step, we are on *n-*3step and hop 2 steps, or we are
    on *n-*4 step and hop 3 steps.
  prefs: []
  type: TYPE_NORMAL
- en: So, to reach the *n*th step, we have three possible paths. To reach step *n*-1th,
    we also have three possible paths. So, to reach both steps, we must have 3+3=6
    paths. Do not say 3*3=9 paths! This is wrong!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can conclude that adding all the paths in a recursive manner should
    give us the expected answers. Moreover, we can use our experience to add *Memoization*
    as well. This way, we avoid calling the method with the same inputs many times
    (exactly as in the case of the Fibonacci numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Staircase*. It also contains the plain recursion
    approach (without *Memoization*).
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Subset sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given set (*arr*) of positive integers and a value,
    *s*. Write a snippet of code that finds out if there is a subset in this array
    whose sum is equal to the given *s*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the array, *arr* = {3, 2, 7, 4, 5, 1, 6, 7, 9}.
    If *s*=7, then a subset can contain the elements 2, 4, and 1, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Subset of sum 7'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Subset of sum 7
  prefs: []
  type: TYPE_NORMAL
- en: The subset containing the elements 2, 4, and 1 is just one of the possible subsets.
    All possible subsets include (3, 4), (2, 4, 1), (2, 5), (7), (1, 6), and (7).
  prefs: []
  type: TYPE_NORMAL
- en: Recursive approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try to find a solution via recursion. If we add the subset *arr*[0]=3,
    then we have to find the subset for *s* = *s-arr*[0] = 7-3 = 4\. Finding a subset
    for *s*=4 is a sub-problem that can be solved based on the same logic, which means
    we can add *arr*[1]=2 in the subset, and the next sub-problem will consist of
    finding the subset for *s* = *s*-*arr*[1] = 4-2 = 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can think like this: start with *sum*=0\. We add *arr*[0]=3
    to this *sum* as *sum*=*sum+arr*[0] = 3\. Next, we check if *sum* = *s* (for example,
    if 3 = 7). If so, we found a subset. If not, we add the next element, *arr*[1]=2,
    to the *sum* as *sum = sum+arr*[1] = 3+2 =5\. We recursively continue to repeat
    this process until there are no more elements to add. At this point, we recursively
    remove elements from *sum* and check if *sum = s* upon each removal. In other
    words, we build every possible subset and check if its *sum* is equal to *s*.
    When we have this equality, we print the current subset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it is clear that if we recursively solve each and every sub-problem,
    then it will lead us to the result. For each element from *arr* we must make a
    decision. Mainly, we have two options: include the current element in the subset
    or not include it. Starting from these statements, we can create the following
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a subset as an array of the same length as the given *arr*. This array
    takes only values of 1 and 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively add each element from *arr* to the subset by setting a value of
    1 at that particular index. Check for the solution (*current sum = given sum)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively remove each element from the subset by setting a value of 0 at that
    particular index. Check for the solution (*current sum = given sum*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of this code is O(n2n), so it's far from being efficient.
    Now, let's try an iterative approach via Dynamic Programming. This way, we avoid
    solving the same problem repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Programming approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Via Dynamic Programming, we can solve this problem in O(s*n). More precisely,
    we can rely on the *Bottom-Up* approach and a `boolean` bidimensional matrix of
    dimension (*n*+1) x (*s*+1), where *n* is the size of the set (*arr*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this implementation, you have to understand how this matrix is
    filled up and how it is read. If we consider that the given *arr* is {5, 1, 6,
    10, 7, 11, 2} and *s*=9, then this `boolean` matrix starts from an initial state,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Initial matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Initial matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have *s*+1 = 9+1 = 10 columns and *n*+1 = 7+1 = 8 rows. As you can see,
    we have filled up row and column 0\. These are the *base cases* and can be interpreted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the first row (row 0) of the matrix (*matrix*[0][]) with 0 (or `false`,
    F) except *matrix*[0][0], which is initialized with 1 (or `true`, T). In other
    words, if the given sum is not 0, then there is no subset to satisfy this sum.
    However, if the given sum is 0, then there is a subset containing only 0\. So,
    the subset containing a 0 can form a single sum equal to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the first column (column 0) of matrix (*matrix*[][0]) with 1 (or
    `true`, T) because, for any set, a subset is possible with 0 sum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we take each row (5, 1, 6, ...) and we try to fill it up with F or T.
    Let''s consider the second row, which contains the element 5\. Now, for each column,
    let''s answer the following question: can we form a sum of *column number* with
    a 5? Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Filling up the second row'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Filling up the second row
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 1 with a 5? No, so false (F).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we form a sum of 2 with a 5? No, so false (F).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 5 with a 5? Yes, so true (T).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we form a sum of 6 with a 5? No, so false (F).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 9 with a 5? No, so false (F).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can try to apply this question to each of the remaining rows, but the more
    we advance, the harder it will be. Moreover, we cannot implement this question
    in code without an algorithm. Fortunately, we can employ an algorithm that can
    be applied to each (*row, column*) cell. This algorithm contains the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: While the element of the current row (*i*) is greater than the value of the
    current column (*j*), we just copy the preceding value (*i*-1, *j*), in the current
    (*i, j*) cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the element of the current row (*i*) is smaller than or equal to the value
    of the current column (*j*), then we look to the (*i*-1, *j*) cell and do the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If cell (*i*-1, *j*) is T, then we fill up the (*i, j*) cell with T as well.
  prefs: []
  type: TYPE_NORMAL
- en: b. If cell (*i*-1, *j*) is F, then we fill up the (*i, j*) cell with the value
    at (*i*-1, *j-element_at_this_row*).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to the second row (containing the element 5), then
    we obtain the same result shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Applying the algorithm to the second row'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Applying the algorithm to the second row
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to *step 1*, for 5 < 1, 5 < 2, 5 < 3, and 5 < 4, we copy the value
    from the preceding cell. When we reach cell (1, 5), we have 5=5, so we need to
    apply *step 2*. More precisely, we apply *step 2b*. The cell (1-1, 5-5) is the
    cell (0, 0) that has the value T. So, the cell (1, 5) is filled up with T. The
    same logic applies to the remaining cells. For example, cell (1, 6) is filled
    up with F since F is the value at (0, 5); the cell at (1, 7) is filled up with
    F since F is the value at (0, 6), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to all the rows, then we obtain the following filled
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Complete matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Complete matrix
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we highlighted the last cell at (7, 9). If the right-bottom cell
    has the value T, then we say that there is at least a subset that satisfies the
    given sum. If it is F, then there is no such subset.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this case, there is a subset whose sum is equal to 9\. Can we identify
    it? Yes, we can, via the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the right-bottom cell, which is T (let's say that this cell is at
    (*i*, *j*)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the cell above this one, (*i*-1, *j*), is F, then write down the element
    at this row (this element is part of the subset) and go to cell (*i*-1, *j*-*element_at_this_row*).
  prefs: []
  type: TYPE_NORMAL
- en: b. While the cell above this one, (*i*-1, *j*), is T, we go up the cell (*i*-1,
    *j*).
  prefs: []
  type: TYPE_NORMAL
- en: c. Repeat this from *step 1a* until the entire subset is written down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' s draw the path of the subset in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Subset solution path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Subset solution path
  prefs: []
  type: TYPE_NORMAL
- en: So, we start from the bottom-right cell, which is at (7, 9) and has the value
    T. Because this cell is T, we can attempt to find the subset that has the sum
    9\. Next, we apply *step 1a*, so we write down the element at row 7 (which is
    2) and go to cell (7-1, 9-2) = (6, 7). So far, the subset is {2}.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply *step 1b*, so we land in cell (3, 7). The cell above (3, 7) has
    the value F, so we apply *step 1a*. First, we write down the element at row 3,
    which is 6\. Then, we go to cell (3-1, 7-6) = (2, 1). So far, the subset is {2,
    6}.
  prefs: []
  type: TYPE_NORMAL
- en: The cell above (2, 1) has the value F, so we apply *step 1a*. First, we write
    down the element at row 2, which is 1\. Then, we go to cell (2-1, 1-1) = (1, 0).
    Above cell (1,0), we have only T, so we stop. The current and final subset is
    {2, 6, 1}. Obviously, 2+6+1 = 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will clarify any other details (this code can tell if the
    given sum at least has a corresponding subset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `printSubsetMatrix()` and `printOneSubset()` methods can be found in the
    complete code named *SubsetSum*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Word break (this is a famous Google problem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the given string (*str*) can be segmented into a space-separated
    sequence of dictionary words.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem is common to Google and Amazon and at the time of
    writing, it is adopted by a lot of medium-large companies. If we type a string
    that doesn''t make sense into Google, then Google attempts to break it down into
    words and asks us if that is what we actually tried to type. For example, if we
    type "thisisafamousproblem", then Google will ask us if we wanted to type "this
    is a famous problem".'
  prefs: []
  type: TYPE_NORMAL
- en: Plain recursion-based solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, if we assume that the given string is *str*`="`thisisafamousproblem" and
    the given dictionary is `{`"this" "is" "a" "famous" "problem"`}`, then we can
    form the result; that is,"this is a famous problem".
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we obtain this? How can we check if the given string can be segmented
    into a space-separated sequence of dictionary words?
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an observation. If we start from the first character of the
    given string, then we notice that "t" is not a word in the given dictionary. We
    can continue by appending the second character to "t", so we get "th". Since "th"
    is not a word in the given dictionary, we can append the third character, "i".
    Obviously, "thi" is not a word in the dictionary, so we append the fourth character,
    "s". This time, we found a word because "this" is a word in the dictionary. This
    word becomes part of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this logic further, if we found "this", then the initial problem is reduced
    to a smaller problem that consists of finding the remaining words. So, by appending
    every character, the problem reduces to a smaller problem but essentially remains
    the same. This sounds like an ideal case for a recursive implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we elaborate on the recursive algorithm, then we have the following steps
    that we must perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the given string, *str*, from the first character (*index* 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take each substring from the given string (by substring, we understand substring
    from *index* to 1, substring from *index* to 2, ...substring from *index* to *str.length*).
    In other words, as long as the current substring is not a word in the given dictionary,
    we continue to add a character from the given string, *str*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current substring is a word in the given dictionary, then we update the
    index so that it's the length of this substring and rely on recursion by checking
    the remaining string from *index* to *str.length*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *index* reaches the length of the string, we return `true`; otherwise, we
    return `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is no surprise that the runtime of this code is exponential. Now, it is
    time to deploy Dynamic Programming.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can avoid recursion and deploy Dynamic Programming instead. More precisely,
    we can use the *Bottom-Up* solution shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code still runs in exponential time O(n2).
  prefs: []
  type: TYPE_NORMAL
- en: Trie-based solution
  prefs: []
  type: TYPE_NORMAL
- en: 'The most efficient solution to solve this problem relies on Dynamic Programming
    and the Trie data structure since it provides the best time complexity. You can
    find a detailed implementation of the Trie data structure in the book *Java Coding
    Problems*: ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the problem of breaking a given string into a set of components
    representing its words. If *p* is a prefix of *str* and *q* is the suffix of *str*
    (the remaining characters), then *pq* is *str* (the concatenation of *p* with
    *q* is *str*). And, if we can break *p* and *q* into words via recursion, then
    we can break *pq = str* by merging the two sets of words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue this logic in the context of a Trie representing the given
    dictionary of words. We can assume that *p* is a word from the dictionary, and
    we must find a way to construct it. This is exactly where the Trie comes in. Because
    *p* is considered a word from the dictionary and *p* is a prefix of *str*, we
    can say that *p* must be found in the Trie via a path consisting of the first
    few letters of *str*. To accomplish this via Dynamic Programming, we use an array,
    let''s denote it as *table*. Every time we find an appropriate *q*, we signal
    it in the *table* array by setting a solution at |*p*| + 1, where |*p*| is the
    length of the prefix, *p*. This means that we can continue by checking the last
    entry to determine if the whole string can be broken up. Let''s see the code for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, because we have two nested loops, the runtime of this solution is
    O(n2). Actually, the inner loop breaks if the node is `null`. And, in the worst-case
    scenario, this happens after *k* steps, where *k* is the deepest path in the Trie.
    So, for a dictionary that contains the longest word of size *z*, we have *k*=*z*+1\.
    This means that the time complexity of the inner loop is O(z) and that the total
    time complexity is O(nz). The extra space is O(*space of the Trie + str.length*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete application is called *WordBreak*. This application also contains
    a method that prints all the strings that can be generated for the given string.
    For example, if the given string is "thisisafamousproblem" and the dictionary
    is `{"`this", "th", "is", "a", "famous", "f", "a", "m", "o", "u", "s", "problem"`}`,
    then the output will contain four sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: th is is a f a m o u s problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: th is is a famous problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this is a f a m o u s problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this is a famous problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Done! Now, it's time to summarize this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered one of the most popular topics in interviews: recursion
    and Dynamic Programming. Mastering this topic requires a lot of practice. Fortunately,
    this chapter provided a comprehensive set of problems that covered the most common
    recursive patterns. From permutations to grid-based problems, from classical problems
    such as Tower of Hanoi to tricky problems such as generating curly braces, this
    chapter has covered a wide range of recursive cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that the key to solving recursive problems consists of drawing
    a meaningful sketch and practicing several cases. This way, you can identify patterns
    and recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss problems that require bit manipulation.
  prefs: []
  type: TYPE_NORMAL
