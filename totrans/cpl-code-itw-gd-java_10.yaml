- en: '*Chapter 8*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第8章*：'
- en: Recursion and Dynamic Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归和动态规划
- en: 'This chapter covers one of the favorite topics of interviewers: Recursion and
    Dynamic Programming. Both work hand in hand, so you must be able to cover both.
    Commonly, the interviewer expects to see a plain recursive solution. However,
    they may ask you to provide some optimization hints or even to code an optimized
    version of your code. In other words, your interviewer will want to see Dynamic
    Programming at work.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了面试官最喜欢的主题之一：递归和动态规划。两者密切相关，因此您必须能够同时掌握两者。通常，面试官希望看到纯递归解决方案。但是，他们可能要求您提供一些优化提示，甚至编写代码的优化版本。换句话说，您的面试官希望看到动态规划的工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Recursion in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，递归
- en: Dynamic Programming in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，动态规划
- en: Coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: 'By the end of this chapter, you will be able to implement a wide range of recursive
    algorithms. You''ll have a significant number of recursive patterns and approaches
    you can use to recognize and implement recursive algorithms in minutes in your
    toolbelt. Let''s start with the first topic of our agenda: recursion.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够实现各种递归算法。您将拥有大量递归模式和方法，可以在几分钟内识别和实现递归算法。让我们从我们议程的第一个主题开始：递归。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code presented in this chapter on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中提供的所有代码[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter08)。
- en: Recursion in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，递归
- en: 'A method that calls itself directly/indirectly is called recursion. This method
    is known as a recursive method. The famous Fibonacci numbers problem can be implemented
    recursively, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直接/间接调用自身的方法称为递归。这种方法称为递归方法。著名的斐波那契数问题可以按照以下方式进行递归实现：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two important parts in this code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有两个重要部分：
- en: '**Base case**: Returns a value without subsequent recursive calls. For special
    input(s), the function can be evaluated without recursion.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本情况**：在没有后续递归调用的情况下返回一个值。对于特殊的输入，函数可以在没有递归的情况下进行评估。'
- en: '`fibonacci()` method calls itself, we have a recursive method.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fibonacci()`方法调用自身，我们有一个递归方法。'
- en: Recognizing a recursive problem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别递归问题
- en: Before we try to solve a problem via a recursive algorithm, we must recognize
    it as a good candidate for such an algorithm. Most of the recursive problems used
    in interviews are famous, so we recognize them by name. For example, problems
    such as Fibonacci numbers, summing a list of numbers, greatest common divisor,
    the factorial of a number, recursive Binary Search, reversing a string, and so
    on are well-known recursive problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试通过递归算法解决问题之前，我们必须将其识别为适合这种算法的良好候选。面试中使用的大多数递归问题都很有名，因此我们可以通过名称来识别它们。例如，斐波那契数、对列表中的数字求和、最大公约数、阶乘、递归二分查找、字符串反转等问题都是众所周知的递归问题。
- en: 'But what do all these problems have in common? Once we know the answer to this
    question, we will be able to recognize other recursive problems as well. The answer
    is quite simple: all these problems can be built off of sub-problems. In other
    words, we say that we can express the value returned by a method in terms of other
    values returned by that method.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，所有这些问题有什么共同之处呢？一旦我们知道了这个问题的答案，我们将能够识别其他递归问题。答案非常简单：所有这些问题都可以建立在子问题的基础上。换句话说，我们可以说我们可以用方法返回的其他值来表示方法返回的值。
- en: Important Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When a problem can be built off sub-problems, it is a good candidate for being
    solved recursively. Typically, such problems include the words *list top/last
    n ..., compute the n*th *or all..., count/find all solutions that ..., generate
    all cases that ...*, and so on. In order to compute *the n*th*...*, we must compute
    *n*th-1*, n*th-2, and so on so that we can divide the problem into sub-problems.
    In other words, computing f(*n*) requires computing f(*n*-1), f(*n*-2), and so
    on.*Practice* is the keyword in recognizing and solving recursive problems. Solving
    a lot of recursive problems will help you recognize them just as easily as you
    blink.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题可以建立在子问题的基础上时，它是适合递归解决的良好候选。通常，这类问题包括诸如*列出前/后n个...，计算第n个...或所有...，计算所有解...，生成所有情况...*等词语。为了计算*第n个*...，我们必须计算*f(n-1)*、*f(n-2)*等，以便将问题分解为子问题。换句话说，计算*f(n)*需要计算*f(n-1)*、*f(n-2)*等。*练习*是识别和解决递归问题的关键词。解决大量递归问题将帮助您像眨眼一样轻松地识别它们。
- en: Next, we'll highlight the main aspects of Dynamic Programming and learn how
    to optimize plain recursion via Dynamic Programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点介绍动态规划的主要方面，并学习如何通过动态规划优化纯递归。
- en: Dynamic Programming in a nutshell
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，动态规划
- en: When we talk about optimizing recursion, we talk about Dynamic Programming.
    This means that solving recursive problems can be done using plain recursive algorithms
    or Dynamic Programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论优化递归时，我们谈论动态规划。这意味着可以使用纯递归算法或动态规划来解决递归问题。
- en: 'Now, let''s apply Dynamic Programming to the Fibonacci numbers, starting with
    the plain recursive algorithm:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将动态规划应用于斐波那契数，从简单的递归算法开始：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The plain recursive algorithm for the Fibonacci numbers has a runtime of O(2n)
    and a space complexity of O(n) – you can find the explanation in [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*. If we set *k*=7 and represent the call stack as
    a tree of calls, then we obtain the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数的纯递归算法的运行时间为O(2n)，空间复杂度为O(n) - 您可以在[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*中找到解释。如果我们设置*k*=7，并将调用堆栈表示为调用树，则我们将获得以下图表：
- en: '![Figure 8.1 – Tree of calls (plain recursion)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 调用树（纯递归）'
- en: '](img/Figure_8.1_B15403.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B15403.jpg)'
- en: Figure 8.1 – Tree of calls (plain recursion)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 调用树（普通递归）
- en: If we check the Big O chart from [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms*, then we'll notice that O(2n) is far from being
    efficient. Exponential runtimes fit the **Horrible** area of the Big O chart.
    Can we do this better? Yes, via the *Memoization*approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*中的大O图表，我们会注意到O(2n)远非高效。指数运行时间适合大O图表的**可怕**区域。我们能做得更好吗？是的，通过*备忘录*方法。
- en: Memoization (or Top-Down Dynamic Programming)
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备忘录（或自顶向下的动态规划）
- en: 'When a recursive algorithm has repeated calls for the same inputs, this indicates
    that it performs duplicate work. In other words, a recursive problem may have
    overlapping sub-problems, so the road to the solution involves solving the same
    sub-problem multiple times. For example, if we redraw the tree of calls for Fibonacci
    numbers and we highlight the overlapping problems, then we obtain the following
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个递归算法对相同的输入进行重复调用时，这表明它执行了重复的工作。换句话说，递归问题可能存在重叠子问题，因此解决方案的路径涉及多次解决相同的子问题。例如，如果我们重新绘制斐波那契数的调用树，并突出显示重叠的问题，那么我们会得到以下图表：
- en: '![Figure 8.2 – Tree of calls (duplicate work)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 调用树（重复工作）'
- en: '](img/Figure_8.2_B15403.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B15403.jpg)'
- en: Figure 8.2 – Tree of calls (duplicate work)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 调用树（重复工作）
- en: It is obvious that more than half of the calls are duplicate calls.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，超过一半的调用是重复的调用。
- en: '*Memoization* is a technique that''s used to remove duplicate work in a method.
    It guarantees that a method is called for the same input only once. To achieve
    this, *Memoization* caches the results of the given inputs. This means that, when
    the method should be called to compute an input that has already been computed,
    *Memoization* will avoid this call by returning the result from the cache.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*备忘录*是一种用于消除方法中重复工作的技术。它保证一个方法只对相同的输入调用一次。为了实现这一点，*备忘录*缓存了给定输入的结果。这意味着，当方法应该被调用来计算已经计算过的输入时，*备忘录*将通过从缓存中返回结果来避免这次调用。'
- en: 'The following code uses *Memoization* to optimize the plain recursive algorithm
    for the Fibonacci numbers (the cache is represented by the `cache` array):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用*备忘录*来优化斐波那契数的普通递归算法（缓存由`cache`数组表示）：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we redraw the tree of calls from the preceding code, then we obtain the
    following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新绘制前面代码的调用树，那么我们会得到以下图表：
- en: '![Figure 8.3 – Tree of calls (Memoization)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 调用树（备忘录）'
- en: '](img/Figure_8.3_B15403.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B15403.jpg)'
- en: Figure 8.3 – Tree of calls (Memoization)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 调用树（备忘录）
- en: Here, it is obvious that *Memoization* has drastically reduced the number of
    recursive calls. This time, the `fibonacci()` method take advantage of cached
    results. The runtime was reduced from O(2n) to O(n), so from exponential to polynomial.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很明显*备忘录*大大减少了递归调用的次数。这次，`fibonacci()`方法利用了缓存的结果。运行时间从O(2n)降低到O(n)，因此从指数降低到多项式。
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '*Memoization* is also referred to as a *Top-Down*approach. The *Top-Down* approach
    is not very intuitive because we start developing the final solution immediately
    by explaining how we develop it from smaller solutions. This is like saying the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*备忘录*也被称为*自顶向下*方法。*自顶向下*方法并不直观，因为我们立即开始开发最终解决方案，解释我们如何从较小的解决方案中开发它。这就像说以下内容：'
- en: '*I wrote a book. How? I wrote its chapters. How? I wrote the sections of each
    chapter. How? I wrote the paragraphs of each section*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*我写了一本书。怎么写的？我写了它的章节。怎么写的？我写了每个章节的部分。怎么写的？我写了每个部分的段落*。'
- en: The space complexity remains O(n). Can we improve it? Yes, via the *Tabulation*
    approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度仍然是O(n)。我们能改进吗？是的，通过*Tabulation*方法。
- en: Tabulation (or Bottom-Up Dynamic Programming)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tabulation（或自底向上的动态规划）
- en: '*Tabulation*, or the *Bottom-Up*approach, is more intuitive than *Top-Down*.
    Essentially, a recursive algorithm (often) starts from the end and works backward,
    while a *Bottom-Up* algorithm starts right from the beginning. The *Bottom-Up*
    approach avoids recursion and improves space complexity.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tabulation*，或*自底向上*方法，比*自顶向下*更直观。基本上，递归算法（通常）从末尾开始向后工作，而*自底向上*算法从一开始就开始。*自底向上*方法避免了递归并改进了空间复杂度。'
- en: '**Important note**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: '*Tabulation* is commonly referred to as a *Bottom-Up* approach. Going bottom-up
    is an approach that avoids recursion and is quite natural. It''s like saying the
    following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tabulation*通常被称为*自底向上*方法。自底向上是一种避免递归并且相当自然的方法。就像说以下内容：'
- en: '*I wrote the paragraphs of each section. And? And I wrote the sections of each
    chapter. And? And I wrote all the chapters. And? And I wrote a book.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*我写了每个部分的段落。然后呢？然后我写了每个章节的部分。然后呢？然后我写了所有的章节。然后呢？然后我写了一本书。*'
- en: '*Bottom-Up* reduces the memory cost imposed by recursion when it builds up
    the call stack, which means that *Bottom-Up* eliminates the vulnerability of getting
    stack overflow errors. This may happen if the call stack gets too large and runs
    out of space.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*自底向上*减少了递归构建调用栈时所施加的内存成本，这意味着*自底向上*消除了发生堆栈溢出错误的脆弱性。如果调用栈变得太大并且空间不足，就可能发生这种情况。'
- en: 'For example, when we compute `fibonacci(k)` via the recursive approach, we
    start with *k* and continue with *k*-1, *k*-2, and so on until 0\. With the *Bottom-Up*
    approach, we start with 0 and continue with 1, 2, and so on until *k*. As shown
    in the following code, this is an iterative approach:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们通过递归方法计算`fibonacci(k)`时，我们从*k*开始，然后继续到*k*-1，*k*-2，依此类推直到0。通过*自底向上*方法，我们从0开始，然后继续到1，2等，直到*k*。如下代码所示，这是一种迭代方法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The runtime of this algorithm is still O(n), but the space complexity was brought
    down from O(n) to O(1). So, to recap the Fibonacci numbers algorithms, we have
    that the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的运行时间仍然是O(n)，但空间复杂度已从O(n)降低到O(1)。因此，总结斐波那契数算法，我们有以下内容：
- en: The **plain recursion** algorithm has a runtime of O(2n) and a space complexity
    of O(n).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Memoization recursion** algorithm has a runtime of O(n) and a space complexity
    of O(n).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **T****abulation** algorithm has a runtime of O(n) and a space complexity
    of O(1).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to practice some coding challenges.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following 15 coding challenges, we will exploit recursion and Dynamic
    Programming. These problems have been carefully crafted to help you understand
    and cover a wide range of problems from this category. By the end of this coding
    challenge session, you should be able to recognize and solve recursive problems
    in the context of an interview.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Robot grid (I)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: We have an *m* x *n* grid. A robot is placed at the top-left corner
    of this grid. The robot can only move either right or down at any point in time,
    but it is not allowed to move in certain cells. The robot''s goal is to find a
    path from the top-left corner to the bottom-right corner of the grid.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, we need to set some conventions of the *m* x *n* grid.
    Let''s assume that the bottom-right corner has the coordinates (0, 0), while the
    top-left corner has the coordinates (*m, n*), where *m* is the row and *n* is
    the column of the grid. So, the robot starts from (*m, n*) and must find a path
    to (0, 0). If we try to sketch an example for a 6x6 grid, then we can obtain something
    like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Determining the moving pattern'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B15403.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Determining the moving pattern
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the robot can go from one cell (*m, n*) to an adjacent
    cell, which can be (*m*-1*, n*) or (*m, n*-1). For example, if the robot is placed
    at (5, 5), then it can go to (4, 5) or (5, 4). Furthermore, from (4, 5), it can
    go to (3, 5) or (4, 4), while from (5, 4), it can go to (5, 3) or (4, 4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a problem that can be divided into sub-problems. We must find the
    final path for the cells (the problem), which we can do if we are able to find
    the path to an adjacent cell (sub-problem). This sounds like a recursive algorithm.
    In recursion, we approach the problem from top to down, so we start from (*m,
    n*) and move back to the origin (0, 0), as shown in the preceding diagram. This
    means that from cell (*m, n*), we try to go into (*m, n*-1) or (*m*-1*, n*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into code can be done as follows (the `maze[][]` matrix is a `boolean`
    matrix that has values of `true` for cells that we are not allowed to go in –
    for example, `maze[3][1] = true` means that we are not allowed in cell (3,1)):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The returned path is stored as a `LinkedHashSet<Point>`. Each path contains
    *m+n* steps and there are only two valid choices we can make at each step; therefore,
    the runtime is O(2m+n). But we can reduce this runtime to O(mn) if we cache the
    cells that failed (returned `false`). This way, the *Memoization* approach saves
    the robot from trying to go in a failed cell multiple times. The complete application
    is called *RobotGridMaze*. It also contains the *Memoization* code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Another popular problem of using a robot is as follows. Let's say we have an
    *m* x *n* grid. A robot is placed at the top-left corner of this grid. The robot
    can only move either right or down at any point in time. The robot's goal is to
    find all the unique paths from the top-left corner to the bottom-right corner
    of the grid.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The plain recursive solution and *Bottom-Up* approach are available in the *RobotGridAllPaths*
    application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Tower of Hanoi
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: This is a classical problem that can occur in an interview at
    any time. The Tower of Hanoi is a problem with three rods (*A,* *B,* and *C*)
    and *n* disks. Initially, all the disks are placed in ascending order on a single
    rod (the largest disk is on the bottom (disk *n*), a smaller one sitting on it
    (*n*-1), and so on (*n*-2*, n*-3*, ...*) until the smallest disk is on the top
    (disk 1). The aim is to move all the disks from this rod to another rod while
    respecting the following rules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：这是一个经典问题，可能随时在面试中出现。汉诺塔是一个有三根杆（*A*，*B*和*C*）和*n*个磁盘的问题。最初，所有的磁盘都按升序放置在一个杆上（最大的磁盘在底部（磁盘*n*），一个较小的磁盘放在它上面（*n*-1），依此类推（*n*-2，*n*-3，...）直到最小的磁盘在顶部（磁盘1）。目标是将所有的磁盘从这根杆移动到另一根杆，同时遵守以下规则：'
- en: Only one disk can be moved at a time.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能移动一个磁盘。
- en: A move means to slide the upper disk from one rod to another rod.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次移动意味着将顶部的磁盘从一个杆滑动到另一个杆。
- en: A disk cannot be placed on top of a smaller disk.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个磁盘不能放在比它更小的磁盘上。
- en: '**Solution**: Trying to solve such problems means that we need to visualize
    some cases. Let''s consider that we want to move the disks from rod *A* to rod
    *C*. Now, let''s put *n* disks on rod *A*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：尝试解决这样的问题意味着我们需要可视化一些情况。让我们假设我们想要将磁盘从杆*A*移动到杆*C*。现在，让我们在杆*A*上放置*n*个磁盘：'
- en: 'For *n=*1: Having a single disk, we need to move one disk from rod *A* to *C*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*1：有一个单独的磁盘，我们需要将一个磁盘从杆*A*移动到*C*。
- en: 'For *n=*2: We know how to move a single disk. To move two, we need to complete
    the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*2：我们知道如何移动一个单独的磁盘。为了移动两个磁盘，我们需要完成以下步骤：
- en: Move disk 1 from *A* to *B* (rod *B* acts as an intermediate for disk 1).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*A*移动到*B*（杆*B*作为磁盘1的中间杆）。
- en: Move disk 2 from *A* to *C* (disk 2 goes directly in its final place).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*A*移动到*C*（磁盘2直接移动到最终位置）。
- en: Move disk 1 from *B* to *C* (disk 1 can be moved on top of disk 2 on rod *C*).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*B*移动到*C*（磁盘1可以移动到杆*C*上的磁盘2上）。
- en: 'For *n=*3: Let''s get some help from the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n=*3：让我们从以下图表中获得一些帮助：
- en: '![Figure 8.5 – Tower of Hanoi (three disks)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 汉诺塔（三个磁盘）'
- en: '](img/Figure_8.5_B15403.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B15403.jpg)'
- en: Figure 8.5 – Tower of Hanoi (three disks)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 汉诺塔（三个磁盘）
- en: 'Due to *n=*2, we know how to move the top two disks from *A* (origin) to *C*
    (target). In other words, we know how to move the top two disks from one rod to
    another rod. Let''s move them from *A* to *B*, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*n=*2，我们知道如何将顶部两个磁盘从*A*（起点）移动到*C*（目标）。换句话说，我们知道如何将顶部两个磁盘从一个杆移动到另一个杆。让我们将它们从*A*移动到*B*，如下所示：
- en: Move disk 1 from *A* to *C* (this time, we use *C* as the intermediate).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*A*移动到*C*（这次我们使用*C*作为中间杆）。
- en: Move disk 2 from *A* to *B.*
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*A*移动到*B*。
- en: Move disk 1 from *C* to *B.*
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*C*移动到*B*。
- en: 'OK, so this is something that we''ve done before. Next, we can move disks 2
    and 3 onto *C*, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我们以前做过的事情。接下来，我们可以将磁盘2和3移动到*C*，如下所示：
- en: Move disk 3 from *A* to *C.*
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘3从*A*移动到*C*。
- en: Move disk 1 from *B* to *A* (we use *A* as the intermediate).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘1从*B*移动到*A*（我们使用*A*作为中间杆）。
- en: Move disk 2 from *B* to *C.*
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁盘2从*B*移动到*C*。
- en: Finally, move disk 3 from *A* to *C.*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将磁盘3从*A*移动到*C*。
- en: 'Continuing with this logic, we can intuit that we can move four disks because
    we know how to move three, we can move five disks because we know how to move
    four, and so on. With rod *A* as the origin, rod *B* as the intermediate, and
    rod *C* as the target, we can conclude that we can move *n* disks by doing the
    following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这种逻辑，我们可以直观地得出我们可以移动四个磁盘，因为我们知道如何移动三个，我们可以移动五个磁盘，因为我们知道如何移动四个，依此类推。以杆*A*为起点，杆*B*为中间杆，杆*C*为目标杆，我们可以得出我们可以通过以下步骤移动*n*个磁盘：
- en: Move the top *n* - 1 disks from the origin to the intermediate, using the target
    as an intermediate.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶部的*n* - 1个磁盘从起点移动到中间杆，使用目标杆作为中间杆。
- en: Move the top *n* - 1 disks from the intermediate to the target, using the origin
    as an intermediate.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶部的*n* - 1个磁盘从中间杆移动到目标杆，使用起点作为中间杆。
- en: 'At this point, it is clear that we have a problem that can be divided into
    sub-problems. Based on the preceding two bullets, we can code this as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，很明显我们有一个可以分解为子问题的问题。基于前面两个项目符号，我们可以编写代码如下：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete application is called *HanoiTowers*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*HanoiTowers*。
- en: Coding challenge 3 – Josephus
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - Josephus
- en: '**Amazon, Google, Adobe, Microsoft, Flipkart**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider a group of *n* men arranged in a circle (1, 2, 3, ...,
    *n*). Every *k*th man will be killed around the circle until only one survivor
    remains. Write an algorithm that finds the *k* position of this survivor. This
    is known as the Josephus problem.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个排成圆圈的*n*个人（1，2，3，...，*n*）。每隔*k*个人将在圆圈中被杀，直到只剩下一个幸存者。编写一个算法，找到这个幸存者的*k*位置。这就是所谓的Josephus问题。'
- en: '**Solution**: Remember that we had a note previously saying that when a problem
    contains the words *compute the n*thand similar expressions, then it is possibly
    a good candidate for being solved via recursion. Here, we have *find the k position*,
    which is a problem that can be divided into sub-problems and be solved via recursion.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：记住我们之前有一个注释，当一个问题包含*计算第n个*之类的表达时，它可能是递归解决的一个很好的候选。在这里，我们有*找到第k个位置*，这是一个可以分解为子问题并通过递归解决的问题。'
- en: 'Let''s consider *n*=15 and *k*=3\. So, there are 15 men and every third man
    will be eliminated from the circle until only one remains. Let''s visualize this
    via the following diagram (this is very useful for figuring out the pattern of
    killings):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑*n*=15和*k*=3。所以，有15个人，每三个人中的一个将在圆圈中被淘汰，直到只剩下一个人。让我们通过以下图表来可视化这一点（这对于找出杀人的模式非常有用）：
- en: '![Figure 8.6 – Josephus for n=15 and k=3'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - n=15和k=3的Josephus'
- en: '](img/Figure_8.6_B15403.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B15403.jpg)'
- en: Figure 8.6 – Josephus for n=15 and k=3
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - n=15和k=3的Josephus
- en: 'So, we have five rounds until we find the survivor, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要进行五轮，直到找到幸存者，如下所示：
- en: 'Round 1: The first elimination is position 3; next, 6, 9, 12, and 15 are eliminated.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1轮：第一个淘汰的是位置3；接下来是6，9，12和15。
- en: 'Round 2: The first elimination is position 4 (1 and 2 are skipped, since position
    15 was the last eliminated in round 1); next, 8 and 13 are eliminated.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 3: The first elimination is position 2 (14 and 1 are skipped, since position
    13 was the last eliminated in round 2); next, 10 and 1 are eliminated.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 4: The first elimination position is 11, followed by position 7.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Round 5: 14 is eliminated and 5 is the survivor.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trying to identify a pattern or a recursive call can be done based on the following
    observations. After the first man (*k*th) is eliminated, *n*-1 men are left. This
    means that we call `josephus(n – 1, k)` to get the position of the *n*-1th man.
    However, notice that the position returned by `josephus(n – 1, k)` will take into
    account the position starting from *k%n* + 1\. In other words, we have to adjust
    the position returned by `josephus(n – 1, k)` to obtain (`josephus(n - 1, k) +
    k - 1) % n + 1`. The recursive method is shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you find this approach quite tricky, then you can try an iterative approach
    based on a queue. First, fill up the queue with *n* men. Next, loop the queue
    and, for each man, retrieve and remove the head of this queue (`poll()`). If the
    retrieved man is not the *k*th, then insert this man back in the queue (`add()`).
    If this is the *k*th man, then break the loop and repeat this process until the
    queue''s size is 1\. The code for this is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete application is called *Josephus*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Color spots
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an *r* x *c* grid where *r* stands for rows and *c* stands
    for columns. Each cell has a color represented by a number *k* (for example, for
    three colors, *k*=3). We define the connected set of a cell (or a color spot)
    as the total cells in which we can go from the respective cell by successive displacements
    on the row or the column, thus keeping the color. The goal is to determine the
    color and the number of cells of the maximum connected set. In other words, we
    need to determine the biggest color spot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider a 5x5 grid and three colors, where we have *r=c=*5
    and *k=*3\. Next, let''s represent the grid as shown in the following diagrams:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B15403.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Biggest color spot ((a) – initial grid, (b) – solved grid)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on image (a). Here, we can see that moving from a cell to another
    cell can be done in a maximum of four directions (up, down, left, and right).
    This means that, from a cell (*r,c*), we can try to go to (*r*-1, *c*), (*r*+1,
    *c*), (*r*, *c*-1), and (*r*, *c*+1). We cannot perform a move if we risk falling
    from the grid or the targeted cell has another color than the current cell. So,
    by iterating each cell ((0, 0), (0, 1), ... (*r*, *c*)), we can determine the
    size of the connected set of that cell (the size of the color spot) by visiting
    each allowed cell and counting it. In image (a), we have four spots that are color
    1 whose sizes are 1, 1, 1, and 2\. We also have six spots that are color 2 whose
    sizes are 1, 1, 2, 1, 1, and 1\. Finally, we have three spots that are color 3
    whose sizes are 11, 1, and 1\.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can conclude that the biggest color spot has a size of 11 and
    a color of 3\. Mainly, we can consider that the color spot of the first cell is
    the maximum spot and that each time we find a color spot bigger than this one,
    we replace this one with the one we found.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus on image (b). Why do we have negative values? Because when
    we visit a cell, we switch its *color* value to *-color*. This is a convenient
    convention that's used to avoid computing the same connected set of a cell multiple
    times. It is like saying that we mark this cell as visited. By convention, we
    cannot move in a cell that has a negative value for a color, so we will not compute
    the size of the same color spot twice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, gluing these observations together to make a recursive method leads to
    the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这些观察结果组合成一个递归方法，得到以下代码：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While the preceding recursive method, `computeColorSpot()`, can compute the
    size of a color spot, starting from the given cell, the following method determines
    the biggest color spot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定单元格开始时，前面的递归方法`computeColorSpot()`可以计算颜色斑点的大小，而以下方法确定了最大的颜色斑点：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *BiggestColorSpot*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BiggestColorSpot*。
- en: Coding challenge 5 – Coins
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战5 - 硬币
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Adobe**，**Microsoft**'
- en: '**Problem**: Consider an amount of *n* cents. Count the ways you can change
    this amount using any number of quarters (25 cents), dimes (10 cents), nickels
    (5 cents), and pennies (1 cent).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑n美分的金额。计算您可以使用任意数量的25美分，10美分，5美分和1美分来更改此金额的方式。'
- en: '**Solution**: Let''s imagine that we have to change 50 cents. Right from the
    start, we can see that changing 50 cents is a problem that can be solved via sub-problems.
    For example, we can change 50 cents using 0, 1, or 2 quarters. Or we can do it
    using 0, 1, 2, 3, 4, or 5 dimes. We can also do it using 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, or 10 nickels. Finally, we can do it using 0, 1, 2, 3, ..., 50 pennies.
    Let''s assume that we have 1 quarter, 1 dime, 2 nickels, and 5 pennies. We can
    use our quarter to say the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设我们必须更改50美分。从一开始，我们就可以看到更改50美分是一个可以通过子问题解决的问题。例如，我们可以使用0、1或2个25美分来更改50美分。或者我们可以使用0、1、2、3、4或5个10美分来做到这一点。我们还可以使用0、1、2、3、4、5、6、7、8、9或10个5美分。最后，我们可以使用0、1、2、3、...、50个1美分。假设我们有1个25美分，1个10美分，2个5美分和5个1美分。我们可以使用我们的25美分来说以下内容：'
- en: '*calculateChange***(50) = 1 quarters + ...**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(50) = 1个25美分 + ...**'
- en: 'But this is like saying the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就像说以下内容：
- en: '*calculateChange***(25) = 0 quarters + ...**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(25) = 0个25美分 + ...**'
- en: 'We don''t have more quarters; therefore, we add a dime:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更多的25美分；因此，我们添加一个10美分：
- en: '*calculateChange***(25) = 0 quarters + 1 dimes + ...**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(25) = 0个25美分 + 1个10美分 + ...**'
- en: 'This can be reduced, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化如下：
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + ...**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(15) = 0个25美分 + 0个10美分 + ...**'
- en: 'We don''t have any more dimes. We add the nickels:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更多的10美分。我们添加了5美分：
- en: '*calculateChange***(15) = 0 quarters + 0 dimes + 2 nickel + ...**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(15) = 0个25美分 + 0个10美分 + 2个5美分 + ...**'
- en: 'This can be reduced to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + ...**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(5) = 0个25美分 + 0个10美分 + 0个5美分 + ...**'
- en: 'Finally, since we don''t have more nickels, we add the pennies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们没有更多的5美分，我们添加了1美分：
- en: '*calculateChange***(5) = 0 quarters + 0 dimes + 0 nickel + 5 pennies**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(5) = 0个25美分 + 0个10美分 + 0个5美分 + 5个1美分**'
- en: 'This can be reduced to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '*calculateChange***(0) = 0 quarters + 0 dimes + 0 nickel + 0 pennies**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*calculateChange***(0) = 0个25美分 + 0个10美分 + 0个5美分 + 0个1美分**'
- en: 'If we try to represent all the possible reductions, we obtain the following
    diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图表示所有可能的减少，我们得到以下图表：
- en: '![Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 将n美分换成25美分，10美分，5美分和1美分'
- en: '](img/Figure_8.8_B15403.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B15403.jpg)'
- en: Figure 8.8 – Changing n cents into quarters, dimes, nickels, and pennies
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 将n美分换成25美分，10美分，5美分和1美分
- en: 'Implementing this reducible algorithm can be done via recursion, as shown in
    the following code. Notice that we are using *Memoization* to avoid changing the
    same amount multiple times:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归实现这种可简化的算法，如下代码所示。请注意，我们使用*Memoization*来避免多次更改相同的金额：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete application is called *Coins*. It also contains the plain recursive
    approach (without *Memoization*).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Coins*。它还包含了纯递归方法（不包括*Memoization*）。
- en: Coding challenge 6 – Five towers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 五座塔
- en: '**Problem**: Consider a 5x5 grid with five defensive towers spread across the
    grid. To provide an optimal defense for the grid, we have to build a tower on
    each row of the grid. Find all the solutions for building these towers so that
    none of them share the same column and diagonal.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个5x5的网格，网格上分布着五座防御塔。为了为网格提供最佳防御，我们必须在网格的每一行上建造一座塔。找出建造这些塔的所有解决方案，以便它们没有共享相同的列和对角线。'
- en: '**Solution**: We know that, on each row, we must build a tower and that it
    is not important in what order we build them on the grid. Let''s sketch a solution
    and a failure, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们知道，在每一行上，我们必须建造一座塔，并且在网格上建造它们的顺序并不重要。让我们草拟一个解决方案和一个失败，如下所示：'
- en: '![Figure 8.9(a) – Failure and solution'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(a) - 失败和解决方案'
- en: '](img/Figure_8.9(a)_B15403.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(a)_B15403.jpg)'
- en: Figure 8.9(a) – Failure and solution
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(a) - 失败和解决方案
- en: 'Let''s focus on the solution and start from the first row: row 0\. We can build
    a tower on this row in any column; therefore, we can say the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于解决方案，并从第一行开始：第0行。我们可以在任何列上的这一行上建造一座塔；因此，我们可以说以下内容：
- en: '![Figure 8.9(b): Part 1 of the logic to build the towers'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(b)：构建塔的逻辑的第1部分'
- en: '](img/Figure_8.9(b)_B15403.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(b)_B15403.jpg)'
- en: 'Figure 8.9(b): Part 1 of the logic to build the towers'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(b)：构建塔的逻辑的第1部分
- en: 'If we continue with the same logic, then we can say the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用相同的逻辑，那么我们可以说以下内容：
- en: '![Figure 8.9(c): Part 2 of the logic to build the towers'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9(c)：构建塔的逻辑的第2部分'
- en: '](img/Figure_8.9(c)_B15403.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9(c)_B15403.jpg)'
- en: 'Figure 8.9(c): Part 2 of the logic to build the towers'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9(c)：构建塔的逻辑的第2部分
- en: 'So, we start from the first row and build the first tower on (0,0). We go to
    the second row and try to build the second tower so that we don''t share the column
    or diagonal with the first tower. We go to the third row and try to build the
    third tower so that we don''t share the column or diagonal with the first two
    towers. We follow the same logic for the fourth and fifth towers. This is our
    solution. Now, we repeat this logic – we build the first tower at (0,1) and continue
    building until we find the second solution. Next, we build the first tower at
    (0, 2), (0, 3) and finally at (0,4) while we repeat the process. We can write
    this recursive algorithm as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *FiveTowers*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Magic index
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Adobe, Microsoft**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a sorted array of *n* elements that allows duplicates.
    An index *k* is magic if *array*[*k*] = *k*. Write a recursive algorithm that
    finds the first magic index.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, let''s quickly draw two sorted arrays containing 18 elements,
    as shown in the following diagram. The array at the top of the image contains
    no duplicates, while the array at the bottom contains duplicates. This way, we
    can observe the influence of these duplicates:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Sorted array of 18 elements'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B15403.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Sorted array of 18 elements
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If we halve the array with no duplicates, then we can conclude that the magic
    index must be on the right-hand side because *array*[8] < 8\. This is true since
    the magic index is 11, so *array*[11] = 11.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: If we halve the array with duplicates, we cannot get the same conclusion we
    received previously. The magic index can be on both sides. Here, we have *array*[5]
    = 5 and *array*[12] = 12\. We must find the first magic index, so we should search
    the left-hand side first.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: But how do we find it? The most obvious approach consists of looping the array
    and checking if *array*[*i*] = *i*. While this works for any ordered array, it
    will not impress the interviewer since it is not recursive, so we need another
    approach.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*, Big O Analysis
    of Algorithms*, you saw an example of searching in a sorted array via the Binary
    Search algorithm. This algorithm can be implemented via recursion since, at each
    step, we halve the previous array and create a sub-problem. Since the indexes
    of an array are ordered, we can adapt the Binary Search algorithm. The main issue
    that we face is that duplicated elements complicate the search. When we halve
    the array, we cannot say that the magic index is on the left or the right, so
    we have to search in both directions, as shown in the following code (first, we
    search the left-hand side):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *MagicIndex*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – The falling ball
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider an *m* x *n* grid where each (*m, n*) cell has an elevation
    represented by a number between 1 and 5 (5 is the highest elevation). A ball is
    placed in a cell of the grid. This ball can fall into another cell, as long as
    that cell has a smaller elevation than the ball cell. The ball can fall in four
    directions: north, west, east, and south. Display the initial grid, as well as
    the grid after the ball falls on all possible paths. Mark the paths with 0.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Always pay attention to the problem requests. Notice that we
    must display the solved grid, not list the paths or count them. The easiest way
    to display a grid is to use two loops, as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s sketch a 5x5 grid and view an input and its output. The following
    image shows the initial grid in the form of a 3D model, along with a possible
    path and the solved grid:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The falling ball'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B15403.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – The falling ball
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'I think we have enough experience to intuit that this problem can be solved
    via recursion. Mainly, we move the ball in all acceptable directions and mark
    each visited cell with 0\. When we have the ball in the (*i, j*) cell, we can
    go in (*i*-1*, j*), (*i+*1*, j*), (*i, j*-1), and (*i, j+*1) directions, as long
    those cells have smaller elevations. In terms of code, we have the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们有足够的经验来直觉地认为这个问题可以通过递归来解决。主要是，我们将球移动到所有可接受的方向，并用0标记每个访问的单元格。当我们将球放在(*i,
    j*)单元格中时，我们可以朝着(*i*-1*, j*)，(*i+*1*, j*)，(*i, j*-1)和(*i, j+*1*)的方向前进，只要这些单元格的高度较小。在代码方面，我们有以下内容：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The complete application is called *TheFallingBall*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*TheFallingBall*。
- en: Coding challenge 9 – The highest colored tower
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战9 - 最高彩色塔
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Consider *n* boxes of different widths (*w*1...n), heights (*h*1...n),
    and colors (*c*1...n). Find the highest tower of boxes that respects the following
    conditions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑不同宽度（*w*1...n）、高度（*h*1...n）和颜色（*c*1...n）的*n*个盒子。找到符合以下条件的最高的盒子塔：'
- en: You cannot rotate the boxes.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能旋转盒子。
- en: You cannot place two successive boxes of the same color.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能连续放置两个相同颜色的盒子。
- en: Each box is strictly larger than the box above it in terms of their width and
    height.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个盒子在宽度和高度上都严格大于它上面的盒子。
- en: '**Solution**: Let''s try to visualize this, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们试着将这个可视化，如下所示：'
- en: '![Figure 8.12(a) – The highest colored tower'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12(a) - 最高的彩色塔'
- en: '](img/Figure_8.12_B15403.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B15403.jpg)'
- en: Figure 8.12(a) – The highest colored tower
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12(a) - 最高的彩色塔
- en: 'We have seven boxes of different sizes and colors. We can imagine that the
    highest tower will contain all these boxes, *b*1...*b*7\. But we have several
    constraints that don''t allow us to simply stack the boxes. We can choose one
    of the boxes as the base box and place another allowed box on top of it, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有七个不同尺寸和颜色的盒子。我们可以想象最高的塔将包含所有这些盒子，*b*1...*b*7。但是我们有一些约束条件，不允许我们简单地堆叠这些盒子。我们可以选择一个盒子作为基础盒子，并将另一个允许的盒子放在其顶部，如下所示：
- en: '![Figure 8.12(b) The logic to select the boxes to build the highest tower'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12(b) 选择盒子建造最高塔的逻辑'
- en: '](img/Figure_8.12(b)_The_logic_to_select_the_boxes_to_build_the_highest_tower.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12(b)_选择盒子建造最高塔的逻辑.jpg)'
- en: Figure 8.12(b) The logic to select the boxes to build the highest tower
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12(b) 选择盒子建造最高塔的逻辑
- en: So, we identified a pattern. We choose a box as the base, and we try to see
    which of the remaining boxes can go on top as the second level. We do the same
    for the third level and so on. When we are done (we cannot add more boxes or no
    boxes are left), we store the size of the highest tower. Next, we repeat this
    scenario with another base box.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们找到了一个模式。我们选择一个盒子作为基础，然后尝试看看剩下的盒子中哪个可以作为第二层放在顶部。我们对第三层也是同样的操作。当我们完成时（不能再添加盒子或没有剩余的盒子时），我们存储最高塔的大小。接下来，我们用另一个基础盒子重复这种情况。
- en: Since every box must be larger in terms of width and height than the box above
    it, we can sort the boxes by width or height in descending order (it is not important
    which one we choose). This way, for any tower of *b*0*,...b*k*, k < n* boxes,
    we can find the next valid box by searching the *b*k+1...*n* interval.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个盒子在宽度和高度上都必须大于上面的盒子，我们可以按宽度或高度按降序对盒子进行排序（选择哪一个并不重要）。这样，对于*k < n*的盒子的任何塔，我们可以通过搜索*b*k+1...*n*区间来找到下一个有效的盒子。
- en: 'Moreover, we can avoid recalculating the best solution for the same base box
    by caching the best solutions via *Memoization*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过*记忆化*来避免为相同的基础盒子重新计算最佳解决方案：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete application is called *HighestColoredTower*. The code also contains
    the plain recursion approach to this problem (without *Memoization*).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*HighestColoredTower*。代码还包含了这个问题的纯递归方法（没有*记忆化*）。
- en: Coding challenge 10 – String permutations
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战10 - 字符串排列
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**，**Google**，**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Write an algorithm that computes all the permutations of a string
    and accommodates the following two conditions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：编写一个算法，计算字符串的所有排列，并满足以下两个条件：'
- en: The given string can contain duplicates.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的字符串可以包含重复项。
- en: The returned list of permutations should not contain duplicates.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的排列列表不应包含重复项。
- en: '**Solution**: Like in any recursive problem, the key consists of recognizing
    the relationship and patterns between the different sub-problems. Right away,
    we can intuit that permuting a string with duplicates should be more complicated
    than permuting a string with unique characters. This means that we must understand
    the permutations of a string with unique characters first.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：就像在任何递归问题中一样，关键在于识别不同子问题之间的关系和模式。我们立刻就能直观地感觉到，对具有重复字符的字符串进行排列应该比对具有唯一字符的字符串进行排列更复杂。这意味着我们必须先理解具有唯一字符的字符串的排列。'
- en: 'The most natural way of permuting the characters of a string can follow a simple
    pattern: each character of the string will become the first character of the string
    (swap their positions) and then permute all the remaining letters using a recursive
    call. Let''s delve into the general case. For a string containing a single character,
    we have a single permutation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串的字符进行排列的最自然的方式可以遵循一个简单的模式：字符串的每个字符将成为字符串的第一个字符（交换它们的位置），然后使用递归调用对所有剩余的字母进行排列。让我们深入研究一般情况。对于包含单个字符的字符串，我们有一个排列：
- en: P(*c*1) = *c*1
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: P(*c*1) = *c*1
- en: 'If we add another character, then we can express the permutations as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个字符，那么我们可以按如下方式表示排列：
- en: P(*c*1*c*2) = *c*1*c*2 and *c*2*c*1
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: P(*c*1*c*2) = *c*1*c*2 和 *c*2*c*1
- en: 'If we add another character, then we must express the permutations using *c*1*c*2\.
    Each permutation of *c*1*c*2*c*3 represents an ordering of *c*1*c*2, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加另一个字符，那么我们必须使用*c*1*c*2来表示排列。每个*c*1*c*2*c*3的排列代表了*c*1*c*2的顺序，如下所示：
- en: '*c*1*c*2 -> *c*1*c*2*c*3,*c*1*c*3*c*2,*c*3*c*1*c*2'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*1*c*2 -> *c*1*c*2*c*3,*c*1*c*3*c*2,*c*3*c*1*c*2'
- en: '*c*2*c*1 -> *c*2*c*1*c*3,*c*2*c*3*c*1,*c*3*c*2*c*1'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace *c*1*c*2*c*3 with ABC. Next, we represent P(ABC) as a diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Permuting ABC'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B15403.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Permuting ABC
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another character, then we must express the permutations using *c*1*c*2*c*3*c*4\.
    Each permutation of *c*1*c*2*c*3*c*4 represents an ordering of *c*1*c*2*c*3, as
    follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '*c*1*c*2*c*3 -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*4*c*2*c*3,*c*4*c*1*c*2*c*3'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '*c*1*c*3*c*2 -> *c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*3*c*2,*c*4*c*1*c*3*c*2'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '*c*3*c*1*c*2 -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*4*c*1*c*2,*c*4*c*3*c*1*c*2'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*c*2c1*c*3 -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*4*c*1*c*3,*c*4*c*2*c*1*c*3'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*c*2*c*3*c*1 -> *c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*3*c*1,*c*4*c*2*c*3*c*1'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*c*3*c*2*c*1 -> *c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*2*c*1,*c*4*c*3*c*2*c*1'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We can continue like this forever, but I think it is quite clear what pattern
    can be used for generating *P*(*c*1, *c*2, ..., *c*n).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is the right moment to take our logic a step further. Now, it is time
    to ask the following questions: if we know how to compute all the permutations
    for strings of *k*-1 characters (*c*1*c*2...*c*k-1), then how we can use this
    information to compute all the permutations for strings of *k* characters (*c*1*c*2...*c*k-1*c*k)?
    For example, if we know how to compute all the permutations for the *c*1*c*2*c*3
    string, then how we can express all the permutations of the *c*1*c*2*c*3*c*4 string
    using *c*1*c*2*c*3 permutations? The answer is to take each character from the
    *c*1*c*2...*c*k string and append the *c*1*c*2...*c*k-1 permutation to it, as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: P(*c*1*c*2*c*3*c*4) = [*c*1 + P(*c*2*c*3*c*4)] + [*c*2 + P(*c*1*c*3*c*4)] +
    [*c*3 + P(*c*1*c*2*c*4)] + [*c*4 + P(*c*1*c*2*c*3)]
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*1 + P(*c*2*c*3*c*4)] -> *c*1*c*2*c*3*c*4,*c*1*c*2*c*4*c*3,*c*1*c*3*c*2*c*4,*c*1*c*3*c*4*c*2,*c*1*c*4*c*2*c*3,*c*1*c*4*c*3*c*2'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*2 + P(*c*1*c*3*c*4)] -> *c*2*c*1*c*3*c*4,*c*2*c*1*c*4*c*3,*c*2*c*3*c*1*c*4,*c*2*c*3*c*4*c*1,*c*2*c*4*c*1*c*3,*c*2*c*4*c*3*c*1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*3 + P(*c*1*c*2*c*4)] -> *c*3*c*1*c*2*c*4,*c*3*c*1*c*4*c*2,*c*3*c*2*c*1*c*4,*c*3*c*2*c*4*c*1,*c*3*c*4*c*1*c*2,*c*3*c*4*c*2*c*1'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[*c*4 + P(*c*1*c*2*c*3)] -> *c*4*c*1*c*2*c*3,*c*4*c*1*c*3*c*2,*c*4*c*2*c*1*c*3,*c*4*c*2*c*3*c*1,*c*4*c*3*c*1*c*2,*c*4*c*3*c*2*c*1'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue to add another character and repeat this logic so that we have
    a recursive pattern that can be expressed in terms of code as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code will work fine. Because we use a `Set` (not a `List`), we respect
    the requirement stating that *the returned list of permutations should not contain
    duplicates*. However, we do generate duplicates. For example, if the given string
    is *aaa*, then we generate six identical permutations, even if there is only one.
    The only difference is that they are not added to the result since a `Set` doesn't
    accept duplicates. This is far from being efficient.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid generating duplicates in several ways. One approach starts by
    counting the characters of a string and storing them in a map. For example, for
    the given string *abcabcaa*,the key-value map can be *a*=4, *b*=2, and *c*=2\.
    We can do this via a simple helper method, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we choose one of these characters as the first character and find all
    the permutations of the remaining characters. We can express this as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*2*,c=*2) *=* [*a +* P(*a=*3*,b=*2*,c=*2)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*1)]
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*3*,b=*2*,c=*2) *=* [*a +* P(*a=*2*,b=*2*,c=*2)] *+* [*b +* P(*a=*3*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*3*,b=*2*,c=*1)]
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*1*,c=*1*) =* [*a +* P(*a=*3*,b=*1*,c=*1)] *+* [*b +* P(*a=*4*,b=*0*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*1*,c=*0)]
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*4*,b=*2*,c=*1*) =* [*a +* P(*a=*3*,b=*2*,c=*1)] *+* [*b +* P(*a=*4*,b=*1*,c=*1)]
    *+* [*c +* P(*a=*4*,b=*2*,c=*0)]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*2*,b=*2*,c=*2) *=* [*a +* P(*a=*1*,b=*2*,c=*2)] *+* [*b +* P(*a=*2*,b=*1*,c=*2)]
    *+* [*c +* P(*a=*2*,b=*2*,c=*1)]
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: P(*a=*3*,b=*1*,c=*1) *= ...*
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue writing until there are no remaining characters. Now, it should
    be quite simple to put this into lines of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete application is called *Permutations*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Knight tour
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a chessboard (an 8x8 grid). Place a knight on this board
    and print all its unique movements.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As you''ve already seen, the best way to tackle such problems
    is to take a piece of paper and a pen and sketch the scenario. A picture is worth
    a thousand words:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Knight tour'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B15403.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Knight tour
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, a knight can move from a (*r*, *c*) cell into a maximum of eight
    other valid cells; that is, (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1,*c*+2), (*r*-2,
    *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1). So,
    in order to obtain the path from 1 to 64 (as shown in the right-hand side of the
    preceding diagram), we can start from a given location and recursively try to
    visit each valid movement. If the current path doesn't represent a solution or
    we've tried all eight cells, then we backtrack.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'To be as efficient as possible, we consider the following aspects:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from a corner of the chessboard: This way, the knight can initially
    go in only two directions instead of eight.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We check for valid cells in a fixed sequence: Maintaining a circular path will
    help us find a new move faster than picking one randomly. The counterclockwise
    circular path from (*r*, *c*) is (*r*+2, *c*+1), (*r*+1, *c*+2), (*r*-1, *c*+2),
    (*r*-2, *c*+1), (*r*-2, *c*-1), (*r*-1, *c*-2), (*r*+1, *c*-2), and (*r*+2, *c*-1).'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We compute the circular path using two arrays: We can move from (*r*, *c*)
    to (*r* + *ROW*[*i*]*,c + COL*[*i*]) with *i* in [0, 7]:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*COL*[] = {1,2,2,1,-1,-2,-2,-1,1};'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '*ROW*[] = {2,1,-1,-2,-2,-1,1,2,2};'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We avoid cycles in paths and duplicate work (for example, visiting the same
    cell multiple times) by storing the visited cells in an *r* x *c* matrix.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By gluing everything together in terms of code, we obtain the following recursive
    approach:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is called *KnightTour*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Curly braces
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Print all the valid combinations of *n* pairs of curly braces.
    A valid combination is when the curly braces are properly opened and closed. For
    *n*=3, the valid combinations are as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '{{{}}},{{}{}},{{}}{},{}{{}},{}{}{}'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The valid combination for *n*=1 is {}.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: For *n=2*, we immediately see the combination as {}{}. However, another combination
    consists of adding a pair of curly braces to the previous combination; that is,
    {{}}.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Going one step further, for *n*=3, we have the trivial combination {}{}{}. Following
    the same logic, we can add a pair of curly braces to combinations for *n*=2, so
    we obtain {{{}}}, {{}}{}, {}{{}}, {{}{}}.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, this is what we obtain after we remove or ignore duplicates. Let''s
    sketch the case for the *n*=3 build based on *n*=2, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Curly braces duplicate pairs'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B15403.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Curly braces duplicate pairs
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: So, if we add a pair of curly braces inside each existing pair of curly braces
    and we add the trivial case ({}{}...{}) as well, then we obtain a pattern that
    can be implemented via recursion. However, we have to deal with a significant
    number of duplicate pairs, so we need additional checks to avoid having duplicates
    in the final result.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s consider another approach, starting with a simple observation. For
    any given *n*, a combination will have 2**n* curly braces (not pairs!). For example,
    for *n*=3, we have six curly braces (three left curly braces ({{{) and three right
    curly braces (}}})) arranged in different, valid combinations. This means that
    we can try to build the solution by starting with zero curly braces and add left/right
    curly braces to it, as long as we have a valid expression. Of course, we keep
    track of the number of added curly braces so that we don''t exceed the maximum
    number, 2**n.* The rules that we must follow are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We add all left curly braces in a recursive manner.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the right curly braces in a recursive manner, as long as the number of
    right curly braces doesn't exceed the number of left curly braces.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, the key to this approach is to track the number of left and
    right curly braces that are allowed. As long as we have left curly braces, we
    insert a left curly brace and call the method again (recursion). If there are
    more right curly braces remaining than there are left curly braces, then we insert
    a right curly brace and call the method (recursion). So, let''s get coding:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is called *Braces*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Staircase
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: A person walks up a staircase. They can hop either one step, two
    steps, or three steps at a time. Count the number of possible ways they can reach
    the top of the staircase.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, let''s set what hopping one, two, or three steps means.
    Consider that hopping one step means to go up the staircase step by step (we land
    on each step). To hop two steps means to jump over a step and land on the next
    one. Finally, to hop three steps means to jump over two steps and land on the
    third one.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we consider a staircase with three steps, then we can go from
    step 0 (or, no step) to step 3 in four ways: step by step (we land on each step),
    we jump over step 1 and land on step 2 and walk on step 3, we walk on step 1 and
    jump over step 2, thereby landing on step 3, or we jump directly on step 3, as
    shown in the following diagram:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Staircase (how to reach step 3)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B15403.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Staircase (how to reach step 3)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'By going one step further in our logic, we may ask ourselves how to reach step
    *n*. Mainly, the *n*th step can be reached if we do the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '*n*-1 step and hop 1 step'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n*-2 step and hop 2 steps'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n*-3 step and hop 3 steps'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, reaching any of these steps – *n-*1, *n-*2, or *n-*3 – is possible
    if we follow the preceding bullets. For example, we can reach the *n-*1 step if
    we are on *n-*2 and hop 1 step, we are on *n-*3step and hop 2 steps, or we are
    on *n-*4 step and hop 3 steps.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: So, to reach the *n*th step, we have three possible paths. To reach step *n*-1th,
    we also have three possible paths. So, to reach both steps, we must have 3+3=6
    paths. Do not say 3*3=9 paths! This is wrong!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can conclude that adding all the paths in a recursive manner should
    give us the expected answers. Moreover, we can use our experience to add *Memoization*
    as well. This way, we avoid calling the method with the same inputs many times
    (exactly as in the case of the Fibonacci numbers):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete application is called *Staircase*. It also contains the plain recursion
    approach (without *Memoization*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Subset sum
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given set (*arr*) of positive integers and a value,
    *s*. Write a snippet of code that finds out if there is a subset in this array
    whose sum is equal to the given *s*.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the array, *arr* = {3, 2, 7, 4, 5, 1, 6, 7, 9}.
    If *s*=7, then a subset can contain the elements 2, 4, and 1, as shown in the
    following diagram:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Subset of sum 7'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B15403.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Subset of sum 7
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The subset containing the elements 2, 4, and 1 is just one of the possible subsets.
    All possible subsets include (3, 4), (2, 4, 1), (2, 5), (7), (1, 6), and (7).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Recursive approach
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try to find a solution via recursion. If we add the subset *arr*[0]=3,
    then we have to find the subset for *s* = *s-arr*[0] = 7-3 = 4\. Finding a subset
    for *s*=4 is a sub-problem that can be solved based on the same logic, which means
    we can add *arr*[1]=2 in the subset, and the next sub-problem will consist of
    finding the subset for *s* = *s*-*arr*[1] = 4-2 = 2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can think like this: start with *sum*=0\. We add *arr*[0]=3
    to this *sum* as *sum*=*sum+arr*[0] = 3\. Next, we check if *sum* = *s* (for example,
    if 3 = 7). If so, we found a subset. If not, we add the next element, *arr*[1]=2,
    to the *sum* as *sum = sum+arr*[1] = 3+2 =5\. We recursively continue to repeat
    this process until there are no more elements to add. At this point, we recursively
    remove elements from *sum* and check if *sum = s* upon each removal. In other
    words, we build every possible subset and check if its *sum* is equal to *s*.
    When we have this equality, we print the current subset.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it is clear that if we recursively solve each and every sub-problem,
    then it will lead us to the result. For each element from *arr* we must make a
    decision. Mainly, we have two options: include the current element in the subset
    or not include it. Starting from these statements, we can create the following
    algorithm:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Define a subset as an array of the same length as the given *arr*. This array
    takes only values of 1 and 0.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively add each element from *arr* to the subset by setting a value of
    1 at that particular index. Check for the solution (*current sum = given sum)*.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively remove each element from the subset by setting a value of 0 at that
    particular index. Check for the solution (*current sum = given sum*).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The time complexity of this code is O(n2n), so it's far from being efficient.
    Now, let's try an iterative approach via Dynamic Programming. This way, we avoid
    solving the same problem repeatedly.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Programming approach
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Via Dynamic Programming, we can solve this problem in O(s*n). More precisely,
    we can rely on the *Bottom-Up* approach and a `boolean` bidimensional matrix of
    dimension (*n*+1) x (*s*+1), where *n* is the size of the set (*arr*).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this implementation, you have to understand how this matrix is
    filled up and how it is read. If we consider that the given *arr* is {5, 1, 6,
    10, 7, 11, 2} and *s*=9, then this `boolean` matrix starts from an initial state,
    as shown in the following diagram:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Initial matrix'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B15403.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Initial matrix
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have *s*+1 = 9+1 = 10 columns and *n*+1 = 7+1 = 8 rows. As you can see,
    we have filled up row and column 0\. These are the *base cases* and can be interpreted
    as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the first row (row 0) of the matrix (*matrix*[0][]) with 0 (or `false`,
    F) except *matrix*[0][0], which is initialized with 1 (or `true`, T). In other
    words, if the given sum is not 0, then there is no subset to satisfy this sum.
    However, if the given sum is 0, then there is a subset containing only 0\. So,
    the subset containing a 0 can form a single sum equal to 0.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the first column (column 0) of matrix (*matrix*[][0]) with 1 (or
    `true`, T) because, for any set, a subset is possible with 0 sum.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we take each row (5, 1, 6, ...) and we try to fill it up with F or T.
    Let''s consider the second row, which contains the element 5\. Now, for each column,
    let''s answer the following question: can we form a sum of *column number* with
    a 5? Let''s see the output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Filling up the second row'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B15403.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Filling up the second row
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 1 with a 5? No, so false (F).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we form a sum of 2 with a 5? No, so false (F).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 5 with a 5? Yes, so true (T).
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we form a sum of 6 with a 5? No, so false (F).
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Can we form a sum of 9 with a 5? No, so false (F).
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can try to apply this question to each of the remaining rows, but the more
    we advance, the harder it will be. Moreover, we cannot implement this question
    in code without an algorithm. Fortunately, we can employ an algorithm that can
    be applied to each (*row, column*) cell. This algorithm contains the following
    steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: While the element of the current row (*i*) is greater than the value of the
    current column (*j*), we just copy the preceding value (*i*-1, *j*), in the current
    (*i, j*) cell.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the element of the current row (*i*) is smaller than or equal to the value
    of the current column (*j*), then we look to the (*i*-1, *j*) cell and do the
    following:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If cell (*i*-1, *j*) is T, then we fill up the (*i, j*) cell with T as well.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: b. If cell (*i*-1, *j*) is F, then we fill up the (*i, j*) cell with the value
    at (*i*-1, *j-element_at_this_row*).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to the second row (containing the element 5), then
    we obtain the same result shown in the following diagram:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Applying the algorithm to the second row'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B15403.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Applying the algorithm to the second row
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to *step 1*, for 5 < 1, 5 < 2, 5 < 3, and 5 < 4, we copy the value
    from the preceding cell. When we reach cell (1, 5), we have 5=5, so we need to
    apply *step 2*. More precisely, we apply *step 2b*. The cell (1-1, 5-5) is the
    cell (0, 0) that has the value T. So, the cell (1, 5) is filled up with T. The
    same logic applies to the remaining cells. For example, cell (1, 6) is filled
    up with F since F is the value at (0, 5); the cell at (1, 7) is filled up with
    F since F is the value at (0, 6), and so on.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to all the rows, then we obtain the following filled
    matrix:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Complete matrix'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B15403.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Complete matrix
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we highlighted the last cell at (7, 9). If the right-bottom cell
    has the value T, then we say that there is at least a subset that satisfies the
    given sum. If it is F, then there is no such subset.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this case, there is a subset whose sum is equal to 9\. Can we identify
    it? Yes, we can, via the following algorithm:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Start from the right-bottom cell, which is T (let's say that this cell is at
    (*i*, *j*)).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the cell above this one, (*i*-1, *j*), is F, then write down the element
    at this row (this element is part of the subset) and go to cell (*i*-1, *j*-*element_at_this_row*).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: b. While the cell above this one, (*i*-1, *j*), is T, we go up the cell (*i*-1,
    *j*).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: c. Repeat this from *step 1a* until the entire subset is written down.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' s draw the path of the subset in our case:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Subset solution path'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B15403.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Subset solution path
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: So, we start from the bottom-right cell, which is at (7, 9) and has the value
    T. Because this cell is T, we can attempt to find the subset that has the sum
    9\. Next, we apply *step 1a*, so we write down the element at row 7 (which is
    2) and go to cell (7-1, 9-2) = (6, 7). So far, the subset is {2}.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply *step 1b*, so we land in cell (3, 7). The cell above (3, 7) has
    the value F, so we apply *step 1a*. First, we write down the element at row 3,
    which is 6\. Then, we go to cell (3-1, 7-6) = (2, 1). So far, the subset is {2,
    6}.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The cell above (2, 1) has the value F, so we apply *step 1a*. First, we write
    down the element at row 2, which is 1\. Then, we go to cell (2-1, 1-1) = (1, 0).
    Above cell (1,0), we have only T, so we stop. The current and final subset is
    {2, 6, 1}. Obviously, 2+6+1 = 9.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will clarify any other details (this code can tell if the
    given sum at least has a corresponding subset):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `printSubsetMatrix()` and `printOneSubset()` methods can be found in the
    complete code named *SubsetSum*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Word break (this is a famous Google problem)
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the given string (*str*) can be segmented into a space-separated
    sequence of dictionary words.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem is common to Google and Amazon and at the time of
    writing, it is adopted by a lot of medium-large companies. If we type a string
    that doesn''t make sense into Google, then Google attempts to break it down into
    words and asks us if that is what we actually tried to type. For example, if we
    type "thisisafamousproblem", then Google will ask us if we wanted to type "this
    is a famous problem".'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Plain recursion-based solution
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, if we assume that the given string is *str*`="`thisisafamousproblem" and
    the given dictionary is `{`"this" "is" "a" "famous" "problem"`}`, then we can
    form the result; that is,"this is a famous problem".
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we obtain this? How can we check if the given string can be segmented
    into a space-separated sequence of dictionary words?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an observation. If we start from the first character of the
    given string, then we notice that "t" is not a word in the given dictionary. We
    can continue by appending the second character to "t", so we get "th". Since "th"
    is not a word in the given dictionary, we can append the third character, "i".
    Obviously, "thi" is not a word in the dictionary, so we append the fourth character,
    "s". This time, we found a word because "this" is a word in the dictionary. This
    word becomes part of the result.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Taking this logic further, if we found "this", then the initial problem is reduced
    to a smaller problem that consists of finding the remaining words. So, by appending
    every character, the problem reduces to a smaller problem but essentially remains
    the same. This sounds like an ideal case for a recursive implementation.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'If we elaborate on the recursive algorithm, then we have the following steps
    that we must perform:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the given string, *str*, from the first character (*index* 0).
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take each substring from the given string (by substring, we understand substring
    from *index* to 1, substring from *index* to 2, ...substring from *index* to *str.length*).
    In other words, as long as the current substring is not a word in the given dictionary,
    we continue to add a character from the given string, *str*.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current substring is a word in the given dictionary, then we update the
    index so that it's the length of this substring and rely on recursion by checking
    the remaining string from *index* to *str.length*.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *index* reaches the length of the string, we return `true`; otherwise, we
    return `false`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no surprise that the runtime of this code is exponential. Now, it is
    time to deploy Dynamic Programming.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up solution
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can avoid recursion and deploy Dynamic Programming instead. More precisely,
    we can use the *Bottom-Up* solution shown here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code still runs in exponential time O(n2).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Trie-based solution
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The most efficient solution to solve this problem relies on Dynamic Programming
    and the Trie data structure since it provides the best time complexity. You can
    find a detailed implementation of the Trie data structure in the book *Java Coding
    Problems*: ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the problem of breaking a given string into a set of components
    representing its words. If *p* is a prefix of *str* and *q* is the suffix of *str*
    (the remaining characters), then *pq* is *str* (the concatenation of *p* with
    *q* is *str*). And, if we can break *p* and *q* into words via recursion, then
    we can break *pq = str* by merging the two sets of words.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue this logic in the context of a Trie representing the given
    dictionary of words. We can assume that *p* is a word from the dictionary, and
    we must find a way to construct it. This is exactly where the Trie comes in. Because
    *p* is considered a word from the dictionary and *p* is a prefix of *str*, we
    can say that *p* must be found in the Trie via a path consisting of the first
    few letters of *str*. To accomplish this via Dynamic Programming, we use an array,
    let''s denote it as *table*. Every time we find an appropriate *q*, we signal
    it in the *table* array by setting a solution at |*p*| + 1, where |*p*| is the
    length of the prefix, *p*. This means that we can continue by checking the last
    entry to determine if the whole string can be broken up. Let''s see the code for
    this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apparently, because we have two nested loops, the runtime of this solution is
    O(n2). Actually, the inner loop breaks if the node is `null`. And, in the worst-case
    scenario, this happens after *k* steps, where *k* is the deepest path in the Trie.
    So, for a dictionary that contains the longest word of size *z*, we have *k*=*z*+1\.
    This means that the time complexity of the inner loop is O(z) and that the total
    time complexity is O(nz). The extra space is O(*space of the Trie + str.length*).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete application is called *WordBreak*. This application also contains
    a method that prints all the strings that can be generated for the given string.
    For example, if the given string is "thisisafamousproblem" and the dictionary
    is `{"`this", "th", "is", "a", "famous", "f", "a", "m", "o", "u", "s", "problem"`}`,
    then the output will contain four sequences:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: th is is a f a m o u s problem
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: th is is a famous problem
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this is a f a m o u s problem
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this is a famous problem
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Done! Now, it's time to summarize this chapter.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered one of the most popular topics in interviews: recursion
    and Dynamic Programming. Mastering this topic requires a lot of practice. Fortunately,
    this chapter provided a comprehensive set of problems that covered the most common
    recursive patterns. From permutations to grid-based problems, from classical problems
    such as Tower of Hanoi to tricky problems such as generating curly braces, this
    chapter has covered a wide range of recursive cases.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that the key to solving recursive problems consists of drawing
    a meaningful sketch and practicing several cases. This way, you can identify patterns
    and recursive calls.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss problems that require bit manipulation.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
