- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The act of making system calls to accomplish tasks provided by the operating
    system is called **system programming**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling an operating system's interrupt handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Special instructions were added to the CPU to support system calls without the
    need to call an interrupt handler, which saves more of the CPU state prior to
    execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Most implementations of `malloc()`/`free()` ask for a large amount of memory
    from the operating system and then divide up that memory during the program's
    execution. A system call is only needed when this memory runs out and `malloc()`/`free()`
    must ask for more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Speculative execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type safety is the extent to which a programming language helps to prevent errors
    due to the differences between types. Strongly typed languages prevent these types
    of error more than weakly typed languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++ templates provide a user with the ability to define your code without having
    to define type information ahead of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes. Most of the C standard is also part of the POSIX standard. POSIX generally
    goes above and beyond to provide additional facilities specific to POSIX operating
    systems. Examples of C and POSIX functions include `read()` and `write()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_start()` is the entry point to an application and is usually provided by
    the C runtime facilities. `main()` is a function provided by the user and is usually
    the first function to execute in the user''s code, which is eventually called
    by the C runtime facilities once the application is fully initialized.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing global constructors and destructors, and initializing C++ exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++ name mangling embeds the entire signature of a function into the function's
    symbol. This is not only needed to provide support for function overloading in
    C++, but also ensures that the linker doesn't accidentally dynamically link two
    functions with the same name that have different signatures (which can happen
    in C).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C symbols are not mangled. C++ are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pointer can point to any memory, including a `nullptr`. A reference cannot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This depends on the CPU architecture. On some CPUs, a short `int` is 16 bits
    wide, while an `int` is 32 bits wide. This is not the case on all CPUs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This depends on the CPU architecture. On most CPUs, an `int` is 32 bits wide,
    but this is not always the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `int32_t` will always be 32 bits wide. On some CPUs, an `int` could be 16,
    32, or 64 bits wide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. These are called **exact-width** types and will always be the desired width.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensures that structures are not automatically padded by the compiler for optimizations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structured binding provides the ability to retrieve the result of a structure
    by manually providing individual variables, for example, `auto [first, second]
    = std::pair{1, 2}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now list nested namespace on the same line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You no longer need to provide an error message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides you with the ability to define a variable inside an `if` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource acquisition is initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To acquire and initialize a resource on construction and release the resource
    on destruction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: States who owns a pointer (that is, the entity responsible for deleting the
    pointer)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Expects()` defines a functions input expectations and `Ensures()` defines
    a function''s output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rax`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rdi`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: subtracts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A segment is a group of sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The information needed to handle exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Fork()` creates a new process, while `exec()` overwrites an existing process
    with a new program. Both are needed to launch a new program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process ID of the process that completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::cin` is type-aware.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capable of handling user-defined types providing cleaner, type-safe IO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Format specifiers are often more flexible than `#include <iomanip>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `std::endl` if a flush must occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::cerr` will flush after each write, while `std::clog` will not. Use `std::cerr`
    when handling errors to ensure that all debugging information is successfully
    flushed prior to a catastrophic issue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::internal`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using both `std::oct` and `std::uppercase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By leveraging a `gsl::span`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By leveraging the `rdbuf()` member function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`new()` allocates a single object, while `new()` allocates an array of objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global memory is visible to the entire program, while static memory (defined
    globally) is only visible to the source file in which it is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By leveraging an alias with the `alignas()` function, such as `using aligned_int
    alignas(0x1000) = int;`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not in C++17 and below
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::shared_ptr` should only be used if more than one object must own the
    memory (that is, the memory needs to be able to be released by more than one object
    in any order and at any time).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes (depending on the operating system and permissions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you allocate 4 bytes and use 3, you have created internal fragmentation (wasted
    memory). If you allocate memory in such a way that the allocator no longer has
    contiguous blocks of memory to give out (even if it has a lot of free memory),
    you have created external fragmentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`is_open()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::ios_base::in` | `std::ios_base::out`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` is read and a flag is set'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffer overflow errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/home/user`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This means that two instances of the same allocator are always equal, which
    in turn means that both allocators can allocate and deallocate each other's memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If two instances of the same allocator can allocate and deallocate each other's
    memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a container is copied, its allocator is also copied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides the container with the ability to create a copy of the allocator
    it was provided for a different type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `std::list`, `n ==1`; for `std::vector`, `n` can be any number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP is connectionless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SOCK_DGRAM`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SOCK_STREAM`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IPV4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Bind()` allocates a port, while `connect()` connects to a previously allocated
    port.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sendto()` takes the address as a parameter and is usually used by UDP, while
    `send()` is usually used by TCP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type safety.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thursday, 1 January 1970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of seconds since the UNIX epoch began.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`clock()` is relative to the execution of the program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Non-POSIX operating systems might support fractional time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper around `difftime()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A steady clock provides the actual time, while a high resolution timer provides
    a number that only provides a value when used with `duration{}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pthread_self()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are not type safe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When two threads race to read/write the same resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a thread waits on a synchronization primitive (for example, a mutex) that
    will never be released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A C++ future provides a type-safe mechanism for returning the result of a thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that a function is only executed once, regardless of the number of
    threads that call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::shared_mutex` provides the ability to support multiple readers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allows a single thread to lock the same mutex more than once without entering
    deadlock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ exceptions do not need to check the return result of every function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: POSIX-style functions must reserve a part of a function's output to convey an
    error. For example, if a function must return a file handle, `0` is returned in
    the event of an error, which means that a file handle cannot have the value `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set jump does not unwind the stack, which means destructors are skipped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`catch(...)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instructions on how to unwind a stack must be stored for every function. This
    is the tradeoff for increased performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are slow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
