- en: Angular Cloud-Based Mapping with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have spent quite a few chapters writing our own backend systems for returning
    information to the client. In the last few years, there has been a trend toward
    using third-party cloud systems. Cloud systems can help lower the costs of writing
    applications, because other companies provide all of the infrastructure that we
    need to use and take care of testing, upgrades, and so on. In this chapter, we
    are going to look at using cloud infrastructure from the Bing mapping team and
    Firebase to provide data storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Signing up to Bing mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implications of billable cloud features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing up to Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a map component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using map search features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `EventEmitter` to notify parent components of child component events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reacting to mapping events to add and remove your own points of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlaying map search results on the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tidying up event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data to Cloud Firestore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Cloud Firestore authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications and the move to cloud services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have been concentrating on writing applications where
    we control the infrastructure on which the application runs and where the data
    is physically stored. Over the last few years, the trend has been to move away
    from this type of application toward a model where other companies provide this
    infrastructure through something called **cloud-based services**. *Cloud services*
    has become a catch-all marketing term to describe the trend of using on-demand
    services from other companies, relying on them to provide application features,
    security, scaling, backup features, and so on. The idea behind this is that we
    can reduce capital costs by letting others take care of these features for us,
    freeing us to write applications that make use of these features in a mix-and-match
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at using cloud-based services from Microsoft
    and Google, so we will look at the process of signing up to these services, the
    implications of using them, and how to make use of them in our final Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our last Angular application, we are going to go to town and use Bing mapping
    services to display the types of maps we are used to using on a daily basis to
    search for locations. We will go even further and use Microsoft's Local Insights
    services to search for a particular business type in the currently visible map
    area. This is one of the two applications that excited me the most when I was
    putting together the plan for this book because I have a love for map-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: As well as displaying maps, we are going to be able to select points of interest
    on the map by clicking directly on the map. These points will be represented by
    colored pins. We will save the location of these points, along with their name,
    in a cloud-based database from Google.
  prefs: []
  type: TYPE_NORMAL
- en: This application should take about an hour to complete, as long as you work
    alongside the code on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will no longer provide details about how to add
    packages using `npm`, or how to create Angular applications, components, or the
    like, as you should be familiar with how to do this by this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'When completed, the application should look like this (maybe not zoomed into
    Newcastle upon Tyne, though):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0f765d2-db52-41cc-88eb-8488d2516510.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting started with Bing mapping in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our last Angular application, so we will start off by creating it in
    the same way we created applications in previous chapters. Again, we are going
    to use Bootstrap, rather than Angular Material.
  prefs: []
  type: TYPE_NORMAL
- en: 'The packages we are going to concentrate on in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bootstrap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bingmaps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firebase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guid-typescript`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are going to be hooking our code up to cloud-based services, we will
    have to sign up to them first. In this section, we will look at what we need to
    do to sign up.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up to Bing mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to use Bing Maps, we have to sign up to Bing Map Services. Navigate
    to [https://www.bingmapsportal.com](https://www.bingmapsportal.com) and click
    the Sign in button. This requires a Windows account, so if you don''t have one,
    you will need to set one up. For now, we are going to assume that you have a Windows
    account available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/082d18cf-f170-4e4b-b7e7-0efef3da47b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we sign in, we need to create a key that our application will use to identify
    itself to the Bing Map Services so that they know who we are and can keep track
    of our map usage. From the My account option, select My Keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/871b25e0-38ce-4aef-a2e5-975fe4c172d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the keys screen appears, you will see a link called Click here to create
    a new key. Clicking the link will show the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c03c1b67-b41c-45c7-977e-d4058f3f05ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of the information on this screen is fairly self-explanatory. The application
    name is used if we have multiple keys and we need to search for them. The URL
    doesn't have to be set, but I like to do this if I am deploying to different web
    applications. It's a handy way to remember which key is associated with which
    application. Since we aren't going to be going for the paid-for enterprise service,
    the only key type that we have available is Basic.
  prefs: []
  type: TYPE_NORMAL
- en: The Application type is probably the most important field on here, from our
    point of view. There are a number of application types that we can choose from,
    each of which has limitations around the number of transactions that it can accept.
    We are going to stick with Dev/Test, which limits us to 125,000 billable transactions,
    cumulatively, over a year-long period.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the Local Insights code in this chapter, this will generate billable
    transactions. If you don't want to run the risk of incurring any costs, I would
    recommend that you disable the code that does this searching.
  prefs: []
  type: TYPE_NORMAL
- en: When we click Create, our map key is created, and is available by clicking the
    Show key or Copy key links in the table that appears. We have now set up everything
    that we need for the map key, so let's move on to signing up to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up to Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firebase requires a Google account. Assuming we have one available, we can
    access the features of Firebase at [https://console.firebase.google.com/](https://console.firebase.google.com/).
    When this screen appears, click the Add project button to start the process of
    adding Firebase support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d9dd8ac-8931-4642-88ce-77e2c20ff855.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose a meaningful name for the project. Before we can create the project,
    we should read the terms and conditions for using Firebase and tick the checkbox
    if we agree with them. Note that if we choose to share usage statistics for Google
    Analytics, we should read the appropriate terms and conditions and check the controller-controller
    terms checkbox as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae904ea1-6b3a-4983-8162-a7d375eb5e19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having clicked Create project, we now have access to the Firebase project.
    While Firebase, as a cloud services provider, is more than just a database, offering
    storage, hosting, and so on, we are just going to use the Database option. When
    we click the Database link, we are presented with the Cloud Firestore screen,
    where we need to click Create database to start the process of creating the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f550f6f4-904d-429c-b822-81af8bd6ac94.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever I refer to Firebase in this chapter, I am using this as a shorthand
    way of saying that this is the Firestore feature of the Firebase cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: While we are creating the database, we will need to choose the level of security
    that we want to apply to our database. We have two options here. We can start
    with the database locked so that reading and writing is disabled. Access to the
    database will then have to be enabled by writing rules that the database will
    check to determine whether or not a write is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, though, we are going to start in test mode, which allows
    unlimited reads and writes to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/78fe0e8c-0642-4993-a5c7-305d5fdbd2d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Like Bing mapping, Firebase has usage limitations and cost implications. We
    are creating a Spark plan datastore, which is the free Firebase version. This
    version comes with hard limits, such as only being able to store 1 GB of data
    per month, with 50,000 reads a day and 20,000 writes a day. For details around
    pricing and limitations, please read [https://firebase.google.com/pricing](https://firebase.google.com/pricing)/.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have clicked Enable and have a database available, we need to be able
    to get access to the key and project details that Firebase creates for us. To
    find this, click the Project overview link on the menu. The </> button pops up
    a screen that shows the details we will need to copy for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85b83eb6-5b9f-44b1-a89c-344c0bca061e.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have our cloud infrastructure set up and have the keys and details we
    need available. We are now ready to write our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Bing Maps application using Angular and Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fastest-growing application types over the last few years has been
    the explosion of mapping applications, whether for your satnav system or running
    Google Maps on your phone. Underneath these applications lie mapping services
    that have been developed by companies such as Microsoft or Google. We are going
    to use the Bing Maps services to add mapping support to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our mapping application has the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on a location will add that location as a point of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a point of interest is added, an information box will be displayed, showing
    details about it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on a point of interest again will delete it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Points of interest will be saved to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to move the point of interest, updating details in the
    database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where available, business information will be automatically retrieved and displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the map component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create two Angular components for this step—one called `MappingcontainerComponent`,
    and another called `MapViewComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: I broke these up because I wanted to use `MappingcontainerComponent` to contain
    the bootstrap infrastructure, while `MapViewComponent` will just contain the map
    itself. If you want to, you can combine these together, but for the purposes of
    establishing a clear delineation to describe what is going on with each part,
    it was easier for me to create two components here. This does mean that we need
    to introduce some coordination between the two components, which will reinforce
    the `EventEmitter` behavior we covered in [Chapter 5](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml),
    *Angular ToDo App with GraphQL and Apollo*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add any body to these components, we have some models and services
    that we need to write to provide the infrastructure that our map and data access
    will need.
  prefs: []
  type: TYPE_NORMAL
- en: Points of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each point of interest is represented by a pin, and can be represented as latitude
    and longitude coordinates, along with its name.
  prefs: []
  type: TYPE_NORMAL
- en: Latitude and longitude are geographic terms that are used to identify exactly
    where something is on the planet. Latitude tells us how far north or south something
    is from the equator, with the equator being 0\. This means that a positive number
    indicates we are north of the equator, and a negative number means we are going
    south from the equator. Longitude tells us how far east or west we are from the
    vertically centered line of the earth which, by convention, runs through Greenwich
    in London. Again, if we are moving east, the numbers are positive, while moving
    west from the line at Greenwich means the numbers will be negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model that represents this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will be referring to both pins and points of interest throughout this section.
    They both represent the same thing, so we will be using them interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create an instance of this, we are going to use a GUID to represent
    it. Since the GUID is unique, we use it as a convenient way to find the point
    of interest when we move or remove it. This isn''t the exact representation of
    the way we are going to store our model in the database because this identifier
    is intended to make sense for tracking the pins on the map, not for tracking the
    pins in the database. To that end, we are going to add a separate model that we
    will use to store the model item in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We create this as an interface because Firebase expects to receive data only,
    with no class infrastructure surrounding it. We could have created `PinModel`
    as an interface as well, but the syntax for instantiating it is slightly more
    cumbersome, which is why we chose to create it as a class.
  prefs: []
  type: TYPE_NORMAL
- en: With the models in place, we are now ready to hook up to Firebase. Rather than
    using the Firebase `npm` directly, we are going to use the official Angular Firebase
    library, called `AngularFire`. The `npm` reference for this is `@angular/fire`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we set up our Firebase datastore, we got the settings that we need to
    create a uniquely identified connection to it. We are going to copy these settings
    into our `environment.ts` and `environment.prod.ts` files. When we publish an
    application to production, Angular remaps `environment.prod.ts` to the environment
    file so that we can have separate dev and production settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's generally bad practice to use the same endpoints for dev and production
    systems, so you could create a separate Firebase instance to hold the production
    mapping information and store that in `environment.prod.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: In `app.module`, we are going to import the `AngularFire` modules and then reference
    them in the imports. When we reference `AngularFireModule`, we call the static
    `initializeApp` method that will use the `environment.firebase` setting to establish
    a connection to Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `import` statements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the Angular `imports`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For Firebase''s functionality, it''s helpful to have a service as a single
    point of implementation for interacting with the database itself. That''s why
    we are going to create a `FirebaseMapPinsService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this class, we are going to use a feature from `AngularFire` called
    `AngularFirestoreCollection`. Firebase exposes the `Query` and `CollectionReference`
    types to perform CRUD operations on the underlying data from the database. `AngularFirestoreCollection`
    wraps this behavior into a handy stream for us. We set the generic type to `PinModelData`
    to say what data will be saved to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our service is going to provide a model that creates an observable of a `PinModelData`
    array that hooks into the `pins` property. The way that we hook this all together
    lies inside the constructor that receives the `AngularFirestore`. The `pins` collection
    is associated with the underlying collection by passing in the name of the collection
    that will be stored in the database (which saves the data as documents in JSON).
    Our `Observable` listens to `valueChanges` on the collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the decisions I took when designing this application was that removing
    a pin from the UI should result in removing the associated point of interest from
    the database. Since it isn''t being referenced by anything else, we don''t need
    to keep it as reference data. Deleting the data is as simple as using `doc` to
    get the underlying document record from the datastore using the `storageId`, and
    then deleting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user adds a point of interest, we want to create a corresponding entry
    in the database, but when they move the pin, we want to update the record. Rather
    than using separate `Add` and `Update` methods, we can combine the logic into
    one method because we know that a record that has an empty `storageId` has not previously been
    saved to the database. Therefore, we give it a unique ID using the Firebase `createId`
    method. If `storageId` is present, then we want to update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Representing the map pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s all very well us being able to save the pins to the database, but we
    also need a way to represent the pins on the map so that we can show them during
    the map session and move them as needed. This class will also act as the connection
    to the data service. The class that we are going to write will demonstrate a neat
    little trick introduced in TypeScript 3, called **rest tuples**, and starts off
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first feature we are going to introduce deals with adding the data for
    a pin when the user clicks on the map. The signature for this method looks a little
    bit strange, so we''ll take a minute or so to cover how it works. This is what
    the signature looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we see `...args` as the last (or only) parameter, our immediate thought
    here is that we are going to be using a REST parameter. If we break the parameter
    list down from the start, we can think of this as starting off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That almost looks like it makes sense, but there''s another REST parameter
    in there. This basically says that we can have any number of numbers at the end
    of the tuple. The reason that we have to apply `...` to this, rather than just
    applying `number[]`, is because we need to spread the elements out. If we just
    used the array format, we would have to push elements into this array in the calling
    code. With the REST parameter in the tuple, we can pull the data out, save it
    to the database, and add it to our `pins` array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The implication of using a tuple like this is that the calling code has to make
    sure that it is putting values into the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we get to the code to call this, we can see that our method is called
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user moves a pin on the map, we will use a similar trick to update
    its location. All we need to do is find the model in our array and update its
    values. We even have to update the name because the act of moving the pin will
    change the address of the pin. We call the same `Save` method on our data service
    just like we did in our `Add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Other classes will need access to the data from the database too. We face two
    choices here—we could either have other classes also use the Firebase map service
    and potentially miss out calls to this class, or we could make this class the
    sole point of access to the map service. We are going to rely on this class to
    be the single point of contact with `FirebaseMapPinsService`, which means that
    we need to expose the `model` through a `Load` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing a point of interest uses a much simpler method signature than adding
    or moving one. All we need is the client-side `id` of the record, which we use
    to find the `PinModelData` item and call `Delete` to remove from Firebase. Once
    we have deleted the record, we find the local index of this record and remove
    it by splicing the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Trying interesting things with map searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to getting the name of the location where the user has placed
    the pin, or moved it to, we want this to happen automatically. We really don't
    want the user to have to type in this value when mapping can pick this for us
    automatically. This means that we are going to have to use mapping features to
    get this information for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bing mapping has a number of optional modules, which we can opt into using,
    that give us the ability to do things such as searches based on location. In order
    to do this, we are going to create a class called `MapGeocode` that will do the
    searching for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that, for some of our classes, we are creating them without creating
    services. This implies that we are going to have to take care of manually instantiating
    the class ourselves. That is fine since we can control the lifetime of our class
    manually. If you want to, when you are recreating the code, you could convert
    classes such as `MapGeocode` into a service and inject it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since search is an optional feature, we need to load it in. To do that, we
    are going to pass in our map and use `loadModule` to load the `Microsoft.Maps.Search`
    module, passing in a new instance of `SearchManager` as the option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains for us to do is write a method to perform the lookup. Since
    this could be a lengthy operation, we need to make this a `Promise` type, returning
    the string that will be populated with the name. Inside this `Promise`, we create
    a request containing the location and a callback that, when executed by the `reverseGeocode`
    method, will update the callback in the `Promise` with the name of the location.
    With this in place, we call `searchManager.reverseGeocode` to perform the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Names matter in coding. In mapping, when we geocode, we convert a physical address
    into a location. The act of converting a location into an address is called **reverse
    geocoding**. That is why our method has the rather cumbersome name of `ReverseGeocode`.
  prefs: []
  type: TYPE_NORMAL
- en: There is another type of search that we need to consider. We want a search that
    uses the visible map area (the viewport) to identify coffee shops in that area.
    To do this, we are going to use Microsoft's new Local Insights API to search for
    things such as businesses in a given area. There is a limitation to this implementation
    right now, in that Local Insights are only available for US addresses, but there
    are plans to roll this feature out across other countries and continents.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show that we can still use mapping in services, we are going to create a
    `PointsOfInterestService` that accepts an `HttpClient`, which we will use to get
    the results of the REST call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The REST call endpoint accepts a query that tells us what type of businesses
    we are interested in, the location to use to perform the search, and the map key.
    Again, our search functionality could be long-running, so we will return a `Promise`,
    this time of a custom `PoiPoint` that returns the latitude and longitude, as well
    as the name of the business:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the API, we are going to use `http.get`, which returns an observable.
    We are going to `pipe` the result and `map` it using `MapData`. We will `subscribe`
    to the result and parse the results down (note that we don''t really know the
    returning type, so we will leave this as `any`). The returning type can contain
    multiple `resourceSets`, mostly for if we were going to have multiple types of
    query at once here, but we only have to concern ourselves with the initial `resourceSet`,
    which we will then use to extract the resources. The following code shows the
    format of the elements we are interested in from this search. When we have finished
    parsing our results, we are going to unsubscribe from the search subscription
    and call back on the `Promise` with the points we have just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our query, we are simply going to search at a point—we can easily extend
    this to search in a bounding box restricted to our view, if we wanted to, by accepting
    the map bounding box and changing `userLocation` to `userMapView=${boundingBox{0}},${boundingBox{1}},${boundingBox{2}},${boundingBox{3}}`
    (where `boundingBox` is a rectangle). For further details about extending the
    search, see [https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10)](https://docs.microsoft.com/en-us/previous-versions/mt832854(v=msdn.10)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the map searching functionality and the database functionality
    done, wouldn't it be great to actually put a map on the screen? Let's take care
    of that now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Bing Maps to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like we covered previously, we are going to use two components to display the
    maps. Let''s start with the `MapViewComponent`. The HTML template for this control
    is really straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, that really is all there is to our HTML. What goes on behind it is a bit
    more complicated, and this is where we are going to learn how Angular lets us
    hook into standard DOM events. We normally don''t show the whole `@Component`
    element because it is pretty much boilerplate code, but in this case, we are going
    to have to do something a little bit different. Here''s the first part of our
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `@Component` section, we hook the window load event up to the `Loaded`
    method. We will add this method shortly, but for now, it's important to know that
    this is how we hook a component up to an event from the host. Inside the component,
    we use an `@ViewChild` to hook up to the `div` in our template. Basically, this
    allows us to reference an element inside our view by name so that we can work
    with it in some arbitrary way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we added a `Loaded` method is because Bing Maps have a particularly
    nasty habit of not working properly in browsers such as Chrome or Firefox unless
    we hook the map up in the `window.load` event. We are going to host the map inside
    the `div` statement we added to the template using a series of map load options,
    which includes the map credentials and the default zoom level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to choose a particular type of map type to display, we can set this
    in the map load options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `MapViewComponent` is going to be hosted inside another component, so we
    will create an `EventEmitter` that we can use to notify the parent. We already
    added the emit code in our `Loaded` method, passing the map we just loaded back
    to the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the parent container now. Most of the template is just taken up
    with creating the Bootstrap containers with the rows and columns. Inside the `div` column, we
    are going to host the child component we just created. Again, we can see that
    we use the `EventEmitter`, so when the map is emitted, it triggers the `MapLoaded`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the mapping container code should be familiar territory to us by now.
    We inject `FirebaseMapPinsService` and `PointsOfInterestService`, which we use
    to create a `MapEvents` instance in the `MapLoaded` method. In other words, when
    the `atp-map-view` component hits `window.load`, the populated Bing map comes
    back through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A note on displaying the map—we really need to set the height of `html` and
    `body` so that it stretches to the full height of the browser window. Set this
    in the `styles.scss` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The map events and setting pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have maps, and we have the logic to save points of interest to databases
    and to move them in memory. The one thing we don''t have is the code to handle
    the user actually creating and managing the pins from the map itself. It''s time
    to rectify that situation and add in a `MapEvents` class that will handle this
    for us. Just like the `MapGeocode`, `PinModel`, and `PinsModel` classes, this
    class is a standalone implementation. Let''s start by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Infobox` is the box that appears when we add a point of interest to the screen.
    We could add a new one when each point of interest is added, but this would be
    a waste of resources. Instead, we are going to add a single `Infobox` and reuse
    it when we add new points on the screen. To do this, we are going to add a helper
    method that checks whether the `Infobox` has been set or not previously. If it
    has not been set before, we will instantiate a new instance of the `Infobox`,
    taking in the pin location, the title, and description. We will be supplying the
    name of the point as the description. We need to set the map instance that this
    will appear on using `setMap`. When we reuse this `Infobox`, all we need to do
    is set the same values in the options and then set the visibility to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of helper methods we still need to add to this class before
    we add the ability to select points from the map. The first one we are going to
    add takes the points of interest from the Local Insights search and adds them
    to the map. Here, we can see that the way that we add a pin is to create a green
    `Pushpin`, which then gets added onto our Bing map at the correct `Location`.
    We also add an event handler that reacts to a click on the pin and shows the `Infobox`
    using the method we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next helper method is more complicated, so we will add it in stages. The
    `AddPushPin` code is going to be called when the user clicks on the map. The signature
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we are going to do in this method is create a `Guid` to
    use when we add a `PinsModel` entry and add a draggable `Pushpin` at the click
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are going to call the `ReverseGeocode` method we wrote
    earlier. When we get the result from this, we will add our `PinsModel` entry and
    push the `Pushpin` onto the map before we show the `Infobox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t finished with this method yet. As well as adding a `Pushpin`, we
    also have to be able to drag it so that the user can choose a new location for
    it when they drag the pin. We are going to use the `dragend` event to move the
    pin. Again, the hard work we put in earlier pays dividends, because we have a
    simple mechanism to `Move` the `PinsModel` and display our `Infobox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when the user clicks a pin, we want to remove the pin from the `PinsModel`
    and the map. When we added the event handlers for `dragend` and `click`, we saved
    the handlers to variables so that we can use them to remove the event handlers
    from the map events. Tidying up after ourselves is good practice, especially when
    dealing with things like event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that''s our helper methods in place. All we need to do now is update
    the constructor to add the ability to `click` on the map to set a point of interest
    and search for Local Insights when the viewport that the user is looking at changes.
    Let''s start with responding to the user clicking on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to store the handler as a variable here because we are associating
    it with something that won't be removed at any stage while the application is
    live in the browser; namely, the map itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user moves the map around so that they can see other areas, we need
    to perform the Local Insights search and, based on the results that come back,
    add the points of interest. We attach an event handler to the map `viewchangeend`
    event to trigger this search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We keep seeing that preparing methods beforehand can save us so much time later
    on. We are simply leveraging the `PointsOfInterestService.Search` method to do
    our Local Insights search for us, and then pumping the results into our `AddPoi`
    method if we get any back. If we don't want to perform the Local Insights search,
    we can simply remove this event handler and won't need to do any searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing that we have left to do is handle the loading in of our pins
    from the database. The code here is a variation of the code we have seen already
    for adding the `click` and `dragend` handlers, but we don''t need to perform the
    geocoding, since we already have the name of each point of interest. Therefore,
    we aren''t going to reuse the `AddPushPin` method. Instead, we will opt to do
    this whole section inline. The load subscription looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The point to note with this code snippet is that, since we are dealing with
    a subscription, once we have completed the subscription, we `unsubscribe` from
    it. The subscription should return an array of `PinModelData` items that we iterate
    over, adding in the elements as needed.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We now have a working mapping solution in place. This was one of
    the chapters I was looking forward to writing the most because I love mapping
    applications. I hope you have as much fun with this as I have. Before we leave
    this chapter, though, if you want to prevent people from getting unsecured access
    to the data, you can apply that knowledge in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is an optional overview of what we would need to do to provide
    security for the database. As you may remember, when we created our Firestore
    database, we set it up so that access was available to anyone, completely unrestricted.
    That's fine while you're developing a small test application, but it's generally
    not what you are going to want to deploy as a commercial application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to change the configuration of our database so that we only allow
    read/write access if the authorization ID is set. To do this, select the Rules
    tab in the Database and add `if request.auth.uid != null;` to the rules list.
    The format of `match /{document=**}` simply means that this rule applies to any
    document in the list. It is possible to set up rules that would only apply to
    certain documents, but that doesn't make much sense in the context of an application
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that doing this means that we would have to add in authentication, just
    like we did in [Chapter 6](9b60d7b2-7831-4125-b975-4a10c32b1cae.xhtml), *Building
    a Chat Room Application Using Socket.IO*. Setting this up is outside the scope
    of this chapter, but copying over the navigation and providing login features
    from the previous chapter should be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7bd73cd5-8073-493f-aefe-9725e47bee1c.png)'
  prefs: []
  type: TYPE_IMG
- en: This has been quite a journey. We have gone through the process of signing up
    for different online services and brought mapping features into our code. At the
    same time, we have seen how we can scaffold an Angular application with TypeScript
    support, without having to generate and register services. You should now be able
    to take this code and look to add the mapping features that you really want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reached the conclusion of projects that work with Angular,
    which we introduced using cloud services from Microsoft and Google in the form
    of Bing Maps and Firebase cloud services for storing data. We signed up to these
    services and obtained the relevant information from them in order to set up client
    access to them. In the course of writing our code, we have created classes to
    work with the Firestore database and interact with Bing Maps to do things such
    as search for addresses based on user clicks, leading to us adding pins to a map,
    as well as searching for coffee shops using Local Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing our journey of TypeScript, we introduced rest tuples. We also saw
    how to add code to Angular components to react to browser host events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to revisit React. This time, we will be creating
    a limited microservice CRM that uses Docker to contain the various microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Angular allow us to interact with a host element?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are latitude and longitude?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of reverse geocoding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What service are we using to store our data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
