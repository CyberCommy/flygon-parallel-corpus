- en: Chapter 2. Using PHP 7 High Performance Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will discuss and understand the syntax differences between
    PHP 5 and PHP 7, featuring the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the abstract syntax tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding differences in parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding differences in `foreach()` handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance using PHP 7 enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a massive file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading a spreadsheet into a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive directory iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will move directly into PHP 7, presenting recipes that take
    advantage of new high performance features. First, however, we will present a
    series of smaller recipes that serve to illustrate the differences in how PHP
    7 handles parameter parsing, syntax, a `foreach()` loop, and other enhancements.
    Before we go into depth in this chapter, let's discuss some basic differences
    between PHP 5 and PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7 introduced a new layer referred to as the **Abstract Syntax Tree** (**AST**),
    which effectively decouples the parsing process from the pseudo-compile process.
    Although the new layer has little or no impact on performance, it gives the language
    a new uniformity of syntax, which was not possible previously.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of AST is the process of *dereferencing*. Dereferencing, simply
    put, refers to the ability to immediately acquire a property from, or run a method
    of, an object, immediately access an array element, and immediately execute a
    callback. In PHP 5 such support was inconsistent and incomplete. To execute a
    callback, for example, often you would first need to assign the callback or anonymous
    function to a variable, and then execute it. In PHP 7 you can execute it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the abstract syntax tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, it might be of interest for you to be free from certain syntax
    restrictions imposed in PHP 5 and earlier. Aside from the uniformity of the syntax
    mentioned previously, where you'll see the most improvement in syntax is the ability
    to call any return value, which is **callable** by simply appending an extra set
    of parentheses. Also, you'll be able to directly access any array element when
    the return value is an array.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any function or method that returns a callback can be immediately executed
    by simply appending parentheses `()` (with or without parameters). An element
    can be immediately dereferenced from any function or method that returns an array
    by simply indicating the element using square brackets `[];`. In the short (but
    trivial) example shown next, the function `test()` returns an array. The array
    contains six anonymous functions. `$a` has a value of `$t`. `$$a` is interpreted
    as `$test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'AST allows us to issue the `echo $$a()[1]()[2](100)` command. This is parsed
    left-to-right, which executes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$$a()` interprets as `test()`, which returns an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1]` dereferences array element `1`, which returns a callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()` executes this callback, which returns an array of two elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2]` dereferences array element `2`, which returns a callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(100)` executes this callback, supplying a value of `100`, which returns `Level
    1/2:101`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Such a statement is not possible in PHP 5: a parse error would be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a more substantive example that takes advantage of AST syntax
    to define a data filtering and validating class. First of all, we define the `Application\Web\Securityclass`.
    In the constructor, we build and define two arrays. The first array consists of
    filter callbacks. The second array has validation callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to call this functionality in a *developer-friendly* manner.
    Thus, if we want to filter digits, then it would be ideal to run a command such
    as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish this we define the magic method `__call()`, which gives us access
    to non-existent methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use `preg_match()` to match the `$method` param against `filter` or `validate`.
    The second sub-match will then be converted into an array key in either `$this->filter`
    or `$this->validate`. If both sub-patterns produce a sub-match, we assign the
    first sub-match to `$prefix`, and the second sub-match `$function`. These end
    up as variable parameters when executing the appropriate callback.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t go too crazy with this stuff!**'
  prefs: []
  type: TYPE_NORMAL
- en: As you revel in your new found freedom of expression, made possible by AST,
    be sure to keep in mind that the code you end up writing could, in the long run,
    be extremely cryptic. This will ultimately cause long-term maintenance problems.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we create a sample file, `chap_02_web_filtering_ast_example.php,`
    to take advantage of the autoloading class defined in [Chapter 1](ch01.html "Chapter 1. Building
    a Foundation"), *Building the Foundation*, to obtain an instance of `Application\Web\Security`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a block of test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call each filter and validator for each item of test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of some input strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on AST, please consult the RFC that addresses the **Abstract
    Syntax Tree**, which can be viewed at [https://wiki.php.net/rfc/abstract_syntax_tree](https://wiki.php.net/rfc/abstract_syntax_tree).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding differences in parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In PHP 5, expressions on the right side of an assignment operation were parsed
    *right-to-left*. In PHP 7, parsing is consistently *left-to-right*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable-variable is a way of indirectly referencing a value. In the following
    example, first `$$foo` is interpreted as `${$bar}`. The final return value is
    thus the value of `$bar` instead of the direct value of `$foo` (which would be
    `bar`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example we have a variable-variable `$$foo`, which references a
    multi-dimensional array with a `bar key` and a `baz sub-key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 5, parsing occurs right-to-left, which means the PHP engine would be
    looking for an `$foo array`, with a `bar key` and a `baz`. sub-key The return
    value of the element would then be interpreted to obtain the final value `${$foo['bar']['baz']}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In PHP 7, however, parsing is consistently left-to-right, which means that `$foo`
    is interpreted first `($$foo)['bar']['baz']`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next example you can see that `$foo->$bar[''bada'']` is interpreted
    quite differently in PHP 5, compared with PHP 7\. In the following example, PHP
    5 would first interpret `$bar[''bada'']`, and reference this return value against
    a `$foo object instance`. In PHP 7, on the other hand, parsing is consistently
    left-to-right, which means that `$foo->$bar` is interpreted first, and expects
    an array with a `bada element`. You will also note, incidentally, that this example
    uses the PHP 7 *anonymous class* feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example is the same as the one immediately above, except that the
    return value is expected to be a callback, which is then immediately executed
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the code examples illustrated in 1 and 2 into a single PHP file that
    you can call `chap_02_understanding_diffs_in_parsing.php`. Execute the script
    first using PHP 5, and you will notice that a series of errors will result, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for the errors is that PHP 5 parses inconsistently, and arrives
    at the wrong conclusion regarding the state of the variable variables requested
    (as previously mentioned). Now you can go ahead and add the remaining examples,
    as shown in steps 5 and 6\. If you then run this script in PHP 7, the results
    described will appear, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on parsing, please consult the RFC, which addresses **Uniform**
    **Variable Syntax**, and can be viewed at [https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding differences in foreach() handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain relatively obscure circumstances, the behavior of code inside a `foreach()`
    loop will vary between PHP 5 and PHP 7\. First of all, there have been massive
    internal improvements, which means that in terms of sheer speed, processing inside
    the `foreach()` loop will be much faster running under PHP 7, compared with PHP
    5\. Problems that are noticed in PHP 5 include the use of `current()`, and `unset()`
    on the array inside the `foreach()` loop. Other problems have to do with passing
    values by reference while manipulating the array itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In both PHP 5 and 7, the output would appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add an assignment before the loop, however, the behavior changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the output of PHP 5 and 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| PHP 5 | PHP 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1****3** | **1****2****3** |'
  prefs: []
  type: TYPE_TB
- en: 'Working with functions that reference the internal array pointer also caused
    inconsistent behavior in PHP 5\. Take the following code example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every array has an internal pointer to its `current` element starting from `1`,
    `current()` returns the current element in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the output running in PHP 7 is normalized and consistent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| PHP 5 | PHP 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1 - 2****2 - 3****3 - 0** | **1 - 1****2 - 1****3 - 1** |'
  prefs: []
  type: TYPE_TB
- en: 'Adding a new element inside the `foreach()` loop, once the array iteration
    by reference is complete, is also problematic in PHP 5\. This behavior has been
    made consistent in PHP 7\. The following code example demonstrates this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| PHP 5 | PHP 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1 -** | **1 -****2-** |'
  prefs: []
  type: TYPE_TB
- en: Another example of bad PHP 5 behavior addressed in PHP 7, during array iteration
    by reference, is the use of functions that modify the array, such as `array_push()`,
    `array_pop()`, `array_shift()`, and `array_unshift()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Have a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| PHP 5 | PHP 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1****2****1****1** | **1****2** |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, we have a case where you are iterating through an array by reference,
    with a nested `foreach()` loop, which itself iterates on the same array by reference.
    In PHP 5 this construct simply did not work. In PHP 7 this has been fixed. The
    following block of code demonstrates this behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| PHP 5 | PHP 7 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0 - 0****0 - 1****0 - 3** | **0 - 0****0 - 1****0 - 3****3 - 0****3 -3**
    |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add these code examples to a single PHP file, `chap_02_foreach.php`. Run the
    script under PHP 5 from the command line. The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the same script under PHP 7 and notice the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, consult the RFC addressing this issue, which was accepted.
    A write-up on this RFC can be found at: [https://wiki.php.net/rfc/php7_foreach](https://wiki.php.net/rfc/php7_foreach).'
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance using PHP 7 enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One trend that developers are taking advantage of is the use of **anonymous
    functions**. One classic problem, when dealing with anonymous functions, is to
    write them in such a way that any object can be bound to `$this` and the function
    will still work. The approach used in PHP 5 code is to use `bindTo()`. In PHP
    7, a new method, `call()`, was added, which offers similar functionality, but
    vastly improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To take advantage of `call()`, execute an anonymous function in a lengthy loop.
    In this example, we will demonstrate an anonymous function, that scans through
    a log file, identifying IP addresses sorted by how frequently they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Web\Access class`. In the constructor, we accept
    a filename as an argument. The log file is opened as an `SplFileObject` and assigned
    to `$this->log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a generator that iterates through the file, line by line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define a method that looks for, and extracts as a sub-match, an
    IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we define a calling program, `chap_02_performance_using_php7_enchancement_call.php`,
    that takes advantage of the autoloading class defined in [Chapter 1](ch01.html
    "Chapter 1. Building a Foundation") , *Building a Foundation,* to obtain an instance
    of `Application\Web\Access`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the anonymous function, which processes one line in the log
    file. If an IP address is detected, it becomes a key in the `$frequency array`,
    and the current value for this key is incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then loop through the iteration of lines in each log file found, processing
    IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can actually do the same thing in PHP 5\. Two lines of code are required,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Performance is 20% to 50% slower than using `call()` in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we reverse-sort the array, but maintain the keys. The output is produced
    in a simple `foreach()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will vary depending on which `access.log` you process. Here is a
    sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the PHP 7 performance improvements have nothing to do with new features
    and functions. Rather, they take the form of internal improvements, which are
    *invisible* until you start running your programs. Here is a short list of improvements
    that fall into this category:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | More info: | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fast parameter parsing | [https://wiki.php.net/rfc/fast_zpp](https://wiki.php.net/rfc/fast_zpp)
    | In PHP 5, parameters provided to functions have to be parsed for every single
    function call. The parameters were passed in as a string, and parsed in a manner
    similar to the `scanf()` function. In PHP 7 this process has been optimized and
    made much more efficient, resulting in a significant performance improvement.
    The improvement is difficult to measure, but seems to be in the region of 6%.
    |'
  prefs: []
  type: TYPE_TB
- en: '| PHP NG | [https://wiki.php.net/rfc/phpng](https://wiki.php.net/rfc/phpng)
    | The PHP **NG** (**Next Generation**) initiative represents a rewrite of most
    of the PHP language. It retains existing functionality, but involves any and all
    time-savings and efficiency measures imaginable. Data structures have been compacted,
    and memory is used more efficiently. Just one change, which affects array handling,
    for example, has resulted in a significant performance increase, while at the
    same time greatly reducing memory usage. |'
  prefs: []
  type: TYPE_TB
- en: '| Removing dead weight | [https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts](https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts)
    | There were approximately two dozen extensions that fell into one of these categories:
    deprecated, no longer maintained, unmaintained dependencies, or not ported to
    PHP 7\. A vote by the group of core developers determined to remove about 2/3
    or the extensions on the "short list". This results in reduced overhead and faster
    overall future development of the PHP language. |'
  prefs: []
  type: TYPE_TB
- en: Iterating through a massive file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions such as `file_get_contents()` and `file()` are quick and easy to use
    however, owing to memory limitations, they quickly cause problems when dealing
    with massive files. The default setting for the `php.ini` `memory_limit` setting
    is 128 megabytes. Accordingly, any file larger than this will not be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration when parsing through massive files is how quickly does
    your function or class method produce output? When producing user output, for
    example, although it might at first glance seem better to accumulate output in
    an array. You would then output it all at once for improved efficiency. Unfortunately,
    this might have an adverse impact on the user experience. It might be better to
    create a **generator**, and use the `yield keyword` to produce immediate results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, the `file*` functions (that is, `file_get_contents()`),
    are not suitable for large files. The simple reason is that these functions, at
    one point, have the entire contents of the file represented in memory. Accordingly,
    the focus of this recipe will be on the `f*` functions (that is, `fopen()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a slight twist, however, instead of using the `f*` functions directly, instead
    we will use the `SplFileObject` class, which is included in the **SPL** (**Standard
    PHP Library**):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Iterator\LargeFile` class with the appropriate
    properties and constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `__construct()` method that accepts a filename as an argument
    and populates the `$file` property with an `SplFileObject` instance. This is also
    a good place to throw an exception if the file does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a method `fileIteratorByLine()method` which uses `fgets()` to
    read one line of the file at a time. It''s not a bad idea to create a complimentary
    `fileIteratorByLength()`method that does the same thing but uses `fread()` instead.
    The method that uses `fgets()` would be suitable for text files that include linefeeds.
    The other method could be used if parsing a large binary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define a `getIterator()`method that returns a `NoRewindIterator()`
    instance. This method accepts as arguments either `ByLine` or `ByLength`, which
    refer to the two methods defined in the previous step. This method also needs
    to accept `$numBytes` in case `ByLength` is called. The reason we need a `NoRewindIterator()`
    instance is to enforce the fact that we''re reading through the file only in one
    direction in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we take advantage of the autoloading class defined in [Chapter
    1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*, to
    obtain an instance of `Application\Iterator\LargeFile` in a calling program, `chap_02_iterating_through_a_massive_file.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside a `try {...} catch () {...}` block, we get an instance of a `ByLine`
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then provide an example of something useful to do, in this case, defining
    an average of words per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then end the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The expected output (too large to show here!) shows us that there are 566,095
    words in the project Gutenberg version of *War and Peace*. Also, we find the average
    number of words per line is eight.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a spreadsheet into a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although PHP does not have any direct capability to read a specific spreadsheet
    format (that is, XLSX, ODS, and so on), it does have the ability to read **(CSV
    Comma Separated Values**) files. Accordingly, in order to process customer spreadsheets,
    you will need to either ask them to furnish their files in CSV format, or you
    will need to perform the conversion yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When uploading a spreadsheet (that is, a CSV file) into a database, there are
    three major considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a (potentially) massive file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting each spreadsheet row into a PHP array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting the PHP array into the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Massive file iteration will be handled using the preceding recipe. We will use
    the `fgetcsv()` function to convert a CSV row into a PHP array. Finally, we will
    use the **(PDO PHP Data Objects**) class to make a database connection and perform
    the insert.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Database\Connection` class that creates a PDO
    instance based on a set of parameters supplied to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then incorporate an instance of `Application\Iterator\LargeFile`. We add
    a new method to this class that is designed to iterate through CSV files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add `Csv` to the list of allowed iterator methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we define a config file,`/path/to/source/config/db.config.php`, that
    contains database connection parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we take advantage of the autoloading class defined in [Chapter 1](ch01.html
    "Chapter 1. Building a Foundation"), *Building a Foundation*, to obtain an instance
    of `Application\Database\Connection` and `Application\Iterator\LargeFile`, defining
    a calling program, `chap_02_uploading_csv_to_database.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we set up a `try {...} catch () {...}` block, which catches `Throwable`.
    This allows us to `catch` both exceptions and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `try {...} catch () {...}` block we get an instance of the connection
    and large file iterator classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We then take advantage of the PDO prepare/execute functionality. The SQL for
    the prepared statement uses `?` to represent values that are supplied in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use `foreach()` to loop through the file iterator. Each `yield` statement
    produces an array of values that represents a row in the database. We can then
    use these values with `PDOStatement::execute()` to execute the prepared statement,
    inserting the row of values into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can then examine the database to verify that the data was successfully inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive directory iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting a list of files in a directory is extremely easy. Traditionally, developers
    have used the `glob()` function for this purpose. To recursively get a list of
    all files and directories from a specific point in a directory tree is more problematic.
    This recipe takes advantage of an **(SPL Standard PHP Library**) class `RecursiveDirectoryIterator`,
    which will serve this purpose admirably.
  prefs: []
  type: TYPE_NORMAL
- en: What this class does is to parse the directory tree, finding the first child,
    then it follows the branches, until there are no more children, and then it stops!
    Unfortunately this is not what we want. Somehow we need to get the `RecursiveDirectoryIterator`
    to continue parsing every tree and branch, from a given starting point, until
    there are no more files or directories. It so happens there is a marvelous class,
    `RecursiveIteratorIterator`, that does exactly that. By wrapping `RecursiveDirectoryIterator`
    inside `RecursiveIteratorIterator,` we accomplish a complete traversal of any
    directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Warning!**'
  prefs: []
  type: TYPE_NORMAL
- en: Be very careful where you start the filesystem traversal. If you start at the
    root directory, you could end up crashing your server as the recursion process
    will not stop until all files and directories have been located!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Iterator\Directory` class that defines the
    appropriate properties and constants and uses external classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor creates a `RecursiveDirectoryIterator` instance inside `RecursiveIteratorIterator`
    based on a directory path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we decide what to do with the iteration. One possibility is to mimic
    the output of the Linux `ls -l -R` command. Notice that we use the `yield` keyword,
    effectively making this method into a **Generator**, which can then be called
    from the outside. Each object produced by the directory iteration is an SPL `FileInfo`
    object, which can give us useful information on the file. Here is how this method
    might look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that the method call includes a file pattern. We need
    a way of filtering the recursion to only include files that match. There is another
    iterator available from the SPL that perfectly suits this need: the `RegexIterator`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is another method, but this time we will mimic the `dir /s` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we take advantage of the autoloading class defined in [Chapter
    1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*, to
    obtain an instance of `Application\Iterator\Directory`, defining a calling program,
    `chap_02_recursive_directory_iterator.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in a `try {...} catch () {...}` block, we make a call to our two methods,
    using an example directory path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `ls()` will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output for `dir()` will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
