- en: AOP and Logger Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about Spring **Aspect-Oriented Programming**
    (**AOP**) and logger controls, both their theory and implementation. We will integrate
    Spring AOP in our existing REST APIs and walk through how AOP and logger controls
    will make our lives easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP theory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of Spring AOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need logger controls?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we implement logger controls?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Spring AOP and logger controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming (AOP)
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aspect-oriented programming is a concept where we add a new behavior to existing
    code without modifying the code itself. The AOP concept is really helpful when
    it comes to logging or method authentication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways you can use AOP in Spring. Let's not get into much detail,
    as it will be a big topic to discuss. Here, we will discuss only the `@Before`
    pointcut and how to use `@Before` in our business logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: AOP (@Before) with execution
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term execution in AOP means having a pointcut in the `@Aspect` annotation
    itself, and it doesn''t depend on the controller API. The alternate way is that
    you will have to explicitly mention the annotation in the API call. Let''s talk
    about the explicit pointcut in the next topic:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this pointcut, we have used the `@Before` annotation, and it uses `execution(*
    com.packtpub.restapp.HomeController.testAOPWithoutAnnotation())`, which means
    this pointcut will be focusing on a specific method, the `testAOPWithoutAnnotation`
    method inside the `HomeController` class, in our case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'For AOP-related work, we might need to add the dependency to our `pom.xml`
    file, which is mentioned as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding dependency will bring all aspect-oriented classes to support our
    AOP implementation in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`@Aspect`: This annotation is used to make the class support aspects. In Spring,
    aspects can be implemented using XML configurations or annotation, such as `@Aspect`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component`: This annotation will make the class scannable according to the
    rule of Spring''s component scanner. By mentioning this class with `@Component`
    and `@Aspect`, we tell Spring to scan this class and identify it as an aspect.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `HomeController` class is given as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we simply create a new method to test our AOP. You may not need to create
    a new API to test our AOP. As long you provide the appropriate method name, it
    should be okay. To make it easier for the reader, we have created a new method
    called `testAOPExecution` in the `HomeContoller` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Testing AOP @Before execution
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just call the API (`http://localhost:8080/test/aop/with/execution`) in the
    browser or using any other REST client; then, you should see the following in
    the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though this log doesn't really help our business logic, we will keep it
    for now to keep things easier for the reader to understand the flow. Once we learn
    about AOP and how it functions, we will integrate it into our business logic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: AOP (@Before) with annotation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen an execution-based AOP method that can be used for one
    or more methods. However, in some places, we may need to keep the implementation
    plain to increase visibility. This will help us use it wherever it is needed,
    and it is not tied to any method. We call it explicit annotation-based AOP.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In order to use this AOP concept, we may need to create an interface that will
    help us with what we need to achieve.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`TokenRequired` is just a base interface for our `Aspect` class. It will be
    supplied to our `Aspect` class, which is mentioned as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`@Retention`: A retention policy determines at what point the annotation should
    be discarded. In our case, `RetentionPolicy.RUNTIME` will be retained for the
    JVM through runtime.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Other retention policies are as listed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`SOURCE`: It will be retained only with the source code, and it will discarded
    during compile time. Once the code is compiled, the annotation will be useless,
    so it won''t be written in the bytecode.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`CLASS`: It will be retained till compile time and will be discarded during
    runtime.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`@Target`: This annotation is applicable for the class level and matches at
    runtime. The target annotation can be used to collect the target object.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `tokenRequiredWithAnnotation` method will implement the business
    logic for our aspect. To keep the logic simple, we have just provided `System.out.println(..)`.
    Later, we will add the main logic to the method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we have created a method called `tokenRequiredWithAnnotation`
    and supplied the `TokenRequired` interface as a parameter for this method. We
    can see the annotation called `@Before` on top of this method with `@annotation(tokenRequired)`.
    This method will be called every time the `@TokenRequired` annotation is used
    in any method. You can see the annotation usage as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main difference between the previous AOP method and this is `@TokenRequired`.
    In the old API caller, we didn't mention any AOP annotation explicitly, but we
    have to mention `@TokenRequired` in this caller as it will call the appropriate
    AOP method. Also, in this AOP method, we don't need to mention `execution`, like
    we did in the previous `execution(* com.packtpub.restapp.HomeController.testAOPWithoutAnnotation())`
    method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Testing AOP @Before annotation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just call the API (`http://localhost:8080/test/aop/with/annotation`) in the
    browser or using any other REST client; then, you should see the following on
    the console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Integrating AOP with JWT
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that you want to restrict the `deleteUser` option in the `UserContoller`
    method. Whoever deletes the user should have the proper JWT token. If they don't
    have the token with them, we won't let them delete any users. Here, we will first
    have a `packt` subject to create a token.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The `http://localhost:8080/security/generate/token?subject=packt`-generated
    token API can be called to generate the token.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: When we use `packt` in the subject, it will generate the `eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJwYWNrdCIsImV4cCI6MTUwOTk0NzY2Mn0.hIsVggbam0pRoLOnSe8L9GQS4IFfFklborwJVthsmz0`
    token.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will have to create an AOP method to restrict the user by asking them
    to have the token in the header of the `delete` call:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Looking at the preceding code, you can see the JWT integration in AOP. Yes,
    we have integrated the JWT token verification part with AOP. So hereafter, if
    someone calls the `@TokenRequired`-annotated API, it will first come to the AOP
    method and check for a token match. If the token is empty, not matched, or expired,
    we will get an error. All possible errors will be discussed as follows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start using the `@TokenRequired` annotation in our API call in the
    `UserController` class. So whenever this `deleteUser` method is called, it will
    go to `JWT`, checking pointcut before executing the API method itself. By doing
    this, we can assure that the `deleteUser` method will not be called without a
    token.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `UserController` class is given here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the token is empty or null, it will throw the following error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the token is matched, it will show the result without throwing any error.
    You''ll see the following result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we don''t provide any token in the headers, it might throw the following
    error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the token is expired, you will get the following error:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logger controls
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging will be helpful when we need to track the output of a specific process.
    It will help us verify the process or find the root cause of the error when things
    go wrong after deploying our application in the server. Without loggers, it will
    be difficult to track and figure out the problem if anything happens.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: There are many logging frameworks we can use in our application; Log4j and Logback
    are the two major frameworks used in most applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: SLF4J, Log4J, and Logback
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SLF4j is an API to help us choose Log4j or Logback or any other JDK logging
    during deployment. SLF4j is just an abstraction layer that gives freedom to the
    user who uses our logging API. If someone wants to use JDK logging or Log4j in
    their implementation, SLF4j will help them plug in the desired framework during
    runtime.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If we create an end product that can't be used by someone as a library, we can
    implement Log4j or Logback directly. However, if we have a code that can be used
    as a library, it would be better to go with SLF4j, so the user can follow any
    logging they want.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Logback is a better alternative for Log4j and provides native support for SLF4j.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Logback framework
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned earlier that Logback is more preferable than Log4j; here we will
    discuss how to implement the Logback logging framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three modules in Logback:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`logback-core`: Basic logging'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`logback-classic`: Improved logging and SLF4j support'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`logback-access`: Servlet container support'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `logback-core` module is the base for other two modules in the Log4j framework.
    The `logback-classic` module is an improved version of Log4j with more features.
    Also, the `logback-classic` module implements the SLF4j API natively. Due to this
    native support, we can switch to different logging frameworks such as **Java Util
    Logging** (**JUL**) and Log4j.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The `logback-access` module provides support to servlet containers such as Tomcat/Jetty,
    specifically to provide HTTP-access log facilities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Logback dependency and configuration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Logback in our application, we need the `logback-classic` dependency.
    However, the `logback-classic` dependency is already available in the `spring-boot-starter`
    dependency. We can check this with dependency tree (`mvn dependency:tree`) in
    our project folder:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While checking dependency tree in the project folder, we will get the whole
    tree for all of our dependencies. The following is the section where we can see
    the `logback-classic` dependency under the `spring-boot-starter` dependency:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the necessary dependency files are already available, we don't need to
    add any dependencies for Logback framework implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Logging levels
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As SLF4j defined these logging levels, whoever implements SLF4j should adapt
    the logging levels of SFL4j. The logging levels are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`TRACE`: Detailed comments that might not be used in all cases'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG`: Useful comments for debugging purposes in production'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`: General comments that might be helpful during development'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARN`: Warning messages that might be helpful in specific scenarios such as
    deprecated methods'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR`: Severe error messages to be watched out for by the developer'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the logging configuration to the `application.properties` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding configuration, we have used logging configuration for both
    Spring Framework and our application. According to our configuration, it will
    print `ERROR` for Spring Framework and `INFO` for our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Logback implementation in class
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a `Logger` to the class; in our case, we can use `UserController`.
    We have to import `org.slf4j.Logger` and `org.slf4j.LoggerFactory`. We can check
    the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we introduced the `_logger` instance. We use the `UserController`
    class as a parameter for the `_logger` instance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to use the `_logger` instance to print the message we wanted.
    Here, we have used `_logger.info()` to print the message:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we have used various loggers to print messages. When
    you restart the server and call the `http://localhost:8080` REST API, you will
    see the following output in the console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the log, the class name will always be in the log to identify
    the specific class in the log. As we haven't mentioned any logging pattern, the
    logger takes the default pattern to print the output with the class. If we need,
    we can change the pattern in our configuration file to get customized logging.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we have used different logging levels to print the messages.
    There is a restriction on the logging level, so based on the business requirements
    and implementation, we will have to configure our logging levels.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们使用了不同的日志级别来打印消息。对日志级别有限制，因此根据业务需求和实现，我们将不得不配置我们的日志级别。
- en: In our logger configuration, we have used only the console printing option.
    We can also provide an option to print to external files wherever we want.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日志配置中，我们只使用了控制台打印选项。我们还可以提供一个选项，将日志打印到我们想要的外部文件中。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered Spring AOP and logger controls with implementation.
    In our existing code, we introduced Spring AOP and walked through how AOP saves
    time via code reuse. For the user to understand AOP, we simplified AOP implementation.
    In the next chapter, we will talk about how to build a REST client and discuss
    more about error handling in Spring.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了Spring AOP和日志控制的实现。在我们现有的代码中，我们介绍了Spring AOP，并演示了AOP如何通过代码重用节省时间。为了让用户理解AOP，我们简化了AOP的实现。在下一章中，我们将讨论如何构建一个REST客户端，并更多地讨论Spring中的错误处理。
