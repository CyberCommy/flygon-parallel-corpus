- en: 4\. Separation of Concerns - Software Architecture, Functions, and Variadic
    Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop classes using the PIMPL idiom to implement object-level encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a callback system using functors, std::function, and lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement lambdas using the right capture technique for the situation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop variadic templates to implement C# style delegates for event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will show you how to implement the PIMPL idiom, and how to develop
    a callback mechanism for your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to implement classes to properly manage
    resources even when the exceptions occurred using RAII. We also learned about
    ADL (**Argument Dependent Lookup**) and how it determines the function to be called.
    Finally, we talked about how the explicit keyword can be used to prevent automatic
    conversion between types by the compiler, known as implicit conversion
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into dependencies, both physical and logical,
    and see how they can affect build times adversely. We'll also learn how to separate
    the visible interface class from the implementation details to increase the speed
    of the build times. We will then learn to capture functions and contexts so that
    we can call them later using `functors`, `std::function` and `lambda expressions`.
    Finally, we will implement a variadic template to deliver an event-based callback
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The Pointer to Implementation (PIMPL) Idiom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As projects implemented in C++ get larger and larger, there is the likelihood
    that the build times will grow at a faster rate than the number of files. This
    is because of the textual inclusion model used by the C++ build model. This is
    done so that the compiler can determine the size and layout of the class, causing
    a coupling between the `caller` and the `callee`, but allowing for optimization.
    Remember that everything must be defined before it can be used. A future feature
    called `Modules` promises to address this issue, but for now we need to understand
    the issue and the techniques used to address the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Logical and Physical Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we wish to access a class from another class, we have a logical dependency.
    One class is logically dependent upon another class. If we consider the `Graphics`
    classes, `Point3d` and `Matrix3d` that we developed in *Chapter 2A*, *No Ducks
    Allowed – Types and Deduction* and *Chapter 3*, *The Distance between Can and
    Should – Objects, Pointers and Inheritance*, we have two logically independent
    classes `Matrix3d` and `Point3d`. However, because of how we implemented the multiplication
    operator between the two, we created a compile-time or **physical dependency**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Physical Dependencies of Matrix3d and Point3d'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: Physical Dependencies of Matrix3d and Point3d'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see with these relatively simple classes, the physical dependencies
    between the header files and the implementation files can quickly get complicated.
    It is this complexity that contributes to the build times of large projects because
    the number of physical (and logical) dependencies grows to thousands. We have
    shown only 13 dependencies in the preceding diagram as indicated by the arrows.
    But there are actually many more, as including a standard library header typically
    pulls in a hierarchy of include files. This means that if one header file is modified,
    then all files that are dependent upon it, either directly or indirectly, will
    need to be re-compiled to account for the change. This trigger for rebuilding
    also occurs if the change is to the private class members definition that users
    of the class cannot even access.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help speed compile times, we have used the guard technique to prevent header
    files from being processed multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And lately, most compilers now support the `#pragma once` directive which achieves
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: These relationships between entities (files, classes, and so on) are known as
    **coupling**. A file/class is **highly coupled** to another file/class if changes
    to the file/class result in changes to the other file/class. A file/class is **loosely
    coupled** to another file/class if changes to the file/class do not result in
    changes to the other file/class.
  prefs: []
  type: TYPE_NORMAL
- en: Highly coupled code (files/classes) introduce problems into a project. Highly
    coupled code is hard to change (inflexible), hard to test and hard to understand.
    Loosely coupled code on the other hand is easier to change (only modify one class),
    highly testable (only need the class being tested) and easier to read and understand.
    Coupling reflects, and is related to, the logical and physical dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The Pointer to Implementation (PIMPL) Idiom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One solution to this problem with coupling is to use the "**Pimpl Idiom**" (which
    stands for **Pointer to Implementation Idiom**). This is also referred to as an
    opaque pointer, the compiler firewall idiom or even **Cheshire Cat technique**.
    Consider the **Qt library**, in particular, the **Qt Platform Abstraction** (**QPA**).
    It is an abstraction layer that hides the details of the Operating Systems and/or
    platforms that the Qt application is hosted on. One method to implement such a
    layer is to use the PIMPL idiom where the common interface is exposed to the application
    developer, but the implementation of how the functionality is delivered is hidden.
    Qt actually uses a variant of PIMPL known as d-pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one feature of a GUI is the use of a dialog that is a popup window
    that displays information or prompts for user input. It could be declared in **dialog.hpp**
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more information about QT Platform Abstraction (QPA), visit the following
    link: [https://doc.qt.io/qt-5/qpa.html#](https://doc.qt.io/qt-5/qpa.html#).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The user has access to all the functions required to use a `Dialog` but has
    no knowledge of how it is implemented. Note that we have a declared `DialogImpl`
    but not defined it. In general, there is not much we can do with such a class
    as `DialogImpl`. But there is one thing that is allowed and that is to declare
    a pointer to it. This feature of C++ allows us to hide the implementation details
    in the implementation file. This means that in this simple case we do not have
    any include files for this declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation file **dialogImpl.cpp** may be implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We note several things from this:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the implementation class `DialogImpl` before we define the methods
    required for Dialog. This is necessary because `Dialog` will need to exercise
    the methods through `m_pImpl` which means that they need to be defined first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Dialog` constructor and destructor are responsible for the memory management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We include all the necessary header files required for the implementation, in
    the implementation file only. This reduces the coupling by minimizing the number
    of headers included in the **Dialog.hpp** file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution, the above program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Sample Pimpl implementation output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: Sample Pimpl implementation output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Advantages and Disadvantages of PIMPL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest advantage in the use of PIMPL is that it breaks the compile-time
    dependencies between the clients of a class and its implementation. This allows
    for faster build times because PIMPL eliminates a large number of `#include` directives
    in the definition (header) file, instead pushing them to only be necessary in
    the implementation file.
  prefs: []
  type: TYPE_NORMAL
- en: It also decouples the implementation from the clients. We are now free to change
    the implementation of the PIMPL class and only that file needs recompilation.
    This prevents compilation cascades where changes to hidden members trigger the
    rebuilding of clients. This is called a compilation-firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other advantages of the PIMPL idiom are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Hiding** – the internal details of implementation are truly isolated
    in the implementation class. If this is part of a library, then it can be used
    to prevent the disclosure of information, such as Intellectual property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DLL`, or `.so` file) and be free to change it without affecting the client
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such advantages come at a cost. The disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance Effort** – there is additional code in the visible class that
    forwards the calls to the Implementation class. This adds a level of indirection
    with a minor increase in complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory Management** – the addition of a pointer for the implementation now
    requires us to manage the memory. It also requires additional storage to hold
    the pointer and, in a memory constrained system (For example: Internet of Things
    device) this may be critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PIMPL with unique_ptr<>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our current implementation of Dialog uses a raw pointer to hold the PIMPL implementation
    reference. In *Chapter 3*, *The Distance between Can and Should – Objects, Pointers
    and Inheritance*, we discussed ownership of objects and introduced smart pointers
    and RAII. The hidden object pointed to by the PIMPL pointer is a resource to be
    managed and should be executed using `RAII` and `std::unique_ptr`. As we shall
    see, there are some caveats for implementing `PIMPL` with `std::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change our Dialog implementation to use smart pointers. Firstly, the header
    files changes to introduce the `#include <memory>` line and the destructor can
    be removed as the `unique_ptr` deletes the implementation class automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we remove the destructor from the implementation file, and we modify
    the constructor to use `std::make_unique`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When re-compiling our new version, there are no problems with the **Dialog.hpp**
    and **DialogImpl.cpp** files, but our client **main.cpp** reports the following
    errors (with the gcc compiler), as you can see below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Failed compilation of Pimpl using unique_ptr'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: Failed compilation of Pimpl using unique_ptr'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first error reports `Dialog` for us when `main()` function ends. As we
    discussed in *Chapter **2A*, *No Ducks Allowed – Types and Deduction* the compiler
    will generate a destructor for us (as we removed it). This generated destructor
    will call the destructor of `unique_ptr` which is the cause of the error. If we
    look at `line 76`, of `operator()` function for the default `deleter` used by
    `unique_ptr` (the `deleter` is the function called by `unique_ptr` when it destroys
    the object it points to):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our code is failing on the second `static_assert()` statement that terminates
    the compilation with an error. The problem is that the compiler is trying to generate
    the destructor for `std::unique_ptr<DialogImpl>` and `DialogImpl` is an incomplete
    type. So, to fix the problem, we control the generation of the destructor to be
    at a point where `DialogImpl` is a complete type.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we put the declaration of the destructor back into the class and
    add its implementation to the `DialogImpl.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run our program, it produces exactly the same output as
    before. In fact, if we only need an empty destructor, we can replace the above
    code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run our program, then following output will be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Sample unique_ptr Pimpl implementation output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Sample unique_ptr Pimpl implementation output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: unique_ptr<> PIMPL Special Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As PIMPL usually implies that the visible interface class owns the implementation
    class, the move-semantics are a natural fit. However, in the same way the compiler
    generated destructor implementation is correct, the compiler generated move constructor
    and move assignment operator will give the desired behavior, that is, perform
    a move on the member `unique_ptr`. The move operations both potentially need to
    perform a delete before assigning the transferred value, and so, suffer from the
    same problem as the destructor with incomplete types. The solution is the same
    as for the destructor – declare the method in the header file and implement when
    the type is complete – in the implementation file. So, our header file looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Depending upon the data items that we are hiding in our implementation class,
    we may also desire copy functionality on our PIMPL classes. Using a `std::unique_ptr`
    inside the Dialog class prevents the automatic generation of a copy constructor
    and copy assignment operator, as the internal members do not support copy. Also,
    by defining the move member functions, as we saw in *Chapter 2A*, *No Ducks Allowed
    – Types and Deduction*, it also stops the compiler in generating the copy versions.
    In addition, if the compiler did generate copy semantics for us, it would only
    be a **shallow copy**. But due to the PIMPL implementation, we need a **deep copy**.
    So, we will need to write our own copy special member functions. Again, the definition
    goes in the header file and the implementation needs to be done where the type
    is complete, inside the **DialogImpl.cpp** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, we add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the implementation would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the `if(this == &rhs)` clauses. These are there to prevent the object from
    copying itself unnecessarily. Also, note that we need to check if either `unique_ptr`
    is empty and process the copy accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before solving any practical in this chapter, download the GitHub repository
    [https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus)
    and import the folder of Lesson 4 in Eclipse, so that you can view the codes for
    each exercises, and activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Implementing a Kitchen with unique_ptr<>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will hide the details of how the kitchen processes orders
    by implementing the `Pimpl idiom` with the `unique_ptr<>`. Follow the below steps
    to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise01** and double click on **Exercise1.cpp** to
    open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise1** to run with the name **Exercise1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 1 will run and produce the following
    output:![Figure 4.5: Exercise 1 Program output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: Exercise 1 Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Open `Kitchen`. We are going to move all the private members into an implementation
    class and hide the details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `#include <memory>` directive to gain access to the `unique_ptr`. Add
    the declaration for the destructor `~Kitchen();` and then add the following two
    lines into the top of the private section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `#include` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-build the program. You'll see that the output
    is still the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all the private members except the two new ones from the `Kitchen` class
    in `Kitchen::Impl` declarations. The `#include <vector>`, `#include "recipe.hpp"`
    and `#include "dessert.hpp"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Kitchen::Impl` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the remainder of the original methods, change them to be scoped to `Kitchen::Impl`
    instead of `Kitchen::`. For example, `std::string Kitchen::processOrder(std::string
    order)` becomes `std::string Kitchen::Impl::processOrder(std::string order)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Kitchen::Impl`, add a constructor with a `std::string` argument and the
    `processOrder()` method. The `Kitchen::Impl` declaration should now look like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In `#include <vector>`, `#include "recipe.hpp"` and `#include "dessert.hpp"`
    to the top of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Kitchen::Kitchen` and `Kitchen::processOrder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Kitchen::Impl` method definitions, add the following two methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to re-build the program. The program will run again
    to produce the original output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6: The Kitchen program output using Pimpl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: The Kitchen program output using Pimpl'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we have taken a class that held many details in its private
    members and moved those details into a PIMPL class to hide the details and decouple
    the interface from the implementation using the techniques previously described.
  prefs: []
  type: TYPE_NORMAL
- en: Function Objects and Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common pattern used in programming, particularly when implementing event-based
    processing, such as asynchronous input and output, is the use of the **callback**.
    A client registers that they want to be notified that an event has occurred (For
    example: data is available to read, or a data transmission is complete). This
    pattern is known as **Observer pattern** or **Subscriber Publisher pattern**.
    C++ supports a variety of techniques to provide the callback mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: Function Pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first mechanism is the use of the **function pointers**. This is a legacy
    feature inherited from the C language. The following program shows an example
    of a function pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This program when compiled and executed, produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Function Pointer Program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Function Pointer Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Strictly speaking the code should be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, thing to note is that the address of (`&`) operator should be used to
    initialize the pointer. Secondly, we should check that the pointer is valid before
    calling it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we attempt to compile this program, we get the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Errors compiling function pointer program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Errors compiling function pointer program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The text of the first error is `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the above program to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It compiles and runs successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Function pointer program using static member function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: Function pointer program using static member function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The function pointer technique is often used when interfacing with C libraries
    that use callbacks and operating system notifications which also support callbacks.
    In these two cases, it would be normal for the callback to take an argument which
    is a `void *` to a user registered data blob pointer. The data blob pointer could
    be the `this` pointer of a class which is then dereferenced and the callback forwarded
    into a member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other languages, such as Python and C#, it is a part of the language that
    capturing a function pointer will also capture the sufficient data to call that
    function (for example: `self` or `this`). C++ has the ability to make any object
    callable through the function call operator which we''ll cover next.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Function Object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ allows for the function call operator `operator()` to be overloaded. This
    leads to the ability to make any object `callable`. An object that can be callable
    is known as a `Scaler` class in the following program implements a `functor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two objects of type `Scaler` created and they are used as functions
    inside the lines generating output. The above program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Functors program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Functors program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One advantage of `functors` over function pointers is that they can contain
    state, either as an object or across all instances. Another advantage is that
    they can be passed to STL algorithms that expect a function (for example `std::for_each`)
    or an operator (for example `std::transform`).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of such a use might look like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, the output produced will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Program output showing Scaler transformed vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: Program output showing Scaler transformed vectors'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 2: Implementing function objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will implement two different function objects that can
    work with the STL algorithm for_each.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise02** and double click on **Exercise2.cpp** to
    open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise2** to run with the name **Exercise2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 4.12: Exercise 2 Initial output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: Exercise 2 Initial output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first thing we will do is fix the formatting of the output by introducing
    a function object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, before the definition of `main()` function add the following
    class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inside the **main()** method replace the following code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**with**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.13: Exercise 2 Improved output format'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Exercise 2 Improved output format'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The internal state of the `Printer` class allows us to fix the formatting.
    Now, introduce an `aggregator` class that will allow us to calculate the `average`.
    Add the following class definition to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifiy `main()` method to use the `Averager` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14: Exercise 2 output with average'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: Exercise 2 output with average'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that `std::for_each()` returns the instance of `Averager` passed into
    it. This instance is copied into the variable `averager` that then contains the
    data required to calculate the average. In this exercise, we implemented two function
    objects or `functor` classes: `Averager` and `Printer` that we could use as functions
    when passed to the STL algorithm `for_each`.'
  prefs: []
  type: TYPE_NORMAL
- en: std::function<> template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 introduced a general polymorphic function wrapper template, `std::function<>`,
    that makes implementing callbacks and other function related capabilities easier.
    `std::function` holds a callable object known as the `std::function` will result
    in `std::bad_function_call` exception being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function object can store, copy or invoke a target that is any of the following
    callable objects: functions, function objects (defines the `operator()`), a pointer
    to member function or a lambda expression. We will cover more about it in the
    topic *What is a Lambda Expression?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When instantiating a `std::function` object, it is only necessary to provide
    the function signature and not the value to initialize it with, leading to an
    empty instance. The instantiation is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Structure of a std::function declaration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Structure of a std::function declaration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The arguments to the template, define the `function signature` of the target
    stored by `variable`. The signature starts with the return type (which may be
    void) and then places inside the parentheses the list of types that the function
    will be invoked with.
  prefs: []
  type: TYPE_NORMAL
- en: The use of free functions and `functors` with `std::function` is straight forward.
    Provided that the signature matches the parameters passed to the `std::function`
    template, we can simply equate the free function or `functor` to the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we want to use a method on an object instance then we need to use
    another STL helper template `std::bind()`. If we run the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Program output using std::bind() and std::function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: Program output using std::bind() and std::function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Several points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The function `method()` is referenced using the class as a scope specifier;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address of the instance of `Binder` is passed as the second argument to
    `std::bind()` which makes it the first argument passed to `method()`. This is
    necessary as all non-static members have an implicit `this` pointer passed as
    the first argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `std::placeholders` definitions, we can bind arguments used when invoking
    the bound method and even change the order passed (as seen by `func3`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++11 introduced some syntactic sugar, known as lambda expressions, that make
    it easier to define anonymous functions that can also be used to bind methods
    and assign them to `std::function` instances expression. We'll cover more about
    it in the topic *What is a Lambda Expression?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Implementing callbacks with std::function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement function callbacks utilizing the `std::function<>`
    template. Follow the below steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise03** and double click on **Exercise3.cpp** to
    open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise3** to run with the name **Exercise3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.17: Exercise 3 output (Calling empty std::function)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Exercise 3 output (Calling empty std::function)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first thing we will do is prevent calling an empty `TestFunctionTemplate()`
    the line `func(42);` and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.18: Exercise 3 output (preventing call to empty std::function)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.18: Exercise 3 output (preventing call to empty std::function)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add the `FreeFunction()` method to the file before the function `TestFunctionTemplate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In `TestFunctionTemplate()` function, immediately before `if (func)` add the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.19: Exercise 3 output (FreeMethod)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: Exercise 3 output (FreeMethod)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add the new class definition before `TestFunctionTemplate()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the line `func = FreeFunction;` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![4.20: Exercise 3 output (Object function call override)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '4.20: Exercise 3 output (Object function call override)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Replace the line `func = funcClass;` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.21: Exercise 3 output (Member function)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.21: Exercise 3 output (Member function)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Replace the line `func = std::bind(…);` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22: Exercise 3 output (lambda function)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.22: Exercise 3 output (lambda function)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we implemented four different types of function callback using
    the `std::function` template – free method, class member function, class function
    call method and a lambda function (which we look at next).
  prefs: []
  type: TYPE_NORMAL
- en: What is a Lambda Expression?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since C++11, C++ has supported `anonymous functions`, also known as `lambda
    expressions`, or just `lambdas`. The two most common forms of lambda expression
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Most common forms of lambda expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.23: Most common forms of lambda expressions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Under normal circumstances, the compiler is able to deduce the return type of
    the lambda based on the return statements within the **function_body** (as embodied
    by form (1) in the figure above). However, if the compiler cannot determine the
    return type, or if we wish to force a different type, then we can use form (2).
  prefs: []
  type: TYPE_NORMAL
- en: Everything after `[captures]` is the same as for a normal function definition,
    except that the name is missing. Lambdas are a convenient way of defining a short
    method (just a few lines) at the location it will be used. The lambda is often
    passed as an argument and will typically not be re-used. It should also be noted
    that a lambda can be assigned to a variable (usually declared with auto).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can re-write the previous program where we used a `Scaler` class to use
    a lambda to achieve the same outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When this program runs the output shows that the vector has been scaled by
    5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Transform using lambda for scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.24: Transform using lambda for scaling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The lambda in this program is `[] (int n) {return 5*n;}` and has an empty capture
    clause `[]`. The empty capture clause means that the lambda function does not
    access any variables from the surrounding scope. If there are no parameters passed
    to the lambda, then the parameters clause `()` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing data into Lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `operator()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A capture clause is a comma-separated list of zero or more captured variables.
    There is also the concept of default captures – either by reference or by value.
    So, the basic syntax for a capture is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[&]` – captures all automatic storage duration variables in scope by reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=]` – captures all automatic storage duration variables in scope by value
    (make a copy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[&x, y]` – captures x by reference and y by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is translated by the compiler into member variables that are initialized
    by the constructor of the anonymous `functor` class. In case of the default captures
    (`&` and `=`), they must come first and only the variables referenced in the body
    are captured. The default capture can be overridden by placing the specific variable
    into the capture clause after the default capture. For example, `[&, x]` will
    by default capture by reference everything except `x` which it will capture by
    value.
  prefs: []
  type: TYPE_NORMAL
- en: However, while the default captures are convenient, they are not the preferred
    method of capture. This is because it can lead to dangling references (capture
    by reference and the referenced variable no longer exists when accessed by the
    lambda) or dangling pointers (capture by value, especially this pointers). It
    is clearer to capture your variables explicitly, which has the added benefit of
    the compiler being able to warn you about unexpected effects (such as trying to
    capture global or static variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 introduced the **init capture** to the capture clause allowing for safer
    code and some optimizations. An init capture declares a variable in the capture
    clause and initializes it for use inside the lambda. An example of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `z` is declared and initialized in the capture clause so that it can
    be used in the lambda. If you want to use the x and y in the lambda, then they
    must be captured separately. As expected, when the lambda is called it produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The init capture can also be used to capture movable objects into the lambda,
    or make copies of class members as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This captures the value of the member variable and happens to give it the same
    name for use inside the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a lambda is a const function, meaning that it cannot change the
    value of a capture-by-value variable. Where it is desirable to modify the value,
    we need to use a third form of lambda expression shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: Another form of lambda expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.25: Another form of lambda expression'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case, `specifiers` is replaced by `mutable`, telling the compiler that
    we want to modify the captured values. If we don't add mutable, and we attempt
    to modify a captured value, then the compiler will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Implementing Lambdas'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise we will implement lambdas to perform a number of actions in
    the context of STL algorithms. Follow the below steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise04** and double click on **Exercise4.cpp** to
    open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise4** to run with the name **Exercise4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.26: Initial output from Exercise 4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.26: Initial output from Exercise 4'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The program `PrintVector()` and `main()`. `PrintVector()` is the same as the
    version we introduced in *What is a Function Object?*. Now modify it to use the
    `std::for_each()` library function and a lambda instead of the ranged-for loop.
    Update `PrintVector()` to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button and we get the same output as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the lambda, we have captured the local variable `sep` by reference.
    Remove the `&` from `sep` and click on the **Run** button. This time the compilation
    fails with the following error:![Figure 4.27: Compilation failure due to modifying
    read-only variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.27: Compilation failure due to modifying read-only variable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Change the lambda declaration to include the `mutable` specifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button and we get the same output as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But we can go one step further. Remove the declaration of `sep` from the function
    `PrintVector()` and change the lambda again to include an init capture. Write
    the following code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `PrintVector()` it now looks more compact as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines after the call to `PrintVector()` in `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button and the output now adds the list of values sorted
    in descending order:![Figure 4.28: Program output for descending sort lambda'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.28: Program output for descending sort lambda'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Change the lambda function body to be `{return a<b;}`. Click on the **Run**
    button and the output now shows the values sorted in ascending order:![Figure
    4.29: Program output for ascending sort lambda'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.29: Program output for ascending sort lambda'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After the call to `PrintVector()` function, add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `values > 25`:![Figure 4.30: Output for count_if lambda stored
    in variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_04_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.30: Output for count_if lambda stored in variable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Add the following lines after the ones above and click the **Run** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Following output will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31: Erroneous output by re-using the pred lambda'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.31: Erroneous output by re-using the pred lambda'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The program wrongly reports that there are `seven (7) values > 40`; it should
    be `three (3)`. The problem is that when the lambda was created and stored in
    the variable `pred`, it captured the current value of threshold which was `25`.
    Change the line that defines `pred` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button and the output now correctly reports the count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.32: Correct output re-using the pred lambda'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.32: Correct output re-using the pred lambda'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we implemented several lambdas, using various features of
    the lambda expression syntax including init capture and mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambdas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While lambdas are a powerful feature of C++, they should be used appropriately.
    The goal is always to produce readable code. So, while a lambda might be short
    and to the point, sometimes it will be better for maintenance purposes to factor
    out the functionality into a well named method.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2B*, *No Ducks Allowed - Templates and Deduction*, we introduced
    generic programming and templates. Templates have been part of C++ before C++03\.
    Prior to C++11, templates were limited to a fixed number of arguments. In some
    cases, where a variable number of arguments was required, it was necessary to
    write a template for each variant of argument numbers required. Alternatively,
    there were variadic functions like `printf()` that could take a variable number
    of arguments. The problem with variadic functions is that they are not type safe
    as access to the arguments was through type casts via the `va_arg` macro. C++11
    changed all that with the introduction of variadic templates where a single template
    can take an arbitrary number of arguments. C++17 improved the writing of variadic
    templates by introducing the `constexpr` if construct that would allow the base
    case template to be merged with the "`recursive`" template.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach is to implement a variadic template and explain how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Variadic Template Program Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.33: Variadic Template Program Output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, what are the parts of a variadic template? And how do we read one? Consider
    the template from the above program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`typename... Args` declares `Args` as a `template parameter pack`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Args... args` is a `function parameter pack`, that is a bag of parameters
    whose types are given by `Args`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeof...(args)` returns the number of pack elements in `args`. It is a special
    form of pack expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args...` expands the pack in the recursive call to `summer()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, you can think of the template as effectively the equivalent
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler processes `summer(1, 3, 5, 7, 9, 11)` in the sample program,
    it performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It deduces that `T` is int and `Args...` is our parameter pack with <int, int,
    int, int, int>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there are more than zero args in the pack, the compiler generates `first
    + summer(args...)` with the ellipsis unpacking the template argument transforming
    `summer(args...)` into `summer(3,5,7,9,11)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler then generates the code for `summer(3,5,7,9,11)`. Again, resulting
    in `first + summer(args...)` being applied where `summer(5,7,9,11)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process is repeated until the compiler has to generate code for `summer(11)`.
    In this case, the else clause of the `constexpr` if statement is triggered which
    simply returns `first`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the types are determined by the arguments to the template, we are not restricted
    to the arguments having the same type. We have already met a couple of variadic
    templates in the STL – `std::function` and std::bind.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another type of variadic template, one which forwards its arguments
    onto another function or template. This kind of template does little on its own
    but provides a standard approach to things. One example is the `make_unique` template
    which could be implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`make_unique` has to call the new operator to allocate memory and then call
    the appropriate constructor for the type. The number of arguments required to
    call the constructor can vary greatly. This form of variadic template introduces
    some addition pack expansions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Args&&...` means we have a list of forwarding references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward<Args>(args)...` which contains to parameter packs that are expanded
    together and must have the same number of elements – Args the template parameter
    pack and args the function parameter pack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is used whenever we need to forward a function call to another
    function call in a variadic template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Implement a multicast event handler'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft first introduced the `Microsoft Foundation Class` (`MFC`) in 1992
    when C++ was in its infancy. This means that many of the design choices around
    the classes were restricted. For example, the handlers for events are typically
    routed through `OnEventXXX()` methods. These are usually configured using macros
    as part of a class derived from the MFC classes. Your team has been tasked with
    implementing multicast event handler more like delegates available in C# using
    templates that embody function objects and lead to variadic templates to achieve
    the variable argument lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, you declare a delegate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This makes Handler a type that can be assigned a value which can be called.
    This is essentially what `std::function<>` delivers us in C++ except for the ability
    to multi-cast. Your team is asked to develop a template class `Delegate` that
    can perform the same way as the C# delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The delegate will take a `variable list of arguments` but only return `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `operator+=` will be used to add new callbacks to the delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be called either using either syntax `delegate.Notify(…)` or `delegate(…)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to develop the Delegate template:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson4/Activity01** folder and configure
    the Current Builder for the project to be CMake Build (Portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project, configure the launcher and run the unit tests (which fail
    the one dummy test). Recommend that the name used for the tests runner is **L4delegateTests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `Delegate` class that can wrap a single handler with all the required
    methods and supports a single int parameter for the callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the template class to support multi-casting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the `Delegate` class to a template that can take a single template argument
    that defines the argument type used by the callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the `Delegate` template to a variadic template that can take zero or
    more arguments that define the types passed to the callbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following the above steps, the expected output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34: Output from the successful implementation of Delegate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.34: Output from the successful implementation of Delegate'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 673.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we implemented a data and method hiding design approach, PIMPL,
    that has the added benefit of reducing dependencies and reducing build times.
    We then implemented function objects directly as custom classes and then as lambda
    functions. We then expanded our template programming skills by diving into variadic
    templates culminating in a template which can be used for event callback processing.
    In the next chapter, we will learn how to use the features of C++ to develop programs
    with multiple thread and manage their co-operation through concurrency constructs.
  prefs: []
  type: TYPE_NORMAL
