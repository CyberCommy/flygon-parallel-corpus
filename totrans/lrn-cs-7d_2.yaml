- en: Day 02 - Getting Started with C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二天 - 开始学习C#
- en: 'Today, we are on day two of our seven-day learning series. Yesterday, we had
    gone through the basic understanding of .NET Core and its important aspects. Today,
    we will discuss the C# programming language. We will start with basics concepts
    by understanding a typical C# program, and then we will start looking at other
    stuff by covering reserved keywords, types, and operators; by the end of day,
    we will be able to write a complete C# program after covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们是在七天学习系列的第二天。昨天，我们已经了解了.NET Core及其重要方面的基本理解。今天，我们将讨论C#编程语言。我们将从理解典型的C#程序的基本概念开始，然后我们将开始涵盖保留关键字、类型和运算符等其他内容；在一天结束时，我们将能够在涵盖以下主题后编写完整的C#程序：
- en: Introducing C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C#
- en: Understanding a typical C# program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解典型的C#程序
- en: An overview of C# reserved keywords, types, and operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#保留关键字、类型和运算符概述
- en: An overview of type conversion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换概述
- en: Understanding statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解语句
- en: Arrays and string manipulations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和字符串操作
- en: Structure versus class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构与类
- en: Introduction to C#
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#简介
- en: In simple words, C# (pronounced *See-Sharp*) is a programming language that
    is developed by Microsoft. C# is approved by **International Standards Organization**
    (**ISO**) and **European Computer Manufacturers Association** (**ECMA**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，C#（发音为*See-Sharp*）是由微软开发的一种编程语言。C#已获得**国际标准化组织**（**ISO**）和**欧洲计算机制造商协会**（**ECMA**）的批准。
- en: 'This is the definition on the official website ([https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是官方网站上的定义（[https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index)）：
- en: C# is a simple, modern, object-oriented, and type-safe programming language.
    C# has its roots in the C family of languages and will be immediately familiar
    to C, C++, Java, and JavaScript programmers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种简单、现代、面向对象和类型安全的编程语言。C#源自C系列语言，对于C、C++、Java和JavaScript程序员来说会立即感到熟悉。
- en: Language C# is designed to adhere to **Common Language Infrastructure** (**CLI**),
    which we discussed on day one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言被设计为遵守**公共语言基础设施**（**CLI**），这是我们在第一天讨论过的。
- en: 'C# is the most popular professional language because of the following reasons:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C#是最受欢迎的专业语言，原因如下：
- en: It is an object-oriented language
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种面向对象的语言
- en: It is component-oriented
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是面向组件的
- en: It is a structured language
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种结构化语言
- en: 'The main part that makes it the most popular: this is a part of the .NET Framework'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其最受欢迎的主要部分：这是.NET Framework的一部分
- en: It has a unified type system, which means all types of language C# inherits
    from a single type object (this is also known as the mother type)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有统一的类型系统，这意味着C#语言的所有类型都继承自单一类型对象（这也被称为母类型）
- en: It was constructed with a robust durable application such as *Garbage collection*
    (discussed on day one)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是构建坚固耐用的应用程序，如*垃圾回收*（在第一天讨论过）
- en: It has the ability to handle unknown issues within a program, which is known
    as exceptional handling (we will discuss exception handling on day four)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有能力处理程序中的未知问题，这被称为异常处理（我们将在第四天讨论异常处理）
- en: Robust support of reflection, which enables dynamic programming (we will discuss
    reflection on day four)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的反射支持，可以实现动态编程（我们将在第四天讨论反射）
- en: History of the C# language
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#语言的历史
- en: The C# language was developed by *Anders Hejlsberg* and his team. The language
    name is inspired by the musical notation *sharp* (*#*), which indicates that the
    written note should be made a semitone higher in pitch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言是由*Anders Hejlsberg*及其团队开发的。语言名称受到了音乐符号*sharp*（*#*）的启发，该符号表示音符应该提高一个半音。
- en: The first released version was C# 1.0, which was launched in January 2002, and
    the current version is C# 7.0.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个发布的版本是C# 1.0，于2002年1月推出，当前版本是C# 7.0。
- en: The following table depicts all versions of the C# language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了C#语言的所有版本。
- en: '| **Version of C#** | **Release year** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **C#版本** | **发布年份** | **描述** |'
- en: '| 1.0 | January 2002 | With Visual Studio 2002 – .NET Framework 1.0 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 2002年1月 | 使用Visual Studio 2002 - .NET Framework 1.0 |'
- en: '| 1.2 | April 2003 | With Visual Studio 2003 – .NET Framework 1.1 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1.2 | 2003年4月 | 使用Visual Studio 2003 - .NET Framework 1.1 |'
- en: '| 2.0 | November 2005 | With Visual Studio 2005 – .NET Framework 2.0 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | 2005年11月 | 使用Visual Studio 2005 - .NET Framework 2.0 |'
- en: '| 3.0 | November 2007 | Visual Studio 2008, Visual Studio 2010 – .NET Framework
    3.0 and 3.5 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 2007年11月 | Visual Studio 2008, Visual Studio 2010 - .NET Framework
    3.0和3.5 |'
- en: '| 4.0 | April 2010 | Visual Studio 2010 – .NET Framework 4 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | 2010年4月 | Visual Studio 2010 - .NET Framework 4 |'
- en: '| 5.0 | August 2012 | Visual Studio 2012, 2013 – .NET Framework 4.5 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 2012年8月 | Visual Studio 2012, 2013 - .NET Framework 4.5 |'
- en: '| 6.0 | July 2015 | Visual Studio 2015 – .NET Framework 4.6 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 2015年7月 | Visual Studio 2015 - .NET Framework 4.6 |'
- en: '| C# 7.0 | March 2017 | Visual Studio 2017 – .NET Framework 4.6.2 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| C# 7.0 | 2017年3月 | Visual Studio 2017 - .NET Framework 4.6.2 |'
- en: '| C# 7.1 | August 2017 | Visual Studio 2017 update3 – .NET Framework 4.7 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| C# 7.1 | 2017年8月 | Visual Studio 2017更新3 - .NET Framework 4.7 |'
- en: In the upcoming section, we will discuss this language in detail, along with
    code examples. We will discuss C# language's keywords, types, operators, and so
    on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将详细讨论这种语言，包括代码示例。我们将讨论C#语言的关键字、类型、运算符等。
- en: Understanding a typical C# program
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解典型的C#程序
- en: Before we start writing a program in C#, let's first go back to day one, where
    we discussed the various IDEs and editors that are helpful in writing programs/applications
    using the C# language. Revisit day one and understand various editors and IDEs
    and check why we should go with one of our choice. We will be using Visual Studio
    2017 update 3 for all our examples in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用C#编写程序之前，让我们先回到第一天，我们在那里讨论了各种有助于使用C#语言编写程序/应用程序的集成开发环境和编辑器。回顾第一天，了解各种编辑器和IDE，并检查为什么我们应该选择其中之一。我们将在本书的所有示例中使用Visual
    Studio 2017更新3。
- en: To know the steps to install Visual Studio 2017, refer to [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解安装Visual Studio 2017的步骤，请参阅[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: 'To get start with a simple C# program (we will create a console application),
    follow these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一个简单的C#程序（我们将创建一个控制台应用程序），请按照以下步骤进行：
- en: Initiate your Visual Studio.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Visual Studio。
- en: Go to File | New | Project (or *ctrl* +*Shift* + *N*).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到文件 | 新建 | 项目（或*ctrl* +*Shift* + *N*）。
- en: Under Visual C# node, select .NET Core and then select Console App.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual C#节点下，选择.NET Core，然后选择控制台应用程序。
- en: 'Name your program, say, `Day02`, and click on OK (see highlighted text in the
    following figure):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的程序取一个名字，比如`Day02`，然后点击确定（见下图中的突出显示的文本）：
- en: '![](img/00011.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: 'You will get the following code in class `Program.cs` – this is the default
    code provided by Visual Studio; you can amend it as per your need:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在`Program.cs`类中得到以下代码-这是Visual Studio提供的默认代码；你可以根据需要进行修改：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By hitting the *F5* key on your keyboard, you will run the program in Debug
    mode.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在键盘上按下*F5*键，您将以Debug模式运行程序。
- en: Typically, every program has two different configurations or modes, that is,
    Debug and Release. In Debug mode, all compiled files and symbols that are helpful
    to drill down any issue encountered during the execution of application will be
    loaded. On the other hand, Release is kind of a clean run, where only binaries
    without Debug symbols load and perform the action. For more information, refer
    to [https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio](https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个程序都有两种不同的配置或模式，即Debug和Release。在Debug模式下，将加载所有编译文件和符号，这些对于在应用程序执行过程中遇到的任何问题进行深入分析是有帮助的。另一方面，Release是一种干净的运行，只有没有Debug符号的二进制文件加载并执行操作。有关更多信息，请参阅[https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio](https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio)。
- en: 'You can see the following output when the program runs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，您将看到以下输出：
- en: '![](img/00012.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: 'Before moving further, let''s analyze the following figure of our console application
    on Visual Studio:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们分析一下在Visual Studio上的控制台应用程序的下图：
- en: '![](img/00013.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: The preceding figure depicts a typical C# program; we are using Visual Studio,
    but the console program remains unchanged across different IDEs or editors. Let's
    discuss this in more detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示了一个典型的C#程序；我们使用的是Visual Studio，但控制台程序在不同的IDE或编辑器中保持不变。让我们更详细地讨论一下。
- en: 1 (System)
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1（System）
- en: This is a place where we defined what the namespaces going to be consumed in
    the program/application are. Generally, this is called using a statement, which
    includes the usage of external, internal, or any other namespaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在程序/应用程序中定义要使用的命名空间的地方。通常，这被称为使用语句，其中包括外部、内部或任何其他命名空间的使用。
- en: System is a typical namespace that contains a lot of fundamental classes. For
    more information, refer to [https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: System是一个包含许多基本类的典型命名空间。有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0)。
- en: 3 (Day02)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3（Day02）
- en: This is the namespace of our existing console application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们现有控制台应用程序的命名空间。
- en: A namespace is a way to keep one set of names separate from another, which means
    you can create as many namespaces as you want and the classes under different
    namespaces will treat them as a separate, although they have the same name; that
    is, if you declare a `ClassExample` class in `namespace Day02`, it would be different
    from the `ClassExample` class declared in the `Day02New` `namespace` and will
    work without any conflicts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是将一组名称与另一组名称分开的一种方式，这意味着您可以创建尽可能多的命名空间，而不同命名空间下的类将被视为不同的，尽管它们具有相同的名称；也就是说，如果在`namespace
    Day02`中声明了一个`ClassExample`类，它将与在`Day02New` `namespace`中声明的`ClassExample`类不同，并且将在没有任何冲突的情况下工作。
- en: 'This is a typical example that shows two classes of the same name with two
    different `namespaces`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的示例，显示了同名的两个类，它们有两个不同的`namespaces`：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code would be called like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将被调用如下：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '![](img/00014.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 2 (Program)
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2（Program）
- en: This is a class name defined in namespace - day two.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在命名空间-day two中定义的类名。
- en: A class in C# is a blueprint of an object. Objects are dynamically created instances
    of a class. In our console program, we have a class program that contains a method
    named `Main`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的类是对象的蓝图。对象是类的动态创建实例。在我们的控制台程序中，我们有一个包含名为`Main`的方法的程序类。
- en: 4 (Main)
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4（Main）
- en: This is an entry point for our program. At least one `Main` method is required
    for our C# program, and it should be static. We will discuss *static* in detail
    in the upcoming section, *Overview of C# reserved keywords*. `Main` is also a
    reserved keyword.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序的入口点。对于我们的C#程序，至少需要一个`Main`方法，并且它应该是静态的。我们将在接下来的部分“C#保留关键字概述”中详细讨论*static*。`Main`也是一个保留关键字。
- en: An entry is a way that lets CLR know the *what* and *where* of the functions
    located in the DLL. For instance, whenever we run our console application, it
    tells CLR that `Main` is the entry point and everything surrounds here. For more
    details, refer to [https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point)
    and [https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 入口是让CLR知道DLL中函数的*何时*和*何地*的方式。例如，每当我们运行我们的控制台应用程序时，它告诉CLR`Main`是入口点，以及周围的一切。有关更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point)和[https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point)。
- en: 5 (Day02)
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5（Day02）
- en: This is the name of the solution of our console application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们控制台应用程序的解决方案的名称。
- en: A solution can contain many libraries, applications, projects, and so on. For
    instance, our solution, Day02, would contain another project called Day03 or Day04\.
    A Visual Studio solution filename for our console application is `Day02.sln`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案可以包含许多库、应用程序、项目等。例如，我们的解决方案Day02将包含另一个名为Day03或Day04的项目。我们控制台应用程序的Visual
    Studio解决方案文件名是`Day02.sln`。
- en: Refer to [https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio](https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio)
    in order to understand the Visual Studio solution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio](https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio)以了解Visual
    Studio解决方案。
- en: To view the solution file, open the folder where `Day02.sln` solution file is
    located. You can directly open this file using any text editor/Notepad. I used
    Notepad++ ([https://notepad-plus-plus.org/](https://notepad-plus-plus.org/)) to
    view the solution file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看解决方案文件，请打开`Day02.sln`解决方案文件所在的文件夹。您可以直接使用任何文本编辑器/记事本打开此文件。我使用Notepad++ ([https://notepad-plus-plus.org/](https://notepad-plus-plus.org/))来查看解决方案文件。
- en: 'The following screenshot depicts our solution file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了我们的解决方案文件：
- en: '![](img/00015.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 6 (Day02)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6（Day02）
- en: This is a project of our console application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们控制台应用程序的一个项目。
- en: 'A project is a bundle that contains everything required for your program. This
    is the definition of the project from the official website: [https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio](https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目是一个包，其中包含了程序所需的一切。这是官方网站上对项目的定义：[https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio](https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio)
- en: A project is contained, in a logical sense and in the file system, within a
    solution, which may contain one or more projects, along with build information,Visual
    Studio window settings and any miscellaneous files that aren't associated with
    any project. In a literal sense, the solution is a text file with its own unique
    format; it is generally not intended to be edited by hand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑上和文件系统中，一个项目包含在一个解决方案中，该解决方案可能包含一个或多个项目，以及构建信息、Visual Studio窗口设置和与任何项目无关的任何杂项文件。从字面上讲，解决方案是一个具有自己独特格式的文本文件；通常不打算手动编辑。
- en: Our project filename is `Day02.csproj`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目文件名是`Day02.csproj`。
- en: You are not required to have a project for your application. You can directly
    start working on your C# files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要为您的应用程序创建一个项目。您可以直接开始在您的C#文件上工作。
- en: 'The following screenshot depicts our project file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了我们的项目文件：
- en: '![](img/00016.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: 7 (Dependencies)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7（依赖项）
- en: This refers to all references and binaries required to run a specific application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是运行特定应用程序所需的所有引用和二进制文件。
- en: 'Dependency is an assembly or dll on which our application depends or where
    our application is consuming the function of referred assembly. For instance,
    our console application requires .NET Core 2.0 SDK, so it includes it as dependencies.
    Refer to the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项是我们的应用程序依赖的程序集或dll，或者我们的应用程序正在使用所引用程序集的函数。例如，我们的控制台应用程序需要.NET Core 2.0 SDK，因此将其包含为依赖项。请参阅以下截图：
- en: '![](img/00017.gif)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.gif)'
- en: 8 (Program.cs)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8（Program.cs）
- en: This is physical class filename.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是物理类文件名。
- en: This is the name of a class file that is physically available on our disk drive.
    Class name and filename could be different, which means if my class name is `Program`,
    then my class filename could be `Program1.cs`. However, it is bad practice to
    call both class and filename with different names, but you can do that and the
    compiler won't throw any exception. For more information, refer to [https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched](https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在我们的磁盘驱动器上物理可用的类文件的名称。类名和文件名可以不同，这意味着如果我的类名是`Program`，那么我的类文件名可以是`Program1.cs`。然而，用不同的名称来命名类和文件名是不好的做法，但你可以这样做，编译器不会抛出任何异常。有关更多信息，请参阅[https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched](https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched)。
- en: Deep-dive into application using Visual Studio
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio深入了解应用程序
- en: In the previous section, you learned about various things that our console application
    can contain. In this section, lets deep-dive to get more insight on this using
    Visual Studio.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您了解了我们的控制台应用程序可以包含的各种内容。在本节中，让我们通过使用Visual Studio进行更深入的了解。
- en: 'To get started, go to the project properties. Do this from the solution explorer
    (right-click on project and click on Properties) or from menus (Project | Day02
    properties); you will get the project properties window, as shown in the following
    screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请转到项目属性。从解决方案资源管理器中进行此操作（右键单击项目，然后单击“属性”），或者从菜单中进行此操作（项目 | Day02属性）；您将获得项目属性窗口，如下截图所示：
- en: '![](img/00018.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: On the Application tab, we can set the Assembly name, the Default namespace,
    the Target framework, and the Output type (the output types are `Console Application`,
    `Windows Application`, `Class Library`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序选项卡上，我们可以设置程序集名称、默认命名空间、目标框架和输出类型（输出类型为`控制台应用程序`、`Windows应用程序`、`类库`）。
- en: 'The following screenshot is that of the Build tab:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是构建选项卡的截图：
- en: '![](img/00019.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: From the Build tab, we can set Conditional compilation symbols, Platform target,
    and other available options.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从构建选项卡中，我们可以设置条件编译符号、平台目标和其他可用选项。
- en: Conditional compilations are nothing but pre-processors, which we will discuss
    on day six.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译就是预处理器，我们将在第六天讨论。
- en: 'The following screenshot depicts the Package tab:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了包选项卡：
- en: '![](img/00020.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: The Package tab helps us directly create NuGet packages. In the earlier version,
    we needed a lot of configuration settings to build a NuGet package. In the current
    version, we just need to provide the information on the Package tab, and Visual
    Studio will generate the NuGet package according to our options. The Debug tab,
    Signing, and Resources tabs are self-explanatory and provide us with a way to
    sign assemblies and support to embed resources in our program.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 包选项卡帮助我们直接创建NuGet包。在早期版本中，我们需要大量配置设置来构建NuGet包。在当前版本中，我们只需要在包选项卡上提供信息，Visual
    Studio将根据我们的选项生成NuGet包。调试选项卡、签名和资源选项卡都是不言自明的，并为我们提供了一种签署程序集和支持在程序中嵌入资源的方法。
- en: Discussing code
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论代码
- en: We have gone through the console application and discussed what a typical console
    application contains and how we can set various things using Visual Studio. Now
    let's discuss our code, which was written in the previous section, *Understanding
    a typical C# program*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了控制台应用程序，并讨论了典型控制台应用程序包含的内容以及如何使用Visual Studio设置各种内容。现在让我们讨论我们在上一节“理解典型的C#程序”中编写的代码。
- en: '`Console` is a static class of a `System` namespace and it can''t be inherited.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`是`System`命名空间的静态类，不能被继承。'
- en: In the said code, we instructed the program to write something to the console
    as an output with the help of the `WriteLine()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们指示程序使用`WriteLine()`方法向控制台输出一些内容。
- en: 'The official definition of `Console` class is as follows ([https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0)):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`类的官方定义如下（[https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0)）：'
- en: Represents the standard input, output, and error streams for console applications.
    This class cannot be inherited.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表示控制台应用程序的标准输入、输出和错误流。此类不能被继承。
- en: '`Console` is nothing but an operating system''s terminal-windows (also known
    as **Console User Interface** (**CUI**))to interact with users. Windows operating
    system has console, that is, Command Prompt that accepts MS-DOS commands. In this
    way, the `Console` class provides basic support to achieve this.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`只是操作系统的终端窗口（也称为**控制台用户界面**（**CUI**））与用户交互。Windows操作系统有控制台，即接受MS-DOS命令的命令提示符。`Console`类提供了基本支持来实现这一点。'
- en: Here are a few important operations we can do with the console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以在控制台上执行的一些重要操作。
- en: Color
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色
- en: 'Console background and/or foreground color can be changed using setter and
    getter properties that accept the value of the `ConsoleColor` enum. To set it
    to the default color, there is a `Reset` method. Let''s demonstrate all color
    combinations using the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用设置器和获取器属性来更改控制台背景和/或前景颜色，这些属性接受`ConsoleColor`枚举的值。有一个`Reset`方法可以将其设置为默认颜色。让我们使用以下代码演示所有颜色组合：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code is one snippet from the complete source code that is available
    on the GitHub repository. The complete code will provide the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是来自GitHub存储库中可用的完整源代码的一部分。完整的代码将提供以下输出：
- en: '![](img/00021.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: Beep
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂鸣
- en: '`Beep` is the method that generates system sound through the console speaker.
    The following is the simplest example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Beep`是通过控制台扬声器生成系统声音的方法。以下是最简单的示例：'
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few more methods that are helpful while working with the console
    application. For more detail on these methods, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，还有一些有用的方法。有关这些方法的更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0)。
- en: Until now, we have discussed a typical C# program with the help of a code example
    using Visual Studio 2017; we went through various sections of the console program
    and discussed them. You can revisit this section once again or proceed with further
    reading.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Visual Studio 2017的代码示例讨论了典型的C#程序；我们已经讨论了控制台程序的各个部分。您可以再次查看本节，或者继续阅读。
- en: An overview of C# reserved keywords, types, and operators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#保留关键字、类型和运算符概述
- en: Reserved keywords are nothing but predefined words that have special meaning
    for the compilers. You cannot use these reserved keywords as normal text or identifiers
    unless you explicitly tell the compiler that this word is not meant to reserve
    for the compiler.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 保留关键字只是编译器的预定义单词，具有特殊含义。除非您明确告诉编译器该单词不是为编译器保留的，否则不能将这些保留关键字用作普通文本或标识符。
- en: In C#, you can use the reserved keyword as a normal word by prefixing the `@`
    symbol.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，您可以通过在保留关键字前加上`@`符号来将其用作普通单词。
- en: 'C# keywords are divided into the following categories:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C#关键字分为以下几类：
- en: '**Types**: In C#, the typing system is divided into value type, reference type,
    and pointer type.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：在C#中，类型系统分为值类型、引用类型和指针类型。'
- en: '**Modifiers**: As is self-explanatory from its name, modifiers are used to
    modify the declaration of types and members of a specific type.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**：从其名称就可以自解释，修饰符用于修改特定类型的声明和成员。'
- en: '**Statement keywords**: These are programming instructions that execute in
    a sequence.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句关键字**：这些是按顺序执行的编程指令。'
- en: '**Method parameters**: These can be declared as a value type or a ref type
    and values can be passed using **out** or **ref** keywords.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：这些可以声明为值类型或引用类型，并且可以使用**out**或**ref**关键字传递值。'
- en: '**Namespace keywords**: These are the keywords that belong to namespaces only.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间关键字**：这些是属于命名空间的关键字。'
- en: '**Operator keywords**: These operators are generally used to perform miscellaneous
    operations, such as type checking, getting the size of the object, and so on.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符关键字**：这些运算符通常用于执行各种操作，例如类型检查，获取对象的大小等。'
- en: '**Conversion keywords**: These are `explicit`, `implicit`, and `operator` keywords,
    which will be discussed in the upcoming sections.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换关键字**：这些是`explicit`、`implicit`和`operator`关键字，将在接下来的部分中讨论。'
- en: '**Access keywords**: These are common keywords that help access things from
    a class that belongs to its parent class or belongs to its own. These keywords
    are `this` and `base`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问关键字**：这些是帮助从属于其父类或自身的类中访问事物的常见关键字。这些关键字是`this`和`base`。'
- en: '**Literal keywords**: Keywords have some values for assignment, which are `null`,
    `true`, `false` , and `default`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文字关键字**：关键字具有一些用于赋值的值，即`null`、`true`、`false`和`default`。'
- en: '**Contextual keywords**: These are used as a specific meaning in the code.
    These are special keywords that are not reserved keywords in C#.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文关键字**：这些在代码中具有特定含义。这些是C#中未保留的特殊关键字。'
- en: '**Query keywords**: These are contextual keywords that can be used in a query
    expression, for instance, the `from` keyword can be used for LINQ.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询关键字**：这些是可以在查询表达式中使用的上下文关键字，例如，`from`关键字可以用于LINQ。'
- en: In the upcoming sections, we will discuss C# keywords in more detail using code
    examples.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用代码示例更详细地讨论C#关键字。
- en: Identifiers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符
- en: These keywords are used in any part of the C# program and are reserved. Identifiers
    are special keywords and are treated differently by the compiler.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字在C#程序的任何部分中使用，并且是保留的。标识符是特殊关键字，编译器对其进行不同处理。
- en: 'These are the identifiers that are reserved by C#:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是C#保留的标识符：
- en: '**abstract**: This informs you that things that come with the abstract modifier
    are yet to complete or have a missing definition. We will discuss this in detail
    on day four.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**abstract**：这告诉您带有抽象修饰符的事物尚未完成或缺少定义。我们将在第四天详细讨论这个。'
- en: '**as**: This can be used in a cast operation. In other words, we can say that
    this checks the compatibility between two types.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**as**：这可以用于转换操作。换句话说，我们可以说这检查两种类型之间的兼容性。'
- en: The `as` keyword falls in the operator category of keywords; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`关键字属于运算符类别的关键字；参考[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords)。'
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will produce the following result:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/00022.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: '**base**: This is the access keyword and is used to access members of the parent
    class from within derived classes. The following is the code snippet that shows
    the usage of the `base` keyword. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**base**：这是访问关键字，用于从派生类内部访问父类的成员。以下是显示`base`关键字用法的代码片段。有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base)'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a very simple example used to showcase the power of `base`. Here, we
    are just using base class members and methods to get the expected output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于展示`base`功能的非常简单的示例。在这里，我们只是使用基类成员和方法来获得预期的输出：
- en: '**bool**: This is an alias of `structureSystem.Boolean` that helps declare
    variables. This has two values: true or false. We will discuss this in detail
    in the upcoming section, *Data types*.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bool**：这是`structureSystem.Boolean`的别名，有助于声明变量。它有两个值：true或false。我们将在即将到来的部分*数据类型*中详细讨论这个。'
- en: '**break**: The keyword is self-explanatory; it breaks something within a particular
    code execution, which could be a flow statement (`for` loop) or the termination
    of a code block (`switch`). We will discuss this in detail in the upcoming section
    on loop and statements.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**break**：这个关键字很容易理解；它中断特定代码执行中的某些内容，可以是流程语句（`for`循环）或代码块的终止（`switch`）。我们将在循环和语句的即将到来的部分详细讨论这个。'
- en: '**byte**: This helps declare variables of an unsigned integer. This is an alias
    of `System.Byte`. We will discuss this in detail in the upcoming section.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**byte**：这有助于声明无符号整数的变量。这是`System.Byte`的别名。我们将在即将到来的部分详细讨论这个。'
- en: '**case**: This is used with the `Switch` statement, which then tends to a code
    block of execution based on some condition. We will discuss `switch` case on day
    three.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例**：这与`Switch`语句一起使用，然后根据某些条件执行代码块。我们将在第三天讨论`switch`案例。'
- en: '**catch**: This keyword is a catch block of exception handling blocks, that
    is, `try`..`catch`..`finally`. We will discuss exception handling in detail on
    day six.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**catch**：这个关键字是异常处理块的catch块，即`try`..`catch`..`finally`。我们将在第六天详细讨论异常处理。'
- en: '**char**: This keyword is useful when we declare a variable to store characters
    that belong to structure `System.Char`. We will discuss this in detail in the
    data type section.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**char**：当我们声明一个变量来存储属于结构`System.Char`的字符时，这个关键字很有用。我们将在数据类型部分详细讨论这个。'
- en: '**checked**: Sometimes, you might face overflow values in your program. Overflow
    exception means that you assigned a larger value than the max value of the assignee
    data type. The compiler raises the overflow exception and the program terminates.
    The keyword checks force the compiler to make sure that overflow will not happen
    to the scenario when the compiler misses it. To understand this better, look at
    the following code snippet:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**checked**：有时，您的程序可能会遇到溢出值。溢出异常意味着您分配了一个比被分配数据类型的最大值还要大的值。编译器会引发溢出异常，程序终止。关键字checks强制编译器确保在编译器忽略的情况下不会发生溢出。为了更好地理解这一点，请看下面的代码片段：'
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will generate a compile-time error. As soon as you write the preceding
    statement, you get the following error:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个编译时错误。一旦您写下前面的语句，您将得到以下错误：
- en: '![](img/00023.gif)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.gif)'
- en: 'The following code snippet is a modified code, as shown in the preceding figure.
    With this modification, the new code will not generate a compile-time error:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个修改后的代码，如前图所示。通过这种修改，新代码将不会生成编译时错误：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will never throw an overflow exception, but it would not
    give the correct sum; it gives -2147483647 as a result of `2147483647` + 19 because
    the actual sum will exceed the maximum positive value of an integer, that is,
    `2147483647`. It will produce the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码永远不会引发溢出异常，但它不会给出正确的总和；它会给出-2147483647作为`2147483647` + 19的结果，因为实际总和将超过整数的最大正值，即`2147483647`。它将产生以下输出：
- en: '![](img/00024.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: 'In real-world programs, we can''t take a risk with wrong calculations. We should
    use the checked keyword to overcome such situations. Let''s rewrite the preceding
    code using checked keywords:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的程序中，我们不能冒错计算的风险。我们应该使用checked关键字来克服这种情况。让我们使用checked关键字重写前面的代码：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As soon as you write the code using the checked keyword, you will see the following
    compile-time error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用checked关键字编写代码，您将看到以下编译时错误：
- en: '![](img/00025.gif)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.gif)'
- en: 'Now let''s discuss more keywords of C#:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论C#的更多关键字：
- en: '**class**: This keyword helps us declare classes. A C# class would contain
    members, methods, variables, fields, and so on (we will discuss these in detail
    on day four). Classes are different from structures; we will discuss this in detail
    in the *Classes versus structures* section.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**class**：这个关键字帮助我们声明类。C#类将包含成员、方法、变量、字段等（我们将在第四天详细讨论这些）。类与结构不同；我们将在*类与结构*部分详细讨论这个。'
- en: '**const**: This keyword helps us declare constant fields or constant locals.
    We will discuss this in detail on day three.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**const**：这个关键字帮助我们声明常量字段或常量局部变量。我们将在第三天详细讨论这个。'
- en: '**continue**: This keyword is the opponent of `break`. It passes control to
    the next iteration in the flow statements, that is, `while`, `do`, `for`, and
    `foreach`. We will discuss this in detail in the upcoming sections.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**continue**：这个关键字是`break`的对手。它将控制传递给流程语句中的下一次迭代，即`while`、`do`、`for`和`foreach`。我们将在接下来的部分详细讨论这个。'
- en: '**decimal**: This helps us declare a data type of 128-bit. We will discuss
    this in detail in the *Data types* section.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**decimal**：这有助于我们声明一个128位的数据类型。我们将在*数据类型*部分详细讨论这个。'
- en: '**default**: This is the keyword that tells us the default condition in a `switch`
    statement. We can also use the default as a literal to get the default values;
    we will discuss this on day three.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**default**：这是告诉我们`switch`语句中的默认条件的关键字。我们也可以使用默认作为文字来获取默认值；我们将在第三天讨论这个。'
- en: '**delegate**: This helps declare a delegate type that is similar to method
    signature. We will discuss this in detail on day six.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**delegate**：这有助于声明类似于方法签名的委托类型。我们将在第六天详细讨论这个。'
- en: '**do**: This executes a statement repeatedly until it meets the expression
    condition of false. We will discuss this in the upcoming section.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**do**：这会重复执行一个语句，直到满足假的表达式条件。我们将在接下来的部分讨论这个。'
- en: '**double**: This helps declare simple 64-bit floating point values. We will
    discuss this in detail in the upcoming section.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**double**：这有助于声明简单的64位浮点值。我们将在接下来的部分详细讨论这个。'
- en: '**else**: This comes with the `if` statement and executes the `code` statement
    that does not fall within the `if` condition. We will discuss this in detail in
    the coming section.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**else**：这与`if`语句一起，并执行不符合`if`条件的`code`语句。我们将在接下来的部分详细讨论这个。'
- en: '**enum**: This helps create enumerations. We will discuss this on day four.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**enum**：这有助于创建枚举。我们将在第四天讨论这个。'
- en: '**event**: This helps declare an event in a publisher class. We will discuss
    this in detail on day six.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**event**：这有助于在发布者类中声明事件。我们将在第六天详细讨论这个。'
- en: '**explicit**: This is one of the conversion keywords. This keyword declares
    a user-defined type conversion operator. We will discuss this in detail in the
    upcoming section.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**explicit**：这是转换关键字之一。此关键字声明用户定义的类型转换运算符。我们将在接下来的部分详细讨论这个。'
- en: '**false**: A bool value indicates the `false` condition, `result`, or `Operator`.
    We will discuss this in detail in the upcoming sections.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**false**：布尔值表示`false`条件，`result`或`Operator`。我们将在接下来的部分详细讨论这个。'
- en: '**finally**: This is a part of exception handling blocks. Finally, a block
    is always executed. We will discuss this in detail on day four.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**finally**：这是异常处理块的一部分。最终，块总是被执行。我们将在第四天详细讨论这个。'
- en: '**fixed**: This is used in unsafe code and is helpful in preventing GC allocation
    or relocation. We will discuss this in detail on day six.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fixed**：这在不安全的代码中使用，有助于防止GC分配或重定位。我们将在第六天详细讨论这个。'
- en: '**float**: This is a simple data type that stores a 32-bit floating point value.
    We will discuss this in detail in the upcoming section.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**float**：这是一个简单的数据类型，用于存储32位浮点值。我们将在接下来的部分详细讨论这个。'
- en: '**for**: The `for` keyword is a part of flow statements. With the use of the
    `for` loop, you can run a statement repeatedly until a specific expression is
    reached. We will discuss this in detail in the upcoming section.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于：`for`关键字是流程语句的一部分。通过使用`for`循环，可以重复运行一个语句，直到达到特定的表达式。我们将在接下来的章节中详细讨论这个问题。
- en: '**foreach**: This is also a flow statement, but it works only on elements for
    collections or arrays. This can be exited using the `goto`, `return`, `break`,
    and `throw` keywords. We will discuss this in detail in the upcoming section.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个：这也是一个流程语句，但它只适用于集合或数组的元素。可以使用`goto`、`return`、`break`和`throw`关键字退出。我们将在接下来的章节中详细讨论这个问题。
- en: '**goto**: This redirects the control to another part with the help of a label.
    In C#, goto is typically used with the `switch..case` statement. We will discuss
    this in detail in the upcoming sections.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到：这将通过标签将控制转移到另一个部分。在C#中，goto通常与`switch..case`语句一起使用。我们将在接下来的章节中详细讨论这个问题。
- en: '**if**: This is a conditional statement keyword. It typically comes with the
    `if...else` statement. We will discuss this in detail in the upcoming sections.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果：这是一个条件语句关键字。它通常与`if...else`语句一起使用。我们将在接下来的章节中详细讨论。
- en: '**implicit**: Similar to the explicit keyword, this helps declare an implicit
    user-defined conversion. We will discuss this in detail in the upcoming sections.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式：类似于显式关键字，这有助于声明隐式用户定义的转换。我们将在接下来的章节中详细讨论这个问题。
- en: '**in**: A keyword helps detect the collection from where we need to iterate
    through members in the `foreach` loop. We will discuss this in detail in the upcoming
    sections.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在：一个关键字，有助于检测我们需要在`foreach`循环中迭代的集合。我们将在接下来的章节中详细讨论这个问题。
- en: '**int**: This is an alias of structure `System.Int32` and a data type that
    stores signed 32-bit integer values. We will discuss this in detail in the upcoming
    sections.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：这是结构`System.Int32`的别名，是一个存储有符号32位整数值的数据类型。我们将在接下来的章节中详细讨论这个问题。
- en: '**interface**: This keyword helps declare an interface that can only contain
    methods, properties, events, and indexers (we will discuss this on day four).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口：这个关键字有助于声明一个只能包含方法、属性、事件和索引器的接口（我们将在第四天讨论这个问题）。
- en: '**internal**: This is an access modifier. We will discuss this in detail on
    day four.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部：这是一个访问修饰符。我们将在第四天详细讨论。
- en: '**is**: Similar to the `as` operator, `is` is also a keyword operator.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是：类似于`as`操作符，`is`也是一个关键字操作符。
- en: 'This is a code example showing the `is` operator:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个显示`is`操作符的代码示例：
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For complete explanation of `is` and `as` operators, refer to [https://goo.gl/4n73JC](https://goo.gl/4n73JC).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`is`和`as`操作符的完整解释，请参阅[https://goo.gl/4n73JC](https://goo.gl/4n73JC)。
- en: '**lock**: This represents a critical section of the code block. With the use
    of the `lock` keyword, we will get a mutual exclusion lock of an object, and it
    will get released after execution of the statement. This generally comes with
    the use of threading. Threading is beyond the scope of this book. For more details,
    refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement)
    and [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定：这表示代码块的临界区。通过使用`lock`关键字，我们将获得对象的互斥锁，并在语句执行后释放。这通常与线程一起使用。线程超出了本书的范围。有关更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement)和[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index)。
- en: '**long**: This helps declare variables to store signed 64-bit integers values,
    and it refers to structure `System.Int64`. We will discuss this in detail in the
    upcoming sections.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长：这有助于声明变量来存储有符号的64位整数值，并且它指的是结构`System.Int64`。我们将在接下来的章节中详细讨论这个问题。
- en: '**namespace**: This helps define namespaces that declare a set of related objects.
    We will discuss this in details on day four.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：这有助于定义声明一组相关对象的命名空间。我们将在第四天详细讨论这个问题。
- en: '**new**: The `new` keyword can be an operator, a modifier, or a constraint.
    We will discuss this in detail on day four.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新：`new`关键字可以是操作符、修饰符或约束。我们将在第四天详细讨论这个问题。
- en: '**null**: This represents a null reference. It does not refer to any object.
    The default value of reference type is null. This is helpful while working with
    nullable types.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空：这表示空引用。它不指向任何对象。引用类型的默认值是null。在使用可空类型时很有帮助。
- en: '**object**: This is an alias of `System.Object`, the universal type in .NET
    world. It accepts any data type instead of null.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：这是`System.Object`的别名，在.NET世界中是通用类型。它接受任何数据类型而不是null。
- en: '**operator**: This helps overload the built-in operator. We will discuss this
    in detail in the upcoming sections..'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符：这有助于重载内置操作符。我们将在接下来的章节中详细讨论这个问题。
- en: '**out**: This is a contextual keyword and will be discussed in detail on day
    four.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：这是一个上下文关键字，将在第四天详细讨论。
- en: '**override**: This keyword helps override or extend the implementation of abstract
    or virtual members, methods, properties , indexer, or event. We will discuss this
    in detail on day four.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖：这个关键字有助于覆盖或扩展抽象或虚拟成员、方法、属性、索引器或事件的实现。我们将在第四天详细讨论这个问题。
- en: '**params**: This helps define method parameters with a variable number of arguments.
    We will discuss this in detail on day four.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：这有助于使用可变数量的参数定义方法参数。我们将在第四天详细讨论这个问题。
- en: '**private**: This is an access modifier and will be discussed on day four.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私人：这是一个访问修饰符，将在第四天讨论。
- en: '**protected**: This is an access modifier and will be discussed on day four.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的：这是一个访问修饰符，将在第四天讨论。
- en: '**public**: This is an access modifier that sets the availability through the
    application and will be discussed on day four.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共：这是一个访问修饰符，设置了整个应用程序的可用性，将在第四天讨论。
- en: '**readonly**: This helps us declare field declaration as read-only. We will
    discuss this in detail on day four.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readonly**：这有助于我们将字段声明为只读。我们将在第四天详细讨论这个问题。'
- en: '**ref**: This helps pass values by reference. We will discuss this in detail
    on day four.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ref**：这有助于通过引用传递值。我们将在第四天详细讨论这个问题。'
- en: '**return**: This helps terminate the execution of a method and returns the
    result for the calling method. We will discuss this in detail on day four.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**return**：这有助于终止方法的执行，并返回给调用方法的结果。我们将在第四天详细讨论这个问题。'
- en: '**sbyte**: This denotes `System.SByte` and stores signed 8-bit integer values.
    We will discuss this in detail in the upcoming sections.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sbyte**：这表示`System.SByte`并存储带符号的8位整数值。我们将在接下来的部分中详细讨论这个问题。'
- en: '**sealed**: This is a modifier that prevents further usage/extension. We will
    discuss this in detail on day four.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sealed**：这是一个修饰符，防止进一步使用/扩展。我们将在第四天详细讨论这个问题。'
- en: '**short**: This denotes `System.Int16` and stores signed 16-bit integer values.
    We will discuss this in detail in the upcoming sections.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短**：这表示`System.Int16`并存储带符号的16位整数值。我们将在接下来的部分中详细讨论这个问题。'
- en: '**sizeof**: This helps get the size in bytes of the inbuilt type and/or unmanaged
    type. For unmanaged and all other types apart from inbuilt data types, the unsafe
    keyword is required.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sizeof**：这有助于获取内置类型和/或不受管理类型的字节大小。对于不受管理和除内置数据类型之外的所有其他类型，需要使用`unsafe`关键字。'
- en: 'The following code is explained `sizeof` using built-in types:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码解释了使用内置类型的`sizeof`：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code produces the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/00026.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: 'Let''s discuss more C# keywords; these keywords are very important and play
    a vital role while writing real-world programs:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论更多的C#关键字；这些关键字在编写现实世界程序时非常重要，并在其中发挥着重要作用：
- en: '**static**: This helps us declare static members and will be discussed in detail
    on day four.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**static**：这有助于我们声明静态成员，并将在第四天详细讨论。'
- en: '**string**: This helps store unicode characters. It is a reference type. We
    will be discussing this in more detail in the upcoming section, **String.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：这有助于存储Unicode字符。这是一个引用类型。我们将在接下来的部分中更详细地讨论这个问题，**字符串**。'
- en: '**struct**: This helps us declare a `struct` type. Struct type is a value type.
    We will be discussing this in more detail in the upcoming section, *Classes versus.
    structs*.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：这有助于我们声明一个`struct`类型。结构类型是一个值类型。我们将在接下来的部分中更详细地讨论这个问题，*类与结构*。'
- en: '**switch**: This helps declare a `switch` statement. Switch is a selection
    statement, and we will be discussing it on day three.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch**：这有助于声明一个`switch`语句。Switch是一个选择语句，我们将在第三天讨论它。'
- en: '**this**: This `this` keyword helps us access the members of the current instance
    of a class. It is also a modifier and we will be discussing on day four. Note
    that the `this` keyword has a special meaning for the `extension` method. Extension
    methods are beyond the scope of this book; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
    for more detail.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**this**：这个`this`关键字帮助我们访问当前类实例的成员。它也是一个修饰符，我们将在第四天讨论。请注意，`this`关键字对于`extension`方法有特殊含义。扩展方法超出了本书的范围；有关更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)。'
- en: '**throw**: This helps throw a system or custom exceptions. We will be discussing
    this in detail on day six.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**throw**：这有助于抛出系统或自定义异常。我们将在第六天详细讨论这个问题。'
- en: '**true**: Similar to false, we discussed this earlier. It represents a Boolean
    value and can be a literal or operator. We will discuss this in more detail in
    the upcoming section.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**true**：与false类似，我们之前讨论过这个问题。它表示一个布尔值，可以是文字或操作符。我们将在接下来的部分中更详细地讨论这个问题。'
- en: '**try**: This represents a `try` block of exception handling. Try block is
    one of the other three blocks that helps handle any unavoidable errors or instances
    of programs. All three blocks are jointly called exceptional handling blocks.
    The try block always comes first. This block contains the code that could throw
    an exception. We will discuss this in more detail on day six.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try**：这表示异常处理的`try`块。Try块是帮助处理任何不可避免的错误或程序实例的另外三个块之一。所有三个块共同称为异常处理块。try块总是首先出现。这个块包含可能引发异常的代码。我们将在第六天详细讨论这个问题。'
- en: '**typeof**: This helps get the type object for a desired type. Also, at runtime,
    you can get the type of object with the help of the `GetType()` method.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**typeof**：这有助于获取所需类型的类型对象。此外，在运行时，您可以使用`GetType()`方法获取对象的类型。'
- en: 'The following code snippet shows the `typeof()` method in action:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`typeof()`方法的运行情况：
- en: '[PRE14]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code will generate the following result:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成以下结果：
- en: '![](img/00027.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'These are the unsigned data types, and these data types store values without
    sign (*+*/*-*):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是无符号数据类型，这些数据类型存储没有符号的值（*+*/*-*）：
- en: '**uint**: This helps declare a variable of an unsigned 32-bit integer. We will
    be discussing this in detail in the upcoming section.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uint**：这有助于声明一个无符号32位整数的变量。我们将在接下来的部分中详细讨论这个问题。'
- en: '**ulong**: This helps declare a variable of an unsigned 65-bit integer. We
    will be discussing this in detail in the upcoming section.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ulong**：这有助于声明一个无符号65位整数的变量。我们将在接下来的部分中详细讨论这个问题。'
- en: '**unchecked**: This keyword works exactly opposite to checked. The code block
    that threw a compile-time error with the use of the checked keyword will not generate
    any compile-time exception with the use of the unchecked keyword.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unchecked**：这个关键字的作用与`checked`完全相反。使用`checked`关键字抛出编译时错误的代码块，使用`unchecked`关键字不会生成任何编译时异常。'
- en: 'Let''s rewrite the code that we wrote using the checked keyword and see how
    the unchecked keyword works exactly opposite to checked:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写使用`checked`关键字编写的代码，并看看`unchecked`关键字如何与`checked`完全相反：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will run smoothly but will give the wrong result, that is,
    *-2147483647*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detail on the checked and unchecked keywords by referring
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**unsafe**: This helps execute an unsafe code block that generally uses pointers.
    We will be discussing this in detail on day six.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ushort**: This helps declare a variable of an unsigned 16-bit integer. We
    will be discussing this in more detail in the upcoming section, *Data types*.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**using**: The `using` keyword works like a directive or statement. Let''s
    consider the following code example:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding directive provides everything that belongs to the `System` namespace:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding directive helps us call static members. After inclusion of the
    preceding directive in the program, we can directly call static members, methods,
    and so on, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code produces the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'C# keywords virtual and void have a special meaning: one allows the other to
    override it, while the other is a used as a return type when the method returns
    nothing. Let''s discuss both in detail:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**virtual**: If the virtual keyword is used, it means that it allows methods,
    properties, indexers, or events to override in a derived class. We will be discussing
    this in more detail on day four.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void**: This is an alias of the `System.Void` type. When void uses the method,
    it means the method does not have any return type. For instance, take a look at
    the following code snippet:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**while**: While is a flow statement that executes the specific code block
    until a specified expression evaluates false. We will be discussing this in more
    detail in the upcoming section, *Flow statements*.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextual
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are not reserved keywords, but they have a special meaning for a limited
    context of a program and can also be used as an identifier outside that context.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the contextual keywords of C#:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**add**: This is used to define a custom accessor and it invokes when someone
    subscribes to an event. The `add` accessors are always followed by the `remove`
    accessors, which means when we provide the add accessor, the remove accessor should
    be applied thereon. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-implement-interface-events](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-implement-interface-events).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ascending/descending**: This contextual keyword is used with an `orderby`
    clause in a `LINQ` statement. We will discuss this in more detail on day six.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**async**: This is used for an asynchronous method, lambda expression, or anonymous
    method. To get the result from asynchronous methods, the `await` keyword is used.
    We will be discussing this in more detail on day six.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dynamic**: This helps us bypass the compile-time type checking. This resolves
    types at runtime.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile time type is what you used to define a variable. Runtime type refers
    to the actual type to which a variable belongs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code in order to understand these terms better:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can create an object of our child class like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, compile-time type for `myObject` is `Parent` as the compiler knows the
    variable is a type of `Parent` without caring or knowing about the fact that we
    are instantiate this object with type `Child`. Hence this is a compile-time type.
    Runtime type is the actual type that is `Child` in our example. Hence, runtime
    type of our variable `myObject` is `Child`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The above code produces following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'For more information, refer: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the contextual keywords that are used in query expressions; let''s
    discuss these keywords in detail:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在查询表达式中使用的上下文关键字；让我们详细讨论这些关键字：
- en: '**from**: This uses the in query expression and will be discussed on day six.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**from**：这在查询表达式中使用，将在第六天讨论。'
- en: '**get**: This defines the accessor and is used along with properties for the
    retrieval of values. We will be discussing this in more detail on day six.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get**：这定义了访问器，并与属性一起用于检索值。我们将在第六天更详细地讨论这个问题。'
- en: '**group**: This is used with a query expression and returns a sequence of `IGroupong<Tkey,TElement>`
    objects. We will discuss this in more detail on day six.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**：这与查询表达式一起使用，并返回一系列`IGroupong<Tkey,TElement>`对象。我们将在第六天更详细地讨论这个问题。'
- en: '**into**: This identifier helps store temporary data while working with query
    expressions. We will discuss this in more detail on day six.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**into**：这个标识符在处理查询表达式时帮助存储临时数据。我们将在第六天更详细地讨论这个问题。'
- en: For more information on contextual keywords, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有关上下文关键字的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords)。
- en: Types
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: In C#, 7.0 types are also known as data types and variables. These are categorized
    into the following broader categories.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，7.0类型也被称为数据类型和变量。这些被归类为以下更广泛的类别。
- en: Value type
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: 'These are derived from the `System.ValueType` class. Variables of the value
    type directly contains their data or, in simple words, the value type variable
    can be assigned directly. Value types can be divided into more sub categories:
    data types, custom types (`Enum` types and `Struct` types). In this section, we
    will discuss the data types in detail. `Enum` will be discussed on day four and
    struct will be discussed in the upcoming sections.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型是从`System.ValueType`类派生的。值类型的变量直接包含它们的数据，或者简单地说，值类型变量可以直接赋值。值类型可以分为更多的子类别：数据类型、自定义类型（`Enum`类型和`Struct`类型）。在本节中，我们将详细讨论数据类型。`Enum`将在第四天讨论，结构将在接下来的章节中讨论。
- en: Data types
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'These are also famous as compliant value types, simple value types, and basic
    value types. I call these data types because of their power to define the nature
    of values. The following table contains all value types:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也被称为符合值类型、简单值类型和基本值类型。我称这些数据类型是因为它们定义值的性质。以下表包含所有值类型：
- en: '| **Nature** | **Type** | **CLR Type** | **Range** | **Default Value** | **Size**
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **性质** | **类型** | **CLR类型** | **范围** | **默认值** | **大小** |'
- en: '| Signed Integer | sbyte | `System.SByte` | -128 to 127 | 0 | 8 bit |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 签名整数 | sbyte | `System.SByte` | -128 到 127 | 0 | 8位 |'
- en: '|  | short | `System.Short` | -32,768 to 32,767 | 0 | 16 bit |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  | short | `System.Short` | -32,768 到 32,767 | 0 | 16位 |'
- en: '|  | int | `System.Int32` | -2,147,483,648 to 2,147,483,647 | 0 | 32 bit |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  | int | `System.Int32` | -2,147,483,648 到 2,147,483,647 | 0 | 32位 |'
- en: '|  | long | `System.Int64` | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 0L | 64 bit |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  | long | `System.Int64` | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
    | 0L | 64位 |'
- en: '| Unsigned Integer | byte | `System.Byte` | 0 to 255 | 0 | 8 bit |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整数 | byte | `System.Byte` | 0 到 255 | 0 | 8位 |'
- en: '|  | ushort | `System.UInt16` | 0 to 65,535 | 0 | 16 bit |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  | ushort | `System.UInt16` | 0 到 65,535 | 0 | 16位 |'
- en: '|  | uint | `System.UInt32` | 0 to 4,294,967,295 | 0 | 32 bit |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  | uint | `System.UInt32` | 0 到 4,294,967,295 | 0 | 32位 |'
- en: '|  | ulong | `System.UInt64` | 0 to 18,446,744,073,709,551,615 | 0 | 64 bit
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  | ulong | `System.UInt64` | 0 到 18,446,744,073,709,551,615 | 0 | 64位 |'
- en: '| Unicode Character | char | `System.Char` | U +0000 to U +ffff | ''\0'' |
    16 bit |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| Unicode字符 | char | `System.Char` | U +0000 到 U +ffff | ''\0'' | 16位 |'
- en: '| Floating point | float | `System.Float` | -3.4 x 10^(38) to + 3.4 x 10^(38)
    | 0.0F | 32 bit |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | float | `System.Float` | -3.4 x 10^(38) 到 + 3.4 x 10^(38) | 0.0F |
    32位 |'
- en: '|  | double | `System.Double` | (+/-)5.0 x 10^(-324) to (+/-)1.7 x 10^(308)
    | 0.0D | 64 bit |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  | double | `System.Double` | (+/-)5.0 x 10^(-324) 到 (+/-)1.7 x 10^(308)
    | 0.0D | 64位 |'
- en: '| Higher-precision decimal | decimal | `System.Decimal` | (-7.9 x 1028 to 7.9
    x 1028) / 100 to 28 | 0.0M | 128 bit |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 更高精度的十进制 | decimal | `System.Decimal` | (-7.9 x 1028 到 7.9 x 1028) / 100
    到 28 | 0.0M | 128位 |'
- en: '| Boolean | bool | `System.Boolean` | True or False | False | Boolean value
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | bool | `System.Boolean` | 真或假 | 假 | 布尔值 |'
- en: 'We can prove the values mentioned in the preceding table with the help of the
    following code snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码片段证明前表中提到的值：
- en: '[PRE24]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we are displaying maximum and minimum values of data
    types, which produces the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们显示了数据类型的最大值和最小值，产生了以下输出：
- en: '![](img/00030.jpeg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Reference type
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'The actual data is not stored in the variable but it contains reference to
    variables. In simple words, we can say that the reference type refers to a memory
    location. Also, multiple variables can refer to one memory location, and if any
    of these variables change the data to that location, all the variables would get
    the new values. Here are the built-in reference types:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实际数据并不存储在变量中，而是包含对变量的引用。简单地说，我们可以说引用类型是指向内存位置的引用。此外，多个变量可以引用一个内存位置，如果这些变量中的任何一个改变了该位置的数据，所有变量都将获得新值。以下是内置的引用类型：
- en: '**class type**: A data structure that contains members, methods, properties,
    and so on. This is also called the object type as this inherits the universal
    `classSystem.Object`. In C# 7.0, class type supports single inheritance; we will
    discuss this in more detail on day seven.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类类型**：包含成员、方法、属性等的数据结构。这也被称为对象类型，因为它继承了通用的`classSystem.Object`。在C# 7.0中，类类型支持单继承；我们将在第七天更详细地讨论这个问题。'
- en: The object type can be assigned a value of any other type; an object is nothing
    but an alias of `System.Object`. In this context, any other type is meant to be
    a value type, reference type, predefined type, and user-defined type.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型可以被赋予任何其他类型的值；对象只是`System.Object`的别名。在这种情况下，其他类型指的是值类型、引用类型、预定义类型和用户定义类型。
- en: There is a concept called `boxing` and `unboxing` that happens once we deal
    with an object type. In general, whenever value type is converted into the object
    type, it is called `boxing`, and when object type is converted into a value type,
    it is called `unboxing.`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个概念叫做`装箱`和`拆箱`，当我们处理对象类型时会发生。一般来说，当值类型转换为对象类型时，称为`装箱`，当对象类型转换为值类型时，称为`拆箱`。
- en: 'Take a look at the following code snippet:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE25]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/00031.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'Here, we are going to discuss three important types, which are interface, string,
    and delegate type:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论三种重要的类型，它们是接口、字符串和委托类型：
- en: '**interface type**: This type is basically a contract that is meant to be implemented
    by whoever is going to use it. A class or struct may use one or more interface
    types. One interface type may be inherited from multiple other interface types.
    We will discuss this in more details on day seven.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口类型**：这种类型基本上是一个合同，谁要使用它就必须实现它。一个类或结构体可以使用一个或多个接口类型。一个接口类型可以从多个其他接口类型继承。我们将在第七天更详细地讨论这个问题。'
- en: '**delegate type**: This is a type that represents a reference to a method of
    a parameter list. Famously, delegates are known as function pointers (as defined
    in C++). Delegates are type- safe. We will discuss this in detail on day four.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托类型**：这是一个表示参数列表中方法的引用的类型。众所周知，委托被称为函数指针（如C++中定义）。委托是类型安全的。我们将在第四天详细讨论这个问题。'
- en: '**string type**: This is an alias of `System.String`. This type allows you
    to assign any string value to variables. We will discuss this in detail in the
    upcoming sections.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串类型**：这是`System.String`的别名。这种类型允许你将任何字符串值赋给变量。我们将在接下来的章节中详细讨论这个问题。'
- en: Pointer type
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针类型
- en: This type belongs to unsafe code. The variable defined as a pointer type stores
    the memory address of another variable. We will discuss this in details on day
    six.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型属于不安全的代码。定义为指针类型的变量存储另一个变量的内存地址。我们将在第六天详细讨论这个问题。
- en: Null type
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空类型
- en: 'Nullable types are nothing but an instance of the `System.Nullable<T>` struct.
    The nullable type contains the same data range as that of its `ValueType` but
    with addition to a null value. Refer to the data type table where int has a range
    of 2147483648 to 2147483647 but `System.Nullable<int>` or `int`? has the same
    range in addition to null. This means you can do this: `int? nullableNum = null;`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型只是`System.Nullable<T>`结构的一个实例。可空类型包含与其`ValueType`相同的数据范围，但额外增加了一个空值。参考数据类型表，其中int的范围为2147483648到2147483647，但`System.Nullable<int>`或`int`?具有相同的范围，另外还可以为null。这意味着你可以这样做：`int?
    nullableNum = null;`。
- en: For more detail on nullable types, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可空类型的更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/)。
- en: Operators
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'In C#, operators are nothing but mathematical or logical operators that tell
    the compiler to perform a specific operation. For instance, a multiplication (*)
    operator tells the compiler to multiply; on the other hand, the logical and (&&)
    operator checks both the operands. We can divide C# operators into broader types,
    as shown in the following table:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，运算符只是告诉编译器执行特定操作的数学或逻辑运算符。例如，乘法(*)运算符告诉编译器进行乘法运算；另一方面，逻辑与(&&)运算符检查两个操作数。我们可以将C#运算符分为更广泛的类型，如下表所示：
- en: '| Type | Operator | Description |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 运算符 | 描述 |'
- en: '| Arithmetic operators | + | Adds two operands, for example, `var result =
    num1 +num2;` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算符 | + | 添加两个操作数，例如，`var result = num1 +num2;` |'
- en: '|  | - | Subtracts second operand from first operand, for example, `var result
    = num1 - num2;` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  | - | 从第二个操作数中减去第一个操作数，例如，`var result = num1 - num2;` |'
- en: '|  | * | Multiplies both operands, for example, `var result = num1 * num2;`
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  | * | 乘以两个操作数，例如，`var result = num1 * num2;` |'
- en: '|  | / | Divides the numerator by the denominator, for example, `var result
    = num1 / num2;` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  | / | 除以分子除以分母，例如，`var result = num1 / num2;` |'
- en: '|  | % | Modulus, for example, `result = num1 % num2;` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|  | % | 取模，例如，`result = num1 % num2;` |'
- en: '|  | ++ | Incremental operator that increases the value by 1\. , for example,
    `var result = num1++;` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  | ++ | 增量运算符，将值增加1，例如，`var result = num1++;` |'
- en: '|  | -- | Decrement operator that decreases the value by 1, for example, `var
    result = num1--;` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  | -- | 递减运算符，将值减1，例如，`var result = num1--;` |'
- en: '| Relational operators | == | Determines whether the two operands are of the
    same value. It returns True if the expression is successful; otherwise it returns
    false, for example, `var result = num1 == num2;` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 关系运算符 | == | 确定两个操作数是否具有相同的值。如果表达式成功，则返回True；否则返回false，例如，`var result = num1
    == num2;` |'
- en: '|  | != | Performs the same as `==` but negates the comparison; if two operands
    are equal, it returns false, for example, `var result = num1 != num2;` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  | != | 执行与`==`相同的操作，但否定比较；如果两个操作数相等，则返回false，例如，`var result = num1 != num2;`
    |'
- en: '|  | > | Determines whether in expression, the left operand is greater than
    the right operand and returns True on success, for example, `var result = num1
    > num2;` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  | > | 确定表达式中左操作数是否大于右操作数，并在成功时返回True，例如，`var result = num1 > num2;` |'
- en: '|  | < | Determines whether in expression, the left operand is less than the
    right operand and returns true on success, for example, `var result = num1 < num2;`
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  | < | 确定表达式中左操作数是否小于右操作数，并在成功时返回true，例如，`var result = num1 < num2;` |'
- en: '|  | >= | Determines whether in expression, the value of the left operand is
    greater than or equal to the value of the right operand and returns true on success,
    for example, `var result = num1 <= num2;` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  | >= | 确定表达式中左操作数的值是否大于或等于右操作数的值，并在成功时返回true，例如，`var result = num1 <= num2;`
    |'
- en: '|  | <= | Determines whether in expression, the value of the left operand is
    less than or equal to the value of the right operand and returns true on success,
    for example, `var result = num1 <= num2;` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| Logical operators | && | This is a logical `AND` operator. Expression evaluates
    on the basis of the left operand; if it''s true, then the right operand would
    not be ignored, for example, `var result = num1 && num2;` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '|  | &#124;&#124; | This is a logical `OR` operator. Expression evaluates to
    true if any of the operands is true, for example, `var result = num1 &#124;&#124;
    num2;` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '|  | ! | This is called the logical `NOT` operator. It reverses the evaluation
    result, for example, `var result = !(num1 && num2);` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| Bitwise operators | &#124; | This is a bitwise `OR` operator and works on
    bits. If either of the bits is 1, the result will be 1, for example, `var result
    = num1 &#124; num2;` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '|  | & | This is a bitwise `AND` operator and works on bits. If either of the
    bits is 0, then the result is 0; otherwise, it''s 1, for example, `var result
    = num1 & num2;` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '|  | ^ | This is a bitwise `XOR` operator and works on bits. If bits are the
    same, the result is 0; otherwise, it''s 1, for example, `var result = num1 ^ num2;`
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '|  | ~ | This is a unary operator and is called a bitwise `COMPLEMENT` operator.
    This works on a single operand and reverses the bit, which means if the bit is
    0, then it returns 1 and vice- versa, for example, `var result = ~num1;` |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '|  | << | This is a bitwise left shift operator and shifts a number to the
    left by the number of bits specified in the expression and adds the zeros to the
    least significant bits, for example, `var result = num1 << 1;` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '|  | >> | This is a bitwise right shift operator and shifts a number to the
    right by the number of bits specified in the expression, for example, `var result
    = num1 >> 1;` |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| Assignment operators | = | The assignment operator that assigns values from
    right-hand side to the left-hand side operand, for example, `var result = nim1
    + num2;` |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '|  | += | The add and assign operator; It adds and assigns values of the right
    operands to the left operands, for example, `result += num1;` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '|  | -= | The subtract and assign operator; It subtracts and assigns values
    of the right operands to the left operands, for example, `result -= num1;` |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '|  | *= | The multiply and assign operator; It multiplies and assigns values
    of the right operands to the left operands, for example, `result *= num1;` |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '|  | /= | The divide and assign operator; It divides and assigns values of
    the right operands to the left operands, for example, `result /= num1;` |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '|  | %= | The modulus and assign operator; It takes modulus of the left and
    right operands and assigns value to the left operands, for example, `result %=
    num1;` |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '|  | <<= | Bitwise left shifts and assignment, for example, `result <<= 2;`
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '|  | >>;= | Bitwise right shifts and assignment, for example, `result >>= 2;`
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '|  | &= | Bitwise `AND` and assignment operator, for example,. `result &= Num1;`
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '|  | ^= | Bitwise `XOR` and assignment operator, for example, `result ^= num1;`
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '|  | &#124;= | Bitwise `OR` and assignment operator, for example, `result &#124;=
    num1;` |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: 'Take a look at the following code snippet, which implements all operators discussed
    previously:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The complete code is available on the GitHub repository, and it produces the
    following results:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: Discussing operator precedence in C#
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The calculation or evaluation of any expression and the order of operators is
    very important. This is what is called operator precedence. We have all read the
    mathematic rule *Order of Operator*, which is abbreviated as *BODMAS*. Refer to
    [https://www.skillsyouneed.com/num/bodmas.html](https://www.skillsyouneed.com/num/bodmas.html)
    to refresh your memory. So, mathematics teaches us how to solve an expression;
    in a similar way, our C# should follow rules to solve or evaluate the expression.
    For instance, *3+2*5* evaluates as *13* and not *25*. So, in this equation, the
    rule is to first multiply and then add. That's why it evaluates as *2*5 = 10*
    and then *3+10 = 13*. You can set a higher precedence order by applying braces,
    so if you do this in the preceding statement *(3+2)*5*, it results in *25*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 任何表达式的计算或评估以及运算符的顺序都非常重要。这就是所谓的运算符优先级。我们都读过数学规则*BODMAS*，它是*括号、指数、乘除、加减*的缩写。请参考[https://www.skillsyouneed.com/num/bodmas.html](https://www.skillsyouneed.com/num/bodmas.html)来刷新您的记忆。因此，数学教会我们如何解决表达式；同样，我们的C#应该遵循规则来解决或评估表达式。例如，*3+2*5*的计算结果是*13*而不是*25*。因此，在这个等式中，规则是先乘后加。这就是为什么它计算为*2*5
    = 10*然后*3+10 = 13*。您可以通过应用括号来设置更高的优先级顺序，所以如果您在前面的语句中这样做*(3+2)*5*，结果是*25*。
- en: To know more about operator precedence, refer to [https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx](https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于运算符优先级的信息，请参考[https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx](https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx)。
- en: 'This is a simple code snippet to evaluate the expression:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的代码片段来评估表达式：
- en: '[PRE27]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code produces the following results:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码产生了以下结果：
- en: '![](img/00033.jpeg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Operator overloading
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'Operator loading is a way to redefine the actual functionality of a particular
    operator. This is important when you''re working with user-defined complex types,
    where the direct use of in-built operators is impossible. For instance, say, you
    have an object with numerous properties and you want an addition of two for these
    types of objects. It is not possible like this: `VeryComplexObject = result =
    verycoplexobj1 + verycomplexobj2;`. To overcome such a situation, overloading
    does the magic.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载是重新定义特定运算符的实际功能的一种方式。当您使用用户定义的复杂类型时，直接使用内置运算符是不可能的。例如，假设您有一个具有许多属性的对象，并且您希望对这些类型的对象进行加法。像这样是不可能的：`VeryComplexObject
    = result = verycoplexobj1 + verycomplexobj2;`。为了克服这种情况，重载可以发挥魔力。
- en: You cannot overload all inbuilt operators; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators)
    to see what operators are overloadable.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能重载所有内置运算符；请参考[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators)查看哪些运算符是可重载的。
- en: 'Let''s consider the following code snippet to see how operator loading works
    (note that this code is not complete; refer to Github for the complete source
    code):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段，以了解运算符重载的工作原理（请注意，此代码不完整；请参考Github获取完整的源代码）：
- en: '[PRE28]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we have a new type coordinate, which is a surface of
    *x* axis and *y* axis. Now if we want to apply some operations, that is not possible
    with the use of inbuilt operators. With the help of operator overloading, we enhance
    the actual functionality of inbuilt operators. The following code is the consumed
    coordinate type:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有一个新类型的坐标，它是*x*轴和*y*轴的表面。现在，如果我们想应用一些操作，使用内置运算符是不可能的。通过运算符重载，我们增强了内置运算符的实际功能。以下代码是使用的坐标类型：
- en: '[PRE29]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/00034.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: An overview of type conversion
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换概述
- en: Type conversion means converting one type into another type. Alternatively,
    we call it as casting or type casting. Type conversion is broadly divided into
    the following categories.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换意味着将一种类型转换为另一种类型。或者，我们称之为强制转换或类型转换。类型转换广泛分为以下几类。
- en: Implicit conversion
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: Implicit conversion is the conversion that is performed by the C# compiler internally
    to match the the type of variable by assignment of values to that variable. This
    action happens implicitly, and there's no need to write any extra code to obey
    the type-safe mechanism. In implicit conversions, only smaller to larger types
    and derived classes to base class is possible.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换是C#编译器在内部执行的转换，以匹配变量的类型通过给该变量赋值。这个操作是隐式的，不需要编写任何额外的代码来遵守类型安全机制。在隐式转换中，只有从较小的类型到较大的类型和派生类到基类的转换是可能的。
- en: Explicit conversion
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式转换
- en: Explicit conversion is the conversion that is performed by the user explicitly
    with the use of the cast operator; that's why this is also known as type casting.
    Explicit conversion is also possible using built-in type conversion methods. For
    more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 显式转换是用户明确执行的转换，使用强制转换运算符；这就是为什么它也被称为类型转换。显式转换也可以使用内置类型转换方法进行。有关更多信息，请参考[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table)。
- en: 'Let''s take a look at the following code snippet, which shows implicit/explicit
    type conversion in action:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段，展示了隐式/显式类型转换的实际操作。
- en: '[PRE30]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/00035.jpeg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: The two most important language fundamentals are type conversion and casting.
    To know more about these two, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最重要的语言基础是类型转换和强制转换。要了解更多关于这两个的信息，请参考[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)。
- en: Understanding statements
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解语句
- en: In C#, you can evaluate different kinds of expression that would or would not
    generate the results. Whenever you say something like *what would happen if result
    &gt;0*, in that case, we are stating something. This can be a decision-making
    statement, result-making statement, assignment statement, or any other activity
    statement. On the other hand, loops are a code block that repeatedly executes
    a couple of statements.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，你可以评估不同类型的表达式，这些表达式可能会产生结果，也可能不会。每当你说类似于*如果结果>0会发生什么*，在这种情况下，我们在陈述某事。这可以是一个决策语句、结果生成语句、赋值语句或任何其他活动语句。另一方面，循环是一个重复执行一些语句的代码块。
- en: In this section, we will discuss statements and loops in detail.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将详细讨论语句和循环。
- en: 'A statement should perform some action before returning a result. In other
    words, if you are writing a statement, that statement should say something. To
    do that, it has to execute some inbuilt or custom operations. Statements can depend
    upon a decision or can be a part of the result of any existing statement. The
    official page ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements))
    defines statement as:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 语句在返回结果之前应执行某些操作。换句话说，如果你在写一个语句，那个语句应该表达一些东西。为了做到这一点，它必须执行一些内置或自定义的操作。语句可以依赖于决定，也可以是任何现有语句的结果的一部分。官方页面（[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)）将语句定义为：
- en: A statement can consist of a single line of code that ends in a semicolon, or
    a series of single-line statements in a block. A statement block is enclosed in
    {} brackets and can contain nested blocks.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句可以由一行以分号结束的代码组成，或者由一个代码块中的一系列单行语句组成。一个语句块被{}括起来，可以包含嵌套块。
- en: 'Take a look at the following code snippet, which shows different statements:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段，展示了不同的语句：
- en: '[PRE31]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we used three type statements: declarative, assignment,
    and block statements. The code produces the following result:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了三种类型的语句：声明、赋值和块语句。代码产生了以下结果：
- en: '![](img/00036.jpeg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: According to the official page ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)),
    C# statements can be broadly divided into the following categories.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方页面（[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)），C#语句可以大致分为以下几类。
- en: Declarative statement
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明语句
- en: Whenever you declare a variable or constant, you are writing a declarative statement.
    You can also assign the values to variables at the time of declaration of variables.
    Assigning values to variables at time of declaration is an optional task, but
    constants are required to assign values at the time you declared them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你声明一个变量或常量时，你都在写一个声明语句。你也可以在声明变量的时候给变量赋值。在声明变量的时候给变量赋值是一个可选的任务，但是常量在声明时需要赋值。
- en: 'This is a typical declarative statement:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的声明语句：
- en: '[PRE32]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Expression statement
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'In an expression statement, the expression that is on the right-hand side evaluates
    results and assigns that result to the left-hand side variable. An expression
    statement could be an assignment, method invocation, or new object creation. This
    is the typical expression statement example:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个表达式语句中，右侧的表达式评估结果并将该结果赋给左侧的变量。表达式语句可以是赋值、方法调用或新对象创建。这是典型的表达式语句示例：
- en: '[PRE33]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Selection statement
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择语句
- en: This is also called a decision-making statement. Statements are branched as
    per the condition and their evaluations. The condition may be one or more than
    one. The selection or decision statement falls under `if...else`, and `switch`
    case. In this section, we will discuss these statements in detail.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为决策语句。语句根据条件和它们的评估进行分支。条件可以是一个或多个。选择或决策语句属于`if...else`和`switch` case。在这一部分，我们将详细讨论这些语句。
- en: The if statement
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if语句
- en: 'The `if` statement is a decision statement that could branch one or more statements
    to evaluate. This statement consists of a Boolean expression. Let''s consider
    the problem of finding vowels in a book that was discussed on day one. Let''s
    write this using the `if` statement:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是一个决定语句，可以分支一个或多个语句进行评估。这个语句由一个布尔表达式组成。让我们考虑一下在第一天讨论过的在一本书中找元音字母的问题。让我们使用`if`语句来写这个问题：'
- en: '[PRE34]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The if..else statement
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if..else语句
- en: 'In this `if` statement followed by else and the else block execute in case
    evaluation of if block is false. This is a simple example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if`语句后面跟着else，如果if块的评估为false，则执行else块。这是一个简单的例子：
- en: '[PRE35]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: if...else if...else statement
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if...else if...else语句
- en: The `if...else` statement is very important when you need to test multiple conditions.
    In this statement, the `if` statement evaluates first, then the `else` `if` statement,
    and at last the else block executes. Here, the `if` statement may or may not have
    the `if...else` statement or block; `if...else` always comes after the `if` block
    and before the `else` block. The `else` statement is the final code block in the
    `if...else...if else...else` statement, which indicates that none of preceding
    conditions evaluate to true.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Nested if statement
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nested `if` statements are nothing but `if` statement blocks within `if` statement
    blocks. Similarly, we can nest `else if` statement blocks. This is a simple code
    snippet:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Switch statement
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a statement that provides a way to select an expression using `switch`
    statement that evaluates the conditions using `case` blocks when code does not
    fall in any of the `case` blocks; then, the `default` block executes (default
    block is an optional block in `switch...case` statement).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch statement is also known as an alternative to `if...else if...else` statement.
    Let''s rewrite our examples used in the previous section to showcase the `if...else
    if...else` statement:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, the default block will execute if none of the case evaluates
    to true. The `switch...case` statement will be discussed in detail on day three.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: There is a slight difference when you're choosing between `switch...case` and
    `if...else`. Refer to [https://stackoverflow.com/questions/94305/what-is-quicker-switch-on-string-or-elseif-on-type](https://stackoverflow.com/questions/94305/what-is-quicker-switch-on-string-or-elseif-on-type)
    for more details.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statement
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These statements provide a way to iterate collection data. There may be a case
    where you want to execute a code block multiple times or a repetitive action is
    required on the same activity. There are iteration loops available to achieve
    this. Code blocks within the loop statement execute sequentially, which means
    the first statement executes first, and so on. The following are the main categories
    into which we can divide iteration statements of C#:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The do...while loop
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This helps us execute a statement or a statement of block repeatedly until it
    evaluates the expression to false. In `do...while` statement, a block of statement
    executes first and then it checks the condition under `while`, which means a statement
    or block of statements that execute at least once.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The while loop
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This executes the statement or code block until the condition evaluates to
    true. In this expression evaluates before the execution of code-block, if expression
    evaluates to false, loop terminates and no statement or code-block execute. Take
    a look at the following code snippet:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code executes the `while` statement repeatedly until expression
    evaluates to false.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is similar to other loops that help run a statement or code
    block repeatedly until an expression evaluates to false. The `for` loop takes
    three sections: the `initializer`, `condition`, and `iterator`, where the `initializer`
    section executes first and only once; this is nothing but a variable to start
    a loop. The next section is condition, and if it evaluates to true, then only
    body statements are executed; otherwise it terminates the loop. The third and
    most important section is incremental or iterator, which updates the loop control
    variable. Let''s take a look at the following code snippet:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The foreach loop
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This helps iterate an array element or collection. It does the same thing as
    the `for` loop, but this is available to iterate through a collection without
    the facility to add or remove items from collections.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code is a working example of a `foreach` statement that prints
    a person's name. `Name` is a property in a collection of the `Person` object.
    The statement of the `foreach` block executes repeatedly until the expression
    `person in persons` evaluates to false.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The jump statement
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jump statement, as is self-explanatory from the name, is a statement that
    helps move control from one section to another. These are the main jump statements
    in C#.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This terminates the control flow `for` loop or in `switch` statement. Take
    a look at the following example:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, execution of the `for` loop will break as soon as the
    `if` expression evaluates to true.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This helps `continue` the control to the next iteration of loop, and it comes
    with `while`, `do`, `for`, or `foreach` loops. Take a look at the following example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding code bypasses the execution when the `if` expression evaluates
    to true.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: default
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This comes with a `switch` statement and a `default` block that makes sure that
    `if` no match found in any of the `case` blocks, the `default` block executes.
    Refer to the `switch...case` statement for more detail.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Exception-handling statement
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has the ability to handle unknown issues within a program, which is known
    as exceptional handling (we will discuss exception handling on day four).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and string manipulations
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and strings are important in C# programming. There may be chances when
    you need string manipulation or play with complex data using arrays. In this section,
    we will discuss arrays and strings.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is nothing but a data structure that stores fixed-size sequential elements
    of the same type. Elements of an array that contained data are basically variables,
    and we can also call an array a collection of variables of the same type, and
    this type is generally called an element type.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: An array is a block of contiguous memory. This block stores everything required
    for an array, that is, elements, element rank, and length of the array. The first
    element rank is 0 and the last element rank is equal to the total length of array
    - 1.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `char[] vowels = {''a'', ''e'', ''i'', ''o'', ''u''};`
    array. An array with size five. Every element is stored in a sequential manner
    and can be accessed using its element rank. The following is the diagram showing
    what things an array declaration contains:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
- en: The preceding figure is a representation of our array declaration for vowels
    that are of *Data type* char. Here, *[ ]* represents an array and tells CLR that
    we are declaring an array of characters. Vowels is a variable name and the right-hand
    side representation of a complete array that contains data.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts what this array looks like in memory:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.gif)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, we have a group of contiguous memory blocks. This also
    tells us that the lowest address of an array in memory corresponds to the first
    element of an array and the highest address of the array in memory corresponds
    to the last element.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the value of an element by its rank (starting with 0). So, in
    the preceding code, *vowels[0]* will give us *a* and *vowels[4]* will give us
    *u*.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about an array, we mean a reference type because array types are
    reference types. Array types are derived from `System.Array`, which is a class.
    Hence, all array types are reference types.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also get the values using `for`, which iterates until
    the `rankIndex < vowels.Length` expression evaluates to false and the code block
    of the `for` loop statement prints the array element based on its rank:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code produces the following results:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we initialized the array and assigned data to a statement
    that is equivalent to `char[] vowels = newchar[5];`. Here, we are telling CLR
    that we are creating an array named vowels of type char that has a maximum of
    five elements. Alternatively, we can also declare the same `char[] vowels = newchar[5]
    { 'a', 'e', 'i', 'o', 'u' };`
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the different types of arrays and see how we
    can use arrays in different scenarios.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Types of arrays
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we discussed what an array is and how we can declare an array. Until
    now, we have discussed an array of single dimension. Consider a matrix where we
    have rows and columns. Arrays are a representation of data arranged in rows and
    columns in respect of the matrix. However, arrays have more types as discussed
    here.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Single-dimensional array
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single-dimensional array can be declared simply by initializing the array
    class and setting up the size. Here is a single-dimensional array:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Multidimensional array
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be declared as more than one-dimension, which that means you can
    create a matrix of rows and columns. Multidimensional arrays could be two-dimensional
    arrays, three-dimensional arrays, or more. Different ways to create a typical
    two-dimensional array of 2x2 size means two rows and two columns:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Following is the code-snippet that accesses the two-dimensional array:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A square matrix is the one with the same rows and columns. Generally, it is
    called an *n* by *n* matrix.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'This code produces the following results:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
- en: Jagged array
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jagged array is an array of array or array in array. In a jagged array, the
    element of array is an array. You can also set an array's element with different
    sizes/dimensions. Any element of jagged array can have another array.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical declaration of a jagged array is as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Consider the following code-snippet:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we are declaring a jagged array of three elements that
    contain a two-dimensional array. After execution, it produces the following results:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
- en: You can also declare more complex arrays to interact with more complex scenarios.
    You can get more information by referring to [https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly typed arrays can be created as well. In implicitly typed arrays,
    the array type inferred from the elements is defined during array initialization,
    for instance, `var charArray = new[] {'a', 'e', 'i', 'o', 'u'};` here we declare
    a char array. For more information on implicitly typed arrays, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, a string is nothing but an array of characters that represents UTF-16
    code units and is used to represent a text.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: The maximum size of a string in memory is 2 GB.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of a string object is as simple as you declaring any variable
    the most commonly used statement: `string authorName = "Gaurav Aroraa";`.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: A string object is called immutable, which means it is read-only. A string object's
    value cannot be modified after it is created. Every operation that you perform
    on a string object returns a new string. As strings are immutable, they cause
    a huge performance penalty because every operation on a string needs to create
    a new string. To overcome this, the `StringBuilder` object is available in the
    `System.Text` class.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: For more information on strings, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0#Immutability](https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0#Immutability).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the alternative ways to declare string objects:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding code snippets tells us that the declaration can be done as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: String literal assignment while declaring a string variable
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While concatenating string
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor initialization using `new`
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method returning string
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of string methods and formatting actions that are available
    for string operations; refer to [https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0)
    for more details.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Structure versus class
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a class in C#, a struct is also a data structure that consists of
    members, functions, and so on. Classes are reference types, but structs are value
    types; hence, these are not required for heap allocation but for allocation on
    the stack.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Value type data will be allocated on stack and reference type data will be allocated
    on heap. A value type that is used in struct is stored on the stack, but when
    the same value type is used in an array, it is stored in a heap.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: For more details on heap and stack memory allocation, refer to [http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html](http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html)
    and [https://www.codeproject.com/Articles/1058126/Memory-allocation-in-Net-Value-type-Reference-type](https://www.codeproject.com/Articles/1058126/Memory-allocation-in-Net-Value-type-Reference-type).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: So, when you create a variable of `struct` type, that variable directly stores
    data instead of reference, as is the case with classes. In C#, the `struct` keyword
    (refer to section C# keywords for more detail) helps declare structures. Structures
    are helpful in representing a record or when you need to present some data.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we have a structure named `BookAuthor` that represents the data of a
    book author. Take a look at the following code that is consuming this structure:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This simply displays the author details. The important point here is that once
    we've copied the structure, changing any field of the structure would not impact
    the copied contents; this is because when we copy, only the data is copied. If
    you perform the same operation on a class, that results in copying references
    instead of copying data. This copying process is called deep copy and shallow
    copy. Refer to [https://www.codeproject.com/Articles/28952/Shallow-Copy-vs-Deep-Copy-in-NET](https://www.codeproject.com/Articles/28952/Shallow-Copy-vs-Deep-Copy-in-NET)
    in order to know more about shallow copy versus deep copy.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result of the preceding code:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try the same operations with the class; take a look at the following
    code, which consumes our class:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now both our class variables will have the same values. The following screenshot
    shows us the results:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
- en: 'Structures and classes are different:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Structures are value types, whereas classes are reference types.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes support single inheritance (multiple inheritance can be achieved using
    interfaces), but structures do not support inheritance.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes have an implicit default constructor, but a structure does not have
    a default constructor.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more functionalities of structures that we did not discuss here. Refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/structs](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/structs)
    to get more inside information about struct.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercise
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rewind our learning for today - that is, day two - by solving the following
    problems:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Write a short program to demonstrate that we can use same class name within
    different namespaces.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `console` class. Write a `console` program to display all available
    colors by modifying the code example discussed in the book so that all vowels
    will be displayed as green and all consonants as blue.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elaborate on C# reserved keywords.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe different categories of C# keywords with examples.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a small program to demonstrate the `is` and `as` operators.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase a query expression with the help of contextual
    keywords.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase the importance of the `this` and `base` keywords.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define boxing and unboxing with the help of a short program.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to prove that pointer type variable stores the memory
    of another variable rather than data.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase the operator precedence order.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is operator overloading? Write a short program to showcase operator overloading
    in action.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the operators that cannot be overloaded and why?
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define type conversion with the help of a short program.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program that uses all the available built-in C# types and perform
    casting using the conversion method (decimal to int conversion can be achieved
    using `var result = Convert.ToInt32(5689.25);`).
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define C# statements.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to elaborate each statement category.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are `jump` statements? Write a small program to showcase all `jump` statements.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an array in C#?
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program and prove that an array is a block of contiguous memory.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to `System.Array` class ([https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0))
    and write a short program.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass an array as a parameter to a method.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the array.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the array.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the `System.String` class and explore all its methods and properties
    with the help of a short program.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are string objects immutable? Write a short program to showcase this.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are string builders?
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a class?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a structure?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a small program and showcase the differences between a `struct` and a
    `class`.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain compile-time type and runtime type.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to show the difference between compile-time type and runtime
    type.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to prove that, explicitly, type conversion leads to data
    loss.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting day 2
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are concluding day two of our seven-day learning series. Today, we started
    with a very simple C# program and went through all of its parts (a typical C#
    program). Then, we discussed everything about C# reserved keywords and accessors
    and we also understand what contextual keywords are.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: We covered the type casting and type conversion of various available data types
    in C#. You learned how boxing and unboxing happened and how we can perform conversion
    using inbuilt methods.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: We also went through and understood various statements, and you learned the
    usage and flow of various statements, such as `for`, `foreach`, `while`, `do`.
    We looked at conditional statements, `that is`, `if`, `if...else`, `if...elseif...else`
    switch with the help of code examples.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: We then went through arrays and understood them with the help of code examples,
    including string manipulations.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we concluded our day by covering structure and classes. We looked at
    how these two are different.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow, on day three, we will discuss all the new features of the C# language
    and discuss their usage and functionality with the help of code examples.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
