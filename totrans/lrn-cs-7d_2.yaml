- en: Day 02 - Getting Started with C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, we are on day two of our seven-day learning series. Yesterday, we had
    gone through the basic understanding of .NET Core and its important aspects. Today,
    we will discuss the C# programming language. We will start with basics concepts
    by understanding a typical C# program, and then we will start looking at other
    stuff by covering reserved keywords, types, and operators; by the end of day,
    we will be able to write a complete C# program after covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a typical C# program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of C# reserved keywords, types, and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and string manipulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure versus class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple words, C# (pronounced *See-Sharp*) is a programming language that
    is developed by Microsoft. C# is approved by **International Standards Organization**
    (**ISO**) and **European Computer Manufacturers Association** (**ECMA**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the definition on the official website ([https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index)):'
  prefs: []
  type: TYPE_NORMAL
- en: C# is a simple, modern, object-oriented, and type-safe programming language.
    C# has its roots in the C family of languages and will be immediately familiar
    to C, C++, Java, and JavaScript programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Language C# is designed to adhere to **Common Language Infrastructure** (**CLI**),
    which we discussed on day one.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# is the most popular professional language because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is an object-oriented language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is component-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a structured language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main part that makes it the most popular: this is a part of the .NET Framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a unified type system, which means all types of language C# inherits
    from a single type object (this is also known as the mother type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was constructed with a robust durable application such as *Garbage collection*
    (discussed on day one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the ability to handle unknown issues within a program, which is known
    as exceptional handling (we will discuss exception handling on day four)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robust support of reflection, which enables dynamic programming (we will discuss
    reflection on day four)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of the C# language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C# language was developed by *Anders Hejlsberg* and his team. The language
    name is inspired by the musical notation *sharp* (*#*), which indicates that the
    written note should be made a semitone higher in pitch.
  prefs: []
  type: TYPE_NORMAL
- en: The first released version was C# 1.0, which was launched in January 2002, and
    the current version is C# 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: The following table depicts all versions of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Version of C#** | **Release year** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | January 2002 | With Visual Studio 2002 – .NET Framework 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.2 | April 2003 | With Visual Studio 2003 – .NET Framework 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | November 2005 | With Visual Studio 2005 – .NET Framework 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | November 2007 | Visual Studio 2008, Visual Studio 2010 – .NET Framework
    3.0 and 3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | April 2010 | Visual Studio 2010 – .NET Framework 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | August 2012 | Visual Studio 2012, 2013 – .NET Framework 4.5 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | July 2015 | Visual Studio 2015 – .NET Framework 4.6 |'
  prefs: []
  type: TYPE_TB
- en: '| C# 7.0 | March 2017 | Visual Studio 2017 – .NET Framework 4.6.2 |'
  prefs: []
  type: TYPE_TB
- en: '| C# 7.1 | August 2017 | Visual Studio 2017 update3 – .NET Framework 4.7 |'
  prefs: []
  type: TYPE_TB
- en: In the upcoming section, we will discuss this language in detail, along with
    code examples. We will discuss C# language's keywords, types, operators, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a typical C# program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing a program in C#, let's first go back to day one, where
    we discussed the various IDEs and editors that are helpful in writing programs/applications
    using the C# language. Revisit day one and understand various editors and IDEs
    and check why we should go with one of our choice. We will be using Visual Studio
    2017 update 3 for all our examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: To know the steps to install Visual Studio 2017, refer to [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get start with a simple C# program (we will create a console application),
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiate your Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to File | New | Project (or *ctrl* +*Shift* + *N*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Visual C# node, select .NET Core and then select Console App.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name your program, say, `Day02`, and click on OK (see highlighted text in the
    following figure):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will get the following code in class `Program.cs` – this is the default
    code provided by Visual Studio; you can amend it as per your need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By hitting the *F5* key on your keyboard, you will run the program in Debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, every program has two different configurations or modes, that is,
    Debug and Release. In Debug mode, all compiled files and symbols that are helpful
    to drill down any issue encountered during the execution of application will be
    loaded. On the other hand, Release is kind of a clean run, where only binaries
    without Debug symbols load and perform the action. For more information, refer
    to [https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio](https://stackoverflow.com/questions/933739/what-is-the-difference-between-release-and-debug-modes-in-visual-studio).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the following output when the program runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving further, let''s analyze the following figure of our console application
    on Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure depicts a typical C# program; we are using Visual Studio,
    but the console program remains unchanged across different IDEs or editors. Let's
    discuss this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 1 (System)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a place where we defined what the namespaces going to be consumed in
    the program/application are. Generally, this is called using a statement, which
    includes the usage of external, internal, or any other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: System is a typical namespace that contains a lot of fundamental classes. For
    more information, refer to [https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system?view=netcore-2.0).
  prefs: []
  type: TYPE_NORMAL
- en: 3 (Day02)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the namespace of our existing console application.
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is a way to keep one set of names separate from another, which means
    you can create as many namespaces as you want and the classes under different
    namespaces will treat them as a separate, although they have the same name; that
    is, if you declare a `ClassExample` class in `namespace Day02`, it would be different
    from the `ClassExample` class declared in the `Day02New` `namespace` and will
    work without any conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical example that shows two classes of the same name with two
    different `namespaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 2 (Program)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a class name defined in namespace - day two.
  prefs: []
  type: TYPE_NORMAL
- en: A class in C# is a blueprint of an object. Objects are dynamically created instances
    of a class. In our console program, we have a class program that contains a method
    named `Main`.
  prefs: []
  type: TYPE_NORMAL
- en: 4 (Main)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an entry point for our program. At least one `Main` method is required
    for our C# program, and it should be static. We will discuss *static* in detail
    in the upcoming section, *Overview of C# reserved keywords*. `Main` is also a
    reserved keyword.
  prefs: []
  type: TYPE_NORMAL
- en: An entry is a way that lets CLR know the *what* and *where* of the functions
    located in the DLL. For instance, whenever we run our console application, it
    tells CLR that `Main` is the entry point and everything surrounds here. For more
    details, refer to [https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point)
    and [https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point](https://docs.microsoft.com/en-us/dotnet/framework/interop/specifying-an-entry-point).
  prefs: []
  type: TYPE_NORMAL
- en: 5 (Day02)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the name of the solution of our console application.
  prefs: []
  type: TYPE_NORMAL
- en: A solution can contain many libraries, applications, projects, and so on. For
    instance, our solution, Day02, would contain another project called Day03 or Day04\.
    A Visual Studio solution filename for our console application is `Day02.sln`.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio](https://stackoverflow.com/questions/30601187/what-is-a-solution-in-visual-studio)
    in order to understand the Visual Studio solution.
  prefs: []
  type: TYPE_NORMAL
- en: To view the solution file, open the folder where `Day02.sln` solution file is
    located. You can directly open this file using any text editor/Notepad. I used
    Notepad++ ([https://notepad-plus-plus.org/](https://notepad-plus-plus.org/)) to
    view the solution file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts our solution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 6 (Day02)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a project of our console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A project is a bundle that contains everything required for your program. This
    is the definition of the project from the official website: [https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio](https://docs.microsoft.com/en-us/visualstudio/ide/solutions-and-projects-in-visual-studio)'
  prefs: []
  type: TYPE_NORMAL
- en: A project is contained, in a logical sense and in the file system, within a
    solution, which may contain one or more projects, along with build information,Visual
    Studio window settings and any miscellaneous files that aren't associated with
    any project. In a literal sense, the solution is a text file with its own unique
    format; it is generally not intended to be edited by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Our project filename is `Day02.csproj`.
  prefs: []
  type: TYPE_NORMAL
- en: You are not required to have a project for your application. You can directly
    start working on your C# files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts our project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 7 (Dependencies)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refers to all references and binaries required to run a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency is an assembly or dll on which our application depends or where
    our application is consuming the function of referred assembly. For instance,
    our console application requires .NET Core 2.0 SDK, so it includes it as dependencies.
    Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.gif)'
  prefs: []
  type: TYPE_IMG
- en: 8 (Program.cs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is physical class filename.
  prefs: []
  type: TYPE_NORMAL
- en: This is the name of a class file that is physically available on our disk drive.
    Class name and filename could be different, which means if my class name is `Program`,
    then my class filename could be `Program1.cs`. However, it is bad practice to
    call both class and filename with different names, but you can do that and the
    compiler won't throw any exception. For more information, refer to [https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched](https://stackoverflow.com/questions/2224653/c-sharp-cs-file-name-and-class-name-need-to-be-matched).
  prefs: []
  type: TYPE_NORMAL
- en: Deep-dive into application using Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned about various things that our console application
    can contain. In this section, lets deep-dive to get more insight on this using
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, go to the project properties. Do this from the solution explorer
    (right-click on project and click on Properties) or from menus (Project | Day02
    properties); you will get the project properties window, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the Application tab, we can set the Assembly name, the Default namespace,
    the Target framework, and the Output type (the output types are `Console Application`,
    `Windows Application`, `Class Library`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is that of the Build tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the Build tab, we can set Conditional compilation symbols, Platform target,
    and other available options.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional compilations are nothing but pre-processors, which we will discuss
    on day six.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts the Package tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Package tab helps us directly create NuGet packages. In the earlier version,
    we needed a lot of configuration settings to build a NuGet package. In the current
    version, we just need to provide the information on the Package tab, and Visual
    Studio will generate the NuGet package according to our options. The Debug tab,
    Signing, and Resources tabs are self-explanatory and provide us with a way to
    sign assemblies and support to embed resources in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the console application and discussed what a typical console
    application contains and how we can set various things using Visual Studio. Now
    let's discuss our code, which was written in the previous section, *Understanding
    a typical C# program*.
  prefs: []
  type: TYPE_NORMAL
- en: '`Console` is a static class of a `System` namespace and it can''t be inherited.'
  prefs: []
  type: TYPE_NORMAL
- en: In the said code, we instructed the program to write something to the console
    as an output with the help of the `WriteLine()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official definition of `Console` class is as follows ([https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0)):'
  prefs: []
  type: TYPE_NORMAL
- en: Represents the standard input, output, and error streams for console applications.
    This class cannot be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: '`Console` is nothing but an operating system''s terminal-windows (also known
    as **Console User Interface** (**CUI**))to interact with users. Windows operating
    system has console, that is, Command Prompt that accepts MS-DOS commands. In this
    way, the `Console` class provides basic support to achieve this.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few important operations we can do with the console.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Console background and/or foreground color can be changed using setter and
    getter properties that accept the value of the `ConsoleColor` enum. To set it
    to the default color, there is a `Reset` method. Let''s demonstrate all color
    combinations using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is one snippet from the complete source code that is available
    on the GitHub repository. The complete code will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Beep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Beep` is the method that generates system sound through the console speaker.
    The following is the simplest example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more methods that are helpful while working with the console
    application. For more detail on these methods, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.console?view=netcore-2.0).
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have discussed a typical C# program with the help of a code example
    using Visual Studio 2017; we went through various sections of the console program
    and discussed them. You can revisit this section once again or proceed with further
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of C# reserved keywords, types, and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reserved keywords are nothing but predefined words that have special meaning
    for the compilers. You cannot use these reserved keywords as normal text or identifiers
    unless you explicitly tell the compiler that this word is not meant to reserve
    for the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, you can use the reserved keyword as a normal word by prefixing the `@`
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# keywords are divided into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Types**: In C#, the typing system is divided into value type, reference type,
    and pointer type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifiers**: As is self-explanatory from its name, modifiers are used to
    modify the declaration of types and members of a specific type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement keywords**: These are programming instructions that execute in
    a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method parameters**: These can be declared as a value type or a ref type
    and values can be passed using **out** or **ref** keywords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace keywords**: These are the keywords that belong to namespaces only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator keywords**: These operators are generally used to perform miscellaneous
    operations, such as type checking, getting the size of the object, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversion keywords**: These are `explicit`, `implicit`, and `operator` keywords,
    which will be discussed in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access keywords**: These are common keywords that help access things from
    a class that belongs to its parent class or belongs to its own. These keywords
    are `this` and `base`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Literal keywords**: Keywords have some values for assignment, which are `null`,
    `true`, `false` , and `default`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contextual keywords**: These are used as a specific meaning in the code.
    These are special keywords that are not reserved keywords in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query keywords**: These are contextual keywords that can be used in a query
    expression, for instance, the `from` keyword can be used for LINQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we will discuss C# keywords in more detail using code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These keywords are used in any part of the C# program and are reserved. Identifiers
    are special keywords and are treated differently by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the identifiers that are reserved by C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**abstract**: This informs you that things that come with the abstract modifier
    are yet to complete or have a missing definition. We will discuss this in detail
    on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**as**: This can be used in a cast operation. In other words, we can say that
    this checks the compatibility between two types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `as` keyword falls in the operator category of keywords; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator-keywords).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**base**: This is the access keyword and is used to access members of the parent
    class from within derived classes. The following is the code snippet that shows
    the usage of the `base` keyword. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple example used to showcase the power of `base`. Here, we
    are just using base class members and methods to get the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool**: This is an alias of `structureSystem.Boolean` that helps declare
    variables. This has two values: true or false. We will discuss this in detail
    in the upcoming section, *Data types*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**break**: The keyword is self-explanatory; it breaks something within a particular
    code execution, which could be a flow statement (`for` loop) or the termination
    of a code block (`switch`). We will discuss this in detail in the upcoming section
    on loop and statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**byte**: This helps declare variables of an unsigned integer. This is an alias
    of `System.Byte`. We will discuss this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case**: This is used with the `Switch` statement, which then tends to a code
    block of execution based on some condition. We will discuss `switch` case on day
    three.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**catch**: This keyword is a catch block of exception handling blocks, that
    is, `try`..`catch`..`finally`. We will discuss exception handling in detail on
    day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**char**: This keyword is useful when we declare a variable to store characters
    that belong to structure `System.Char`. We will discuss this in detail in the
    data type section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**checked**: Sometimes, you might face overflow values in your program. Overflow
    exception means that you assigned a larger value than the max value of the assignee
    data type. The compiler raises the overflow exception and the program terminates.
    The keyword checks force the compiler to make sure that overflow will not happen
    to the scenario when the compiler misses it. To understand this better, look at
    the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a compile-time error. As soon as you write the preceding
    statement, you get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet is a modified code, as shown in the preceding figure.
    With this modification, the new code will not generate a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will never throw an overflow exception, but it would not
    give the correct sum; it gives -2147483647 as a result of `2147483647` + 19 because
    the actual sum will exceed the maximum positive value of an integer, that is,
    `2147483647`. It will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In real-world programs, we can''t take a risk with wrong calculations. We should
    use the checked keyword to overcome such situations. Let''s rewrite the preceding
    code using checked keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you write the code using the checked keyword, you will see the following
    compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s discuss more keywords of C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**: This keyword helps us declare classes. A C# class would contain
    members, methods, variables, fields, and so on (we will discuss these in detail
    on day four). Classes are different from structures; we will discuss this in detail
    in the *Classes versus structures* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**const**: This keyword helps us declare constant fields or constant locals.
    We will discuss this in detail on day three.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**continue**: This keyword is the opponent of `break`. It passes control to
    the next iteration in the flow statements, that is, `while`, `do`, `for`, and
    `foreach`. We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**decimal**: This helps us declare a data type of 128-bit. We will discuss
    this in detail in the *Data types* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**default**: This is the keyword that tells us the default condition in a `switch`
    statement. We can also use the default as a literal to get the default values;
    we will discuss this on day three.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delegate**: This helps declare a delegate type that is similar to method
    signature. We will discuss this in detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**do**: This executes a statement repeatedly until it meets the expression
    condition of false. We will discuss this in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**double**: This helps declare simple 64-bit floating point values. We will
    discuss this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**else**: This comes with the `if` statement and executes the `code` statement
    that does not fall within the `if` condition. We will discuss this in detail in
    the coming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**enum**: This helps create enumerations. We will discuss this on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**event**: This helps declare an event in a publisher class. We will discuss
    this in detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**explicit**: This is one of the conversion keywords. This keyword declares
    a user-defined type conversion operator. We will discuss this in detail in the
    upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**false**: A bool value indicates the `false` condition, `result`, or `Operator`.
    We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**finally**: This is a part of exception handling blocks. Finally, a block
    is always executed. We will discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fixed**: This is used in unsafe code and is helpful in preventing GC allocation
    or relocation. We will discuss this in detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**float**: This is a simple data type that stores a 32-bit floating point value.
    We will discuss this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for**: The `for` keyword is a part of flow statements. With the use of the
    `for` loop, you can run a statement repeatedly until a specific expression is
    reached. We will discuss this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**foreach**: This is also a flow statement, but it works only on elements for
    collections or arrays. This can be exited using the `goto`, `return`, `break`,
    and `throw` keywords. We will discuss this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**goto**: This redirects the control to another part with the help of a label.
    In C#, goto is typically used with the `switch..case` statement. We will discuss
    this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if**: This is a conditional statement keyword. It typically comes with the
    `if...else` statement. We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**implicit**: Similar to the explicit keyword, this helps declare an implicit
    user-defined conversion. We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**in**: A keyword helps detect the collection from where we need to iterate
    through members in the `foreach` loop. We will discuss this in detail in the upcoming
    sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**int**: This is an alias of structure `System.Int32` and a data type that
    stores signed 32-bit integer values. We will discuss this in detail in the upcoming
    sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**interface**: This keyword helps declare an interface that can only contain
    methods, properties, events, and indexers (we will discuss this on day four).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**internal**: This is an access modifier. We will discuss this in detail on
    day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**is**: Similar to the `as` operator, `is` is also a keyword operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a code example showing the `is` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For complete explanation of `is` and `as` operators, refer to [https://goo.gl/4n73JC](https://goo.gl/4n73JC).
  prefs: []
  type: TYPE_NORMAL
- en: '**lock**: This represents a critical section of the code block. With the use
    of the `lock` keyword, we will get a mutual exclusion lock of an object, and it
    will get released after execution of the statement. This generally comes with
    the use of threading. Threading is beyond the scope of this book. For more details,
    refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement)
    and [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/index).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**long**: This helps declare variables to store signed 64-bit integers values,
    and it refers to structure `System.Int64`. We will discuss this in detail in the
    upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**namespace**: This helps define namespaces that declare a set of related objects.
    We will discuss this in details on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**new**: The `new` keyword can be an operator, a modifier, or a constraint.
    We will discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**null**: This represents a null reference. It does not refer to any object.
    The default value of reference type is null. This is helpful while working with
    nullable types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**object**: This is an alias of `System.Object`, the universal type in .NET
    world. It accepts any data type instead of null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**operator**: This helps overload the built-in operator. We will discuss this
    in detail in the upcoming sections..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**out**: This is a contextual keyword and will be discussed in detail on day
    four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**override**: This keyword helps override or extend the implementation of abstract
    or virtual members, methods, properties , indexer, or event. We will discuss this
    in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**params**: This helps define method parameters with a variable number of arguments.
    We will discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private**: This is an access modifier and will be discussed on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected**: This is an access modifier and will be discussed on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public**: This is an access modifier that sets the availability through the
    application and will be discussed on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**readonly**: This helps us declare field declaration as read-only. We will
    discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ref**: This helps pass values by reference. We will discuss this in detail
    on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**return**: This helps terminate the execution of a method and returns the
    result for the calling method. We will discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sbyte**: This denotes `System.SByte` and stores signed 8-bit integer values.
    We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sealed**: This is a modifier that prevents further usage/extension. We will
    discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**short**: This denotes `System.Int16` and stores signed 16-bit integer values.
    We will discuss this in detail in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sizeof**: This helps get the size in bytes of the inbuilt type and/or unmanaged
    type. For unmanaged and all other types apart from inbuilt data types, the unsafe
    keyword is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code is explained `sizeof` using built-in types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss more C# keywords; these keywords are very important and play
    a vital role while writing real-world programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**static**: This helps us declare static members and will be discussed in detail
    on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**string**: This helps store unicode characters. It is a reference type. We
    will be discussing this in more detail in the upcoming section, **String.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**struct**: This helps us declare a `struct` type. Struct type is a value type.
    We will be discussing this in more detail in the upcoming section, *Classes versus.
    structs*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch**: This helps declare a `switch` statement. Switch is a selection
    statement, and we will be discussing it on day three.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**this**: This `this` keyword helps us access the members of the current instance
    of a class. It is also a modifier and we will be discussing on day four. Note
    that the `this` keyword has a special meaning for the `extension` method. Extension
    methods are beyond the scope of this book; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
    for more detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**throw**: This helps throw a system or custom exceptions. We will be discussing
    this in detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**true**: Similar to false, we discussed this earlier. It represents a Boolean
    value and can be a literal or operator. We will discuss this in more detail in
    the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**try**: This represents a `try` block of exception handling. Try block is
    one of the other three blocks that helps handle any unavoidable errors or instances
    of programs. All three blocks are jointly called exceptional handling blocks.
    The try block always comes first. This block contains the code that could throw
    an exception. We will discuss this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**typeof**: This helps get the type object for a desired type. Also, at runtime,
    you can get the type of object with the help of the `GetType()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet shows the `typeof()` method in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the unsigned data types, and these data types store values without
    sign (*+*/*-*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**uint**: This helps declare a variable of an unsigned 32-bit integer. We will
    be discussing this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ulong**: This helps declare a variable of an unsigned 65-bit integer. We
    will be discussing this in detail in the upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unchecked**: This keyword works exactly opposite to checked. The code block
    that threw a compile-time error with the use of the checked keyword will not generate
    any compile-time exception with the use of the unchecked keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s rewrite the code that we wrote using the checked keyword and see how
    the unchecked keyword works exactly opposite to checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will run smoothly but will give the wrong result, that is,
    *-2147483647*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detail on the checked and unchecked keywords by referring
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked)
  prefs: []
  type: TYPE_NORMAL
- en: '**unsafe**: This helps execute an unsafe code block that generally uses pointers.
    We will be discussing this in detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ushort**: This helps declare a variable of an unsigned 16-bit integer. We
    will be discussing this in more detail in the upcoming section, *Data types*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**using**: The `using` keyword works like a directive or statement. Let''s
    consider the following code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding directive provides everything that belongs to the `System` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding directive helps us call static members. After inclusion of the
    preceding directive in the program, we can directly call static members, methods,
    and so on, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'C# keywords virtual and void have a special meaning: one allows the other to
    override it, while the other is a used as a return type when the method returns
    nothing. Let''s discuss both in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**virtual**: If the virtual keyword is used, it means that it allows methods,
    properties, indexers, or events to override in a derived class. We will be discussing
    this in more detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void**: This is an alias of the `System.Void` type. When void uses the method,
    it means the method does not have any return type. For instance, take a look at
    the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**while**: While is a flow statement that executes the specific code block
    until a specified expression evaluates false. We will be discussing this in more
    detail in the upcoming section, *Flow statements*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are not reserved keywords, but they have a special meaning for a limited
    context of a program and can also be used as an identifier outside that context.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the contextual keywords of C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**: This is used to define a custom accessor and it invokes when someone
    subscribes to an event. The `add` accessors are always followed by the `remove`
    accessors, which means when we provide the add accessor, the remove accessor should
    be applied thereon. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-implement-interface-events](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/how-to-implement-interface-events).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ascending/descending**: This contextual keyword is used with an `orderby`
    clause in a `LINQ` statement. We will discuss this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**async**: This is used for an asynchronous method, lambda expression, or anonymous
    method. To get the result from asynchronous methods, the `await` keyword is used.
    We will be discussing this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dynamic**: This helps us bypass the compile-time type checking. This resolves
    types at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile time type is what you used to define a variable. Runtime type refers
    to the actual type to which a variable belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code in order to understand these terms better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create an object of our child class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, compile-time type for `myObject` is `Parent` as the compiler knows the
    variable is a type of `Parent` without caring or knowing about the fact that we
    are instantiate this object with type `Child`. Hence this is a compile-time type.
    Runtime type is the actual type that is `Child` in our example. Hence, runtime
    type of our variable `myObject` is `Child`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code produces following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For more information, refer: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the contextual keywords that are used in query expressions; let''s
    discuss these keywords in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**from**: This uses the in query expression and will be discussed on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**get**: This defines the accessor and is used along with properties for the
    retrieval of values. We will be discussing this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**group**: This is used with a query expression and returns a sequence of `IGroupong<Tkey,TElement>`
    objects. We will discuss this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**into**: This identifier helps store temporary data while working with query
    expressions. We will discuss this in more detail on day six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on contextual keywords, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords).
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, 7.0 types are also known as data types and variables. These are categorized
    into the following broader categories.
  prefs: []
  type: TYPE_NORMAL
- en: Value type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are derived from the `System.ValueType` class. Variables of the value
    type directly contains their data or, in simple words, the value type variable
    can be assigned directly. Value types can be divided into more sub categories:
    data types, custom types (`Enum` types and `Struct` types). In this section, we
    will discuss the data types in detail. `Enum` will be discussed on day four and
    struct will be discussed in the upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are also famous as compliant value types, simple value types, and basic
    value types. I call these data types because of their power to define the nature
    of values. The following table contains all value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Nature** | **Type** | **CLR Type** | **Range** | **Default Value** | **Size**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Signed Integer | sbyte | `System.SByte` | -128 to 127 | 0 | 8 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | short | `System.Short` | -32,768 to 32,767 | 0 | 16 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | int | `System.Int32` | -2,147,483,648 to 2,147,483,647 | 0 | 32 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | long | `System.Int64` | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
    | 0L | 64 bit |'
  prefs: []
  type: TYPE_TB
- en: '| Unsigned Integer | byte | `System.Byte` | 0 to 255 | 0 | 8 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | ushort | `System.UInt16` | 0 to 65,535 | 0 | 16 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | uint | `System.UInt32` | 0 to 4,294,967,295 | 0 | 32 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | ulong | `System.UInt64` | 0 to 18,446,744,073,709,551,615 | 0 | 64 bit
    |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode Character | char | `System.Char` | U +0000 to U +ffff | ''\0'' |
    16 bit |'
  prefs: []
  type: TYPE_TB
- en: '| Floating point | float | `System.Float` | -3.4 x 10^(38) to + 3.4 x 10^(38)
    | 0.0F | 32 bit |'
  prefs: []
  type: TYPE_TB
- en: '|  | double | `System.Double` | (+/-)5.0 x 10^(-324) to (+/-)1.7 x 10^(308)
    | 0.0D | 64 bit |'
  prefs: []
  type: TYPE_TB
- en: '| Higher-precision decimal | decimal | `System.Decimal` | (-7.9 x 1028 to 7.9
    x 1028) / 100 to 28 | 0.0M | 128 bit |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | bool | `System.Boolean` | True or False | False | Boolean value
    |'
  prefs: []
  type: TYPE_TB
- en: 'We can prove the values mentioned in the preceding table with the help of the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are displaying maximum and minimum values of data
    types, which produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Reference type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actual data is not stored in the variable but it contains reference to
    variables. In simple words, we can say that the reference type refers to a memory
    location. Also, multiple variables can refer to one memory location, and if any
    of these variables change the data to that location, all the variables would get
    the new values. Here are the built-in reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**class type**: A data structure that contains members, methods, properties,
    and so on. This is also called the object type as this inherits the universal
    `classSystem.Object`. In C# 7.0, class type supports single inheritance; we will
    discuss this in more detail on day seven.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object type can be assigned a value of any other type; an object is nothing
    but an alias of `System.Object`. In this context, any other type is meant to be
    a value type, reference type, predefined type, and user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: There is a concept called `boxing` and `unboxing` that happens once we deal
    with an object type. In general, whenever value type is converted into the object
    type, it is called `boxing`, and when object type is converted into a value type,
    it is called `unboxing.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we are going to discuss three important types, which are interface, string,
    and delegate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**interface type**: This type is basically a contract that is meant to be implemented
    by whoever is going to use it. A class or struct may use one or more interface
    types. One interface type may be inherited from multiple other interface types.
    We will discuss this in more details on day seven.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delegate type**: This is a type that represents a reference to a method of
    a parameter list. Famously, delegates are known as function pointers (as defined
    in C++). Delegates are type- safe. We will discuss this in detail on day four.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**string type**: This is an alias of `System.String`. This type allows you
    to assign any string value to variables. We will discuss this in detail in the
    upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type belongs to unsafe code. The variable defined as a pointer type stores
    the memory address of another variable. We will discuss this in details on day
    six.
  prefs: []
  type: TYPE_NORMAL
- en: Null type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nullable types are nothing but an instance of the `System.Nullable<T>` struct.
    The nullable type contains the same data range as that of its `ValueType` but
    with addition to a null value. Refer to the data type table where int has a range
    of 2147483648 to 2147483647 but `System.Nullable<int>` or `int`? has the same
    range in addition to null. This means you can do this: `int? nullableNum = null;`.'
  prefs: []
  type: TYPE_NORMAL
- en: For more detail on nullable types, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/).
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, operators are nothing but mathematical or logical operators that tell
    the compiler to perform a specific operation. For instance, a multiplication (*)
    operator tells the compiler to multiply; on the other hand, the logical and (&&)
    operator checks both the operands. We can divide C# operators into broader types,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic operators | + | Adds two operands, for example, `var result =
    num1 +num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | - | Subtracts second operand from first operand, for example, `var result
    = num1 - num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | * | Multiplies both operands, for example, `var result = num1 * num2;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | / | Divides the numerator by the denominator, for example, `var result
    = num1 / num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | % | Modulus, for example, `result = num1 % num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | ++ | Incremental operator that increases the value by 1\. , for example,
    `var result = num1++;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | -- | Decrement operator that decreases the value by 1, for example, `var
    result = num1--;` |'
  prefs: []
  type: TYPE_TB
- en: '| Relational operators | == | Determines whether the two operands are of the
    same value. It returns True if the expression is successful; otherwise it returns
    false, for example, `var result = num1 == num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | != | Performs the same as `==` but negates the comparison; if two operands
    are equal, it returns false, for example, `var result = num1 != num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | > | Determines whether in expression, the left operand is greater than
    the right operand and returns True on success, for example, `var result = num1
    > num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | < | Determines whether in expression, the left operand is less than the
    right operand and returns true on success, for example, `var result = num1 < num2;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | >= | Determines whether in expression, the value of the left operand is
    greater than or equal to the value of the right operand and returns true on success,
    for example, `var result = num1 <= num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | <= | Determines whether in expression, the value of the left operand is
    less than or equal to the value of the right operand and returns true on success,
    for example, `var result = num1 <= num2;` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical operators | && | This is a logical `AND` operator. Expression evaluates
    on the basis of the left operand; if it''s true, then the right operand would
    not be ignored, for example, `var result = num1 && num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124;&#124; | This is a logical `OR` operator. Expression evaluates to
    true if any of the operands is true, for example, `var result = num1 &#124;&#124;
    num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | ! | This is called the logical `NOT` operator. It reverses the evaluation
    result, for example, `var result = !(num1 && num2);` |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise operators | &#124; | This is a bitwise `OR` operator and works on
    bits. If either of the bits is 1, the result will be 1, for example, `var result
    = num1 &#124; num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | & | This is a bitwise `AND` operator and works on bits. If either of the
    bits is 0, then the result is 0; otherwise, it''s 1, for example, `var result
    = num1 & num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | ^ | This is a bitwise `XOR` operator and works on bits. If bits are the
    same, the result is 0; otherwise, it''s 1, for example, `var result = num1 ^ num2;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | ~ | This is a unary operator and is called a bitwise `COMPLEMENT` operator.
    This works on a single operand and reverses the bit, which means if the bit is
    0, then it returns 1 and vice- versa, for example, `var result = ~num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | << | This is a bitwise left shift operator and shifts a number to the
    left by the number of bits specified in the expression and adds the zeros to the
    least significant bits, for example, `var result = num1 << 1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | >> | This is a bitwise right shift operator and shifts a number to the
    right by the number of bits specified in the expression, for example, `var result
    = num1 >> 1;` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment operators | = | The assignment operator that assigns values from
    right-hand side to the left-hand side operand, for example, `var result = nim1
    + num2;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | += | The add and assign operator; It adds and assigns values of the right
    operands to the left operands, for example, `result += num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | -= | The subtract and assign operator; It subtracts and assigns values
    of the right operands to the left operands, for example, `result -= num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | *= | The multiply and assign operator; It multiplies and assigns values
    of the right operands to the left operands, for example, `result *= num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | /= | The divide and assign operator; It divides and assigns values of
    the right operands to the left operands, for example, `result /= num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | %= | The modulus and assign operator; It takes modulus of the left and
    right operands and assigns value to the left operands, for example, `result %=
    num1;` |'
  prefs: []
  type: TYPE_TB
- en: '|  | <<= | Bitwise left shifts and assignment, for example, `result <<= 2;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | >>;= | Bitwise right shifts and assignment, for example, `result >>= 2;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | &= | Bitwise `AND` and assignment operator, for example,. `result &= Num1;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | ^= | Bitwise `XOR` and assignment operator, for example, `result ^= num1;`
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | &#124;= | Bitwise `OR` and assignment operator, for example, `result &#124;=
    num1;` |'
  prefs: []
  type: TYPE_TB
- en: 'Take a look at the following code snippet, which implements all operators discussed
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code is available on the GitHub repository, and it produces the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Discussing operator precedence in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The calculation or evaluation of any expression and the order of operators is
    very important. This is what is called operator precedence. We have all read the
    mathematic rule *Order of Operator*, which is abbreviated as *BODMAS*. Refer to
    [https://www.skillsyouneed.com/num/bodmas.html](https://www.skillsyouneed.com/num/bodmas.html)
    to refresh your memory. So, mathematics teaches us how to solve an expression;
    in a similar way, our C# should follow rules to solve or evaluate the expression.
    For instance, *3+2*5* evaluates as *13* and not *25*. So, in this equation, the
    rule is to first multiply and then add. That's why it evaluates as *2*5 = 10*
    and then *3+10 = 13*. You can set a higher precedence order by applying braces,
    so if you do this in the preceding statement *(3+2)*5*, it results in *25*.
  prefs: []
  type: TYPE_NORMAL
- en: To know more about operator precedence, refer to [https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx](https://msdn.microsoft.com/en-us/library/aa691323(VS.71).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple code snippet to evaluate the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operator loading is a way to redefine the actual functionality of a particular
    operator. This is important when you''re working with user-defined complex types,
    where the direct use of in-built operators is impossible. For instance, say, you
    have an object with numerous properties and you want an addition of two for these
    types of objects. It is not possible like this: `VeryComplexObject = result =
    verycoplexobj1 + verycomplexobj2;`. To overcome such a situation, overloading
    does the magic.'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot overload all inbuilt operators; refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/overloadable-operators)
    to see what operators are overloadable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code snippet to see how operator loading works
    (note that this code is not complete; refer to Github for the complete source
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a new type coordinate, which is a surface of
    *x* axis and *y* axis. Now if we want to apply some operations, that is not possible
    with the use of inbuilt operators. With the help of operator overloading, we enhance
    the actual functionality of inbuilt operators. The following code is the consumed
    coordinate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An overview of type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type conversion means converting one type into another type. Alternatively,
    we call it as casting or type casting. Type conversion is broadly divided into
    the following categories.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit conversion is the conversion that is performed by the C# compiler internally
    to match the the type of variable by assignment of values to that variable. This
    action happens implicitly, and there's no need to write any extra code to obey
    the type-safe mechanism. In implicit conversions, only smaller to larger types
    and derived classes to base class is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explicit conversion is the conversion that is performed by the user explicitly
    with the use of the cast operator; that's why this is also known as type casting.
    Explicit conversion is also possible using built-in type conversion methods. For
    more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit-numeric-conversions-table).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet, which shows implicit/explicit
    type conversion in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The two most important language fundamentals are type conversion and casting.
    To know more about these two, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, you can evaluate different kinds of expression that would or would not
    generate the results. Whenever you say something like *what would happen if result
    &gt;0*, in that case, we are stating something. This can be a decision-making
    statement, result-making statement, assignment statement, or any other activity
    statement. On the other hand, loops are a code block that repeatedly executes
    a couple of statements.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss statements and loops in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'A statement should perform some action before returning a result. In other
    words, if you are writing a statement, that statement should say something. To
    do that, it has to execute some inbuilt or custom operations. Statements can depend
    upon a decision or can be a part of the result of any existing statement. The
    official page ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements))
    defines statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement can consist of a single line of code that ends in a semicolon, or
    a series of single-line statements in a block. A statement block is enclosed in
    {} brackets and can contain nested blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet, which shows different statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used three type statements: declarative, assignment,
    and block statements. The code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: According to the official page ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)),
    C# statements can be broadly divided into the following categories.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you declare a variable or constant, you are writing a declarative statement.
    You can also assign the values to variables at the time of declaration of variables.
    Assigning values to variables at time of declaration is an optional task, but
    constants are required to assign values at the time you declared them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical declarative statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Expression statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an expression statement, the expression that is on the right-hand side evaluates
    results and assigns that result to the left-hand side variable. An expression
    statement could be an assignment, method invocation, or new object creation. This
    is the typical expression statement example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Selection statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is also called a decision-making statement. Statements are branched as
    per the condition and their evaluations. The condition may be one or more than
    one. The selection or decision statement falls under `if...else`, and `switch`
    case. In this section, we will discuss these statements in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement is a decision statement that could branch one or more statements
    to evaluate. This statement consists of a Boolean expression. Let''s consider
    the problem of finding vowels in a book that was discussed on day one. Let''s
    write this using the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The if..else statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this `if` statement followed by else and the else block execute in case
    evaluation of if block is false. This is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: if...else if...else statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `if...else` statement is very important when you need to test multiple conditions.
    In this statement, the `if` statement evaluates first, then the `else` `if` statement,
    and at last the else block executes. Here, the `if` statement may or may not have
    the `if...else` statement or block; `if...else` always comes after the `if` block
    and before the `else` block. The `else` statement is the final code block in the
    `if...else...if else...else` statement, which indicates that none of preceding
    conditions evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Nested if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nested `if` statements are nothing but `if` statement blocks within `if` statement
    blocks. Similarly, we can nest `else if` statement blocks. This is a simple code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a statement that provides a way to select an expression using `switch`
    statement that evaluates the conditions using `case` blocks when code does not
    fall in any of the `case` blocks; then, the `default` block executes (default
    block is an optional block in `switch...case` statement).
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch statement is also known as an alternative to `if...else if...else` statement.
    Let''s rewrite our examples used in the previous section to showcase the `if...else
    if...else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the default block will execute if none of the case evaluates
    to true. The `switch...case` statement will be discussed in detail on day three.
  prefs: []
  type: TYPE_NORMAL
- en: There is a slight difference when you're choosing between `switch...case` and
    `if...else`. Refer to [https://stackoverflow.com/questions/94305/what-is-quicker-switch-on-string-or-elseif-on-type](https://stackoverflow.com/questions/94305/what-is-quicker-switch-on-string-or-elseif-on-type)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These statements provide a way to iterate collection data. There may be a case
    where you want to execute a code block multiple times or a repetitive action is
    required on the same activity. There are iteration loops available to achieve
    this. Code blocks within the loop statement execute sequentially, which means
    the first statement executes first, and so on. The following are the main categories
    into which we can divide iteration statements of C#:'
  prefs: []
  type: TYPE_NORMAL
- en: The do...while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This helps us execute a statement or a statement of block repeatedly until it
    evaluates the expression to false. In `do...while` statement, a block of statement
    executes first and then it checks the condition under `while`, which means a statement
    or block of statements that execute at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This executes the statement or code block until the condition evaluates to
    true. In this expression evaluates before the execution of code-block, if expression
    evaluates to false, loop terminates and no statement or code-block execute. Take
    a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code executes the `while` statement repeatedly until expression
    evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is similar to other loops that help run a statement or code
    block repeatedly until an expression evaluates to false. The `for` loop takes
    three sections: the `initializer`, `condition`, and `iterator`, where the `initializer`
    section executes first and only once; this is nothing but a variable to start
    a loop. The next section is condition, and if it evaluates to true, then only
    body statements are executed; otherwise it terminates the loop. The third and
    most important section is incremental or iterator, which updates the loop control
    variable. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The foreach loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This helps iterate an array element or collection. It does the same thing as
    the `for` loop, but this is available to iterate through a collection without
    the facility to add or remove items from collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a working example of a `foreach` statement that prints
    a person's name. `Name` is a property in a collection of the `Person` object.
    The statement of the `foreach` block executes repeatedly until the expression
    `person in persons` evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: The jump statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jump statement, as is self-explanatory from the name, is a statement that
    helps move control from one section to another. These are the main jump statements
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This terminates the control flow `for` loop or in `switch` statement. Take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, execution of the `for` loop will break as soon as the
    `if` expression evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This helps `continue` the control to the next iteration of loop, and it comes
    with `while`, `do`, `for`, or `foreach` loops. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code bypasses the execution when the `if` expression evaluates
    to true.
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This comes with a `switch` statement and a `default` block that makes sure that
    `if` no match found in any of the `case` blocks, the `default` block executes.
    Refer to the `switch...case` statement for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exception-handling statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has the ability to handle unknown issues within a program, which is known
    as exceptional handling (we will discuss exception handling on day four).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and string manipulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and strings are important in C# programming. There may be chances when
    you need string manipulation or play with complex data using arrays. In this section,
    we will discuss arrays and strings.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is nothing but a data structure that stores fixed-size sequential elements
    of the same type. Elements of an array that contained data are basically variables,
    and we can also call an array a collection of variables of the same type, and
    this type is generally called an element type.
  prefs: []
  type: TYPE_NORMAL
- en: An array is a block of contiguous memory. This block stores everything required
    for an array, that is, elements, element rank, and length of the array. The first
    element rank is 0 and the last element rank is equal to the total length of array
    - 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `char[] vowels = {''a'', ''e'', ''i'', ''o'', ''u''};`
    array. An array with size five. Every element is stored in a sequential manner
    and can be accessed using its element rank. The following is the diagram showing
    what things an array declaration contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure is a representation of our array declaration for vowels
    that are of *Data type* char. Here, *[ ]* represents an array and tells CLR that
    we are declaring an array of characters. Vowels is a variable name and the right-hand
    side representation of a complete array that contains data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts what this array looks like in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.gif)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, we have a group of contiguous memory blocks. This also
    tells us that the lowest address of an array in memory corresponds to the first
    element of an array and the highest address of the array in memory corresponds
    to the last element.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the value of an element by its rank (starting with 0). So, in
    the preceding code, *vowels[0]* will give us *a* and *vowels[4]* will give us
    *u*.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about an array, we mean a reference type because array types are
    reference types. Array types are derived from `System.Array`, which is a class.
    Hence, all array types are reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can also get the values using `for`, which iterates until
    the `rankIndex < vowels.Length` expression evaluates to false and the code block
    of the `for` loop statement prints the array element based on its rank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we initialized the array and assigned data to a statement
    that is equivalent to `char[] vowels = newchar[5];`. Here, we are telling CLR
    that we are creating an array named vowels of type char that has a maximum of
    five elements. Alternatively, we can also declare the same `char[] vowels = newchar[5]
    { 'a', 'e', 'i', 'o', 'u' };`
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the different types of arrays and see how we
    can use arrays in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Types of arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we discussed what an array is and how we can declare an array. Until
    now, we have discussed an array of single dimension. Consider a matrix where we
    have rows and columns. Arrays are a representation of data arranged in rows and
    columns in respect of the matrix. However, arrays have more types as discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Single-dimensional array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single-dimensional array can be declared simply by initializing the array
    class and setting up the size. Here is a single-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be declared as more than one-dimension, which that means you can
    create a matrix of rows and columns. Multidimensional arrays could be two-dimensional
    arrays, three-dimensional arrays, or more. Different ways to create a typical
    two-dimensional array of 2x2 size means two rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the code-snippet that accesses the two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A square matrix is the one with the same rows and columns. Generally, it is
    called an *n* by *n* matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Jagged array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jagged array is an array of array or array in array. In a jagged array, the
    element of array is an array. You can also set an array's element with different
    sizes/dimensions. Any element of jagged array can have another array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical declaration of a jagged array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are declaring a jagged array of three elements that
    contain a two-dimensional array. After execution, it produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also declare more complex arrays to interact with more complex scenarios.
    You can get more information by referring to [https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0).
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly typed arrays can be created as well. In implicitly typed arrays,
    the array type inferred from the elements is defined during array initialization,
    for instance, `var charArray = new[] {'a', 'e', 'i', 'o', 'u'};` here we declare
    a char array. For more information on implicitly typed arrays, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, a string is nothing but an array of characters that represents UTF-16
    code units and is used to represent a text.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum size of a string in memory is 2 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of a string object is as simple as you declaring any variable
    the most commonly used statement: `string authorName = "Gaurav Aroraa";`.'
  prefs: []
  type: TYPE_NORMAL
- en: A string object is called immutable, which means it is read-only. A string object's
    value cannot be modified after it is created. Every operation that you perform
    on a string object returns a new string. As strings are immutable, they cause
    a huge performance penalty because every operation on a string needs to create
    a new string. To overcome this, the `StringBuilder` object is available in the
    `System.Text` class.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on strings, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0#Immutability](https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0#Immutability).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the alternative ways to declare string objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippets tells us that the declaration can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: String literal assignment while declaring a string variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While concatenating string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor initialization using `new`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method returning string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of string methods and formatting actions that are available
    for string operations; refer to [https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.0)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Structure versus class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a class in C#, a struct is also a data structure that consists of
    members, functions, and so on. Classes are reference types, but structs are value
    types; hence, these are not required for heap allocation but for allocation on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Value type data will be allocated on stack and reference type data will be allocated
    on heap. A value type that is used in struct is stored on the stack, but when
    the same value type is used in an array, it is stored in a heap.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on heap and stack memory allocation, refer to [http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html](http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html)
    and [https://www.codeproject.com/Articles/1058126/Memory-allocation-in-Net-Value-type-Reference-type](https://www.codeproject.com/Articles/1058126/Memory-allocation-in-Net-Value-type-Reference-type).
  prefs: []
  type: TYPE_NORMAL
- en: So, when you create a variable of `struct` type, that variable directly stores
    data instead of reference, as is the case with classes. In C#, the `struct` keyword
    (refer to section C# keywords for more detail) helps declare structures. Structures
    are helpful in representing a record or when you need to present some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a structure named `BookAuthor` that represents the data of a
    book author. Take a look at the following code that is consuming this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This simply displays the author details. The important point here is that once
    we've copied the structure, changing any field of the structure would not impact
    the copied contents; this is because when we copy, only the data is copied. If
    you perform the same operation on a class, that results in copying references
    instead of copying data. This copying process is called deep copy and shallow
    copy. Refer to [https://www.codeproject.com/Articles/28952/Shallow-Copy-vs-Deep-Copy-in-NET](https://www.codeproject.com/Articles/28952/Shallow-Copy-vs-Deep-Copy-in-NET)
    in order to know more about shallow copy versus deep copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try the same operations with the class; take a look at the following
    code, which consumes our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now both our class variables will have the same values. The following screenshot
    shows us the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Structures and classes are different:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures are value types, whereas classes are reference types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes support single inheritance (multiple inheritance can be achieved using
    interfaces), but structures do not support inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes have an implicit default constructor, but a structure does not have
    a default constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more functionalities of structures that we did not discuss here. Refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/structs](https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/structs)
    to get more inside information about struct.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rewind our learning for today - that is, day two - by solving the following
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a short program to demonstrate that we can use same class name within
    different namespaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `console` class. Write a `console` program to display all available
    colors by modifying the code example discussed in the book so that all vowels
    will be displayed as green and all consonants as blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elaborate on C# reserved keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe different categories of C# keywords with examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a small program to demonstrate the `is` and `as` operators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase a query expression with the help of contextual
    keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase the importance of the `this` and `base` keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define boxing and unboxing with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to prove that pointer type variable stores the memory
    of another variable rather than data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to showcase the operator precedence order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is operator overloading? Write a short program to showcase operator overloading
    in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the operators that cannot be overloaded and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define type conversion with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program that uses all the available built-in C# types and perform
    casting using the conversion method (decimal to int conversion can be achieved
    using `var result = Convert.ToInt32(5689.25);`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define C# statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to elaborate each statement category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are `jump` statements? Write a small program to showcase all `jump` statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an array in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program and prove that an array is a block of contiguous memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to `System.Array` class ([https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.array?view=netcore-2.0))
    and write a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass an array as a parameter to a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the `System.String` class and explore all its methods and properties
    with the help of a short program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are string objects immutable? Write a short program to showcase this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are string builders?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a small program and showcase the differences between a `struct` and a
    `class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain compile-time type and runtime type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to show the difference between compile-time type and runtime
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a short program to prove that, explicitly, type conversion leads to data
    loss.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting day 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are concluding day two of our seven-day learning series. Today, we started
    with a very simple C# program and went through all of its parts (a typical C#
    program). Then, we discussed everything about C# reserved keywords and accessors
    and we also understand what contextual keywords are.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the type casting and type conversion of various available data types
    in C#. You learned how boxing and unboxing happened and how we can perform conversion
    using inbuilt methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also went through and understood various statements, and you learned the
    usage and flow of various statements, such as `for`, `foreach`, `while`, `do`.
    We looked at conditional statements, `that is`, `if`, `if...else`, `if...elseif...else`
    switch with the help of code examples.
  prefs: []
  type: TYPE_NORMAL
- en: We then went through arrays and understood them with the help of code examples,
    including string manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we concluded our day by covering structure and classes. We looked at
    how these two are different.
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow, on day three, we will discuss all the new features of the C# language
    and discuss their usage and functionality with the help of code examples.
  prefs: []
  type: TYPE_NORMAL
