- en: Chapter 5. Introduction to Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mongoose is a robust Node.js ODM module that adds MongoDB support to your Express
    application. It uses schemas to model your entities, offers predefined validation
    along with custom validations, allows you to define virtual attributes, and uses
    middleware hooks to intercept operations. The Mongoose design goal is to bridge
    the gap between the MongoDB schemaless approach and the requirements of real-world
    application development. In this chapter, you''ll go through the following basic
    features of Mongoose:'
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose schemas and models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema indexes, modifiers, and virtual attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the model's methods and performing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying your data using predefined and custom validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware to intercept the model's methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose is a Node.js module that provides developers with the ability to model
    objects and save them as MongoDB documents. While MongoDB is a schemaless database,
    Mongoose offers you the opportunity to enjoy both strict and loose schema approaches
    when dealing with Mongoose models. As with any other Node.js module, before you
    can start using it in your application, you will first need to install it. The
    examples in this chapter will continue directly from those in the previous chapters;
    so, for this chapter, copy the final example from [Chapter 3](ch03.html "Chapter 3. Building
    an Express Web Application"), *Building an Express Web Application*, and let's
    start from there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Mongoose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve installed and verified that your MongoDB local instance is running,
    you''ll be able to connect it using the Mongoose module. First, you will need
    to install Mongoose in your `node_modules` folder, so change your `package.json`
    file to look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To install your application dependencies, go to your application folder and
    issue the following command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will install the latest version of Mongoose in your `node_modules` folder.
    After the installation process has successfully finished, the next step will be
    to connect to your MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect to MongoDB, you will need to use the MongoDB connection URI. The
    MongoDB connection URI is a string URL that tells the MongoDB drivers how to connect
    to the database instance. The MongoDB URI is usually constructed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you''re connecting to a local instance, you can skip the username and
    password and use the following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest thing to do is to define this connection URI directly in your
    `config/express.js` configuration file and use the `mongoose` module to connect
    to the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since you''re building a real application, saving the URI directly
    in the `config/express.js` file is a bad practice. The proper way to store application
    variables is to use your environment configuration file. Go to your `config/env/development.js`
    file and change it to look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in your `config` folder, create a new file named `mongoose.js`, which contains
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how you required the `mongoose` module and connected to the MongoDB instance
    using the `db` property of your configuration object. To initialize your Mongoose
    configuration, go back to your `server.js` file and change it to look like what
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it; you have installed Mongoose, updated your configuration file, and
    connected to your MongoDB instance. To start your application, use your command-line
    tool and navigate to your application folder to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Your application should be running and be connected to the MongoDB local instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you experience any problems or get the `Error: failed to connect to [localhost:27017]`
    output, make sure that your MongoDB instance is running properly.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Mongoose schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to your MongoDB instance was the first step, but the real magic of
    the Mongoose module is its ability to define a document schema. As you already
    know, MongoDB uses collections to store multiple documents, which aren't required
    to have the same structure as one another. However, when dealing with objects,
    it is sometimes necessary for documents to be similar. Mongoose uses a schema
    object to define the document list of properties, each with its own type and constraints
    in order to enforce the document structure. After specifying a schema, you will
    go on to define a Model constructor, which you'll use to create instances of MongoDB
    documents. In this section, you'll learn how to define a user schema and model
    and how to use a model instance to create, retrieve, and update user documents.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user schema and model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create your first schema, go to the `app/models` folder and create a new
    file named `user.server.model.js`. In this file, paste the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, you did two things: first, you defined your
    `UserSchema` object using the `Schema` constructor, and then you used the schema
    instance to define your User model. Note that for simplicity reasons, we save
    the password as clear text; however, in real world applications, the user password
    should be properly encrypted. Next, you''ll learn how to use the User model to
    perform CRUD operations in your application''s logic layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering the User model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can start using the User model, you will need to include the `user.server.model.js`
    file in your Mongoose configuration file in order to register the User model.
    To do this, change your `config/mongoose.js` file to look like what is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your Mongoose configuration file is loaded before any other configuration
    is performed in the `server.js` file. This is important since any module that
    is loaded after this module will be able to use the User model without loading
    it by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new users using save()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can start using the User model right away, but to keep things organized,
    it is better that you create a `Users` controller that will handle all user-related
    operations. In the `app/controllers` folder, create a new file named `users.server.controller.js`
    and paste the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over this code. First, you used the `mongoose` module to call the `model`
    method, which will return the `User` model you defined previously. Next, you create
    a controller method named `create()`, which you will later use to create new users.
    Using the new keyword, the `create()` method creates a new model instance, which
    is populated using the request body. Finally, you call the model instance's `save()`
    method, which either saves the user and outputs the `user` object or fails it,
    passing the error to the next middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your new controller, let''s add a set of user-related routes that call
    the controller''s methods. Begin by creating a file named `users.server.routes.js`
    inside the `app/routes` folder. In this newly created file, paste the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since your Express application will serve mainly as a RESTful API for the AngularJS
    application, it is a best practice to build your routes according to the REST
    principles. In this case, the proper way to create a new user is to use an HTTP
    POST request to the base `users` route you defined here. Change your `config/express.js`
    file to look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! To test it out, go to your root application folder and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application should be running. To create a new user, perform an HTTP POST
    request to the base `users` route and make sure that the request body includes
    the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to test your application would be to execute the following `curl`
    command in your command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are going to execute many different HTTP requests to test your application.
    For Mac OS X and Linux users, `curl` is a useful tool, but there are several other
    tools specifically designed for this task; we recommend that you find your favorite
    one and use it from now on.
  prefs: []
  type: TYPE_NORMAL
- en: Finding multiple user documents using find()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `find()` method is a model method that retrieves multiple documents stored
    in the same collection using a query and is a Mongoose implementation of the MongoDB
    `find()` collection method. To understand this better, add the following `list()`
    method to your `app/controllers/users.server.controller.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the new `list()` method uses the `find()` method to retrieve an array
    of all the documents in the `users` collection. To use the new method you created,
    you''ll need to register a route for it, so go to your `app/routes/users.server.routes.js`
    file and change it to look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'All you have left to do is run your application by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, you will be able to retrieve a list of your users by visiting `http://localhost:3000/users`
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced querying using find()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding code example, the `find()` method accepted two arguments,
    a MongoDB query object and a callback function, but it can accept up to four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Query`: This is a MongoDB query object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Fields]`: This is an optional string object that represents the document
    fields to be returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Options]`: This is an optional `options` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Callback]`: This is an optional callback function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, in order to retrieve only the usernames and e-mails of your users,
    you will need to modify your call to look like what is shown in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, you can also pass an `options` object when calling the `find()`
    method, which will manipulate the query result. For instance, to paginate through
    the `users` collection and retrieve only a subset of your `users` collection,
    you can use the `skip` and `limit` options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will return a subset of up to 10 user documents while skipping the first
    10 documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about query options, it is recommended that you visit the official
    Mongoose documentation at [http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: Reading a single user document using findOne()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Retrieving a single user document is done using the `findOne()` method, which
    is very similar to the `find()` method, but it retrieves only the first document
    of the subset. To start working with a single user document, we''ll have to add
    two new methods. Add the following lines of code to the end of your `app/controllers/users.server.controller.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read()` method is simple to understand; it is just responding with a JSON
    representation of the `req.user` object, but what is creating the `req.user` object?
    Well, the `userById()` method is the one responsible for populating the `req.user`
    object. You will use the `userById()` method as a middleware to deal with the
    manipulation of single documents when performing read, delete, and update operations.
    To do this, you will have to modify your `app/routes/users.server.routes.js` file
    to look like what is shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note how you added the `users.read()` method with a request path containing
    `userId`. In Express, adding a colon before a substring in a route definition
    means that this substring will be handled as a request parameter. To handle the
    population of the `req.user` object, you use the `app.param()` method, which defines
    a middleware to be executed before any other middleware that uses that parameter.
    Here, the `users.userById()` method will be executed before any other middleware
    registered with the `userId` parameter, which is the `users.read()` middleware
    in this case. This design pattern is useful when building a RESTful API, where
    you often add request parameters to the routing string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, run your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then, navigate to `http://localhost:3000/users` in your browser, grab one of
    your users' `_id` values, and navigate to `http://localhost:3000/users/[id]`,
    replacing the `[id]` part with the user's `_id` value.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an existing user document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mongoose model has several available methods to update an existing document.
    Among these are the `update()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`
    methods. Each of the methods serves a different level of abstraction, easing the
    `update` operation when possible. In our case, and since we already use the `userById()`
    middleware, the easiest way to update an existing document would be to use the
    `findByIdAndUpdate()` method. To do this, go back to your `app/controllers/users.server.controller.js`
    file and add a new `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how you used the user''s `id` field to find and update the correct
    document. Note that the default Mongoose behavior is to pass the callback to the
    document before it was updated; by setting the `new` option to `true`, we''re
    making sure that we''re receiving the updated document. The next thing you should
    do is wire your new `update()` method in your users'' routing module. Go back
    to your `app/routes/users.server.routes.js` file and change it to look like what
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how you used the route you had previously created and how you just chained
    the `update()` method using the route''s `put()` method. To test your `update()`
    method, run your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use your favorite REST tool to issue a PUT request, or use `curl` and
    execute this command, replacing the `[id]` part with a real document''s `_id`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an existing user document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Mongoose model has several available methods for removing an existing document.
    Among these are the `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`
    methods. In our case, and since we already use the `userById()` middleware, the
    easiest way to remove an existing document would be to simply use the `remove()`
    method. To do this, go back to your `app/controllers/users.server.controller.js`
    file and add the following `delete()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how you used the `user` object to remove the correct document. The next
    thing you should do is use your new `delete()` method in your user''s routing
    file. Go to your `app/routes/users.server.routes.js` file and change it to look
    like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how you used the route you had previously created and how you just chained
    the `delete()` method using the route''s `delete()` method. To test your `delete`
    method, run your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use your favorite REST tool to issue a `DELETE` request, or use `curl`
    and execute the following command, replacing the `[id]` part with a real document''s
    `_id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This completes the implementation of the four CRUD operations, providing you
    with a brief understanding of the Mongoose model capabilities. However, these
    methods are just examples of the vast features included with Mongoose. In the
    next section, you'll learn how to define default values, power your schema fields
    with modifiers, and validate your data.
  prefs: []
  type: TYPE_NORMAL
- en: Extending your Mongoose schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing data manipulations is great, but in order to develop complex applications,
    you will need your ODM module to do more. Luckily, Mongoose supports various other
    features that help you safely model your documents and keep your data consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Defining default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining default field values is a common feature for data-modeling frameworks.
    You can add this functionality directly to your application's logic layer, but
    that would be messy and is generally a bad practice. Mongoose offers to define
    the default values at the schema level, helping you organize your code better
    and guaranteeing your documents' validity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to add a created date field to your `UserSchema`. The created
    date field should be initialized at creation time and the time at which the user
    document was initially created should be saved—a perfect example of when you can
    utilize a default value. To do this, you''ll have to change your `UserSchema`;
    so, go back to your `app/models/user.server.model.js` file and change it to look
    like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note how the created field is added and its default value defined. From now
    on, every new user document will be created with a default creation date that
    represents the moment the document was created. You should also note that every
    user document created prior to this schema change would be assigned a created
    field representing the moment you queried for it, since these documents don't
    have the created field initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your new changes, run your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use your favorite REST tool to issue a POST request or use `curl` and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A new user document will be created with a default created field initialized
    at the moment of creation.
  prefs: []
  type: TYPE_NORMAL
- en: Using schema modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may want to perform a manipulation over schema fields before
    saving them or presenting them to the client. For this purpose, Mongoose uses
    a feature called *modifiers*. A modifier can either change the field's value before
    saving the document, or it can represent it differently at query time.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest modifiers are the predefined ones included with Mongoose. For
    instance, string-type fields can have a trim modifier to remove whitespaces, an
    uppercase modifier to uppercase the field value, and so on. To understand how
    predefined modifiers work, let''s make sure the username of your users is clear
    from a leading and trailing whitespace. To do this, all you have to do is change
    your `app/models/user.server.model.js` file to look like what is shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the `trim` property added to the `username` field. This will make sure
    your username data will be kept trimmed.
  prefs: []
  type: TYPE_NORMAL
- en: Custom setter modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Predefined modifiers are great, but you can also define your own custom setter
    modifiers to handle data manipulation before saving the document. To understand
    this better, let''s add a new `website` field to your User model. The `website`
    field should begin with `http://` or `https://`, but instead of forcing your customer
    to add this in the UI, you can simply write a custom modifier that validates the
    existence of these prefixes and adds them when required. To add your custom modifier,
    you will need to create the new `website` field with a `set` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, every user created will have a properly formed website URL that is modified
    at creation time. However, what if you already have a big collection of user documents?
    You can, of course, migrate your existing data, but when dealing with big datasets,
    it would have a serious performance impact, so you can simply use getter modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Custom getter modifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Getter** modifiers are used to modify existing data before outputting the
    documents to the next layer. For instance, in our previous example, a getter modifier
    would sometimes be better for changing the already existing user documents by
    modifying their website field at query time instead of going over your MongoDB
    collection and updating each document. To do this, all you have to do is change
    your `UserSchema`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You simply changed the setter modifier to a getter modifier by changing the
    `set` property to `get`. However, the important thing to notice here is how you
    configured your schema using `UserSchema.set()`. This will force Mongoose to include
    getters when converting the MongoDB document to a JSON representation and will
    allow the output of documents using `res.json()` in order to include the getter's
    behavior. If you didn't include this, you would have your document's JSON representation
    ignoring the getter modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modifiers are powerful and can save you a lot of time, but they should be used
    with caution in order to prevent unpredicted application behavior. It is recommended
    that you visit [http://mongoosejs.com/docs/api.html](http://mongoosejs.com/docs/api.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding virtual attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to have dynamically calculated document properties,
    which are not really presented in the document. These properties are called *virtual
    attributes*, and they can be used to address several common requirements. For
    instance, let''s say you want to add a new `fullName` field, which will represent
    the concatenation of the user''s first and last names. To do this, you will have
    to use the `virtual()` schema method; so, a modified `UserSchema` would include
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, you added a virtual attribute named `fullName`
    to your `UserSchema`, added a `getter` method to that virtual attribute, and then
    configured your schema to include virtual attributes when converting the MongoDB
    document to a JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, virtual attributes can also have setters in order to help you save
    your documents they way you prefer instead of just adding more field attributes.
    In this case, let''s say you wanted to break an input''s `fullName` field into
    your first and last name fields. To do this, a modified virtual declaration would
    look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Virtual attributes are a great feature of Mongoose, allowing you to modify document
    representation as they're being moved through your application's layers without
    getting persisted to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing queries using indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we previously discussed, MongoDB supports various types of indexes to optimize
    query execution. Mongoose also supports the indexing functionality and even allows
    you to define secondary indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic example of indexing is the unique index, which validates the uniqueness
    of a `document` field across a collection. In our example, it is common to keep
    usernames unique, so in order to convey this to MongoDB, you will need to modify
    your `UserSchema` definition to include the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell MongoDB to create a unique index for the `username` field of
    the `users` collections. Mongoose also supports the creation of secondary indexes
    using the `index` property. So, if you know that your application will use a lot
    of queries involving the `email` field, you can optimize these queries by creating
    an e-mail secondary index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Indexing is a wonderful feature of MongoDB, but you should keep in mind that
    it might cause you some trouble. For example, if you define a unique index on
    a collection where data is already stored, you might encounter some errors while
    running your application until you fix the issues with your collection data. Another
    common issue is Mongoose's automatic creation of indexes when the application
    starts, a feature that can cause major performance issues when running in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom model methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose models are quite packed with both static and instance predefined methods,
    some of which you have already used. However, Mongoose also lets you define your
    own custom methods to empower your models, giving you a modular tool to separate
    your application logic properly. Let's go over the proper way of defining these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Model static methods give you the liberty to perform model-level operations,
    such as adding extra `find` methods. For instance, let''s say you want to search
    users by their username. You could, of course, define the `this` method in your
    controller, but that wouldn''t be the right place for it. What you''re looking
    for is a static model method. To add a static method, you will need to declare
    it as a member of your schema''s `statics` property. In our case, adding a `findOneByUsername()`
    method would look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is using the model''s `findOne()` method to retrieve a user document
    that has a certain username. Using the new `findOneByUsername()` method would
    be similar to using a standard `static` method by calling it directly from the
    `User` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course, come up with many other static methods; you'll probably
    need them when developing your application, so don't be afraid to add them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom instance methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static methods are great, but what if you need methods that perform instance
    operations? Well, Mongoose offers support for those too, helping you slim down
    your code base and properly reuse your application code. To add an instance method,
    you will need to declare it as a member of your schema''s `methods` property.
    Let''s say you want to validate your user''s password with an `authenticate()`
    method. Adding this method would then be similar to what is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow you to call the `authenticate()` method from any `User` model
    instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, defining custom model methods is a great way to keep your project
    properly organized while reusing common code. In the upcoming chapters, you'll
    discover how both instance and static methods can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Model validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major issues when dealing with data marshaling is validation. When
    users input information to your application, you'll often have to validate that
    information before passing it on to MongoDB. While you can validate your data
    at the logic layer of your application, it is more useful to do this at the model
    level. Luckily, Mongoose supports both simple predefined validators and more complex
    custom validators. Validators are defined at the field level of a document and
    are executed when the document is being saved. If a validation error occurs, the
    save operation is aborted and the error is passed to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mongoose supports different types of predefined validators, most of which are
    type-specific. The basic validation of any application is, of course, the existence
    of a value. To validate field existence in Mongoose, you''ll need to use the `required`
    property in the field you want to validate. Let''s say you want to verify the
    existence of a `username` field before you save the user document. To do this,
    you''ll need to make the following changes to your `UserSchema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will validate the existence of the `username` field when saving the document,
    thus preventing the saving of any document that doesn't contain that field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `required` validator, Mongoose also includes type-based predefined
    validators, such as the `enum` and `match` validators for strings. For instance,
    to validate your `email` field, you will need to change your `UserSchema` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The usage of a `match` validator here will make sure that the `email` field
    value matches the given `regex` expression, thus preventing the saving of any
    document where the e-mail doesn't conform to the right pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is the `enum` validator, which can help you define a set of
    strings that are available for that field value. Let''s say you add a `role` field.
    A possible validation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding condition will allow the insertion of only these three possible
    strings, thus preventing you from saving the document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about predefined validators, it is recommended that you visit
    [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other than predefined validators, Mongoose also enables you to define your
    own custom validators. Defining a custom validator is done using the `validate`
    property. The `validate` property value should be an array consisting of a **validation**
    function and an error message. Let''s say you want to validate the length of your
    user password. To do this, you would have to make these changes in your `UserSchema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This validator will make sure your user password is at least six characters
    long, or else it will prevent the saving of documents and pass the error message
    you defined to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose validation is a powerful feature that allows you to control your model
    and supply proper error handling, which you can use to help your users understand
    what went wrong. In the upcoming chapters, you'll learn how you can use Mongoose
    validators to handle users input and prevent common data inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mongoose middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mongoose middleware are functions that can intercept the process of the `init`,
    `validate`, `save`, and `remove` instance methods. Middleware are executed at
    the instance level and have two types: pre middleware and post middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: Using pre middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pre middleware gets executed before the operation happens. For instance, a pre-save
    middleware will get executed before the saving of the document. This functionality
    makes pre middleware perfect for more complex validations and default values assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pre middleware is defined using the `pre()` method of the schema object,
    so validating your model using a pre middleware will look like what is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using post middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A post middleware gets executed after the operation happens. For instance, a
    post-save middleware will get executed after saving the document. This functionality
    makes post middleware perfect for logging your application logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'A post middleware is defined using the `post()` method of the schema object,
    so logging your model''s `save()` method using a post middleware will look something
    like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Mongoose middleware are great for the performing of various operations, including
    logging, validation, and performing various data consistency manipulations. Don't
    worry if you feel overwhelmed right now because later on in this book, you'll
    understand these better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about middleware, it is recommended that you visit [http://mongoosejs.com/docs/middleware.html](http://mongoosejs.com/docs/middleware.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using Mongoose ref fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although MongoDB doesn't support joins, it supports the reference from a document
    to another document using a convention named **DBRef**. DBRef enables the reference
    from one document to another using a special field that contains the collection
    name and the document `ObjectId` field. Mongoose implements a similar behavior
    for supporting document referral using the `ObjectID` schema type and the use
    of the `ref` property. It also supports the population of the parent document
    with the child document when querying the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s say you create another schema for blog posts
    called `PostSchema`. Because a user authors a blog post, `PostSchema` will contain
    an `author` field that will be populated by a `User` model instance. So, a `PostSchema`
    will look like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note the `ref` property telling Mongoose that the `author` field will use the
    `User` model to populate the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this new schema is a simple task. To create a new blog post, you will
    need to retrieve or create an instance of the `User` model, create an instance
    of the `Post` model, and then assign the `post author` property with the `user`
    instance. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Mongoose will create a reference in the MongoDB `post` document and will later
    use it to retrieve the referenced user document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is only an `ObjectID` reference to a real document, Mongoose will
    have to populate the `post` instance with the `user` instance. To do this, you''ll
    have to tell Mongoose to use the `populate()` method when retrieving the document.
    For instance, a `find()` method that populates the `author` property will look
    like what is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Mongoose will then retrieve all the documents in the `posts` collection and
    populate their `author` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose's support for this feature enables you to calmly rely on object references
    to keep your data models organized. Later in this book, you'll learn how to reference
    in order to support your application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about reference fields and population, it is recommended that
    you visit [http://mongoosejs.com/docs/populate.html](http://mongoosejs.com/docs/populate.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the robust Mongoose model. You connected
    to your MongoDB instance and created your first Mongoose schema and model. You
    also learned how to validate your data and modify it using schema modifiers and
    Mongoose middleware. You discovered virtual attributes and modifiers, and you
    learned how to use them in order to change the representation of your documents.
    You also discovered how to use Mongoose to implement a reference between documents.
    In the next chapter, we'll go through the **Passport** authentication module,
    which will use your `User` model to address user authentication.
  prefs: []
  type: TYPE_NORMAL
