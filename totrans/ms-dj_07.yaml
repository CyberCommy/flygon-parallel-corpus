- en: Chapter 7. Advanced Views and URLconfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views and URLconfs*,
    we explained the basics of Django's view functions and URLconfs. This chapter
    goes into more detail about advanced functionality in those two pieces of the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: URLconf Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's nothing special about URLconfs-like anything else in Django, they're
    just Python code. You can take advantage of this in several ways, as described
    in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlining function imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this URLconf, which builds on the example in [Chapter 2](ch02.xhtml
    "Chapter 2. Views and URLconfs"), *Views and URLconfs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As explained in [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views
    and URLconfs*, each entry in the URLconf includes its associated view function,
    passed directly as a function object. This means it's necessary to import the
    view functions at the top of the module.
  prefs: []
  type: TYPE_NORMAL
- en: But as a Django application grows in complexity, its URLconf grows, too, and
    keeping those imports can be tedious to manage. (For each new view function, you
    have to remember to import it, and the import statement tends to get overly long
    if you use this approach.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to avoid that tedium by importing the `views` module itself.
    This example URLconf is equivalent to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Special-Casing URLs in debug mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of constructing `urlpatterns` dynamically, you might want to take
    advantage of this technique to alter your URLconf''s behavior while in Django''s
    debug mode. To do this, just check the value of the `DEBUG` setting at runtime,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the URL `/debuginfo/` will only be available if your `DEBUG`
    setting is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Named groupsPreview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above example used simple, non-named regular-expression groups (via parenthesis)
    to capture bits of the URL and pass them as positional arguments to a view.
  prefs: []
  type: TYPE_NORMAL
- en: In more advanced usage, it's possible to use named regular-expression groups
    to capture URL bits and pass them as keyword arguments to a view.
  prefs: []
  type: TYPE_NORMAL
- en: In Python regular expressions, the syntax for named regular-expression groups
    is `(?P<name>pattern)`, where `name` is the name of the group and `pattern` is
    some pattern to match.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have a list of book reviews on our books site, and we want
    to retrieve reviews for certain dates, or date ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Notes:**'
  prefs: []
  type: TYPE_NORMAL
- en: To capture a value from the URL, just put parenthesis around it. There's no
    need to add a leading slash, because every URL has that. For example, it's `^reviews`,
    not `^/reviews`.
  prefs: []
  type: TYPE_NORMAL
- en: The `'r'` in front of each regular expression string is optional but recommended.
    It tells Python that a string is raw-that nothing in the string should be escaped.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example requests:**'
  prefs: []
  type: TYPE_NORMAL
- en: A request to `/reviews/2005/03/` would match the third entry in the list. Django
    would call the function `views.month_archive(request,``'2005',``'03')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/reviews/2005/3/` would not match any URL patterns, because the third entry
    in the list requires two digits for the month.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/reviews/2003/` would match the first pattern in the list, not the second
    one, because the patterns are tested in order, and the first one is the first
    test to pass. Feel free to exploit the ordering to insert special cases like this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/reviews/2003` would not match any of these patterns, because each pattern
    requires that the URL end with a slash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/reviews/2003/03/03/` would match the final pattern. Django would call the
    function `views.review_detail(request,``''2003'',``''03'',``''03'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the above example URLconf, rewritten to use named groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This accomplishes exactly the same thing as the previous example, with one
    subtle difference: The captured values are passed to view functions as keyword
    arguments rather than positional arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: A request to `/reviews/2005/03/` would call the function `views.month_archive(request,``year='2005',``month='03')`,
    instead of `views.month_archive(request,``'2005',``'03')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request to `/reviews/2003/03/03/` would call the function `views.review_detail(request,``year='2003',``month='03',``day='03')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, this means your URLconfs are slightly more explicit and less prone
    to argument-order bugs-and you can reorder the arguments in your view's function
    definitions. Of course, these benefits come at the cost of brevity; some developers
    find the named-group syntax ugly and too verbose.
  prefs: []
  type: TYPE_NORMAL
- en: The matching/grouping algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the algorithm the URLconf parser follows, with respect to named groups
    vs. non-named groups in a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are any named arguments, it will use those, ignoring non-named arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it will pass all non-named arguments as positional arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both cases, any extra keyword arguments that have been given will also be
    passed to the view.
  prefs: []
  type: TYPE_NORMAL
- en: What the URLconf searches against
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The URLconf searches against the requested URL, as a normal Python string. This
    does not include `GET` or `POST` parameters, or the domain name. For example,
    in a request to `http://www.example.com/myapp/`, the URLconf will look for `myapp/`.
    In a request to `http://www.example.com/myapp/?page=3`, the URLconf will look
    for `myapp/`. The URLconf doesn't look at the request method. In other words,
    all request methods-`POST`, `GET`, `HEAD`, and so on-will be routed to the same
    function for the same URL.
  prefs: []
  type: TYPE_NORMAL
- en: Captured arguments are always strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each captured argument is sent to the view as a plain Python string, regardless
    of what sort of match the regular expression makes. For example, in this URLconf
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '...the `year` argument to `views.year_archive()` will be a string, not an integer,
    even though the `[0-9]{4}` will only match integer strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying defaults for view arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A convenient trick is to specify default parameters for your view''s arguments.
    Here''s an example URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, both URL patterns point to the same view-`views.page`-but
    the first pattern doesn't capture anything from the URL. If the first pattern
    matches, the `page()` function will use its default argument for `num`, `"1"`.
    If the second pattern matches, `page()` will use whatever `num` value was captured
    by the regex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Keyword Arguments vs. Positional Arguments**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python function can be called using keyword arguments or positional arguments-and,
    in some cases, both at the same time. In a keyword argument call, you specify
    the names of the arguments along with the values you''re passing. In a positional
    argument call, you simply pass the arguments without explicitly specifying which
    argument matches which value; the association is implicit in the arguments'' order.
    For example, consider this simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def sell(item, price, quantity): print "Selling %s unit(s) of %s at %s" %
    (quantity, item, price)`'
  prefs: []
  type: TYPE_NORMAL
- en: To call it with positional arguments, you specify the arguments in the order
    in which they're listed in the function definition:`sell('Socks', '$2.50', 6)`
  prefs: []
  type: TYPE_NORMAL
- en: To call it with keyword arguments, you specify the names of the arguments along
    with the values. The following statements are equivalent:`sell(item='Socks', price='$2.50',
    quantity=6)` `sell(item='Socks', quantity=6, price='$2.50')` `sell(price='$2.50',
    item='Socks', quantity=6)` `sell(price='$2.50', quantity=6, item='Socks')` `sell(quantity=6,
    item='Socks', price='$2.50')` `sell(quantity=6, price='$2.50', item='Socks')`
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can mix keyword and positional arguments, as long as all positional
    arguments are listed before keyword arguments. The following statements are equivalent
    to the previous examples: `sell(''Socks'', ''$2.50'', quantity=6)` `sell(''Socks'',
    price=''$2.50'', quantity=6)` `sell(''Socks'', quantity=6, price=''$2.50'')`'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each regular expression in a `urlpatterns` is compiled the first time it's accessed.
    This makes the system blazingly fast.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Django can''t find a regex matching the requested URL, or when an exception
    is raised, Django will invoke an error-handling view. The views to use for these
    cases are specified by four variables. The variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handler404`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler500`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler403`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler400`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their default values should suffice for most projects, but further customization
    is possible by assigning values to them. Such values can be set in your root URLconf.
    Setting these variables in any other URLconf will have no effect. Values must
    be callables, or strings representing the full Python import path to the view
    that should be called to handle the error condition at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Including other URLconfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At any point, your `urlpatterns` can include other URLconf modules. This essentially
    roots a set of URLs below other ones. For example, here''s an excerpt of the URLconf
    for the Django website itself. It includes a number of other URLconfs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the regular expressions in this example don''t have a `$` (end-of-string
    match character) but do include a trailing slash. Whenever Django encounters `include()`,
    it chops off whatever part of the URL matched up to that point and sends the remaining
    string to the included URLconf for further processing. Another possibility is
    to include additional URL patterns by using a list of `url()` instances. For example,
    consider this URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `/credit/reports/` URL will be handled by the `credit.views.report()`
    Django view. This can be used to remove redundancy from URLconfs where a single
    pattern prefix is used repeatedly. For example, consider this URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve this by stating the common path prefix only once and grouping
    the suffixes that differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Captured parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An included URLconf receives any captured parameters from parent URLconfs,
    so the following example is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the captured `"username"` variable is passed to the included
    URLconf, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Passing extra options to view functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'URLconfs have a hook that lets you pass extra arguments to your view functions,
    as a Python dictionary. The `django.conf.urls.url()` function can take an optional
    third argument which should be a dictionary of extra keyword arguments to pass
    to the view function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, for a request to `/reviews/2005/`, Django will call `views.year_archive(request,`
    `year='2005',` `foo='bar')`. This technique is used in the syndication framework
    to pass metadata and options to views (see [Chapter 14](ch14.xhtml "Chapter 14. Generating
    Non-HTML Content"), *Generating Non-HTML Content*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dealing with conflicts**'
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to have a URL pattern which captures named keyword arguments,
    and also passes arguments with the same names in its dictionary of extra arguments.
    When this happens, the arguments in the dictionary will be used instead of the
    arguments captured in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Passing extra options to include()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, you can pass extra options to `include()`. When you pass extra options
    to `include()`, each line in the included URLconf will be passed the extra options.
    For example, these two URLconf sets are functionally identical: Set one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Set two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that extra options will always be passed to every line in the included
    URLconf, regardless of whether the line's view actually accepts those options
    as valid. For this reason, this technique is only useful if you're certain that
    every view in the included URLconf accepts the extra options you're passing.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse resolution of URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common need when working on a Django project is the possibility to obtain
    URLs in their final forms either for embedding in generated content (views and
    assets URLs, URLs shown to the user, and so on) or for handling of the navigation
    flow on the server side (redirections, and so on)
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly desirable to avoid hard-coding these URLs (a laborious, non-scalable
    and error-prone strategy) or having to devise ad-hoc mechanisms for generating
    URLs that are parallel to the design described by the URLconf and as such in danger
    of producing stale URLs at some point. In other words, what's needed is a DRY
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Among other advantages it would allow evolution of the URL design without having
    to go all over the project source code to search and replace outdated URLs. The
    piece of information we have available as a starting point to get a URL is an
    identification (for example the name) of the view in charge of handling it, other
    pieces of information that necessarily must participate in the lookup of the right
    URL are the types (positional, keyword) and values of the view arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides a solution such that the URL mapper is the only repository
    of the URL design. You feed it with your URLconf and then it can be used in both
    directions:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a URL requested by the user/browser, it calls the right Django
    view providing any arguments it might need with their values as extracted from
    the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with the identification of the corresponding Django view plus the values
    of arguments that would be passed to it, obtain the associated URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one is the usage we've been discussing in the previous sections. The
    second one is what is known **as reverse resolution of URLs**, **reverse URL matching**,
    **reverse URL lookup**, or simply **URL reversing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django provides tools for performing URL reversing that match the different
    layers where URLs are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In templates: Using the `url` template tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Python code: Using the `django.core.urlresolvers.reverse()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In higher level code related to handling of URLs of Django model instances:
    The `get_absolute_url()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider again this URLconf entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'According to this design, the URL for the archive corresponding to year **nnnn**
    is `/reviews/nnnn/`. You can obtain these in template code by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If, for some reason, it was decided that the URLs where content for yearly review
    archives are published at should be changed then you would only need to change
    the entry in the URLconf. In some scenarios where views are of a generic nature,
    a many-to-one relationship might exist between URLs and views. For these cases
    the view name isn't a good enough identifier for it when comes the time of reversing
    URLs. Read the next section to know about the solution Django provides for this.
  prefs: []
  type: TYPE_NORMAL
- en: Naming URL patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to perform URL reversing, you'll need to use named URL patterns as
    done in the examples above. The string used for the URL name can contain any characters
    you like. You are not restricted to valid Python names. When you name your URL
    patterns, make sure you use names that are unlikely to clash with any other application's
    choice of names. If you call your URL pattern `comment`, and another application
    does the same thing, there's no guarantee which URL will be inserted into your
    template when you use this name. Putting a prefix on your URL names, perhaps derived
    from the application name, will decrease the chances of collision. We recommend
    something like `myapp-comment` instead of `comment`.
  prefs: []
  type: TYPE_NORMAL
- en: URL namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URL namespaces allow you to uniquely reverse named URL patterns even if different
    applications use the same URL names. It's a good practice for third-party apps
    to always use namespaced URLs. Similarly, it also allows you to reverse URLs if
    multiple instances of an application are deployed. In other words, since multiple
    instances of a single application will share named URLs, namespaces provide a
    way to tell these named URLs apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django applications that make proper use of URL namespacing can be deployed
    more than once for a particular site. For example, `django.contrib.admin` has
    an `AdminSite` class which allows you to easily deploy more than once instance
    of the admin. A URL namespace comes in two parts, both of which are strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application namespace**: This describes the name of the application that
    is being deployed. Every instance of a single application will have the same application
    namespace. For example, Django''s admin application has the somewhat predictable
    application namespace of `admin`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Instance namespace**: This identifies a specific instance of an application.
    Instance namespaces should be unique across your entire project. However, an instance
    namespace can be the same as the application namespace. This is used to specify
    a default instance of an application. For example, the default Django admin instance
    has an instance namespace of `admin`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaced URLs are specified using the `:` operator. For example, the main
    index page of the admin application is referenced using "`admin:index`". This
    indicates a namespace of "`admin`", and a named URL of "`index`".
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces can also be nested. The named URL `members:reviews:index` would look
    for a pattern named "`index`" in the namespace "`reviews`" that is itself defined
    within the top-level namespace "`members`".
  prefs: []
  type: TYPE_NORMAL
- en: Reversing namespaced URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When given a namespaced URL (for example "`reviews:index`") to resolve, Django
    splits the fully qualified name into parts and then tries the following lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: First, Django looks for a matching application namespace (in this example, "`reviews`").
    This will yield a list of instances of that application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a current application defined, Django finds and returns the URL
    resolver for that instance. The current application can be specified as an attribute
    on the request. Applications that expect to have multiple deployments should set
    the `current_app` attribute on the request being processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current application can also be specified manually as an argument to the
    `reverse()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no current application. Django looks for a default application instance.
    The default application instance is the instance that has an instance namespace
    matching the application namespace (in this example, an instance of reviews called
    "`reviews`").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no default application instance, Django will pick the last deployed
    instance of the application, whatever its instance name may be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the provided namespace doesn't match an application namespace in step 1,
    Django will attempt a direct lookup of the namespace as an instance namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are nested namespaces, these steps are repeated for each part of the
    namespace until only the view name is unresolved. The view name will then be resolved
    into a URL in the namespace that has been found.
  prefs: []
  type: TYPE_NORMAL
- en: URL namespaces and included URLconfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'URL namespaces of included URLconfs can be specified in two ways. Firstly,
    you can provide the application and instance namespaces as arguments to `include()`
    when you construct your URL patterns. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will include the URLs defined in `reviews.urls` into the application namespace
    `''reviews''`, with the instance namespace `''author-reviews''`. Secondly, you
    can include an object that contains embedded namespace data. If you `include()`
    a list of `url()` instances, the URLs contained in that object will be added to
    the global namespace. However, you can also `include()` a 3-tuple containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will include the nominated URL patterns into the given application and
    instance namespace. For example, the Django admin is deployed as instances of
    `AdminSite`. `AdminSite` objects have a `urls` attribute: A 3-tuple that contains
    all the patterns in the corresponding admin site, plus the application namespace
    "`admin`", and the name of the admin instance. It is this `urls` attribute that
    you `include()` into your projects `urlpatterns` when you deploy an admin instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to pass a tuple to `include()`. If you simply pass three arguments:
    `include(reviews_patterns`,`''reviews''`,`''author-reviews'')`, Django won''t
    throw an error but due to the signature of `include()`, `''reviews''` will be
    the instance namespace and `''author-reviews''` will be the application namespace
    instead of vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has provided many advanced tips and tricks for views and URLconfs.
    Next, in [Chapter 8](ch08.xhtml "Chapter 8. Advanced Templates"), *Advanced Templates*,
    we'll give this advanced treatment to Django's template system.
  prefs: []
  type: TYPE_NORMAL
