- en: Chapter 3. Designing Your Application with Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is perhaps best known as a cross-platform user interface toolkit, and only
    in the last few years has Qt Creator really evolved to be a full software development
    environment. Even in its early releases, however, Qt had an excellent facility
    for building user interfaces with Qt Designer, now part of Qt Creator. More recently,
    the developers building Qt have added Qt Quick as a second option for user interface
    development. Qt Quick extends the Qt libraries and the Qt Designer capabilities
    of Qt Creator to build fluid interfaces for touchscreens and set-top boxes and
    to facilitate the declarative nature of Qt Quick and **Qt Meta-object Language**
    (**QML**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to create user interfaces using Qt Designer,
    the user interface builder in Qt Creator. We begin by introducing key concepts
    to understanding the Qt framework: **signals** and **slots**. Next, we revisit
    using Qt Designer to create application forms, the basis of your user interface
    when using Qt Widgets. We touch on how to add resources and access them in your
    application, an important facet of user interface design. Then, we return to the
    code for a bit and build on the fundamentals of QML you learned in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Qt Creator"), *Getting Started with Qt Creator*.
    At the end of this chapter, you''ll be well equipped to decide whether your application
    should be written using Qt GUI or Qt Quick, and to build your application with
    the help of the documentation that accompanies Qt Creator.'
  prefs: []
  type: TYPE_NORMAL
- en: Code interlude – signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software systems, there is often the need to couple different objects. Ideally,
    this coupling should be loose, that is, not dependent on the system's compile-time
    configuration. This is especially obvious when you consider user interfaces; for
    example, a button press may adjust the contents of a text widget or cause something
    to appear or disappear. Many systems use events for this purpose; components offering
    data encapsulate that data in an event, and an event loop (or, more recently,
    an event listener) catches the event and performs some action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt offers a better way: signals and slots. Like an event, the sending component
    generates a signal—in Qt parlance, the object emits a signal—which recipient objects
    may receive in a slot for the purpose. Qt objects may emit more than one signal,
    and signals may carry arguments; in addition, multiple Qt objects can have slots
    connected to the same signal, making it easy to arrange one-to-many notifications.
    Equally important, if no object is interested in a signal, it can be safely ignored,
    and no slots connected to the signal. Any object that inherits from `QObject`,
    Qt''s base class for objects, can emit signals or provide slots for connection
    to signals. Under the hood, Qt provides extensions to C++ syntax for declaring
    signals and slots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example will help make this clear. The classic example you find in
    the Qt documentation is an excellent one, and we''ll use it again it here, with
    some extension''s. Imagine you have the need for a counter, that is, a container
    that holds an integer. In C++, you might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Counter` class has a single private member, `m_value`, bearing its value.
    Clients can invoke the value to obtain the counter's value, or set its value by
    invoking `setValue` with a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt, using signals and slots, we write the class this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `Counter` class inherits from `QObject`, the base class for all Qt objects.
    All `QObject` subclasses must include the declaration `Q_OBJECT` as the first
    element of their definition; this macro expands to Qt code implementing the subclass-specific
    glue necessary for the Qt object and signal-slot mechanism. The constructor remains
    the same, initializing our private member to zero. Similarly, the accessor method
    value remains the same, returning the current value for the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object''s slots must be public, and are declared using the Qt extension
    to C++ public slots. This code defines three slots: a `setValue` slot, which accepts
    a new value for the counter, and the `increment` and `decrement` slots, which
    increment and decrement the value of the counter. Slots may take arguments, but
    do not return them; the communication between a signal and its slots is one way,
    initiating with the signal and terminating with the slot(s) connected to the signal.'
  prefs: []
  type: TYPE_NORMAL
- en: The counter offers a single signal. Like slots, signals are also declared using
    a Qt extension to C++, `signals`. In the example above, a `Counter` object emits
    the signal `valueChanged` with a single argument, which is the new value of the
    counter. A signal is a function signature, not a method; Qt's extensions to C++
    use the type signature of signals and slots to ensure type safety between signal-slot
    connections, a key advantage signals and slots have over other decoupled messaging
    schemes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the developers, it''s our responsibility to implement each slot in our class
    with whatever application logic makes sense. The `Counter` class''s slots look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the implementation of the `setValue` slot as a method, which is what
    all slots are at their heart. The `setValue` slot takes a new value and assigns
    the new value to the `Counter` class's private member variable if they aren't
    the same. Then, the signal emits the `valueChanged` signal, using the Qt extension
    `emit`, which triggers an invocation to the slots connected to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a common pattern for signals that handle object properties: testing
    the property to be set for equality with the new value, and only assigning and
    emitting a signal if the values are unequal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a button, say `QPushButton`, we could connect its clicked signal
    to the `increment` or `decrement` slot, so that a click on the button incremented
    or decremented the counter. I''d do that using the `QObject::connect` method,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We first create the `QPushButton` and `Counter` objects. The `QPushButton` constructor
    takes a string, the label for the button, which we denote to be the string `Increment`
    or its localized counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we pass this to each constructor? Qt provides a parent-child memory management
    between QObjects and their descendants, easing clean-up when you're done using
    an object. When you free an object, Qt also frees any children of the parent object,
    so you don't have to. The parent-child relationship is set at construction time;
    I'm signaling to the constructors that when the object invoking |this code is
    freed, the push button and counter may be freed as well. (Of course, the invoking
    method must also be a subclass of `QObject` for this to work.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, I call `QObject::connect`, passing first the source object and the signal
    to be connected, and then the receiver object and the slot to which the signal
    should be sent. The types of the signal and the slot must match, and the signals
    and slots must be wrapped in the `SIGNAL` and `SLOT` macros, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals can also be connected to signals, and when that happens, the signals
    are chained and trigger any slots connected to the downstream signals. For example,
    I could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This connects the counter `b` with the counter `a`, so that any change in value
    to the counter `a` also changes the value of the counter `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots are used throughout Qt, both for user interface elements and
    to handle asynchronous operations, such as the presence of data on network sockets
    and HTTP transaction results. Under the hood, signals and slots are very efficient,
    boiling down to function dispatch operations, so you shouldn't hesitate to use
    the abstraction in your own designs. Qt provides a special build tool, the meta-object
    compiler, which compiles the extensions to C++ that signals and slots require
    and generates the additional code necessary to implement the mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Creating forms in Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple calculator application using Qt Designer and two forms:
    one form taking the arguments for an arithmetic operation, and a second dialog
    form for presenting the results. I''ll do this twice in this chapter, first showing
    you how to do this using Qt GUI, and again using Qt Quick. The example is contrived,
    but will show you how to create multiple user interface forms in both environments,
    and give you practice in working with signals and slots.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started with Qt Creator"), *Getting
    Started with Qt Creator*, you learned the basic elements of the Qt GUI Designer,
    including the palette of widgets you can use, the central edit pane, the tree
    of objects, and the property view. The following screenshot shows the Qt Designer
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the main form](img/2319OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Qt Creator's Designer for Qt GUI applications
  prefs: []
  type: TYPE_NORMAL
- en: 'Working from left to right, the parts of the screen you see are:'
  prefs: []
  type: TYPE_NORMAL
- en: The views selector, presently indicating that the Qt Designer view is active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The palette of possible widgets you can lay out on your form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form editor, above the connection editor, which lets you wire signals and
    slots between widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object tree, indicating all of the objects that have been laid out on the
    form and showing their parent-child relationships through the use of nested lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the object tree is the property editor, where you can edit the compile-time
    properties of any item you select on the form editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new Qt GUI project (select **Qt Gui Application**
    from the **New File or Projects…** dialog) naming the project `QtGuiCalculator`,
    and then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Forms** folder of the project, double-click on the `mainwindow.ui`
    file. The designer will open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out **Vertical Layout** from the palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the layout and choose **Lay out**, then choose **Adjust Size**.
    The layout will shrink to a point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two **Line Edit** widgets and drop them on the vertical layout in the object
    viewer (the far-right pane). You'll see the vertical layout grow to accept each
    of the line editors. You should now have something that looks like the following
    screenshot:![Creating the main form](img/2319OS_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your layout after the first two text fields
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Horizontal Layout** and drop it on the vertical layout in the object
    viewer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag-and-drop four **Push Button** widgets on the horizontal layout you just
    added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the containing window so that the entire layout is shown in the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the buttons `plusButton`, `minusButton`, `timesButton`, and `divideButton`
    using the property browser in the lower-right corner. As you do so, scroll down
    to the **text** property (under **QAbstractButton**) and give each button a logical
    label like `+`, `-`, `*`, and `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the top input line and name it `argument1Input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the bottom input line and name it `argument2Input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next screenshot shows what you should see in the Qt Designer form editor
    pane so far. You can also manually arrange the buttons by breaking the layout
    and positioning them using the mouse, but that typically makes your layout less
    robust to window resizing, and is generally not a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the main form](img/2319OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our calculator user interface
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, this is pretty straightforward. We used a vertical layout and a horizontal
    layout to lay out the various controls; this takes advantage of Qt''s dynamic
    constraints on widget layout and sizing. All widgets have a minimum and a maximum
    size, which are used by layouts to determine the actual size a widget consumes.
    Some widgets are elastic; that is, they stretch to fill their contents. When specifying
    the actual size of a widget, you can specify that it takes one of the following
    values in each of the x and y axes:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum size of the widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum size of the widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fixed size between its minimum and maximum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expanding size, expanding to fit the contents of the widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt provides four kinds of layouts, which you can mix and match as we just did.
    You've encountered the vertical and horizontal layouts; there's also a grid layout,
    which lets you organize things in an *m* × *n* grid, and a form layout, which
    organizes widgets in a manner similar to how the native platform enumerates fields
    on a form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, our layout''s a little bunched up. Let''s add some spacers to better
    fill the space in the window, and also add a button for an about box:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag **Vertical Spacer** and drop it between the input lines, and a second vertical
    spacer between the horizontal layout containing the row of buttons and the input
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Tool Button** widget to the vertical layout, and add a spacer between
    the bottom line and the push button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the last push button `aboutButton` and give it the text `About`. We'll
    add an icon later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the application as we''ve constructed it in
    the designer if you press the **Run** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the main form](img/2319OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our application's main window
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make our result dialog. Right-click on the project and choose **Add
    New…**, then:'
  prefs: []
  type: TYPE_NORMAL
- en: In the dialog that appears, choose **Qt** on the left, and then **Qt Designer
    Form** in the middle. Click on **Choose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a dialog style for your dialog; choose **Dialog with Buttons Bottom**
    and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `resultdialog.ui` and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog that appears, drag out **Form Layout**. Right-click on it and
    choose **Lay out** and **Adjust size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Label** widget to the form layout. Change its text to read `Result`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out another label, and name it `result`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now may be a good time for you to experiment with layouts and spacers, and style
    the dialog any way you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Using application resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s add an icon to the application for the **About** button. You can
    draw one, or go to a website such as The *Noun Project* ([http://bit.ly/16n9bOk](http://bit.ly/16n9bOk))
    for a suitable icon. Icons can be PNG, JPEG, or other formats; a good choice is
    SVG, because SVG images are vector based and scale correctly to different sizes.
    Put the resource file in your project directory, and then:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the **Edit** view in Qt Creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the solution and click on **Add New…**; then, choose **Qt** and
    **Qt Resource File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `resources.qrc` isn't already open in the editor, double-click on it in the
    solution pane. The resource file editor will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**, choose **Add prefix**, and prefix `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add** again, select **Add Files**, and choose your icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Icons are loaded in the read-only segment of your application through the Qt
    resource compiler. You can access them anywhere you''d access a file by prefixing
    the path and name of the resource with a colon. For example, we might place a
    text file in our application resources and then open the file for reading, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Application resources are suitable for text and small media files such as icons
    or images. You should avoid using them for larger items like movies and large
    sounds, however, because they'll needlessly bloat the size of your application
    binary. For those purposes, it's better to package media files with your application
    and load them directly from the disk.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll use the resource you added, when we add our about
    box to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating forms, message boxes, and dialogs in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Qt Designer generates an XML-based layout file (which ends in `.ui`) for
    each form you create in the designer. At compile time, Qt Creator compiles the
    layout into a header file that constructs the components for your user interface
    layout. The pattern typically used by Qt applications is to construct a private
    layout class that is instantiated by a main window or dialog''s constructor, and
    then the user interface is instantiated. Here''s how it works for the main window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Ui::MainWindow` class is automatically constructed by the Qt Designer;
    by including its declaration in `mainwindow.cpp`, we create an instance of it
    and assign that instance to the `ui` field. Once initialized, we call its `setupUi`
    function, which creates the entire user interface you sketched out in Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controls we laid out in Qt Designer are accessible as field names. For
    example, we can modify `mainwindow.cpp` to invoke an about box by adding a slot
    to `mainwindow.h` to handle the case when you click on the **About** button, and
    then add the code to invoke an about box in the implementation of the slot. To
    do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `public slots` declaration to `mainwindow.h`, along with a slot named
    `aboutClicked`. It should now read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation of the `aboutClicked` slot to `mainwindow.cpp`. This
    code constructs a `QMessageBox` object on the stack, and sets its icon to the
    icon you added in your resources earlier, the text of the dialog to `"Lorem ipsum"`,
    and the title of the message box to `"About"`. The `exec` method of the `QMessageBox`
    invocation opens the message box and blocks the application flow until you dismiss
    the message box. It should read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of `mainwindow.cpp`, add an `include` statement for the `QMessageBox`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainWindow` constructor, connect the signal from the about button to
    the slot you just created. Your constructor should now read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we build the application, we now have a fully functioning about box, including
    the application icon you chose. The `connect` call is just like the previous signal-slot
    connections we've seen; it connects the `clicked` signal of `aboutButton` to your
    `aboutClicked` slot in the main window UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word on naming signals and slots before we continue: a signal is typically
    named a verb in its past tense, denoting the semantics of the event that just
    occurred that it''s trying to signal. A slot should somehow match those semantics,
    preferably including more detail as to how the signal is being handled. So Qt
    names the button''s `clicked` signal logically, and I expand on this by giving
    a slot named `aboutClicked`. Of course, you can name your signals and slots whatever
    you like, but this is a good practice to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we wire up the other buttons and implement our calculator logic, we
    need to set up the class for our `results` dialog. We''ll follow the pattern of
    the `MainWindow` class, creating a private `ui` member that contains an instance
    of the compile-time generated object that constructs the UI for the results dialog.
    You can create the `ResultDialog` class using the **New File** wizard available
    by right-clicking on the project; choose **Qt Designer Form Class** and name it
    `ResultDialog`. The class itself should inherit from `QDialog`. The header file
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is forward-declare the `Dialog` class created
    by the Qt Designer; we do this in the namespace `Ui`, so it doesn't conflict with
    any other code in my application. Then, we need to declare a pointer to an instance
    of that class as a private member variable; we name this pointer `ui`, as was
    done for the `MainWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can guess what our `ResultDialog` implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At construction time, it makes an instance of our `Ui:Dialog` class, and then
    invokes its `setupUi` method to create an instance of the user interface at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the Qt GUI application logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application logic for the calculator is simple: we add a property setter
    to the `ResultDialog` implementation that lets us set the `result` field of the
    dialog, and then wire up some arithmetic, signals, and slots in `MainWindow` to
    do the actual computation and show the dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the change to `ResultDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method takes a float, the value to show in the dialog, and formats the
    result as a string using Qt's default formatting. Qt is fully internationalized;
    if you do this in English-speaking locales, it will use a decimal point, while
    if you do it with a locale set to a region where a comma is used as the decimal
    separator, it will use a comma instead. The `number` method is a handy one, with
    overloads taking doubles and floats, as well as integers, and arguments to indicate
    the precision and exponentiation of the returned string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the modified `MainWindow` class. First, the revised class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the base class `QMainWindow`, I now include `QPair`, a simple
    Qt template that lets us pass pairs of values. We'll use the `QPair` template,
    type-defined as `Arguments`, to pass around the pair of arguments for an arithmetic
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'I add a signal, computed, which the class triggers any time it performs an
    arithmetic operation. I also add slots for each of the arithmetic button clicks:
    `plusClicked`, `minusClicked`, `timesClicked`, and `dividedClicked`. Finally,
    I add a signal `showResult`, which shows the result when a computation occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of `MainWindow` now needs to do a bunch of signal-slot wiring
    for all of our buttons, signals, and slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After connecting the about button to the slot that shows the about dialog, I
    next connect the computed signal from `MainWindow` to its `showResult` slot. Note
    that this signal/slot carries an argument, the value to show. The remaining four
    connections connect each of the operation buttons with the code to perform a specific
    arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `showResult` slot creates a new `ResultDialog` object if we don''t already
    have one, sets its result to the incoming value, and invokes the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `arguments` method is a helper method used by each of the arithmetic functions,
    it fetches the values from each of the input lines, converts them from strings
    to floating-point numbers, and does a little bit of error checking to ensure that
    the entries are valid floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QString` method `toFloat` does just that: it converts a string to a floating-point
    number, returns the number, and sets the Boolean passed in to `true` if the conversion
    was successful, and `false` otherwise. The code does this for both argument input
    lines, then checks the resulting Boolean values, and reports an error if either
    argument is malformed, before returning a QPair of the arguments to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code actually performs the arithmetic, signaling that a computation
    has occurred when the operation is complete. For example, take the `plusClicked`
    slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This obtains the arguments from the input lines using the `arguments` function,
    computes the sum, and then emits the computed signal with the summed value. Because
    we connected the computed signal to the `showResults` slot, this triggers a call
    to `showResults`, which creates the `ResultDialog` object if necessary, and shows
    the dialog with the computed result. The `minusClicked`, `timesClicked`, and `divideClicked`
    methods are all similar.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about Qt GUI widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are whole books written about programming with the Qt GUI widget set:
    it''s a very rich widget set that includes just about everything you''d need to
    build the average Macintosh, Windows, or Linux application, and has the advantage
    that the UI controls are familiar to most computer users. To explore further,
    see the Qt documentation at [http://bit.ly/17stfw3](http://bit.ly/17stfw3).'
  prefs: []
  type: TYPE_NORMAL
- en: Code interlude – Qt Quick and QML syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the programming you do at the lowest level is imperative: you describe
    how an algorithm should work ("take this value and square it", "search for the
    first occurrence of this string and replace it", "format this data this way",
    and so forth). With Qt Quick, your programming is largely declarative: instead
    of saying *how*, you say *what*. For example, in C++ with Qt, we might write code
    like this to draw a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a 16 x 16 pixel rectangle, allocates a `QPainter` object
    that does the drawing, tells the painter that its brush should be colored blue,
    and then tells the painter to draw the rectangle. In QML, I''d simply write the
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is obvious: I am just saying that there is a blue rectangle
    that''s 16 x 16 pixels. It''s up to the Qt Quick runtime to determine how to draw
    the rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick''s underlying language is QML. It is based heavily on JavaScript,
    and in fact, most things that you can write in JavaScript you can also express
    in QML. Expression syntax is essentially unchanged: assignments, arithmetic, and
    so forth are all the same, and the name-value system is functionally the same,
    although object frames may be preceded by a type declaration (as you see with
    the `Rectangle` example that I just showed you).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key exception to the "what works in JavaScript works in QML" rule is the lack
    of a document object model (DOM) and things like the document root for global
    variables because there's no root context or DOM on which other things hang. If
    you're porting a web application to QML, be prepared to refactor those parts of
    your application's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in QML must be parented in the fashion of a tree; each QML file must
    contain an encapsulating object, and then can have child objects that have child
    objects. However, there must be a single root for the hierarchy at the top of
    the file. Often, this root is a rectangle, which draws a base rectangle on which
    its children are presented, or an item, which is a container for a more complex
    user interface element that doesn't actually draw anything. Each item may have
    a name, which is stored in its `id` property.
  prefs: []
  type: TYPE_NORMAL
- en: Most visible QML items can have states; that is, a collection of properties
    that apply when a particular state is active. This lets you do things such as
    declare the difference between a button's dormant and pressed state; pressing
    the button just toggles between the states, and the button's color, shadow, and
    so on can all change with you, and there is no need to change each individual
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key concept in QML that''s not present in JavaScript is that of **binding**:
    if two QML object properties share the same value, changing one changes the other.
    Binding couples values with notifications about values is similar to how references
    work in C++, or how pass-by reference works in other languages, but this happens
    in QML at the level of the variable name being referenced. This is very handy
    in coding things such as animations, because you can use the value of one object
    as the value for another object, and when the underlying value changes in one
    place, both objects are updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'QML files can depend on each other, or include files of JavaScript for business
    logic. You''ve already seen one example of this at the top of every QML file:
    the `import` directive instructs the runtime to include the indicated file and
    version, so when I write `import QtQuick 2.0`, the runtime finds the declaration
    of the QtQuick module Version 2.0 and includes its symbols when parsing the file.
    This is how you can encapsulate functionality. QML files in your project are included
    by default, while you can also include JavaScript files and assign them to a specific
    JavaScript variable. For example, we could have a JavaScript file `calculatorLogic.js`
    that implements all of the functionality of my calculator, and in the QML, write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The initial import loads JavaScript and assigns its value to the QML object
    `CalculatorLogic`; I can then dispatch methods and access properties of that object
    as if it were any other QML object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick declares a number of basic datatypes; these match closely with the
    datatypes you find in Qt when writing C++ code, although the syntax can differ.
    Some of the most important types you''ll encounter are:'
  prefs: []
  type: TYPE_NORMAL
- en: A point with the `x` and `y` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rectangle with the `x`, `y`, `width`, and `height` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A size with the `width` and `height` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A color, which is a quoted string in HTML RGB notation or a named color from
    Qt's lexicon of colors (most colors you can think of have names in QML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2D, 3D, or 4D vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types including Boolean values, strings, integers, and floating-point
    numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a lot of visible types for user interface construction; in this
    chapter, there's only room to touch on a few. For a detailed list of all QML types
    and the documentation about those types, see [http://bit.ly/17stfw3](http://bit.ly/17stfw3).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Qt Quick applications in Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started with Qt Creator"), *Getting
    Started with Qt Creator*, you gained basic familiarity with the Qt Designer for
    Qt Quick applications. Let''s take another look before we recreate our calculator
    app in QML. The next screenshot shows the Qt Designer for the Qt Quick window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Qt Quick applications in Qt Designer](img/2319OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Qt Designer for Qt Quick
  prefs: []
  type: TYPE_NORMAL
- en: 'Working from the left again, we have the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The view selector, showing that the Qt Designer view is active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object hierarchy for the file being edited, showing the parent-child relationship
    between visible items in that file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the object hierarchy is a palette of the items you can drag out onto the
    QML editor pane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to the object hierarchy is a summary of the states for the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the summary of states is the object editor for the QML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there's a property editor that lets you adjust the properties of the
    currently selected QML item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frankly, I find it easier to just write QML than to use the designer. The syntax
    takes a little getting used to, but what the designer is good for is previewing
    the QML you've written by hand and making minor adjustments to its layout.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of layout, before we see our sample code in detail, it's worth noting
    that QML has a rich dynamic layout system. Visible items have an `anchor` property,
    and you can anchor an item's sides against that of its neighbors or the parent
    view. You saw this briefly in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Qt Creator"), *Getting Started with Qt Creator*, where we made `MouseArea`
    as big as its parent. We'll also use that to control the layout of the calculator
    argument input lines and operator buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Start making our sample code now by choosing **New File or Project…** from the
    **File** menu, and walk through the wizard to create a Qt Quick 2.0 application.
    Name your application `QtQuickCalculator`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our calculator has a button for each operation. While we could make each button
    a separate rectangle and `MouseArea`, it's far easier to make a single QML button
    that encapsulates the behavior of a button, including the change in appearance
    when you press on it, the placement of the button label, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new QML file by right-clicking on the project and choosing **Add New…**,
    then from the Qt items, choose **QML File (Qt Quick 2)**. The button is a rectangle
    that contains a second rectangle, a `Text` label for the button, and a `MouseArea`
    region that handles button clicks. Name the file `Button.qml`, and edit it so
    that it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Working from the top of the file code:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the scope of this file, the button's ID is simply `button`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's 64 pixels in both width and height.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button has a single property configurable by its clients, the `operation`
    property. That property is actually an alias, meaning it's automatically setting
    the value of the `buttonText.text` property instead of being a separate field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button emits a single signal, the `clicked` signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button's color is green.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a rectangle that fills the button that is colored black, but has opacity
    of zero, meaning in normal use it's not visible, it's transparent. As the button
    is pressed, I adjust the opacity of this rectangle, to shade the button darker
    when it's being pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `text` label of the button is `16` points in size, colored white, and centered
    in the button itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MouseArea` region that accepts clicks for the button is the same size as
    the button and emits the clicked signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The button has two states: the default state, and a second state pressed that
    occurs when the `mouseArea.pressed` property is `true` (because you are pressing
    the mouse button in the mouse area). When the state is pressed, I request a single
    `PropertyChange` event, changing the rectangle''s opacity a bit to give a shadow
    over the button, darkening it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can actually see the two states of the button if you enter the Qt Designer
    (see the following screenshot). A state is just a name, a `when` clause indicating
    when the state is active, and a collection of `PropertyChanges` indicating what
    properties should change when the state is active. All visible QML items have
    a `state` property, which is just the name of the currently active state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a reusable button](img/2319OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The states of the button
  prefs: []
  type: TYPE_NORMAL
- en: Note that QML uses signals and slots similar to Qt in C++, but there's no `emit`
    keyword. Instead, you declare the signal directly using the `signal` keyword and
    the name of the signal, and then you invoke the signal as if it were a function
    call. For each QML item's signal, the slot is named `on` followed by the signal
    name; for example, `onClicked`, `onPressed`, and so on. Thus, when we use the
    button, we write an `onClicked` handler for the `clicked` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The calculator's main view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go back to the editor and edit `main.qml` directly. We''re going to declare
    our input lines, result line, and four operation buttons directly in code; you
    can do much of the same with the designer if you''d prefer, and then edit the
    code to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The view has two `TextInput` lines, a read-only `text` result line, and then
    the `operation` buttons, wrapped in a `Row` item to give them a horizontal layout.
    The base view for the calculator is `grey`, and is in a window 360 × 200 pixels.
    The controls are positioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first input line is anchored to the top left of the parent window, with
    margins of 10 pixels. It's 160 pixels long and the default height for an 18-point
    `TextInput` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second input line is anchored to the right side of the parent, with a margin
    of 10 pixels at the top and right. It's also 160 pixels long, and the default
    height of an 18-point `TextInput` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result input line's top is anchored to the bottom of the input line, and
    to the left of the parent rectangle. It also has 10 pixels of margins on each
    side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buttons are spaced 20 pixels apart in a `Row` item that's anchored to the
    bottom of the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These anchors let the view reflow nicely if you resize the application window;
    the input lines spread across the width of the window, and the button bar on the
    bottom moves down as the window enlarges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the buttons has a `click` slot that obtains the floating-point interpretation
    of each of the input lines and performs the appropriate arithmetic operation.
    They''re each instances of `Button`, the QML class I showed you in the previous
    section. Note the use of the JavaScript function `parseFloat` in the `onClicked`
    handlers: as you''d expect from what I mentioned before, there''s support for
    the functions in the JavaScript runtime in QML, so we can just invoke JavaScript
    functions directly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the completed calculator application. Note,
    when running the app, if you mouse over a button and press down, you''ll see the
    shading darken (this isn''t shown in the screenshot). This reflects the two states
    in the button that I showed you in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The calculator''s main view](img/2319OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The completed Qt Quick calculator application
  prefs: []
  type: TYPE_NORMAL
- en: Learning more about Qt Quick and QML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Quick was designed to create fluid applications that don't have a lot of
    deep widget complexity. Media hubs, photo viewers, phone dialers, web browsers,
    and other sorts of applications that don't need to match the look and feel of
    the host platform (or are on embedded systems where the host platform is all written
    in Qt Quick) are good examples of applications suiting the Qt Quick paradigm.
    For more information about Qt Quick with a plethora of examples that show you
    the breadth and power of the platform, see [http://bit.ly/16ULQ4V](http://bit.ly/16ULQ4V).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt comes with not one, but two complementary GUI toolkits: Qt GUI, which takes
    a traditional widget-based approach to GUI development, and Qt Quick, which provides
    a declarative approach better-suited for platform-agnostic user interfaces for
    media boxes, some cell phone applications, automobile dashboards, and other embedded
    environments. For both, Qt offers Qt Designer, a drag-and-drop environment that
    lets you construct, configure, and preview your user interface as you build your
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Core to Qt is the notion of signals and slots, Qt's answer to callbacks and
    events for handling the late-binding required of today's GUI applications. Qt
    objects can emit signals, which are type-safe function declarations, and other
    objects can connect to those signals, triggering method calls when the signals
    are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you''ll take a break from learning about Qt Creator and
    graphical user interface development to focus on one key aspect of application
    development: localization. I''ll show you how to use Qt Linguist and Qt''s localization
    functions to localize your application.'
  prefs: []
  type: TYPE_NORMAL
