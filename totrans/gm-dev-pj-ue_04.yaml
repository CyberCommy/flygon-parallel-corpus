- en: 4\. Player Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will tackle the subject of player input. We will learn how to associate
    a keypress or touch input from a touch-enabled device with an in-game action such
    as jumping or moving.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know about `Action Mappings` and `Axis
    Mappings`, how to create and modify them, how to listen to each of those mappings,
    how to execute in-game actions when they're pressed and released, and how to preview
    your game as if you were playing on a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created our C++ class that inherits from the `Character`
    class and added all the necessary `Actor` components to be able to see the game
    from that character's perspective, as well as being able to see the character
    itself. We then created a `Blueprint` class that inherits from that C++ class,
    in order to visually set up all its necessary components. We also learned briefly
    about Action and Axis Mappings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be going more in-depth on these topics, as well as
    covering their C++ usage. We will learn about how player input works in UE4, how
    the engine handles input events (*key presses and releases*), and how we can use
    them to control logic in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start this chapter by getting to know how UE4 abstracts the keys pressed
    by the player to make it easier for you to be notified of those events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be using an alternative version of the `Character`
    blueprint we created, called `BP_MyTPC`, in the previous chapter. This chapter's
    version will have the default UE4 Mannequin mesh and not one from Mixamo.
  prefs: []
  type: TYPE_NORMAL
- en: Input Actions and Axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Player input is the thing that distinguishes video games from other entertainment
    media: the fact that they''re interactive. For a video game to be interactive,
    it must take into account the player''s input. Many games do this by allowing
    the player to control a virtual character that acts upon the virtual world it''s
    in, depending on the keys and buttons that the player presses, which is exactly
    what we''ll be doing in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Most game development tools nowadays allow you to abstract keypresses into Actions
    and Axes, which allow you to associate a name (for example, *Jump*) with several
    different player inputs (pressing a button, flicking a thumbstick, and so on).
    The difference between Actions and Axes is that Actions are used for binary inputs
    (inputs that can either be pressed or released, like the keys on the keyboard),
    while Axes are used for inputs that are scalar or continuous (that is, that can
    have a range of values, like thumbsticks, which can go from `–1` to `1` on both
    the *x* and *y* axes).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you're making a racing game where the further you pull down
    the gamepad's right trigger button, the more the car accelerates, that would be
    an `Axis`, because its value can range from `0` to `1`. However, if you wanted
    to allow the player to pause the game, that would be an Action, because it only
    requires knowing whether or not the player has pressed a certain key.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it's not a very good idea to have the player character jump when the
    player presses the *Spacebar* key explicitly, but instead to have the player jump
    when the *Jump* action is pressed. This *Jump* action can then have its associated
    keys edited elsewhere so that both developers and players can easily change which
    key causes the player character to jump. This is how UE4 allows you to specify
    player input events (although you can also listen to explicit keypresses as well,
    this is usually not the best way to go).
  prefs: []
  type: TYPE_NORMAL
- en: Open your UE4 project and go to the `Project Settings` window. You can do this
    by either clicking `Edit` in the top-left corner of the editor and then selecting
    `Project Settings…`, or by clicking `Settings` in the editor `Toolbar` and then
    selecting `Project Settings…`
  prefs: []
  type: TYPE_NORMAL
- en: This window will allow you to modify several settings related to your project,
    in a wide variety of categories. If you scroll down the left edge of `Project
    Settings`, you should find the `Input` option under the `Engine` category, which
    will take you to your project's input settings. Click this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you do, you should see the input settings at the right edge of the window,
    where you''ll be able to access your project''s `Action Mappings` and `Axis Mappings`,
    among other things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The Action and Axis Mappings available in the Input settings
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: The Action and Axis Mappings available in the Input settings window'
  prefs: []
  type: TYPE_NORMAL
- en: The `Action Mappings` property allows you to specify a list of actions in your
    project (for example, the *Jump* action) and their corresponding keys (for example,
    the *Spacebar* key).
  prefs: []
  type: TYPE_NORMAL
- en: '`Axis Mappings` allows you to do the same thing, but for keys that do not have
    a binary value (either pressed or released) but instead have a continuous value,
    like the thumbsticks on a controller whose values can go from `–1` to `1` on the
    *x* and *y* axes, or the trigger buttons on a controller whose values can go from
    `0` to `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider an Xbox One controller, which can be broken down into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Left analog stick`, usually used for controlling movement in games'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dpad`, which can be used for controlling movement, as well as having a variety
    of other uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Right analog stick`, usually used for controlling the camera and view perspective'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Face buttons (X, Y, A, and B)`, which can have various uses depending on the
    game, but usually allow the player to perform actions in the game world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bumpers and Triggers (LB, RB, LT, and RT)`, which can be used for actions
    such as aiming and shooting or accelerating and braking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also set up binary keys as axes if you want to; for instance, set up
    the player character's movement for both a gamepad thumbstick (which is a continuous
    key whose value goes from `–1` to `1`) and two binary keys on the keyboard (*W*
    and *S*).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be taking a look at how to do this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When we generated the `Third Person` template project back in *Chapter 1*, *Unreal
    Engine Introduction*, it came with some inputs already configured, which were
    *W*, *A*, *S*, and *D* keys, as well as the `left thumbstick` for movement and
    the `Space Bar` key and `gamepad bottom face` button for jumping.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add new `Action` and `Axis Mappings` in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Creating the Jump Action and Movement Axes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll be adding a new `Action Mapping` for the *Jump* action
    and a couple of new `Axis Mappings` for the *Movement* action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Input Settings` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press the `+` icon to the right of the `Action Mappings` property to create
    a new `Action Mapping`:![Figure 4.2: Adding a new Action Mapping'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: Adding a new Action Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you do so, you should see a new `Action Mapping` called `NewActionMapping_0`
    mapped to the `None` key (*meaning it''s not mapped to any key*):![Figure 4.3:
    The default settings of a new Action Mapping'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: The default settings of a new Action Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Change the name of this mapping to `Jump` and the key associated with it to
    the `Spacebar` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To change the key mapped to this action, you can click the drop-down property
    currently set to the `None` key, type `Space Bar`, and select the first option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The key drop-down menu (top) where the Space'
  prefs: []
  type: TYPE_NORMAL
- en: Bar key is being selected (bottom)
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: The key drop-down menu (top) where the Space Bar key is being selected
    (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify whether or not you want this action to be executed when the
    player presses the specified key while holding one of the modifier keys – `Shift`,
    `Ctrl`, `Alt`, or `Cmd`, by checking each of their appropriate checkboxes. You
    can also remove this key from this `Action Mapping` by clicking the `X` icon:![Figure
    4.5: The key drop-down menu and the options to specify modifier keys'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: and removing this key from this Action Mapping
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: The key drop-down menu and the options to specify modifier keys
    and removing this key from this Action Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new key to an `Action Mapping`, you can simply click the `+` icon
    next to the name of that `Action Mapping`, and to remove an `Action Mapping` altogether,
    you can click the `x` icon next to it:![Figure 4.6: The name of the Action Mapping,
    with the + and x icons next to it'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: The name of the Action Mapping, with the + and x icons next to
    it'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use a controller button to map to this `Action Mapping`.
  prefs: []
  type: TYPE_NORMAL
- en: Because most gamepads have the same keys in very similar places, UE4 abstracts
    most of their keys to generic terms using the `Gamepad` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new key to this `Action Mapping` and set that new key to be the `Gamepad
    Face Button Bottom` key. If you''re using an Xbox controller, this will be the
    `A` button, and if you''re using a PlayStation controller, this will be the `X` button:![Figure
    4.7: The Gamepad Face Button Bottom key added to the Jump Action Mapping'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: The Gamepad Face Button Bottom key added to the Jump Action Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up our `Jump` `Action Mapping`, let's set up our `Movement
    Axis Mapping`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `+` icon next to the `Axis Mappings` property to add a new `Axis
    Mapping`. This new `Axis Mapping` will be used to move the character left and
    right. Name it `MoveRight` and assign to it the `Gamepad Left Thumbstick X-Axis`
    key, so that the player can use the *x* axis of the left thumbstick to move the
    character left and right:![Figure 4.8: The MoveRight Axis Mapping with the Gamepad
    Left'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thumbstick X-Axis key associated with it
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: The MoveRight Axis Mapping with the Gamepad Left Thumbstick X-Axis
    key associated with it'
  prefs: []
  type: TYPE_NORMAL
- en: If you look to the right of the key we assigned, instead of the modifier keys,
    you should see the `Scale` property of that key. This property will allow you
    to invert an axis so that the player moves left when the player tilts the thumbstick
    to the right and vice versa, as well as increasing or decreasing the sensitivity
    of an axis.
  prefs: []
  type: TYPE_NORMAL
- en: To allow the player to move right and left using keyboard keys (which are either
    pressed or released and don't have a continuous value, unlike thumbsticks), we'll
    have to add two keys with inverted values on their scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more keys to this `Axis Mapping,` the first being the `D` key, with
    a `Scale` of `1`, and the second one being the `A` key, with a `Scale` of `–1`.
    This will cause the character to move right when the player presses the `D` key
    and to move left when the player presses the `A` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: The MoveRight Axis Mapping with both the Gamepad and keyboard
    keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: The MoveRight Axis Mapping with both the Gamepad and keyboard keys'
  prefs: []
  type: TYPE_NORMAL
- en: 'After doing this, add another `Axis Mapping` with the name of `MoveForward`
    with the `Gamepad Left Thumbstick Y-Axis`, `W`, and `S` keys, the latter having
    a `Scale` of `–1`. This axis will be used to move the character forward and backward:![Figure
    4.10: The MoveForward Axis Mapping'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: The MoveForward Axis Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: And with those steps completed, we've completed this chapter's first exercise,
    where you've learned how you can specify `Action` and `Axis` `Mappings` in UE4,
    allowing you to abstract which keys are responsible for which in-game actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how UE4 handles player input and processes it within
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Player Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about a situation where the player presses the *Jump* action, which
    is associated with the `Spacebar` key, to get the player character to jump. Between
    the moment the player presses the `Spacebar` key and the moment the game makes
    the player character jump, quite a few things have to connect those two events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at all the steps necessary that lead from one event to the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hardware Input`: The player presses the `Spacebar` key. UE4 will be listening
    to this keypress event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PlayerInput` class: After the key is pressed or released, this class will
    translate that key into an action or axis. If there is an action or axis associated
    with that key, it will notify all classes that are listening to the action that
    it was just pressed, released, or updated. In this case, it will know that the
    `Spacebar` key is associated with the *Jump* action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Player Controller` class: This is the first class to receive these events,
    given that it''s used to represent a player in the game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Pawn` class: This class (and consequently the `Character` class, which
    inherits from it) can also listen to those events, as long as they are possessed
    by a Player Controller. If so, it will receive these events after that class.
    In this chapter, we will be using our `Character` C++ class to listen to action
    and axis events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know how UE4 handles player inputs, let's take a look at the `DefaultInput.ini`
    file and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: DefaultInput.ini
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go to your project's directory, using File Explorer, and then open its
    `Config` folder, you'll find some `.ini` files in it, one of which should be the
    `DefaultInput.ini` file. As the name suggests, this file holds the main settings
    and configuration for input-related properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the first exercise of this chapter, where we edited the project's `Input`
    settings, what was happening, in reality, was that the editor was writing to and
    reading from the `DefaultInput.ini` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this file in a text editor of your choice. It contains many properties,
    but the ones we want to take a look at now are the list of `Action Mappings` and
    `Axis Mappings`. Near the end of the file, you should see, for instance, the *Jump*
    action being specified in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see some axes being specified, such as the `MoveRight` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of editing the project's `Input Settings`, you can directly edit this
    file to add, modify, and remove `Action Mappings` and `Axis Mappings`, although
    this isn't a very user-friendly way to do so. Keep in mind that this file will
    also be available when you package your project to an executable file, which means
    that the player will be able to edit this file to their liking.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how we can listen to `Action Mappings` and `Axis Mappings` in
    C++ in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Listening to Movement Actions and Axes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will register the actions and axes we created in the previous
    section with our character class by binding those actions and axes to specific
    functions in our character class using C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Player Controller` or `Character` to listen to Actions and Axes, the
    main way to do that is by registering the `Action` and `Axis` delegates using
    the `SetupPlayerInputComponent` function. The `MyThirdPersonChar` class should
    already have a declaration and an implementation for this function. Let''s have
    our character class listen to those events by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MyThirdPersonChar` class header file in Visual Studio and make sure
    there''s a declaration for a `protected` function called `SetupPlayerInputComponent`
    that returns nothing and receives a `class UInputComponent* PlayerInputComponent`
    property as a parameter. This function should be marked as both `virtual` and
    `override`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this class''s source file and make sure this function has an implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside its implementation, start by calling the `PlayerInputComponent` property''s
    `BindAction` function. This function will allow this class to listen to a specific
    action, in this case, the `Jump` action. It receives the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FName ActionName` – The name of the action we want to listen to; in our case,
    the `Jump` action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EInputEvent InputEvent` – The specific key event we want to listen to, which
    can be pressed, released, double-clicked, and so on. In our case, we want to listen
    to the pressed event, which we can specify by using the `IE_Pressed` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserClass* Object` – The object that the callback function will be called
    on; in our case, the `this` pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FInputActionHandlerSignature::TUObjectMethodDelegate< UserClass >::FMethodPtr
    Func` – This property is a bit wordy, but is essentially a pointer to the function
    that will be called when this event happens, which we can specify by typing `&`
    followed by the class''s name, followed by `::`, followed by the function''s name.
    In our case, we want this to be the existing `Jump` function belonging to the
    `Character` class, so we''ll specify it with `&ACharacter::Jump`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All functions used to listen to actions must receive no parameters unless you
    use `Delegates`, which are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to tell our character to stop jumping, you''ll have to duplicate this
    line and then change the new line''s input event to `IE_Released` and the function
    that''s called to be the `Character` class''s `StopJumping` function instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''ll be using the `InputComponent` class, we''ll need to include
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re listening to the `Jump` action and having the character jump
    when that action is executed, let''s move on to its movement. Inside the class''s
    header file, add a declaration for a `protected` function called `MoveRight`,
    which returns nothing and receives a `float Value` parameter. This is the function
    that will be called when the value of the `MoveRight` axis is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class''s source file, add this function''s implementation, where we''ll
    start by checking whether the `Controller` property is valid (not a `nullptr`)
    and whether the `Value` property is different than `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If both these conditions are true, we''ll want to move our character using
    the `AddMovementInput` function. One of the parameters of this function is the
    direction in which you want the character to move. To calculate this direction,
    we''ll need to do two things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the camera''s rotation on the *z* axis (yaw), so that we move the character
    relative to where the camera is looking. To achieve this, we can create a new
    `FRotator` property with a value of `0` for pitch (rotation along the *y* axis)
    and roll (rotation along the *x* axis) and the value of the camera''s current
    yaw for the property''s yaw. To get the camera''s yaw value, we can call the Player
    Controller''s `GetControlRotation` function and then access its `Yaw` property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call the `AddMovementInput` function, passing as parameters the
    `Direction` and `Value` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''ll be using both the `KismetMathLibrary` and `Controller` objects,
    we''ll need to include them at the top of this source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After listening to the `Jump` action, inside this class''s `SetupPlayerInputComponent`
    function, listen to the `MoveRight` axis by calling the `PlayerInputComponent`
    property''s `BindAxis` function. This function is used to listen to an Axis instead
    of an Action, and the only difference between its parameters and the `BindAction`
    function''s parameters is that it doesn''t need to receive an `EInputState` parameter.
    Pass as parameters to this function `"MoveRight"`, the `this` pointer, and this
    class''s `MoveRight` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All functions used to listen to an axis must receive a `float` property as a
    parameter unless you use `Delegates`, which is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now listen to the `MoveForward` axis in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class''s header file, add a similar declaration to that of the `MoveRight`
    function, but name it `MoveForward` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class''s source file, add an implementation to this new `MoveForward`
    function. Copy the implementation of the `MoveRight` function into this new implementation,
    but replace the call to the `KismetMathLibrary` object''s `GetRightVector` function
    with the call to its `GetForwardVector` function. This will use the vector representing
    the direction the camera is facing instead of its Right Vector, which faces its
    right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SetupPlayerInputComponent` function''s implementation, duplicate the
    line of code that listens to the `MoveRight` axis and replace the first parameter
    with `"MoveForward"` and the last parameter with a pointer to the `MoveForward`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now compile your code, open the editor, and open your `BP_MyTPS` Blueprint asset.
    Delete the `InputAction Jump` event, as well as the nodes connected to it. Do
    the same for the `InputAxis MoveForward` and `InputAxis MoveRight` events. We
    will be replicating this logic in C++ and need to remove its Blueprint functionality,
    so that there are no conflicts when handling input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, play the level. You should be able to move the character using the keyboard''s
    `W,` `A`, `S`, and `D` keys or the controller''s left thumbstick, as well as jumping
    with the `Spacebar` key or `gamepad face button bottom`:![Figure 4.11: The player
    character moving'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: The player character moving'
  prefs: []
  type: TYPE_NORMAL
- en: After following all these steps, you have concluded this exercise. You now know
    how to listen to `Action` and `Axis` events using C++ in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of listening to a specific `Action` or `Axis`, you can listen to a specific
    key by using the `PlayerInputComponent` property's `BindKey` function. This function
    receives the same parameters as the `BindAction` function, except for the first
    parameter, which should be a key instead of an `FName`. You can specify keys by
    using the `EKeys` enum followed by `::`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up all the logic necessary to have our character move and
    jump, let's add the logic responsible for rotating the camera around our character.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the camera around the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cameras are an extremely important part of games, as they dictate what and how
    the player will see your game throughout the play session. When it comes to third-person
    games, which is the case for this project, the camera allows you not only to see
    the world around them but also the character you're controlling. Whether the character
    is taking damage, falling, or something else, it's important for the player to
    always know the state of the character they are controlling and to be able to
    have the camera face the direction they choose.
  prefs: []
  type: TYPE_NORMAL
- en: Much like with every modern, third-person game, we will always have the camera
    rotate around our player character. To have our camera rotate around our character,
    after setting up the `Camera` and `Spring Arm` components in *Chapter 2*, *Working
    with Unreal Engine*, let's continue by adding two new `Axis Mappings`, the first
    one called `Turn`, which is associated with the `Gamepad Right Thumbstick X-Axis`
    and `MouseX` keys, and the second one called `LookUp`, which is associated with
    the `Gamepad Right Thumbstick Y-Axis` and `MouseY` keys, this latter key having
    a scale of `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These `Axis Mappings` will be used to have the player look right and left as
    well as up and down, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: The Turn and LookUp Axis Mappings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: The Turn and LookUp Axis Mappings'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add the C++ logic responsible for turning the camera with the player's input.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `MyThirdPersonChar` class's `SetupPlayerInputComponent` function implementation
    and duplicate either the line responsible for listening to the `MoveRight` axis
    or the `MoveForward` axis twice. In the first duplicated line, change the first
    parameter to `"Turn"` and the last parameter to the `Pawn` class's `AddControllerYawInput`
    function, while the second duplicated line should have the first parameter be
    `"LookUp"` and the last parameter be the `Pawn` class's `AddControllerPitchInput`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions are responsible for adding rotation input around the *z*
    (turning left and right) and *y* (looking up and down) axes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile the changes made in this section, open the editor, and play
    the level, you should now be able to move the camera by rotating the mouse or
    by tilting the controller''s right thumbstick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: The camera is rotated around the player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: The camera is rotated around the player'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes the logic to rotate the camera around the player character
    with the player's input. In the next exercise, we'll take a broad look at the
    topic of mobile platforms such as Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to recent advancements in technology, the majority of the population
    now has access to affordable mobile devices such as smartphones and tablets. These
    devices, although small, still have quite a bit of processing power and can now
    do many things that bigger devices such as laptops and desktop computers do. One
    of those things is playing video games.
  prefs: []
  type: TYPE_NORMAL
- en: Because mobile devices are much more affordable and versatile than other devices
    you can play video games on, you have a lot of people playing games on them. For
    this reason, it's worth considering developing video games for mobile platforms
    such as Android and iOS, the two biggest mobile app stores.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how to preview our game on a virtual mobile device
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Previewing on Mobile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll be playing our game using `Mobile Preview`, to see what
    it's like to play our game on a mobile device. Before we can do this, we have
    to go to the `Android Platform` settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Project Settings` window and scroll down its left edge until you
    find the `Android` option beneath the `Platforms` category. Click that option.
    You should see the following to the right of the categories:![Figure 4.14: The
    Android Platform window warning that the project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: currently isn’t configured for that platform
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: The Android Platform window warning that the project currently
    isn''t configured for that platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning is letting you know that the project has not yet been configured
    for Android. To change that, click the `Configure Now` button inside the *red
    warning*. When you do, it should be turned into a green warning, letting you know
    that the platform is configured:![Figure 4.15: The Android platform window notifying
    you that the project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: is configured for this platform
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: The Android platform window notifying you that the project is
    configured for this platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve done this, you can close `Project Settings`, click the arrow
    next to the `Play` button in the editor''s toolbar, and select the `Mobile Preview`
    option you see available:![Figure 4.16: The Mobile Preview option under the Play
    button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: The Mobile Preview option under the Play button'
  prefs: []
  type: TYPE_NORMAL
- en: This will cause the engine to start loading this preview, as well as compiling
    all the necessary shaders, which should take a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it''s done, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: The Mobile Preview window playing the game as if on an Android
    device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: The Mobile Preview window playing the game as if on an Android
    device'
  prefs: []
  type: TYPE_NORMAL
- en: 'This preview should look similar to the normal preview inside the editor with
    a couple of notable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The visual fidelity has been lowered. Because mobile platforms don't have the
    same type of computing power as PCs and consoles, the visual quality is lowered
    to take that into account. On top of that, some rendering features available in
    high-end platforms are simply not supported in mobile platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two added virtual joysticks at the *lower-left* and *lower-right* corner of
    the screen, which work similarly to those of a controller, where the left joystick
    controls the character's movement and the right joystick controls the camera's
    rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This window acts as a mobile screen where your mouse is your finger, so if
    you press and hold the left joystick using the left mouse button, and then drag
    it, that will cause the joystick to move on the screen and consequently make the
    character move, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: The character is moved using the left virtual joystick'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.18: The character is moved using the left virtual joystick'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude this chapter by learning how to preview our game
    on the Android mobile platform and verify that its inputs are working.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now jump into the next exercise, where we'll be adding touch input that
    causes the player character to jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Adding Touchscreen Input'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll be continuing from our previous exercise by making it
    so that the player character starts jumping when the player tabs the screen if
    they're playing on a touchscreen device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add touchscreen input to our game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `MyThirdPersonChar` class''s header file and add two declarations
    for protected functions that return nothing and receive the `ETouchIndex::Type
    FingerIndex` and `FVector Location` parameters, the first one of which indicates
    the index of the finger that touched the screen (whether it was the first, second,
    or third finger to touch the screen) and the second one, which indicates the position
    that was touched on the screen. Name one of these functions `TouchBegin` and the
    other one `TouchEnd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MyThirdPersonChar` class''s source file, add the implementation of
    both these functions, where the `TouchBegin` function will call the `Jump` function
    and the `TouchEnd` function will call the `StopJumping` function. This will cause
    our character to start jumping when the player touches the screen and to stop
    jumping when they stop touching the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `SetupPlayerInputComponent` function''s implementation and add two
    calls to the `BindTouch` function of `PlayerInputComponent`, which will bind the
    event of the screen being touched to a function. This function receives the same
    parameters as the `BindAction` function except for the first one, `ActionName`.
    In the first function call, pass as parameters the input event `IE_Pressed`, the
    `this` pointer, and this class''s `TouchBegin` function, and in the second call,
    pass the input event `IE_Released`, the `this` pointer, and this class''s `TouchEnd`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Preview the game using `Mobile Preview`, just like we did in the previous exercise.
    If you use the left mouse button to click the middle of the screen, the player
    character should jump:![Figure 4.19: The character jumping after clicking the
    middle of the screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: The character jumping after clicking the middle of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude the logic that will make our character jump as long
    as the player is touching the screen if they're playing on a touchscreen device.
    Now that we've learned how to add inputs to our game and associate those inputs
    with in-game actions such as jumping and moving the player character, let's consolidate
    what we've learned in this chapter by adding a new `Walk` action to our game from
    start to finish in the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Adding Walking Logic to Our Character'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the current game, our character runs by default when we use the movement
    keys, but we need to reduce the character's speed and make it walk.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this activity, we'll be adding logic that will make our character walk
    when we move it while holding the `Shift` key on the keyboard or the `Gamepad
    Face Button Right` key (`B` for the Xbox controller and `O` for PlayStation controller).
    Further, we will preview it on a mobile platform as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Input Settings` through the `Project Settings` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `Action Mapping` called `Walk` and associate it with the `Left Shift`
    and `Gamepad Face Button Right` keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MyThirdPersonChar` class's header file and add declarations for two
    `protected` functions that return nothing and receive no parameters, called `BeginWalking`
    and `StopWalking`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the implementations for both these functions in the class's source file.
    In the implementation of the `BeginWalking` function, change the character's speed
    to 40% of its value by modifying the `CharacterMovementComponent` property's `MaxWalkSpeed`
    property accordingly. To access the `CharacterMovementComponent` property, use
    the `GetCharacterMovement` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation for the `StopWalking` function will be the inverse of that
    of the `BeginWalking` function, which will increase the character's walk speed
    by 250%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the `Walk` action to the `BeginWalking` function when that action is pressed,
    and to the `StopWalking` function when it is released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, you should be able to have your character walk,
    which decreases its speed and slightly changes its animation, by holding either
    the keyboard's *Left Shift* key or the controller's *Face Button Right* button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: The character running (left) and walking (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_04_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.20: The character running (left) and walking (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now preview our game on a mobile platform, as we did in *Exercise 4.03*,
    *Previewing on Mobile*, and drag the left analog stick just slightly to get our
    character to walk slowly. The result should look similar to the following screenshot:![Figure
    4.21: The character walking in the mobile preview'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_04_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.21: The character walking in the mobile preview'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our activity. Our character should now be able to walk slowly
    as long as the player is holding the `Walk` action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to add, remove, and modify `Action Mappings`
    and `Axis Mappings`, which give you some flexibility when determining which keys
    trigger a specific action or axis, how to listen to them, and how to execute in-game
    logic when they're pressed and released.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to handle the player's input, you can allow the player
    to interact with your game and offer the agency that video games are so well known
    for.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start making our own game from scratch. It'll be
    called `Dodgeball` and will consist of the player controlling a character trying
    to run away from enemies that are throwing dodgeballs at it. In that chapter,
    we will have the opportunity to start learning about many important topics, with
    a heavy focus on collisions.
  prefs: []
  type: TYPE_NORMAL
