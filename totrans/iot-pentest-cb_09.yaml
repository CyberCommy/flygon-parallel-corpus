- en: Mobile Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data securely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing data in transit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely using Android and iOS platform components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing third-party code and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing reverse engineering protections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mobile applications are often a crux for controlling consumer IoT. Be it smart
    home devices or connected vehicles, mobile applications are a desirable target
    to attack and be kept secure. In [Chapter 5](4f5f4da8-0adb-4596-925c-f90929b55915.xhtml), *Exploiting
    IoT Mobile Applications*, exploitation of mobile applications was covered from
    an offensive perspective. This chapter will provide mobile application security
    defensive controls used to protect from common attack vectors. It is important
    to note that this chapter is by no means exhaustive when it comes to mobile security
    best practices as full books are written on this subject alone. It is encouraged
    to reference supplemental reading for more in-depth understanding of certain controls
    and best practices described in this chapter. Where appropriate, examples for
    Android and iOS will be given throughout recipes. As per OWASP''s Mobile Security
    Project ([https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls](https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Controls)),
    the top 10 mobile controls consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and protecting sensitive data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Protecting authentication credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Protecting data in transit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing user authentication, authorization, and session management correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping the backend APIs (services) and the platform (server) secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Securing data integration with third-party services and applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paying specific attention to the collection and storage of consent for the collection
    and use of the user's data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing controls to prevent unauthorized access to paid-for resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensuring secure distribution/provisioning of mobile applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Carefully checking any runtime interpretation of code for errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter will address several of the earlier mentioned mobile security controls
    that are relative to common IoT application use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data securely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensitive data in mobile applications varies on the nature of the IoT device.
    Many devices may store personal data, collect personal data, **patient health
    information** (**PHI**), credit card information, and store account credentials
    on a mobile device to authenticate to an IoT device. Leaked credentials or long-lived
    session tokens may have a critical impact for smart door locks and connected vehicles.
    This sensitive data must be secured with controls and verifications in place.
    Many times, sensitive data is unintentionally exposed to third-party applications
    running on a mobile device for operating system **interprocess communication**
    (**IPC**). Additionally, it is not uncommon to lose a mobile device, or have it
    stolen or seized when traveling. In these cases, applications must employ proper
    security controls to protect sensitive data and make obtaining the data more difficult.
    In this recipe, we will discuss methods for storing sensitive data securely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, SQLCipher will be used to demonstrate a method of secure database
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLCipher can be downloaded from the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.zetetic.net/sqlcipher/](https://www.zetetic.net/sqlcipher/)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Android and iOS platforms have native methods to securely store sensitive
    data. For Android, sensitive data can be stored in the KeyStore. For iOS, sensitive
    data can be stored in the Keychain. It is important to note that, if a device
    is rooted or jailbroken, Android's KeyStore and iOS' Keychain contents can be
    dumped. Although, if an Android device has a **Trusted Execution Environment**
    (**TEE**) or a **Secure Element** (**SE**), the KeyStore is not directly accessible
    to the operating system and the data saved will not be accessible. In addition
    to the native platform APIs available to store data securely, third-party libraries
    are available to encrypt data on disk or an entire SQLite database such as SQLCipher.
    SQLCipher is available for Android and iOS and should be used to store data securely
    if SQLite databases are used for an IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use SQLCipher in an Android application, we need to create an activity,
    initialize the SQLCipher database, and save the data in the appropriate database
    table and column, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An important step not included in the earlier example is the establishment of
    a PRAGMA key. This PRAGMA key is the encryption key for the SQLCipher database
    and should be generated at runtime during app initialization for each user and
    device. The PRAGMA key should have sufficient entropy and should not be hardcoded
    into the application or stored in storage locations that are not hardware backed
    (for example, secure element).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common Android insecure storage location for settings and configurations often
    used by developers is `SharedPreferences.xml`. Data saved in `SharedPreferences.xml`
    is clear text readable unless a third-party wrapper is used to encrypt the values
    of preferences.
  prefs: []
  type: TYPE_NORMAL
- en: For iOS, data should not be stored in files within the application container
    or within clear text plist files. The Keychain should be used for all credential
    and token data with the proper Keychain API attributes according to the context
    in which your app runs. For example, if the app does not run in the background,
    use the most restrictive attributes such as `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`,
    which prevents Keychain items from being backed up by iTunes or `kSecAttrAccessibleWhenUnlocked`.
    If the app needs to run in the foreground, use the `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several best practices to follow that apply to both Android and iOS
    when storing data. Common best practices include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Do not store sensitive data where possible.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Only store data that is needed for application function.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Avoid storing sensitive data in cache, external memory storage (SD cards),
    or temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Do not log sensitive data to disk or to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Disable keyboard caching for sensitive input fields.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Restrict backing up application data.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. If sensitive data is stored on disk, encrypt its contents and store the
    data in a tamper-proof location such as a secure element.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Ensure the app wipes sensitive data from memory after its use and when no
    longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Ensure that the clipboard is disabled for sensitive text fields.
  prefs: []
  type: TYPE_NORMAL
- en: At times, platform security APIs such as the KeyStore and Keychain may not be
    enough to ensure data confidentiality and integrity of sensitive data. In these
    cases, it is recommended to augment protections with application-level encryption
    and then store the encrypted data in the platform's secure storage location.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on the Keychain, refer to *Apple's Keychain Services Programming
    Guide* ([https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#/](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html%23/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on the Keychain, refer to *Android's Developer* documentation
    ([https://developer.android.com/training/articles/keystore.html](https://developer.android.com/training/articles/keystore.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on using SQLCipher, refer to *SQLCipher's API Developer*
    documentation ([https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication for mobile applications can occur from both server side and client
    side. IoT mobile applications can make use of both design patterns although each
    have their own risk considerations when implementing in production. This section
    will discuss some of these risks as well as best practice design implementations
    for server and client-side authentication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'General application principles for securely authenticating users apply to mobile
    applications as well. A great reference is OWASP''s *Authentication Cheat Sheet*
    ([https://www.owasp.org/index.php/Authentication_Cheat_Sheet](https://www.owasp.org/index.php/Authentication_Cheat_Sheet)).
    Common authentication controls and best practices consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Proper password strength controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 characters or more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password complexity policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 uppercase, 1 lowercase, 1 digit, 1 special character, and disallowing 2 consecutive
    characters such as 222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce password history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disallow the last three used passwords (password reuse)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transmitting credentials only over encrypted communications (TLS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send credentials over an `HTTP POST` body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-authenticate users for sensitive features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing account pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing security questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing camera feeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlocking vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure authentication error messages do not disclose potential sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A correct error response is as follows, invalid username and/or password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring logging of authentication functions to detect login failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent automated brute-force attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a CAPTCHA or similar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limit suspicious login attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporarily lock accounts after a given threshold and email the account address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure multifactor authentication exists and is enforced at login as well as
    when using step up authentication to access resources. Two-factor methods include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user known value in addition to a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **one-time password** (**OTP**) or code sent via email or SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A physical token with an OTP in addition to a user's password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding items apply to both web applications, hybrid mobile applications,
    and even native mobile applications. The following items are mobile-specific authentication
    best practices to implement into an application:'
  prefs: []
  type: TYPE_NORMAL
- en: If biometrics are used, ensure to use the KeyStore and Keychain rather than
    the event based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions are invalidated server-side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications list the last login activities and allow users to block devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refrain from using device UUIDs, IP addresses, MAC addresses, and IMEIs for
    authentication or authorization purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a third-party OTP application (for example, Google or Salesforce authenticator)
    outside of the mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android-specific authentication practices are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When using Android's FingerprintManager class ([https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager.html)),
    use the `KeyGenerator` class with an asymmetric key pair. An example of using
    an asymmetric key pair is available at [https://github.com/googlesamples/android-AsymmetricFingerprintDialog](https://github.com/googlesamples/android-AsymmetricFingerprintDialog).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced in Android Nougat API 24, use the `setInvalidatedByBiometricEnrollment`
    (`boolean invalidateKey`) method to invalidate new fingerprints from retrieving
    keys on the mobile device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps should utilize the SafetyNet reCAPTCHA API to protect authentication from
    bot-based brute force attempts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the SafteyNet reCAPTCHA API, the following steps must be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register a reCAPCTHA key pair via [https://www.google.com/recaptcha/admin#androidsignup](https://www.google.com/recaptcha/admin%23androidsignup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/018e9535-f65e-46ef-946c-7ecc3e5aa292.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the SafetyNet API dependency and Google Play Services if not already configured.
    For example, include the compile `com.google.android.gms:play-services-safetynet:11.4.2`
    in the project build gradle file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A request to invoke a verify request has to be made via the `verifyWithRecaptcha()`
    ([https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String)](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetClient#verifyWithRecaptcha(java.lang.String))).
    This request must contain the API site key as a parameter and must override the
    `onSuccess()` and `onFailure()` methods. The following snippet of code shows how
    to invoke this method provided Android''s Developer guide ([https://developer.android.com/training/safetynet/recaptcha.html#send-request](https://developer.android.com/training/safetynet/recaptcha.html%23send-request)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate the response token via `SafetyNetApi.RecaptchaTokenResult.getTokenResult()`.
    An example `JSON HTTP` response looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, logic must be added to handle failures and errors. There are seven status
    codes the SafetyNet reCAPTCHA API uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. `RECAPTCHA_INVALID_SITEKEY`
  prefs: []
  type: TYPE_NORMAL
- en: 2\. `RECAPTCHA_INVALID_KEYTYPE`
  prefs: []
  type: TYPE_NORMAL
- en: 3\. `RECAPTCHA_INVALID_PACKAGE_NAME`
  prefs: []
  type: TYPE_NORMAL
- en: 4\. `UNSUPPORTED_SDK_VERSION`
  prefs: []
  type: TYPE_NORMAL
- en: 5\. `TIMEOUT`
  prefs: []
  type: TYPE_NORMAL
- en: 6\. `NETWORK_ERROR`
  prefs: []
  type: TYPE_NORMAL
- en: 7\. `ERROR`
  prefs: []
  type: TYPE_NORMAL
- en: 'Details about each of the status codes are available at the following reference
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes.](https://developers.google.com/android/reference/com/google/android/gms/safetynet/SafetyNetStatusCodes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS-specific authentication practices are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: Store an application's secret in an access-controlled Keychain lists to the
    specific application. An example code snippet for using the Keychain and Touch
    ID can be found using Apple's Developer documentation at [https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html](https://developer.apple.com/library/content/samplecode/KeychainTouchID/Listings/KeychainTouchID_AAPLKeychainTestsViewController_m.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure applications read from `LAContext.evaluatedPolicyDomainState` to check
    if the `evaluatedPolicyDomainState` value has altered indicating the enrolled
    Touch ID fingerprint has changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disallow Keychain synchronizing to iCloud via `kSecAttrSynchronizable` unless
    required for app functioning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch ID is a common method for authenticating users; however, there are several
    approaches and tools to bypass apps that only use the Local Authentication framework.
    Using Keychain ACLs as mentioned previously prevents attackers from overriding
    the `LAContextevaluatePolicy:localizedReason:reply` method during runtime or patching
    the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on iOS Keychain services refer to *Keychain Services Programming
    Guide* ([https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding authenticating to remote servers using the Fingerprint
    API, visit Android's developer blog ([https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html](https://android-developers.googleblog.com/2015/10/new-in-android-samples-authenticating.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the following Android developer page on the SafetyNet reCAPTCHA API ([https://developer.android.com/training/safetynet/recaptcha.html](https://developer.android.com/training/safetynet/recaptcha.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing data in transit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing end-to-end communication for IoT mobile applications has been known
    to be a difficult problem to solve. Often, data is leaked via clear text protocols
    such as HTTP or UDP (SIP) for audio transmission to a mobile application. On occasion,
    IoT manufacturers have been found to leak data to third parties that only communicate
    over HTTP or use less secure encryption configurations for analytic services such
    as content recognition or crash reporting analytic services. The goal of securing
    data in transit is to ensure the confidentiality and integrity of data exchanged
    between the mobile app, IoT device, and API endpoints. A mobile app must set up
    a secure encrypted channel for network communication using TLS and configuring
    the proper cipher suites. For devices such as smart locks or connected vehicles,
    this is a must. This recipe will cover best practices to follow to secure data
    in transit for IoT mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing data in transit for mobile applications has common requirements and
    best practices to follow. Best practices to secure data in transit include but
    are not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the most updated TLS and cipher suite configurations the platform supports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the server X.509 certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the certificate hostname
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only accept certificates signed by a trusted certificate authority, which includes
    public CAs as well as internal trusted CAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disallow self-signed certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin connections to only trusted certificates and/or public keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation varies between Android and iOS. Native cryptographic APIs
    are available for both platforms; however, third-party wrapper libraries are also
    available but may not have abilities such as certificate pinning.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, an Android app creates a KeyStore with CAs (trusted
    certificates) that initializes the TrustManager whose job is to validate only
    the certificates that are within the KeyStore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `KeyPinStore` class that is thread-safe (public static synchronized):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the CAs that are inside the application''s assets directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a KeyStore with our specified trusted CAs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the TrustManager to validate the CAs in our KeyStore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the SSLContent that uses our TrustManager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Tell the URLConnection to use a SocketFactory from our SSLContext when communicating
    to the application''s API endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A tool that can help with ensuring proper TLS/SSL configurations are in place
    is one released by Google called nogotofail. Not only does nogotofail check configurations,
    but it also ensures vulnerable TLS/SSL protocols are not in use as well as an
    insight as to what data is being sent from a client device via MITM techniques.
    To learn more about nogotofail, visit the project's GitHub page [https://github.com/google/nogotofail](https://github.com/google/nogotofail).
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar actions can be used to pin to certificates and/or public key fingerprints
    of certificates in iOS. Pinning is performed through the `NSURLConnectionDelegate`,
    where `connection:canAuthenticateAgainstProtectionSpace:` and `connection:didReceiveAuthenticationChallenge:.`
    must be implemented within `connection:didReceiveAuthenticationChallenge:`, and
    call `SecTrustEvaluate` to perform X509 validation checks. A sample iOS pinning
    application provided by OWASP can be used as a reference when deploying such checks
    in applications. The sample program can be downloaded via the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip](https://www.owasp.org/images/9/9a/Pubkey-pin-ios.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the general best practices that all applications should follow when
    employing TLS, iOS has a new feature that developers can take advantage of and
    will be required when submitting to Apple''s App Store in the future ([https://developer.apple.com/news/?id=12212016b](https://developer.apple.com/news/?id=12212016b)).
    This feature is known as **App Transport Security** (**ATS**), introduced in iOS
    9 and is enabled by default. ATS requires apps to communicate over HTTPS using
    TLSv1.2 with **Perfect Forward Secrecy** (**PFS**) as well as specific cipher
    suites. If an app does not meet the minimum requirements, connections will not
    be allowed to the iOS app. This is great for all IoT devices; however, there are
    ways to get around ATS. Specifically, developers can completely disable ATS by
    using the `NSAllowsArbitraryLoads` configuration in the `Info.plist` file, as
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/923236c5-0e58-41f1-89e5-0814cdd7ef0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, this is very common in IoT applications due to the lack of knowledge
    in cryptography and/or PKI. ATS also gives the ability to provide exceptions per
    domain or globally rather than disabling ATS altogether. The following is a non-exhaustive
    list of exceptions that can be applied to the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable PFS (`NSExceptionRequiresForwardSecrecy`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable ATS for media (`NSAllowsArbitraryLoadsForMedia`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow insecure connections over HTTP (`NSExceptionAllowsInsecureHTTPLoads`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower the minimum TLS version (`NSExceptionMinimumTLSVersion`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow connections to local domains (`NSAllowsLocalNetworking`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apple has provided a tool that checks for App Transport Security issues called
    nscurl. Nscurl can be used by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Apple is making promising changes to influence developers to ensure data is
    being secured in transit. As noted, all apps submitted to the App Store will be
    required to support ATS at a time to be announced by Apple.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sample Android public key pinning application provided by OWASP can be downloaded
    via the following URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip](https://www.owasp.org/images/1/1f/Pubkey-pin-android.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following Apple developer guide to learn more about ATS requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW57](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html%23/apple_ref/doc/uid/TP40009251-SW57)'
  prefs: []
  type: TYPE_NORMAL
- en: Securely using Android and iOS platform components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When IoT mobile applications execute or retrieve commands from third-party apps,
    internal platform APIs are used for **interprocess communication** (**IPC**).
    IPC can be used to integrate applications to make calls to expense tracking apps,
    third-party service apps such as IFTTT, or personal assistants such as Amazon's
    Alexa. Platforms such as Android offer a rich IPC capability while iOS only offers
    a couple of options. The majority of IoT applications use platform and hardware
    features to interact with the physical world, which in turn poses a higher impact
    in the event that adversaries successfully exploit a bug. In this recipe, we will
    discuss how to employ security controls around IPC and how to use platform APIs
    in a secure manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interacting with commands originating from applications over to a mobile platform
    is a powerful capability. If not secured properly, unauthorized apps can hijack
    commands and access data that was not intended to be received by unintended parties.
    When using platform APIs, the following practices should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not export sensitive functionality through IPC unless these mechanisms are
    properly protected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs from external sources and users should be validated and sanitized, if
    necessary. This includes data received via the user interface, IPC mechanisms
    such as intents, custom URL handlers, and network sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebViews should be configured to allow only the minimum set of protocol handlers
    required such as HTTPS and to disable other dangerous handlers, such as `file://`,
    `tel://`, `sms://`, and `app-id://`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict IPC calls to a whitelist of trusted applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitelist web pages and URL handlers to be loaded locally or remotely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request only the minimum set of permissions necessary for app functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native methods exposed via WebViews should be verified that only JavaScript
    within the application sandbox is rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebViews should disable JavaScript unless explicitly required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization should only use safe serialization APIs and be cryptographically
    signed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the listed practices can be applied to Android and iOS platforms; however,
    specific considerations such as Android permissions, custom permissions, and protection
    levels should be reviewed according to an application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of a custom permission called `IOT_COOKBOOK_ACTIVITY`
    that is required when launching the `MAIN_ACTIVITY``Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first code block defines the new permission with a label tag and description
    about the `Activity`. Next, the protection level is set based on the type of permission
    it is granting. Once the permission is defined, it can be enforced on the component
    by specifying the uses-permission in the application''s `AndroidManifest.xml`
    file. In the following example, the second block is the component that we will
    restrict with the permission we have defined. It can be enforced by adding the
    `android:permission` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the new permission `IOT_COOKBOOK_ACTIVTY` is created, apps can request
    it using the uses-permission tag in the `AndroidManifest.xml` file. In this case,
    it must be an app that is signed with the same certificate that can launch the
    `MAIN_ACTIVITY`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When introducing custom permissions and protection levels, it's always a good
    idea to reference Android's Developer documentation. All Android permissions can
    be found in the Android developer documentation at [https://developer.android.com/guide/topics/permissions/requesting.html](https://developer.android.com/guide/topics/permissions/requesting.html).
  prefs: []
  type: TYPE_NORMAL
- en: In iOS applications, permissions are not applicable due to the closed ecosystem
    of iOS. However, iOS and Android share WebViews, which enable web pages to be
    loaded inside an app. Similar to web applications, malicious code can be executed
    inside web browsers, including the ones in WebViews. This is important to consider
    when reducing the attack surface of an IoT application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates how to disable JavaScript in WKWebViews
    in iOS applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For Android applications, disabling JavaScript is done by configuring a WebView''s
    `WebSettings`, as shown next. Additional settings should be configured such as
    disabling filesystem access, turning off plugins, and turning off geolocation,
    if not needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With least privilege and security in-depth principles in mind, apps should only
    utilize and expose platform components for required business functionality. As
    a rule of thumb, any data being sent and retrieved from third-party applications
    should be considered untrustworthy and validated appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Securing third-party code and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all software, mobile applications heavily use third-party libraries
    and wrappers to perform a function such as making HTTP requests or encrypting
    objects. These libraries can also introduce weaknesses into an application and
    expose confidential information or affect the integrity of the application itself.
    With this in mind, third-party code should be reviewed for vulnerabilities, updated,
    and tested where applicable. This is especially true for hybrid applications that
    depend on third-party hybrid frameworks and libraries to send, receive, and save
    data. This recipe will discuss methods to ensure third-party code does not introduce
    vulnerabilities into IoT applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](1a595cca-2dc4-4426-a3dc-ce5ac0b0a721.xhtml), *Firmware Security
    Best Practices*, methods to scan JavaScript libraries with NSP as well as Retire.js
    were discussed, these can still be applied to mobile applications. To ensure third-party
    code does not introduce security holes into mobile applications, the following
    recommendations should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuously inventory the versions of libraries and frameworks and their dependencies
    using tools such as nsp, Retirejs, and dependency-check ([https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a bill of materials for all components and third-party software used
    in the mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously monitor vulnerabilities databases such as NVD for vulnerabilities
    in utilized components via analysis tools to automate the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze third-party libraries to ensure they are invoked at runtime and remove
    functions not required for the application function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure hybrid frameworks use the most up-to-date versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor hybrid framework releases and blogs to ensure no known components with
    vulnerabilities are in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch vulnerable libraries in the event framework developers do not merge upstream
    libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor utilized open source code repositories for security issues and concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure hybrid framework plugins have been reviewed for security flaws prior
    to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize newer Android version APIs to take advantage of newly introduced features
    (Apple forces iOS updates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review Android and iOS security bulletins for platform vulnerabilities and new
    security capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the most common mobile hybrid frameworks is Apache''s Cordova. Cordova
    can be updated for iOS and Android via the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Cordova is known for being targeted by researchers and often has security updates
    included in new releases for both Android and iOS. The release notes for Cordova
    can be found via their blog located at [https://cordova.apache.org/blog/](https://cordova.apache.org/blog/).
    A good place to look for bugs that have not been released yet is the framework's
    bug tracking system such as Cordova's ([https://issues.apache.org/jira/projects/CB/summary](https://issues.apache.org/jira/projects/CB/summary)).
    You will be amazed to see the amount of bugs fixed, reported, and closed. For
    example, another popular hybrid framework used is Xamarin. Xamarin's credential
    manager used a hardcoded Android Keystore password leaving account credentials
    at risk of compromise from April 2014, until it was fixed in late 2016\. This
    can be found viewing the project's GitHub repository [https://github.com/xamarin/Xamarin.Auth/issues/55](https://github.com/xamarin/Xamarin.Auth/issues/55).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google takes a snapshot of devices being used in Google Play and publishes this
    data to a dashboard in an effort to help prioritization of supporting different
    devices ([https://developer.android.com/about/dashboards/index.html](https://developer.android.com/about/dashboards/index.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every month Google releases Android security bulletins that list announcements,
    vulnerabilities with CVEs, their severity, and mitigations. Android security bulletins
    can be found at [https://source.android.com/security/bulletin/](https://source.android.com/security/bulletin/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple releases an iOS security guide every year that details the platform security
    features and new security control capabilities with new iOS versions. The iOS
    security guide can be found at [https://www.apple.com/business/docs/iOS_Security_Guide.pdf](https://www.apple.com/business/docs/iOS_Security_Guide.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing reverse engineering protections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing secure code can be difficult when there are code bases with internal
    and outsourced teams for **user experience** (**UX**), specific feature sets such
    as finding devices during app startup, ensuring rule settings properly execute,
    and others such as ensuring app updates do not negatively affect IoT devices in
    the network. With such complexity for one application, bugs are bound to be discovered
    and security controls circumvented by attackers. Yes, this is inevitable for any
    software although techniques are available to make reverse engineering more difficult
    for attackers to compromise applications and steal a company's **intellectual
    property** (**IP**).
  prefs: []
  type: TYPE_NORMAL
- en: These techniques can be built into the application logic to protect against
    runtime modification, static analysis of applications binaries via obfuscation
    of application classes, and segmentation of data preparing for potential compromise.
    It is important to note, applications still need to build security controls into
    applications and not replace controls with third-party software protections. This
    recipe will introduce practices for making applications more resilient to attacks.
    These practices will not only make applications more resilient but also contribute
    to in-depth defenses as part of an application's anti-abuse system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When implementing app reverse engineering controls and code modification techniques,
    the following practices should be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications should detect and respond to rooted or jailbroken devices either
    by alerting the user or terminating the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obfuscation of classes and methods is applied to builds for impeding on de-obfuscation
    via dynamic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware-backed process isolation is preferred over obfuscation whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should prevent debugging and prevent debuggers from being attached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should detect the presence of reverse engineering tools and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications should detect when running in an emulated environment and respond
    appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production builds should strip symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production builds should not contain debugging code or debuggable features such
    as `android:debuggable="false"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android applications can use the SafetyNet Attestation API compatibility check
    to ensure applications have not been modified by an unknown source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SafetyNet Verify Apps API should be used to check whether any potentially
    harmful apps are installed on a device ([https://developer.android.com/training/safetynet/verify-apps.html](https://developer.android.com/training/safetynet/verify-apps.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iOS apps can look for common jailbreak file-based checks such as the following
    list ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x06j-Testing-Resiliency-Against-Reverse-Engineering.md)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition, iOS apps can attempt to execute root-level system API calls or
    checking file permissions by writing data to a file that is outside of the application's
    sandbox to detect whether a device is jailbroken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android apps can use similar methods to check commonly found rooted device
    files and also attempt to execute commands as root. A list of commonly rooted
    files and apps is listed as follows ([https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md](https://github.com/OWASP/owasp-mstg/blob/master/Document/0x05j-Testing-Resiliency-Against-Reverse-Engineering.md)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, checking for custom Android ROM builds can indicate a rooted device
    although it is not a definitive method.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple checks and defense methods should be used to ensure resilience. The
    overall goal is to ensure attackers cannot tamper, modify code, perform runtime
    modifications, and reverse engineering app packages to prevent abuse. Several
    of the preceding practices can be introduced into an application's logic upon
    startup and throughout the runtime of the application. Commercial solutions are
    available to perform some of the earlier-listed practices and more; however, they
    should be vetted prior to integrating into an application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the risks of mobile application reverse engineering and unauthorized
    code modification, reference OWASP's Reverse Engineering and Code Modification
    Prevention Project [https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project](https://www.owasp.org/index.php/OWASP_Reverse_Engineering_and_Code_Modification_Prevention_Project).
    This project does a great job of describing technical and business risk use cases
    with supplemental mitigation suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about requesting a compatibility check via the SafetyNet API
    can be found via the following Android Developer page ([https://developer.android.com/training/safetynet/attestation.html#cts-check](https://developer.android.com/training/safetynet/attestation.html#cts-check)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
