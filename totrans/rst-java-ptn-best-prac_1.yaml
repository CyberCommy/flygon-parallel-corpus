- en: Chapter 1. REST – Where It Begins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services in the traditional SOA formats have been around for a long time
    to implement heterogeneous communication between applications. One way to support
    this kind of communication is to use the **Simple Object Access Protocol** (**SOAP**)/**Web
    Services Description Language** (**WSDL**) approach. SOAP/WSDL is an XML-based
    standard and works well when there is a strict contract between the services.
    We are now in the era of distributed services where different clients from the
    Web, mobile, as well as other services (internal or external), can make use of
    APIs exposed by different vendors and open source platforms. This requirement
    enforces the need for easier exchange of information between distributed services
    along with predictable, robust, well-defined interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP 1.1 is defined in RFC 2616, and is ubiquitously used as the standard protocol
    for distributed, collaborative hypermedia information systems. **Representational
    State Transfer** (**REST**) is inspired by HTTP and can be used wherever HTTP
    is used. This chapter will go over the basics of the RESTful services design and
    show how to produce and consume RESTful services, based on the standard Java API.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the following topics.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety and idempotence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles for building RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Standard API for RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices when designing RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST is an architectural style that conforms to the web standards such as using
    HTTP verbs and URIs. It is bound by the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: All resources are identified by the URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All resources can have multiple representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All resources can be accessed/modified/created/deleted by standard HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no state information on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST and statelessness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is bound by the principle of **statelessness**. Each request from the client
    to the server must have all the details to understand the request. This helps
    to improve visibility, reliability, and scalability for requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visibility** is improved, as the system monitoring the requests does not
    have to look beyond one request to get details. **Reliability** is improved as
    there is no check-pointing/resuming in case of partial failures. **Scalability**
    is improved because the number of requests that can be processed by the server
    increases, as the server is not responsible for storing any state.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roy Fielding's dissertation on the REST architectural style provides details
    on the statelessness of REST. Check [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: With this initial introduction to the basics of REST, we shall cover the different
    maturity levels and how REST falls in it in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The Richardson Maturity Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Richardson Maturity Model** is a model developed by Leonard Richardson.
    It talks about the basics of REST in terms of resources, verbs, and hypermedia
    controls. The starting point for the maturity model is to use the HTTP layer as
    the transport. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Richardson Maturity Model](img/7963OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Level 0 – Remote Procedure Invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Level 0 contains SOAP or XML-RPC sending data as **Plain Old XML** (**POX**).
    Only the `POST` methods are used. This is the most primitive way of building SOA
    applications with a single `POST` method and using XML to communicate between
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Level 1 – REST resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Level 1 uses the `POST` methods and instead of using a function and passing
    arguments it uses the REST URIs. So, it still uses only one HTTP method. It is
    better than Level 0 as it breaks a complex functionality into multiple resources
    with the use of one `POST` method to communicate between services.
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 – more HTTP verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Level 2 uses other HTTP verbs such as `GET`, `HEAD`, `DELETE`, and `PUT` along
    with the `POST` methods. Level 2 is the real use case of REST, which advocates
    using different verbs based on the HTTP request methods and the system can have
    multiple resources.
  prefs: []
  type: TYPE_NORMAL
- en: Level 3 – HATEOAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is the most
    mature level of Richardson''s model. The responses to the client requests contain
    hypermedia controls, which can help the client decide what is the next action
    they can take. Level 3 encourages easy discoverability and makes it easy for the
    responses to be self-explanatory. There is debate about whether HATEOAS is truly
    RESTful because the representation contains more information beyond just describing
    the resource. We will show details on how some platforms such as PayPal have implemented
    HATEOAS as part of their APIs in [Chapter 5](ch05.html "Chapter 5. Advanced Design
    Principles"), *Advanced Design Principles*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers safety and idempotence, the two important terminologies
    when dealing with RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Safety and idempotence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section discusses in detail what are safe and idempotent methods.
  prefs: []
  type: TYPE_NORMAL
- en: Safe methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Safe methods are methods that do not change the state on the server. For example,
    `GET /v1/coffees/orders/1234` is a safe method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Safe methods can be cached. `GET` and `HEAD` are safe methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` method is not safe as it will create or modify a resource on the server.
    The `POST` method is not safe for the same reasons. The `DELETE` method is not
    safe as it deletes a resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An idempotent method is a method that will produce the same results irrespective
    of how many times it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GET` method is idempotent, as multiple calls to the `GET` resource will
    always return the same response.
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` method is idempotent as calling the `PUT` method multiple times will
    update the same resource and not change the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` is not idempotent and calling the `POST` method multiple times can have
    different results and will result in creating new resources. `DELETE` is idempotent
    because once the resource is deleted, it is gone and calling the method multiple
    times will not change the outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: Design principles for building RESTful services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the process of designing, developing, and testing RESTful services.
    We will cover each of these in detail in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resource URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process involves deciding what nouns will represent your resource.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the methods supported by the resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process involves using the various HTTP methods for CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the different representations supported by the resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This step involves choosing whether the resource representation should be JSON,
    XML, HTML, or plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the RESTful services using JAX-RS APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API needs to be implemented based on the JAX-RS specification
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the service on an application container such as Tomcat, Glassfish, and
    WildFly. The samples show how to create a WAR file and deploy on Glassfish 4.0
    and it can work with any JavaEE 7-compliant container.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the client API for testing the services or use curl-or-browser-based tools
    to test the REST requests.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resource URIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful resources are identified by resource URIs. REST is extensible due to
    the use of URIs for identifying resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows sample URIs, which can represent different resources
    in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URI | Description of the URI |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/library/books` | This is used to represent a collection of book resources
    in a library |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/library/books/isbn/12345678` | This is used to represent a single book
    identified by its ISBN "12345678" |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/coffees` | This is used to represent all the coffees that are sold by
    a coffee shop |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/coffees/orders` | This is used to represent all the coffees that are
    ordered |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/coffees/orders/123` | This is used to represent a single order of coffee
    identified by "123" |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/users/1235` | This is used to represent a user in a system identified
    by "1235" |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/users/5034/books` | This is used to represent all the books for a user
    identified by "5034" |'
  prefs: []
  type: TYPE_TB
- en: 'All the preceding samples show a clear readable pattern, which can be interpreted
    by the client. All these resources could have multiple representations. These
    examples of resources shown in the preceding table can be represented by JSON,
    XML, HTML, or plain text and can be manipulated by HTTP methods: `GET`, `PUT`,
    `POST`, and `DELETE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the methods supported by the resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP verbs comprise a major portion of the uniform interface constraint, which
    defines the association between the actions identified by the verb, to the noun-based
    REST resource.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes HTTP methods and descriptions for the actions
    taken on the resource with a simple example of a collection of books in a library.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP method | Resource URI | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/library/books` | This gets a list of books |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/library/books/isbn/12345678` | This gets a book identified by ISBN
    "12345678" |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/library/books` | This creates a new book order |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/library/books/isbn/12345678` | This deletes a book identified
    by ISBN "12345678" |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/library/books/isbn/12345678` | This updates a specific book identified
    by ISBN "12345678'' |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/library/books/isbn/12345678` | This can be used to do a partial
    update for a book identified by ISBN "12345678" |'
  prefs: []
  type: TYPE_TB
- en: The next section will cover the semantics of each HTTP verb in the context of
    REST.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs and REST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP verbs inform the server what to do with the data sent as part of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `GET` method is the simplest verb of HTTP, which enables us to get access
    to a resource. Whenever the client clicks a URL in the browser, it sends a `GET`
    request to the address specified by the URL. `GET` is safe and idempotent. The
    `GET` requests are cached. Query parameters can be used in `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a simple `GET` request to retrieve all active users is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: POST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`POST` is used to create a resource. The `POST` requests are neither idempotent
    nor safe. Multiple invocations of the `POST` requests can create multiple resources.'
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` requests should invalidate a cache entry if it exists. Query parameters
    with the `POST` requests are not encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `POST` request to create a user can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: PUT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`PUT` is used to update a resource. `PUT` is idempotent but not safe. Multiple
    invocations of the `PUT` requests should produce the same results by updating
    the resource.'
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` requests should invalidate the cache entry if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `PUT` request to update a user can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`DELETE` is used to delete a resource. `DELETE` is idempotent but not safe.
    This is idempotent because based on the RFC 2616, the side effects of N > 0 requests
    is the same as for a single request. This means once the resource is deleted,
    calling `DELETE` multiple times will get the same response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a request to delete a user can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: HEAD
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`HEAD` is similar to the `GET` request. The difference is that only HTTP headers
    are returned and no content is returned. `HEAD` is idempotent and safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a request to send a `HEAD` request with curl is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It can be useful to send a `HEAD` request to see if the resource has changed
    before trying to get a large representation using a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: PUT versus POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to RFC, the difference between `PUT` and `POST` is in the Request
    URI. The URI identified by `POST` defines the entity that will handle the `POST`
    request. The URI in the `PUT` request includes the entity in the request.
  prefs: []
  type: TYPE_NORMAL
- en: So, `POST /v1/coffees/orders` means to create a new resource and return an identifier
    to describe the resource. In contrast, `PUT /v1/coffees/orders/1234` means to
    update a resource identified by `"1234"` if it exists; else create a new order
    and use the `orders/1234` URI to identify it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PUT` and `POST` can both be used to create or update methods. The usage of
    the method depends on the idempotence behavior expected from the method as well
    as the location of the resource to identify it.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover how to identify the different representations of
    the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the different representations of the resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RESTful resources are abstract entities, which need to be serialized to
    a representation before they can be communicated to the client. The common representations
    for a resource can be XML, JSON, HTML, or plain text. A resource can provide the
    representation to the client based on what the client can handle. A client can
    specify which language and media type it prefers. This is known as **content negotiation**.
    [Chapter 2](ch02.html "Chapter 2. Resource Design"), *Resource Design*, covers
    the content negotiation topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have some idea on designing RESTful resources and associating HTTP
    verbs to take actions on the resources, we will cover what it takes to implement
    the APIs and build a RESTful service. This section will cover the following topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Java API for RESTful Services (JAX-RS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java API for RESTful Services (JAX-RS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java API for RESTful services provides portable APIs for building and developing
    applications based on the REST architectural style. Using JAX-RS, Java POJOs can
    be exposed as RESTful web resources, which are independent of the underlying technology
    and use a simple annotation-based API.
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS 2.0 is the latest version of the specification and has newer features
    compared to its predecessor JAX-RS 1.0, especially in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Bean validation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client API support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous invocation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jersey is the implementation of JAX-RS specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover all these topics in detail in the subsequent chapters. We are
    demonstrating a simple coffee shop example where you can create a REST resource
    called `CoffeesResource`, which can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Give details of the orders placed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get details on a specific order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a RESTful resource, we begin with a POJO called `CoffeesResource`.
    An example of a JAX-RS resource is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we create a small POJO called `CoffeesResource`.
    We annotate the class with `@Path("v1/coffees")`, which identifies the URI path
    this class serves requests for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define a method called `getCoffeeList()`. This method has the following
    annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@GET`: This indicates that the annotated method represents a HTTP `GET` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PATH`: In this example, the `GET` requests for `v1/coffees/orders` will be
    handled by this `getCoffeeList()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces`: This defines the media types produced by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another method to create an order is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second method of creating an order, we defined a method called `addCoffee()`.
    This method has the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@POST`: This indicates that the annotated method represents the HTTP `POST`
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Consumes`: This defines the media types consumed by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces`: This defines the media types produced by this resource. In our
    preceding snippet, we define the `MediaType.APPLICATION_JSON` that has the `application/json`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ValidateOnExecution`: This specifies which methods should have their parameters
    or return values validated on execution. More details on the `@ValidateOnExecution`
    and `@Valid` annotations will be covered in [Chapter 3](ch03.html "Chapter 3. Security
    and Traceability"), *Security and Traceability*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, we saw with a simple sample on how easy it is to convert a simple POJO
    to a REST resource. Now, we will cover the `Application` subclass, which will
    define the components of a JAX-RS application including the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for a sample `Application` subclass named `CoffeeApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the `getClasses()` method has been overridden
    and we add the `CoffeesResource` class to the `Application` subclass. The `Application`
    classes can be part of `WEB-INF/classes` or `WEB-INF/lib` in the WAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the RESTful services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created the resource and added the meta-information to the Application
    subclass, the next step is to build the WAR file .The WAR file can be deployed
    on any servlet container.
  prefs: []
  type: TYPE_NORMAL
- en: The source for the samples is available as part of the downloadable bundle with
    this book, which will have detailed steps to deploy and run the samples.
  prefs: []
  type: TYPE_NORMAL
- en: Test the RESTful services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can then use the Client API functionality provided by JAX-RS 2.0 to access
    the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Client API with JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing RESTful resources using curl, or a browser-based extension called
    Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Client API with JAX-RS 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX-RS 2.0 had newer Client APIs for accessing RESTful resources. The entry
    point of the client API is `javax.ws.rs.client.Client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the newly introduced Client API in JAX-RS 2.0, the endpoint can be accessed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the default instance of the client is obtained
    using the `ClientFactory.newClient()` method. Using the `target` method, we create
    a `WebTarget` object. These target objects are then used to prepare the request
    by adding the method and the query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to these APIs, the way we would get access to REST resources was like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can see how there has been an improvement in the JAX-RS 2.0 Client-side
    API support to avoid using `HTTPURLConnection` and instead use the fluent Client
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the request is a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `WebTarget.request()` method returns a `javax.ws.rs.client.InvocationBuilder`,
    which takes a `post()` method to invoke a HTTP `POST` request. The `post()` method
    takes an entity from the `Coffee` instance and specifies that the media type is
    `"APPLICATION_XML"`.
  prefs: []
  type: TYPE_NORMAL
- en: A `MessageBodyReaderWriter` implementation is registered with the client. More
    on `MessageBodyReader` and `MessageBodyWriter` will be covered in [Chapter 2](ch02.html
    "Chapter 2. Resource Design"), *Resource Design*.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes some of the main JAX-RS classes/annotations we
    covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: '| Name of annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.Path` | This identifies the URI path that the resource serves
    a method for |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.ApplicationPath` | This is used by a subclass of `Application`
    as a base URI for all URIs supplied by the resources in application |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.Produces` | This defines the media type that the resource can
    produce |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.Consumes` | This defines the media type that the resource can
    consume |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.client.Client` | This defines the entry point for client requests
    |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.ws.rs.client.WebTarget` | This defines a resource target identified
    by the URI |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clients are heavyweight objects that help facilitate the client-side communication
    infrastructure. It is therefore advised to construct only a small number of client
    instances in the application, as initialization as well as disposal of a client
    instance may be a rather expensive operation. Additionally, client instances must
    be properly closed before being disposed to avoid leaking resources.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing RESTful resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following section covers the different ways REST resources can be accessed
    and tested by clients.
  prefs: []
  type: TYPE_NORMAL
- en: cURL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'cURL is a popular command-line tool for testing REST APIs. The cURL library
    and the cURL command give the user the ability to create a request, put it on
    the pipe, and explore the response. The following are a few samples of `curl`
    requests for some basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| curl request | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `curl http://api.foo.com/v1/coffees/1` | This is a simple `GET` request |'
  prefs: []
  type: TYPE_TB
- en: '| `curl -H "foo:bar" http://api.foo.com/v1/coffees` | This is an example of
    a `curl` request for adding request headers using `-H` |'
  prefs: []
  type: TYPE_TB
- en: '| `curl -i http://api.foo.com/v1/coffees/1` | This is an example of a `curl`
    command to view response headers using `-i` |'
  prefs: []
  type: TYPE_TB
- en: '| `curl –X POST -d''{"name":"John Doe","username":"jdoe", "phone":"412-344-5644"}
    http://api.foo.com/v1/users` | This is an example of a `curl` request for a `POST`
    method to create a user |'
  prefs: []
  type: TYPE_TB
- en: Even though cURL is extremely powerful, it has a lot of options to remember
    and use. Sometimes, it helps to use a browser-based tool to develop REST API such
    as Postman or Advanced REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Postman on the Chrome browser is an excellent tool to test and develop REST
    API. It has a JSON and XML viewer for rendering the data. It can also allow previewing
    HTTP 1.1 requests, replay, and organize requests for future use. Postman shares
    the same environment as the browser and can display browser cookies too.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of Postman over cURL is that there is a nice user interface for
    entering parameters so that the user does not need to deal with commands or scripts.
    Various authorization schemes such as a basic user authentication and digest access
    authentication are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot, which shows how to send queries in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/7963OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we see the Postman application. A simple
    way to test Postman is to launch the Postman Application from Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Then, select the HTTP method `GET` and paste the `api.postcodes.io/random/postcodes`
    URL. (PostCodes is a free, open source service based on geodata.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a JSON response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: On the left pane of the preceding screenshot are different queries, which have
    been added to a collection like getting all the coffee orders, getting a specific
    order, creating orders, and so on based on testing the various samples in this
    book. You can create custom collections of queries similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details, check [http://www.getpostman.com/](http://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are some additional tools, which can be very useful when working with REST
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced REST Client
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Advanced REST Client is another Chrome extension based on Google WebToolkit,
    which allows the user to test and develop REST API.
  prefs: []
  type: TYPE_NORMAL
- en: JSONLint
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: JSONLint is a simple online validator that ensures the JSON is valid. When sending
    JSON data as part of requests, it is useful to validate if the format of the data
    conforms to the JSON specification. In such cases, the client can validate the
    input using JSONLint. For more details, check [http://jsonlint.com/](http://jsonlint.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Best practices when designing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section highlights some of the best practices when designing
    RESTful resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The API developer should use nouns to understand and navigate through resources
    and verbs with the HTTP method, for example, the /user/1234/books is better than
    /user/1234/getBook URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use associations in the URIs to identify subresources. For example, to get the
    authors for book 5678, for user 1234, use the following `/user/1234/books/5678/authors`
    URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For specific variations, use query parameters. For example, to get all the books
    with 10 reviews, use `/user/1234/books?reviews_counts=10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow partial responses as part of query parameters if possible. An example
    of this case is to get only the name and age of a user, the client can specify,
    ?fields as a query parameter and specify the list of fields that should be sent
    by the server in the response using the `/users/1234?fields=name,age` URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have defaults for the output format for the response in case the client does
    not specify which format it is interested in. Most API developers choose to send
    JSON as the default response mime type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have camelCase or use `_` for attribute names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support a standard API for counts, for example `users/1234/books/count`, in
    case of collections so that the client can get an idea of how many objects can
    be expected in the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will also help the client with pagination queries. More details on pagination
    will be covered in [Chapter 5](ch05.html "Chapter 5. Advanced Design Principles"),
    *Advanced Design Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: Support a pretty printing option, `users/1234?pretty_print`. Also, it is a good
    practice to not cache queries with a pretty print query parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid chattiness by being as verbose as possible in the response. This is because
    if the server does not provide enough details in the response, the client needs
    to make more calls to get additional details. That is a waste of network resources
    as well as counts against the client's rate limits. More details on rate limiting
    are covered in [Chapter 5](ch05.html "Chapter 5. Advanced Design Principles"),
    *Advanced Design Principles*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links may be useful to review for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RFC 2616**: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Richardson Maturity Model**: [http://www.crummy.com/writing/speaking/2008-QCon/act3.html](http://www.crummy.com/writing/speaking/2008-QCon/act3.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jersey implementation of JAX-RS**: [https://jersey.java.net/](https://jersey.java.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InspectB.in**: [http://inspectb.in/](http://inspectb.in/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman**: [http://www.getpostman.com/](http://www.getpostman.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced REST Client**: [https://code.google.com/p/chrome-rest-client/](https://code.google.com/p/chrome-rest-client/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamentals of REST, CRUD API, and how to design
    RESTful resources. We worked with JAX-RS 2.0-based annotations that can represent
    HTTP methods and Client APIs that can be used to target the resources. Additionally,
    we iterated the best practices when designing RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will dig deeper into the concepts covered here. We will also
    cover topics such as content negotiation, entity providers in JAX-RS 2.0, error
    handling, versioning schemes, and response codes in REST. We will look into techniques
    the server can use to send responses to the client using Streaming or Chunking.
  prefs: []
  type: TYPE_NORMAL
