- en: Chapter 5\. TypeORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every time you use Nest.js in the real world, you need some kind of persistence
    for your data. That is, you need to save the data that the Nest.js app receives
    somewhere, and you need to read data from somewhere so that you can then pass
    that data as a response to the requests that the Nest.js app receives.
  prefs: []
  type: TYPE_NORMAL
- en: That “somewhere” will be, most of the time, a database.
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM is a Object Relational Mapping (ORM) that works with several different
    relational databases. An Object Relational Mapping is a tool that converts between
    objects (such as “Entry” or “Comment,” since we’re building a blog) and tables
    in a database.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this conversion is an entity (called Data Transfer Object) that
    knows how to read data from the database to memory (so you can use the data as
    a response for a request,) as well as how to write to the database from memory
    (so that you are able to store data for later).
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM is conceptually similar to Sequelize. TypeORM is also written in TypeScript
    and uses decorators extensively, so it’s a great match for Nest.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will obviously focus on using TypeORM together with Nest.js, but TypeORM
    can also be used in both the browser and the server side, with traditional JavaScript
    as well as TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM allows you to use both the data mapper pattern, as well as the active
    record pattern. We will focus on the active record pattern as it greatly reduces
    the amount of boilerplate code needed to use in the context of a typical Nest.js
    architecture, like the one explained throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM can also work with MongoDB, though in this case using a dedicated NoSQL
    ORM such as Mongoose is a more common approach.
  prefs: []
  type: TYPE_NORMAL
- en: What database to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeORM supports the following databases:'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MS SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sql.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle (experimental)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering that in this book we are already using PostgreSQL with Sequelize
    and MongoDB with Mongoose, we decided to use MariaDB with TypeORM.
  prefs: []
  type: TYPE_NORMAL
- en: About MariaDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MariaDB is an open source, community-driven project led by some of the original
    developers of MySQL. It was forked from MySQL when Oracle acquired the latter
    with the intention of keeping it free and open under the GNU General Public License.
  prefs: []
  type: TYPE_NORMAL
- en: The original idea of the project was to act as a drop-in replacement for MySQL.
    This remains largely true for version up to 5.5, while MariaDB kept its version
    numbers in sync with the MySQL ones.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, newer versions, starting with versions 10.0, have slightly diverted
    from this approach. It’s still true, though, that MariaDB still focuses on being
    highly compatible with MySQL and sharing the same API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeORM is of course distributed as an npm package. You need to run `npm install
    typeorm @nestjs/typeorm`.
  prefs: []
  type: TYPE_NORMAL
- en: You also need a TypeORM database driver; in this case, we will install the MySQL/MariaDB
    one with `npm install mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM depends on `reflect-metadata` as well, but luckily we had it previously
    installed as Nest.js depends on it too, so there’s nothing else for us to do.
    Keep in mind that you will need to install this dependency too if you’re using
    TypeORM outside of a Nest.js context.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** If you haven’t yet, it’s always a good idea to install Node.js: `npm
    install --save-dev @types/node`.'
  prefs: []
  type: TYPE_NORMAL
- en: Start the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get a database to connect to, we will use Docker Compose, with the
    official MariaDB Docker image, to set up our local development environment. We
    will point to the `latest` Docker image tag, which at the time of writing, corresponds
    to version 10.2.14.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Connect to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a database to connect TypeORM, let’s configure the connection.
  prefs: []
  type: TYPE_NORMAL
- en: We have several ways of configuring TypeORM. The most straightforward one, which
    is great for getting started, is creating a `ormconfig.json` file in the project
    root folder. This file will get grabbed automagically by TypeORM on startup.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example configuration file that suits our usecase (i.e. using Docker
    Compose with the configuration previously proposed).
  prefs: []
  type: TYPE_NORMAL
- en: '**ormconfig.json**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes on the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: The properties `host`, `port`, `username`, `password` and `database` need to
    match the ones specified earlier in the `docker-compose.yml` file; otherwise,
    TypeORM will not be able to connect to the MariaDB Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `synchronize` property tells TypeORM whether to create or update the database
    schema whenever the application starts, so that the schemas match the entities
    declared in the code. Setting this property to `true` can easily lead to loss
    of data, so **make sure you know what you’re doing** before enabling this property
    in production environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize TypeORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the database is running and you are able to successfully establish
    a connection between it and our Nest.js app, we need to instruct Nest.js to use
    TypeORM as a module.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the `@nest/typeorm` package we previously installed, using TypeORM
    inside our Nest.js application is as easy as importing the `TypeOrmModule` in
    our main app module (probably the `app.module.ts` file.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Modelling our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the best thing about using an ORM is that you can take advantage of
    the modelling abstraction that they provide: basically, they allow us to think
    about our data and to shape it with properties (including types and relations),
    generating “object types” (and plugging them to databases tables) that we can
    then use and manipulate as direct interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: This abstraction layer saves you from writing database-specific code like queries,
    joins, etc. A lot of people love not having to struggle with selects and the like;
    so this abstraction layer comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Our first entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with TypeORM, this object abstractions are named *entities.*
  prefs: []
  type: TYPE_NORMAL
- en: An entity is basically a class that is mapped to a database table.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let’s create our first entity, which we will name `Entry`. We
    will use this entity to store entries (posts) for our blog. We will create a new
    file at `src/entries/entry.entity.ts`; that way TypeORM will be able to find this
    entity file since earlier in our configuration we specified that entity files
    will follow the `src/**/*.entity.ts` file naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `@Entity()` decorator from the `typeorm` npm package is used to mark the
    `Entry` class as an entity. This way, TypeORM will know that it needs to create
    a table in our database for these kinds of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Entry` entity is still a bit too simple: we haven’t defined a single property
    for it. We will probably need things like a title, a body, an image and a date
    for our blog entries, right? Let’s do it!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Not bad! Each property we define for our entity is marked with a `@Column`
    decorator. Again, this decorator tells TypeORM how to treat the property: in this
    case, we are asking for each property to be stored in a column of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, this entity will not work with this code. This is because each entity
    needs to have at least one primary column, and we didn’t mark any column as such.
  prefs: []
  type: TYPE_NORMAL
- en: Our best bet is to create an `id` property for each entry and store that on
    a primary column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ah, that’s better! Our first entity is working now. Let’s use it!
  prefs: []
  type: TYPE_NORMAL
- en: Using our models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When having to connect requests to data models, the typical approach in Nest.js
    is building dedicated services, which serve as the “touch point” with each model,
    and to build controllers, which link the services to the requests reaching the
    API. Let’s follow the `model -> service -> controller` approach in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: The service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical Nest.js architecture, the application heavy-lifting is done by
    the services. In order to follow this pattern, create a new `EntriesService`,
    using it to interact with the `Entry` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a new file at: **`src/entries/entries.service.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The most important part of the service is creating a TypeORM repository with
    `Repository<Entry>`, and then injecting it in our constructor with `@InjectRepository(Entry)`.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, in case you’re wondering, repositories are probably the most commonly
    used design pattern when dealing with ORMs, because they allow you to abstract
    the database operations as object collections.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the latest service code, once you have created and injected the
    Entry repository, use it to `.find()` and `.save()` entries from the database,
    among other things. These helpful methods are added when we create a repository
    for the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have taken care of both the data model and the service, let’s write
    the code for the last link: the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a controller for exposing the Entry model to the outside world
    through a RESTful API. The code is really simple, as you can see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a new file at: **`src/entries/entries.controller.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we are using Nest.js dependency injection to make the `EntryService`
    available in our `EntryController`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a new module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step for our new entity endpoint to work is to include the entity,
    the service, and the controller in the app module. Instead of doing this directly,
    we will follow the “separated modules” approach and create a new module for our
    entries, importing all of the necessary pieces there and then importing the whole
    module in the app module.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a new file named: **`src/entries/entries.module.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember when we included the `TypeOrmModule` in the `AppModule` as one of
    the first steps of this chapter? We used the `TypeOrmModule.forRoot()` formula
    there. However, we are using a different one here: `TypeOrmModule.forFeature()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This distinction coming from the Nest.js TypeORM implementation allows us to
    separate different functionalities (“features”) in different modules. This way
    you can adapt your code to some of the ideas and best practices exposed in the
    Architecture chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, let’s import the new `EntriesModule` into the `AppModule`. If you neglect
    this step, your main app module won’t be aware of the existence of the `EntriesModule`
    and your app will not work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/app.module.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now you can fire requests to `/entities` and the endpoint will invoke
    writes and reads from the database.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to give our database a try! We will fire some requests to the endpoints
    that we previously linked to the database and see if everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a GET request to the `/entries` endpoint. Obviously, since
    we haven’t created any entries yet, we should receive an empty array as a response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Success! Let’s retrieve the new entry by ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Yes! Our previous POST request triggered a write in the database and now this
    last GET request is triggering a read from the database, and returning the data
    previously saved!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to retrieve all entries once again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We just confirmed that requests to the `/entries` endpoint successfully executed
    reads and writes in our database. This means that our Nest.js app is usable now,
    since the basic functionality of almost any server application (that is, storing
    data and retrieving it on demand) is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we are now reading from and writing to the database through our
    entity, we only wrote a basic, initial implementation; we should review our code
    to see what can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now go back to the entity file, `src/entries/entry.entity.ts`, and figure
    out what kind of improvements we can do there.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-generated IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the database entries need to have a unique ID. At this point, we are
    simply relying on the ID sent by the client when creating the entity (when sending
    the POST request,) but this is less than desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Any server-side application will be connected to multiple clients, and all of
    those clients have no way of knowing which ID’s are already in use, so it would
    be impossible for them to generate and send a unique ID with each POST request.
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM provides a couple of ways of generating unique ID’s for entities. The
    first one is using the `@PrimaryGeneratedColumn()` decorator. By using it, you
    no longer need to include an ID in the body of the POST request, nor do you need
    to manually generate an ID for an entry before saving it. Instead, the ID is automagically
    generated by TypeORM whenever you ask for a new entry to be saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth mentioning that these unique ID’s will be generated in a sequential
    way, which means that each ID will be one number higher than the highest already
    present in the database (the exact method for generating the new ID will depend
    on the database type.)
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeORM can go one step further, though: if you pass the `"uuid"` argument
    to the `@PrimaryGeneratedColumn()` decorator, the generated value will then look
    like a random collection of letters and numbers with some dashes, making sure
    they’re unique (at least *reasonably* unique.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, remember to change the type of `id` from `number` to `string`!
  prefs: []
  type: TYPE_NORMAL
- en: When was the entry created?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the original entity definition, the `created_at` field was also expected
    to be received from the client. We can, however, improve this easily with some
    more TypeORM magic decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `@CreateDateColumn()` decorator to dynamically generate the insertion
    date for each entry. In other words, you don’t need to set the date from the client
    or create it manually before saving the entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Nice, isn’t it? How about knowing also when the entry was last modified, as
    well as how many revisions have been done to it? Again, TypeORM makes both easy
    to do, and requires no additional code on our side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our entity will now automagically handle for us the modification date, as well
    as the revision number, on each subsequent save operations. You can track changes
    made to each instance of the entity without having to implement a single line
    of code!
  prefs: []
  type: TYPE_NORMAL
- en: Column types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When defining columns in our entities using decorators, as exposed above, TypeORM
    will infer the type of database column from the used property type. This basically
    means that when TypeORM finds a line like the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This maps the `string` property type to a `varchar` database column type.
  prefs: []
  type: TYPE_NORMAL
- en: This will work just fine a lot of the time, but in some occasions we might find
    ourselves in the position of being more explicit about the type of columns to
    be created in the database. Fortunately, TypeORM allows this kind of custom behavior
    with very little overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To customize the column type, pass the desired type as a string argument to
    the `@Column()` decorator. A specific example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The exact column types that can be used depend on the type of database you are
    using.
  prefs: []
  type: TYPE_NORMAL
- en: Column types for `mysql` / `mariadb`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int`, `tinyint`, `smallint`, `mediumint`, `bigint`, `float`, `double`, `dec`,
    `decimal`, `numeric`, `date`, `datetime`, `timestamp`, `time`, `year`, `char`,
    `varchar`, `nvarchar`, `text`, `tinytext`, `mediumtext`, `blob`, `longtext`, `tinyblob`,
    `mediumblob`, `longblob`, `enum`, `json`, `binary`, `geometry`, `point`, `linestring`,
    `polygon`, `multipoint`, `multilinestring`, `multipolygon`, `geometrycollection`'
  prefs: []
  type: TYPE_NORMAL
- en: Column types for `postgres`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int`, `int2`, `int4`, `int8`, `smallint`, `integer`, `bigint`, `decimal`,
    `numeric`, `real`, `float`, `float4`, `float8`, `double precision`, `money`, `character
    varying`, `varchar`, `character`, `char`, `text`, `citext`, `hstore`, `bytea`,
    `bit`, `varbit`, `bit varying`, `timetz`, `timestamptz`, `timestamp`, `timestamp
    without time zone`, `timestamp with time zone`, `date`, `time`, `time without
    time zone`, `time with time zone`, `interval`, `bool`, `boolean`, `enum`, `point`,
    `line`, `lseg`, `box`, `path`, `polygon`, `circle`, `cidr`, `inet`, `macaddr`,
    `tsvector`, `tsquery`, `uuid`, `xml`, `json`, `jsonb`, `int4range`, `int8range`,
    `numrange`, `tsrange`, `tstzrange`, `daterange`'
  prefs: []
  type: TYPE_NORMAL
- en: Column types for `sqlite` / `cordova` / `react-native`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int`, `int2`, `int8`, `integer`, `tinyint`, `smallint`, `mediumint`, `bigint`,
    `decimal`, `numeric`, `float`, `double`, `real`, `double precision`, `datetime`,
    `varying character`, `character`, `native character`, `varchar`, `nchar`, `nvarchar2`,
    `unsigned big int`, `boolean`, `blob`, `text`, `clob`, `date`'
  prefs: []
  type: TYPE_NORMAL
- en: Column types for `mssql`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`int`, `bigint`, `bit`, `decimal`, `money`, `numeric`, `smallint`, `smallmoney`,
    `tinyint`, `float`, `real`, `date`, `datetime2`, `datetime`, `datetimeoffset`,
    `smalldatetime`, `time`, `char`, `varchar`, `text`, `nchar`, `nvarchar`, `ntext`,
    `binary`, `image`, `varbinary`, `hierarchyid`, `sql_variant`, `timestamp`, `uniqueidentifier`,
    `xml`, `geometry`, `geography`'
  prefs: []
  type: TYPE_NORMAL
- en: Column types for `oracle`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`char`, `nchar`, `nvarchar2`, `varchar2`, `long`, `raw`, `long raw`, `number`,
    `numeric`, `float`, `dec`, `decimal`, `integer`, `int`, `smallint`, `real`, `double
    precision`, `date`, `timestamp`, `timestamp with time zone`, `timestamp with local
    time zone`, `interval year to month`, `interval day to second`, `bfile`, `blob`,
    `clob`, `nclob`, `rowid`, `urowid`'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not ready to commit yourself to one specific database type and you’d
    like to keep your options open for the future, it might not be the best idea to
    use a type that’s not available in every database.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL in SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeORM has still one last trick in the hat: a `simple-json` column type that
    can be used in every supported database. With it, you can directly save Plain
    Old JavaScript Objects in one of the relational database columns. Yes, mindblowing!'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put it to use with a new `author` property in the entity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `simple-json` column type allows you to directly store even complex JSON
    trees without needing to define a model for them first. This can come handy in
    situations where you appreciate a bit more flexibility than the traditional relational
    database structure allows.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed the chapter up to this point, you will have a way of saving
    new blog entries to your database through your API and then reading them back.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a second entity to handle comments in each blog entry
    and then create a relationship between entries and comments in such a way that
    one blog entry can have several comments that belong to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the `Comments` entity then.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/comments/comment.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You have probably noticed that the `Comment` entity is quite similar to the
    `Entry` entity.
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be to create a “one-to-many” relationship between entries
    and comments. For that, include a new property in the `Entry` entity with a `@OneToMany()`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: “One-to-many” relationships have to be bi-directional, so you need to add an
    inverse relationship “many-to-one” in the `Comment` entity. This way, both will
    get properly “tied up.”
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/comments/comment.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second argument that we’re passing to both the `@OneToMany()` and the `@ManyToOne()`
    decorators is used to specify the inverse relationship that we’re also creating
    on the other related entity. In other words, in the `Entry` we are saving the
    related `Comment` entity in a property named `comments`. That’s why, in the `Comment`
    entity definition, we pass `entry => entry.comments` as a second argument to the
    decorator, to the point where in `Entry` the comments be stored.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** Not all relationships *need* to be bi-directional. “One-to-one” relationships
    can very well be both uni-directional or bi-directional. In the case of uni-directional
    “one-to-one” relationships, the owner of the relationship is the one declaring
    it, and the other entity wouldn’t need to know anything about the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! Now each of our entries can have several comments.
  prefs: []
  type: TYPE_NORMAL
- en: How to store related entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we talk about code, the most straightforward way of saving a comment that
    belongs to an entry would be to save the comment and then save the entry with
    the new comment included. Create a new `Comments` service to interact with the
    entity, and then modify the `Entry` controller to call that new `Comments` service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how. It’s not as hard as it sounds!
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be our new service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/comments/comments.service.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code sure looks familiar, doesn’t it? It’s very similar to the `EntriesService`
    that we already had, since we are providing quite the same functionality for both
    comments and entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be the modified `Entries` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.controller.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, the new `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Receives both a blog entry and an array of comments that belong to that entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new empty array property (named `comments`) inside the blog entry
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterates over the received comments, saving each one of them and then pushing
    them one by one to the new `comments` property of `entry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, saves the `entry`, which now includes a “link” to each comment inside
    its own `comments` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving related entities the easier way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code we wrote last works, but it’s not very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, TypeORM provides us with a easier way to save related entities,
    though: enabling “cascades”.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting `cascade` to `true` in our entity will mean that we’ll no longer need
    to separately save each related entity; rather, saving the owner of the relationship
    to the database will save those related entities at the same time. This way, our
    previous code can be simplified.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let’s modify our `Entry` entity (which is the owner of the relationship)
    to enable cascade.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This was really easy: we just added a `{cascade: true}` object as third argument
    for the `@OneToMany()` decorator.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will refactor the `create()` method on the `Entries` controller.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.controller.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Please compare the new controller with our previous implementations; we were
    able to get rid of the dependency on the `Comments` service, as well as an iterator
    on the `create()` method. This makes our code shorter and cleaner, which is always
    good as it reduces the risk of introducing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we found out how to save entities that are related one to another,
    while saving their relationship as well. This is a crucial step for the success
    of our related entities. Nice job!
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving related entities in bulk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to save an entity and include its relationships, we’ll
    take a look on how to read both an entity from the database, as well as all their
    related entities.
  prefs: []
  type: TYPE_NORMAL
- en: The idea in this case is that, when we request a blog entry (only one) from
    the database, we also get the comments that belong to it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since you’re familiar with blogs in general (they’ve been around
    for a while, right?), you will be aware that not all blogs load both the blog
    entry and the comments at the same time; many of them load the comments only when
    you reach the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the functionality, however, we will assume that our blogging
    platform will retrieve both the blog entry and the comments at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to modify the `Entries` service to achieve this. Again, it’s going
    to be quite easy!
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.service.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We only added a `{ relations: [''comments''] }` as second argument to the `findOneById()`
    method of the `Entry` repository. The `relations` property of the options object
    is an array, so we can retrieve as many relationships we need to. Also, it can
    be used with any `find()` related method (that is, `find()`, `findByIds()`, `findOne()`
    and so on.)'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with TypeORM, regular relationships (like the ones we have written
    so far) are *eager* relationships. This means that when we read entities from
    the database, the `find*()` methods will return the related entities as well,
    without us needing to write joins or manually read them.
  prefs: []
  type: TYPE_NORMAL
- en: We can also configure our entities to treat relationships as *lazy*, so that
    the related entities are not retrieved from the database until we say so.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved by declaring the type of the field that holds the related
    entity as a `Promise` instead of a direct type. Let’s see the difference in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Of course, using lazy relationships means that we need to change the way we
    save our entity to the database. The next code block demonstrates how to save
    lazy relationships. Pay attention to the `create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.controller.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We made the `create()` method “lazy” by:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a new `resolvedComments` empty array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going through all of the comments received in the request, saving each one and
    then adding it to the `resolvedComments` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all comments are saved, we assign a promise to the `comments` property
    of `entry`, and then immediately resolve it with the array of comments built in
    step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `entry` with the related comments as an already resolved promise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concept of assigning an immediately resolved promise as value of an entity
    before saving is not easy to digest. Still, we need to resort to this because
    of the asynchronous nature of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: That said, be aware that TypeORM support for lazy relationships is still in
    the experimental phase, so use them with care.
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve explored “one-to-many” relationships. Obviously, TypeORM supports
    “one-to-one” and “many-to-many” relationships as well.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just in case you’re not familiar with this kind of relationships, the idea behind
    it is that one instance of an entity, and only one, belongs to one instance, and
    only one, of another entity.
  prefs: []
  type: TYPE_NORMAL
- en: To give a more specific example, let’s imagine that we were going to create
    a new `EntryMetadata` entity to store new things that we want to keep track of,
    like, let’s say, the number of likes a blog entry got from readers and a shortlink
    for each blog entry.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new entity called `EntryMetadata`. We will put the
    file in the `/entry` folder, next to the `entry.entity.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry_metadata.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The entity we just created is quite simple: it only has the regular `uuid`
    property, as well as two other properties for storing `likes` for an entry, and
    also a `shortlink` for it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s tell TypeORM to include one instance of the `EntryMetadata` entity
    in each instance of the `Entry` entity.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed the `@JoinColumn()` decorator. Using this decorator in
    “one-to-one” relationships is required by TypeORM.
  prefs: []
  type: TYPE_NORMAL
- en: Bi-directional one-to-one relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, the relationship between `Entry` and `EntryMetadata` is uni-directional.
    In this case, it is probably enough.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say, however, that we want to have the possibility of accessing an instance
    of `EntryMetadata` directly and then fetch the `Entry` instance it belongs to.
    Well, we can’t do that right now; not until we make the relationship bi-directional.
  prefs: []
  type: TYPE_NORMAL
- en: So, just for the sake of demonstration, we will include the inverse relationship
    in the `EntryMetadata` instance to the `Entry` instance, so that you know how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry_metadata.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you don’t include the `@JoinColumn()` decorator on this second entry.
    That decorator should only be used in the owner entity; in our case, in `Entry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second adjustment we need to make is pointing to the location of the related
    entity in our original `@OneToOne()` decorator. Remember, we just saw that this
    needs to be done by passing a second argument to the decorator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now we have a beautiful, working bi-directional one-to-one relationship
    between the `Entry` and the `EntryMetadata` entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, if you’re wondering how could we save and then retrieve this two
    related entities, I’ve got good news for you: it works the same way that we saw
    with one-to-many relationships. So, either do it by hand as exposed earlier in
    this chapter, or (my personal favorite) use “cascades” for saving them, and `find*()`
    to retrieve them!'
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last type of relationship that we can establish for our entities is known
    as “many-to-many.” This means that multiple instances of the owning entity can
    include multiple instances of the owned entity.
  prefs: []
  type: TYPE_NORMAL
- en: A good example might be us wanting to include “tags” to our blog entries. An
    entry might have several tags, and a tag can be used in several blog entries,
    right. That makes the relationship fall under the “many-to-many” typology.
  prefs: []
  type: TYPE_NORMAL
- en: We will save some code here, because these relationships are declared exactly
    the same way than the “one-to-one” relationships, only changing the `@OneToOne()`
    decorator to `@ManyToMany()`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced TypeORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a look at security.
  prefs: []
  type: TYPE_NORMAL
- en: Security first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you went through the Sequelize chapter in this same book, you might be familiar
    with the concept of lifecycle hooks. In that chapter, we are using a `beforeCreate`
    hook to encrypt the users’ passwords before we save them to our database.
  prefs: []
  type: TYPE_NORMAL
- en: In case you’re wondering if such a thing exists also in TypeORM, the answer
    is yes! Though the TypeORM documentation refers to them as “listeners” instead.
  prefs: []
  type: TYPE_NORMAL
- en: So, to demonstrate its functionality, let’s write a very simple `User` entity
    with a username and a password, and we will make sure to encrypt the password
    before we save it to the database. The specific listener we will be using is called
    `beforeInsert` in TypeORM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Other listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, a listener is a method that gets triggered upon a specific event
    within TypeORM, be it write-related or read-related. We just learned about the
    `@BeforeInsert()` listener, but we have a few other ones we can take advantage
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@AfterLoad()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeInsert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AfterInsert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AfterUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeRemove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AfterRemove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing and extending entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeORM offers two different ways of reducing code duplication between entities.
    One of them follows the composition pattern, while the other follows the inheritance
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Even though a lot of authors defend favoring composition over inheritance, we
    will expose here the two possibilities and let the reader decide which one fits
    better his/her own particular needs.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way of composing entities in TypeORM is using an artifact known as embedded
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded entities are basically entities with some declared table columns (properties)
    that can be included inside other bigger entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go with the example: after reviewing the code we wrote earlier for the
    entities of both `Entry` and `Comment`, we can easily see that there are (among
    others) three duplicated properties: `created_at`, `modified_at` and `revision`.'
  prefs: []
  type: TYPE_NORMAL
- en: It would be a great idea to create an “embeddable” entity to hold those three
    properties and then embed them into both our original entities. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: We will first create a `Versioning` entity (the name is not great, I know, but
    should work for you to see the idea) with those three duplicated properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/common/versioning.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’re not using the @Entity decorator in this entity. This is because
    it’s not a “real” entity. Think of it as an “abstract” entity, i.e. an entity
    that we will never instantiate directly, but we rather will use to embed it in
    other instantiable entities in order to give them some reusable functionality.
    Or, in other words, composing entities from smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we will embed this new “embeddable” entity into our two original entities.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**`src/comments/comment.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Even in this really simple case, we’ve reduced the two original entities from
    three different properties to only one! In both the `Entry` entity and the `Comment`
    entity, the `versioning` column will be actually replaced by the properties inside
    the `Versioning` embedded entity when we invoke any of their reading or writing
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Entity inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second choice that TypeORM offers for reusing code between our entities
    is using entity inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re already familiar with TypeScript, entity inheritance is quite easy
    to understand (and implement) when you take into account that entities are nothing
    more (and nothing less!) than regular TS classes with some decorators on top.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular example, let’s imagine that our Nest.js-based blog has been
    online for some time, and that it has become quite a success. Now we would like
    to introduce sponsored blog entries so that we can make a few bucks and invest
    them in a few more books.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing is, sponsored entries are going to be a lot like regular entries,
    but with a couple of new properties: sponsor name and sponsor URL.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we might decide, after quite some thought, to extend our original
    `Entry` entity and create a `SponsoredEntry` out of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/sponsored-entry.entity.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That’s about it. Any new instance we create from the `SponsoredEntry` entity
    will have the same columns from the extended `Entry` entity, plus the two new
    columns we defined for `SponsoredEntry`.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeORM brings a caching layer out of the box. We can take advantage of it with
    only a little overhead. This layer is specially useful if you are designing an
    API that expects a lot of traffic and/or you need the best performance you can
    get.
  prefs: []
  type: TYPE_NORMAL
- en: Both cases would benefit increasingly from the cache because we use more complex
    data retrieval scenarios, such as complex `find*()` options, lots of related entities,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: The caching needs to be explicitly activated when connecting to the database.
    In our case so far, this will be the `ormconfig.json` file that we created at
    the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**ormconfig.json**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After activating the caching layer on the connection, we will need to pass
    the `cache` option to our `find*()` methods, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The line of code above will make the `.find()` method to return the cached value
    if it’s present and not expired, or the value from the corresponding database
    table otherwise. So, even if the method is fired three thousand times within the
    expiration time window (see below), only one database query would be actually
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeORM uses a couple of defaults when dealing with caches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default cache lifetime is 1,000 milliseconds (i.e. 1 second.) In case we
    need to customize the expiration time, we just need to pass the desired lifetime
    as value to the `cache` property of the options object. In the case above, `this.entry.find({
    cache: 60000 })` would set a cache TTL of 60 seconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TypeORM will create a dedicated table for the cache in the same database you’re
    already using. The table will be named `query-result-cache`. This is not bad,
    but it can greatly improved if we have a Redis instance available. In that cache,
    we will need to include our Redis connection details in the `ormconfig.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ormconfig.json**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way we can easily improve the performance of our API under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: Building a query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TypeORM’s repository methods for retrieving data from our database greatly
    isolates the complexity of querying away from us. They provide a very useful abstraction
    so that we don’t need to bother with actual database queries.
  prefs: []
  type: TYPE_NORMAL
- en: However, apart from using these various `.find*()` methods, TypeORM also provides
    a way of manually executing queries. This greatly improves flexibility when accessing
    our data, at the cost of demanding us to write more code.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeORM tool for executing queries is the `QueryBuilder`. A very basic example
    could involve refactoring our good old `findOneById()` method in the `EntriesService`
    so that it uses the `QueryBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.service.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Another slightly more complex scenario would be to build a join in order to
    also retrieve the related entities. We will come back once again to the `findOneById()`
    method we just modified to include the related comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**`src/entries/entries.service.ts`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Building our model from a existing database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we have started with a “clean” database, then created our
    models, leaving to TypeORM the task of transforming the models into database columns.
  prefs: []
  type: TYPE_NORMAL
- en: This is the “ideal” situation, but... What if we found ourselves in the opposite
    situations? What if we already had a database with tables and columns populated?
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a nice open source project we can use for that: [typeorm-model-generator](https://github.com/Kononnable/typeorm-model-generator).
    It’s packed as a command line tool and can be run with `npx`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** In case you’re not familiar with it, `npx` is a command that comes
    out of the box with `npm` > 5.2 and that allows us to run npm modules from the
    command line without having to install them first. To use it, you just need to
    prepend `npx` to the regular commands from the tool. We would use `npx ng new
    PROJECT-NAME` on our command line, for example, if we wanted to scaffold a new
    project with Angular CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: When it’s executed, typeorm-model-generator will connect to the specified database
    (it supports roughly the same ones that TypeORM does) and will generate entities
    following the settings we pass as command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a useful tool for only some very specific use cases, we will leave
    the configuration details out of this book. However, if you find yourself using
    this tool, go ahead and check [its GitHub repository](https://github.com/Kononnable/typeorm-model-generator).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeORM is a very useful tool and enables us to do a lot of heavy lifting when
    dealing with databases, while greatly abstracting things like data modelling,
    queries, and complex joins, thus simplifying our code.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very suitable for being used in Nest.js-based projects thanks to the
    great support the framework provides through the `@nest/typeorm` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the things that we covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: The database types supported by TypeORM and some hints on how to choose one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to connect TypeORM to your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an entity and how to create your first one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data from your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging TypeORM to make it easier working with metadata (ID’s, creation and
    modification dates...).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the type of columns in your database to match your needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building relationships between your different entities and how to handle them
    when reading from and writing to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced procedures like reusing code through composition or inheritance;
    hooking into lifecycle events; caching; and building queries by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, we really think the more familiar you grow with Nest.js, the more
    likely you start to feel comfortable writing TypeORM code, since they both look
    alike in a few aspects as their extensive use of TypeScript decorators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we cover Sequelize, which is a promise-based ORM.
  prefs: []
  type: TYPE_NORMAL
