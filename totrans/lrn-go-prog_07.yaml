- en: Chapter 7. Composite Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In prior chapters, you may have caught glimpses of the use of composite types
    such as arrays, slices, maps, and structs in some of the sample code. While early
    exposure to these types may have left you curious, rest assured in this chapter
    you will get a chance to learn all about these composite types. This chapter continues
    what started in [Chapter 4](ch04.html "Chapter 4. Data Types"), *Data Types*,
    with discussions covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The array type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slice type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The struct type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you would find in other languages, Go arrays are containers for storing
    sequenced values of the same type that are numerically indexed. The following
    code snippet shows samples of variables that are assigned array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrtypes.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the types that are assigned to each variable in the previous example
    are specified using the following type format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[<length>]<element_type>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type definition of an array is composed of its length, enclosed within
    brackets, followed by the type of its stored elements. For instance, the `days`
    variable is assigned a type `[7]string`. This is an important distinction as Go''s
    type system considers two arrays, storing the same type of elements but with different
    lengths, to be of different types. The following code illustrates this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even though both variables are arrays with elements of type `string`, the type
    system considers the `days` and `weekdays` variables as different types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later in the chapter, you will see how this type restriction is mitigated with
    the use of the slice type instead of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Array types can be defined to be multi-dimensions. This is done by combining
    and nesting the definition of one-dimensional array types as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrtypes.go
  prefs: []
  type: TYPE_NORMAL
- en: Go does not have a separate type for multi-dimensional arrays. An array with
    more than one dimension is composed of one-dimensional arrays that are nested
    within each other. The next section covers how single and multi-dimensional arrays
    are initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Array initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an array variable is not explicitly initialized, all of its elements will
    be assigned the zero-value for the declared type of the elements. An array can
    be initialized with a composite literal value with the following general format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<array_type>{<comma-separated list of element values>}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value for an array is composed of the array type definition (discussed
    in the previous section) followed by a set of comma-separated values, enclosed
    in curly brackets, as illustrated by the following code snippet, which shows several
    arrays being declared and initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrinit.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of elements in the literal must be less than or equal to the size
    declared in the array type. If the array defined is multi-dimensional, it can
    be initialized using literal values by nesting each dimension within the enclosing
    brackets of another, as shown in the following example snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrinit.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows two additional ways that array literals can be
    specified. The length of an array may be omitted and replaced by ellipses during
    initialization. The following will assign type `[5]string` to variable `weekdays`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The literal value of an array can also be indexed. This is useful if you want
    to initialize only certain array elements while allowing others to be initialized
    with their natural zero-value. The following specifies the initial values for
    elements at positions 0, `2`, `4`, `6`, `8`. The remaining elements will be assigned
    the empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Declaring named array types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of an array can become awkward for reuse. For each declaration, it
    becomes necessary to repeat the declaration, which can be error prone. The way
    to handle this idiomatically is to alias array types using type declarations.
    To illustrate how this works, the following code snippet declares a new named
    type, `matrix`, using a multi-dimension array as its underlying type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrtype_dec.go
  prefs: []
  type: TYPE_NORMAL
- en: The declared named type, `matrix`, can be used in all contexts where its underlying
    array type is used. This allows a simplified syntax that promotes reuse of the
    complex array type.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are static entities that cannot grow or shrink in size once they are
    declared with a specified length. Arrays are a great option when a program needs
    to allocate a block of sequential memory of a predefined size. When a variable
    of an array type is declared, it is ready to be used without any further allocation
    semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the following declaration of the `image` variable would allocate a memory
    block composed of 256 adjacent `int` values initialized with zeroes, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Using arrays](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to C and Java, Go uses the square brackets index expression to access
    values stored in an array variable. This is done by specifying the variable identifier
    followed by an index of the element enclosed within the square brackets, as shown
    in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous code updates the fifth element and prints the first element in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: Array length and capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The built-in `len` function returns the declared length of an array type. The
    built-in `cap` function can be used on an array to return its capacity. For instance,
    in the following source snippet, the array `seven` of type `[7]string` will return
    `7` as its length and capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For arrays, the `cap()` function always returns the same value as `len()`. This
    is because the maximum capacity of an array value is its declared length. The
    capacity function is better suited for use with the slice type (discussed later
    in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Array traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Array traversal can be done using the traditional `for` statement or with the
    more idiomatic `for…range` statement. The following snippet of code shows array
    traversal done with both the `for` statement, to initialize an array with random
    numbers in `init()`, and the `for` range statement used to realize the `max()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrmax_iter.go
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional `for` statement, the loop's index variable `i` is used to
    access the value of the array using the index expression `num[i]`. In the `for…range`
    statement, in the `max` function, the iterated value is stored in the `val` variable
    with each pass of the loop and the index is ignored (assigned to the blank identifier).
    If you do not understand how *for* statements work, refer to [Chapter 3](ch03.html
    "Chapter 3. Go Control Flow"), *Go Control Flow*, for a thorough explanation of
    the mechanics of loops in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Array as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays values are treated as a single unit. An array variable is not a pointer
    to a location in memory, but rather represents the entire block of memory containing
    the array elements. This has the implications of creating a new copy of an array
    value when the array variable is reassigned or passed in as a function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could have unwanted side effects on memory consumption for a program.
    One fix for is to use pointer types to reference array values. In the following
    example, a named type, `numbers`, is declared to represent array type `[1024 *
    1024]]int`. Instead of taking the array value directly as parameters, functions
    `initialize()` and `max()` receive a pointer of type `*numbers`, as shown in the
    following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arrptr.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code uses the built-in function `new(numbers)` to initialize the
    array elements with their zero values and obtain a pointer to that array as shown
    in `main()`. So when the functions `initialize` and `max` are invoked, they will
    receive the address (a copy of it) of the array instead of the entire 100K-sized
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before changing the subject, it should be noted that a composite literal array
    value can be initialized with the address operator `&` to initialize and return
    a pointer for the array, as shown in the following example. In the snippet, composite
    literal `&galaxies{...}` returns pointer `*galaxies`, initialized with the specified
    element values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/arraddr.go
  prefs: []
  type: TYPE_NORMAL
- en: The array type is a low-level storage construct in Go. Arrays, for instance,
    are usually used as the basis for storage primitives, where there are strict memory
    allocation requirements to minimize space consumption. In more common cases however,
    the slice, covered in the next section, is often used as the more idiomatic way
    of working with sequenced indexed collections.
  prefs: []
  type: TYPE_NORMAL
- en: The slice type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The slice type is commonly used as the idiomatic construct for indexed data
    in Go. The slice is more flexible and has many more interesting characteristics
    than arrays. The slice itself is a composite type with semantics similar to arrays.
    In fact, a slice uses an array as its underlying data storage mechanism. The general
    form of a slice type is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[ ]<element_type>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one obvious difference between a slice and an array type is omission of
    the size in the type declaration, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slicetypes.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The missing size attribute in the slice type indicates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike arrays, the size of a slice is not fixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slice type represents all sets of the specified element type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means a slice can theoretically grow unbounded (though in practice this
    is not true as the slice is backed by an underlying bounded array). A slice of
    a given element type is considered to be the same type regardless of its underlying
    size. This removes the restriction found in arrays where the size determines the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following variables, `months` and `q1`, have the same type
    of `[]string` and will compile with no problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slicetypes.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to arrays, slice types may be nested to create multi-dimensional slices,
    as shown in the following code snippet. Each dimension can independently have
    its own size and must be initialized individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Slice initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slice is represented by the type system as a value (the next section explores
    the internal representation of a slice). However, unlike the array type, an uninitialized
    slice has a zero value of *nil*, which means any attempt to access elements of
    an uninitialized slice will cause a program to panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the simplest ways to initialize a slice is with a composite literal
    value using the following format (similar to an array):'
  prefs: []
  type: TYPE_NORMAL
- en: '*<slice_type>{<comma-separated list of element values>}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value for a slice is composed of the slice type followed by a set
    of comma-separated values, enclosed in curly brackets, that are assigned to the
    elements of the slice. The following code snippet illustrates several slice variables
    initialized with composite literal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/sliceinit.go
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the composite literal value of a slice is expressed using a similar
    form as the array. However, the number of elements provided in the literal is
    not bounded by a fixed size. This implies that the literal can be as large as
    needed. Under the cover though, Go creates and manages an array of appropriate
    size to store the values expressed in the literal.
  prefs: []
  type: TYPE_NORMAL
- en: Slice representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier it was mentioned that the slice value uses an underlying array to store
    data. The name *slice*, in fact, is a reference to a slice of data segment from
    the array. Internally, a slice is represented by a composite value with the followings
    three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| a *pointer* | The pointer is the address of the first element of the slice
    stored in an underlying array. When the slice value is uninitialized, its pointer
    value is nil, indicating that it is not pointing to an array yet.Go uses the pointer
    as the zero value of the slice itself. An uninitialized slice will return nil
    as its zero value. However, the slice value is not treated as a reference value
    by the type system. This means certain functions can be applied to a nil slice
    while others will cause a panic.Once a slice is created, the pointer does not
    change. To point to a different starting point, a new slice must be created. |'
  prefs: []
  type: TYPE_TB
- en: '| a *length* | The length indicates the number of contiguous elements that
    can be accessed starting with the first element. It is a dynamic value that can
    grow up to the capacity of the slice (see capacity next).The length of a slice
    is always less than or equal to its capacity. Attempts to access elements beyond
    the length of a slice, without resizing, will result in a panic. This is true
    even when the capacity is larger than the length. |'
  prefs: []
  type: TYPE_TB
- en: '| a *capacity* | The capacity of a slice is the maximum number of elements
    that may be stored in the slice, starting from its first element. The capacity
    of a slice is bounded by the length of the underlying array. |'
  prefs: []
  type: TYPE_TB
- en: 'So, when the following variable `halfyr` is initialized as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be stored in an array of type `[6]string` with a pointer to the first
    element, a length, and a capacity of `6`, as represented graphically in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slice representation](img/B036376_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to create a slice value is by slicing an existing array or another
    slice value (or pointers to these values). Go provides an indexing format that
    makes it easy to express the slicing operation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<slice or array value>[<low_index>:<high_index>]*'
  prefs: []
  type: TYPE_NORMAL
- en: The slicing expression uses the [`:`] operator to specify the low and high bound
    indices, separated by a colon, for the slice segment.
  prefs: []
  type: TYPE_NORMAL
- en: The *low* value is the zero-based index where the slice segment starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *high* value is the *n^(th)* element offset where the segment stops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows examples of slice expressions by re-slicing the following
    value: `halfyr := []string{"Jan","Feb","Mar","Apr","May","Jun"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `all := halfyr[:]` | Omitting the low and high indices in the expression
    is equivalent to the following:`all := halfyr[0 : 6]`This produces a new slice
    segment equal to the original, which starts at index position 0 and stops at offset
    position `6`:`["Jan","Feb","Mar","Apr","May","Jun"]` |'
  prefs: []
  type: TYPE_TB
- en: '| `q1 := halfyr[:3]` | Here the slice expression omits low index value and
    specifies a slice segment length of `3`. It returns new slice, `["Jan","Feb","Mar"]`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `q2 := halfyr[3:]` | This creates a new slice segment with the last three
    elements by specifying the staring index position of `3` and omitting the high
    bound index value, which defaults to `6`. |'
  prefs: []
  type: TYPE_TB
- en: '| `mapr := halfyr[2:4]` | To clear any confusion about slicing expressions,
    this example shows how to create a new slice with the months `"Mar"` and `"Apr"`.
    This returns a slice with the value `["Mar","Apr"]`. |'
  prefs: []
  type: TYPE_TB
- en: Slicing a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Slicing an existing slice or array value does not create a new underlying array.
    The new slice creates new pointer location to the underlying array. For instance,
    the following code shows the slicing of the slice value `halfyr` into two additional
    slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_reslice.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The backing array may have many slices projecting a particular view of its
    data. The following figure illustrates how slicing in the previous code may be
    represented visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slicing a slice](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that both slices `q1` and `q2` are pointing to different elements in
    the same underlying array. Slice `q1` has an initial length of `3` with a capacity
    of `6`. This implies `q1` can be resized up to `6` elements in total. Slice `q2`,
    however, has a size of `3` and a capacity of `3` and cannot grow beyond its initial
    size (slice resizing is covered later).
  prefs: []
  type: TYPE_NORMAL
- en: Slicing an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, an array can also be sliced directly. When that is the case,
    the provided array value becomes the underlying array. The capacity and the length
    the slices will be calculated using the provided array. The following source snippet
    shows the slicing of an existing array value called months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_reslice_arr.go
  prefs: []
  type: TYPE_NORMAL
- en: Slice expressions with capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, Go''s slice expression supports a longer form where the maximum capacity
    of the slice is included in the expression, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<slice_or_array_value>[<low_index>:<high_index>:max]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *max* attribute specifies the index value to be used as the maximum capacity
    of the new slice. That value may be less than, or equal to, the actual capacity
    of the underlying array. The following example slices an array with the max value
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_reslice_arr.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet creates a new slice value `summer1` with size `3`
    (starting at index position `6` to `9`). The max index is set to position `9`,
    which means the slice has a capacity of `3`. If the max was not specified, the
    maximum capacity would automatically be set to the last position of the underlying
    array as before.
  prefs: []
  type: TYPE_NORMAL
- en: Making a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slice can be initialized at runtime using the built-in function `make`. This
    function creates a new slice value and initializes its elements with the zero
    value of the element type. An uninitialized slice has a nil zero value an indication
    that it is not pointing an underlying array. Without an explicitly initialization,
    with a composite literal value or using the `make()` function, attempts to access
    elements of a slice will cause a panic. The following snippet reworks the previous
    example to use the `make()` function to initialize the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slicemake.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make()` function takes as an argument the type of the slice to be initialized
    and an initial size for the slice. Then it returns a slice value. In the previous
    snippet, `make()` does the followings:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an underlying array of type `[6]string`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates the slice value with length and capacity of `6`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a slice value (not a pointer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After initialization with the `make()` function, access to a legal index position
    will return the zero value for the slice element instead of causing a program
    panic. The `make()` function can take an optional third parameter that specifies
    the maximum capacity of the slice, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slicemake2.go
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet will initialize the `months` variable with a slice value
    with an initial length of `6` and a maximum capacity of `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Using slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest operation to do with a slice value is to access its elements.
    As was mentioned, slices use index notation to access its elements similar to
    arrays. The following example accesses element at index position 0 and updates
    to `15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_use.go
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, it prints the updated value using index expression `h[0]`
    to retrieve the value of the item at position `0`. Note that the slice expression
    with only the index number, `h[0]` for instance, returns the value of the item
    at that position. When, however, the expression includes a colon, say `h[2:]`
    or `h[:6]`, that expression returns a new slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slice traversal can be done using the traditional `for`statement or with the,
    more idiomatic, `for…range` statement as shown in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_loop.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code snippet, function `scale` uses index variable `i` to update
    the values in slice `factor` directly, while function `contains` uses the iteration-emitted
    value stored in `num` to access the slice element. If you need further detail
    on the `for…range` statement, see [Chapter 3](ch03.html "Chapter 3. Go Control
    Flow"), *Go Control Flow*.
  prefs: []
  type: TYPE_NORMAL
- en: Slices as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a function receives a slice as its parameter, the internal pointer of
    that slice points to the underlying array of the slice. Therefore, all updates
    to the slice, within the function, will be seen by the function''s caller. For
    instance, in the following code snippet, all changes to the `vector` parameter
    will be seen by the caller of function `scale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_loop.go
  prefs: []
  type: TYPE_NORMAL
- en: Length and capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go provides two built-in functions to query the length and capacity attributes
    of a slice. Given a slice, its length and maximum capacity can be queried, using
    the `len` and `cap` functions respectively, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Recall that a slice is a value (not a pointer) that has a nil as its zero-value.
    Therefore, the code is able to query the length (and capacity) of an uninitialized
    slice without causing a panic at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Appending to slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The one indispensable feature of slice types is their ability to dynamically
    grow. By default, a slice has a static length and capacity. Any attempt to access
    an index beyond that limit will cause a panic. Go makes available the built-in
    variadic function `append` to dynamically add new values to a specified slice,
    growing its lengths and capacity, as necessary. The following code snippet shows
    how that is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_append.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous snippet starts with a slice with a size and capacity of `3`. The
    `append` function is used to dynamically add new values to the slice beyond its
    initial size and capacity. Internally, `append` will attempt to fit the appended
    values within the target slice. If the slice has not been initialized or has an
    inadequate capacity, append will allocate a new underlying array, to store the
    values of the updated slice.
  prefs: []
  type: TYPE_NORMAL
- en: Copying slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that assigning or slicing an existing slice value simply creates a new
    slice value pointing to the same underlying array structure. Go offers the `copy`
    function, which returns a deep copy of the slice along with a new underlying array.
    The following snippet shows a `clone()` function, which makes a new copy of a
    slice of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_use.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous snippet, the `copy` function copies the content of `v` slice
    into `result`. Both source and target slices must be the same size and of the
    same type or the copy operation will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Strings as slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Internally, the string type is implemented as a slice using a composite value
    that points to an underlying array of rune. This affords the string type the same
    idiomatic treatment given to slices. For instance, the following code snippet
    uses index expressions to extract slices of strings from a given string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_string.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The slice expression on a string will return a new string value pointing to
    its underlying array of runes. The string values can be converted to a slice of
    byte (or slice of rune) as shown in the following function snippet, which sorts
    the characters of a given string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/slice_string.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code shows the explicit conversion of a slice of bytes to a string
    value. Note that each character may be accessed using the index expression.
  prefs: []
  type: TYPE_NORMAL
- en: The map type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go map is a composite type that is used as containers for storing unordered
    elements of the same type indexed by an arbitrary key value. The following code
    snippet shows a variety of map variables declarations with a variety of key types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/maptypes.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet shows several variables declared as maps of different
    types with a variety of key types. In general, map type is specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*map[<key_type>]<element_type>*'
  prefs: []
  type: TYPE_NORMAL
- en: The *key* specifies the type of a value that will be used to index the stored
    elements of the map. Unlike arrays and slices, map keys can be of any type, not
    just `int`. Map keys, however, must be of types that are comparable including
    numeric, string, Boolean, pointers, arrays, struct, and interface types (see [Chapter
    4](ch04.html "Chapter 4. Data Types")*, Data Types*, for discussion on comparable
    types).
  prefs: []
  type: TYPE_NORMAL
- en: Map initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a slice, a map manages an underlying data structure, opaque to its
    user, to store its values. An uninitialized map has a nil zero-value as well.
    Attempts to insert into an uninitialized map will result in a program panic. Unlike
    a slice, however, it is possible to access elements from a nil map, which will
    return the zero value of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other composite types, maps may be initialized using a composite literal
    value of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<map_type>{<comma-separated list of key:value pairs>}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows variable initialization with map composite literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/mapinit.go
  prefs: []
  type: TYPE_NORMAL
- en: The literal mapped values are specified using a colon-separated pair of key
    and value as shown in the previous example. The type of each key and value pair
    must match that of the declared elements in the map.
  prefs: []
  type: TYPE_NORMAL
- en: Making Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to a slice, a map value can also be initialized using the *make* function.
    Using the make function initializes the underlying storage allowing data to be
    inserted in the map as shown in the following short snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/maptypes.go
  prefs: []
  type: TYPE_NORMAL
- en: The `make` function takes as argument the type of the map and it returns an
    initialized map. In the previous example, the `make` function will initialize
    a map of type `map[int]string`. The `make` function can optionally take a second
    parameter to specify the capacity of the map. However, a map will continue to
    grow as needed ignoring the initial capacity specified.
  prefs: []
  type: TYPE_NORMAL
- en: Using maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As is done with slice and arrays, index expressions are used to access and
    update the elements stored in maps. To set or update a `map` element, use the
    index expression, on the left side of an assignment, to specify the key of the
    element to update. The following snippet shows an element with the `"Jan"` key
    being updated with the value `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing an element with a given key is done with an index expression, placed
    on the right side of an assignment, as shown in the following example, where the
    value indexed with the `"Mar"` key is assigned the `val` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier it was mentioned that accessing a non-existent key will return the
    zero-value for that element. For instance, the previous code would return 0 if
    the element with the key `"Mar"` does not exist in the map. As you can imagine,
    this can be a problem. How would you know whether you are getting an actual value
    or the zero-value? Fortunately, Go provides a way to explicitly test for the absence
    of an element by returning an optional Boolean value as part of the result of
    an index expression, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/map_use.go
  prefs: []
  type: TYPE_NORMAL
- en: The function in the preceding snippet tests the existence of a key before updating
    its value. Called the *comma-ok* idiom, the Boolean value stored in the `ok` variable
    is set to false when the value is not actually found. This allows the code to
    distinguish between the absence of a key and the zero value of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Map traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for…range` loop statement can be used to walk the content of a map value.
    The `range` expression emits values for both key and element values with each
    iteration. The following code snippet shows the traversal of map `hist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/map_use.go
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration returns a key and its associated element value. Iteration order,
    however, is not guaranteed. The internal map iterator may traverse the map in
    a different order with each run of the program. In order to maintain a predictable
    traversal order, keep (or generate) a copy of the keys in a separate structure,
    such as a slice for instance. During traversal, range over the slice of keys to
    traverse in a predictable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be aware that update done to the emitted value during the iteration
    will be lost. Instead, use an index expression, such as `hist[key]` to update
    an element during iteration. For details on `for…range` loop, refer to [Chapter
    3](ch03.html "Chapter 3. Go Control Flow"), *Go Control Flow*, for a thorough
    explanation of Go `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Map functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the `make` function, discussed earlier, map types support two additional
    functions discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| len(map) | As with other composite types, the built-in `len()` function returns
    the number of entries in a map. For instance, the following would print **3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `len` function will return zero for an uninitialized map. |
  prefs: []
  type: TYPE_NORMAL
- en: '| delete(map, key) | The built-in `delete` function deletes an element from
    a given map associated with the provided key. The following code snippet would
    print **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Maps as parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because a map maintains an internal pointer to its backing storage structure,
    all updates to map parameter within a called function will be seen by the caller
    once the function returns. The following sample shows a call to the `remove` function
    to change the content of a map. The passed variable, `hist`, will reflect the
    change once the `remove` function returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/map_use.go
  prefs: []
  type: TYPE_NORMAL
- en: The struct type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last type discussed in this chapter is Go''s `struct`. It is a composite
    type that serves as a container for other named types known as fields. The following
    code snippet shows several variables declared as structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/structtypes.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the struct type has the following general format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*struct{<field declaration set>}*'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` type is constructed by specifying the keyword `struct` followed
    by a set of field declarations enclosed within curly brackets. In its most common
    form, a field is a unique identifier with an assigned type which follows Go's
    variable declaration conventions as shown in the previous code snippet (`struct`
    also support anonymous fields, covered later).
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to understand that the type definition for a `struct` includes
    all of its declared fields. For instance, the type for the person variable (see
    earlier code snippet) is the entire set of fields in the declaration `struct {
    name string; address struct { street string; city string; state string; postal
    string }}`. Therefore, any variable or expression requiring that type must repeat
    that long declaration. We will see later how that is mitigated by using named
    types for `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing struct fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A struct uses a *selector expression* (or dot notation) to access the values
    stored in fields. For instance, the following would print the value of the `name`
    field of the person struct variable from the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Selectors can be chained to access fields that are nested inside a struct.
    The following snippet would print the street and city for the nested address value
    of a `person` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Struct initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to arrays, structs are pure values with no additional underlying storage
    structure. The fields for an uninitialized struct are assigned their respective
    zero values. This means an uninitialized struct requires no further allocation
    and is ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, a struct variable can be explicitly initialized using a composite
    literal of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<struct_type>{<positional or named field values>}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite literal value for a struct can be initialized by a set of field
    values specified by their respective positions. Using this approach, all field
    values must be provided, to match their respective declared types, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/structinit.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous struct literal, all field values of the `struct` are provided,
    matching their declared field types. Alternatively, the composite literal value
    of a `struct` can be specified using a field indices and their associated value.
    As before, the index (the field name) and its value is separated by a colon, as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/structinit.go
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, field values of the composite literal can be selectively specified
    when the index and its value are provided. For instance, in the initialization
    of the `node` variable, the `edge` field is initialized while `weight` is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring named struct types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attempting to reuse struct types can get unwieldy fast. For instance, having
    to write `struct { name string; address struct { street string; city string; state
    string; postal string }}` to express a struct type, every time it is needed, would
    not scale, would be error prone, and would make for grumpy Go developers. Luckily,
    the proper idiom to fix this is to use named types, as illustrated in the following
    source code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/structtype_dec.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous example binds struct type definitions to the identifiers person
    and address. This allows the struct types to be reused in different contexts without
    the need to carry around the long form of the type definitions. You can refer
    to [Chapter 4](ch04.html "Chapter 4. Data Types"), *Data Types*, to learn more
    about named types.
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previous definitions of struct types involved the use of named fields. However,
    it is also possible to define a field with only its type, omitting the identifier.
    This is known as an anonymous field. It has the effect of embedding the type directly
    into the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is demonstrated in the following code snippet. Both types, `diameter`
    and the name, are embedded as `anonymous` fields in the `planet` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_embed.go
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function in the previous snippet shows how the anonymous fields are
    accessed and updated, as is done in the `planet` struct. Notice the names of the
    embedded types become the field identifiers in the composite literal value for
    the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify field name resolution, Go follows the following rules when using
    anonymous fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the type becomes the name of the field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of an anonymous field may not clash with other field names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use only the unqualified (omit package) type name of imported types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These rules also hold when accessing the fields of embedded structs directly
    using selector expressions, as is shown in the following code snippet. Notice
    the name of the embedded types are resolved as fields names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_embed.go
  prefs: []
  type: TYPE_NORMAL
- en: Promoted fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fields of an embedded struct can be *promoted* to its enclosing type. Promoted
    fields appear in selector expressions without the qualified name of their types,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_embed.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous snippet, the highlighted fields are promoted from the embedded
    type `name` by omitting it from the selector expression. The values of the fields
    `long`, `short`, and `symbol` come from embedded type `name`. Again, this will
    only work if the promotion does not cause any identifier clashes. In case of ambiguity,
    the fully qualified selector expression can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Structs as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that struct variables store actual values. This implies that a new copy
    of a struct value is created whenever a `struct` variable is reassigned or passed
    in as a function parameter. For instance, the following will not update the value
    of name after the call to `updateName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_ptr.go
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be remedied by passing a pointer to the `struct` value of the person
    type, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_ptr2.go
  prefs: []
  type: TYPE_NORMAL
- en: In this version, the `p` variable is declared as `*person` and is initialized
    using the built-in `new()` function. After `updateName()` returns, its changes
    are seen by the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: Field tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last topic on structs has to do with field tags. During the definition of
    a `struct` type, optional `string` values may be added to each field declaration.
    The value of the string is arbitrary and it can serve as hints to tools or other
    APIs that use reflection to consume the tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a definition of the Person and Address structs that are
    tagged with JSON annotation which can be interpreted by Go''s JSON encoder and
    decoder (found in the standard library):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch07/struct_ptr2.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice the tags are represented as raw string values (wrapped within a pair
    of ````). The tags are ignored by normal code execution. However, they can be
    collected using Go's reflection API as is done by the JSON library. You will encounter
    more on this subject in [Chapter 10](ch10.html "Chapter 10. Data IO in Go"), *Data
    IO in Go*, when the book discusses input and output streams.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a lot of ground as it walked through each of the composite
    types found in Go to provide insightful coverage of their characteristics. The
    chapter opened with a coverage of the array type, where readers learned how to
    declare, initialize, and use array values. Next, readers learned all about the
    slice type, specifically the declaration, initialization, and practical examples
    that uses slice index expressions to create new or re-slice existing slices. The
    chapter covered the map type, which included information on map initialization,
    access, update, and traversal. Lastly, the chapter provided information about
    the definition, initialization, and usage of the struct type.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, this is probably one of the longest chapters of the book. However,
    the information covered here will prove to be invaluable as the book continues
    to explore new topics. The next chapter will introduce the idea of using Go to
    support object-like idioms using methods and interfaces.
  prefs: []
  type: TYPE_NORMAL
