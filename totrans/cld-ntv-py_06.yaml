- en: Creating UIs to Scale with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we created webViews for our application and also saw the
    integration between our frontend and backend application, which was very important
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on structuring our frontend. Ideally, each module
    should be responsible for a single thing. As in our main components, we are running
    too many operations within single modules. Besides rendering the different views,
    we have code to make an API request to endpoints and receive, handle, and format
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Flux on React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flux** is a pattern that Facebook created to build consistent and stable
    webapps with React. React doesn''t give you the ability to manage data; rather,
    it simply accepts data through props and components, and further, the components
    process the data.'
  prefs: []
  type: TYPE_NORMAL
- en: The React library doesn't really tell you how to get the components, or where
    to store the data, that's why it's called the **view layer**. In React, we don't
    have a framework as we have in the case of Angular or Backbone. That's where Flux
    comes in. Flux is not really a framework, but it's a pattern that will have you
    building your own views.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a Flux pattern? We have your React components, such as a Tweet component
    and so on, and these components do two things in the Flux pattern--they either
    perform actions or they listen to stores. In our use case, if a user wants to
    post a tweet, the components need to perform actions and actions then interact
    with stores, update the pattern to the API, and give a response to the components.
    The following diagram will give you more clarity on Flux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Flux concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the Flux concepts that you need to understood before moving
    ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actions**: This is the way components interact with API endpoints and update
    them. In our case, we post new tweets using it. Actions pipe the action to the
    dispatcher. It might create multiple actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatcher**: This dispatches every single event that comes in and sends
    it across to every single subscriber, which are basically stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores**: This is an important part of Flux. Components always listen to
    stores for any changes. Say, if you wrote a new tweet, that''s an action, and
    wherever the tweet is updated in the store, an event is fired and the component
    is made aware that it has to be updated with the latest data. If you come from
    the AngularJS world, store is a service, or if you are of Backbone.js, stores
    are nothing but a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: This is used to store the action names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using the `JSX` file instead of `JS`, as there is not much difference--`JS`
    is a standard Javascript and `JSX` is an HTML-like syntax that you can use with
    React to create React components easily and perceptively.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dates to UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we deep dive into Flux, a little thing we need to add to our views is
    the date feature. Earlier, you were seeing the timing of the tweets that are stored
    in the database as the **TZ** format; however, ideally, it should be compared
    with current timings and should be shown in reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do that, we will need to update our `main.jsx` file so that it
    will format our tweets. Add the following code to `main.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our work is done here. Now, our tweet should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building user interfaces with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Flux, we will be defining the responsibility of every module, and it should
    also be single. The React responsibility is to re-render the view when that data
    changes, which is good for us. All we need to do is listen to these data events
    using something like Flux, which will manage our data.
  prefs: []
  type: TYPE_NORMAL
- en: With Flux, you not only separate the responsibility of modules, but also get
    to do a unidirectional flow within your app, and that's why Flux is so popular.
  prefs: []
  type: TYPE_NORMAL
- en: In the Flux loop, for every module, there's always one direction to go through.
    This intentional constraint on the flow is what makes the Flux applications easy
    to design, easy to grow, and easy to manage and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will give you more clarity on the Flux architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the diagram, I have taken reference from the Flux repository ([https://github.com/facebook/flux](https://github.com/facebook/flux)).
  prefs: []
  type: TYPE_NORMAL
- en: Actions and dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with Flux, we have to pick a starting point. It could be anything.
    I find it good to start with the actions. You'll also have to pick a direction
    of flow. You could go clockwise or counterclockwise. Clockwise is probably good
    for you as a starting point, so we'll do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to install the Flux library directly using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding command should be executed from our application directory,
    or you can add it in `package.json` and execute `npm install` to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's begin with action as our starting point, where we will be following
    a single responsibility principle. We'll be creating an actions library to communicate
    with the API, and another action to communicate with the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating the `actions` folder in the static directory. We will
    be saving all our actions in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two actions that need to be performed--it could be listing the
    tweets or adding new tweets--we''ll start with listing the tweets. Create a `Tactions`
    file with the `getAllTweets` function, which should be calling REST API''s to
    get all the tweets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I mentioned that Flux-based applications are easy to design, right? Here's why.
    Because we know this actions module has a single responsibility with a single
    flow--either we provide the API call here or it's better to invoke a module that
    will make all API calls for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Tactions.jsx` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we imported the API module, which will invoke the API's to get
    the tweets.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create `API.jsx` in the static directory with the following code
    snippet to get tweets from the backend server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Sactions` file in the actions directory, which will call the dispatcher
    and define the `actionType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we still need to define the dispatcher. Luckily, Facebook created
    a dispatcher that comes along with the Flux packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, **Dispatcher** is the central hub for your application,
    which dispatched the **Actions** and data for registered callbacks. You can refer
    to the following diagram for a better understanding of the data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file named `dispatcher.jsx`, which will create an instance of
    dispatcher with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now you can import this dispatcher anywhere in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s update our `Sactions.jsx` file, in which you will find the `receivedTweets`
    function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `receivedTweets` function , there are three things to be described.
    Firstly, `rawTweets` will be received from the `getAllTweets` function in `API.jsx`,
    which we need to update as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stores manage the application state by taking control of the data within your
    application, which means stores manage the data, data retrieval methods, dispatcher
    callbacks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have defined our dispatcher, next, we need to identify the subscriber's
    for the change provided by the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate directory in stores in the static directory, which will contain
    all the store definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `TStore` file that will subscribe to any changes emitted by
    the dispatcher. Add the following code to the `TStore` file which does so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have started the tweet action, which sent the API module a
    message to get all the tweets. The API did that and then invoked the server actions
    to pass on the data to the dispatcher. The dispatcher then labeled the data and
    dispatched it. We also created stores that basically manage the data and request
    data from the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, your stores are not connected with our app. The stores are supposed
    to emit changes whenever they occur and, based on that, views will be changed
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, our main component is interested in changes emitted events by the store.
    For now, let's import our store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move forward, let''s see if our complete flow of application is working
    fine. It should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's good practice to keep on checking the user interfaces after you have reached
    a certain stable state of your application creation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on. Currently, we are just dispatching the tweets, next, we need
    to decide what we need to do with these tweets. So, let's first receive the tweets
    and then emit changes to the views accordingly. We will be using emitter to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Emitter** is a part of the events library that we previously installed using
    `npm`. So, we can import it from there. Note how it is not the default export,
    but rather the destructed property on it. Then, our store will be an instance
    of this tweet `EventEmitter` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `TStore.jsx` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wow, that's a lot of code to understand at one time! Let's understand it part
    by part, and the flow of the code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will import the `EventEmitter` library from the events packages
    by using the following import utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will store the received tweets in `_tweets` and update the tweets
    in the `getAll()` function so that, in views, it will show the tweet''s timing
    with reference to the current system time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have also created functions for the views to add and remove the change event
    listener. These two functions will also be just a wrap around the `EventEmitter`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions take `callback` arguments that will be sent by views. These
    functions are basically to add or remove listener for the views to start or stop
    listening to these changes in the store. Add the following code to `TStore.jsx`
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have no errors in the console with all the updated code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to views, that is, the main component where we will create a function
    to pull data from the store and prepare an object for the state of component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write `getAppState()` function in `main.jsx`, which maintains the state
    of the app, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the file extension doesn't really matter, whether it is
    `.js` or `.jsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be calling this function from the `Main` class, and we will also
    call the add and remove listener functions that we created in `main.jsx`, using
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we have to update the `render` function to get the `Tweetslist` state
    to show in view, and it is done using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, we have done pretty much everything now; our tweet should be shown without
    any problems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! Our application is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the architecture diagram of Flux, we have completed the flow
    of Flux once, but we still need to complete the cycle by creating the API's to
    add new tweets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement it by sending a new tweet feature using Flux. We will be making
    a couple of changes in `main.jsx`. In the `render` function, the `Tweetcall` to
    `addTweet` function into following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we will call the `Tweet` component without a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, in the `Tweet` component, we will call the `TActions` module to add
    new tweets. Update the code in the `Tweet` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Render` function in the `Tweet` component remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new `sendTweet` function that will invoke an API call to the endpoint
    URL of the backend application and add it to the backend database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `Taction.jsx` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `API.addTweet` function in `API.jsx`, which will make an API call
    and also update the state of tweetlists as well. Add the following `addTweet`
    function to the `API.jsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Also, we are passing the newly added tweets to the server actions to get them
    dispatched and available for stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new function, `receivedTweet`, which will dispatch them. Use the
    following code snippet to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`ActionTypes` are constantly defined in `constants.jsx` in the static directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `RECEIVED_TWEET``actiontype` case in the tweet store
    to emit changes for the view to take further action. The following is the updated
    `Appdispatcher.register` function defined in `TStore.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are pretty much done with adding a new tweet module using Flux and
    it should work totally fine, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we click on the Tweet Now button, the tweet should be added and it
    should project in the following panel, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to structure our application by using the Flux
    pattern, and we also got an understanding of the different concepts of Flux, such
    as dispatcher, stores, and so on. Flux gives you good patterns to distribute responsibility
    between modules, which really needs to be understood, as we are developing an
    application for the cloud platform, such as AWS, Azure, and so on, so our application
    should be highly responsive. That's all we have from the building user interfaces
    side, but in the coming chapter, we will understand a few important concepts,
    such as event sourcing, and how we can make the application more secure by using
    different authentication methods.
  prefs: []
  type: TYPE_NORMAL
