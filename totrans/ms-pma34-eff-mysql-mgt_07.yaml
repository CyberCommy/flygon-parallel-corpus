- en: Chapter 7. Importing Structure and Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to import data that we may have exported
    for backup or transfer purposes. Exported data may also come from authors of other
    applications, and could contain the whole foundation structure of these applications,
    along with some sample data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current phpMyAdmin version (3.4) can import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files containing MySQL statements (usually having a `.sql` suffix, but not necessarily
    so)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV files (comma-separated values, although the separator is not necessarily
    a comma); these files can be imported by phpMyAdmin itself or via the MySQL `LOAD
    DATA INFILE` statement which enables the MySQL server to handle the data directly
    rather than having phpMyAdmin parse it first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Document Spreadsheet files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML files (generated by phpMyAdmin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary column upload covered in [Chapter 5](ch05.html "Chapter 5. Changing
    Data and Structure") can be said to belong to the import family.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Importing and uploading are synonyms in this context.
  prefs: []
  type: TYPE_NORMAL
- en: In general, an exported file can be imported to the same database it came from
    or to any other database; the XML format is an exception to this and a workaround
    is given in the XML section later in the chapter. Also, a file generated from
    an older phpMyAdmin version should have no problem being imported by the current
    version, but the difference between the MySQL version at time of export and the
    one at time of import might play a bigger role regarding compatibility. It's difficult
    to evaluate how future MySQL releases will change the language's syntax, bringing
    import challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The import feature can be accessed from several panels:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Import** menu available from the home page, the `Database` view, or the
    `Table` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Import files** menu offered inside the Query window (as explained in [Chapter
    11)](ch11.html "Chapter 11. Entering SQL Statements")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default values for the `Import` interface are defined in `$cfg['Import']`.
  prefs: []
  type: TYPE_NORMAL
- en: Before examining the actual import dialog, let us discuss some limits issues.
  prefs: []
  type: TYPE_NORMAL
- en: Limits for the transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we import, the source file is usually on our client machine and, therefore,
    must travel to the server via HTTP. This transfer takes time and uses resources
    that may be limited in the web server's PHP configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using HTTP, we can upload our file to the server using a protocol
    such as FTP, as described in the *Reading files from a web server upload directory*
    section. This method circumvents the web server's PHP upload limits.
  prefs: []
  type: TYPE_NORMAL
- en: Time limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let us consider the time limit. In `config.inc.php`, the `$cfg['ExecTimeLimit']`
    configuration directive assigns, by default, a maximum execution time of 300 seconds
    (five minutes) for any phpMyAdmin script, including the scripts that process data
    after the file has been uploaded. A value of `0` removes the limit, and in theory,
    gives us infinite time to complete the import operation. If the PHP server is
    running in safe mode, modifying `$cfg['ExecTimeLimit']` will have no effect. This
    is because the limits set in `php.ini` or in user-related web server configuration
    files (such as `.htaccess` or virtual host configuration files), take precedence
    over this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the time it effectively takes depends on two key factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Web server load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL server load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time taken by the file, as it travels between the client and the server,
    does not count as execution time as the PHP script only starts to execute after
    the file has been received on the server. Therefore, the `$cfg['ExecTimeLimit']`
    parameter has an impact only on the time used to process data (such as decompression
    or sending it to the MySQL server).
  prefs: []
  type: TYPE_NORMAL
- en: Other limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system administrator can use the `php.ini` file or the web server's virtual
    host configuration file to control uploads on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `upload_max_filesize` parameter specifies the upper limit or maximum file
    size that can be uploaded via HTTP. This one is obvious, but another less obvious
    parameter is `post_max_size`. As HTTP uploading is done via the POST method, this
    parameter may limit our transfers. For more details about the POST method, please
    refer to [http://en.wikipedia.org/wiki/Http#Request_methods](http://en.wikipedia.org/wiki/Http#Request_methods).
  prefs: []
  type: TYPE_NORMAL
- en: The `memory_limit` parameter is provided to prevent web server child processes
    from grabbing too much of the server's memory—phpMyAdmin runs inside a child process.
    Thus, the handling of normal file uploads, especially compressed dumps, can be
    compromised by giving this parameter a small value. Here, no preferred value can
    be recommended; the value depends on the size of uploaded data we want to handle
    and on the size of the physical memory. The memory limit can also be tuned via
    the `$cfg['MemoryLimit']` parameter in `config.inc.php`, as seen in [Chapter 6](ch06.html
    "Chapter 6. Exporting Structure and Data (Backup)").
  prefs: []
  type: TYPE_NORMAL
- en: Finally, file uploads must be allowed by setting `file_uploads` to `On`; otherwise,
    phpMyAdmin won't even show a dialog to choose a file. It would be useless to display
    this dialog as the connection would be refused later by the PHP component of the
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: Handling big export files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the file is too big, there are ways in which we can resolve the situation.
    If the original data is still accessible via phpMyAdmin, we could use phpMyAdmin
    to generate smaller export files, choosing the **Dump some row(s)** dialog. If
    this were not possible, we could use a spreadsheet program or a text editor to
    split the file into smaller sections. Another possibility is to use the **upload
    directory mechanism**, which accesses the directory defined in `$cfg['UploadDir']`.
    This feature is explained later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In recent phpMyAdmin versions, the **Partial import** feature can also solve
    this file size problem. By selecting the **Allow the interruption…** checkbox,
    the import process will interrupt itself if it detects that it is close to the
    time limit. We can also specify a number of queries to skip from the start, in
    case we successfully import a number of rows and wish to continue from that point.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading into a temporary directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On a server, a PHP security feature called `open_basedir` (which limits the
    files that can be opened by PHP to the specified directory tree) can impede the
    upload mechanism. In this case, or for any other reason, when uploads are problematic,
    the `$cfg['TempDir']` parameter can be set with the value of a temporary directory.
    This is probably a sub-directory of phpMyAdmin's main directory, into which the
    web server is allowed to put the uploaded file.
  prefs: []
  type: TYPE_NORMAL
- en: Importing SQL files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any file containing MySQL statements can be imported via this mechanism. This
    format is the more commonly used for backup/restore purposes. The dialog is available
    in the `Server` view, `Database` view, or the `Table` view, via the **Import**
    page, or in the Query window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing SQL files](img/7782_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no relation between the currently selected table (here **author)**
    and the actual contents of the SQL file that will be imported. All the contents
    of the SQL file will be imported, and it is those contents that determine which
    tables or databases are affected. However, if the imported file does not contain
    any SQL statements to select a database, all statements in the imported file will
    be executed on the currently selected database.
  prefs: []
  type: TYPE_NORMAL
- en: Let us try an import exercise. First, we make sure that we have a current SQL
    export file of the `book` table (as explained in [Chapter 6)](ch06.html "Chapter 6. Exporting
    Structure and Data (Backup)"). This export file must contain the structure and
    the data. Then we drop the `book` table—yes, really! We could also simply rename
    it. (Refer to [Chapter 9](ch09.html "Chapter 9. Performing Table and Database
    Operations") for the procedure.)
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to import the file back to the current database (the file could
    be imported for testing in a different database or even on another MySQL server).
    We should be on the **Import** page, where we can see the **File to import** dialog.
    We just have to hit the **Browse** button and choose our file.
  prefs: []
  type: TYPE_NORMAL
- en: phpMyAdmin is able to detect which compression method (if any) has been applied
    to the file. Depending on the phpMyAdmin version, and the extensions that are
    available in the PHP component of the web server, there is variation in the formats
    that the program can decompress.
  prefs: []
  type: TYPE_NORMAL
- en: However, to import successfully, phpMyAdmin must be informed of the character
    set of the file to be imported. The default value is **utf-8**. However, if we
    know that the import file was created with another character set, we should specify
    it here.
  prefs: []
  type: TYPE_NORMAL
- en: A **SQL compatibility mode** selector is available at import time. This mode
    should be adjusted to match the actual data that we are about to import, according
    to the type of server where the data was previously exported.
  prefs: []
  type: TYPE_NORMAL
- en: Another option, **Do not use AUTO_INCREMENT for zero values**, is marked by
    default. If we have a value of zero in a primary key and we want it to stay zero
    instead of being auto-incremented, we should use this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the import, we click on **Go**. The import procedure continues and
    we receive a message: **Import has been successfully finished, 2 queries executed**.
    We can browse our newly-created tables to confirm the success of the import operation.'
  prefs: []
  type: TYPE_NORMAL
- en: An import file may contain the `DELIMITER` keyword. This enables phpMyAdmin
    to mimic the `mysql` command-line interpreter. The `DELIMITER` separator is used
    to delineate the part of the file containing a stored procedure, as these procedures
    can themselves contain semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Importing CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine how to import CSV files. There are two possible
    methods—**CSV** and **CSV using LOAD DATA**. The first method is implemented internally
    by phpMyAdmin and is the recommended one for its simplicity. With the second method,
    phpMyAdmin receives the file to be loaded, and passes it to MySQL. In theory,
    this method should be faster. However, it has more requirements due to MySQL itself
    (refer to the *Requirements* sub-section of the *CSV using LOAD DATA* section).
  prefs: []
  type: TYPE_NORMAL
- en: Differences between SQL and CSV formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, the SQL format contains both structure and data. The CSV file format
    contains data only, so if we import in `Table` view, we must already have an existing
    table in place. This table does not need to have the same structure as the original
    table (from which the data comes); the **Column names** dialog enables us to choose
    which columns are affected in the target table.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 3.4, we can also import a CSV file in `Database` view. In this
    case, phpMyAdmin examines the CSV data and generates a table structure to hold
    this data (with generic column names such as `COL 1, COL 2` and a table name such
    as `TABLE 24)`.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a test file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before trying an import, let us generate an `author.csv` export file from the
    `author` table. We use the default values in the **CSV export** options. We can
    then use the **Empty** option to empty the `author` table—we should avoid dropping
    this table as we still need the table structure. The procedure to empty a table
    is covered in [Chapter 5](ch05.html "Chapter 5. Changing Data and Structure"),
    in the *Deleting all of the rows in a table* section.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the `author` table menu, we select **Import** and then **CSV**.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSV](img/7782_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can influence the behavior of the import in a number of ways. By default,
    importing does not modify existing data (based on primary or unique keys). However,
    the **Replace table data with file** option instructs phpMyAdmin to use `REPLACE`
    statements instead of `INSERT` statements, so that existing rows are replaced
    with the imported data.
  prefs: []
  type: TYPE_NORMAL
- en: Using **Do not abort on INSERT error**, `INSERT IGNORE` statements are generated.
    These cause MySQL to ignore any duplicate key problems during insertion. A duplicate
    key from the import file does not replace existing data, and the procedure continues
    for the next line of CSV data.
  prefs: []
  type: TYPE_NORMAL
- en: We can then specify the character that terminates each column, the character
    that encloses data, and the character that escapes the enclosing character. Usually
    this is **\**.
  prefs: []
  type: TYPE_NORMAL
- en: For **Lines terminated with** option, the **auto** choice should be tried first
    as it detects the end-of-line character automatically. We can also specify manually
    which characters terminate the lines. The usual choice is **\n** for UNIX-based
    systems, **\r\n** for DOS or Windows systems, and **\r** for Mac-based systems
    (up to Mac OS 9). If in doubt, we can use a hexadecimal file editor on our client
    computer (not part of phpMyAdmin) to examine the exact codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, phpMyAdmin expects a CSV file with the same number of columns and
    the same column order as the target table. This can be changed by entering a comma-separated
    list of column names in **Column names**, respecting the source file format. For
    example, let us say our source file contains only the author ID and the author
    name information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We would have to put **id, name** in **Column names** to match the source file.
  prefs: []
  type: TYPE_NORMAL
- en: When we click on **Go**, the import is executed and we get a confirmation. We
    might also see the actual `INSERT` queries generated if the total size of the
    file is not too big.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: CSV using LOAD DATA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this method (only available in the `Table` view), phpMyAdmin relies on
    the server's `LOAD DATA INFILE` or `LOAD DATA LOCAL INFILE` mechanisms to do the
    actual import, instead of processing the data internally. These statements are
    the fastest way for importing text in MySQL. They cause MySQL to start a read
    operation either from a file located on the MySQL server `(LOAD DATA INFILE)`
    or from another place `(LOAD DATA LOCAL INFILE)`, which in this context, is always
    the web server's file system. If the MySQL server is located on a computer other
    than the web server, we won't be able to use the `LOAD DATA INFILE` mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Relying on the MySQL server has some consequences. Using `LOAD DATA INFILE`
    requires that the logged-in user possess a global `FILE` privilege. Also, the
    file itself must be readable by the MySQL server's process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html "Chapter 19. Administrating the MySQL Server") explains
    phpMyAdmin''s interface, which can be used by system administrators to manage
    privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the `LOCAL` modifier in `LOAD DATA LOCAL INFILE` must be allowed by
    the MySQL server and MySQL's client library used by PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `LOAD` methods are available from the phpMyAdmin `LOAD` interface,
    which tries to choose the best possible default option.
  prefs: []
  type: TYPE_NORMAL
- en: Using the LOAD DATA interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We select **Import** from the `author` table menu. Choosing **CSV using LOAD
    DATA** option brings up the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the LOAD DATA interface](img/7782_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The available options have already been covered in the *CSV* section.
  prefs: []
  type: TYPE_NORMAL
- en: In the **File to import** section, we choose our `author.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can choose the `LOAD` method, as discussed earlier, by selecting
    the **Use LOCAL keyword** option. We then click on **Go**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, we can see the confirmation screen as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the LOAD DATA interface](img/7782_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This screen shows the exact **LOAD DATA LOCAL INFILE** statement used. Here
    is what has happened:'
  prefs: []
  type: TYPE_NORMAL
- en: We chose **author.csv**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The contents of this file were transferred over HTTP and received by the web
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The PHP component inside the web server saved this file in a work directory
    (here `/opt/php-upload-tmp/)` and gave it a temporary name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: phpMyAdmin, informed of the location of this working file, built a `LOAD DATA
    LOCAL INFILE` command, and sent it to MySQL. Note that just one query was executed,
    which loaded many rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MySQL server read and loaded the contents of the file into our target table.
    It then returned the number of affected rows **(2)**, which phpMyAdmin displayed
    on the results page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing other formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to SQL and CSV formats, phpMyAdmin can import Open Document Spreadsheet
    and XML files. However, these files need to have been exported by phpMyAdmin itself,
    or closely follow what phpMyAdmin does when exporting.
  prefs: []
  type: TYPE_NORMAL
- en: Open Document Spreadsheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when we export via phpMyAdmin in this format, the **Put column names
    in the first row** option is not marked. This means that the exported file contains
    only data. At import time, a corresponding option **The first line of the file
    contains the table column names** is offered and should not be marked if the file
    does not contain the column names in its first line.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the exported file does contain the column names, we can check this
    option. Therefore, when importing from the `Database` view, phpMyAdmin will do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a table, using the file name `(author.ods)` as the table name `(author)`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the first line's column names as column names for this table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine each column's type and appropriate size, based on the data itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert data into the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are in the `Table` view, only the data will be imported.
  prefs: []
  type: TYPE_NORMAL
- en: Other import options exist to indicate what should be done with empty rows and
    with data containing percentages or currency values.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The amount of structural information that can be created by importing an XML
    file depends on the options that were chosen at export time. Indeed, if the **Tables**
    option of the **Object creation options** dialog was selected, then the exact
    `CREATE TABLE` statement is placed in the exported file. Therefore, the same table
    structure is available in the restored table.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if the **Export contents** option was marked, the whole data is there
    in the XML file ready to be imported back. There are no options available at import
    time as XML is a self-describing format; therefore, phpMyAdmin can correctly interpret
    what is in the file and react appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the original database name is part of the XML export, the current phpMyAdmin
    version only supports importing an XML file into the database from which the export
    originated. To import to a different database, we need to first use a text editor
    and change the database name inside the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Reading files from a web server upload directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get around cases where uploads are completely disabled by a web server's
    PHP configuration, or where upload limits are too small, phpMyAdmin can read upload
    files from a special directory located on the web server's file system.
  prefs: []
  type: TYPE_NORMAL
- en: We first specify the directory name of our choice in the `$cfg['UploadDir']`
    parameter, for example,`'./upload'`. We can also use the `%u` string, as described
    in [Chapter 6](ch06.html "Chapter 6. Exporting Structure and Data (Backup)"),
    to represent the user's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us go back to the **Import** page. We get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The directory you set for upload work cannot be reached**.'
  prefs: []
  type: TYPE_NORMAL
- en: This error message is expected, as the directory does not exist. It is supposed
    to have been created inside the current `phpMyAdmin` installation directory. The
    message might also indicate that the directory exists, but can't be read by the
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP safe mode, the owner of the directory and the owner of the phpMyAdmin-installed
    scripts must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using an SFTP or FTP client, we create the necessary directory, and can now
    upload a file there (for example **book.sql)** bypassing any PHP timeouts or upload
    maximum limits.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the file itself must have permissions that allow the web server to
    read it.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the easiest way is to allow everyone to read the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refreshing the **Import** page brings up the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading files from a web server upload directory](img/7782_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on **Go** should execute the statements located in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic decompression is also available for the files located in the upload
    directory. The file names should have extensions such as `.bz2, .gz, .sql.bz2`,
    or `.sql.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the double extensions `(.sql.bz2)` is a better way to indicate that a
    `.sql` file was produced and then compressed, as we see all the steps used to
    generate this file.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an upload progress bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Especially when importing a large file, it's interesting to have a visual feedback
    on the progression of upload. Please note that the progress bar we are discussing
    here informs us only about the uploading part, which is a subset of the whole
    import operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a JavaScript-enabled browser is a requirement for this feature. Moreover,
    the web server''s PHP component must have the JSON extension and at least one
    of these extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: The well-know APC extension ([http://pecl.php.net/package/APC](http://pecl.php.net/package/APC)),
    which is highly recommended anyway for its opcode caching benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `uploadprogress` extension ([http://pecl.php.net/package/uploadprogress](http://pecl.php.net/package/uploadprogress))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: phpMyAdmin uses AJAX techniques to fetch progress information, then displays
    it as part of the **File to import** dialog. The number of bytes uploaded, total
    number of bytes, and percentage uploaded are displayed under the bar.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring APC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few `php.ini` directives play an important role for upload progress. First,
    the `apc.rfc1867` directive must be set to `On` or `true`, otherwise this extension
    won't be reporting upload progress to the calling script. When set to `On`, this
    extension updates an APC user cache entry with the upload status information.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the frequency of the updates can be set via the `apc.rfc1867_freq` directive,
    which can take the form of a percentage of the total file size (for example, `apc.rfc1867_freq
    = "10%")`, or a size in bytes (suffixes `k` for kilobytes, `m` for megabytes,
    and `g` for gigabytes are accepted). A value of `0` here indicates us to update
    as often as possible, which looks interesting but in reality may slow down the
    upload.
  prefs: []
  type: TYPE_NORMAL
- en: This very notion of update frequency explains why the bar progresses in chunks
    rather than continuously when using this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Various options in phpMyAdmin that allow us to import data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different mechanisms involved in importing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The limits that we might hit when trying a transfer, and ways to bypass these
    limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will explain how to do single-table searches (covering search
    criteria specification) and how to search in the whole database.
  prefs: []
  type: TYPE_NORMAL
