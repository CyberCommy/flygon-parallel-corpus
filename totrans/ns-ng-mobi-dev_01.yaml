- en: Get Into Shape with @NgModule
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to kick things off with some solid project organization
    exercises to prepare us for building an amazing app with NativeScript for Angular.
    We want to give you some insights into a few important and powerful concepts to
    think about as you plan your architecture, to pave your way to a smooth development
    experience with scalability in mind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Combining Angular with NativeScript provides a wealth of useful paradigms and
    tools to construct and plan your app. As often said, with great power comes great
    responsibility, and as awesome as this tech combination is to create amazing apps,
    they can also be used for creating an overengineered and difficult to debug app.
    Let's take a few chapters to walk through some exercises you can use to help avoid
    common pitfalls and truly unlock the full potential of this stack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce you to Angular's `@NgModule` decorator, which we will use
    exclusively to help organize our app's code into logical units with explicit purpose
    and portability in mind. We will also introduce a few Angular concepts we will
    use in our architecture, such as dependency injectable services. After doing our
    diligence in building a solid foundation to work with, we will rapidly approach
    running our app for the first time towards the end of third chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What is NativeScript for Angular?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your native mobile app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Organization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture planning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NgModule` decorator'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Injectable` decorator'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking your app into modules
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mental preparation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving right into coding, you can greatly enhance the development experience
    for your project by mapping out the various services and features your app needs.
    Doing so will help reduce code duplication, frame your data flow, and lead the
    way for rapid feature development in the future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A service is a class that typically handles processing and/or provides data
    to your app. Your usage of these services does not need to know the specifics
    of where the data came from, just that it can ask the service for its purpose
    and it will happen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The sketch exercise
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good exercise for this is to sketch out a rough idea of one of your app views.
    You may not know what it will look like yet and that's okay; this is purely an
    exercise to think about the user expectations as a first step to guiding your
    thought process into the various sections or modules you need to construct to
    meet those expectations. It will also help you think about the various states
    the app needs to manage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, the app we are going to build, **TNSStudio** (**Telerik NativeScript**
    (**TNS**))*.* We will dive into more detail of what our app is and what exactly
    it will do in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00005.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Starting from top to bottom, we can see a header with a menu button, a logo,
    and a record button. Then, we have a listing of user recorded tracks, each with
    a (re)record button and a solo or mute button.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'From this one sketch, we may think about several services the app may need
    to provide:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A Player Service
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Recorder Service
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Persistent Store service to remember which volume level settings the user
    sets for each track in the recording mix and/or if the user is authenticated
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also gain some insight into the various states the app may need to manage:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A listing of user recordings/tracks
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the app is playing audio or not
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the app is in the recording mode or not
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level thinking
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also advantageous to provide some low-level services that provide a convenient
    API to access things, such as HTTP remote requests and/or logging. Doing so will
    allow you to create unique characteristics that you or your team like to work
    with when interacting with low-level APIs. For instance, maybe your backend API requires
    a unique header to be set in addition to a special authentication header for each
    request. Creating a low-level wrapper around an HTTP service will allow you to
    isolate those unique characteristics and provide a consistent API for your app
    to interact with, to guarantee all the API calls are enhanced with what they need
    in one place.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, your team may desire an ability to funnel all the logging code
    to a third-party log analyzer (for debugging or other performance-related metrics).
    Creating low-level wrappers with the lean code around some framework services
    will allow your app to adapt to these potential needs quickly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Modularize with @NgModule
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can then think about breaking these services up into organizational units
    or modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides us with the `@NgModule` decorator, which will help us define
    what these modules look like and what they provide to our app. In an effort to
    keep our app's bootstrap/launch time as fast as possible, we can organize our
    modules in such a way to allow some service/features to be lazily loaded after
    our app has launched. Bootstrapping one module with a small subset of required
    code that our app needs to launch will help keep this launch phase to a minimum.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Our app's module breakdown
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how we will break down our app organization by module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`CoreModule`: Low-level services, components, and utilities that provide a
    nice foundation layer. Things such as interacting with logging, dialogs, HTTP,
    and other various commonly used services.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AnalyticsModule`******: Potentially, you could have a module that provides
    various services to handle analytics for your app.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayerModule`*****: Provides everything our app needs to play audio.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RecorderModule`*****: Provides everything our app needs to record audio.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*(*)*These are considered *Feature Modules.* *(**)*We will omit this module
    from the example in this book but wanted to mention it here for context.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The module benefits
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a similar organization provides several advantageous things for you and
    your team:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**High degree of usability**: By designing a low-level `CoreModule`, you and
    your team have the opportunity to design how you like to work with commonly used
    services, in a unique way, across not only the app you are building now but more
    in the future. You can easily move `CoreModule` into a completely different app
    and gain all the same unique APIs you have designed for this app when working
    with low-level services.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Viewing your own app code as a ''Feature Module''**: Doing so will help you
    focus on just the unique abilities your app should provide outside of what the
    `CoreModule` provides as well as reduce the duplication of the code.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encourages and enhances rapid development**: By confining commonly used functionality
    to our `CoreModule`, we relieve the burden of having to worry about those details
    in our feature modules. We can simply inject those services provided by our `CoreModule`
    and use those APIs and never repeat ourselves.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: In the future, if an underlying detail needs to change
    because of how your app needs to work with a low-level service, it need only be
    changed in one place (in the `CoreModule` service) versus having redundant code
    potentially spread across different sections of your app.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Splitting your app into modules will allow you to load only
    the modules you need at startup, then later, lazily load other features on demand.
    Ultimately, this leads to a faster app startup time.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be thinking, why not just combine the player/recorder modules together
    into one module?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer:** Our app is only going to allow recording when a registered user
    is authenticated. Therefore, it is beneficial to consider the potential of authenticated
    contexts and what features are only accessible to authenticated users (if any).
    This will allow us to further fine tune the loading performance of our app to
    what is needed when it''s needed only.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to assume that you have NativeScript installed properly on your
    computer. If you do not, please follow the install instructions at [https://nativescript.org](https://nativescript.org).
    Once installed, we need to create our app framework using a shell prompt:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `tns` stands for Telerik NativeScript**.** It is the primary **command-line
    user interface** (**CLI**) tool you will use to create, build, deploy, and test
    any NativeScript app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will create a new folder called `TNSStudio`. Inside is your primary
    project folder including everything required to build an app. It will contain
    everything relating to this project. After the project folder has been created,
    you need to do one more thing to have a fully runnable app. That''s, adds the
    runtimes for Android and/or iOS:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are on a Macintosh, you can build for both iOS and Android. If you are
    running on a Linux or Windows device, Android is the only platform you can compile
    for on your local machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Create our module shells
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without writing the implementation of our services yet, we can define what
    our `CoreModule` will generally look like with `NgModule` by starting to define
    what it should provide:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/core/core.module.ts`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Injectable services
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the boilerplate we need for our services. Note here that
    the injectable decorator is imported from Angular to declare that our service
    will be made available through Angular''s **Dependency Injection** (**DI**) system,
    which allows these services to be injected into any class constructor that may
    need it. The DI system provides a nice way to guarantee that these services will
    be instantiated as singletons and shared across our app. It''s also worth noting
    that we could alternatively provide these services on the component level if we
    didn''t want them to be singletons and instead have unique instances created for
    certain branches of our component tree, which will make up our user interface.
    In this case, though, we want these created as singletons. We will be adding the
    following to our `CoreModule`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`LogService`: Service to funnel all our console logging through.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatabaseService`: Service to handle any persistent data our app needs. For
    our app, we will implement the native mobile device**''**s storage options, such
    as application settings, as a simple key/value store. However, you could implement
    more advanced storage options here, such as remote storage through Firebase for
    example.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `app/modules/core/services/log.service.ts`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, create `app/modules/core/services/database.service.ts`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Consistency and standards
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For consistency and to reduce the length of our imports as well as prepare
    for better scalability, let''s also create an `index.ts` file in `app/modules/core/services`,
    which will export a `const` collection of our services as well as export these
    services (in an alphabetical order to keep things tidy):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will follow a similar pattern of the organization throughout the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing CoreModule
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now modify our `CoreModule` to use what we have created. We will take
    this opportunity to also import the `NativeScriptModule` which our app will need
    to work with other NativeScript for Angular features which we will want accessible
    globally for our app. Since we know we will want those features, globally, we
    can also specify that they are exported so when we import and use our `CoreModule`,
    we won''t need to worry about importing `NativeScriptModule` elsewhere. Here''s
    what our `CoreModule` modifications should look like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have a good starting base for our `CoreModule`, the details of which
    we will implement in the following chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a solid foundation for our app in this chapter. You learned how to
    think about your app's architecture in terms of modules. You also learned how
    to utilize Angular's `@NgModule` decorator to frame out these modules. And finally,
    we now have a great base architecture to work from to build our app on top of.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的应用程序打下了坚实的基础。您学会了如何从模块的角度思考应用程序的架构。您还学会了如何利用Angular的`@NgModule`装饰器来构建这些模块。最后，我们现在有了一个很好的基础架构，可以在其上构建我们的应用程序。
- en: Now that you have some of the key concepts under your belt, we can now move
    onto the heart of our app, the feature modules. Let's dive into the main features
    of our app to continue constructing our service layers in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules*. We will soon be creating some views for our app and running
    the app on iOS and Android in [Chapter 3](part0046.html#1BRPS0-289fe2426d594f99a90e4363b2c9c34d),
    *Our First View via Component Building*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了一些关键概念，我们可以继续进入我们应用程序的核心部分，即功能模块。让我们深入了解我们应用程序的主要功能，继续构建我们的服务层在[第2章](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d)中，*功能模块*。我们很快将在[第3章](part0046.html#1BRPS0-289fe2426d594f99a90e4363b2c9c34d)中为我们的应用程序创建一些视图，并在iOS和Android上运行应用程序，*通过组件构建我们的第一个视图*。
