- en: Chapter 9. Linux /proc/kcore Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered Linux binaries and memory as it pertains to userland.
    This book won't be complete, however, if we don't spend a chapter on the Linux
    kernel. This is because it is actually an ELF binary as well. Similar to how a
    program is loaded into memory, the Linux kernel image, also known as **vmlinux**,
    is loaded into memory at boot time. It has a text segment and a data segment,
    overlaid with many section headers that are very specific to the kernel, and which
    you won't see in userland executables. We will also briefly cover LKMs in this
    chapter, as they are ELF files too.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel forensics and rootkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to learn the layout of the Linux kernel image if you want to
    be a true master of kernel forensics in Linux. Attackers can modify the kernel
    memory to create very sophisticated kernel rootkits. There are quite a number
    of techniques out there for infecting a kernel at runtime. To list a few, we have
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `sys_call_table` infection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt handler patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function trampolines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug register rootkits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception table infection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kprobe instrumentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The techniques listed here are the primary methods that are most commonly used
    by a kernel rootkit, which usually infects the kernel in the form of an **LKM**
    (short for **Loadable Kernel Module**). Getting an understanding of each technique
    and knowing where each infection resides within the Linux kernel and where to
    look in the memory are paramount to being able to detect this insidious class
    of Linux malware. Firstly, however, let's take a step back and see what we have
    to work with. Currently, there are a number of tools in the market and in the
    open source world that are capable of detecting kernel rootkits and help in searches
    for memory infections. We will not be discussing those. We will, however, be discussing
    methods that are taken from kernel Voodoo. Kernel Voodoo is a project of mine
    that is still mostly private, with the exception of releasing a few components
    of it to the public, such as **taskverse**. This will be discussed later in this
    chapter, with a link to download it from. It uses some very practical techniques
    for detecting almost any type of kernel infection. The software is based on ideas
    from my original work, named Kernel Detective, which was designed in 2009, and
    for the curious, it can still be found on my website at [http://www.bitlackeys.org/#kerneldetective](http://www.bitlackeys.org/#kerneldetective).
  prefs: []
  type: TYPE_NORMAL
- en: This software works on older 32-bit Linux kernels (2.6.0 to 2.6.32) only; 64-bit
    support was only partially completed. Some of the ideas from this project were
    timeless, however, and I extracted them recently and coupled them with some new
    ideas. The result is Kernel Voodoo, a host intrusion detection system, and kernel
    forensics software that relies on /proc/kcore for advanced memory acquisition
    and analysis. In this chapter, we are going to discuss some of the fundamental
    techniques that it uses, and in some cases, we will employ them manually with
    GDB and /proc/kcore.
  prefs: []
  type: TYPE_NORMAL
- en: stock vmlinux has no symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you have compiled your own kernel, you will not have a readily accessible
    vmlinux, which is an ELF executable. Instead, you will have a compressed kernel
    in `/boot`, usually named `vmlinuz-<kernel_version>`. This compressed kernel image
    can be decompressed, but the result is a kernel executable that has no symbol
    table. This poses a problem for forensics analysts or kernel debugging with GDB.
    The solution for most people in this case is to hope that their Linux distribution
    has a special package with their kernel version having debug symbols. If so, then
    they can download a copy of their kernel that has symbols from the distribution
    repository. In many cases, however, this is not possible, or not convenient for
    one reason or another. Nonetheless, this problem can be remedied with a custom
    utility that I designed and released in 2014\. This tool is called **kdress**,
    because it dresses the kernel symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, it is named after an old tool by Michael Zalewskis, called dress.
    That tool would dress a static executable with a symbol table. This name originates
    from the fact that people run a program called **strip** to remove symbols from
    an executable, and therefore "dress" is an appropriate name for a tool that rebuilds
    the symbol table. Our tool, kdress, simply takes information about symbols from
    either the `System.map` file or `/proc/kallsyms` depending on whichever is more
    readily available. Then, it reconstructs that information into the kernel executable
    by creating a section header for the symbol table. This tool can be found on my
    GitHub profile at [https://github.com/elfmaster/kdress](https://github.com/elfmaster/kdress).
  prefs: []
  type: TYPE_NORMAL
- en: Building a proper vmlinux with kdress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to use the kdress utility to build a vmlinux
    image that can be loaded with GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The utility has created an output file called vmlinux, which has a fully reconstructed
    symbol table. If, for example, we want to locate the `sys_call_table` in the kernel,
    then we can easily find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Having a kernel image with symbols is very important for both debugging and
    forensic analysis. Nearly all forensics on the Linux kernel can be done with GDB
    and `/proc/kcore`.
  prefs: []
  type: TYPE_NORMAL
- en: /proc/kcore and GDB exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/proc/kcore` technique is an interface for accessing kernel memory, and
    is conveniently in the form of an ELF core file that can be easily navigated with
    GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Using GDB with `/proc/kcore` is a priceless technique that can be expanded to
    very in-depth forensics for the skilled analyst. Here is a brief example that
    shows how to navigate `sys_call_table`.
  prefs: []
  type: TYPE_NORMAL
- en: An example of navigating sys_call_table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can look at the first pointer held in `sys_call_table[0]`
    and determine that it contains the address of the syscall function `sys_read`.
    We can then look at the first five instructions of that syscall. This is an example
    of how easy it is to navigate kernel memory using GDB and `/proc/kcore`. If there
    had been a kernel rootkit installed that hooked `sys_read` with function trampolines,
    then displaying the first few instructions would have shown a jump or return to
    another malicious function. Using a debugger in this manner to detect kernel rootkits
    is very useful if you know what to look for. The structural nuances of the Linux
    kernel and how it may be infected are advanced topics and seem esoteric to many
    people. One chapter is not enough to fully demystify all of this, but we will
    cover the methods that may be used to infect the kernel and detect the infections.
    In the following sections, I will discuss a few approaches used to infect the
    kernel from a general standpoint, while giving some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using just GDB and `/proc/kcore`, it is possible to detect every type of infection
    that is mentioned throughout this chapter. Tools such as kernel Voodoo are very
    nice and convenient but are not absolutely necessary to detect deviations from
    a normally operating kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Direct sys_call_table modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional kernel rootkits, such as **adore** and **phalanx**, worked by overwriting
    pointers in `sys_call_table` so that they would point to a replacement function,
    which would then call the original syscall as needed. This was accomplished by
    either an LKM or a program that modified the kernel through `/dev/kmem` or `/dev/mem`.
    On today's Linux systems, for security reasons, these writable windows into memory
    are disabled or are no longer capable of anything but read operations depending
    on how the kernel is configured. There have been other ways of trying to prevent
    this type of infection, such as marking `sys_call_table` as `const` so that it
    is stored in the `.rodata` section of the text segment. This can be bypassed by
    marking the corresponding **PTE** (short for **Page Table Entry**) as writeable,
    or by disabling the write-protect bit in the `cr0` register. Therefore, this type
    of infection is a very reliable way to make a rootkit even today, but it is also
    very easily detected.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting sys_call_table modifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect `sys_call_table` modifications, you may look at the `System.map` file
    or `/proc/kallsyms` to see what the memory address of each system call should
    be. For instance, if we want to detect whether or not the `sys_write` system call
    has been infected, we need to learn the legitimate address of `sys_write` and
    its index within the `sys_call_table`, and then validate that the correct address
    is actually stored there in memory using GDB and `/proc/kcore`.
  prefs: []
  type: TYPE_NORMAL
- en: An example of validating the integrity of a syscall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember that numbers are stored in little endian on x86 architecture. The value
    at `sys_call_table[1]` is equivalent to the correct `sys_write` address as looked
    up in `/proc/kallsyms`. We have therefore successfully verified that the `sys_call_table`
    entry for `sys_write` has not been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel function trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique was originally introduced by Silvio Cesare in 1998\. The idea
    was to be able to modify syscalls without having to touch `sys_call_table`, but
    the truth is that this technique allows any function in the kernel to be hooked.
    Therefore, it is very powerful. Since 1998, a lot has changed; the kernels text
    segments can no longer be modified without disabling the write-protect bit in
    `cr0` or modifying a PTE. The main issue, however, is that most modern kernels
    use SMP, and kernel function trampolines are unsafe because they use non-atomic
    operations such as `memcpy()` every time the patched function is called. As it
    turns out, there are methods for circumventing this problem as well, using a technique
    that I will not discuss here. The real point is that kernel function trampolines
    are actually still being used, and therefore understanding them is still quite
    important.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is considered a safer technique to patch the individual call instructions
    that invoke the original function so that they invoke the replacement function
    instead. This method can be used as an alternative to function trampolines, but
    it may be arduous to find every single call, and this often changes from kernel
    to kernel. Therefore, this method is not as portable.
  prefs: []
  type: TYPE_NORMAL
- en: Example of function trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you want to hijack syscall `SYS_write` and do not want to worry about
    modifying `sys_call_table` directly since it is easily detectable. This can be
    accomplished by overwriting the first 7 bytes of the `sys_write` code with a stub
    that contains code for jumping to another function.
  prefs: []
  type: TYPE_NORMAL
- en: An example code for hijacking sys_write on a 32-bit kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code example replaces the first 6 bytes of `sys_write` with a `push; ret`
    stub, which pushes the address of the new `sys_write` function onto the stack
    and returns to it. The new `sys_write` function can then do any sneaky stuff it
    wants to, although in this example we only print a message to the kernel log buffer.
    After it has done the sneaky stuff, it must remove the trampoline code so that
    it can call untampered sys_write, and finally it puts the trampoline code back
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting function trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, function trampolines will overwrite part of the procedure prologue
    (the first 5 to 7 bytes) of the function that they are hooking. So, to detect
    function trampolines within any kernel function or syscall, you should inspect
    the first 5 to 7 bytes and look for code that jumps or returns to another address.
    Code like this can come in a variety of forms. Here are a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: An example with the ret instruction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Push the target address onto the stack and return to it. This takes up 6 bytes
    of machine code when a 32-bit target address is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An example with indirect jmp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Move the target address into a register for an indirect jump. This takes 7
    bytes of code when a 32-bit target address is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An example with relative jmp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Calculate the offset and perform a relative jump. This takes 5 bytes of code
    when a 32-bit offset is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for instance, we want to validate whether or not the sys_write syscall
    has been hooked with a function trampoline, we can simply examine its code to
    see whether the procedure prologue is still in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first 5 bytes are actually serving as NOP instructions for alignment (or
    possibly space for ftrace probes). The kernel uses certain sequences of bytes
    (0x66, 0x66, 0x66, 0x66, and 0x90). The procedure prologue code follows the initial
    5 NOP bytes, and is perfectly intact. Therefore, this validates that `sys_write`
    syscall has not been hooked with any function trampolines.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt handler patching – int 0x80, syscall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One classic way of infecting the kernel is by inserting a phony system call
    table into the kernel memory and modifying the top-half interrupt handler that
    is responsible for invoking syscalls. In an x86 architecture, the interrupt 0x80
    is deprecated and has been replaced with a special `syscall/sysenter` instruction
    for invoking system calls. Both syscall/sysenter and `int 0x80` end up invoking
    the same function, named `system_call()`, which in-turn calls the selected syscall
    within `sys_call_table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On x86_64, the preceding call instruction takes place after a swapgs in `system_call()`.
    Here is what the code looks like in `entry.S`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `(r/e)ax` register contains the syscall number that is multiplied by `sizeof(long)`
    to get the index into the correct syscall pointer. It is easily conceivable that
    an attacker can `kmalloc()` a phony system call table into the memory (which contains
    some modifications with pointers to malicious functions), and then patch the call
    instruction so that the phony system call table is used. This technique is actually
    quite stealthy because it yields no modifications to the original `sys_call_table`.
    Unfortunately for intruders, however, this technique is still very easy to detect
    for the trained eye.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting interrupt handler patching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect whether the `system_call()` routine has been patched with a call to
    a phony `sys_call_table` or not, simply disassemble the code with GDB and `/proc/kcore`,
    and then find out whether or not the call offset points to the address of `sys_call_table`.
    The correct `sys_call_table` address can be found in `System.map` or `/proc/kallsyms`.
  prefs: []
  type: TYPE_NORMAL
- en: Kprobe rootkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This particular type of kernel rootkit was originally conceived and described
    in great detail in a 2010 Phrack paper that I wrote. The paper can be found at
    [http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html).
  prefs: []
  type: TYPE_NORMAL
- en: This type of kernel rootkit is one of the more exotic brands in that it uses
    the Linux kernels Kprobe debugging hooks to set breakpoints on the target kernel
    function that the rootkit is attempting to modify. This particular technique has
    its limitations, but it can be quite powerful and stealthy. However, just like
    any of the other techniques, if the analyst knows what to look for, then the kernel
    rootkits that use kprobes can be quite easy to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting kprobe rootkits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting the presence of kprobes by analyzing memory is quite easy. When a
    regular kprobe is set, a breakpoint is placed on either the entry point of a function
    (see jprobes) or on an arbitrary instruction. This is extremely easy to detect
    by scanning the entire code segment looking for breakpoints, as there is no reason
    a breakpoint should be placed in the kernel code other than for the sake of kprobes.
    For the case of detecting optimized kprobes, a jmp instruction is used instead
    of a breakpoint (`int3`) instruction. This would be easiest to detect when jmp
    is placed on the first byte of a function, since that is clearly out of place.
    Lastly, there is a simple list of active kprobes in `/sys/kernel/debug/kprobes/list`
    that actually contains a list of kprobes that are being used. However, any rootkit,
    including the one that I demonstrated in phrack, will hide its kprobes from the
    file, so do not rely on it. A good rootkit will also prevent kprobes from being
    disabled in `/sys/kernel/debug/kprobes/enabled`.
  prefs: []
  type: TYPE_NORMAL
- en: Debug register rootkits – DRR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of kernel rootkit uses the Intel Debug registers as a means to hijack
    the control flow. A great Phrack paper was written by *halfdead* on this technique.
    It is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://phrack.org/issues/65/8.html](http://phrack.org/issues/65/8.html).'
  prefs: []
  type: TYPE_NORMAL
- en: This technique is often hailed as ultra-stealth because it requires no modification
    of `sys_call_table`. Once again, however, there are ways of detecting this type
    of infection as well.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting DRR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many rootkit implementations, `sys_call_table` and other common infection
    points do go unmodified, but the `int1` handler does not. The call instruction
    to the `do_debug` function gets patched to call an alternative `do_debug` function,
    as shown in the phrack paper linked earlier. Therefore, detecting this type of
    rootkit is often as simple as disassembling the int1 handler and looking at the
    offset of the `call do_debug` instruction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If `target_address` has the same value as the `do_debug` address found in `System.map`
    or `/proc/kallsyms`, it means that the int1 handler has not been patched and is
    considered clean.
  prefs: []
  type: TYPE_NORMAL
- en: VFS layer rootkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another classic and powerful method of infecting the kernel is by infecting
    the kernel's VFS layer. This technique is wonderful and quite stealthy since it
    technically modifies the data segment in the memory and not the text segment,
    where discrepancies are easier to detect. The VFS layer is very object-oriented
    and contains a variety of structs with function pointers. These function pointers
    are filesystem operations such as open, read, write, readdir, and so on. If an
    attacker can patch these function pointers, then they can take control of these
    operations in any way that they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting VFS layer rootkits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are probably several techniques out there for detecting this type of infection.
    The general idea, however, is to validate the function pointer addresses and confirm
    that they are pointing to the expected functions. In most cases, these should
    be pointing to functions within the kernel and not to functions that exist in
    LKMs. One quick approach to detecting is to validate that the pointers are within
    the range of the kernel's text segment.
  prefs: []
  type: TYPE_NORMAL
- en: An example of validating a VFS function pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Other kernel infection techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other techniques available for hackers for the purpose of infecting
    the Linux kernel (we have not discussed these in this chapter), such as hijacking
    the Linux page fault handler ([http://phrack.org/issues/61/7.html](http://phrack.org/issues/61/7.html)).
    Many of these techniques can be detected by looking for modifications to the text
    segment, which is a detection approach that we will examine further in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: vmlinux and .altinstructions patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my opinion, the single most effective method of rootkit detection can be
    summed up by verifying the code integrity of the kernel in the memory—in other
    words, comparing the code in the kernel memory against the expected code. But
    what can we compare kernel memory code against? Well, why not vmlinux? This was
    an approach that I originally explored in 2008\. Knowing that an ELF executable''s
    text segment does not change from disk to memory, unless it''s some weird self-modifying
    binary, which the kernel is not… or is it? I quickly ran into trouble and was
    finding all sorts of code discrepancies between the kernel memory text segment
    and the vmlinux text segment. This was baffling at first since I had no kernel
    rootkits installed during these tests. After examining some of the ELF sections
    in vmlinux, however, I quickly saw some areas that caught my attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several sections within the Linux kernel binary that contain alternative
    instructions. As it turns out, the Linux kernel developers had a bright idea:
    what if the Linux kernel can intelligently patch its own code segment at runtime,
    changing certain instructions for "memory barriers" based on the specific CPU
    that was detected? This would be a nice idea because fewer stock kernels would
    need to be created for all the different types of CPUs out there. Unfortunately
    for the security researcher who wants to detect any malicious changes in the kernel''s
    code segment, these alternative instructions would have to be understood and applied
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: .altinstructions and .altinstr_replace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two sections that contain the majority of information needed to know
    which instructions in the kernel are getting patched at runtime. There is a great
    article that explains these sections now, which was not available at the time
    of my early research into this area of the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
  prefs: []
  type: TYPE_NORMAL
- en: The general idea, however, is that the `.altinstructions` section contains an
    array of `struct alt_instr` structs. Each one represents an alternative instruction
    record, giving you the location of the original instruction and the location of
    the new instruction that should be used to patch the original. The `.altinstr_replace`
    section contains the actual alternative instructions that are referenced by the
    `alt_instr->repl_offset` member.
  prefs: []
  type: TYPE_NORMAL
- en: From arch/x86/include/asm/alternative.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On older kernels, the first two members gave the absolute addresses of the old
    and new instructions, but on newer kernels, a relative offset is used.
  prefs: []
  type: TYPE_NORMAL
- en: Using textify to verify kernel code integrity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the years, I have designed several tools that detect the integrity of the
    Linux kernel's code segment. This detection technique will obviously work only
    on kernel rootkits that modify the text segment, and most of them do in some way
    or the other. However, there are exceptions such as rootkits that rely only on
    altering the VFS layer, which resides in the data segment and will not be detected
    by verifying the integrity of the text segment. Most recently, the tool that I
    wrote (a part of the kernel Voodoo software suite) is named textify, and it essentially
    compares the text segment of the kernel memory, taken from `/proc/kcore`, against
    the text segment in vmlinux. It parses `.altinstructions` and various other sections,
    such as `.parainstructions`, to learn the locations of code instructions that
    are legally patched. In this way, there are no false positives showing up. Although
    textify is currently not available to the public, the general idea has been explained.
    Therefore, it may be reimplemented by anyone who wishes to attempt the somewhat
    arduous coding procedures necessary to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: An example of using textify to check sys_call_table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first check to make sure that `sys_call_table`
    has not been modified. On modern Linux systems, `sys_call_table` is marked as
    read-only and is therefore stored in the text segment, which is why we can use
    textify to validate its integrity. In the next command, we run textify with the
    `-a` switch, which scans every single byte in the entire text segment for illegal
    modifications. We could have simply run `-a` to begin with since `sys_call_table`
    is included in `-a`, but sometimes, it's nice to scan things by symbol name too.
  prefs: []
  type: TYPE_NORMAL
- en: Using taskverse to see hidden processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Linux kernel, there are a several ways to modify the kernel so that process
    hiding can work. Since this chapter is not meant to be an exegesis on all kernel
    rootkits, I will cover only the most commonly used method and then propose a way
    of detecting it, which is implemented in the taskverse program I made available
    in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, the process IDs are stored as directories within the `/proc` filesystem;
    each directory contains a plethora of information about the process. The `/bin/ps`
    program does a directory listing in `/proc` to see which pids are currently running
    on the system. A directory listing in Linux (such as with `ps` or `ls`) uses the
    `sys_getdents64` system call and the `filldir64` kernel function. Many kernel
    rootkits hijack one of these functions (depending on the kernel version) and then
    insert some code that skips over the directory entry containing the `d_name` of
    the hidden process. As a result, the `/bin/ps` program is unable to find the processes
    that the kernel rootkit deems hidden by skipping over them in the directory listing.
  prefs: []
  type: TYPE_NORMAL
- en: Taskverse techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The taskverse program is a part of the kernel Voodoo package, but I released
    a more elementary version for free that uses only one technique to detect hidden
    processes; however, this technique is still very useful. As we were just discussing,
    rootkits commonly hide the pid-directories in `/proc` so that `sys_getdents64`
    and `filldir64` cannot see them. The most straightforward and obvious approach
    used to see these processes would be to bypass the /proc directory completely
    and follow the task list in the kernel memory to look at each process descriptor
    that is represented by a linked list of `struct task_struct` entries. The head
    of the list pointer can be found by looking up the `init_task` symbol. With this
    knowledge, a programmer with some skill can open up `/proc/kcore` and traverse
    the task list. The details of this code can be viewed in the project itself, which
    is available on my GitHub profile at [https://github.com/elfmaster/taskverse](https://github.com/elfmaster/taskverse).
  prefs: []
  type: TYPE_NORMAL
- en: Infected LKMs – kernel drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered various types of kernel rootkit infections in memory,
    but I think that this chapter begs a section dedicated to explaining how kernel
    drivers can be infected by attackers, and how to go about detecting these infections.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 for infecting LKM files – symbol hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LKMs are ELF objects. To be more specific, they are `ET_REL` files (object
    files). Since they are effectively just relocatable code, the ways to infect them,
    such as hijacking functions, are more limited. Fortunately, there are some kernel-specific
    mechanisms that take place during the load time of the ELF kernel object, the
    process of relocating functions within the LKM, that makes infecting them quite
    easy. The entire method and reasons for it working are described in this wonderful
    phrack paper at [http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html),
    but the general idea is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject or link in the parasite code to the kernel module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the symbol value of `init_module()` to have the same offset/value as
    the evil replacement function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the method used most ubiquitously by attackers on modern Linux systems
    (2.6 to 3.x kernels). There is another method that has not been specifically described
    anywhere else, and I will share it briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Method 2 for infecting LKM files (function hijacking)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LKM files are relocatable code, as previously mentioned, and are therefore quite
    easy to add code to since the parasite can be written in C and then compiled as
    relocatable before linking. After linking the new parasite code, which presumably
    contains a new function (or several functions), the attacker can simply hijack
    any function within the LKM using function trampolines, as described early in
    this chapter. So, the attacker replaces the first several bytes of the target
    function with a jump to the new function. The new function then memcpy's the original
    bytes to the old function before invoking it, and memcpy's the trampoline back
    in place for the next time the hook is to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On newer systems, the write protect bit must be disabled prior to patching the
    text segment, such as with the `memcpy()` calls that are necessary to implement
    function trampolines.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting infected LKMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution to this problem should seem obvious based on the two simple detection
    methods just described. For the symbol hijacking method, you can simply look for
    two symbols that have the same value. In the example shown in the Phrack article,
    the `init_module()` function was hijacked, but the technique should apply to any
    function that the attacker wants to hijack. This is because the kernel handles
    relocations for each one (although I have not tested this theory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the preceding symbol output that `init_module` and `evil` have the
    same relative address. This—right here—is an infected LKM as demonstrated in Phrack
    68 #11\. Detecting functions hijacked with trampolines is also quite simple and
    was already described in section 9.6.3, where we discussed detecting trampolines
    in the kernel. Simply apply the same analysis to the functions in a LKM file,
    which can be disassembled with tools such as objdump.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes on /dev/kmem and /dev/mem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the good old days, hackers were able to modify the kernel using the /dev/kmem
    device file. This file, which gave programmers a raw portal to the kernel memory,
    was eventually subject to various security patches and removed from many distributions.
    However, some distros still have it available to read from, which can be a powerful
    tool for detecting kernel malware, but it is not necessary as long as /proc/kcore
    is available. Some of the best work ever written on patching the Linux kernel
    was conceived by Silvio Cesare, which can be seen in his early writings from 1998
    and can be found on vxheaven or on this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtime kernel kmem patching*: [http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: /dev/mem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been a number of kernel rootkits that used /dev/mem, namely phalanx
    and phalanx2, written by Rebel. This device has also undergone a number of security
    patches. Currently, it is present on all systems for backwards compatibility,
    but only the first 1 MB of memory is accessible, primarily for legacy tools used
    by X Windows.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD /dev/kmem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On some OSes such as FreeBSD, the /dev/kmem device is still available and is
    writable by default. There is even an API specifically designed for accessing
    it, and there's a book called *Writing BSD rootkits* that demonstrates its abilities.
  prefs: []
  type: TYPE_NORMAL
- en: K-ecfs – kernel ECFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the **ECFS** (short for **Extended Core
    File Snapshot**) technology. It is worth mentioning near the end of this chapter
    that I have worked out some code for a kernel-ecfs, which merges vmlinux and `/proc/kcore`
    into a kernel-ecfs file. The result is essentially a file similar to /proc/kcore,
    but one that also has section headers and symbols. In this way, an analyst can
    easily access any part of the kernel, LKMs, and kernel memory (such as the "vmalloc'd"
    memory). This code will eventually become publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: A sneak peek of the kernel-ecfs file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we are demonstrating how `/proc/kcore` has been snapshotted into a file
    called `kcore.img` and given a set of ELF section headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Kernel hacking goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is a vast topic with regards to forensic analysis and reverse
    engineering. There are many exciting ways to go about instrumenting the kernel
    for purposes of hacking, reversing, and debugging, and Linux offers its users
    many entry points into these areas. I have discussed some files and APIs that
    are useful throughout this chapter, but I will also give a small, condensed list
    of things that may be of help in your research.
  prefs: []
  type: TYPE_NORMAL
- en: General reverse engineering and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`/proc/kcore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/kallsyms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot/System.map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/mem` (deprecated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/kmem` (deprecated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU debugger (used with kcore)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced kernel hacking/debugging interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kprobes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ftrace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Papers mentioned in this chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kprobe instrumentation: [http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Runtime kernel* *kmem patching*: [http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LKM infection: [http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Special sections in Linux binaries*: [https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel Voodoo: [http://www.bitlackeys.org/#ikore](http://www.bitlackeys.org/#ikore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of this book, we stepped out of userland binaries and
    took a general look at what types of ELF binaries are used in the kernel, and
    how to utilize them with GDB and `/proc/kcore` for memory analysis and forensics
    purposes. We also explained some of the most common Linux kernel rootkit techniques
    that are used and what methods can be applied to detect them. This small chapter
    serves only as a primary resource for understanding the fundamentals, but we just
    listed some excellent resources so that you can continue to expand your knowledge
    in this area.
  prefs: []
  type: TYPE_NORMAL
