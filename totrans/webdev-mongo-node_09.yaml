- en: Testing Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we've been pretty much flying by the seat of our pants
    when it comes to the code we've been writing. We literally had no way of knowing
    whether the code worked until we tested it out in an actual browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with the Mocha test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests with the Chai.js assertion library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spies and stubs with Sinon and Proxyquire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are great for ensuring that your code functions properly, but they're
    also awesome for preventing new, unexpected bugs from suddenly popping up because
    of an innocent little change you made to some unsuspecting code.
  prefs: []
  type: TYPE_NORMAL
- en: The tools of the trade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by taking a look at the various tools and libraries we will use
    to run and write our tests. There are three main concepts that we will need to
    cover before we can actually start writing real tests.
  prefs: []
  type: TYPE_NORMAL
- en: The first is a test runner, or the framework we use to run our suite of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the frameworks follow **Test Driven Development** (**TDD**), and their
    process relies on the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a unit test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It implements the unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes the test and verifies that the test passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second concept is the assertion library itself--the language we use to write
    our tests. A special version of using assertion language to design and build pieces
    of functionality incrementally, guided by an expected behavior, is **Behavior
    Driven Development** (**BDD**).
  prefs: []
  type: TYPE_NORMAL
- en: For both TDD and BDD, we can use the Mocha testing framework; however, we will
    be writing assertions using a special assertion library called `Chai.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll take a look at the idea of spies and stubs, which are fake representatives
    of certain parts of our code that are relied on when we need to track function
    calls to ensure an expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with the Mocha framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for an application, you typically write them in batches that
    are module specific. These batches are referred to as suites or specs. Each suite
    typically contains a batch of tests organized in a way that almost mirrors the
    application itself. With Node, the idea is no different in that each suite of
    tests we write will be specific to an individual module. You'll require the module
    you want to test against and write a collection of tests for each part of the
    module's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you''ll have many different test files testing each and every component
    of your application, you''ll want a way to quickly execute all of the tests. This
    is where the test runner comes in. The test runner that we''ve decided to use
    is called Mocha. You can install Mocha globally, like any other `npm` package,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You might require security privileges when installing on Linux or OS X, which
    can done simply using `sudo` before `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, the Mocha command-line tool is now available. Simply executing
    `mocha` from a command line will execute the test run with a few default options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test runner will look for a folder named `test` and any `.js` file within.
    In our case, we haven''t actually set up any tests yet, so executing `mocha` alone
    won''t accomplish anything; instead, it will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the Mocha test runner does find `.js` files, it executes them like any
    other Node file, except it looks for a few specific keywords within the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some sample code for a typical test block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing Mocha will scan the file for is a `describe` block. A `describe`
    block is a way to define a specific group of test cases in a single line. You
    can have many `describe` blocks in a `test` file, and each `describe` block can
    have many specific tests. In addition, `describe` blocks can be nested as deeply
    as you like to better organize your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Once a `describe` block is found, a few other items are executed within it.
    A `beforeEach` and `afterEach` block is checked to see whether there is any pretest
    work that needs to be executed before each test is executed. Likewise, any clean
    up that needs to occur between tests can be taken care of within the `afterEach`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these blocks are optional and therefore, not required. A good example
    of when you would want to use a `beforeEach` block is if you need to instantiate
    an object that you will be testing--you would want to create a new instance before
    every single test. This way, whatever changes a test might push to the object
    will be reset and will not inadvertently affect any other tests. Likewise, any
    changes you've made during a test to any other related objects can be reset during
    an `afterEach` block.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `describe` block, defining individual tests is done with `it` statements.
    Within each `it` statement, it's generally considered good practice to include
    a single `expect` to assert the actual test (although you can include as many
    `expect` function calls as you like, it's still only considered a single test
    because of the single `it`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using the BDD style syntax when writing our suites, which allows our
    tests to read like user stories. Using the preceding test snippet, you can read
    the tests as `The code should test something` and `The code should test something_else`.
    In fact, if we ran the previous tests, we would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Asserting tests with Chai.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the preceding unit test example, we used special blocks to define
    our test groups with Mocha, but we used a separate language when defining our
    actual individual tests. These tests are called **assertions**, and we chose to
    use the `Chai.js` library. This is purely a personal preference, as there are
    a number of different assertion libraries that exist. Each library does basically
    the same thing, with slight variations on the syntax and style of actually writing
    the tests. Since `Chai.js` is project specific and based on a personal preference,
    we will install it as a project dependency (instead of installing it globally).
    In addition, as our tests are not actually required for our application to run,
    we'll include `Chai.js` under the `devDependencies` list in our `package.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Performing `npm install` on the developer 's machine will yield all packages
    under normal dependencies, as well as `devDependencies` from `package.json`. When
    the environment changes to production, we will need to execute `npm install --prod`
    to specify the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will help `npm` to install packages under dependencies and not `devDependencies`
    from `package.json`. In order to include `Chai.js` in our project as a `devDependency`,
    we will use the `--save-dev` flag instead of `--save` when performing the `npm`
    install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting started with Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chai itself has a few different flavors of API styles that can be used when
    writing tests. The BDD API, which is what we will use for the tests we write,
    uses `expect` and `should`. There's also the assert API, which is more of a TDD
    style. The benefit of using the BDD style with `expect`/`should` is that you can
    chain the assertion methods to improve readability of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about BDD and TDD by accessing the following Wikipedia page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the BDD assertion API with `Chai.js` provides a number of methods at our
    disposal, such as `to`, `be`, `is`, and many more. They have no testing capability,
    but instead they improve the assertion readability. All the getters are listed
    at [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
  prefs: []
  type: TYPE_NORMAL
- en: All of these getters will follow an `expect()` statement and can be coupled
    with `not`, in case we want to flip the assertion negatively.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding getters are combined with the `chai` assertion methods, such as
    `ok`, `equal`, `within`, and so on, to determine a test's outcome. All those methods
    are listed at [http://chaijs.com/api/assert/](http://chaijs.com/api/assert/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start constructing simple assertions.The `chai` provides three different
    assertion styles: `expect`, `should`, and `assert`. Consider the following simple
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `expect`/`should` function is based on self-descriptive
    language chains. Both differ in their way of declaration--the `expect` function
    provides a starting point for a chain, whereas the `should` interface extends
    an `Object.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` interface provides simple but powerful TDD style assertions. Apart
    from the preceding example that yields a deep equality assertion, exception testing,
    and instance are also available. For more in-depth learning, refer to the Chai
    documentation at [http://chaijs.com/api](http://chaijs.com/api).
  prefs: []
  type: TYPE_NORMAL
- en: Spies and stubs with Sinon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing your code will prove to be extremely difficult if there isn't an easy
    way to `spy` on functions and know whenever they are called. Additionally, when
    one of your functions is called, it will be nice to know what arguments were passed
    to it and what was returned. In testing a `spy` is a special placeholder function
    that replaces an existing function when you want to check specifically if/when
    `it` was called. Spies track a number of properties for a function when it's called,
    and they can also pass through the expected functionality of the original function.
    The `Sinon.js` library provides both `spy` and `stub` functionalities and is quite
    extensive. For a complete list of the different options available with this powerful
    framework, I strongly recommend that you spend some time reading the documentation
    at [http://sinonjs.org/docs](http://sinonjs.org/docs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will use `Sinon.js` with our tests, we should install it as another
    `devDependency`, exactly the same way we did with `Chai.js`. In addition, we should
    also install the `sinon-chai` helper, which provides additional `chai` assertion
    verbs, specifically for use with Sinon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The inclusion of `sinon-chai` allows us to write special assertions, such as
    `to.be.calledWith`, which would otherwise not work with `chai` alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a function that simply adds two numbers together and
    returns the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing a test for the `doWork` function, we want to assert that the `sum`
    function was called. We don''t necessarily care what the function does or whether
    it even works; we just want to make sure--since `doWork` relies on `sum`--that
    it''s actually calling the `function()` function. In this scenario, the only way
    we could be sure is if we had a way to spy on the `sum` function and know whether
    it was ever called. Using `spy`, we can do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding scenario, the `sum` function is replaced with a `spy` function.
    So its actual functionalities will no longer exist. If we want to ensure that
    the `sum` function is not only spied on but still functions the way we expect,
    we will need to attach `.andCallThrough()` after `sinon.spy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that by including `andCallThrough` on our `sum` spy, we're able to not
    only spy on it and assert that it was called, but also spy on the `console.log`
    function and assert that it was called with the correct value returned by `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: Where a `spy` is typically just a watcher of a function and only reports whether
    the function was called, a `stub` allows you to provide custom functionalities
    for a function on the fly during test execution. Test stubs are said to be preprogrammed
    behavioral functions that are used to test wrapped boilerplate code required as
    a module dependency in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of `stub` as a super spy, where it reports the same things that a `spy`
    does, but also performs whatever specific tasks you want as well. Using the same
    example, let''s stub the `sum` function to always return the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Stubbing a function is great when a function performs work that might yield
    unexpected results, and you just want to force the response for the purposes of
    your test. Stubbing is also handy when you're doing TDD and you're testing against
    a function that you haven't even written yet.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing node modules with Proxyquire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spies and stubs are great when writing tests against code within the same module,
    but when you need to spy on or stub a module required within another Node module,
    things get a little trickier. Fortunately, there's a tool called **Proxyquire**
    that will allow you to stub modules that are required from your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we require the `request` module. The `request` module accepts
    two parameters, one of which is a `callback` function. This is where things start
    to get tricky. How are we going to implement spies and/or stubs in this type of
    scenario? Furthermore, how can we prevent our tests from explicitly making a network
    call to fetch `google.com`? What if `google.com` is down (ha!) when we run our
    tests?
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to spy on the `request` module, we will need a way to intercept
    actual `require` and attach our own stubbed version of `request` instead. The
    `request` module is actually a great example of a module that you would want to
    stub, because `request` is used to make a network call, and that's something that
    you want to ensure that your tests never actually do. You don't want your tests
    relying on an external resource, such as a network connection or being dependent
    on the data returned from a live request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Proxyquire, we can actually set up our tests in a way that they''ll intercept
    the `require` module and replace what gets executed with our own stub. Here''s
    an example of a test file written against the module we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the test suite does is set up a `spy` and a generic `stub` function
    that will be used as the `request` module. Then, we include our `google` module,
    but we do it using `proxyquire` instead of a typical `require` module. Using `proxyquire`,
    we pass the path to the module the same way we would with `require`, except the
    second parameter is the module that would be required within that module and the
    `stub` function to use in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Before each test, we will execute the original `google` module and assert against
    our `stub` that it was, in fact, called. Additionally, we assert that the `log`
    spy was called with whatever data was returned from the `request` module. Since
    we are in control of that module, we can test, quite literally, that the string
    `google.com` was returned when a request was made to `http://google.com` (which
    we know for a fact is not true--not only that, but we know that a network call
    was never sent to `www.google.com`, either).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using a special power of a `stub` that allows us to execute a particular
    parameter to the stubbed function, assuming that it was a `callback` function.
    Here, we''re using `callsArgWith` and including the argument `index` (zero based)
    as the first parameter; in this case, one of the two parameters that were passed
    to the request, the first (index 0), was the URL itself, and the second (index
    1) was the `callback` function. Using `callsArgWith`, we can execute the `callback`
    function and specifically provide its parameters, in this case, `null`, `null`,
    and a string. Like `Sinon.js` and `Chai.js`, `proxyquire` will also need to be
    included in our project as `devDependency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Writing and running your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, all of the test code we've seen were just demos and examples,
    and we haven't actually run any tests. Let's set up the basic structure of our
    application so that we can start writing real tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to set up the folder structure that will house all
    of our tests. Consider the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the root of the application project folder, create a folder named `tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `tests` folder, create three more folders for `controllers`, `models`,
    and `server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Writing a test helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing the tests for our application, there's a small amount
    of overhead that we will need to take care of to prepare for our tests. To take
    care of this overhead, we will write a `testhelper` file that will be included
    and run with every test file we execute via Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `testhelper.js` within the `tests` folder, and insert the
    following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is code that we would typically need to include at the top of every one
    of our test files; however, by including it in a single file, we can instruct
    Mocha to automatically require this file for every test file that is run. The
    file itself just includes the `chai` and `sinon` modules and defines a few global
    variables as shortcuts for our test writing. Additionally, it instructs `chai`
    to use the `sinonChai` module so that our syntax is extended and we can write
    Sinon-specific Chai assertions. The command to actually run our suite of tests
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we installed Mocha globally earlier so that we can execute the
    `mocha` command from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the path to our tests in the preceding command, it's assumed that the
    command will be executed from the root of the application project folder. The
    `-r` flag instructs Mocha to require the `testhelper.js` module. The `-R` flag
    is an option to define the style of the test reporting output. We chose to use
    the `spec` style, which lists our report in a nested indentation style with each
    `describe` and `it` statement, along with a green checkmark for the passed tests.
    Finally, the last argument is the path to our `test` files; in this case, we provided
    wildcards so that all of our tests will run.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha has a few different reporting styles that you can choose from. These include
    dot (repeating dots for each test), list, progress (a percentage bar), JSON, and
    spec. One of the more interesting, albeit somewhat useless, is the `-R nyan` reporting
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a quick sample test to make sure that our project is properly
    set up. Within the `tests` folder, create a new file named `mocha.test.js` and
    include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test is pretty straightforward and simply asserts that `1` is
    equal to `1`. Save this file and run the `Mocha` test command again, and you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You might find it tiresome and frustrating to remember and execute that long,
    convoluted command for `Mocha`. Fortunately, there''s a pretty easy solution.
    Edit the `package.json` file in the application, and add the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By making this tweak in the `package.json` file, you can now simply execute
    `npm test` from a command line as a quick and easy shortcut. This is a standard
    convention with the `package.json` file, so any developer will know how to simply
    execute `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that our project is set up to properly run and execute tests, let's start
    writing some real tests for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of that background information out of the way, let's focus on writing
    some real tests for the application we've built. In the following sections, we
    will write tests for the routes, servers, models, and controllers in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start things a little slowly by taking a look at one of the most basic
    files in our application, the `routes.js` file. This file simply defines the number
    of routes that the application should respond to. This will be one of the easiest
    files to write tests for.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `routes.js` file is in the `server` folder within our main application,
    let's put its corresponding test file in a similar location. Within the `tests/server`
    folder, create a file named `routes.test.js`. Since the `routes.test.js` file
    will be testing the functionalities of our `routes.js` file, we will need it to
    `require` the same modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following code in `test/server/routes.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the paths are different since we require modules from within our
    `test/server` folder, but we also require app-specific modules. Also, note that
    in addition to the modules that our original `routes.js` file requires, we also
    require the `routes` module itself. How else will we be able to test the functionalities
    of the module if it isn''t included? Next, let''s set up the structure of the
    test suite and create a few spies. Include this new block of code following the
    previous code within `tests/server/routes.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you recall, the `routes` module's `initialize` function accepted a single
    parameter, an `app` object. In our tests, we defined `app` as a simple, anonymous
    object with three functions-- `get`, `post`, and `delete`; each of these is a
    `spy`. We include a `beforeEach` block to execute the `initialize` function before
    every one of our test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s include some tests. First, we''ll test that the `GET` endpoints
    are configured correctly. Immediately after the `// to do: write tests...` comment,
    place the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, test the `POST` endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, test the `DELETE` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Each of these tests asserts the same thing, that is, that `app` object's corresponding
    `get`, `post`, or `delete` function was executed with the correct parameters for
    each route. We were able to test against the parameters because the `app` object
    we used was a `spy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `mocha` command to execute the suite of tests, you should see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Testing the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the `server.js` file will be slightly different than any of our other
    files. The file runs as the root of our application, so it doesn't export a module
    or any object that we can directly test. Since we launch our server using `server.js`,
    we will need to emulate launching our server from our code. We'll create a function
    called `server`, which will require the `server.js` file using `proxyquire`, and
    `stub` each of the modules that it requires. Executing the `server()` function
    will be exactly the same as executing node `server.js` from a command line. All
    of the code within the file will execute via that function, and then we can test
    against each of the calls that are made using `stub`s from within `proxyquire`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `server.test.js` within the `tests/server/` folder and
    insert the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Before each test is run for our server, we reset the stubs for all of the major
    components of the server. These stubs include the `app` object, `express`, `config`,
    and `mongoose`. We're stubbing each of these modules since we want to `spy` on
    them (and we use a `stub` because some of them need to return objects that we'll
    work with in our file). Now that we have all of our spies in place and our `app`
    object scaffold set up, we can start testing the main functionalities of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to check whether the following conditions pass:'
  prefs: []
  type: TYPE_NORMAL
- en: An application is created
  prefs: []
  type: TYPE_NORMAL
- en: The views directory is set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port is set and can be configured and/or set to default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app itself is configured (`config` is called with it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mongoose connects to a database URI string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app itself is launched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replace the `// to do: write tests...` comment in the earlier code with the
    following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding group of tests, we test the bootstrapping of our server, which
    are all of the functionalities that initially run within `server.js`. The names
    of the tests are pretty self-explanatory. We're checking against the various methods
    of the `app` object, ensuring that they're called and/or that the correct parameters
    were passed in. For the tests, we want to test that a specific type of parameter
    was called, not what the parameter value was literally; we use Sinon's match element,
    which allows our tests to be a little more generic. We wouldn't want to hardcode
    the MongoDB URI string in our tests, because that's just another place we would
    have to maintain--although you could very well do this if you wanted your test
    to be that strict (that is, to assert that the exact URI string was passed quite
    literally).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second set of tests, we want to ensure that the port is set, that it
    defaults to `3300`, and that it can be changed via the use of a node environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With these tests in place, run the `npm test` command again, and you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Testing a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing our models, we want to include the `model` module itself and then
    write tests against it. The easiest solution here is that we create a test `model`
    object and then assert that the model has all of the fields that we expect, as
    well as any virtuals we might have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `tests/models/image.test.js` file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we include `ImageModel` using `require` (note the path for the `require`
    statement). The very first test we run is to make sure that `ImageModel` has a
    mongoose schema property. After this test, we define the `beforeEach` block that
    we'll rely on for the remainder of our tests. Before every test, we will want
    to instantiate a new `ImageModel` object that we can test against. We can do this
    in a `beforeEach` block so that we're sure that we're dealing with a fresh object
    in every test and that it hasn't been tainted by any tests that were previously
    run. It's also important to note that the order of the first test and the `beforeEach`
    block doesn't actually matter, as the `beforeEach` block will run before every
    test in its parent `describe` function, regardless of the order it was defined
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following suite of tests replacing the placeholder `// to do: write
    tests...` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will check to ensure that each property that we expect an `ImageModel`
    instance to have is defined. For the properties that have default values set,
    we also check to ensure that the default values are set as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test against the `virtuals` that we expect `ImageModel` to have,
    and verify that they function the way they''re supposed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When testing the `uniqueId` virtual, it should return the `image` model's filename
    without the extension. As the `beforeEach` defines our `image` model with a filename
    of `testfile.jpg`, we can assert with our test that the `uniqueId` returned is
    equal to `testfile` (the filename without the extension).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the tests for our model should provide the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Testing a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Last but not least, let''s take a look at the `image` controller, and specifically
    test for the main `index` function. Since the `index` function does a lot of work
    and performs a number of different tasks, the test file will make extensive use
    of stubs and spies. The first thing we need to do before any tests is declare
    a number of global variables for our tests, as well as set up all of our `stub`s,
    spies, and placeholder objects for use with `proxyquire`. Then, we require the
    actual image controller using `proxyquire`. Create a file named `tests/controllers/image.test.js`
    and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we define a number of global variables, such as spies, stubs,
    or empty placeholder JavaScript objects. Once our `stub`s are prepared, we will
    call `proxyquire` to include our `image` controller (ensuring that the required
    modules within the `image` controller are actually replaced with our various `stub`s
    and spies). Now that all of our globals, `stub`s, and spies are prepared, let's
    include some tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following code after the preceding block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we will build up some setup using a `beforeEach` block for our
    tests. This sets spies on each of the `res` object''s functions, including render,
    JSON, and redirect (each of these are used throughout the `image` controller).
    We fake the query string parameter by setting the `req.params` object with an
    `image_id` property. Finally, we will create a test `image` object that will be
    used by our fake mongoose `image` model stub to emulate a database object being
    returned from MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first test we run is to ensure that the `index` function actually exists.
    Within the `index` function, the very first action that occurs is that the `image`
    model is found via the `Models.Image.findOne` function. In order to test that
    function, we will need to first set it as `spy`. The reason we do this here and
    not in `beforeEach` is because we might want the `findOne` method to behave slightly
    differently in each test, so we don't want to set a strict rule to be applied
    for all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In order to emulate that a `GET` call was posted to our server and our image
    `index` controller function was hit, we can just fire the function manually. We
    do this using `image.index(req, res)` and pass in our fake request and response
    objects (defined earlier as globals and stubbed in the `beforeEach` function).
  prefs: []
  type: TYPE_NORMAL
- en: Since `ModelsStub.Image.findOne` is a spy, we can test that it was called, and
    then separately test that it was called specifically with the parameters we expect
    it to be called with. In the case of `findOne`, where the second parameter is
    a callback function, we don't care or want to test the very specific function
    that was included, but only ensure that an actual function was included. To do
    this, we can use Sinon's matcher API and specify that a func, or function, was
    included as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last set of `tests` tests the code that executes when an image is found
    and returned from the `findOne` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that you will note here is that `findOne` is no longer a spy
    in these tests, but a stub that will manually fire the callback function that's
    provided as its second parameter. The callback function that's fired will include
    our test `image` model. With this stub, we are emulating that the database call
    was in fact made via `findOne` and that a valid `image` model was returned. Then,
    we can test the remainder of the code that executes within that main callback.
    We perform a similar setup with the `Comment.find` call.
  prefs: []
  type: TYPE_NORMAL
- en: When the `sidebarStub` gets executed, we use the `callsArgWith` Sinon function,
    which fires the callback function that was originally included as a parameter.
    Within that callback function, we include fake `viewModel` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Once `sidebarStub` does its job, we expect `res.render` to have been called,
    and we specify the exact parameters we expect it to have been called with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the tests for the `image` controller should yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Spy and stub everything!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When in doubt, the safest thing you can do when writing your tests is spy on
    everything and stub everything else. There are always going to be times when you'll
    want a function to execute naturally; in that case, leave it alone. Ultimately,
    you never want your tests to be dependent on any other system that includes database
    servers, other network servers, other APIs, and so on. You only want to test that
    your own code works, nothing more. If your code is expected to make a call to
    an API, spy on the actual call and just assert that your code attempted to make
    the call. Likewise, fake the response from the server via a stub and ensure that
    your code handles the response properly.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to check for dependencies in your code is to stop any other
    services from running (your local node app, and so on), as well as possibly even
    disabling your network connection. If your tests time out or fail somewhere unexpectedly,
    it's likely because you missed a function you needed to spy on or stub along the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Don't get stuck going down a rabbit hole when writing your tests. It's easy
    to get carried away and start testing functionalities that can safely be assumed
    to be working. An example of this is writing tests to ensure that a third-party
    module is performing correctly. If it's not a module you wrote, don't test it.
    Don't worry about writing tests to prove the module does what it says it should.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about TDD when writing JavaScript specifically, I would highly
    recommend that you read Christian Johansen''s beast of a book: *Test-Driven JavaScript
    Development*. This book is huge and speaks of the sheer volume of information
    related to TDD. In some circles, TDD truly is a way of life, and it will define
    the style with which you write your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Automating everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test automation was never so easy without Gulp. Gulp is an open source JavaScript
    library that provides efficient build creation processes and serves as a task
    runner. We will use Gulp to automate our unit tests by a single command in terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by installing all the required packages using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that you may require root access to install the global package of `gulp-cli`.
    Use `sudo` in such cases, for example, `sudo npm install gulp-cli -g`. We used
    `--save-dev` to install Gulp locally and save it as a development dependency in
    our `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we created a Gulp file in the `test` directory. Now, to `test` the
    directory of our app and make sure that we have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfbb4d48-2f9a-4c71-88bc-07ea63285012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve installed the required packages and created a Gulp file, let''s
    start writing some code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the terminal, run Gulp, and you will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49d043ab-3d77-48be-a95a-61d6320c1b97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Gulp is faster and simpler; why?: Gulp uses node.js streams to pass a data
    chunk through a series of the piped plugin. This accelerates the in-memory process
    operations and performs the write operation at the end of the task, once and for
    all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get ready to expand the scope of learning Gulp and automate our unit
    tests we covered in the previous sections. We will start by installing the other
    required npm packages. Note that we will need to install them in our `project`
    folder and not in the `test` folder. So, let''s go back one step using `cd..`,
    and ensure that you are at your project''s root level and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gulp-mocha` is a plugin to run the `mocha` test files. Now, let''s modify
    our Gulp file and add some es6 spices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run `gulp test-server` to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8408a50-aebd-4165-863a-12f562c73aee.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's discuss how the preceding code works. First, we created the `test-helper`
    task that reads the `testhelper.js` file in memory and does nothing else but store
    the global variables required to test our `server.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We used mocha as a framework to write test cases. The `gulpMocha` plugin runs
    the test cases in memory by reading the `server.test.js` file and pipes the output
    in terminal. To study about `gulp-mocha` in detail, follow the [https://github.com/sindresorhus/gulp-mocha](https://github.com/sindresorhus/gulp-mocha)
    link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the syntactical structure of how to write dependencies if required. Let''s
    get clarity on adding a dependency by writing one more task, as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This time we will run `gulp test-routes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a question may arise regarding managing so many tasks. Gulp also provides
    a solution for automating all the tasks in one go. Let''s add the following snippet
    to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding command; Gulp `build` and automation of unit tests are both
    now complete. Further, we can add all the controllers and respective models so
    as to achieve project-based automation of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has definitely been a crash course on testing, but the groundwork has been
    laid, and I hope that you have a solid understanding of the tool chain that you
    can use to write your own tests. Trust this powerhouse suite of tools, and you'll
    be writing bulletproof code in no time!
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate goal with writing tests is to have 100 percent complete code coverage
    and have unit tests exist for every line of code you write. From here, the true
    test is to switch to TDD, which dictates that you write tests before any code
    exists at all. Obviously, tests against nonexistent code will fail, so you'll
    then need to write the least amount of code to get it to pass, and repeat!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a number of cloud-based hosting options
    available to get your application up and running online.
  prefs: []
  type: TYPE_NORMAL
