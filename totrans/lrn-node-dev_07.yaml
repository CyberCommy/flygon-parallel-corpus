- en: Promises in Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we looked at many important concepts of asynchronous
    programming in Node. This chapter is about promises. Promises are available in
    JavaScript since ES6\. Although they have been around in third-party libraries
    for quite some time, they finally made their way into the core JavaScript language,
    which is great because they're a really fantastic feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about how promises work, we'll start to understand
    exactly why they're useful, and why they've even come to exist inside JavaScript. We'll
    take a look at a library called axios that supports promises. This will let us
    simplify our code, creating our promise calls easily. We'll actually rebuild an
    entire weather app in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look into following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ES6 promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather app with promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to ES6 promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises aim to solve a lot of the problems that come up when we have a lot
    of asynchronous code in our application. They make it a lot easier to manage our
    asynchronous computations—things such as requesting data from a database. Alternatively,
    in the case of a weather app, things such as fetching data from a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app.js` file we do a similar thing using callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have two callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that gets passed into `geocodeAddress`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that gets passed into `getWeather`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use this to manage our asynchronous actions. In our case, it's things such
    as fetching data from an API, using an HTTP request. We can use promises in this
    example to make the code a lot nicer. This is exactly the aim later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore the basics concept of promises. We'll compare
    and contrast callbacks with promises just yet, because there's a lot more subtleties
    than can be described without knowing exactly how promises work. So, before we
    talk about why they're better, we will simply create some.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an example promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Atom, inside the `playground` folder, we'll create a new file and call
    it `promise.js`. Before we define promises and talk about exactly how they work,
    we will run through a simple example because that is the best way to learn just
    about anything—going through an example and seeing how it works.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we'll work through a very basic example. We'll stick to the
    core promise features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with this very simple example, we''ll make a variable called
    `somePromise`. This will eventually store the promise object. We''ll be calling
    various methods on this variable to do something with the promise. We''ll set
    the `somePromise` variable equal to the return result from the constructor function
    for promises. We''ll use the `new` keyword to create a new instance of a promise.
    Then, we''ll provide the thing we want to create a new instance of, `Promise`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this `Promise` function, which is indeed a function—we have to call it
    like one; that is, it takes one argument. This argument will be a function. We''ll
    use an anonymous arrow function (`=>`), and inside it, we''ll do all of the asynchronous
    stuff we want to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It will all be abstracted, kind of like we abstract the HTTP request inside
    the `geocodeAddress` function in the `geocode.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All of the complex logic in the `geocodeAddress` function does indeed need to
    happen, but the `app.js` file doesn't need to worry about it. The `geocode.geocodeAddress`
    function in the `app.js` file has a very simple `if` statement that checks whether
    there's an error. If there is an error, we will print a message, and if there's
    not, we move on. The same thing will be true with promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new Promise` callback function will get called with two arguments, `resolve`
    and `reject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is how we'll manage the state of our promise. When we make a promise, we're
    making a promise; we're saying, "Hey, I'll go off and I'll fetch that website
    data for you." Now this could go well, in which case, you will `resolve` the promise,
    setting its state to fulfilled. When a promise is fulfilled, it's gone out and
    it's done the thing you've expected it to do. This could be a database request,
    an HTTP request, or something else completely.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call `reject`, you're saying, "Hey, we tried to get that thing
    done man, but we just could not." So the promise has been considered rejected.
    These are the two states that you can set a promise to—fulfilled or rejected.
    Just like inside `geocode.js`, we either provide one argument for an error, or
    we provide the second argument if things went well. Instead of doing that though,
    promises give us two functions we can call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to illustrate exactly how we can use these, we''ll call `resolve`.
    Once again, this is not asynchronous. We''re not doing anything quite yet. So
    all of this will happen essentially in real time, as far as you see in Terminal.
    We''ll call `resolve` with some data. In this case, I''ll pass in a string, `Hey.
    It worked!`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now this string is the value the promise was fulfilled with. This is exactly
    what someone will get back. In case of the `geocode.geocodeAddress` function in
    app file, it could be the data, whether it's the results or the error message.
    In our case though, we're using `resolve`, so this will be the actual data the
    user wanted. When things go well, `Hey. It worked!` is what they expect.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can only pass one argument to both `resolve` and `reject`, which means
    that if you want to provide multiple pieces of information I recommend that you
    resolve or reject an object that you can set multiple properties on. In our case
    though, a simple message, `Hey. It worked!`, will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the promise method then
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to actually do something when the promise gets either resolved
    or rejected, we need to call a promise method called `then`; `somePromise.then`.
    The `then` method lets us provide `callback` functions for both success and error
    cases. This is one of the areas where callbacks differ from promises. In a callback,
    we had one function that fired no matter what, and the arguments let us know whether
    or not things went well. With promises we'll have two functions, and this will
    be what determines whether or not things went as planned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now before we dive into adding two functions, let''s start with just one. Right
    here, I''ll call then, passing in one function. This function will only get called
    if the promise gets fulfilled. This means that it works as expected. When it does,
    it will get called with the value passed to `resolve`. In our case, it''s a simple
    `message`, but it can be something like a user object in the case of a database
    request. For now though, we''ll stick with `message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print `message` to the screen. Inside the callback, when the promise
    gets fulfilled we''ll call `console.log`, printing `Success`, and then as a second
    argument, we''ll print the actual `message` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the promise example in Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a very basic promise example in place, let''s run it from
    the Terminal using `nodemon`, which we installed in the previous chapter. We''ll
    add `nodemon`, and then we''ll go into the `playground` folder, `/promise.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1baa93e7-2dda-4403-af61-a5918704c603.png)'
  prefs: []
  type: TYPE_IMG
- en: When we do this right away, our app runs and we get success. `Hey. It worked!` This
    happens instantaneously. There was no delay because we haven't done anything asynchronously.
    Now when we first explored callbacks (refer to [Chapter 5](b34c7f1b-8ae4-4974-a24b-6051605af3c7.xhtml),
    *Basics of Asynchronous Programming in Node.js* ), we used `setTimeout` to simulate
    a delay, and this is exactly what we'll do in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `somePromise` function, we''ll call `setTimeout`, passing in the
    two arguments: the function to call after the delay and the delay in milliseconds.
    I''ll go with `2500`, which is 2.5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now after those 2.5 seconds are up, then, and only then, do we want to `resolve`
    the promise. This means that our function, the one we pass into then will not
    get called for 2.5 seconds. Because, as we know, this will not get called until
    the promise resolves. I''ll save the file, which will restart `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b7bd22e-6649-463f-b385-3764d2b41738.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Terminal, you can see we have our delay, and then `success: Hey it worked!`
    prints to the screen. This 2.5 second delay was caused by this `setTimeout`. After
    the delay was up (in this case it''s an artificial delay, but later it''ll be
    a real delay), we''re able to `resolve` with the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now there''s a chance that things didn''t go well. We have to handle errors
    inside our Node applications. In that case, we wouldn''t call `resolve`, we would
    call `reject`. Let''s comment out the `resolve` line, and create a second one,
    where we call `reject`. We''ll call `reject` much the same way we called `resolve`.
    We have to pass in one argument, and in this case, a simple error message like `Unable
    to fulfill promise` will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we call `reject`, we''re telling the promise that it has been rejected.
    This means that the thing we tried to do did not go well. Currently, we don''t
    have an argument that handles this. As we mentioned, this function only gets called
    when things go as expected, not when we have errors. If I save the file and rerun
    it in Terminal, what we''ll get is a promise that rejects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5925ae3-0b3a-4186-8be9-73ed7d094396.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we don't have a handler for it, so nothing will print to the screen.
    This will be a pretty big problem. We need to do something with that error message.
    Maybe we will alert the user, or we will try some other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the previous code output, we can see that nothing printed between
    the restarting and exiting. In order to do something with the error, we''ll add
    a second argument to the `then` method. This second argument is what lets us handle
    errors in our promises. This argument will get executed and called with that value.
    In this case, it''s our message. We''ll create an argument called `errorMessage`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the argument, we can do something with that. In this case, we''ll print
    it to the screen using `console.log`, printing `Error` with a colon and a space
    to add some nice formatting, followed by the actual value that was rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we can refresh things by saving the file. We
    will now see our error message in Terminal, because we now have a place for it
    to do something:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a3cb6c6-97d1-4630-8932-6e8a8bfaa198.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have a place for it to print the message to the screen; `Unable to
    fulfill promise` prints to the screen, which works exactly as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Merits of promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a promise that can either get resolved or rejected. If it gets resolved,
    meaning the promise was fulfilled, we have a function that handles that. If it
    gets rejected, we have a function that handles that as well. This is one of the
    reasons why promises are awesome. You get to provide different functions, depending
    on whether or not the promise got resolved or rejected. This lets you avoid a
    lot of complex `if` statements inside of our code, which we needed to do in `app.js`
    to manage whether or not the actual callback succeeded or failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now inside a promise, it''s important to understand that you can only either
    `resolve` or `reject` a promise once. If you `resolve` a promise you can''t `reject`
    it later, and if you `resolve` it with one value you can''t change your mind at
    a later point in time. Consider this example, where I have a code like the following
    code; here I `resolve` first and then I `reject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we'll get our success `message` printing to the screen. We'll
    never see `errorMessage`, because, as I just said, you can only do one of these
    actions once. You can either `resolve` once or you can `reject` once. You can't
    do both; you can't do either twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another great advantage over callbacks. There''s nothing preventing
    us from accidentally calling the `callback` function twice. Let''s consider the `geocode.js`
    file for example. Let''s add another line in the `if` block of geocode request
    call, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a more obvious example, but it could easily be hidden inside of complex
    `if-else` statements. In this case, our `callback` function in `app.js` will indeed
    get called twice, which can cause really big problems for our program. Inside
    the promise example this callback will never get called twice, no matter how many
    times you try to call `resolve` or `reject`, this function will only get fired
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prove that right now by calling `resolve` again. In the promise example
    case, let''s save the file with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's refresh things; we'll `resolve` with our message, `Hey. It worked!` and
    we'll never ever have the function fired a second time with no message. Because,
    as we said, the promise is already resolved. Once you set a promise's state to
    either fulfilled or rejected, you can't set it again.
  prefs: []
  type: TYPE_NORMAL
- en: Now before a promise's `resolve` or `reject` function gets called, a promise
    is in a state known as pending. This means that you're waiting for information
    to come back, or you're waiting for your async computation to finish. In our case,
    while we're waiting for the weather data to come back, the promise would be considered
    pending. A promise is considered settled when it has been either fulfilled or
    rejected.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which one you chose, you could say the promise has settled, meaning
    that it's no longer pending. In our case, this would be a settled promise that
    was indeed fulfilled because `resolve` is called right here. So these are just
    a couple of the benefits of promises. You don't have to worry about having callbacks
    called twice, you can provide multiple functions—one for success handling and
    one for error handling. It really is a fantastic utility!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gone through a quick example of how promises work, going over
    just the very fundamentals, we'll to move on to something slightly more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll explore two more ways to use promises. We'll create functions
    that take input and return a promise. Also, we'll explore promise chaining, which
    will let us combine multiple promises.
  prefs: []
  type: TYPE_NORMAL
- en: Providing input to promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the problem with the example we discussed in the previous section is that
    we have a promise function, but it doesn't take any input. This most likely is
    never going to be the case when we're using real-world promises. We'll want to
    provide some input, such as the ID of a user to fetch from the database, a URL
    to request, or a partial URL, for example, just the address component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we''ll have to create a function. For this example, we''ll
    make a variable, which will be a function called `asyncAdd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will be a function that simulates the async functionality using `setTimeout`.
    In reality, it's just going to add two numbers together. However, it will illustrate
    exactly what we need to do, later in this chapter, to get our weather app using
    promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the function, we will take two arguments, `a` and `b`, and we''ll return
    a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, whoever calls this `asyncAdd` method, they can pass in input, but they
    can also get the promise back so that they can use then to sync up and wait for
    it to complete. Inside the `asyncAdd` function, we''ll use `return` to do this.
    We''ll `return` the `new Promise` object using the exact same `new Promise` syntax
    we did when we created the `somePromise` variable. Now this is the same function,
    so we do need to provide the constructor function that gets called with both `resolve`
    and `reject`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an `asyncAdd` function, which takes two numbers and returns a promise.
    The only thing left to do is to actually simulate the delay, and make the call
    to `resolve`. To do this, we''ll simulate the delay using `setTimeout`. Then we''ll
    pass in my `callback` function, setting the delay to 1.5 seconds, or `1500` milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `callback` function, we''ll write a simple `if-else` statement that
    will check if the type of both `a` and `b` is a number. If it is, great! We''ll
    `resolve` the value of the two numbers added. If they''re not numbers (one or
    more), then we''ll `reject`. To do this, we''ll use the `if` statement with the
    `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using the `typeof` object to get the string type before the variable.
    Also, we''re checking whether it''s equal to a number, which is what will come
    back from `typeof` when we have a number. Now similar to `a`, we''ll add `typeof
    b`,  which is also a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the two numbers up, resolving the value. Inside the code block of
    the `if` statement, we''ll call `resolve`, passing in `a + b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the two numbers up, passing in one argument to `resolve`. Now
    this is the happy path when both `a` and `b` are indeed numbers. If things don''t
    go well, we''ll want to add `reject`. We''ll use the `else` block to do this.
    If the previous condition fails, we''ll `reject` by calling `reject(''Arguments
    must be numbers'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an `asyncAdd` function that takes two variables, `a` and `b`, returns
    a promise, and anyone who happens to call `asyncAdd` can add a then call onto
    the return result to get that value.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now what exactly will this look like? To show this, first we''ll comment out
    all of the code we have in the `newPromise` variable of `promise.js`. Following
    this, we''ll call the `asyncAdd` variable where we make `asyncAdd`. We''ll call
    it like we would any other function, by passing in two values. Remember, this
    could be a database ID or anything else for an async function. In our case, it''s
    just two numbers. Let''s say, `5` and `7`. Now the return value from this function
    is a promise. We can make a variable and call then on that variable, but we can
    also just tack the `then` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we''ll do when we use promises; we''ll tack on then, passing
    in our callbacks. The first callback being the success case, and the second one
    being the error case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second callback, we''ll get our `errorMessage`, which we can log to
    the screen using the `console.log(errorMessage);` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If one or more of the numbers are not actually numbers, the `error` function
    will fire because we called `reject`. If both are numbers, all we''ll do will
    get the result and print it to the screen, using `console.log`. We''ll add `res`
    and inside the arrow function (`=>`), we''ll add the `console.log` statement and
    print the string `Result` with a colon. Then, as the second argument in `console.log`,
    we''ll pass in the actual number, which will print it to the screen as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our promise `asyncAdd` function in place, let''s test this
    out inside Terminal. To do this, we''ll run `nodemon` to start up `nodemon playground/promise.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c8c4cc6-4777-4da8-89e2-6f18d6255ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: Right away, we'll get the delay and the result, `12` prints to the screen. This
    is fantastic! We are able to create the function that takes the dynamic input,
    but still returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Now notice that we've taken an async function that usually requires callbacks
    and we've wrapped it to use promises. This is a good handy feature. As you start
    using promises in Node, you'll come to realize that some things do not support
    promises and you'd like them to. For example, the request library that we used
    to make our HTTP requests does not support promises natively. However, we can
    wrap our request call inside of a promise, which is what we'll to do later in
    the section. For now though, we have a basic example illustrating how this works.
    Next, we'd like to talk about promise chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Promise chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promise chaining is the idea of having multiple promises run in a sequence.
    For example, I want to take an address and convert that into coordinates, and
    take those coordinates and convert them into weather information; this is an example
    of needing to synchronize two things. Also, we can do that really easily using
    promise chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to chain our promises, inside our success call we''ll return a new
    promise. In our example, we can `return` a new promise by calling `asyncAdd` again.
    I''ll call `asyncAdd` next to the `res` and `console.log` statements, passing
    in two arguments: the result, whatever the previous promise has returned, and
    some sort of new number; let''s use `33`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re returning a promise so we can add my chaining onto it by calling
    the `then` method again. The `then` method will to get called after we close the
    closing parenthesis for our previous `then` method. This will also take one or
    more arguments. We can pass in a success handler, which will be a function and
    an error handler, which will also be a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `then` callbacks set up, we can actually fill them out.
    Once again we will get a result; this will be the result of `5` plus `7`, which
    is `12`, plus `33`, which will be `45`. Then, we can print `console.log (''Should
    be 45'')`. Next, we''ll print the actual value from results variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our error handler will also be the same. We''ll have `errorMessage` and
    we''ll print it to the screen using the `console.log`, printing `errorMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what we have is some chaining. Our first then `callback` functions will
    fire based on the result of our first `asyncAdd` call. If it goes well, the first
    one will fire. If it goes poorly, the second function will fire. Our second then
    call will be based on the `asyncAdd` call, where we add `33`. This will let us
    chain the two results together, and we should get `45` printing to the screen.
    We''ll save this file, which will restart things inside `nodemon`. Eventually,
    we''ll get our two results: `12` and our `Should be 45`. As shown in the following
    code image, we get just that, `Result: 12` and `Should be 45`, printing to the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51085c19-914c-45d4-9900-831e8209b8ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Error handling in promises chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now when it comes to error handling, there are a few quirks; so, we''ll simulate
    some errors. First up, let''s simulate an error in our second `asyncAdd` call.
    We know we can do that by passing in a value that''s not a number. In this case,
    let''s wrap `33` inside quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be a string and our call should `reject`. Now we can save the file
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07962445-c8f8-4784-8512-560de7bf4cec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get `Result: 12`, then we get our error, `Arguments must be numbers`. Exactly
    as we expect, this is printing on the screen. Instead of getting `Should be 45`,
    we get our error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But things get a little trickier when something earlier on in the promise chain
    gets rejected. Let''s swap `''33''` with the number `33`. Then let''s replace
    `7` with the string `''7''`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause our first promise to fail, which means we''ll never see the
    result. We should see the error message printing to the screen, but that''s not
    what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9144348b-9213-4f2b-89ff-9d3a09e6dff6.png)'
  prefs: []
  type: TYPE_IMG
- en: When we restart, we do indeed get the error message printing to the screen,
    but then we also get `Should be 45 undefined`. The second then `console.log` is
    running because we provided an error handler in the second `asyncAdd` function.
    It's running the error handler. Then it says,* Okay, things must be good now we
    ran the error handler. Let's move on to the next then call calling the success
    case*.
  prefs: []
  type: TYPE_NORMAL
- en: The catch method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fix the error, we can remove both of our error handlers from both the `then`
    calls, and replace them with a call at the very bottom, to a different method,
    which we''ll call `.catch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The catch promise method is similar to then, but it just takes one function.
    This is the error handler. As shown in the following code, we can specify one
    error handler if any of our promise calls fail. We''ll take `errorMessage` and
    print it to the screen using `console.log(errorMessage)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For now though, if things are a little blurry that is okay, as long as you're
    starting to see exactly what we're doing. We're taking the result from one promise
    and passing it to a different one. In this case, the result works exactly as expected.
    The first promise fails, we get, `Arguments must be numbers` printing to the screen.
    Also, we don't get that broken statement where we try to print `45`, but we get
    undefined instead. Using catch, we can specify an error handler that will fire
    for all of our previous failures. This is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: The request library in promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now as I mentioned earlier, some libraries support promises while others don't.
    The request library does not support promises. We will make a function that wraps
    request, returning a promise. We'll use some functionalities from the `geocode.js`
    file from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s discuss a quick setup, and then we''ll actually fill it out.
    In the `playground` folder, we can make a new file to store this, called `promise-2.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e237b240-cc2b-44e0-887a-52ae3eba14e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll make a function called `geocodeAddress`. The `geocodeAddress` function
    will take the plain text address, and it will return a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `geocodeAddress` function will return a promise. So if I pass in a ZIP
    code, such as `19146`, I would expect a promise to come back, which I can attach
    a `then` call to. This will let me wait for that request to finish. Right here,
    I''ll tack on a call to `then`, passing in my two functions: the success handler
    for when the promise is fulfilled and the error handler for when the promise is
    rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when things go well, I''ll expect the `location` object with the address,
    the `latitude`, and the `longitude`, and when things go poorly, I''ll expect the
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the error message happens, we''ll just print it to the screen using `console.log
    (errorMessage)`. For now, when things go well and the success case runs, we''ll
    just print that entire object using our pretty printing technique, `console.log`.
    Then, we''ll call `JSON.stringify`, like we''ve done many times before, passing
    in the three arguments—the object, undefined for the filter method—which we''ll
    never use in the book, and the number `2` for the number of spaces we''d like
    to use as our indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is what we want to create, the function that lets this functionality work
    as expected. This `then` call should work as shown in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started I''ll return the promise by calling: `return new Promise`, passing
    in my constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, we''ll add that call to request. Let''s provide the `resolve`
    and `reject` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `Promise` set up, we can load in the request module on
    top of the code, creating a constant called `request` and setting that equal to
    the return result from `require(''request'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll move into the `geocode.js` file, grab code inside the `geocodeAddress`
    function, and move it over into `promise-2 file`, inside of the constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are mostly good to go; we only need to change a few things. The first
    thing we need to do is to replace our error handlers. In the `if` block of the
    code, we have called our `callback` handler with one argument; instead, we''ll
    call `reject`, because if this code runs, we want to `reject` the promise. We
    have the same thing in the next `else` block. We''ll call `reject` if we get `ZERO_RESULTS`.
    This is indeed a failure, and we do not want to pretend we succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the next `else` block, this is where things did go well; here we can
    call `resolve`. Also, we can remove the first argument, as we know `resolve` and
    `reject` only take one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We are able to specify multiple values though, because we `resolve` an object
    with properties on it. Now that we have this in place, we are done. We can actually
    save our file, rerun it inside Terminal, and test things out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the request library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test, we''ll save the file, move into Terminal, and shut down `nodemon`
    for the `promise.js` file. We''ll run `node` for the `promise.js` file. It''s
    in the `playground` folder, and it''s called `promise-2.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this program, we''re actually making that HTTP request. As
    shown in the following code output, we can see the data comes back exactly as
    we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fa26c34-7594-4433-ac64-700af003a6eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our `address`, `latitude`, and `longitude` variables. This is fantastic!
    Now let''s test to see what happens when we pass in an invalid address, something
    like 5 zeroes, which we''ve used before to simulate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save the file, rerun the program, and `Unable to find that address.`
    prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd136fb7-56f6-4180-8d82-fb50a1c5e611.png)'
  prefs: []
  type: TYPE_IMG
- en: This happens only because we call `reject`. We will call `reject` inside of
    the `Promise` constructor function. We have our error handler, which prints the
    message to the screen. This is an example of how to take a library that does not
    support promises and wrap it in a promise, creating a promise ready function.
    In our case, that function is `geocodeAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: Weather app with promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll learn how to use a library that has promises built
    in. We''ll explore the axios library, which is really similar to request. Although,
    instead of using callbacks as request does, it uses promises. So we don''t have
    to wrap our calls in promises to get that promise functionality. We''ll actually
    be recreating the entire weather app in this section. We''ll only have to write
    about 25 lines of code. We''ll go through the entire process: taking the address,
    getting the coordinates, and then fetching the weather.'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching weather app code from the app.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fetch weather app code from the app.js file, we'll duplicate `app.js`, because
    we configure `yargs` in the original `app.js` file and we'll want to carry the
    code over to the new project. There's no need to rewrite it. In the `weather`
    directory, we'll duplicate `app.js`, giving it a new name, `app-promise.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `app-promise.js`, before we add anything, let''s rip some stuff out.
    We''ll be ripping out the `geocode` and `weather` variable declarations. We''ll
    not be requiring any files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3bb21f5-b5b1-4c6a-a140-4ff58de97564.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then I''ll remove everything after our `yargs` configuration, which in this
    case is just our call to `geocodeAddress`. The resultant code will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Axios documentations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a clean slate, we can get started by installing the new library.
    Before we run the `npm install` command, we''ll see where we can find the documentation.
    We can get it by visiting: [https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios).
    As shown in the following screenshot, we have the axios npm library page, where
    we can view all sorts of information about it, including the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1b15161-a362-4fa5-a931-7c7d8f79ad9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can see some things that look familiar. We have calls to then and catch,
    just like we do when we use promises outside of axios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c120402b-5698-4ec0-8c0a-7b838ad882ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the stats column of this page, you can see that this is a super popular
    library. The most recent version is 0.13.1\. This is the exact version we'll be
    using. Feel free to go to this page when you use axios in your projects. There
    are a lot of really good examples and documentation. For now though, we can install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install axios, inside Terminal, we''ll be running `npm install`; the library
    name is `axios`, and we''ll specify the version `0.17.1` with the `save` flag
    updating the `package.json` file. Now I can run the `install` command, to install
    axios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b94abf0-4c96-4509-b51d-4076e50445e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Making calls in the app-promise file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside our `app-promise` file, we can get started by loading in `axios` at
    the top. We''ll make a constant called `axios`, setting it equal to `require(''axios'')`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can actually start making the calls in the
    code. This will involve us pulling out some of the functionality from the geocode
    and weather files. So we'll open up the `geocode.js` and `weather.js` files. Because
    we will be pulling some of the code from these files, things such as the URL and
    some of the error handling techniques. Although we'll talk about the differences
    as they come up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to encode the address and get the geocode
    URL. Now this stuff happens inside `geocode.js`. So we''ll actually copy the `encodedAddress`
    variable line, where we create the encoded address, and paste it in the `app-promise`
    file, following the `argv` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we do need to tweak this a little bit. The `address` variable doesn''t
    exist; but we have `argv.address`. So, we''ll switch `address` with `argv.address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the encoded address; the next thing we need to get before we can
    start using axios is the URL that we want to make the request to. We''ll grab
    that from the `geocode.js` file as well. In `app-promise.js`, we will make a new
    variable called `geocodeURI`. Then, we''ll take the URL present in `geocode.js`,
    from the opening tick to the closing tick, copy it, and paste it in `app-promise.js`,
    equal to `geocodeURI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we use the encoded `address` variable inside the URL; this is fine because
    it does exist in our code. So at this point, we have our `geocodeUrl` variable
    and we can get started in making our very first axios request.
  prefs: []
  type: TYPE_NORMAL
- en: Making axios request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our case, we''ll be taking the address and getting the `latitude` and `longitude`.
    To make our request, we''ll call a method available on axios, `axios.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` is the method that lets us make our HTTP get request, which is exactly
    what we want to do in this case. Also, it''s really simple to set up. When you''re
    expecting JSON data, all you have to do is to pass in the URL that we have in
    the `geocodeUrl` variable. There''s no need to provide any other options, such
    as an option letting it know it''s `JSON. axios` knows how to automatically parse
    our JSON data. What get returns is actually a promise, which means we can use
    `.then` in order to run some code when the promise gets fulfilled or rejected,
    whether things go well or poorly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside then, we''ll provide one function. This will be the success case. The
    success case will get called with one argument, which the `axios` library recommends
    that you call `response`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, we could call anything you like. Now inside the function, we''ll
    get access to all of the same information we got inside of the request library;
    things such as our headers, response, and request headers, as well as the body
    information; all sorts of useful info. What we really need though is the `response.data`
    property. We''ll print that using `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place, we can run our `app-promise` file, passing in
    a valid address. Also, we can see what happens when we make that request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside command line (Terminal), we''ll use the `clear` command first to clear
    the Terminal output. Then we can run `node` `app-promise.js`, passing in an address.
    Let''s use a valid address, for example, `1301 lombard street, philadelphia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The request goes out. And what do we get back? We get back the results object
    exactly as we saw it when we used the other modules in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9b590ca-3f30-4583-9aa6-d9bad585323b.png)'
  prefs: []
  type: TYPE_IMG
- en: The only difference in this case is that we're using promises built in, instead
    of having to wrap it in promises or using callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in axios request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now aside from the success handler we used in the previous example, we can
    also add a call to catch, to let us catch all of the errors that might occur.
    We''ll to get the error object as the one-and-only argument; then we can do something
    with that error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the function, we''ll kick things off, using `console.log` to print the
    error argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s simulate an error by removing the dot in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can see what happens when we rerun the program. Now I'm doing this to explore
    the `axios` library. I know exactly what will happen. This is not why I'm doing
    it. I'm doing it to show you how you should approach new libraries. When you get
    a new library, you want to play around with all the different ways it works. What
    exactly comes back in that error argument when we have a request that fails? This
    is important information to know; so when you write a real-world app, you can
    add the appropriate error handling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, if we rerun the exact same command, we''ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b892515-a390-41a9-84d2-56b558906ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there really is nothing to print on the screen. We have a lot
    of very cryptic error codes and even the `errorMessage` property, which usually
    contains something good or does not. Then we have an error code followed by the
    URL. What we want instead is print a plain text English message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll use an `if-else` statement, checking what the code property
    is. This is the error code and in this case `ENOTFOUND`; we know it means that
    it could not connect to the server. In `app-promise.js`, inside the error handler,
    we can add this by having `if` and checking the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If that is the case, we''ll print some sort of custom message to the screen
    using `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an error handler that handles this specific case. So we can remove
    our call to `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we save the file, and rerun things from Terminal, we should get a much
    nicer error message printing to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53f9b560-267b-411e-a2d1-6615e4267ddf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what we get: `Unable to connect to API servers`. Now I''ll
    add that dot back in, so things start working. We can worry about the response
    that comes back.'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling with ZERO_RESULT body status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you remember, inside the geocode file, there were some things we needed to
    do. We've already handled the error related to server connection, but there is
    still another error pending, that is, if the `body.status` property equals `ZERO_RESULTS`.
    We want to print an error message in that case.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll inside `app-promise`, create our very own error. We'll throw
    an error inside the `axios.get` function. This error will cause all of the code
    after it, not to run. It will move right into the error handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we only want to throw an error if the status property is set to `ZERO_RESULTS`.
    We''ll add an `if` statement at the very top of the `get` function to check `if
    (response.data.status)` equals `ZERO_RESULTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If that is the case, then things went bad and we do not want to move on to
    make the weather request. We want to run our catch code we have. To throw a new
    error that our promise can catch, we''ll use a syntax called `throw new Error`.
    This creates and throws an error letting Node know that something went wrong.
    We can provide our own error message, something that''s readable to a user: `Unable
    to find that address`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a message that''ll let that user know exactly what went wrong. Now
    when this error gets thrown, the same catch code will run. Currently, we only
    have one `if` condition that checks whether the code property is `ENOTFOUND`.
    So we''ll add an `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `else` block, we can print the error message, which is the string
    we typed in the throw `new Error` syntax using the `e.` message property, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If the error code is not `ENOTFOUND`, we''ll simply print the message to the
    screen. This will happen if we get zero results. So let''s simulate that to make
    sure the code works. Inside Terminal, we''ll rerun the previous command passing
    in a zip code. At first, we''ll use a valid zip code, `08822` and we should get
    our data back. Then we''ll use an invalid one: `00000`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the request with a valid address, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c125c1ba-ce47-4adb-9d2f-6f996c2bf381.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run the request with the invalid address, we get the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3acd268c-c83b-486e-98a9-87c2e2ad37eb.png)'
  prefs: []
  type: TYPE_IMG
- en: By calling `throw new Error`, we're immediately stopping the execution of this
    function. So `console.log` with `e.message` never prints, which is exactly what
    we want. Now that we have our error handler in place, we can start generating
    that weather URL.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the weather URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to generate the weather URL, we''ll copy the URL from the `weather`
    file, taking it with the ticks in place, and moving it into the `app-promise`
    file. We''ll make a new variable called `weatherUrl`, setting it equal to the
    copied URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `weatherUrl` does need a few pieces of information. We need the `latitude`
    and `longitude`. We have two variables `lat` and `lng`, so let''s create them,
    getting the appropriate value from that response object, `var lat` and `var lng`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in order to pull them off, we have to go through that process of digging
    into the object. We''ve done it before. We''ll be looking in the response object
    at the data property, which is similar to the body in the request library. Then
    we''ll go into `results`, grabbing the first item and accessing the `geometry`
    property, then we''ll access `location.lat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now similarly, we can add things for the `longitude` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now before we make that weather request, we want to print the formatted address
    because that''s something the previous app did as well. In our `console.log(response.data)`
    statement, and instead of printing `response.data`, we''ll dive into the data
    object getting the formatted address. This is also on the results array''s first
    item. We''ll be accessing the `formatted_address` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our formatted address printing to the screen, we can make our
    second call by returning a new promise. This is going to let us chain these calls
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining the promise calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we''ll return a call to `axios.get`, passing in the URL. We
    just defined that, it is `weatherUrl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this call returning, we can attach another `then` call right
    between our previous `then` call and catch call, by calling then, passing in one
    function, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will get called when the weather data comes back. We''ll get
    that same response argument, because we''re using the same method, `axios.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `then` call, we don''t have to worry about throwing any errors,
    since we never needed to access a body property in order to check if something
    went wrong. With the weather request if this callback runs, then things went right.
    We can print the weather information. In order to get that done, we''ll make two
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`temperature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apparentTemperature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `temperature` variable will get set equal to `response.data`. Then we''ll
    access that `currently` property. Then we''ll access temperature. We''ll pull
    out the second variable, the actual temperature or `apparentTemperature`, which
    is the property name, `var apparentTemperature`. We''ll be setting this equal
    to `response.data.currently.apparentTemperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our two things pulled out into variables, we can add those
    things inside of a call, `console.log`. We chose to define two variables, so that
    we don''t have to add the two really long property statements to `console.log`.
    We can simply reference the variables. We''ll add `console.log` and we''ll use
    template strings in the `console.log` statement, so that we can inject the previous
    mentioned two values inside of quotes: `It''s currently`, followed by `temperature`.
    Then we can add a period, `It feels like`, followed by `apparentTemperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our string printing to the screen, we can test that our app
    works as expected. We''ll save the file and inside Terminal, we''ll rerun the
    command from two commands ago where we had a valid zip code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45cf383a-3a5f-4c59-a096-2ba3d38088a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run this, we get the weather info for `Flemington`, New Jersey. It''s
    currently `84` degrees, but it feels like `90`. If we run something that has a
    bad address, we do get the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b8c8c29-25de-44af-8688-7ebd557f4cc8.png)'
  prefs: []
  type: TYPE_IMG
- en: So everything looks great! Using the `axios` library, we're able to chain promises
    like the app-promise without needing to do anything too crazy. The `axios get`
    method returns a promise, so we can access it directly using then.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we use then once to do something with that geolocation data. We
    print the address to the screen. Then we return another promise, where we make
    the request for the weather. Inside of our second `then` call, we print the weather
    to the screen. We also added a catch call, which will handle any errors. If anything
    goes wrong with either of our promises, or if we throw an error, catch will get
    fired printing the messages to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This is all it takes to use axios and set up promises for your HTTP requests.
    Now one reason people love promises over traditional callbacks is that instead
    of nesting we can simply chain. So our code doesn't get indented to crazy levels.
    As we saw in `app.js` in the previous chapter, we went a few indentation levels
    deep just to add two calls together. If we needed to add a third it would have
    gotten even worse. With promises, we can keep everything at the same level, keeping
    our code a lot easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've gone through a quick example of how promises work, by
    going over just the very fundamentals. Async is a critical part to Node.js. We
    went through the very basics of callbacks and promises. We looked a few examples,
    creating a pretty cool weather app.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our asynchronous Node.js programming, but this
    does not mean that you have to stop building out the weather app. There are a
    couple ideas as to what you could do to continue on with this project. First up,
    you can load in more information. The response we get back from the weather API
    contains a ton of stuff besides just the current temperature, which is what we
    used. It'd great if you can incorporate some of that stuff in there, whether it's
    high/low temperatures, or chances of precipitation.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, it'd be really cool to have a default location ability. There would
    be a command that lets me set a default location, and then I could run the weather
    app with no location argument to use that default. We could always specify a location
    argument to search for weather somewhere else. This would be an awesome feature,
    and it would work kind of similar to the Notes app, where we save data to the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start creating web servers, which will be async.
    We'll make APIs, which will be async. Also, we'll create real-time Socket.IO apps,
    which will be async. We'll move on to creating Node apps that we deploy to servers,
    making those servers accessible to anybody with a web connection.
  prefs: []
  type: TYPE_NORMAL
