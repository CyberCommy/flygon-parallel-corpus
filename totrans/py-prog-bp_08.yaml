- en: Order Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to extend the web application that we implemented
    in [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml), *Online Video Game
    Store with Django*. I don't know if you noticed, but there are a few important
    things missing in that project. The first is the ability to submit an order. As
    of right now, users can browse products and add items to the shopping cart; however,
    there's no way of sending the order and completing the purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Another item that is missing is a page where the users of our application will
    be able to see all the orders that have been sent, as well as a history of their
    orders.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, we are going to create a microservice called *order,* which will
    do everything related to orders made on the site. It will receive orders, update
    orders, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of how to create microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Django REST Framework to create RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to consume the services and integrate them with other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy an application on AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run our web application with Gunicorn behind the HTTP proxy `nginx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like all the previous chapters, we are going to start off this chapter by setting
    up the environment that we need to develop our services on. Let''s start by creating
    our working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our virtual environment with `pipenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you don't know how to use `pipenv`, in the section *Setting up the environment*
    in [Chapter 4](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml), *Exchange Rates and
    the Currency Conversion Tool,* there is a very good introduction about how to
    get started with `pipenv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the virtual environment created, we need to install the project dependencies.
    For this project, we are going to install Django and the Django REST Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason that we are using Django and the Django REST Framework instead of
    a simpler framework like Flask is that the main idea of this project is to provide
    a separation of concerns, creating a microservice that will handle orders made
    in the online game store that we developed in the previous chapter. We don't want
    to only provide APIs to be consumed by the web application. It would be great
    to have a simple website so that we can list the orders, see the details of each
    order, and also perform updates such as changing the order's status.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, Django already has a very powerful and flexible
    admin UI that we can customize to provide that kind of functionality to our users--all
    without spending too much time developing a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the dependencies, your `Pipfile` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now, we can start a new Django project. We are going to create the
    project using the `django-admin` tool. Let''s go ahead and create a project called
    `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With the project created, we are going to create a Django app. For this project,
    we are going to create just one app that is going to be called `main`. First,
    we change the directory to the service directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we use the `django-admin` tool to create an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Django app, your project structure should look similar to
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we are going to start creating the model for our service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the service models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part of the order service, we are going to create the model that
    will store data about the order coming from the online video game store. Let''s
    go ahead and open the `models.py` file in the main app directory and start adding
    the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will create a class called `OrderCustomer` that inherits from `Model`, and
    define three properties; the `customer_id`, which will correspond to the customer
    ID in the online game store, the `name` of the customer, and lastly, the `email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will create the model that will store information about the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Order` class inherits from `Model`, and we start this class by adding a
    tuple containing the status that the orders in our application can have. We also
    define a foreign key, `order_customer`, which will create the relationship between
    the `OrderCustomer` and `Order`. It is then time to define other fields, starting
    with `total`, which is the total purchase value of that order. We then have two
    datetime fields; `created_at`, which is the date that the order has been submitted
    by the customer, and `last_update`, which is a field that is going to be used
    when we want to know when the order has a status update.
  prefs: []
  type: TYPE_NORMAL
- en: When adding `auto_now_add` to a `DateTimeField`, Django uses the `django.utils.timezone.now`
    function, which will return the current `datetime` object with timezone information.
    DateField uses `datetime.date.today()`, which does not contain timezone information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last model that we are going to create is `OrderItems`. This will hold
    items belonging to an order. We will define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also define a `Meta` class so we can set some metadata to the model.
    In this case, we are setting the `verbose_name_plural` to `Order items` so that
    it looks correctly spelled in the Django admin UI. Then, we define `product_id`,
    `name`, `quantity`, and `price_per_unit`, which refer to the `Game` model in the
    online video game store.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the item quantity and the foreign key `Order`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to edit the `settings.py` file in `microservices/order/order`
    directory and add the main app to `INSTALLED_APPS`. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left is to create and apply the database migrations. First,
    we run the command `makemigrations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And `migrate` to apply the changes to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating the model's managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our application more readable and not clutter the endpoints with a lot
    of business logic, we are going to create managers for our model classes. If you
    followed the previous chapter, you should be very familiar with this. In a nutshell,
    managers are an interface that provide query operations to Django models.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Django adds a manager to every model; it is stored on a property
    named objects. The default manager that Django adds to the models is sometimes
    sufficient and there's no need to create a custom manager, but it is a good practice
    to keep all database-related code within the model. This will make our code more
    consistent, readable, and easier to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the only model we are interested in creating is a custom model
    manager called Order, but before we start implementing the order manager, we need
    to create a few helper classes. The first class that we need to create is a class
    that will define custom exceptions that may occur when performing queries on our
    database. Of course, we could use the exceptions that are already defined in the
    standard library, but it is always a good practice to create exceptions that make
    sense within the context of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The three exceptions that we are going to create are `InvalidArgumentError`,
    `OrderAlreadyCompletedError`, and `OrderCancellationError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception `InvalidArgumentError` will be raised when invalid arguments
    are passed to the functions that we are going to define in the manager, so let''s
    go ahead and create a file called `exceptions.py` in the main app directory with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a class called `InvalidArgumentError` that inherits from `Exception`,
    and the only thing we do in it is override the constructor and receive an argument
    called `argument_name`. With this argument, we can specify what caused the exception
    to be raised.
  prefs: []
  type: TYPE_NORMAL
- en: We will also customize the exception message, and lastly, we will call the constructor
    on the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to create an exception that will be raised when we try to
    cancel an order that has the status as canceled, and also when we try to set the
    status of an order to completed when the order is already completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to add two more custom exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These two classes don't do too much. They only inherit from `Exception`. We
    will configure and customize a message for each exception and pass it over to
    the super class initializer. The value of adding custom exception classes is that
    it will improve the readability and maintainability of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! There is only one more thing we need to add before starting with the
    manager. We will create functions in the model manager that will return data filtered
    by status. As you can see, in the definition of the `Order` model, we defined
    the status like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Which means that if we want to get all the orders with a status of `Completed`,
    we would need to write something similar to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one problem with this code, can you guess what? If you guessed
    that *magic* number, `5`, you are absolutely right! Imagine how frustrated our
    colleagues would be if they needed to maintain this code and see only the number
    `5` there and have no idea what 5 actually means. Because of this, we are going
    to create an enumeration that we can use to express the different statuses. Let''s
    create a file called `status.py` in the `main` app directory and add the following
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, when we need to get all the orders with a `Completed` status, we can
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Much better!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the model manager for it. Create a file called `managers.py`
    in the mail app directory, and we can start by adding a few imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `OrderManager` class and the first method called `set_status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two parameters, order, and status. The `order` is an object
    of type `Order` and the status is an item of the `Status` enumeration that we
    created previously.
  prefs: []
  type: TYPE_NORMAL
- en: We start this method by validating the arguments and raising the corresponding
    exception. First, we validate if the fields have a value and are the correct type.
    If the validation fails, it will raise an `InvalidArgumentError`. Then, we check
    if the order that we are trying to set the status for is already completed; in
    this case, we cannot change it anymore, so we raise an `OrderAlreadyCompletedError`.
    If all the arguments are valid, we set the order's status and save.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we want to be able to cancel an order that is still not
    being processed; in other words, we will allow orders to be canceled only if the
    status is `Received`. Here is what the `cancel_order` method should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method only gets the `order` argument, and first, we need to check if the
    order object is valid and raise an `InvalidArgumentError` if it is invalid. Then,
    we check if the order's status is `not Received`. In this case, we raise an `OrderCancellationError`
    exception. Otherwise, we go ahead and call the `set_status` method, passing `Status.Cancelled` as
    an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to get a list of all orders for a given customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `get_all_orders_by_customer` method gets the `customer_id` as an argument. Then,
    we use the filter function to filter orders by the `customer_id` and we also order
    it by status; the orders that are still being processed will be on the top of
    the QuerySet.
  prefs: []
  type: TYPE_NORMAL
- en: In case the `customer_id` is invalid, for example, if we pass a string instead
    of an integer, a `ValueError` exception will be raised. We catch this exception
    and raise our custom exception `InvalidArgumentError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The financial department of our online video game store had the requirement
    of getting a list of all complete and incomplete orders for a specific user, so
    let''s go ahead and add some methods for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first method, `get_customer_incomplete_orders`, gets an argument called `customer_id`.
    It is like the previous method; we will catch a `ValueError` exception in case
    the `customer_id` is invalid, and raise an `InvalidArgumentError`. The interesting
    part of this method is the filter. Here, we use a `Q()` object, which encapsulates
    an SQL expression in the form of a `Python` object.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have `~Q(status=Status.Completed.value)`, which is the '`not`' operator,
    which is the same as saying the status is not `Status.Complete`. We also filter
    `order_customer_id` to check if it's equal to the method's `customer_id` argument,
    and lastly, we order the QuerySet by status.
  prefs: []
  type: TYPE_NORMAL
- en: '`get_customer_completed_orders` is basically the same, but this time, we filter
    orders that have a status equal to `Status.Completed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Q()` object allows us to write much more complex queries making use of
    `|` (OR) and `&` (AND) operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, every department that is responsible for taking care of the order life
    cycle wants an easy way to get orders at a certain stage; for example, the workers
    responsible for shipping the games want to get a list of all orders that have
    a status equal to `Payment Complete` so they can ship these orders to the customers.
    So, we need to add a method that will do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple method; here, we get the status as an argument. We check
    if the status is valid; if not, we raise an `InvalidArgumentError`. Otherwise,
    we continue and filter the orders by status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another requirement from our finance department is to get a list of orders
    in a given date range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get two parameters, `start_date` and `end_date`. As with all the other
    methods, we start by checking if these arguments are valid; in this case, the
    arguments cannot be `None` and have to be an instance of the `Datetime` object.
    If any of the fields are invalid, an `InvalidArgumentError` will be raised. When
    the arguments are valid, we filter the orders using the `created_at` field and
    we also use this special syntax, `created_at__range`, which means that we are
    going to pass a date range and it will be used as a filter. Here, we are passing
    `start_date` and `end_date`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just one method that might be interesting to implement and it can
    add value to the administrators of our application. The idea here is to add a
    method that, when called, automatically changes the order to the next status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method gets just one argument, the order. We check if the order is valid,
    and if it is invalid, we raise an `InvalidArgumentError`. We also want to make
    sure that once the order gets to the `Completed` status, it can no longer be changed.
    So, we check if the order is of the status `Completed`, then we raise an `OrderAlreadyCompleted`
    exception. Lastly, we add `1` to the current status and save the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can change our `Order` model so that it makes use of the `OrderManager`
    that we just created. Open the model.py file in the main app directory, and at
    the end of the `Order` class, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, now we can access all the methods that we defined in the `OrderManager`
    through `Order.objects`.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to add tests to our model manager methods.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we haven't covered how to create tests. Now is a good time
    to do that, so we are going to create tests for the methods that we created in
    the model manager.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need tests? The short answer to this question is that tests will allow
    us to know that the methods or functions are doing the right thing. The other
    reason (and one of the most important, in my opinion) is that tests give us more
    confidence when it comes to performing changes in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Django has great tools out of the box for creating unit and integration tests,
    and combined with frameworks like Selenium, it is possible to basically test all
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, let's create our first tests. Django creates a file called `test.py`
    in the `app` directory when creating a new Django app. You can write your tests
    in there, or if you prefer to keep the project more organized by separating the
    tests into multiple files, you can remove that file and create a directory called
    `tests` and place all your tests files in there. Since we are only going to create
    tests for the Order model manager, we are going to keep all the tests in the `tests.py`
    file that Django created for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `test.py` file and let''s start by adding a few imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Great! We start by importing the relative delta function so we can easily perform
    date operations, like adding days or months to a date. This will be very helpful
    when testing the methods that get orders for a certain period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we import some Django-related things. First is the `TestCase` class, which
    is a subclass of `unittest.TestCase`. Since we are going to write tests that will
    interact with the database, it is a good idea to use `django.tests.TestCase` instead
    of `unittest.TestCase`. Django's `TestCase` implementation will make sure that
    your test is running within a transaction to provide isolation. This way, we will
    not have unpredictable results when running the test because of data created by
    another test in the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: We also import some of the model classes that we are going to use in our test,
    the `Order`, the `OrderCustomer` models, and also the Status class when we are
    going to test the method that changes order statuses.
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests for your application, we don't want to only test the *good* scenarios,
    we also want to test when things go wrong, and bad arguments are passed to the
    functions and methods that are being tested. For this reason, we are importing
    our custom error classes, so we can make sure that the right exception is being
    raised in the right situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the imports in place, it is time to create the class and the
    method that will set up data for our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a class called `OrderModelTestCase`, inheriting from the `django.test.TestCase`.
    Then, we define the `setUpTestData` method, which will be the method that will
    be responsible for setting up the data that will be used by each test.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create two users; the first one has two orders and one of the orders
    is set to `Completed`. The second user has only one order.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the cancel order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first method that we are going to test is the `cancel_orders` method. As
    the name says, it will cancel an order. There a few things we want to test in
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test is quite straightforward; we only want to test if we can cancel
    an order, setting its status to `Cancelled`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test is that it shouldn't be possible to cancel orders that have
    not been received; in other words, only the orders that have the current status
    set to `Received` can be canceled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to test if the correct exception is raised in case we pass an invalid
    argument to the `cancel_order` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that said, let''s add our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first test, `test_cancel_order`, starts off by getting an order with ID
    1\. We assert that the returned value is not `None` using the `assertIsNotNone`
    function, and we also use the function `assertEqual` to make sure that the order
    has the status '`Received`'.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `cancel_order` method from the order model manager passing
    the order, and lastly, we use the `assertEqual` function again to verify that
    the order's status is in fact changed to `Cancelled`.
  prefs: []
  type: TYPE_NORMAL
- en: The second test, `test_cancel_complated_order`, starts by getting the order
    with ID equal to `2`; remember that we have set this order with the `Completed` status.
    Then, we do the same thing as the previous test; we verify that the order is not
    equal to `None`, and we verify that the status is set to `Complete`. Finally,
    we use the `assertRaises` function to test that the correct exception is raised
    if we try to cancel an order that is already cancelled; in this case, an exception
    of type `OrderCancellationError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the `test_cancel_order_with_invalid_argument` function, which
    will test if the correct exception will be raised if we pass an invalid argument
    to the `cancel_order` function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the get all orders function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to add tests to the `get_all_orders_by_customer` method.
    For this method, we need to test:'
  prefs: []
  type: TYPE_NORMAL
- en: If the correct number of orders is returned when given a customer ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the correct exception is raised when passing an invalid argument to the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The tests for the `get_all_orders_by_customer` method are quite simple. In the
    first test, we fetch the orders for the customer with ID `1` and test if the returned
    number of items is equal to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, we assert if calling `get_all_orders_by_customer` with an
    invalid argument, in fact, raises an exception of type `InvalidArgumentError`.
    In this case, the test will successfully pass.
  prefs: []
  type: TYPE_NORMAL
- en: Getting customer's incomplete orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get_customer_incomplete_orders` method returns all the orders with the
    statuses that are different from `Completed` given a customer ID. For this test,
    we need to verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: The method returns the correct number of items and also if the item returned
    does not have a status equal to `Completed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to test if an exception is raised when an invalid value is passed
    as an argument to this method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The test `test_get_customer_incomplete_orders` starts off by calling the  `get_customer_incomplete_orders` function
    and passing as an argument a customer ID equal to `1`. Then, we verify that the
    number of returned items is correct; in this case, there's only one incomplete
    order, so it should be `1`. Lastly, we check if the item that was returned in
    fact has a status different to `Completed`.
  prefs: []
  type: TYPE_NORMAL
- en: The other test, exactly like the previous one testing that tested exceptions,
    just calls the method and asserts that the correct exception has been raised.
  prefs: []
  type: TYPE_NORMAL
- en: Getting customer's completed orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to test `get_customer_completed_order`. This method, as
    the name says, returns all the orders that have a status of `Completed` for a
    given customer. Here, we will test the same scenarios as `get_customer_incompleted_orders`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `get_customer_completed_orders`, passing a customer ID equal
    to `1`, and then we verify that the number of items returned is equal to `1`.
    To finish it up, we verify that the item that was returned has, in fact, a status
    set to `Completed`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting orders by status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get_order_by_status` function returns a list of orders given a status.
    There are two scenarios we have to test here:'
  prefs: []
  type: TYPE_NORMAL
- en: If the method returns the correct number of orders given a specific status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the correct exception is raised when passing an invalid argument to the
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Simple enough. The first test we call is `get_orders_by_status`, passing as
    an argument `Status.Received`. Then, we verify that only two orders are returned.
  prefs: []
  type: TYPE_NORMAL
- en: For the second test, for the `get_order_by_status` method, like the previous
    exceptions tests, run the method, passing an invalid argument and then verify
    that the exception of type `InvalidArgumentError` has been raised.
  prefs: []
  type: TYPE_NORMAL
- en: Getting orders by period
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to test the `get_order_by_period` method, which returns a
    list of orders given an initial and an end date. For this method, we are going
    to perform the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the method, passing as arguments, and orders created within that period
    should be returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the method, passing as arguments valid dates where we know that no orders
    were created, which should return an empty result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test if an exception is raised when calling the method, passing an invalid start
    date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test if an exception is raised when calling the method, passing an invalid end
    date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start this method by creating `date_from`, which is the current date minus
    one day. Here, we use the `relativedelta` method of the `python-dateutil` package
    to perform date operations. Then, we define `date_to`, which is the current date
    plus two days.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our period, we can pass these values as arguments to the `get_orders_by_period`
    method. In our case, we set up three orders, all created with the current date,
    so this method call should return exactly three orders.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a different period where we know that there won't be any orders.
    The `date_from` function is defined with the current date plus three days, so `date_from`
    is the current date plus `1` month.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the method again passing the new values of `date_from` and `date_to`
    should not return any orders.
  prefs: []
  type: TYPE_NORMAL
- en: The last two tests for `get_orders_by_period` are the same as the exception
    tests that we implemented previously.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the order's next status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next method from the `Order` model manager that we are going to create is
    the `set_next_status` method. The `set_next_status` method is just a method that
    can be used for convenience and it will set the next status of an order. If you
    remember, the `Status` enumeration that we created means that every item in the
    enumeration is set to `auto()`, which means that items in the enumeration will
    get a numeric sequential number as a value.
  prefs: []
  type: TYPE_NORMAL
- en: When we save an order in the database and set its status to, for example, `Status.Processing`,
    the value of the status field in the database will be `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The function simply adds `1` to the current order's status, so it goes to the
    next status item unless the status is `Completed`; that's the last status of the
    order's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have refreshed our memories about how this method works, it is
    time to create the tests for it, and we will have to perform the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: That the order gets the next status when `set_next_status` is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test if an exception will be raised when calling `set_next_status` and passing
    as an argument an order with the status `Completed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test if an exception is raised when passing an invalid order as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first test, `test_set_next_status`, starts by getting the order with an
    ID equal to `1`. Then, it asserts that the order object is not equal to none,
    and we also assert that the value of the order's status is `Received`. Then, we
    call the `set_next_status` method, passing the `order` as an argument. Right after
    that, we assert again to make sure that the status has changed. The test will
    pass if the order's status is equals to `2`, which is `Processing` in the `Status`
    enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: The other two tests are very similar to the order test where we assert exceptions,
    but it is worth mentioning that the test `test_set_next_status_on_completed_order` asserts
    that if we try calling the `set_next_status` on an order that has a status equal
    to `Status.Completed`, then an exception of type `OrderAlreadyCompletedError`
    will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the order's status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we are going to implement the last tests of the `Order` model manager.
    We are going to create tests for the `set_status` method. The `set_status` method
    does exactly what the name implies; it will set a status for a given order. We
    need to perform the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Set a status and verify that the order's status has really changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the status in an order that is already completed; it should raise an exception
    of type `OrderAlreadyCompletedError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the status in an order that is already canceled; it should raise an exception
    of type `OrderAlreadyCancelledError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `set_status` method using an invalid order; it should raise an exception
    of type `InvalidArgumentError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `set_status` method using an invalid status; it should raise an exception
    of type `InvalidArgumentError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to go through all the tests where we are testing exceptions,
    because they are similar to the tests that we implemented previously, but it is
    worth going through the first test. On the test `test_set_status`, it will get
    the order with an ID equal to `1`, which as we defined in the `setUpTestData`,
    has a status equal to `Status.Received`. We call the `set_status` method passing
    the order and the new status as arguments, in this case, `Status.Processing`.
    After setting the new status, we just call `assertEquals` to make sure that the
    order's status in fact changed to `Status.Processing`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the order model serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have everything we need to start creating out API endpoints. In this
    section, we are going to create endpoints for every method that we implemented
    in the `Order` manager.
  prefs: []
  type: TYPE_NORMAL
- en: For some of these endpoints, we are going to use the Django REST Framework.
    The advantage of using the Django REST Framework is that the framework includes
    a lot of out of the box features. It has different authentication methods, a really
    robust serialization of objects, and my favorite is that it will give you a web
    interface where you can browse the API, which also contains a large collection
    of base classes and mixins when you need to create class-based views.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's dive right into it!
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we need to do at this point is to create serializer classes
    for the entities of our model, the `Order`, `OrderCustomer`, and `OrderItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a file called `serializers.py` in the main `app` directory,
    and let''s start by adding a few import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the `functools` module from the standard library; then,
    we import the serializer from the `rest_framework` module. We are going to use
    it to create our model serializers. Lastly, we will import the models that we
    are going to use to create the `serializers`, the `Order`, `OrderItems`, and `OrderCustomer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first serializer that we are going to create is the `OrderCustomerSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderCustomerSerializer` inherits from `ModelSerializer` and it is quite
    simple; it just defines some class metadata. We will set the model, the `OrderCustomer,`
    and also the property fields which will contain a tuple with the fields, that
    we are going to serialize.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create the `OrderItemSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderItemSerializer` is pretty similar to the `OrderCustomerSerializer`.
    The class also inherits from `ModelSerializer` and defines a couple of metadata
    properties. The first one is a model, which we set to `OrderItems`, and then the
    fields with a tuple containing every model field that we want to serialize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last serializer that we are going to create is the `OrderSerializer`, so
    let''s start by defining a class called `OrderSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: First, we define two properties. The `items` property is set to `OrderItemSerializer`,
    which means that it will use that serializer when we need to serialize the JSON
    data that we are going to send when we want to add new orders. The `items` property
    refers to the items (the games) that an order contains. Here, we use only one
    keyword argument `(many=True)`. This will tell you that the serializer items will
    be an array.
  prefs: []
  type: TYPE_NORMAL
- en: The status field is a little bit special; if you remember the status field in
    the `Order` model, it is defined as a `ChoiceField`. When we save an order in
    the database, that field will store the value `1` if the order has a status of `Received`,
    `2` if the status is `Processing`, and so on. When the consumers of our API call
    the endpoint to get orders, they will be interested in the name of the status
    and not the number.
  prefs: []
  type: TYPE_NORMAL
- en: So, the solution to this problem is to define the field as `SerializeMethodField`,
    and then we are going to create a function called `get_status`, which will return
    the display name of the order's status. We are going to see what the implementation
    of the `get_status` method looks like in a short while.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the `order_customer` property, which is set to `OrderCustomerSerializer`,
    and that means that the framework will use the `OrderCustomerSerializer` class
    when trying to deserialize the JSON object we send when trying to add a new order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define a `Meta` class, so that we can add some metadata information
    to the serializer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first property, `depth`, specifies the depth of the relationships that should
    be traversed before the serialization. In this case, it is set to `1`, because
    when fetching an order object, we also want to have information about the customers
    and items. Like the other serializers, we set the model to `Order` and the fields
    property specifies which fields will be serialized and deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implement the `get_status` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is the method that will get the display value for the `ChoiceField` status.
    This will override the default behavior and return the result of the `get_status_display()` function
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_created_order_item` method is just a helper method which we are going
    to use to create and prepare the order item''s objects prior to performing a bulk
    insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are going to get two arguments. The first argument will be a dictionary
    with the data about the `OrderItem` and an `order` argument with an object of
    type `Order`. First, we update the dictionary passed in the first argument, adding
    the `order` object, then we call the `OrderItem` constructor, passing the items
    as an argument in the `item` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am going to show you what that''s used for a short while. Now that we have
    got to the core of this serializer, we are going to implement the `create` method,
    which will be a method that will be called automatically every time we call the
    serializer''s `save` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the create method will be called automatically when calling the `save`
    method, and it will get the `validated_data` as an argument. The `validated_date`
    is a validated, de-serialized order data. It will look similar to the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this JSON, we are passing all the information at once. Here,
    we have the `order`, the `items` property, which is a list of order items, and
    the `order_customer`, which contains information about the customer who submitted
    the order.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have to perform the creation of these objects individually, we first
    pop the `order_customer` and the `items` so we have three different objects. The
    first, `validated_customer`, will only contain data related to the person who
    made the order. The `validated_items` object will only contain data related to
    each item of the order, and finally, the `validated_data` object will only contain
    data related to the order itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'After splitting the data, we can now start adding the objects. We start by
    creating an `OrderCustomer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the order. The `Order` has a foreign key field called `order_customer`,
    which is the customer that is connected to that particular Order. What we need
    to do is create a new item in the `validated_data` dictionary with a key called `order_customer`,
    and set its value to the customer that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we are going to add  `OrderItems`. Now, to add the order items, we need
    to do a few things. The `validated_items` variable is a list of items that belong
    to the underlying order, and we need to first set the order to each one of these
    items, and create an `OrderItem` object for each one of the items on the list.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways of performing this operation. You could do it in two
    parts; for example, first loop through the item's list and set the order property,
    then loop through the list again and create the `OrderItem` objects. However,
    that wouldn't be so elegant, would it?
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach here is to take advantage of the fact that Python is a multi-paradigm
    programming language, and we can solve this problem in a more functional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make use of one of the built-in function maps. The `map` function will
    apply a function that I specify as the first argument to an iterable that is passed
    as the second argument, which then returns an iterable with the results.
  prefs: []
  type: TYPE_NORMAL
- en: The function that we are going to pass as the first argument to map is a function
    called `partial`, from the `functools` module. The `partial` function is a high-order
    function, meaning that it will return another function (the one in the first argument)
    and will add the argument and keyword arguments to its signature. In the preceding
    code, it will return `self._create_order_item`, and the first argument will be
    an item of the iterable `validated_items`. The second argument is the order that
    we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the value of `mapped_items` should contain a list of `OrderItem`
    objects, and the only thing left to do is call `bulk_create`, which will insert
    all the items on the list for us.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to create the views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create the views, we are going to create some helper classes and
    functions that will make the code in the view simpler and clean. Go ahead and
    create a file called `view_helper.py` in the main app directory, and as usual,
    let''s start by including the import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import some things from the Django REST Framework, the main one being
    the generic, which contains definitions for the generic view classes that we are
    going to use to create our own custom views. The status contains all the HTTP
    status codes, which are very useful when sending the response back to the client.
    Then, we import the `Response` class, which will allow us to send content to the
    client that can be rendered in different content types, for example, JSON and
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we import the `HttpResponse` from Django with its equivalent of `Response`
    in the rest framework.
  prefs: []
  type: TYPE_NORMAL
- en: We also import all the custom exceptions that we implemented previously, so
    we can handle the data properly and send useful error messages to the client when
    something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import the `OrderSerializer`, which we will use for serialization,
    deserialization, and the validation model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first class that we are going to create is the `OrderListAPIBaseView` class,
    which will serve as a base class for all the views that will return a list of
    content to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderListAPIBaseView` inherits from generics. `ListAPIView` provides us
    with get and list methods, which we can override to add functionality which meets
    our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The class starts by defining two properties; `serializer_class`, which is set
    to `OrderSerializer`, and the `lookup_field`, which in this case we set to empty
    string. We will override this value in the child classes. Then, we define the
    `get_queryset` method, and that is also going to be overridden in the child classes.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we implement the list method, which will first run the `get_queryset`
    method to get the data that will be returned to the user. If an error occurs,
    it will return a response with status `400` (`BAD REQUEST`), otherwise, it will
    use the `OrderSerializer` to serialize the data. The `result` argument is the
    `QuerySet` result returned by the `get_queryset` method, and the `many` keyword
    argument tells the serializer that we will serialize a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: When the data is serialized properly, we send a response with status `200` (OK)
    with the results of the query.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of this base class is that all the children classes will only need
    to implement the `get_queryset` method, which will keep the view classes small
    and neat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add a function that will help us with the methods that
    will perform a `POST` request. Let''s go ahead and add a function called `set_status_handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This function is very simple; it will just get a function as an argument. Run
    the function; if one of the exceptions occurs, it will return a `400` (`BAD REQUEST`)
    response back to the client, otherwise, it will return a `204` (`NO CONTENT`)
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Adding views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to start adding the views! Open the `views.py` file in the
    main `app` directory, and let''s add some import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, we will import the `HttpReponse` from the `django.http` module and `get_object_or_404`
    from the `django.shortcuts` module. The latter is just a helper function that
    will get an object, and in case it cannot find it, it will return a response with
    the status `440` (`NOT FOUND`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we import generics for creating generic views and statuses, and from the `rest_framework`,
    we import the `Response` class.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import some of the models, helper methods, and functions, and the
    serializer that we are going to be using in the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be ready to start creating the views. Let''s create a view that will
    get all the orders for a given customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Nice! So, we created a class that inherits from the base class `(OrderListAPIBaseView)`,
    which we created in the `view_helpers.py`, and since we have already implemented
    the list method, the only method that we needed to implement here was the `get_queryset`.
    The `get_queryset` method gets a `customer_id` as an argument and simply calls
    the `get_all_orders_by_customer` that we created in the `Order` model manager,
    passing the `customer_id`.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined the value of the `lookup_field`, which will be used to get the
    value of the keyword argument that is passed on to the `kwargs` of the list method
    on the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two more views to get the incomplete and complete orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Pretty much the same as the first view that we implemented, we define the `lookup_field`
    and override the `get_queryset` to call the appropriated method in the `Order`
    model manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add a view that will get a list of orders when given a
    specific status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we are defining the `lookup_field` as `status_id` and we
    override the `get_queryset` to call `get_orders_by_status`, passing the status
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `Status`(`status_id`), so we pass the `Enum` item and not only
    the ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the views that we implemented so far will only accept `GET` requests and
    it will return a list of orders. Now, we are going to implement a view that supports
    `POST` requests so we are able to receive new orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, this class differs a bit from the previous ones that we created, the base
    class being generics. `CreateAPIView` provides us with a `post` method, so we
    override that method in order to add the logic that we need. First, we get the
    request's data and pass it as an argument to the `OrderSerializer` class; it will
    deserialize the data and set it to the serializer variable. Then, we call the
    method `is_valid()`, which will validate the received data. If the request's data
    is not valid, we return a `400` response (`BAD REQUEST`), otherwise, we go ahead
    and call the `save()` method. This method will internally call the `create` method
    on the serializer, and it will create the new order along with the new order's
    customer and the order's items. If everything goes well, we return a `202` response
    (`CREATED`) together with the ID of the newly created order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create three functions that will handle the order canceling,
    setting the next order''s status, and lastly, setting a specific order''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are not using the Django REST framework class-based views
    here. We are just using regular functions. The first one, the `cancel_order` function,
    gets two parameters—the request and the `order_id`. We start by using the shortcut
    function, `get_object_or_404`. The `get_object_or_404` function returns a `404`
    response (`NOT FOUND`) if it cannot find the object matching the criteria passed
    in the second argument. Otherwise, it will return the object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the helper function `set_status_handler` that we implemented in
    the `view_helpers.py` file. This function gets another function as an argument.
    So, we are passing a `lambda` function that will execute the method in the `Order`
    model manager that we want. In this case, when the `lambda` function is executed,
    it will execute the `cancel_order` method that we defined in the `Order` model
    manager, passing the order that we want to cancel.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_next_status` function is quite similar, but instead of calling the
    `cancel_order` inside of the `lambda` function, we will call `set_next_status`,
    passing the order that we want to set to the next status.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_status` function contains a bit more logic in it, but it is also quite
    simple. This function will get two arguments, the `order_id` and the `status_id`.
    First, we get the order object, then we look up the status using the `status_id`.
    If the status doesn't exist, a `ValueError` exception will be raised and then
    we return a `400` response (`BAD REQUEST`). Otherwise, we call the `set_status_handle`,
    passing a `lambda` function that will execute the `set_status` function passing
    the order and the status objects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the service URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the views in place, it is a good time to start setting
    up the URLs that the users of our order service can call to fetch and modify orders.
    Let''s go ahead and open the `urls.py` file in the main `app` directory; first,
    we need to import all the view classes and functions that we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now, we can start adding the URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To add new URLs, we need to use the `path` `function` to pass the first argument,
    the `URL`. The second argument is the function that will be executed when a request
    is sent to the `URL` specified by the first argument. Every URL that we create
    has to be added to the `urlspatterns` list. Note that Django 2 simplified how
    parameters were added to the URL. Previously, you would need to some using regular
    expressions; now, you can just follow the notation `<type:param>`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we try this out, we have to open the `urls.py` file, but this time in
    the order directory because we need to include the URLs that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `urls.py` file should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want all the URLs that we defined on the main app to be under `/api/`.
    To achieve this, the only thing we need to do is create a new route and include
    the URLs from the main app. Add the following code in the `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s not forget to import the `include` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The order service won't be public when we deploy it to the AWS; however as an
    extra security measure, we are going to enable token authentication for this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the service''s APIs, we will have to send an authentication token.
    Let''s go ahead and enable it. Open the `settings.py` file in the `order` directory
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can place this right after `INSTALLED_APPS`.
  prefs: []
  type: TYPE_NORMAL
- en: The `DEFAULT_PERMISSION_CLASSES` function defines the global permission policy.
    Here, we set it to `rest_framework.permissions.IsAuthenticated`, which means that
    it will deny access to any unauthorized user.
  prefs: []
  type: TYPE_NORMAL
- en: The `DEFAULT_AUTHENTICATION_CLASSES` function specifies the global authentication
    schemas. In this case, we are going to use token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `INSTALLED_APPS`, we need to include the `rest_framework.authtoken`.
    Your `INSTALLED_APPS` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Save the file, and on the terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The Django REST framework has out of the box views, so the users can call and
    acquire a token. However, for simplicity, we are going to create a user who can
    have access to the APIs. Then, we can manually create an authentication token
    that can be used to do the request to the order service APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create this user. Start the service with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: And browse to `https://localhost:8000/admin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the AUTHENTICATION AND AUTHORIZATION tab, you will see the `Users` model.
    Click on Add and create a user with the username `api_user`. When the user is
    created, browse back to the admin first page and under the AUTH TOKEN**,** click
    on Add. Select the `api_user` in the drop-down menu and click SAVE. You should
    see a page like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/edccbabd-f4f7-4bf9-9e8a-930fe3e07c42.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the key and let's create a small script just to add an order so we can
    test the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `send_order.py`; it can be placed anywhere you want as
    long as you have the virtual environment activated, since we are going to use
    the package requests to send the order to the order services. Add the following
    content to the `send_order.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, we can start the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In another window, we will run the script that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a95e41c-4f91-4a4e-ab80-64223855e413.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What? Something went wrong here, can you guess what it is? Note the log message
    that was printed in the screenshot in the terminal where I have the Django development
    server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Ok, it says here that the server has received a PUT request to `/api/order/add/`,
    and one thing to notice here is that code `401` signifies `Unauthorized`. This
    means that the settings that we have added in the `settings.py` file worked fine.
    To call the APIs, we need to be authenticated, and we are using token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a token for a user, we need to log in in the Django administration
    UI. There, we will find the AUTH TOKEN section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2d36948d-637f-4279-8ae5-2ab99d1abc0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on that green plus sign on the right-hand side. Then, you can select
    the user you wish to create a token for and when you are ready, click save. After
    that, you will see a list of tokens that have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20e4a65d-5b1a-4455-9ed6-8aad6945c683.png)'
  prefs: []
  type: TYPE_IMG
- en: That key is the key you want to send in the request's **HEADER**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a token, we can modify the `send_order.py` script and add
    the token information to the request, so on the top of the `send_order` function,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The token variable is the token that we created for the user `api_user`. To
    get the token, just log in to the Django admin UI and under AUTH TOKEN, you will
    see the tokens that have been created. Just remove the token that I added here
    and replace it with the one that was generated for the `api_user` on your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to send the headers along with the request. Change the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go to the terminal and run our code again. You should see an output
    similar to the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b834857f-c578-4561-bf20-7c10a898da7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that now, we get the following log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This means that the authentication works properly. Go ahead and take the time
    to explore the Django admin UI and verify that now we have one customer and one
    order with a couple of items created on our database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try some of the other endpoints to see if they are working as expected.
    For example, we can get all the orders for that customer that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: You can perform small tests to the endpoints using any tool you want. There
    are a few very handy browser plugins that you can install, or, if you are like
    me and like to do everything on the terminal, you can use cURL. Alternatively
    if you want to try to build something with Python, there is the `httpie` package
    that you can install using pip. Use the `pip install httpie --upgrade --user` command
    to install `httpie` on your local directory under `./local/bin`. So, don't forget
    to add this directory to your PATH. I like to use `httpie` instead of cURL because
    `httpie` shows a nice and formatted JSON output so I can get a better view of
    the response that I'm getting back from the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try the first `GET` endpoint that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Just as expected. Go ahead and try the other endpoints!
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going back to the online video game store and send the order.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the game online store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the service up and running, we are ready to finish the online
    video game store project from [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml),
    *Online Video Game Store with Django*. We are not going to perform many changes,
    but there are two improvements that we are going to do:'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, in the online video game store, it is not possible to submit
    orders. The users of our site can only add items to the cart, visualize, and edit
    the cart's items. We are going to finish that implementation and create a view
    so that we can submit the order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to implement one more view where we can see the order history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get right to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change that we are going to do is add the authentication token for
    the `api_user` that we created in the service orders. We also want to add the
    base URL to the order service, so it will be easier for us to build up the URLs
    that we need to perform the requests. Open the `settings.py` file in the `gamestore`
    directory and add these two constant variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: It does not matter where you place this code, but maybe it's a good idea to
    just place it at the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change that we are going to do is add a `namedtuple` called `OrderItem`,
    just to help us prepare the order''s data so it is compatible with the format
    that the order service is expecting. Open the `models.py` file in the `gamestore/main`
    directory and add `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Another change to the models file is that we are going to add a new method
    in the `ShoppingCartManager` class called `empty`, so that when it''s called,
    it will remove all the cart''s items. Inside of the `ShoppingCartManager` class,
    add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the file, let''s create the `namedtuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we are going to change the `cart.html` template. Locate the `send
    order` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Nice! We just created a form around the button and added the Cross-Site Request
    Forgery token within the form, so that when we click the button, it will send
    a request to `cart/send`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the new URLs. Open the `urls.py` file in the main `app` directory,
    and let''s add two new URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You can place these two URL definitions right after the definition of the `/cart/` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.py` file and add some new imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a function that will help us with the serialization of the order
    data to be sent to the order service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two more views to add, the first being the `send_order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `my_orders` view, which will be the new view that returns the order
    history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create the `my-orders.html` file, which is going to be the template
    that is rendered by the `my_orders` view. Create a new file called `my-orders.html`
    in the `main/templates/main/` directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This template is very basic; it is just looping through the orders and then
    looping the items and building a HTML table with the item's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do some changes in `site.css`, where we have the custom styling
    of the online video game store. Open the `site.css` file in the `static/styles` folder
    and let''s do some modifications. First, locate this code, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this file, we can add stylings that are specific to the order
    history page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to add one more menu option that will be a link to the new
    `my orders` page. Open the `base.html` file in the `templates` directory in the
    applications `root` directory, and locate the menu option `CART`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after the closing `</li>` tag, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last change that we are going to do is improve the layout of error
    messages that we show in the UI. Locate this code at the end of the `base.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Testing the integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have everything in place. Now, we need to start both the website and the
    services so we can verify if everything is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that for testing, we will need to run the Django
    application in different ports. We can run the website (game online store) using
    the default port `800`, and for the order services, we can use port `8001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open two terminals; in one terminal, we are going to start the online video
    game store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'And, on the second terminal, we are going to start the order service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Great! Open the browser and head to `http://localhost:8000` and log in with
    our credentials. After logging in, you will notice that a few things are different.
    Now, there is a new option in the top menu called `ORDERS`. It should be empty,
    so go ahead and add a few items to the cart. When you are done, go to the cart
    view and click on the send order button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went right, you should see a notification at the top of the page,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23172db2-3235-40a2-8e5d-7fa0e02142bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! It worked just as expected. Notice that after sending the order to
    the order service, the shopping cart got emptied as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on the `ORDERS` option on the top menu, and you should see the order
    that we just submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a3ff13e-c15e-4cce-8cfa-7d66c14e0787.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to show the world the work that we have been doing so far.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to deploy the gamestore Django application and also the order service
    to EC2 instances in Amazon Web services.
  prefs: []
  type: TYPE_NORMAL
- en: This section is not about configuring Virtual Private Cloud, Security groups,
    Routing tables, and EC2 instances. Packt has plenty of excellent books and videos
    available that talk about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will assume that you already have your environment set up, and
    focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing all necessary dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using `gunicorn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring `nginx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'My AWS setup is quite simple, but it definitely works for more complex setups.
    Right now, I have one VPC with one subnet and two EC2 instances on it (`gamestore`
    and order-service). See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e36b74d3-ac74-4979-851d-878b9b9f5b7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can start with the `gamestore` application; connect via ssh to the EC2 instance
    that you wish to deploy the game online application on. Remember that to `ssh`
    in one of those instances, you will need to have the `.pem` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by updating any package that we have installed on that machine;
    it is not required, but it is a good practice since some of the packages may have
    security fixes and performance improvements that you probably want to have on
    your installs. Amazon Linux uses the `yum` package manager, so we run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Just answer yes `y` to any package that needs an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'These EC2 instances do not have Python installed by default, so we need to
    install it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install `nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we install our project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now, we can copy our application, exit this instance, and from our
    local machine, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This command will recursively copy all the files from the `gamestore` directory
    on our local machine over to our home directory in the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the settings.py file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one thing we have to change here. In the `settings.py` file, there
    is a list called `ALLOWED_HOSTS`, which was empty when we created the Django project.
    We will need to add the IP address of the EC2 that we are deploying the application
    to; in my case, it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to change the `ORDER_SERVICE_BASEURL` that we defined at the end
    of the file. It needs to be the address of the instance that we are going to deploy
    to the order service. In my case, the IP is `35.176.194.15`, so my variable will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create a folder to keep the application since it is not a good
    idea to keep the application running in the `ec2-user` folder. So, we are going
    to create a new folder in the `root` directory called `app` and copy the `gamestore`
    directory over to the newly created directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We need also to set the current permissions on that directory. When `nginx`
    is installed, it also creates a `nginx` user and a group. So, let''s change the
    ownership of the entire folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to set up `nginx`, edit the `/etc/nginx/nginx.conf` file,
    and under `service`, add the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to restart the `nginx` service so that the service reflects the changes
    that we just made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we go over to the `application` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application with `gunicorn`. We are going to start the application
    as an `nginx` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can browse to the site. You don't need to specify port `8000` since `nginx`
    will route the requests coming from port `80` to `127.0.0.1:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the order service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying the order service is pretty much the same as the `gamestore` project,
    the only difference is that we are going to install different Python dependencies
    and deploy the application in a different directory. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: You can pretty much repeat all the steps up until installing the `nginx` step.
    Also, make sure that you are using the elastic IP address of the other EC2 instance
    from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you install `nginx`, we can install the order service dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now copy the project file. Go to the directory where you have the service''s
    directory, and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `gamestore`, we also need to edit the `settings.py` file and add our EC2
    instance elastic IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create a folder in the `root` directory so the project is not
    laying around in the `ec2-user` home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the owner of the entire directory as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s edit the `/etc/nginx/nginx.conf` file, and, under `service`, add the
    following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This time, we don't need to configure the static folder since the order services
    don't have anything like images, templates, JS, or CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the `nginx` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Go over to the service''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'And start the application with `gunicorn`. We are going to start the application
    as an `nginx` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can browse to the address where the `gamestore` is deployed, and
    you should see the site up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to the site, you will see the first page. All the products are loading,
    and the login and logout sections are also working properly. Here''s a screenshot
    of my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9660d0a6-ccf9-4d45-981a-f541742d1c64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you browse to a view that makes use of the order service, for example, the
    orders section, you can verify that everything is working, and if you have placed
    any orders on the site, you should see the orders listed here, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b57770dd-21a8-4748-81ae-5c8326529984.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of topics in this chapter; we have built the order service
    that was responsible for receiving orders from the web application that we developed
    in the previous chapter. The order service also provides other features, such
    as the ability to update the status of orders and provide order information using
    different criteria.
  prefs: []
  type: TYPE_NORMAL
- en: This microservice was an extension of the web application that we developed
    in the previous chapter, and in the following chapter, we are going to extend
    it even further by adding serverless functions to notify the users of our application
    when an order is successfully received and also when the order's status has changed
    to shipped.
  prefs: []
  type: TYPE_NORMAL
