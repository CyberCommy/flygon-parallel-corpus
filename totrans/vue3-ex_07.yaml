- en: '*Chapter 7*: Creating a Shopping Cart System with GraphQL'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a travel booking system with Vue 3 and Express.
    This was the first project where we built from scratch our own backend that is
    used by the frontend. Having our own backend lets us do a lot more stuff that
    we can't do otherwise—for example, we can save the data that we like in the database
    that we created ourselves. Also, we added our own authentication system to authenticate
    the admin user. On the admin frontend, we protect our routes with the `beforeEnter`
    route guard, which checks for the authentication token before the admin user can
    log in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the GraphQL **application programming interface** (**API**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GraphQL API with Express
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the admin frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the customer frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter's project can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the GraphQL API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we created a backend with Express. The endpoint accepts
    JSON data as input and returns JSON data as a response. However, it can take any
    JSON data, which the backend may not expect. Also, there is no easy way to test
    our API endpoints without the frontend. This is something that we can solve with
    GraphQL APIs. **GraphQL** is a special query language that makes communication
    easier between the client and server. GraphQL APIs have a built-in data structure
    validation. Each property has a data type, which can be a simple or complex type,
    consisting of many properties with simple data types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: We can also test GraphQL APIs with GraphiQL, which is a web page that lets us
    make our own GraphQL API requests easily. Since there is a data type validation
    for each request, it can provide an autocomplete feature, according to the definition
    of the GraphQL API schema. The schema provides us with all the data type definitions
    that are used with queries and mutations. Queries are requests that let us query
    for data with our GraphQL API, while mutations are GraphQL requests that let us
    change data in some way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We define queries and mutations explicitly with a schema string. The queries
    and mutations take input types as data types for the input data, and return data
    with the specified output data types. Therefore, we will never be in any doubt
    about the structure of the data that we have to send to make a GraphQL request
    and will never have to guess as to what kind of data a request will return.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模式字符串明确定义查询和变异。查询和变异将输入类型作为输入数据的数据类型，并使用指定的输出数据类型返回数据。因此，我们永远不会对我们必须发送的数据的结构产生任何疑问，也永远不必猜测请求将返回什么类型的数据。
- en: GraphQL API requests are mostly just regular **HyperText Transfer Protocol**
    (**HTTP**) requests, except that they have a special structure. All requests go
    to the `/graphql` endpoint by default, and we send queries or mutations as a string
    value of the `query` property in the JSON requests. The variable values are sent
    with the `variable` parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API请求基本上只是常规的**超文本传输协议**（**HTTP**）请求，只是它们具有特殊的结构。所有请求默认都发送到`/graphql`端点，并且我们将查询或变异作为JSON请求中`query`属性的字符串值发送。变量值与`variable`参数一起发送。
- en: The queries and mutations are named, and all the queries and mutations are sent
    to the resolver functions with the same names in the code, instead of to route
    handlers. The functions then take the arguments specified by the schema, after
    which we can get the request data and do what we want with it in our resolver
    function code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和变异是有名称的，并且所有查询和变异都以相同的名称发送到解析器函数中的代码，而不是路由处理程序。然后函数根据模式指定的参数获取请求数据，并在解析器函数代码中对其进行处理。
- en: With Vue 3 apps, we can use specialized GraphQL API clients to make GraphQL
    API request creation easier. All we have to do to make a request is pass in a
    string for the queries and mutations, along with the variables that go with the
    queries and mutations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vue 3应用程序，我们可以使用专门的GraphQL API客户端来更轻松地创建GraphQL API请求。我们只需传入一个字符串来进行查询和变异，以及与查询和变异相关的变量。
- en: In this chapter, we will create a shopping cart system with an admin frontend
    and a customer frontend with Vue 3\. We will then create a backend with Express
    and the `express-graphql` library that takes GraphQL API requests and stores data
    in a SQLite database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Vue 3创建一个带有管理前端和客户前端的购物车系统。然后，我们将使用Express和`express-graphql`库创建一个后端，该后端接收GraphQL
    API请求并将数据存储在SQLite数据库中。
- en: Setting up the shopping cart system project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置购物车系统项目
- en: To create the vacation booking project, we had to create subprojects for the
    frontend, the admin frontend, and the backend. To create the frontend and admin
    frontend projects, we will use Vue CLI. To create the backend project, we will
    use the `express-generator` global package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建度假预订项目，我们必须为前端、管理前端和后端创建子项目。为了创建前端和管理前端项目，我们将使用Vue CLI。为了创建后端项目，我们将使用`express-generator`全局包。
- en: 'To set up this chapter''s project, we execute the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置本章的项目，我们执行以下步骤：
- en: First, we create a folder to house all the projects, and name it `shopping-cart`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个文件夹来存放所有项目，并将其命名为`shopping-cart`。
- en: We then create `admin-frontend`, `frontend`, and `backend` folders inside the
    main folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在主文件夹内创建`admin-frontend`，`frontend`和`backend`文件夹。
- en: Next, we go into the `admin-frontend` folder and run `npx vue create` to add
    the scaffolding code for the Vue project to the `admin-frontend` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进入`admin-frontend`文件夹，并运行`npx vue create`来为`admin-frontend`文件夹添加Vue项目的脚手架代码。
- en: If we are asked to create the project in the current folder, we select `Y`,
    and then when we're asked to choose the Vue version of the project, we choose
    `Vue 3`. Likewise, we run Vue CLI the same way with the `frontend` folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the Express project, we run the Express application generator app.
    To run it, we go into the `backend` folder and then run `npx express-generator`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command will add all the files that are required for our project to the
    `backend` folder. If you get an error, try running the `express-generator` package
    as an administrator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished setting up the project, we can start working on the
    code. Next, we will start with creating the GraphQL backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GraphQL API with Express
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start the shopping cart system project, we first create a GraphQL API with
    Express. We start with the backend since we need it for both frontends. To get
    started, we have to add a few libraries that are needed to manipulate the SQLite
    database and add authentication to our app. Also, we need the library to enable
    **Cross-Origin Resource Sharing** (**CORS**) in our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: CORS is a way to let us make requests from the browser to an endpoint hosted
    in a different domain from where the frontend is hosted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our Express app accept GraphQL requests, we use the `graphql` and `express-graphql`
    libraries. To install both, we run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After installing the packages, we are ready to work on the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Working with resolver functions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we work on the resolver functions. To add them, we first add a `resolvers`
    folder into the `backend` folder. Then, we can work on the resolver for authentication.
    In the `resolvers` folder, we create an `auth.js` file and write the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `login` method is a resolver function. It takes the `user object` property
    with the `username` and `password` properties, and we use these to check for the
    credentials. We check if the username is `'admin'` and the password is `'password'`.
    If the credentials are correct, then we issue the token. Otherwise, we throw an
    error, which will be returned as an error response by the `/graphql` endpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Adding resolvers for the order logic
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We next add the resolvers for the order logic. In the `resolvers` folder, we
    add the `orders.js` file. Then, we work on the resolver function to get the order
    data. The order data has information about the order itself and also about what
    has been bought by the customer. To add the resolvers, we write the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We open the database with the `sqlite3.Database` constructor, with the path
    to the database. Then, we return a promise that queries all the orders with the
    items that the custom bought. The orders are in the `orders` table. The store
    inventory items are stored in the `shop_items` table, and we have the `order_shop_items`
    table to link the order and the items bought.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a `select` query with the `db.all` method to get all the data, and
    we join all the related tables with an `inner join` to get the related data in
    the other tables. In the callback, we write the following code to loop through
    the rows to create the `order` object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This lets us remove duplicate order entries in the rows. The key is the `order_id`
    value, and the value is the order data itself. Then, we get all order values with
    the `Object.values` method. We assign the returned array to the `orderArr` variable.
    Then, we loop through the `orderArr` array to get all the shop items that were
    ordered from the original row's array with the `filter` method, to look up the
    items by `order_id`. We call `map` to extract the shop item data of the order
    from the row.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We call `resolve` on the data to return it as a response from the `/graphql`
    endpoint. In the first few lines of the callback, we call `reject` when `err`
    is truthy so that we can return the error to the user, if there is one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `db.close()` to close the database once we're done. We can
    do this at the end, since we used `db.serialize` to run all the statements in
    the `serialize` callback in a series so that the **Structured Query Language**
    (**SQL**) code could be run in sequence.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Adding an order
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We add a resolver function to add an order. To do this, we write the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We get the request payload for the order, with the variables we destructured
    within the argument. We open the database the same way, and we start with the
    same promise code and the `db.serialize` call, but inside it we create a prepared
    statement with the `db.prepare` method. We issue an `INSERT` statement to add
    the data to the order entry.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `run` with the variable values we want to insert, to run the SQL
    statement. Prepared statements are good since all the variable values we passed
    into `db.run` are sanitized to prevent SQL injection attacks. Then, we call `finalize`
    to commit the transaction.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get the ID value of the row that has just been inserted into the `orders`
    table with the `db.all` call, with the `SELECT` statement. In the callback of
    the `db.all` method, we get the returned data and destructure `orderId` from the
    returned data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create another prepared statement to insert the data for the shop items
    that were bought into the `order_shop_items` table. We just insert `order_id`
    and `shop_item_id` to link the order to the shop item bought.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We loop through the `orderedItems` array and call `run` to add the entries,
    and we call `finalize` to finalize all the database transactions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `resolve` to return a success response to the client.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off this file, we add the `removeOrder` resolver to let us remove
    orders from the database. To do this, we write the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We call `db.serialize` and `db.prepare` in the same way as we did before. The
    only difference is that we are issuing `DELETE` statements to delete everything
    with the given `order_id` in the `order_shop_items` and `orders` tables. We need
    to delete items from the `order_shop_items` table first since the order is still
    being referenced there.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Once we get rid of all the references of the order outside the `orders` table,
    we can delete the order itself in the `orders` table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Getting the shop items
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We create a `shopItems.js` file in the `resolvers` folder to hold the resolver
    functions for getting and setting the shop items. First, we start with a resolver
    function to get all the shop items. To do this, we write the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We call `db.serialize` and `db.all`, as we did before. We just get all the `shop_items`
    entries with the query and we call `resolve` to return the selected data as a
    response to the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Adding a resolver function to add a shop item
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will now add a resolver function to add a shop item. To do this, we write
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We issue an `INSERT` statement to insert an entry, with the values destructured
    from the parameter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the `removeShopItem` resolver by writing the following code
    to let us remove an entry from the `shop_items` table by its ID:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mapping resolvers to queries and mutations
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to map the resolvers to queries and mutations so that we can call them
    when making GraphQL API requests. To do this, we go to the `app.js` file and add
    a few things. We will also add some middleware so that we can enable cross-domain
    communication and token checks for some requests. To do this, we start by writing
    the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We import everything we need with the `require` function. We can replace all
    the stuff at the top of the file with the preceding code block. We import the
    resolvers, the CORS middleware, the GraphQL library items, and the `jsonwebtoken`
    module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the schema for our GraphQL API by calling the `buildSchema`
    function. To do this, we write the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The full schema definition can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter07/backend/app.js).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We have the `type` keyword to define a data type for a response, and we have
    the `Response` and `Token` types to use as the response. The `express-graphql`
    library will check the structure of the response against what is specified in
    the data type, so whatever query or mutation that returns data with the `Response`
    type should have a `status string` property. This is optional since we don't have
    an exclamation mark after the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The `input` keyword lets us define an `input` type. An `input` type is used
    for specifying the data structure of request payloads. They are defined the same
    way as `output` types with a list of properties, with their data type after the
    colon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We can nest one data type in another, as we did with the `ordered_items` property
    in the `OrderOutput` type. We specify that it holds an array of objects with the
    `ShopItemOutput` data type. Likewise, we specify a similar data type for the `ordered_items`
    property in the `Order` data type. The square brackets indicate that the data
    type is an array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`Query` and `Mutation` are special data types that let us add the resolver
    names before the colon and the data type of the output after the colon. The `Query`
    type specifies the queries, and the `Mutation` type specifies the mutations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we specify the `root` object with all the resolvers added to it, by writing
    the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We just put all the resolvers we imported into the `root` object and we spread
    all the entries into the `root` object to merge them all into one object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add `authMiddleware` to add an authentication check for some GraphQL
    requests. To do this, we write the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We get the `query` property from the JSON request payload to check which query
    or mutation the GraphQL request is invoking. Then, we get the `authorization`
    header with the `req.get` method. Next, we define a `requiresAuth` Boolean variable
    to check if the client is making requests that invoke the restricted queries or
    mutations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If that is `true`, we call `jwt.verify` to verify the token with the secret.
    If it's valid, then we call `next` to proceed to the `/graphql` endpoint. Otherwise,
    we return a `401` response. If a `query` or `mutation` property doesn't need authentication,
    then we just call `next` to proceed to the `/graphql` endpoint.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Adding the middleware
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we add all the middleware we need to enable cross-domain communication,
    and add the `/graphql` endpoint to accept GraphQL requests. To do this, we write
    the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We write the following line of code to enable cross-domain communication:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following line of code lets us accept JSON requests, which we also need
    for accepting GraphQL requests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following line of code adds the authentication check to restricted GraphQL
    queries:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding line of code must be added before the following code block:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This way, the authentication check is done before the GraphQL request can be
    made. Finally, the following code block adds a `/graphql` endpoint to let us accept
    GraphQL requests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `grapgqlHTTP` function returns a middleware after we pass in a bunch of
    options. We set the schema for the GraphQL API. The `rootValue` property has an
    object with all the resolvers. The resolver names should match the names specified
    in the `Query` and `Mutation` types. The `graphiql` property is set to `true`
    so that we can use the GraphiQL web app available when we go to the `/graphql`
    page in the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: To test authenticated endpoints, we can use the `ModHeader` extension available
    with Chrome and Firefox to add the authentication header with the token to the
    request headers. Then, we can test authenticated GraphQL requests easily.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The extension can be downloaded from [https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en](https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en)
    for Chromium browsers and [https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search](https://addons.mozilla.org/en-CA/firefox/addon/modheader-firefox/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search)
    for Firefox.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the GraphiQL interface looks like. We also
    have the `ModHeader` extension to let us add the headers required to make authenticated
    requests at the top right of the screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – GraphiQL with ModHeader extension'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.1_B14405.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – GraphiQL with ModHeader extension
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `db.sql` script to let us create the database we need to
    use, by writing the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create the tables that we used in the resolvers script. `TEXT` lets us store
    text in a column; `INTEGER` lets us store integers; `FOREIGN KEY` specifies a
    foreign key that references a column specified in the table and column after `REFERENCES`;
    `NOT NULL` makes a column required; `DROP TABLE IF EXISTS` drops a table, if it
    exists; `CREATE TABLE` creates a table; `PRIMARY KEY` specifies the primary key
    column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SQLite database
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create and manipulate a SQLite database, we use the **DB Browser for SQLite**
    (**DB4S**) program, which we can download from [https://sqlitebrowser.org/](https://sqlitebrowser.org/).
    This program works with Windows, Mac, and Linux. Then, we can click on **New Database**
    and save the `db.sqlite` database in the `backend` folder so that the backend
    can access the database. Then, in the **Execute SQL** tab, we paste in the script
    to add the tables to the database. For changes for the database to be written
    to disk, you have to save them. To do this, click on the **File** menu and then
    click on **Write Changes**. We can also press the *Ctrl* + *S* keyboard combination
    to save the changes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in `package.json`, we change the `start` script by writing the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We switch `nodemon` so that the app will restart when we change the code and
    save it. We run `npm I –g nodemon` to install `nodemon` globally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the backend, we can move on to the frontend so that
    we have a complete shopping cart system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Creating the admin frontend
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the backend app done, we can move on to working on the frontend.
    Since we have already created the Vue 3 project earlier for the admin frontend
    in the `admin-frontend` folder, we just have to install packages that we need
    and then work on the code. We need the `graphql-request` GraphQL package and the
    GraphQL client library, and the VeeValidate, Vue Router, Axios, and Yup packages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'To install them, we run the following command in the `admin-frontend` folder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After installing the packages, we can start working on the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Working with components
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we start working on the components. In the `components` folder, we add
    the `TopBar` component into the `components/TopBar.vue` file to hold the route
    links and the **Log Out** button by writing the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We add the Vue Router `router-link` components to let the admin user click on
    them to go to different pages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The **Log Out** button runs the `logOut` method when it is clicked to clear
    local storage with `localStorage.clear` and redirects back to the login page with
    `this.$router.push`. The `/` path will map to the login page, as we will see later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `src/plugins` folder, we add the `router.js` file. To do this,
    we write the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We added the `beforeEnter` route guard to check if the authentication token
    is stored in local storage. If it is stored already and we are going to an authenticated
    route, then we proceed to the page by calling `next` with no arguments. Otherwise,
    we redirect back to the login page by calling `next` with an object with the `fullPath`
    property set to `'/'`. If there is any error, we also go back to the login page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `routes` array with the route mappings. We map the path to
    the component so that when we type in the **Uniform Resource Locator** (**URL**)
    in the browser or click a router link on the page, we go to the page we mapped
    to. We add the `beforeEnter` route guard to the route that requires authentication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `createRouter` to create the `router` object, and we call `createWebHashHistory`
    to use hash mode. With hash mode, the hostname and the rest of the URL will be
    separated by a `#` sign. We also add the `routes` array into the object we pass
    into `createRouter`, to add the route mappings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Then, we export the `router` object so that we can add it to our app later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the login page component. To do this, we create the `views`
    folder, add the `Login.vue` file to it, and then write the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We add the `Form` component with the `validationSchema` prop set to the `yup`
    schema. We listen for the `submit` event, which is emitted when all the fields
    are valid, and we click the **Submit** button. The `submitForm` method will have
    the form field values we entered, and the `Field` component lets us create a form
    field.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '`ErrorMessage` displays the error message with the form field. If the `name`
    prop values of `Field` and `ErrorMessage` match, then any form validation for
    the field with the given name will be automatically displayed. The `placeholder`
    attribute lets us add a form placeholder, and the `type` attribute sets the `form`
    input type.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the script portion of our component. To do this, we write the
    following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create the GraphQL client object with the `GraphQLClient` constructor. This
    takes the GraphQL endpoint URL and various options that we can pass in. We will
    use it to pass in the required request headers in components that require authentication.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The `schema` variable holds the `yup` validation schema, which has the `name`
    and `password` fields. Both fields are strings and they are both required, as
    indicated by the method calls. The property names must match the `name` prop value
    of the `Field` and `ErrorMessage` components for the validation to trigger for
    the field.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Adding the login logic and making our first GraphQL request
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we add the login logic by writing the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We register the `Form`, `Field`, and `ErrorMessage` components imported from
    the VeeValidate package. We have the `data` method, which returns an object with
    the schema so that we can use it in the template. Finally, we have the `submitForm`
    method, to get the `username` and `password` values from the `Field` components
    and make the login mutation GraphQL request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We pass the `$username` and `$password` values into the parentheses to pass
    them into our mutation. The values will be obtained from the `variablesvariables`
    object, which we pass into the `graphQLClient.request` method. If the request
    is successful, we then get back the token from the request. Once we get the token,
    we put it in `localStorage.setItem` to put it into local storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `gql` tag is a function that lets us convert the string into a query JSON
    object that can be sent to the server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'If the login request failed, we then display an alert. The following screenshot
    shows the login screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Admin login screen'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.2_B14405.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Admin login screen
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Creating the orders page
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we create an orders page by creating a `views/Orders.vue` file. To do
    this, we update the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add `TopBar` and loop through the orders with `v-for` to render the entries.
    We also loop through `ordered_items`. We show the total price of the ordered items
    with the `calcTotal` method. We also have the **Delete Order** button, which calls
    the `deleteOrder` method when we click it. The `key` prop must be specified so
    that Vue 3 can identify the items.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a script with the GraphQL client by writing the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is different from the login page since we set the authorization header
    to the token we obtained from local storage. Next, we create the component object
    by writing the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We register the `TopBar` component with the `components` property. We have the
    `data` method to return an object with the `orders` reactive property. In the
    `beforeMount` hook, we call the `getOrders` method to get the orders when the
    component is mounting. The `calcTotal` method calculates the total price of all
    the ordered items by getting the price from all the `orderedItems` objects with
    `map` and then calling `reduce` to add all the prices together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The `getOrders` method makes a GraphQL query request to get all the orders.
    We specify the fields we want to get with the request. We specify the fields for
    the nested objects we also want to get, so we do the same with `ordered_items`.
    Only the fields that are specified will be returned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `graphQlClient.request` with the query to make the query request,
    and assign the data returned to the `orders` reactive property.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The `deleteOrder` method takes an `order` object and makes a `removeOrder` mutation
    request to the server. `orderId` is in the variables, so the correct order will
    be deleted. We call `getOrders` to get the latest orders again after deleting
    them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the orders page that the admin sees:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Orders page: admin view'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.3_B14405.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3 – Orders page: admin view'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the orders page, we will move on to add a page to let
    admins add and remove items they want to sell in the shop.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing shop items for sale
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we add a shop items page to let us add and remove shop items. To do this,
    we start with the template. We render the shop items by writing the following
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add the `TopBar` component as we did before and we render `shopItems`, as
    we did with the orders.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a dialog box with the HTML dialog element to let us add shop items.
    To do this, we write the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We set the `open` prop to control when the dialog box is opened, and we set
    the class to `center` so that we can apply styles to center the dialog box and
    display it above the rest of the page later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Inside the dialog box, we have the form created in the same way as with the
    login page. The only difference is the fields that are in the form. At the bottom
    of the form, we have a **Cancel** button to set the `showDialog` reactive property
    to `false` to close the dialog, since it's set as the value of the `open` prop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the script with the GraphQL client and form validation schema
    (as we did before), as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we add the `component options` object by writing the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We register components and create a `data` method to return the reactive properties
    we use. The `beforeMount` hook calls the `getShopItems` method to get the shop
    items from the API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `getShopItems` method by writing the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We just make a `getShopItems` query request to get the data with the fields
    in the braces returned.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `submitForm` method to make a mutation request to add a shop
    item entry, by writing the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We get all the form field values by destructuring the object in the parameter,
    then we call `graphQLClient.request` to make the request with the variables set
    from the destructured properties from the parameter. We convert `price` to a number
    since `price` should be a float, according to the schema we created in the backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Once the request is done, we set `showDialog` to `false` to close the dialog
    and we call `getShopItems` again to get the shop items.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method we''ll add is the `deleteItem` method. The code for this can
    be seen in the following snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We make the `removeShopItem` mutation request to delete a shop item entry. When
    the request is done, we call `getShopItems` again to get the latest data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The admin''s view of the shop items page can be seen in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Shop items page: admin view'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.4_B14405.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4 – Shop items page: admin view'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/App.vue`, we write the following code to add the `router-view` component
    to show the route component content:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `src/main.js`, we write the following code to add the router to our app:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, in `package.json`, we change the server script to serve the app from
    a different port so that it won''t conflict with the frontend. To do this, we
    write the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are now finished with the admin frontend and will move on to the final part
    of this project, which is a frontend for the customer so that they can order items.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Creating the customer frontend
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have finished with the admin frontend, we finish this chapter's
    project by creating the customer's frontend. This is similar to the admin frontend
    except that there is no authentication required to use it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by installing the same packages that we installed for the admin frontend.
    So, we go to the `frontend` folder and run the following command to install all
    the packages:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need Vuex with the `Vuex-Persistedstate` plugin to store the shopping cart
    items. The rest of the packages are the same as for the admin frontend.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Creating the plugins folder
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a `plugins` folder in the `src` folder and add the routes by creating
    the `router.js` file in the folder and writing the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we create our Vuex store by creating the `src/plugins/vuex.js` file and
    then writing the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We call `createStore` to create the Vuex store. In the object that we pass into
    `createStore`, we have the `state` method to return the `cartItems` state initialized
    to an array. The `getters` property has an object with the `cartItemsAdded` method
    to return the `cartItems` state value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In the `mutations` property object, we have the `addCartItem` method to call
    `state.cartItems.push` to add a `cartItem` value to the `cartItems` state. We
    get the existing cart item IDs with the `map` and `filter` method. We only want
    the numeric ones. The ID for the new cart item would be the highest one from the
    `cartItemIds` array plus `1`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `removeCartItem` method lets us call `splice` to remove a cart item by index,
    and `clearCart` resets the `cartItems` state to an empty array.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `plugins` property to an object with the `createPersistedState`
    function, to create a `Vuex-Persistedstate` plugin to store the `cartItems` state
    to local storage. The `key` value is the key to store the `cartItem` values under.
    Then, we export the store so that we can add it to our app later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Creating the order form page
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we create an order form page. This has a form to let customers enter
    their personal information and edit the cart. To create it, we create a `src/views`
    folder if one doesn''t already exist, and then we create an `OrderForm.vue` component
    file. We start by writing the following template code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have similar forms to those for the admin frontend. We use the same `Form`,
    `Field`, and `ErrorMessage` components from VeeValidate.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We loop through the cart items with `v-for` to render them onto the screen.
    They're retrieved from local storage via `Vuex-Persistedstate` with the `cartItemsAdded`
    getter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the script the same way by writing the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We create the GraphQL client and the validation schema, and we register the
    components in the same way as we did in the shop item page of the admin frontend.
    The only new thing is to call the `mapGetters` method to add the Vuex getters
    as a computed property of our component. We just pass in an array of strings with
    the name of the getters to map the computed properties to. Next, we add the methods
    by writing the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have the `submitOrder` method that gets the inputted data from the order
    form and makes an `addOrder` mutation request to the server. In the `variables`
    object, we need to remove `cartItemId` from each `ordered_items` object so that
    it matches the `ShopItem` schema that we created in the backend. We can't have
    extra properties that aren't included in the schema in an object we send to the
    server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Once the request succeeds, we call `clearCart` to clear the cart, and then we
    call `thus.$router.push` to go to the success page. The `mapMutation` method maps
    the mutations to methods in our component. The `clearCart` method is the same
    as the `clearCart` Vuex store mutation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the admin view of the order form:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Order form: admin view'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.5_B14405.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5 – Order form: admin view'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `src/views/Shop.vue` file by writing the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We render the shop items with `v-for`, as we did with the other components.
    We also have a `router-link` component to render a link on the page.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the number of cart items added with the `cartItemsAdded` getter. The
    `clearCart` Vuex mutation method is called when we click on **Clear Shopping Cart**.
    Next, we add the script for the component by writing the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We create the GraphQL client the same way. In the component, we call `getShopItems`
    in the `beforeMount` hook to get the shopping cart items. We also call `mapMutations`
    to map the Vuex mutations we need into methods in our component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we shrink the `img` elements to `100px` width by writing the following
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we create an order success page by creating a `src/views/Success.vue`
    file and writing the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The order success page just has some text and a link to go back to the shop's
    home page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `src/App.vue`, we write the following code to add the `router-view`
    component to show the route pages:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `src/main.js`, we add the following code to add the router and Vuex store
    to our app:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, we change the port that the app project is served from by writing
    the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our project is now complete.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We can run the frontend projects with `npm run serve` and the backend projects
    with `npm start`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: By working on the shopping cart project, we learned how to create GraphQL APIs,
    which are JSON APIs that can process GraphQL instructions via queries and mutations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily create a GraphQL API with Express and the `express-graphql` library.
    To make GraphQL HTTP requests easily, we use the `graphql-request` JavaScript
    GraphQL client, which works in the browser. This lets us set request options such
    as headers, the query to make, and variables that go with the query easily.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The `graphql-request` GraphQL client is used instead of a regular HTTP client
    to make requests to the backend from our Vue app. The `graphql-request` library
    lets us make GraphQL HTTP requests more easily than when using a regular HTTP
    client. With it, we can easily pass in GraphQL queries and mutations with variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: A GraphQL API is created with a schema that maps to resolver functions. Schemas
    let us define all the data types of our input and output data so that we don't
    have to guess which data we have to send. If we send any invalid data, then we
    will get an error telling us exactly what is wrong with the request. We also have
    to specify the data fields that we want to return with our GraphQL queries, and
    only the fields that we specified are returned. This lets us return the data that
    we need to use, making it much more efficient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can add authentication to a GraphQL API request with the usual token
    check before making requests to the `/graphql` endpoint.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We can easily test GraphQL requests with the GraphiQL interactive sandbox that
    lets us make the requests we want. To test authenticated requests, we can use
    the `ModHeader` extension to set the header so that we can make authenticated
    requests successfully.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to create a real-time chat app with
    Laravel and Vue 3.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
