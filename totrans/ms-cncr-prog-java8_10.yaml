- en: Chapter 9. Diving into Concurrent Data Structures and Synchronization Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among of the most important elements in every computer program are **data structures**.
    Data structures allow us to store the data that our applications read, transform,
    and write in different ways according to our needs. The selection of an adequate
    data structure is a critical point to get good performance. A bad choice can degrade
    the performance of an algorithm considerably. Java concurrency API includes some
    data structures designed to be used in concurrent applications without provoking
    data inconsistencies or loss of information.
  prefs: []
  type: TYPE_NORMAL
- en: Another critical point in concurrent applications are **synchronization mechanisms**.
    You use them to implement mutual exclusion by creating a critical section, that
    is to say, a piece of code that can only be executed by one thread at a time.
    But you can also use synchronization mechanisms to implement dependencies between
    threads when, for example, a concurrent task must wait for the finalization of
    another task. Java concurrency API includes basic synchronization mechanisms,
    like the `synchronized` keyword and very high-level utilities, such as the `CyclicBarrier`
    class or the `Phaser` class you used in [Chapter 5](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 5. Running Tasks Divided into Phases – The Phaser Class"), *Running Tasks
    Divided into Phases – The Phaser Class*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronization mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every computer program works with data. They get the data from a database, a
    file, or another source, transform that data, and then write the transformed data
    into a database, a file, or another destination. The programs work with data stored
    in memory and use data structures to store the data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: When you implement a concurrent application, you must be very careful with the
    utilization of data structures. If different threads can modify the data stored
    in a unique data structure, you have to use a synchronization mechanism to protect
    the modifications over that data structure. If you don't do this, you can have
    a data race condition. Your application may sometimes work correctly, but next
    time may crash with a random exception, stuck in an infinite loop, or silently
    produce an incorrect result. The outcome will depend on the order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid data race conditions you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a non-synchronized data structure and add the synchronization mechanisms
    by yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a data structure provided by the Java concurrency API that implements the
    synchronization mechanism internally and is optimized to be used in concurrent
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option is the most recommended. Through the pages of this section,
    you will review the most important concurrent data structures giving special importance
    to Java 8's new features.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking and non-blocking data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java concurrency API provides two kinds of concurrent data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking data structures**: This kind of data structure provides methods
    to insert and delete data on it where, when the operation cannot be done immediately
    (for example, if you want to take an element and the data structure is empty),
    the thread that made the call will be blocked until the operation can be done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-blocking data structures**: This kind of data structure provides methods
    to insert and delete data on it that, when the operation cannot be done immediately,
    return a special value or throw an exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we have a non-blocking equivalent for the blocking data structure.
    For example, the `ConcurrentLinkedDeque` class is a non-blocking data structure
    and the `LinkedBlockingDeque` is the blocking equivalent. Blocking data structures
    have methods that behave like non-blocking data structures. For example, the `Deque`
    interface defines the `pollFirst()` method that does not block returns `null`
    if the deque is empty. Every blocking queue implementation implements this method
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Java collections framework** (**JCF**) provides a set of different data
    structures that can be used in sequential programming. The Java concurrent API
    extends those structures, providing others that can be used in concurrent applications.
    This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces**: This extends the interfaces provided by the JCF, adding some
    methods that can be used in concurrent applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**: This implements the previous interfaces to provide implementations
    that can be used in the applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we make an introduction to the interfaces and classes
    you can use in concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's describe the most important interfaces implemented by the concurrent
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: BlockingQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **queue** is a linear data structure that allows you to insert elements at
    the end of the queue and get elements from the start. It's a **First-In-First-Out**
    (**FIFO**) data structure where the first elements introduced in the queue are
    the first ones that are processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JCF defines the `Queue` interface that defines the basic operations to
    be implemented in a queue. This interface provides methods to:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert an element at the end of the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve and remove an element from the head of the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve without removing an element from the head of the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface defines two versions of these methods that have different behaviors
    when the method can be done (for example, if you want to retrieve an element of
    an empty queue):'
  prefs: []
  type: TYPE_NORMAL
- en: Methods that throw an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that return a special value, for example `false` or `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next table includes the names of the methods for every operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Exception | Special value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Insert | `add()` | `offer()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve and remove | `remove()` | `poll()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve but don''t remove | `element()` | `peek()` |'
  prefs: []
  type: TYPE_TB
- en: 'The `BlockingDeque` interface extends the `Queue` interface, adding methods
    that block the calling thread if the operation can be done. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Blocks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Insert | `put()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve and remove | `take()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve without removing | N/A |'
  prefs: []
  type: TYPE_TB
- en: BlockingDeque
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A **deque** is a linear data structure, like the queue, but allows you to insert
    and delete elements from both sides of the data structure. The JCF defines the
    `Deque` interface that extends the `Queue` interface. In addition to the methods
    provided by the `Queue` interface, it provides methods to insert, retrieve and
    remove, and retrieve without removing at both ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Exception | Special value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Insert | `addFirst()`, `addLast()` | `offerFirst()`, `offerLast()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve and remove | `removeFirst()`, `removeLast()` | `pollFirst()`, `pollLast()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve without removing | `getFirst()`, `getLast()` | `peekFirst()`, `peekLast()`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The `BlockingDeque` interface extends the `Deque` interface, adding the methods
    that block the calling threads when the operation can''t be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Blocks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Insert | `putFirst()`, `putLast()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve and remove | `takeFirst()`, `takeLast()` |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve without removing | N/A |'
  prefs: []
  type: TYPE_TB
- en: ConcurrentMap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A **map** (sometimes also called an **associative array**) is a data structure
    that allows you to store (key, value) pairs. The JCF provides the `Map` interface
    that defines the basic operations to work with the map. This includes methods
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`put()`: Insert a (key, value) pair into the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: Return the value associated with a key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`: Remove the (key, value) pair associated with the specified key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsKey()`and `containsValue()`: Return true if the map contains the specified
    key of the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This interface has been modified in Java 8 to include the following new methods.
    You will learn how to work with these methods later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach()`: This method executes the given function over all the elements
    of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compute()`, `computeIfAbsent()`, and `computeIfPresent()`: These methods allows
    you to specify a function that calculates the new value associated with a key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge()`: This method allows you to specify merging a (key, value) pair into
    an existing map. If the key isn''t in the map, it''s inserted directly. If not,
    the function specified is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentMap` extends the `Map` interface to provide the same methods to
    concurrent applications. Notice that in Java 8 (unlike Java 7), the `ConcurrentMap`
    interface doesn''t add new methods to the `Map` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: TransferQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This interface extends the `BlockingQueue` interface and adds methods to transfer
    elements from producers to consumers, where producers can wait until a consumer
    takes off its element. The new methods added by this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transfer()`: Transfer an element to a consumer and wait (blocking the calling
    thread) until the element is consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryTransfer()`: Transfer an element if there is a consumer waiting. If not,
    this method returns the `false` value and doesn''t insert the element in the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java concurrency API provides different implementations of the interfaces
    described before. Some of them don't add any new characteristics but others add
    new interesting functionality.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedBlockingQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `BlockingQueue` interface to provide a queue with
    blocking methods that optionally can have a limited number of elements. It also
    implements the `Queue`, `Collection`, and `Iterable` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentLinkedQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `Queue` interface to provide a thread-save unlimited
    queue. Internally, it uses a non-blocking algorithm to guarantee that there won't
    be a data race in your application.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedBlockingDeque
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `BlockingDeque` interface to provide a deque with
    blocking methods that optionally can have a limited number of elements. It has
    more functionality than `LinkedBlockingQueue` but may have more overhead, thus
    `LinkedBlockingQueue` should be used when deque features are unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentLinkedDeque
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `Deque` interface to provide a thread-save unlimited
    deque that allows you to add and delete elements at both ends of the deque. It
    has more functionality than `ConcurrentLinkedQueue`, but may have more overhead
    as occurs with `LinkedBlockingDeque`.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayBlockingQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `BlockingQueue` interface to provide an implementation
    of a blocking queue with a limited number of elements based on an array. It also
    implements the `Queue`, `Collection`, and `Iterable` interfaces. Unlike non-concurrent
    array-based data structures (`ArrayList` and `ArrayDeque`), `ArrayBlockingQueue`
    allocates an array of a fixed size specified in the constructor and never resizes
    it.
  prefs: []
  type: TYPE_NORMAL
- en: DelayQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class implements the `BlockingDeque` interface to provide an implementation
    of a queue with blocking methods and an unlimited number of elements. The elements
    of this queue must implement the `Delayed` interface, so they have to implement
    the `getDelay()` method. If that method returns a negative or zero value, the
    delay has expired and the element can be taken of the queue. The head of the queue
    is the element with the most negative value of delay.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedTransferQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class provide an implementation of the `TransferQueue` interface. It provides
    a blocking queue with an unlimited number of elements, and with the possibility
    of using them as a communication channel between producers and consumer where
    producers can wait for consumers to process their elements.
  prefs: []
  type: TYPE_NORMAL
- en: PriorityBlockingQueue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This class provide an implementation of the `BlockingQueue` interface where
    the elements can be polled according to their natural order or by a comparator
    specified in the constructor of the class. The head of this queue is determined
    by the sorting order of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentHashMap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This class provides an implementation of the `ConcurrentMap` interface. It
    provides a thread-safe hash table. In addition to the methods added in the `Map`
    interface in the Java 8 version, this class has added other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`search()`, `searchEntries()`, `searchKeys()`, and `searchValues()`: These
    methods allows you to apply a search function over the (key, value) pairs, over
    the keys, or over the values. The search function can be a lambda expression,
    and the method ends when the search function returns a not-null value. That is
    the result of the execution of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce()`, `reduceEntries()`, `reduceKeys()`, and `reduceValues()`: These
    methods allows you to apply a `reduce()` operation to transform the (key, value)
    pairs, the keys, or the entries as occurs with streams (Refer to [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model* to get more details about the `reduce()` method).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More methods have been added (`forEachValue`, `forEachKey`, and so on), but
    they are not covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to use the new features introduced in Java
    8 to the concurrent data structures.
  prefs: []
  type: TYPE_NORMAL
- en: First example with ConcurrentHashMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model*, you implemented an application to make a search in a dataset from 20,000
    Amazon products. We have taken that information from the Amazon product co-purchasing
    network metadata, which includes information about 548,552 products including
    title, salesrank, and similar products. You can download this dataset from [https://snap.stanford.edu/data/amazon-meta.html](https://snap.stanford.edu/data/amazon-meta.html).
    In that example, you used a `ConcurrentHashMap<String, List<ExtendedProduct>>`
    named `productsByBuyer` to store information about the products purchased by a
    user. The keys of this map are the identifier of the user, and the values a list
    of the products purchased by the user. You're going to use that map to learn how
    to work with the new methods of the `ConcurrentHashMap` class.
  prefs: []
  type: TYPE_NORMAL
- en: The forEach() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method allows you to specify a function that will be executed on every
    (key, value) pair of `ConcurrentHashMap`. There are many versions of this method,
    but the most basic version has only a `BiConsumer` function that can be expressed
    as a lambda expression. For example, you can use this method to print how many
    products every user has purchased, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This basic version is a part of the usual `Map` interface and is always executed
    sequentially. In this code, we have used a lambda expression where `id` is the
    key of the element and `list` is the value of the element.
  prefs: []
  type: TYPE_NORMAL
- en: In this other example, we have used the `forEach()` method to calculate the
    average rating given per every user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have also used a lambda expression where `id` is the key of
    the element and `list` is its value. We have used a stream applied to the list
    of products to calculate the average rating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other versions of this method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach(parallelismThreshold, action)`: This is the version of the method
    you have to use in concurrent applications. If the map has more elements than
    the number specified in the first parameter, this method will be executed in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachEntry(parallelismThreshold, action)`: The same as the previous, but
    in this case the action is an implementation of the `Consumer` interface that
    receives a `Map.Entry` object with the key and the value of the element. You can
    also use a lambda expression in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachKey(parallelismThreshold, action)`: The same as the previous, but in
    this case the action will be applied only over the keys of `ConcurrentHashMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachValue(parallelismThreshold, action)`: The same as the previous, but
    in this case the action will be applied only over the values of `ConcurrentHashMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current implementation uses the common `ForkJoinPool` instance to execute the
    parallel tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The search() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method applies a search function to all the elements of `ConcurrentHashMap`.
    This search function can return a null value or a value different from null. The
    `search()` method will return the first non-null value returned by the search
    function. This method receives two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parallelismThreshold`: If the map has more elements than the number specified
    by this parameter, this method will be executed in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchFunction`: This is an implementation of the `BiFunction` interface that
    can be expressed as a lambda expression. This function receives as parameters
    the key and the value of each element and, as we mentioned before, has to return
    a non-null value if you find what you are searching for and a null value if you
    don''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, you can use this function to find the first book that contains
    a word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we use 100 as `parallelismThreshold` and a lambda expression to
    implement the search function. In this function, for every element, we process
    all the products of the list. If we find a product that contains the word `java`,
    we return that product. This is the value returned by the `search()` method. Finally,
    we write the buyer and the title of the product in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other versions of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchEntries(parallelismThreshold, searchFunction)`: In this case, the search
    function is an implementation of the `Function` interface that receives as a parameter
    a `Map.Entry` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchKeys(parallelismThreshold, searchFunction)`: In this case, the search
    function is applied only over the keys of `ConcurrentHashMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchValues(parallelismThreshold, searchFunction)`: In this case, the search
    function is applied only over the values of `ConcurrentHashMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reduce() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method is similar to the `reduce()` method provided by the `Stream` framework,
    but in this case you work directly with the elements of `ConcurrentHashMap`. This
    method receive three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parallelismThreshold`: If `ConcurrentHashMap` has more elements than the number
    specified in this parameter, this method will be executed in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transformer`: This parameter is an implementation of the `BiFunction` interface
    that can be expressed as a lambda function. It receives as a parameter a key and
    a value and returns a transformation of these elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reducer`: This parameter is an implementation of the `BiFunction` interface
    that can be expressed as a lambda function too. It receives as parameters two
    objects returned by the transformer function. The objective of this function is
    to group those two objects into a single one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example of this method, we will obtain a list of products that have a
    review with a value of `1` (the worst value). We have used two auxiliary variables.
    The first one is `transformer`. It is a `BiFunction` interface that we will use
    as the `transformer` element of the `reduce()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function will receive the key, which is the `id` of a user, and a list
    of `ExtendedProduct` objects with the products purchased by that user. We process
    all the products of the list and return the products that have a rating of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second variable is the reducer `BinaryOperator`. We use it as the reducer
    function of the `reduce()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reduce receives two lists of `ExtendedProduct` and concatenates them into
    a single one using the `addAll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we only have to implement the call to the `reduce()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other versions of the `reduce()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduceEntries()`, `reduceEntriesToDouble()`, `reduceEntriesToInt()`, and `reduceEntriesToLong()`:
    In this case, the transformer and reducer functions work over `Map.Entry` objects.
    The last three versions return respectively a `double`, an `int`, and a `long`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceKeys()`, `reduceKeysToDouble()`, and `reduceKeysToInt()`, `reduceKeysToLong()`:
    In this case, the transformer and reducer functions work over the keys of the
    map. The last three versions return respectively a `double`, an `int`. and a `long`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceToInt()`, `reduceToDouble()`, and `reduceToLong()`: In this case, the
    transformer function works over the keys and values and the reducer method works
    over `int`, `double`, or `long` number respectively. These methods return an `int`,
    `double`, and `long` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceValues()`, `reduceValuesToDouble()`, `reduceValuesToInt()`, and `reduceValuesToLong()`:
    In this case, the transformer and reducer functions work over the values of the
    map. The last three versions return a `double`, an `int`, and a `long` value respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compute() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method (which is defined in the `Map` interface) receives as parameters
    the key of an element and an implementation of the `BiFunction` interface that
    can be expressed as a lambda expression. This function will receive the key and
    value of the element if the key exists in `ConcurrentHashMap` or null if the key
    doesn't exist in `ConcurrentHashMap`. The method will replace the value associated
    with the key with the value returned by the function, insert them in `ConcurrentHashMap`
    if it doesn't exist, or remove the item if `null` is returned for a previously
    existing item. Note that during the `BiFunction` execution, one or several map
    entries can be locked. Thus, your `BiFunction` should not work for very long and
    should not try to update any other entries in the same map. Otherwise a deadlock
    might occur.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use this method with the new atomic variable introduced
    in Java 8 named `LongAdder` to calculate the number of bad reviews associated
    with every product. We create a new `ConcurrentHashMap` named counter. The keys
    will be the title of the products and the value an object of the `LongAdder` class
    to count how many bad reviews every product has.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We process all the elements of `badReviews` `ConcurrentLinkedDeque` calculated
    in the previous section and use the `compute()` method to create and update the
    `LongAdder` associated with every product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we write the results in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Another example with ConcurrentHashMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another method added in the `ConcurrentHashMap` class and defined
    in the Map interface. It''s the `merge()` method that allows you to merge a (key,
    value) pair into the map. If the key doesn''t exist in `ConcurrentHashMap`, it
    is inserted directly. If the key exists, you have to define which will be the
    new value associated with that key from the old one and the new one. This method
    receives three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The key we want to merge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value we want to merge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of `BiFunction` that can be expressed as a lambda expression.
    This function receives as parameters the old value and the new value associated
    with the key. The method will associate with the key the value returned by this
    function. `BiFunction` is executed under a partial lock of the map, so it's guaranteed
    that it's not concurrently executed for the same key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we have split the 20,000 products of Amazon used in the previous
    section in files by the year of the review. For every year, we load `ConcurrentHashMap`
    where the products are the keys and a list of reviews are the values. So, we can
    load the reviews of 1995 and 1996 with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to merge both versions of `ConcurrentHashMap` into one, we can use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We process all the elements of the 1996 `ConcurrentHashMap` and for every (key,
    value) pair, we call the `merge()` method over the 1995 `ConcurrentHashMap`. The
    `merge` function will receive two lists of reviews, so we only have to concatenate
    them into one.
  prefs: []
  type: TYPE_NORMAL
- en: An example with the ConcurrentLinkedDeque class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Collection` interface has also included new methods in Java 8\. Most of
    the concurrent data structures implement this interface, so we can use these new
    features with them. Two of them are the `stream()` and `parallelStream()` methods
    used in [Chapter 7](part0047_split_000.html#1CQAE2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 7. Processing Massive Datasets with Parallel Streams – The Map and Reduce
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Reduce
    Model* and [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model*. Let's see how to use the other two using `ConcurrentLinkedDeque` with
    the 20,000 products we have used in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: The removeIf() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method has a default implementation in the `Collection` interface that
    is not concurrent and is not overridden by the `ConcurrentLinkedDeque` class.
    This method receives an implementation of the `Predicate` interface as a parameter
    that will receive an element of the `Collection` as a parameter and should return
    a `true` or a `false` value. The method will process all the elements of the `Collection`
    and will delete those that obtain a `true` value with the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to delete all the products with a salesrank higher
    than 1,000, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The spliterator() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method returns an implementation of the `Spliterator` interface. A **spliterator**
    defines the data source that can be used by the `Stream` API. You rarely need
    to use spliterator directly, but sometimes you may want to create your own spliterator
    to produce a custom source for the stream (for example, if you implement your
    own data structure). If you have your own spliterator implementation, you can
    create a stream on top of it using `StreamSupport.stream(mySpliterator, isParallel)`.
    Here, `isParallel` is a Boolean value that determines whether the created stream
    will be parallel or not. A spliterator is like an iterator in the sense that you
    can use it to traverse all the elements in the collection, but you can split them
    to make that traversal in a concurrent way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A spliterator has eight different characteristics that define its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONCURRENT`: The spliterator source may be safely concurrently modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT`: All the elements returned by the spliterator are distinct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMMUTABLE`: The spliterator source cannot be modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NONNULL`: The spliterator never returns a `null` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDERED`: The elements returned by the spliterator are ordered (which means
    their order matters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIZED`: The spliterator is capable of returning an exact number of elements
    with the `estimateSize()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SORTED`: The spliterator source is sorted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUBSIZED`: If you use the `trySplit()` method to divide this spliterator,
    the resulting spliterators will be `SIZED` and `SUBSIZED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most useful methods of this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`estimatedSize()`: This method will give you an estimation of the number of
    elements in the spliterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachRemaining()`: This method allows you to apply an implementation of
    the `Consumer` interface, which can be represented with a lambda function, to
    the elements of the spliterator that haven''t yet been processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAdvance()`: This method allows you to apply an implementation of the `Consumer`
    interface, which can be represented with a lambda function, to the next element
    to process by the spliterator if there is one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trySplit()`: This method tries to split the spliterator in two parts. The
    caller spliterator will process some elements and the returned spliterator will
    process the others. If the spliterator is `ORDERED`, the returned spliterator
    must process a strict prefix of the elements and the call must process the strict
    suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasCharacteristics()`: This method allows you to check the properties of the
    spliterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see an example of this method with the `ArrayList` data structure, with
    20,000 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need an auxiliary task that will process a set of products to convert
    their title to lowercase. This task will have a `Spliterator` as an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this task writes the number of products processed when it finishes
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the main method, once we have loaded `ConcurrentLinkedQueue` with the 20,000
    products, we can obtain the spliterator, check some of its properties, and look
    at its estimated size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can divide the spliterator using the `trySplit()` method and look
    at the size of the two spliterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can execute two tasks in an executor, one for the spliterator, to
    see that every spliterator has really processed the expected number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see the results of the execution of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The spliterator() method](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how before splitting the spliterator, the `estimatedSize()` method
    returns 20,000 elements. After the execution of the `trySplit()` method, both
    spliterators have 10,000 elements. These are the elements processed by each of
    the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomic variables were introduced in Java 1.5 to provide atomic operations over
    `integer`, `long`, `boolean`, `reference`, and `Array` objects. They provide some
    methods to increment, decrement, establish the value, return the value, or establish
    the value if its current value is equal to a predefined one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java 8, four new classes has been added. These are `DoubleAccumulator`,
    `DoubleAdder`, `LongAccumulator`, and `LongAdder`. In a previous section, we used
    the `LongAdder` class to count the number of bad reviews of the products. This
    class provides similar functionality to `AtomicLong`, but it has better performance
    when you frequently update the cumulative sum from different threads and request
    the result only at the end of the operation. The `DoubleAdder` function is equal
    to it but with double values. The main objective of both classes is to have a
    counter that can be updated by different threads in a consistent way. The most
    important methods of these classes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`: Increment the value of the counter with the value specified as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`increment()`: Equivalent to `add(1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decrement()`: Equivalent to `add(-1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum()`: This method returns the current value of the counter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take into account that the `DoubleAdder` class doesn't have the `increment()`
    and `decrement()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LongAccumulator` and `DoubleAccumulator` classes are similar but they
    have a very important difference. They have a constructor where you specify two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The identity value of the internal counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to accumulate the new value into the accumulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the function must not depend on the order of accumulation. In this
    case, the most important methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accumulate()`: This method receives a `long` value as a parameter. It applies
    the function to increment or decrement the counter to the current value and the
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: Returns the current value of the counter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code will write 362,880 in the console in all the
    executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use a commutative operation inside the accumulator so the result is the same
    for any input order.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Synchronization of tasks is the coordination between those tasks to get the
    desired results. In concurrent applications, we can have two kinds of synchronizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process synchronization**: We use this kind of synchronization when we want
    to control the order of execution of the tasks. For example, a task must wait
    for the finalization of other tasks before it starts its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data synchronization**: We use this kind of synchronization when two or more
    tasks access the same memory object. In this case, you have to protect the access
    in the write operations to that object. If you don''t do this, you can have a
    data race condition where the final results of a program vary from one execution
    to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java concurrency API provides mechanisms that allow you to implement both
    types of synchronization. The most basic synchronization mechanism provided by
    the Java language is the `synchronized` keyword. This keyword can be applied to
    a method or to a block of code. In the first case, only one thread can execute
    the method at a time. In the second case, you have to specify a reference to an
    object. In this case, only one block of code protected by an object can be executed
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also provide other synchronization mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Lock` interface and its implementation classes: This mechanism allows
    you to implement a critical section to guarantee that only one thread will execute
    that block of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Semaphore` class that implements the well-known **semaphore** synchronization
    mechanism introduced by *Edsger Dijkstra*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountDownLatch` allows you to implement a situation where one or more threads
    wait for the finalization of other threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CyclicBarrier` allows you to synchronize different tasks in a common point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Phaser` allows you to implement concurrent tasks divided into phases. We made
    a detailed description of this mechanism in [Chapter 5](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 5. Running Tasks Divided into Phases – The Phaser Class"), *Running Tasks
    Divided into Phases – The Phaser Class*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchanger` allows you to implement a point of data interchange between two
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletableFuture`, a new feature of Java 8, extends the `Future` mechanism
    of the executor tasks to generate the result of a task in an asynchronous way.
    You can specify tasks to be executed after the result is generated, so you can
    control the order of the execution of the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will show you how to use these mechanisms, giving
    special attention to the `CompletableFuture` mechanism introduced in the Java
    8 version.
  prefs: []
  type: TYPE_NORMAL
- en: The CommonTask class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have implemented a class named the `CommonTask` class. This class will sleep
    the calling thread during a random period of time between `0` and `10` seconds.
    This is its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All the tasks we're going to implement in the following sections will use this
    class to simulate its execution time.
  prefs: []
  type: TYPE_NORMAL
- en: The Lock interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most basic synchronization mechanisms is the `Lock` interface and
    its implementation classes. The basic implementation class is the `ReentrantLock`
    class. You can use this class to implement a critical section in an easy way.
    For example, the following task gets a lock in the first line of its code using
    the `lock()` method and releases it in the last line using the `unlock()` method.
    Only one task can execute the code between these two sentences at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check this if, for example, you execute ten tasks in an executor using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the following image, you can see the result of an execution of this example.
    You can see how only one task is executed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Lock interface](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Semaphore class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The semaphore mechanism was introduced by Edsger Dijkstra in 1962 and is used
    to control the access to one or more shared resources. This mechanism is based
    on an internal counter and two methods named `wait()` and `signal()`.When a thread
    calls the `wait()` method, if the internal counter has a value bigger than 0,
    then the semaphore decrements the internal counter and the thread gets access
    to the shared resource. If the internal counter has a value of 0, the thread is
    blocked until some thread calls the `signal()` method. When a thread calls the
    `signal()` method, the semaphore looks to see whether there are some threads waiting
    in the `waiting` state (they have called the `wait()` method). If there are no
    threads waiting, it increments the internal counter. If there are threads waiting
    for the semaphore, it gets one of those threads, which will return for the `wait()`
    method and access the shared resource. The other threads that were waiting continue
    waiting for their turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, semaphores are implemented in the `Semaphore` class. The `wait()`
    method is called `acquire()` and the `signal()` method is called `release()`.
    For example, in this example, we have used this task where a `Semaphore` class
    is protecting its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the main program, we execute ten tasks that share a `Semaphore` class initialized
    with two shared resources, so we will have two tasks running at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of an execution of this example.
    You can see how two tasks are running at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Semaphore class](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The CountDownLatch class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class provides a mechanism to wait for the finalization of one or more
    concurrent tasks. It has an internal counter that must be initialized with the
    number of tasks we are going to wait for. Then, the `await()` method sleeps the
    calling thread until the internal counter arrives at zero and the `countDown()`
    method decrements that internal counter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in this task we use the `countDown()` method to decrement the internal
    counter of the `CountDownLatch` object it receives as a parameter in its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the `main()` method, we execute the tasks in an executor and wait for
    their finalization using the `await()` method of `CountDownLatch`. The object
    is initialized with the number of tasks we want to wait for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CountDownLatch class](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The CyclicBarrier class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class allows you to synchronize some tasks in a common point. All tasks
    will wait in that point until all have arrived. Internally, it also manages an
    internal counter with the tasks that haven't arrived at that point yet. When a
    task arrives at the determined point, it has to execute the `await()` method to
    wait for the rest of the tasks. When all the tasks have arrived, the `CyclicBarrier`
    object wakes them up so they continue with their execution.
  prefs: []
  type: TYPE_NORMAL
- en: This class allows you to execute another task when all the parties have arrived.
    To configure this, you have to specify a runnable object in the constructor of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have implemented the following Runnable that uses a `CyclicBarrier`
    object to wait for other tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have also implemented another `Runnable` object that will be executed by
    `CyclicBarrier` when all the tasks have executed the `await()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `main()` method, we execute ten tasks in an executor. You can
    see how `CyclicBarrier` is initialized with the number of tasks we want to synchronize
    and with an object of the `FinishBarrierTask` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CyclicBarrier class](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how when all the tasks arrive at the point where the `await()` method
    is called, `FinishBarrierTask` is executed and then all the tasks continue with
    their execution.
  prefs: []
  type: TYPE_NORMAL
- en: The CompletableFuture class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a new synchronization mechanism introduced in the Java 8 concurrency
    API. It extends the `Future` mechanism, giving it more power and flexibility.
    It allows you to implement an event-driving model linking tasks that will only
    be executed when others have finished. As with the `Future` interface, `CompletableFuture`
    must be parameterized with the type of the result that will be returned by the
    operation. As with a `Future` object, the `CompletableFuture` class represents
    a result of an asynchronous computation, but the result of `CompletableFuture`
    can be established by any thread. It has the `complete()` method to establish
    the result when the computation ends normally, and the method `completeExceptionally()`
    when the computation ends with an exception. If two or more threads call the `complete()`
    or `completeExceptionally()` methods over the same `CompletableFuture`, only the
    first call will take effect.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can create `CompletableFuture` using its constructor. In this case,
    you have to establish the result of the task using the `complete()` method as
    we explained before. But you can also create one using the `runAsync()` or `supplyAsync()`
    methods. The `runAsync()` method executes a `Runnable` object and returns `CompletableFuture<Void>`
    so that computation can't return any result. The `supplyAsync()` method executes
    an implementation of the `Supplier` interface parametrized with the type that
    will be returned by this computation. The `Supplier` interface provides the `get()`
    method. In that method, we have to include the code of the task and return the
    result generated by it. In this case, the result of `CompletableFuture` will be
    the result of the `Supplier` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class provides a lot of methods that allow you to organize the order of
    execution of tasks implementing an event-driving model where one task doesn''t
    start its execution until a previous one has finished. These are some of those
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thenApplyAsync()`: This method receives as a parameter an implementation of
    the `Function` interface that can be represented as a lambda expression. This
    function will be executed when the calling `CompletableFuture` has been completed.
    This method will return `CompletableFuture` to get the result of the `Function`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenComposeAsync()`: This method is analogous to `thenApplyAsync`, but is
    useful when the supplied function returns `CompletableFuture` too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenAcceptAsync()`: This method is similar to the previous one but the parameter
    is an implementation of the `Consumer` interface that can be also specified as
    a lambda expression; in this case, the computation won''t return a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenRunAsync()`: This method is equivalent to the previous one but in this
    case receives a `Runnable` object as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenCombineAsync()`: This method receives two parameters. The first one is
    another `CompletableFuture` instance. The other is an implementation of the `BiFunction`
    interfaces that can be specified as a lambda function. This `BiFunction` will
    be executed when both `CompletableFuture` (the calling one and the parameter)
    have been completed. This method will return `CompletableFuture` to get the result
    of the `BiFunction`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAfterBothAsync()`: This method receives two parameters. The first one is
    another `CompletableFuture`. The other is an implementation of the `Runnable`
    interface that will be executed when both `CompletableFuture` (the calling one
    and the parameter) have been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAfterEitherAsync()`: This method is equivalent to the previous one, but
    the Runnable task is executed when one of the `CompletableFuture` objects is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allOf()`: This method receives as a parameter a variable list of `CompletableFuture`
    objects. It will return a `CompletableFuture<Void>` object that will return its
    result when all the `CompletableFuture` objects have been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anyOf()`: This method is equivalent to the previous one, but the returned
    `CompletableFuture` returns its result when one of the `CompletableFuture` is
    completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you want to obtain the result returned by `CompletableFuture`, you
    can use the `get()` or `join()` methods. Both methods block the calling thread
    until `CompletableFuture` has been completed and then returns its result. The
    main difference between both methods is that `get()` throws `ExecutionException`,
    which is a checked exception, but `join()` throws `RuntimeException` (which is
    an unchecked exception). Thus, it's easier to use `join()` inside non-throwing
    lambdas (like `Supplier`, `Consumer`, or `Runnable`).
  prefs: []
  type: TYPE_NORMAL
- en: Most of the methods explained before have the `Async` suffix. This means that
    these methods will be executed in a concurrent way using the `ForkJoinPool.commonPool`
    instance. Those methods that have versions without the `Async` suffix will be
    executed in a serial way (that is to say, in the same thread where `CompletableFuture`
    is executed) and with the `Async` suffix and an executor instance as an additional
    parameter. In this case, `CompletableFuture` will be executed asynchronously in
    the executor passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CompletableFuture class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, you will learn how to use the `CompletableFuture` class to
    implement the execution of some asynchronous tasks in a concurrent way. We will
    use our collection of 20,000 products of Amazon to implement the following tree
    of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the CompletableFuture class](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, we're going to use the examples. Then, we will execute four concurrent
    tasks. The first one will make a search of products. When the search finishes,
    we will write the results to a file. The second one will obtain the best-rated
    product. The third one will obtain the best-selling product. When these both finish,
    we will concatenate their information using another task. Finally, the fourth
    task will get a list with the users who have purchased a product. The `main()`
    program will wait for the finalization of all the tasks and then will write the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the details of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary tasks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we will use some auxiliary tasks. The first one is `LoadTask`,
    which will load the product information from the disk and will return a list of
    `Product` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It implements the `Supplier` interface to be executed as `CompletableFuture`.
    Inside, it uses a stream to process and parse all the files obtaining a list of
    products.
  prefs: []
  type: TYPE_NORMAL
- en: The second task is `SearchTask`, which will implement the search in the list
    of `Product` objects, looking for the ones that contain a word in the title. This
    task is an implementation of the `Function` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It receives `List<Product>` with the information of all the products a return
    `List<Product>` with the products that meet the criteria. Internally, it creates
    the stream on the input list, filters it, and collects the result to another list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `WriteTask` is going to write the products obtained in the search
    task in a `File`. In our case, we generate an HTML file, but feel free to write
    this information in the format you want. This task implements the `Consumer` interface,
    so its code must be something like the follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The main() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have organized the execution of the tasks in the `main()` method. First,
    we execute the `LoadTask` using the `supplyAsync()` method of the `CompletableFuture`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, with the resultant `CompletableFuture`, we use `thenApplyAsync()` to execute
    the search task when the load task has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the search task has been completed, we want to write the results of the
    execution in a file. As this task won''t return a result, we use the `thenAcceptAsync()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have used the exceptionally() method to specify what we want to do if the
    write task throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `thenApplyAsync()` method over the `completableFuture` object
    to execute the task to get the list of users who purchased a product. We specify
    this task as a lambda expression. Take into account that this task will be executed
    in parallel with the search task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In parallel with these tasks, we also executed the tasks using the `thenApplyAsync()`
    method to find the best-rated product and the best-selling product. We have defined
    these tasks using a lambda expression too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, we want to concatenate the results of the last two tasks.
    We can do this using the `thenCombineAsync()` method to specify a task that will
    be executed after both tasks have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we wait for the end of the final tasks using the `allOf()` and `join()`
    methods and write the results using the `get()` method to obtain them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, you can see the results of an execution of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The main() method](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, the `main()` method executes all the configuration and waits for the
    finalization of the tasks. The execution of the tasks follows the order we have
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed two components of all concurrent applications.
    The first one is data structures. Every program uses them to store in memory the
    information it has to process. We have quickly been introduced to the concurrent
    data structures to make a detailed description of the new features introduced
    in the Java 8 Concurrency API that affect the `ConcurrentHashMap` class and the
    classes that implement the `Collection` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The second one is the synchronization mechanisms that allow you to protect your
    data when more than one concurrent task wants to modify them, and to control the
    order of execution of the tasks if necessary. In this case, we have also quickly
    been introduced to the synchronization mechanisms, giving a detailed description
    of `CompletableFuture`, a new feature of the Java 8 concurrency API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will show you how you can implement complete concurrent
    systems integrating the different parts that can also be concurrent and using
    different classes to implement its concurrency.
  prefs: []
  type: TYPE_NORMAL
