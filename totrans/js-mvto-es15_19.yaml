- en: Chapter 6. Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a different approach to development than the heavily
    object oriented approach that we have focused on so far. Object oriented programming
    is a fantastic tool for solving a great number of problems but it has some issues.
    Parallel programming within an object oriented context is difficult as the state
    can be changed by various different threads with unknown side effects. Functional
    programming does not permit state or mutable variables. Functions act as primary
    building blocks in functional programming. Places where you might have used a
    variable in the past will now use a function.
  prefs: []
  type: TYPE_NORMAL
- en: Even in a single threaded program, functions can have side-effects that change
    global state. This means that, when calling an unknown function, it can alter
    the whole flow of the program. This makes debugging a program quite difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is not a functional programming language but we can still apply
    some functional principles to our code. We''ll look at a number of patterns in
    the functional space:'
  prefs: []
  type: TYPE_NORMAL
- en: Function passing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters and pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional functions are side-effect-free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core tenant of functional programming is that functions should not change
    state. Values local to the function may be set but nothing outside the function
    may change. This approach is very useful for making code more maintainable. There
    need no longer be any concern that passing an array into a function is going to
    play havoc with its contents. This is especially a concern when using libraries
    that are not under your control.
  prefs: []
  type: TYPE_NORMAL
- en: There is no mechanism within JavaScript to prevent you from changing global
    state. Instead you must rely on developers to write side-effect-free functions.
    This may be difficult or not, depending on the maturity of the team.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be desirable to put all the code from your application into functions,
    but separating as much as possible is desirable. There is a pattern called command
    query separation that suggests that methods should fall into two categories. Either
    they are a function that reads a value or they are a command that sets a value.
    Never the twain should meet. Keeping methods categorized like this eases in debugging
    and in code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: One of the consequences of side effect-free functions is that they can be called
    any number of times with the same inputs and the result will be the same. Furthermore,
    because there are no changes to state, calling the function many times will not
    cause any ill side effects, other than making it run slower.
  prefs: []
  type: TYPE_NORMAL
- en: Function passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming languages, functions are first class citizens. Functions
    can be assigned to variables and passed around just like you would with any other
    variable. This is not entirely a foreign concept. Even languages such as C had
    function pointers that could be treated just like other variables. C# has delegates
    and, in more recent versions, lambdas. The latest release of Java has also added
    support for lambdas as they have proven to be so useful.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript allows for functions to be treated as variables and even as objects
    and strings. In this way JavaScript is functional in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of JavaScript''s single threaded nature, callbacks are a common convention
    and you can find them pretty much everywhere. Consider calling a function at a
    later date on a web page. This is done by setting a timeout on the window object
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The arguments for the set timeout function are a function to call and a time
    to delay in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Irrespective of the JavaScript environment in which you''re working, it is
    almost impossible to avoid functions in the shape of callbacks. Node.js'' asynchronous
    processing model is highly dependent on being able to call a function and pass
    in something to be completed at a later date. Making calls to external resources
    in a browser is also dependent on a callback to notify the caller that some asynchronous
    operation has completed. In basic JavaScript this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that we assign the `onreadystatechange` function before we even
    send the request. This is because assigning it later may result in a race condition
    in which the server responds before the function is attached to the ready state
    change. In this case, we''ve used an inline function to process the returned data.
    Because functions are first class citizens we can change this to look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is typically a cleaner approach and avoids performing complex processing
    in line with another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you might be more familiar with the jQuery version of this, which
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the boiler plate of dealing with ready state changes is handled
    for you. There is even convenience provided for you if the request for data fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've passed an object into the `ajax` call which defines a number
    of properties. Amongst these properties are function callbacks for success and
    failure. This method of passing numerous functions into another suggests a great
    way of providing expansion points for classes.
  prefs: []
  type: TYPE_NORMAL
- en: Likely you've seen this pattern in use before without even realizing it. Passing
    functions into constructors as part of an options object is a commonly used approach
    to providing extension hooks in JavaScript libraries. We saw some treatment of
    functions in the previous chapter, [Chapter 5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "Chapter 5. Behavioral Patterns"), *Behavioral Patterns*, when passing function
    into the observer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Westeros the tourism industry is almost non-extant. There are great difficulties
    with bandits killing tourists and tourists becoming entangled in regional conflicts.
    Nonetheless, some enterprising folks have started to advertise a grant tour of
    Westeros in which they will take those with the means on a tour of all the major
    attractions. From King's Landing to Eyrie, to the great mountains of Dorne - the
    tour will cover it all. In fact, a rather mathematically inclined member of the
    tourism board has taken to calling it a Hamiltonian tour as it visits everywhere
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HamiltonianTour` class provides an options object which allows the definition
    of an options object. This object contains the various places to which a callback
    can be attached. In our case the interface for it would look something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The full `HamiltonianTour` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in the highlighted code how we check the options and then execute
    the callback as needed. This can be used by simply doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running this code would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Passing functions is a great approach to solving a number of problems in JavaScript
    and tends to be used extensively by libraries such as jQuery and frameworks such
    as express. It is so commonly adopted that using it provides added barriers to
    your code's readability.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re at all familiar with the Unix command line or, to a lesser extent,
    the Windows command line, then you''ll have probably made use of pipes. A pipe,
    which is represented by the `|` character is shorthand for "take the output of
    program A and put it into program B". This relatively simple idea makes the Unix
    command line incredibly powerful. For instance, if you wanted to list all the
    files in a directory and then sort them and filter for any which start with either
    the letters `b` or `g` and end with an `f` then the command might look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ls` command lists all files and directories, the `sort` command sorts
    them, and the `grep` command matches file names against a regular expression.
    Running this command in the `etc` directory on an Ubuntu box in `/etc` would give
    a result which looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Some functional programming languages such as F# offer a special syntax for
    piping between functions. In F#, filtering a list for even numbers can be done
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is very nice-looking, especially when used for long chains of functions.
    As an example, taking a number, casting it to a float, square rooting it, and
    then rounding it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a clearer syntax than the C-style syntax that would look more like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, there is no ability to write pipes in JavaScript using a nifty
    F# style syntax, but we can still improve upon the normal method shown in the
    preceding code by using method chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in JavaScript is an object, which means that we can have some real
    fun adding functionality to existing objects to improve their look. Operating
    on collections of objects is a space in which functional programming provides
    some powerful features. Let's start by adding a simple filtering method to the
    array object. You can think of these queries as being like SQL database queries
    written in a functional fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We would like to provide a function that performs a match against each member
    of the array and returns a set of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The rather simple looking function allows us to quickly filter an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we return is also an object, an array object in this case. We can continue
    to chain methods onto it like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The result of this is an array containing only the number 6, as it is the only
    number between 1 and 10 which is both even and divisible by three. This method
    of returning a modified version of the original object without changing the original
    is known as a fluent interface. By not changing the original item array, we've
    introduced a small degree of immutability into our variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add another function to our library of array extensions, we can start
    to see how useful these pipes can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This extension allows for projections of the original items based on an arbitrary
    projection function. Given a set of objects which contain IDs and names, we can
    use our fluent extensions to array to perform complex operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will build a new array which contains only children with even IDs
    and instead of full objects, the array will contain only their names: `Sansa`
    and `Brandon`. For those familiar with .Net these functions may look very familiar.
    The **Language Integrated Queries** (**LINQ**) library on .Net provides similarly
    named functional inspired functions for the manipulation of collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chaining functions in this manner can be both easier to understand and easier
    to build than alternatives: temporary variables are avoided and the code made
    terser. Consider the preceding example re-implemented using loops and temporary
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A number of JavaScript libraries such as d3 are constructed to encourage this
    sort of programming. At first it seems like the code created following this convention
    is bad due to very long line length. I would argue that this is a function of
    line length not being a very good tool to measure complexity rather than an actual
    problem with the approach.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at some simple array functions which add filtering and pipes to
    arrays. Another useful tool is the accumulator. Accumulators aid in building up
    a single result by iterating over a collection. Many common operations such as
    summing up the elements of an array can be implemented using an accumulator instead
    of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is popular within functional programming languages and many of them
    actually offer an optimization called "tail call optimization". A language that
    supports this provides optimizations for functions using recursion in which the
    stack frame is reused. This is very efficient and can easily replace most loops.
    Details on whether tail call optimization is supported in any JavaScript interpreter
    are sketchy. For the most part it doesn't seem like it is but we can still make
    use of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with `for` loops is that the control flow through the loop is mutable.
    Consider this rather easy-to-make mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you spot the error? It took me several attempts to get a working version
    of this code I could break. The problem is in the loop counter in the second loop,
    it should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Obviously this could be somewhat mitigated through better variable naming but
    we would like to avoid the problem altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Instead we can make use of an accumulator, a tool for combining multiple values
    from a collection into a single value. We've rather missed Westeros for a couple
    of patterns so let's get back to our mythical example land. Wars cost a great
    deal of money but fortunately there are a great number of peasants to pay taxes
    and finance the lords in their games for the throne.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our peasants are represented by a simple model which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Over this set of peasants we have an accumulator which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code takes a list of items, an accumulator value, and a function that projects
    the value to be integrated into the accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projection function looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to prime this function, we simply need to pass in an initial value
    for the accumulator along with the array and projection. The priming value will
    vary but more often than not it will be an identity; an empty string in the case
    of a string accumulator and a 0 or 1 in the case of mathematical ones.
  prefs: []
  type: TYPE_NORMAL
- en: Each pass through the accumulator shrinks the size of the array over which we
    are operating. All this is done without a single mutable variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner accumulation can really be any function you like: string appending,
    addition, or something more complicated. The accumulator is somewhat like the
    visitor pattern except that modifying values in the collection inside an accumulator
    is frowned upon. Remember that functional programming is side-effect-free.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not to be confused with memorization, memoization is a specific term for retaining
    a number of previously calculated values from a function.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, side-effect-free functions can be called multiple times without
    causing problems. The corollary to this is that a function can also be called
    fewer times than needed. Consider an expensive function which does some complex
    or, at least, time-consuming math. We know that the result of the function is
    entirely predicated on the inputs to the function. So the same inputs will always
    produce the same outputs. Why, then, would we need to call the function multiple
    times? If we saved the output of the function, we could retrieve that instead
    of redoing the time-consuming math.
  prefs: []
  type: TYPE_NORMAL
- en: Trading off space for time is a classic computing science problem. By caching
    the result, we make the application faster but we will consume more memory. Deciding
    when to perform caching and when to simply recalculate the result is a difficult
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros, learned men, known as Maesters, have long had a fascination
    with a sequence of numbers which seems to reappear a great deal in the natural
    world. In a strange coincidence they call this sequence the Fibonacci sequence.
    It is defined by adding the two previous terms in the sequence to get the next
    one. The sequence is bootstrapped by defining the first few terms as 0, 1, 1\.
    So to get the next term we would simply add 1 and 1 to get 2\. The next term would
    add 2 and 1 to get 3 and so forth. Finding an arbitrary member of the sequence
    requires finding the two previous members, so it can end up being a bit of calculation.
  prefs: []
  type: TYPE_NORMAL
- en: In our world we have discovered a closed form that avoids much of this calculation
    but in Westeros no such discovery has been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naïve approach is to simply calculate every term like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This solution works very quickly for small numbers such as 10\. However, for
    larger numbers, say greater than 40, there is a substantial slow-down. This is
    because the base case is called 102,334,155 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if we can improve things by memoizing some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have just memoized every item we encounter. As it turns out for this algorithm
    we store *n+1* items, which is a pretty good trade-off. Without memoization, calculating
    the 40th fibonacci number took 963ms while the memoization version took only 11ms.
    The difference is far more pronounced when the functions become more complex to
    calculate. Fibonacci of 140 took 12 ms for the memoization version while the naïve
    version took… well, it is has been a day and it is still running.
  prefs: []
  type: TYPE_NORMAL
- en: The best part of this memoization is that subsequent calls to the function with
    the same parameter will be lightning-fast as the result is already computed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example only a very small cache was needed. In more complex examples
    it is difficult to know how large a cache should be or how frequently a value
    will need to be recomputed. Ideally your cache will be large enough that there
    will always be room to put more results in. However, this may not be realistic
    and tough decisions will need to be made about which members of the cache should
    be removed to save space. There is a plethora of methods for performing cache
    invalidation. It has been said that cache invalidation is one of the toughest
    problems in computing science, the reason being that we're effectively trying
    to predict the future. If anybody has perfected a method of telling the future,
    it is likely they are applying their skills in a more important domain than cache
    invalidation. Two options are to prey on the least recently used member of the
    cache or the least frequently used member. It is possible that the shape of the
    problem may dictate a better strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a fantastic tool for speeding up calculations which need to be
    performed multiple times or even calculations which have common sub-calculations.
    One can consider memoization as just a special case of caching, which is a commonly
    used technique when building web servers or browsers. It is certainly worthwhile
    exploring in more complex JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the cornerstones of functional programming is that so called variables
    can be assigned only once. This is known as immutability. ECMAScript 2015 supports
    a new keyword, `const`. The `const` keyword can be used in the same way as `var`
    except that variables assigned with `const` will be immutable. For instance, the
    following code shows a variable and a constant that are both manipulated in the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the results for the constant and variable are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using an older browser without support, then `const` won''t be available
    to you. A possible workaround is to make use of the `Object.freeze` functionality
    which is more widely adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax here is not very user-friendly. Also an issue is
    that attempting to assign to an already assigned `const` simply fails silently
    instead of throwing an error. Failing silently in this fashion is not at all a
    desirable behavior; a full exception should be thrown. If you enable strict mode,
    a more rigorous parsing mode is added in ECMAScript 5, and an exception is actually
    thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is the `object.Create` syntax we spoke about earlier. When creating
    properties on the object, one can specify `writable: false` to make the property
    immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, even in strict mode no exception is thrown when attempting to write
    to a non-writable property. Thus I would claim that the `const` keyword is not
    perfect for implementing immutable objects. You're better off using freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go into a higher-end coffee shop and place an order for some overly complex
    beverage (Grande Chai Tea Latte, 3 Pump, Skim Milk, Lite Water, No Foam, Extra
    Hot anybody?) then that beverage is going to be made on-the-fly and not in advance.
    Even if the coffee shop knew which orders were going to come in that day, they
    would still not make all the beverages up front. First, because it would result
    in a large number of ruined, cold beverages, and second, it would be a very long
    time for the first customer to get their order if they had to wait for all the
    orders of the day to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead coffee shops follow a just-in-time approach to crafting beverages. They
    make them when they're ordered. We can apply a similar approach to our code through
    the use of a technique known as lazy instantiation or lazy initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an object which is expensive to create; that is to say that it takes
    a great deal of time to create the object. If we are unsure if the object's value
    will be needed, we can defer its full creation until later.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump into an example of this. Westeros isn''t really big on expensive
    coffee shops but they do love a good bakery. This bakery takes requests for different
    bread types in advance and then bakes them all at once should they get an order.
    However, creating the bread object is an expensive operation so we would like
    to defer that until somebody actually comes to pick up the bread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating a list of bread types to be created as needed. This list
    is appended to by ordering a bread type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This allows for breads to be rapidly added to the required bread list without
    paying the price for each bread to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when `pickUpBread` is called we''ll actually create the breads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we call a series of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the collection of actual breads is left until after the pickup
    has been requested.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation can be used to simplify asynchronous programming. Promises
    are an approach to simplifying callbacks which are common in JavaScript. Instead
    of building up complicated callbacks, a promise is an object which contains a
    state and a result. When first called, the promise is in an unresolved state;
    once the `async` operation completes, the state is updated to complete and the
    result is filled in. You can think of the result as being lazily instantiated.
    We'll look at promises and promise libraries in more detail in [Chapter 9](part0147_split_000.html#4C62M2-015e68c68a464f18a9559f448be84435
    "Chapter 9. Web Patterns"), *Web Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Being lazy can save you quite a bit of time in creating expensive objects that
    end up never being used.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although callbacks are the standard way of dealing with asynchronous methods
    in JavaScript they can get out of hand easily. There are a number of approaches
    to solving this spaghetti code: promise libraries provide a more fluent way of
    handling callbacks and future versions of JavaScript may adopt an approach similar
    to the C# `async/await` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: I really like accumulators but they can be inefficient in terms of memory use.
    The lack of tail recursion means that each pass through adds another stack frame,
    so this approach may result in memory pressure. All things are a trade-off in
    this case between memory and code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is not a functional programming language. That is not to say that
    it isn't possible to apply some of the ideas from functional programming to it.
    These approaches enable cleaner, easier to debug code. Some might even argue that
    the number of issues will be reduced although I have never seen any convincing
    studies on that.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we looked at six different patterns. Lazy instantiation, memoization,
    and immutability are all creational patterns. Function passing is a structural
    pattern as well as a behavioral one. Accumulators are also behavioral in nature.
    Filters and pipes don't really fall into any of the GoF categories so one might
    think of them as a style pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll look at a number of patterns for dividing the logic
    and presentation in applications. These patterns have become more important as
    JavaScript applications have grown.
  prefs: []
  type: TYPE_NORMAL
