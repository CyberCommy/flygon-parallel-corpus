- en: Building an ASP.NET Core Music Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter marks a change in direction for us. In previous chapters, we concentrated
    on using TypeScript as our main development language. In this chapter, we are
    going to look at how we can use TypeScript inside Microsoft's ASP.NET Core in
    order to learn how to mix ASP.NET Core, C#, and TypeScript to make an artist-search
    program where we can search for musicians and retrieve details about their music.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why we have ASP.NET Core MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an ASP.NET Core application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why we have `Program.cs` and `Startup.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding TypeScript support to an ASP.NET application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `fetch` promise in TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires .NET Core Framework version 2.1 or higher. The easiest
    way to install this framework is to download and install Visual Studio; Microsoft
    provides a fully functional Community Edition, which you can get at [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: .NET applications don't tend to use `npm` to download packages; instead, they
    use NuGet to manage .NET packages. Building the source code will download the
    packages automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ASP.NET Core MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft has a long and relatively chequered history with web frameworks.
    I first started developing server-based applications back in the late 1990s with
    their **Active Server Pages** technology, now known as classic **ASP**. This technology
    allowed the developer to create dynamic web pages based on user requests and send
    the resulting web pages back to the client. This technology required a special
    **Internet Information Services** (**IIS**) plugin for it to work, so it was entirely
    Windows-based and was a strange mix of the proprietary VBScript language and HTML.
    This meant that we often saw code that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the language was so verbose for mixing dynamic content with HTML,
    and the underlying types were not type-safe, meant that developing with ASP was
    particularly error-prone, and debugging was challenging, to say the least.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the evolution of ASP was formally released in 2002 and was
    known as ASP.NET (or ASP.NET Web Forms). This was based on Microsoft's new .NET
    Framework and radically changed the way that we built web applications. Using
    this, we could build applications using languages such as C# or VB.NET and combine
    user controls in our web pages in order to create small self-contained components
    that slotted into our web pages. This was a great move on Microsoft's part, but
    there were still some fundamental issues that people spent a lot of time working
    around. The biggest issue was the fact that the web page was inherently mixed
    with the logic because the actual server-side implementation was handled using
    code behind. There was also a strict page compilation cycle, so the default architecture
    was based on the idea that there would be a round trip between the client and
    the server. Again, this could be worked around (and frequently was), but as a
    default architecture, it left a lot to be desired. Also, this technology was tied
    into the Windows platform, so it didn't get the reach that it could have. Even
    though .NET and C# were standardized so that other implementations could be created,
    Web Forms was a proprietary technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recognizing the limitations of the Web Forms model, a team inside Microsoft
    decided to work on a form of ASP that would no longer be bound by the code-behind
    limitations of Web Forms. This was a major step forward because it opened the
    architecture up to developers so that they could follow object-oriented best practices
    better, including separation of concerns. All of a sudden, Microsoft had given
    developers a fighting chance of developing applications that followed SOLID design
    principles. This framework, known as ASP.NET MVC, allows us to develop applications
    following the **Model View Controller** (**MVC**) pattern. This is a powerful
    pattern because it allows us to separate code out into separate logical areas.
    MVC stands for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This is the business layer that represents the logic that drives
    the behavior of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This is the display that the user sees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This handles the inputs and interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the interactions in the MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc31160f-78d5-4ae0-8cde-bd36722bc352.png)'
  prefs: []
  type: TYPE_IMG
- en: This architecture represents yet another major step forward for us when we want
    to develop full-stack web applications; however, it still suffers from the problem
    that it relies on Windows to host it.
  prefs: []
  type: TYPE_NORMAL
- en: Indirectly, from this diagram, we can work out that ASP.NET represents code
    that runs both on the client and on the server. This means that we don't need
    a server-side instance of Node running, so we can leverage the power and features
    of the .NET stack with this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Something that came as a surprise to a lot of people was the fact that Microsoft
    began to shift its focus away from Windows—long considered a cash cow for the
    company—and moved toward a more open model where the operating system their applications
    ran on became much less important. This has reflected a shift in its core priorities
    where cloud operations, through their superlative Azure offerings, have very much
    become the focus. If Microsoft stayed with its web architecture as it stood, then
    it would be missing out on a lot of the opportunities that were opening up; therefore,
    it started a multi-year rearchitecting of .NET Framework to remove its reliance
    on Windows and to make it platform-agnostic for developers using it.
  prefs: []
  type: TYPE_NORMAL
- en: This has resulted in Microsoft releasing ASP.NET Core MVC, which removes the
    reliance on Windows altogether. From one code base, we can now target Windows
    or Linux. All of a sudden, the number of servers that we can host our code on
    has gone through the roof, and the cost of running the servers has potentially
    gone down. At the same time, with each successive version of Core that Microsoft
    releases, they are tuning and honing the performance to give considerable boosts
    in the request server statistics. Also, the fact that we can develop these applications
    for free, and target Linux hosting as well, means that this technology is a lot
    more exciting for start-ups. I thoroughly expect the number of start-ups getting
    on the ASP.NET Core MVC bandwagon to grow significantly over the next couple of
    years as cost barriers are reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project we are building in this chapter is quite different from any of the
    ones we have written so far. This project sees us moving away from pure TypeScript
    and toward working with mixed programming languages, namely C# and TypeScript,
    as we see how to incorporate TypeScript into an ASP.NET Core web application.
    The application itself uses the Discogs music API so that our users can search
    for artists and retrieve details of their discography and artwork. The search
    part is accomplished using pure ASP.NET with C#, while the artwork retrieval is accomplished
    using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as you work alongside the code in the GitHub repository, this chapter
    should take about 3 hours to complete, which will not seem like much as we try
    out the code together! The finished application will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18c8afb1-0dc6-460b-9a92-d52982b833a8.png)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started creating a music library with ASP.NET Core, C#, and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a big music fan. I have played guitar for years, which has led to me listening
    to a lot of musicians. Keeping track of all the music they have produced can be
    a very complex task, so I have long been interested in publicly available APIs
    that let us search for all things musician-related. The public API that I think
    provides us with the widest set of choices for querying for albums, artists, tracks,
    and more is the Discog library.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take advantage of this API and write an application
    that leverages ASP.NET Core in order to show you how we can use C# and TypeScript
    cooperatively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run this application, you will need to set up an account at Discogs,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start off at [https://www.discogs.com/users/create](https://www.discogs.com/users/create)
    and sign up for an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While we could create a Discogs API application if we wanted to, especially
    if we wanted to take advantage of features such as authentication and having access
    to the full API, all we need for our purposes is to generate a personal access
    token by clicking the Generate token button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ae659752-6d91-4511-8b26-011bcd220084.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have signed up to Discogs and generated our token, we are ready
    to create our ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our ASP.NET Core application with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we created our applications from the command line. With
    Visual Studio, however, the normal practice is to create our application visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio and select Create a New Project to start the wizard for
    creating new projects. We are going to create an ASP.NET Core Web Application,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5d736ebb-0268-4a52-b701-eb8f29c3ade3.png)'
  prefs: []
  type: TYPE_IMG
- en: Older versions of .NET were only capable of running on Windows platforms. While
    .NET is an excellent framework, and C# is a wonderful language, this lack of cross-platform
    capability meant that .NET was only ever favored by companies with Windows desktops
    or Windows servers available. A while back, Microsoft decided to address this
    deficiency by stripping .NET back and rearchitecting it from the ground up as
    something that could run cross-platform. This has broadened the reach of .NET
    immensely and is known as .NET Core. What this means to us is that we can develop
    on one platform and deploy our application to another platform. Internally, .NET
    Core applications have platform-specific code that gets hidden behind a single
    .NET API so, for example, we can do file access without worrying about how the
    underlying operating system handles files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to choose where we are going to put our code. My local Git repository
    is based under `E:\Packt\AdvancedTypeScript3`, so targeting that as my location
    tells Visual Studio to create the necessary files in a folder under that directory.
    In this case, Visual Studio will create a solution called `Chapter10`, which will
    contain all of our files. Click Create to create all the files we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bcb4038d-155f-4f8b-bd39-055f3290fbaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once Visual Studio has finished creating our solution, it should have the following
    files available. As we develop our application, we will discuss the more important
    files and look at how we can use them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/85a99675-de30-4783-accb-81050be3a5aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also build and run our application (pressing *F5* will do this), resulting
    in the application starting up like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/20bd92b9-ec72-4549-a592-7bdd61b87d62.png)'
  prefs: []
  type: TYPE_IMG
- en: Having created our application, in the next section, we are going to cover the
    important points of the generated code, starting with the startup and program
    files before we start to amend it and bring in our search functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavior-wise, the starting point for our application is the `Startup` class.
    The purpose of this file is to set up the system during the startup process, so
    we take care of features such as configuring how cookies will be handled by our
    application and adding HTTP support. While this class is largely boilerplate in
    terms of functionality, we will come back to it later on in order to add support
    for the Discogs client we are going to write. The questions are, where does this
    functionality get called from? What actually starts our physical application?
    The answer to these questions is the `Program` class. If we quickly break this
    code down, we will see how the startup functionality is brought in and how it
    helps to build our hosting application.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET-executable applications start with a `Main` method. Sometimes, this is
    hidden from developers, but there is always one somewhere. This is the standard
    entry point for executable applications, and our web application is no different.
    This static method simply calls the `CreateWebHostBuilder` method, passing in
    any command-line arguments before calling Build and Run to build the host and
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `=>` here is not the same as using the fat arrow. What this does,
    in this particular context, is replace the `return` keyword, so if you have a
    method with a single `return` operation, this can be simplified. The equivalent
    code, complete with the `return` statement, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateDefaultBuilder` is used to configure our service host with options such
    as setting up the Kestrel web engine, loading configuration information, and setting
    up logging support. The `UseStartup` method tells the default builder that our
    `Startup` class is the one that it needs to use to start the service.'
  prefs: []
  type: TYPE_NORMAL
- en: The Startup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what does our `Startup` class actually look like? Well, in a similar fashion
    to the way we have been developing with TypeScript, C# starts with the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike JavaScript, C# does not have a special `constructor` keyword. Instead,
    C# uses the name of the class to represent the constructor. Note that, just like
    JavaScript when we create our constructor, we don''t give it a return type (we''ll
    see how C# deals with return types shortly). Our constructor is going to receive
    a configuration entry to allow us to read the configuration. We expose this as
    a C# property using the following `get;` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the runtime starts up our host process, the `ConfigureServices` method
    is called. This is the point where we would hook in any services that we need;
    in this code, I've added an `IDiscogsClient`/`DiscogsClient` registration, which
    adds this particular combination to the IoC container so that we can inject it
    into other classes later on. We have already seen an example of the dependency
    injection happening in this class with the configuration being supplied to the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry that we haven''t seen `IDiscogsClient` and `DiscogsClient` yet.
    We will soon be adding the class and interface to our code. Here, we are registering
    them with the service collection so that they can be injected into classes automatically.
    As you may remember from what we said earlier in this book, a singleton will only
    give one instance of a class, regardless of where it is used. This is very similar
    to when we generated services in Angular, where we were registering the services
    as singletons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Something to note here is that the place where we set the return type differs
    from TypeScript. Like we saw in our TypeScript, we set the return type at the
    very end of the method declaration. With C#, the return type is set before the
    name so we know that `ConfigureServices` has a `void` return type.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax on `AddSingleton` shows that C# also supports generics, so the syntax
    should not be scary to us. While there is a lot of parity in the language, TypeScript
    has some interesting differences here in that there aren't dedicated `any` or
    `never` types, for instance. If we wanted our C# type to do something similar
    to `any`, it would have to use the `object` type instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the underlying services have been configured, the last step for this
    class is to configure the HTTP request pipeline. This simply means that this tells
    the application how to respond to HTTP requests. In this code, we can see that
    we already have support for static files enabled. This is very important for us
    because we are going to rely on static file support to hook our TypeScript (well,
    the compiled JavaScript version) so that it coexists with our C# application.
    We can also see that routing has been set up for our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's all very well creating the C# infrastructure to fire up our application,
    but if we don't have anything to display, then we are wasting our time. It is
    time for us to look at the base files that are going to be served up.
  prefs: []
  type: TYPE_NORMAL
- en: The files that make up the base views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entry point for our view is the special `_ViewStart.cshtml` file. This
    file defines the common layout that the application will display. Rather than
    adding the contents to this file directly, we place the contents in a file called
    `_Layout.cshtml` and refer to this (minus the file extension) when setting the `Layout`
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Files that end with `.cshtml` have a special meaning to ASP.NET. This tells
    the application that these files are a combination of C# and HTML, which the underlying
    engine will have to compile before serving the result to the browser. We should
    be very familiar with this concept by now, having seen similar behavior with both
    React and Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered the view entry point, we need to consider `_Layout`
    itself. The default ASP.NET implementation currently uses Bootstrap 3.4.1 so,
    as we go through this file, we''re going to make the necessary changes for using
    Bootstrap 4\. Let''s start with the header as it currently stands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This header looks like a fairly normal header, but there are a few little quirks
    in it. In the title, we are picking up `Title` from `@ViewData`. We use `@ViewData`
    to transfer data between the controller and the view, so if we looked in the `index.cshtml`
    file (for instance), the top part of the file would say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What this section does, in combination with our layout, is set our `title` tag
    to `Home Page - Chapter 10`. The `@` symbol tells the compiler that ASP.NET's
    templating engine, called Razor, will have to do something with that piece of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of our header splits the logic of what style sheets to include
    based on whether or not we are in the development environment. If we are running
    a development build, we get one set of files, whereas the release version gets
    the minified versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to simplify our header by serving up Bootstrap from the CDN, regardless
    of whether or not we are in development mode, and change our title slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of our page layout is the `body` element. We are going to
    break this down section by section. Starting with the `body` element, we are going
    to look at the `navigation` element first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is, by and large, a familiar `navigation` component (albeit in Bootstrap
    3 format). Converting the `navigation` component into Bootstrap 4 gives us the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the unfamiliar areas lie inside the `a` links. The `asp-controller` class
    links the view to the `controller` class; by convention, these class names expand
    out into `<<name>>Controller`, so `Home` becomes `HomeController`. There is an
    associated `asp-action`, which relates to the method inside the controller class
    that we will call. Clicking the `About` link will call the `About` method inside
    `HomeController.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method sets a message that will be written onto the `About` page, and then
    returns that view. ASP.NET is smart enough to use `View()` to work out that it
    should return the `About.cshtml` page for this because this is the `About` action.
    This is where we start to see the controller part join to the view part in MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the `_Layout` file, the next section that we are interested
    in is the following section, where we render in the body contents using `@RenderBody`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The view that we have chosen to display from our controller will be rendered
    at the point that `@RenderBody` is declared, so we can assume that the purpose
    of this command is to act as the placeholder to put the relevant view in. We are
    going to change this slightly to use our Bootstrap knowledge properly and to add
    a more meaningful footer. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to cover the rest of this file because we really need to start
    looking at the model and the view we're going to render in, but please read the
    source code from GitHub and make the relevant JavaScript changes in this file
    so that you are using Bootstrap 4 in place of Bootstrap 3.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start writing the model part of our MVC code base. We will
    do this by writing the model that will send the request to the Discogs API and
    get and transform the results into something that can be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Discogs model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will remember that we added a registration for an `IDiscogsClient` model earlier
    on. We hadn''t actually added any code at that point, so our application would
    fail to compile. We are now going to create the interface and implementation.
    `IDiscogClient` is a model, so we are going to create it inside our model directory.
    To create the interface and model in Visual Studio, we need to right-click on
    the `Models` folder to bring up a context menu. Inside the menu, select Add >
    Class.... The following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9198f088-be82-4206-8dca-79a048b9574b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This brings up the following dialog, where we can create the class or associated
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ed01a66f-f3f1-4f3a-b827-7314dfbd50f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the sake of brevity, we can create both the interface and the class definition
    inside the same file. I''ve separated them out in the GitHub code, but there''s
    no need to do that for our classes here. First, we have the interface definition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The use of `Task<Results>` in our definition is similar to specifying a promise
    that returns a particular type in TypeScript. What we are saying here is that
    our method will run asynchronously and, at some point, it will return a `Results`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Results type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data that we get back from Discogs comes back as a hierarchy of fields.
    Ultimately, we want to have code in place that will convert and return the results,
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a888d2d8-cfc3-400b-af8a-9ae253f752e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Behind the scenes, we are going to convert the JSON result from our call into
    a set of types. The top-level type is the `Results` type, which we are going to
    return out of our `GetByArtist` call. This hierarchy is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b034ce2f-3325-4270-8b03-ccc4d47191f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to see what the mappings look like, we are going to build the `CommunityInfo`
    type from scratch. This class will be used in our `SearchResult` class to provide
    the community fields that we selected in the previous QuickWatch screenshot. Create
    a class called `CommunityInfo` and add the following line at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are adding this line because there are features from here that we want to
    use; specifically, we want to use `JsonProperty` to map the name of a C# property
    onto one that is present in the JSON result. We have two fields that `CommunityInfo`
    needs to return—one that identifies how many people `want` the music title, and
    another that identifies how many people `have` it. We are going to follow standard
    C# naming conventions and use Pascal casing for property names (this means that
    the first letter is capitalized). Since the property name uses Pascal casing,
    we are going to use the `JsonProperty` attribute to map that name to the appropriate
    REST property name, so the `Want` property will be mapped to `want` in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We aren't going to go through all the classes and properties. I would definitely
    recommend reading the GitHub code for more details, but this should definitely
    help to clarify what the project structure is.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our DiscogsClient class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we write our `DiscogsClient` class, we already have the contract that
    it will be based on, along with the interface definition. This tells us that our
    class starts off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The definition of our class looks slightly different to our interface because
    we didn't have to say that `GetByArtist` was `public` or that the method was `async`.
    When we use `async` in a method declaration, we are setting a compilation expectation
    that the method will have the `await` keyword inside it. This should be very familiar
    to us from our TypeScript use of `async`/`await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the Discogs API, it always starts off with the `https://api.discogs.com/` URL. In
    order to make life a little bit easier for us in our code base, we are going to
    define this as a constant in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class is going to talk to a REST endpoint. This means that we must be able
    to access HTTP from our code. In order to do this, our constructor will have a
    class that implements the `IHttpClientFactory` interface that''s been injected
    into it. The client factory will implement a pattern called the factory pattern
    to build an appropriate `HttpClient` instance for us to use when we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This rather strange-looking syntax in the constructor simply states that we
    are going to set the member variable with the HTTP client factory that we pass
    in. If the client factory is null, `??` means that the code falls through to the
    next statement, which will throw an exception stating that the argument is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does our `GetByArtist` method look like? The first thing we want to
    do is check whether or not we have passed an artist into the method. If we haven''t,
    then we''re going to return an empty `Results` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create our HTTP request, we need to build our request address up.
    While we are building our address, we are going to append the path from `GetByArtist`
    with the `BasePath` string we defined as a constant. Suppose we wanted to search
    for `Peter O''Hanlon` as the artist. We would build up our search string so that
    we would escape the text that the user has entered to prevent dangerous requests
    from being sent; therefore, we would end up building an HTTP request string that
    looks like that shown at [https://api.discogs.com/database/search?artist=Peter
    O%27Hanlon&per_page=10](https://api.discogs.com/database/search?artist=Peter%20O%27Hanlon&per_page=10).
    We have limited the number of results to 10 in order to keep well within the Discogs
    request limit. We start with the helper method that appends the two strings together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the helper in place, we can build up the `GET` request. As we discussed
    previously, we need to change the artist so that potentially dangerous search
    terms are sanitized. With `Uri.EscapeDataString`, we have replaced the apostrophe
    in my name with its equivalent ASCII value of `%27`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the request created, we need to add a couple of headers to it. We need
    to add an `Authorization` token and a `user-agent` because Discogs is expecting
    to receive them. The `Authorization` token takes the format of `Discogs token=<<token>>`,
    where `<<token>>` is the token we created earlier when we signed up. The `user-agent`
    just needs to be something meaningful, so we set it to `AdvancedTypeScript3Chapter10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of our puzzle is to use the factory to create `HttpClient`.
    When this has been created, we call `SendAsync` to send our request to the Discogs
    server. When this comes back, we read the `Content` response and when this comes
    back, we need to convert the type using `DeserializeObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we put this all together, our class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We mentioned that there was a rate limit. What does that actually mean, though?
  prefs: []
  type: TYPE_NORMAL
- en: Discogs rate limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discog limits the number of requests that can be issued from a single IP. For
    authenticated requests, Discog limits the rate of requests to 60 per minute. For
    unauthenticated requests, for most cases, the number of requests that can be sent
    is 25 per minute. The number of requests is monitored using a moving window.
  prefs: []
  type: TYPE_NORMAL
- en: We have our Discogs API model written; now, it's time for us to look at wiring
    our model to our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up our controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the power of dependency injection to pass the Discogs client
    model that we just wrote in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, when we were setting up the navigation, we set `asp-action`
    to `Index`. When we perform a search, our view is going to pass the search string
    over to `Index` and call the `GetByArtist` method. When we get the result of the
    search back, we set `ViewBag.Result` with the results list. Finally, we serve
    up `View`, which will be the `Index` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But what does our view look like? We now need to set up the `Index` view.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Index view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the top of the file, we set the `ViewData` to `Title`. We saw what this
    did back when we looked at `_Layout.cshtml`, but it''s worth repeating that the
    value that we set here is used to help build the title in our master layout page.
    When we run our application, this sets the title to `Home Page - AdvancedTypeScript
    3 - Discogs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The user interacts with our application through a search control. It''s time
    for us to add it in. We are going to add a `div` ID, which we will call `pageRoot`,
    that will contain a `form` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can see that we are using the full power of ASP.NET to our advantage
    here. Our form is MVC-aware, so we tell it that we are using `HomeController`
    (remembering the conventions for controllers) by using `asp-controller`. We set
    the action to `Index`, so we are going to call the same `Index` method that we
    do when we navigate to this page. The reason that we can do this is that we still
    want to show the current page when we have finished searching so that the user
    can search for a different artist if necessary. Our `Index` method is clever enough
    to know whether or not we have passed a search string to trigger the search, so
    when the user triggers a search inside our form, the search string will be provided
    and this will trigger the search itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the form, we need to add an input search field and a button that triggers
    the `submit` form when pressed. The class elements in here are just used to make
    our `button` and `input` fields into Bootstrap versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, this is what our search section looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to run the application right now, we would see the following. If
    we were to enter the details of an artist and press the Search button, the search
    would be triggered, but no data would be displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/526284b7-2120-4e9f-aecb-d84bc373a14e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have search results coming back, we need to get the result out
    of the `ViewBag` that we added our result to. It''s easy to become confused by `ViewBag`
    and `ViewData`, so it''s worth talking about these for a second as they both serve
    the same purpose of bidirectionally passing data between the controller and the
    view, only slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: When we added the results of the search, we set this as `ViewBag.Result`. If
    we were to take a look at the source code for `ViewBag`, though, we wouldn't actually
    find a property called **Result**. The reason for this is down to the fact that `ViewBag`
    is dynamic; in other words, it allows us to create arbitrary values that can be
    shared between the controller and the view, which can be called anything. In general,
    using `ViewBag` is a reasonable option, but since it is dynamic, it does not have
    the benefit of the compiler detecting whether or not there are errors, so it's
    vital that you make sure that the property you set in the controller is given
    exactly the same name as the property you set in the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewData`, however, relies on the use of a dictionary (similar to `map` in
    TypeScript), where we potentially have a number of key/value pairs holding the
    data. Internally, the value is an object, so this would have implications if we
    were setting the value in the view and passing it back to the controller as we
    would have to cast the object to the appropriate type. The effect of this is that
    setting `ViewBag.Counter = 1` in the view means that we could treat `ViewBag.Counter`
    as an integer directly in our controller, but setting `ViewData["Counter"] = 1`
    in the view means we would have to cast `ViewData["Counter"]` to an integer before
    we could do anything with it. The cast would look something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For our purposes, we could have used either approach because the responsibility
    for setting the result lies with our controller, but I''m happy going with `ViewBag`
    to set our result. So, how do we go about adding the data in? We know that our
    `Index` page is a `.cshtml` file, so we can mix C# and HTML together. The way
    we denote the C# section is to use `@{ }`, so in order to render out the results,
    we need to check that there is a value in `ViewBag.Result` (note that C# uses
    `!=`, instead of the JavaScript format of `!==`, to test that the result is not
    null). The code that we write to render our result out starts off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our result, we are going to create a Bootstrap table, with `Title` and
    `Artwork` as two columns. The HTML markup of the table that we''re going to build
    starts off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Inside our table body (`tbody`), we are going to have to loop over each item
    in our result and write the relevant value out. The first thing that we have to
    do is create a variable called `index`. We are going to put this in place now,
    in anticipation of the point where we need to add an image with a unique name
    (we'll cover that in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to use `foreach` to iterate over every item in `ViewBag.Result`.
    For each item, we are going to create a new table row using `<tr></tr>` and, inside
    the row, we will write out two table data cells (`<td></td>`) containing the title
    and the resource URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application now, we will get results back, and these results
    will be written to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d86fad7-40fa-4989-b355-9d11eec98f78.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, the artwork element is wrong. That's not a picture, so we need to
    put something in place to go off and retrieve the pictures themselves, which requires
    our code to make another REST call for each result. We want this to happen when
    the results have been returned, so we are going to turn to client-side functionality
    now when we see how we can leverage TypeScript to get the image results for us.
  prefs: []
  type: TYPE_NORMAL
- en: Adding TypeScript to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The starting point for our TypeScript—pretty much as always—is our `tsconfig.json`
    file. We are going to create this to be as slimline as possible. We are going
    to set this particular `outDir` here because the creation of our project set a
    number of files in `wwwroot`. In the `wwwroot/js` folder, ASP.NET has already
    created a `site.js` file, so we are going to target our script to live alongside
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use a single method to call the Discogs API to retrieve the
    relevant image. We aren't going to rely on any TypeScript packages loaded from
    an external source to make our API call because JavaScript provides us with the
    `fetch` API, which allows us to make REST calls without any dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by adding a file called `discogHelper.ts`, which will contain the
    function we are going to call from our ASP.NET application. The reason we are
    adding this as a TypeScript method is that we want this to run on the client,
    rather than on the server side. This decreases the time taken to get the initial
    results loaded onto the client screen because we are going to let the client fetch
    and asynchronously load the images for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of our function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `RequestInfo` parameter will accept the URL of the image request on the
    server. This follows the fact that Discog does not return full details about a
    particular music title, so the album artwork is not available at this point. Instead,
    it returns the REST call that we have to make to retrieve the full details, which
    we can then parse out to retrieve the artwork. For example, Steve Vai's Passion
    and Warfare album information returns the `ResourceUrl` of the [https://api.discogs.com/masters/44477](https://api.discogs.com/masters/44477) link.
    That becomes the URL that we pass in as our `request` to retrieve the full details,
    including the artwork.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter that we accept is the `id` of the `img` object. When we
    iterate over our initial search results to build the table of results, as well
    as add the album title, we also include a uniquely identified image, which we
    pass into our function. This allows us to dynamically update `src` when we have
    finished retrieving details about the album. Sometimes, this can lead to an amusing
    effect in the client because some albums take longer to retrieve than others,
    so it is entirely possible that the list of images updates out of sequence, meaning
    that later images are populated sooner than earlier ones. This is nothing to worry
    about because we are deliberately doing this to show that our client code is truly
    asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: If we really wanted to worry about making our images display sequentially, we
    would change our function to accept an array of requests and image placeholders,
    issue our calls, and only update the images once all the REST calls had finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, the `fetch` API uses a promise called `fetch` for us to make
    our call. This accepts the request and, optionally, a `RequestInit` object that
    allows us to pass custom settings to our call, including the HTTP verb we want
    to apply and any headers we want to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Guess what? We are using the same `authorization` and `user-agent` headers here
    that we set in the C# code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already said that the `fetch` API is promise-based, so we can rightly
    expect that the `fetch` call waits to complete before it returns the result. In
    order to get our image, we are going to perform a couple of transformations. The
    first transformation is to convert the response into a JSON representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion operation is asynchronous, so the next stage of our transformation
    can occur in its own `then` block as well. At this point, if all has gone well,
    we should have a response body. We retrieve the `HTMLImageElement` using the image
    ID that we passed into our function. If this is a valid image, then we set `src`
    to the first `uri150` result we get back, which gives us the address of the 150
    x 150 px image from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting this all together, our search function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Discogs allows us to issue JSONP requests, which means that we have to pass
    a callback query string parameter. In order to issue a JSONP request, we would
    have to install the Fetch JSONP package from [https://github.com/camsong/fetch-jsonp](https://github.com/camsong/fetch-jsonp).
    This requires changing the signature of the `fetch` call to `fetchJsonp` instead.
    Apart from that, the rest of our functions look the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, we should be comfortable with the use of `async`/`await` inside promises.
    If we wanted a slightly less verbose function, we could change the code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to address how we call our TypeScript functionality
    from ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Calling our TypeScript functionality from ASP.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to our ASP.NET code, we can now hook up the `searchDiscog` function
    for retrieving our images. The first thing we need to do is include the reference
    to the search script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now expand our image section to include the search
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting this all together, our `Index` page now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the application, both the title and the image will be returned
    after we have performed a search. Rerunning the same search now gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/949e84f9-4b2c-479f-8531-6cd20d4fe89c.png)'
  prefs: []
  type: TYPE_IMG
- en: And that's it. We have an ASP.NET Core MVC application that we can use to search
    for artists and retrieve titles and artwork. All of this was achieved using a
    combination of ASP.NET MVC, HTML, Bootstrap, C#, and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, our last chapter, we moved over to developing an application using
    ASP.NET Core, C#, and TypeScript. We took this opportunity to learn about what
    Visual Studio generates for us when it creates an ASP.NET Core web application.
    We discovered that ASP.NET Core emphasizes the use of the MVC pattern to help
    us segregate the responsibilities of our code. In order to build this application,
    we signed up to the Discogs site and registered a token to let us start retrieving
    artists' details using C#. From the artist results, we created some TypeScript
    functionality that called out to the same site to retrieve album artwork.
  prefs: []
  type: TYPE_NORMAL
- en: While building the application, we covered how to mix C# and HTML code in the
    same `.cshtml` file, which constitutes the view. We wrote our own model to perform
    the artist search and we looked at how to update the controller to tie the model
    and the view together.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed your journey with TypeScript and hope that we have enhanced
    your knowledge to the point where you want to use it more and more. TypeScript
    is a wonderful language and is always a joy to use, so please, go and have as
    much fun with it as I do. I look forward to seeing your work.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why does TypeScript look similar to C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What C# method starts our program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does ASP.NET Core differ from ASP.NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the rate limitations of Discog?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core is a huge topic and would take far more time to cover than we
    have in this short chapter. Bearing that in mind, I recommend the following books
    for you to continue your ASP.NET journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ASP.NET Core 2 Fundamentals* ([https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals)):
    Build cross-platform apps and dynamic web services with this server-side web application
    framework by Onur Gumus and Mugilan T. S. Ragupathi. ISBN: 978-1789538915'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering ASP.NET Core 2.0* ([https://www.packtpub.com/in/application-development/mastering-aspnet-core](https://www.packtpub.com/in/application-development/mastering-aspnet-core)):
    MVC patterns, configuration, routing, deployment, and more by Ricardo Peres. ISBN:
    978-1787283688'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Microservices with .NET Core 2.0* ([https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition)):
    Transitioning monolithic architectures using microservices with .NET Core 2.0
    using C# 7.0 by Gaurav Aroraa. ISBN: 978-1788393331'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning ASP.NET Core 2.0* ([https://www.packtpub.com/application-development/learning-aspnet-core-20](https://www.packtpub.com/application-development/learning-aspnet-core-20)):
    Build modern web apps with ASP.NET Core 2.0, MVC, and EF Core 2 by Jason De Oliveira
    and Michel Bruchet. ISBN: 978-1788476638'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
