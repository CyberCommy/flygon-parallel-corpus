- en: Let Us Begin Our Automation Journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing third-party packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating strings with formatted values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from structured strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a third-party tool—parse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going deeper into regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this chapter is to lay down some of the basic techniques that
    will be useful through this book. The main idea is to be able to create a good
    Python environment to run the automation tasks that will follow, and be able to
    parse text inputs into structured data.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a good amount of tools installed by default, but it also makes it
    easy to install third-party tools that can simplify common operations when processing
    texts. In this chapter, we'll see how to import modules from external sources
    and use them to leverage the full potential of Python.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to structure input data is critical in any automation task. Most
    of the data that we will process in this book will come from unformatted sources
    such as web pages or text files. As the old computer adage says, *garbage in,
    garbage out*, making the sanitizing of inputs a very important task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a first step when working with Python, it is a good practice to explicitly define the
    working environment. This helps with detaching from the operative system interpreter
    and environment, and properly defining the dependencies that will be used. Not
    doing so tends to generate chaotic scenarios. Remember, *explicit is better than
    implicit!*
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially important in two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with multiple projects on the same computer, as they can have different
    dependencies that clash at some point. For example, two versions of the same module
    cannot be installed in the same environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working on a project that will be used on a different computer, for example,
    developing some code in a personal laptop that will ultimately run in a remote
    server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common joke among developers is responding to a bug with *it runs on my machine*, meaning
    that it appears to work on their laptop, but not on the production servers. Although
    a huge number of factors can produce this error, a good practice is to produce
    an automatically replicable environment, reducing uncertainty over what dependencies
    are really being used.
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to achieve using the `virtualenv` module, which sets up a virtual
    environment, so none of the installed dependencies will be shared with the Python
    version installed on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: In Python3, the `virtualenv` tool is installed automatically, which was not
    the case in previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new virtual environment, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the main directory that contains the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This creates a subdirectory called `.venv` that contains the virtual environment.The
    directory containing the virtual environment can be located anywhere. Keeping
    it on the same root keeps it handy, and adding a dot in front of it avoids it
    being displayed when running `ls` or other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before activating the virtual environment, check the version installed in `pip`.
    This is different depending on your operative system, for example, 9.0.3 for MacOS
    High Sierra 10.13.4\. It will be upgraded later. Also check the referenced Python
    interpreter, which will be the main operating system one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, your virtual environment is ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activate the virtual environment by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the prompt will display `(.venv)`, showing that the virtual
    environment is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the Python interpreter used is the one inside the virtual environment,
    and not the general operative system one from step 3 of *Getting ready*. Checking
    the location within a virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade the version of `pip` and check the version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Get out of the environment and run `pip` to check the version, which will return
    the previous environment. Check the `pip` version and the Python interpreter to
    show the ones before activating the virtual environment ones, as shown in step
    3 of the *Getting ready* section. Note that they are different pip versions!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that inside the virtual environment you can use `python` instead of `python3`,
    although `python3` is available as well. This will use the Python interpreter
    defined in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: In some systems like Linux, it's possible that you need to use `python3.7` instead
    of `python3`. Verify that the Python interpreter you're using is 3.7 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the virtual environment, step 3 of the *How to do it...* section installs
    the most recent version of `pip`, without affecting the external installation.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual environment contains all the Python data in the `.venv` directory,
    and the `activate` script points all the environment variables there. The best
    thing about it is that it can be deleted and recreated very easily, removing the
    fear of experimenting in a self-contained sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the directory name is displayed in the prompt. If you need to
    differentiate the environment, use a descriptive directory name, such as `.my_automate_recipe`, or
    use the `--prompt` option.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove a virtual environment, deactivate it and remove the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `venv` module has more options, which can be shown with the `-h` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A convenient way of dealing with virtual environments, especially if you often have
    to swap between them, is using the  `virtualenvwrapper` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following variables to your sheet startup script, these normally
    being `.bashrc` or `.bash_profile`. The virtual environments will be installed
    under the `WORKON_HOME` directory instead of the same directory as the project,
    as shown previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Sourcing the startup script or opening a new Terminal will allow you to create
    new virtual environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For more information, check the documentation of `virtualenvwrapper` at: [https://virtualenvwrapper.readthedocs.io/en/latest/index.html](https://virtualenvwrapper.readthedocs.io/en/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the *Tab* key after `workon` autocompletes with the available environments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Installing third-party packages* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing third-party packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strongest capabilities of Python is the ability to use an impressive
    catalog of third-party packages that cover an amazing amount of ground in different
    areas, from modules specialized in performing numerical operations, machine learning,
    and network communications, to command-line convenience tools, database access,
    image processing, and much more!
  prefs: []
  type: TYPE_NORMAL
- en: Most of them are available on the official Python Package Index ([https://pypi.org/](https://pypi.org/)),
    which has more than 130,000 packages ready to use. In this book, we'll install
    some of them, and in general spending a little time researching external tools
    when trying to solve a problem is time well spent. It's very likely that someone
    else has created a tool that solves all, or at least part, of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: As important as finding and installing a package is keeping track of which packages
    are being used. This greatly helps with **replicability**, meaning the ability
    to start the whole environment from scratch in any situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point is to find a package that will be of use in our project.
  prefs: []
  type: TYPE_NORMAL
- en: A great one is `requests`, a module that deals with HTTP requests and is known
    for its easy and intuitive interface, as well as its great documentation. Take
    a look at the documentation, which can be found here: [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll use `requests` throughout this book when dealing with HTTP connections.
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be to choose the version to use. In this case, the latest
    (2.18.4, at the time of writing) will be perfect. If the version of the module
    is not specified, by default, it will install the latest version, which can lead
    to inconsistencies in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also use the great `delorean` module for time handling (version 1.0.0 [http://delorean.readthedocs.io/en/latest/](http://delorean.readthedocs.io/en/latest/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `requirements.txt` file in our main directory, which will specify
    all the requirements for our project. Let''s start with `delorean` and `requests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Install all the requirements with the `pip` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use both modules when using the virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `requirements.txt` file specifies the module and version, and `pip` performs
    a search on [pypi.org](http://pypi.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a new virtual environment from scratch and running the following will
    completely recreate your environment, which makes replicability very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that step 2 of the *How to do it...* section automatically installs other
    modules that are dependencies, such as `urllib3`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If any of the modules need to be changed to a different version because a new
    version is available, change it using requirements and run the `install` command
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is also applicable when a new module needs to be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point, the `freeze` command can be used to display all installed modules.
    `freeze` returns the modules in a format compatible with `requirements.txt`, making
    it possible to do this to generate a file with our current environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will include dependencies, so expect a lot more modules in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Finding great third-party modules is not easy sometimes. Searching for specific
    functionality can work well, but sometimes there are great modules that are a
    surprise because they do things you never thought of. A great curated list is
    **Awesome Python** ([https://awesome-python.com/](https://awesome-python.com/)),
    which covers a lot of great tools for common Python use cases, such as cryptography,
    database access, date and time handling, and  so on.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, installing packages may require additional tools, such as compilers
    or a specific library that supports some functionality (for example, a particular
    database driver). If that's the case, the documentation will normally explain
    the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating strings with formatted values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the basic abilities when dealing with creating text and documents is
    to be able to properly format the values into structured strings. Python is quite
    smart in presenting good defaults, such as properly rendering a number, but there
    are a lot of options and possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss some of the common options when creating formatted text with the
    example of a table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main tool to format strings in Python is the `format` method. It works
    with a defined mini-language to render variables this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `template` is a string that gets interpreted based on the mini-language.
    At its easiest, it replaces the values between curly brackets with the parameters.
    Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In 95% of cases, this formatting will be all that's required; keeping things
    simple is great! But for complicated times, such as when aligning the strings
    automatically and creating good looking text tables, the mini-language format has
    more options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write the following script, `recipe_format_strings_step1.py`, to  print an
    aligned table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it to display the following aligned table. Note that `PERCENT` is correctly
    displayed as a percentage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TEMPLATE` constant contains three columns, each one properly named (`REVENUE`,
    `PROFIT`, `PERCENT`). This makes it more explicit and straightforward to apply
    the template on the format call.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the name of the parameter, there''s a colon that separates the format
    definition. Note that all inside the curly brackets. In all columns, the format
    specification sets the width to seven characters and aligns the values to the
    right with the `>` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: Revenue adds a thousands separator with the `,` symbol—`[{revenue:>7,}]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profit adds a `+` sign for positive values. A `-` for negatives is added automatically—`[{profit:>+7}]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Percent displays a percent value, with a precision of two decimal places—`[{percent:>7.2%}]`.
    This is done through 0.2 (precision) and adding a `%` symbol for the percentage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have also seen the available Python formatting with the `%` operator.
    While it works for simple formatting, it is less flexible than the formated mini-language,
    and it is not recommended for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great new feature since Python 3.6 is to use f-strings, which perform a format
    action using defined variables this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This simplifies a lot of the code and allows us to create very descriptive and
    readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when using f-strings to ensure that the string is replaced at the
    proper time. A common problem is that the variable defined to be rendered is not
    yet defined. For example, `TEMPLATE`, defined previously, won't be defined as
    an f-string, as `revenue` and the rest of the parameters are not available at
    that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to write a curly bracket, you''ll need to repeat it twice. Note
    that each duplication will be displayed as a single curly bracket, plus a curly
    bracket for the value replacement, making a total of three brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to create meta templates—templates that produce templates. In
    some cases, that will be useful, but try to limit their use, as they'll get complicated
    very quickly, producing code that will be difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Format Specification mini-language has more options than the ones
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: As the language tries to be quite concise, sometimes it can be difficult to
    determine the position of the symbols. You may sometimes ask yourself questions
    like—*Is the `+` symbol before or after than the width parameters.?* Read the
    documentation with care and remember to always include a colon before the format
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: Please check the full documentation and examples on the Python website ([https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Template Reports* recipe in [Chapter 5](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml),
    *Generating Fantastic Reports*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Manipulating strings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic ability when dealing with text is to be able to properly manipulate
    that text. That means to be able to join it, split it into regular chunks, or
    change it to be uppercase or lowercase. We'll discuss more advanced methods for
    parsing text and separating it later, but in lots of cases it is useful to divide
    a paragraph into lines, sentences, or even words. Other times, words will have
    to have some characters removed or replaced with a canonical version to be able
    to compare it with a determined value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll define a basic text to transform it into its main components, and then
    we'll reconstruct it. As an example, a report needs to be transformed into a new
    format to be sent via email.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input format we''ll use in this example will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We need to redact the text to eliminate any references to numbers. It needs
    to be properly formatted by adding a new line after each period, justified with
    80 characters, and transformed into ASCII for compatibility reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The text will be stored in the `INPUT_TEXT` variable in the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After entering the text, split it into individual words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace any numerical digits with an `''X''` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the text into pure ASCII (note that the name of the company contains
    a letter, `ñ`, which is not ASCII):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Group the words into 80-character lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Format all lines as titles and join them as a single piece of text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the steps performs a specific transformation of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one splits the text on the default separators, whitespaces, and new
    lines. This splits it into individual words with no lines or multiple spaces for
    separation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To replace the digits, we go through every character of each word. For each
    one, if it's a digit, an `'X'` is returned instead. This is done with two list
    comprehensions, one to run on the list, and another on each word, replacing only
    if there's a digit—`['X' if w.isdigit() else w for w in word]`. Note that the
    words are joined together again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the words is encoded into an ASCII byte sequence and decoded back again
    into the Python string type. Note the use of the `errors` parameter to force the
    replacement of unknown characters such as `ñ`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between strings and bytes is not very intuitive at first, especially
    if you never have to worry about multiple languages or encoding transformation. In
    Python 3, there's a strong separation between strings (internal Python representation)
    and bytes, so most of the tools applicable to strings won't be available in byte
    objects. Unless you have a good idea of why you need a byte object, always work with
    Python strings. If you need to perform transformations like the one in this task,
    encode and decode in the same line so that you keep your objects in the comfortable realm
    of Python strings. If you are interested in learning more about encodings, you
    can check out this brief article ([https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3](https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3))
    and this other longer and more detailed one ([http://www.diveintopython3.net/strings.html](http://www.diveintopython3.net/strings.html)).
  prefs: []
  type: TYPE_NORMAL
- en: This step first adds an extra newline character (the `\n` character) for all
    words ending with a period. This marks the different paragraphs. After that, it
    creates a line and adds the words one by one. If an extra word will make it go
    over 80 characters, it finishes the line and starts a new one. If the line already
    ends with a new line, it finishes it and starts another one as well. Note that
    there's an extra space added to separate the words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, each of the lines is capitalized as a Title (the first letter of each
    word is upper cased) and all the lines are joined through new lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some other useful operations that can be performed on strings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings can be sliced like any other list. This means that `'word'[0:2]` will
    return `'wo'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.splitlines()` to separate lines by newline character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are `.upper()` and `.lower()` methods, which return a copy with all the
    characters set to uppercase or lowercase. Their use is very similar to `.title()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For easy replacements (for example, change all `A` to `B` or change `mine` to
    `ours`), use `.replace()`. This method is useful for very simple cases, but replacements
    can get tricky easily. Be careful with the order of replacements to avoid collisions
    and case sensitivity issues. Note the wrong replacement in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the issues we'll see with regular expressions matching unexpected
    parts of your code.
  prefs: []
  type: TYPE_NORMAL
- en: There are more examples to follow later. Refer to the regular expressions recipes
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with multiple languages, or with any kind of non-English input,
    it is very useful to learn the basics of Unicode and encodings. In a nutshell,
    given the vast amount of characters in all the different languages in the world,
    including alphabets not related to the Latin one, such as Chinese or Arabic, there's
    a standard to try and cover all of them so that computers can properly understand
    them. Python 3 greatly improved this situation, making the strings internal objects
    to deal with all of those characters. The encoding that Python uses, and the most
    common and compatible one, is currently UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good article to learn about the basics of UTF-8 is this blog post: ([https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with encodings is still relevant when reading from external files that
    can be encoded in different encodings (for example, CP-1252 or windows-1252, which
    is a common encoding produced by legacy Microsoft systems, or ISO 8859-15, which
    is the industry standard).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating strings with formatted values* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Going deeper into regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Dealing with Encodings* recipe in [Chapter 4](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Searching and Reading Local Files*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from structured strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of automated tasks, we'll need to treat input text that's in a particular
    format and extract the relevant information. For example, a spreadsheet may define
    a percentage in text (such as 37.4%) that we want to retrieve in numerical format
    to apply it later (0.374, as a float).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to process sale logs that contain inline information
    about a product, such as sold, price, profit, and some other information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that we need to parse information stored in sales logs. We''ll use
    a sales log with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, a specific log may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the price has a leading zero. All prices will have two digits for
    the dollars, and two for the cents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to activate our virtual environment before we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Python interpreter, make the following imports. Remember to activate
    your `virtualenv`,  as described in the *Creating a virtual environment* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the log to parse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Split the log into its parts, which are divided by ` -`  (note the space before
    and after the dash). We ignore the `SALE` part as it doesn''t add any relevant
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the `timestamp` into a datetime object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the `product_id` into a integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the price into a `Decimal` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have all the values in native Python formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic working of this is to isolate each of the elements and then parse
    them in to the proper type. The first step is to split the full log into smaller
    parts. The `-` string is a good divider, as it splits it into four parts—a timestamp
    one, one with just the word `SALE`, the product, and the price.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the timestamp, we need to isolate the ISO format, which is in
    brackets in the log. That's why it's stripped off the brackets. We use the `delorean` module (introduced
    earlier) to parse it in to a `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: The word `SALE` is ignored. There's no relevant information there.
  prefs: []
  type: TYPE_NORMAL
- en: 'To isolate the product ID, we split the product part at the colon. Then, we
    parse the last element as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To divide the price, we use the dollar sign as a separator, and parse it as
    a `Decimal` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As described in the next section, do not parse this value into a float type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These log elements can be combined together into a single object, helping with
    parsing and aggregating them. For example, we could define a class in Python code
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the parsing can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Avoid using float types for prices. Floats numbers have precision problems
    that may produce strange errors when aggregating multiple prices, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Try these two options to avoid problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use integer cents as the base unit**: This means multiplying currency inputs
    by 100 and transforming them into integers (or whatever fractional unit is correct
    for the currency used). You may still want to change the base when displaying
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parse into the Decimal type**: The `Decimal` type keeps the fixed precision
    and works as you''d expect. You can find further information about the `Decimal`
    type in the Python docs at [https://docs.python.org/3.6/library/decimal.html](https://docs.python.org/3.6/library/decimal.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use the `Decimal` type, parse the results directly into `Decimal` from
    the string. If transforming it first into a float, you can carry the precision
    errors to the new type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Going deeper into regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a third-party tool—parse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While manually parsing data, as seen in the previous recipe, works very well
    for small strings, it can be very laborious to tweak the exact formula to work
    with a variety of input. What if the input has an extra dash sometimes? Or it
    has a variable length header depending on the size of one of the fields?
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced option is to use regular expressions, as we'll see in the next
    recipe. But there's a great module in Python called `parse` ([https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse))
    that allows us to reverse format strings. It is a fantastic tool, that's powerful,
    easy to use, and greatly improves the readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add the parse module to the `requirements.txt` file in our virtual environment
    and reinstall the dependencies, as shown in the *Creating a virtual environment* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requirements.txt` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, reinstall the modules in the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `parse` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the log to parse, in the same format as in the *Extracting data from
    structured strings* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Analyze it and describe it as you''ll do when trying to print it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `parse` and check the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the results are all strings. Define the types to be parsed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse once again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a custom type for the price to avoid issues with the float type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `parse` module allows us to define a format, such as string, that reverses
    the format method when parsing values. A lot of the concepts that we discussed
    when creating strings applies here—put values in brackets, define the type after
    a colon, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: By default, as seen in step 4, the values are parsed as strings. This is a good
    starting point when analyzing text. The values can be parsed into more useful
    native types, as shown in steps 5 and 6 in the *How to do it...* section. Please
    note that while most of the parsing types are the same as the ones in the Python
    Format Specification mini-language, there are some others available, such as `ti`
    for timestamps in ISO format.
  prefs: []
  type: TYPE_NORMAL
- en: If native types are not enough, our own parsing can be defined, as demonstrated
    in step 7 in the *How to do it...* section. Note that the definition of the price
    function gets a string and returns the proper format, in this case a `Decimal`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: All the issues about floats and price information described in the *There's
    more* section of the *Extracting data from structured strings* recipe apply here
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The timestamp can also be translated into a `delorean` object for consistency.
    Also, `delorean` objects carry over timezone information. Adding the same structure
    as in the previous recipe gives the following object, which is capable of parsing
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'So, parsing it returns similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This code is contained in the GitHub file `Chapter01/price_log.py`.
  prefs: []
  type: TYPE_NORMAL
- en: All `parse` supported types can be found in the documentation at [https://github.com/r1chardj0n3s/parse#format-specification](https://github.com/r1chardj0n3s/parse#format-specification).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Extracting data from structured strings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Going deeper into regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **regular expression**, or **regex**, is a pattern to *match* text. In other
    words, it allows us to define an **abstract string** (typically the definition
    of a structured kind of text) to check with other strings to see if they match
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: It is better to describe them with an example. Think of defining a pattern of
    text as *a word that starts with an uppercase A and contains only lowercase Ns
    and As after that*. The word *Anna* matches it, but *Bob*, *Alice*, and *James *does
    not. The words *Aaan*, *Ana*, *Annnn*, and *Aaaan* will also be matches, but *ANNA* won't.
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds complicated, that's because it is. Regexes can be notoriously
    complicated because they may be incredibly intricate and difficult to follow.
    But they are very useful, because they allow us to perform incredibly powerful
    pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common uses of regexes are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating input data**: For example, that a phone number is only numbers,
    dashes, and brackets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String parsing**: Retrieve data from structured strings, such as logs or
    URLs. This is similar to what''s described in the previous recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scrapping**: Find the occurrences of something in a long text. For example,
    find all emails in a web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replacement**: Find and replace a word or words with others. For example,
    replace *the owner* with *John Smith*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Some people, when confronted with a problem, think "I know, I''ll use regular
    expressions." Now they have two problems."'
  prefs: []
  type: TYPE_NORMAL
- en: – Jamie Zawinski
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are at their best when they are kept very simple. In general,
    if there is a specific tool to do it, prefer it over regexes. A very clear example
    of this is HTML parsing; check [Chapter 3](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml),
    *Building Your First Web Scraping Application,* for better tools to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Some text editors allow us to search using regexes as well. While most are editors
    aimed at writing code, such as Vim, BBEdit, or Notepad++, they're also present
    in more general tools, such as MS Office, Open Office, or Google Documents. But
    be careful, as the particular syntax may be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `python` module to deal with regexes is called `re`. The main function we'll
    cover is `re.search()`, which returns a *match *object with information about
    what matched the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As regex patterns are also defined as strings, we'll differentiate them by prefixing
    them with an *r*, such as `r'pattern'`. This is the Python way of labeling a text
    as raw string literals, meaning that the string within is taken literally, without
    any escaping. This means that a `\` is used as a backslash instead of a sequence.
    For example, without the r prefix, `\n` means newline character.
  prefs: []
  type: TYPE_NORMAL
- en: Some characters are special, and refer to concepts such as *the end of the string*,
    *any digit*, *any character*, *any whitespace character*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form is just a literal string. For example, the regex pattern
    `r''LOG''` matches the string `''LOGS''`, but not the string `''NOT A MATCH''`.
    If there''s not a match, search returns `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `re` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, match a pattern that is not at the start of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Match a pattern that is only at the start of the string. Note the `^` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Match a pattern only at the end of the string. Note the `$` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Match the word `''thing''` (not excluding `things`), but not `something` or
    `anything`. Note the `\b` at the start of the second pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Match a pattern that''s only numbers and dashes (for example, a phone number).
    Retrieve the matched string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Match an email address naively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `re.search` function matches a pattern, no matter its position in the string.
    As explained previously, this will return `None` if the pattern is not found,
    or a `match` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following special characters are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Marks the start of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Marks the end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b`: Marks the start or end of a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S`: Marks any character that''s not a whitespace, including special characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More special characters are shown in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6 in the *How to do it...* section, the `r'[0123456789-]+'` pattern is
    composed of two parts. The first one is between square brackets, and matches any
    single character between `0` and `9` (any number) and the dash (`-`) character.
    The `+` sign after that means that this character can be present one or more times.
    This is called a **quantifier** in regexes. This makes a match on any combination
    of numbers and dashes, no matter how long it is.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 again uses the `+` sign to match as many characters as necessary before
    the `@` and again after it. In this case, the character match is `\S`, which matches
    any non-whitespace character.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the naive pattern for emails described here is *very* naive,
    as it will match invalid emails such as `john@smith@test.com`. A better regex
    for most uses is `r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"`. You
    can go to [http://emailregex.com/](http://emailregex.com/) for find it and links
    to more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note that parsing a valid email including corner cases is actually a difficult
    and challenging problem. The previous regex should be fine for most uses covered
    in this book, but in a general framework project such as Django, email validation
    is a very long and very unreadable regex.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting matching object returns the position where the matched pattern
    starts and ends (using the `start` and `end` methods), as shown in step 5, which
    splits the string into matched parts, showing the distinction between the two
    matching patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The difference displayed in step 5 is a very common one. Trying to capture GP
    can end up capturing eg**gp**lant and ba**gp**ipe! Similarly, `things\b` won't
    capture things. Be sure to test and make the proper adjustments, such as capturing
    `\bGP\b` for just the word GP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific matched pattern can be retrieved by calling `group()`, as shown
    in step 6\. Note that the result will always be a string. It can be further processed
    using any of the methods that we''ve previously seen, such as by splitting the
    phone number into groups by dashes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with regexes can be difficult and complex. Please allow time to test
    your matches and be sure that they work as you expect in order to avoid nasty
    surprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check your regexes interactively with some tools. A good one that''s
    freely available online is [https://regex101.com/](https://regex101.com/), which
    displays each of the elements and explains the regex. Double-check that you''re
    using the Python flavor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c4e482e-ec3f-4e68-b39b-b58feebb6c34.png)'
  prefs: []
  type: TYPE_IMG
- en: See that the EXPLANATION describes that `\b` matches a word boundary (start
    or end of a word), and that *thing* matches literally these characters.
  prefs: []
  type: TYPE_NORMAL
- en: Regexes, in some cases, can be very slow, or even produce what's called **regex
    denial-of-service**, a string created to confuse a particular regex so that it
    takes an enormous amount of time, even in the worst case blocking the computer.
    While automating tasks probably won't get you into those problems, keep an eye
    out in case a regex takes too long.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Extracting data from structured strings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Going deeper into regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going deeper into regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll see more about how to deal with regular expressions. After
    introducing the basics, we will dig a little deeper into pattern elements, introduce
    groups as a better way to retrieve and parse strings, see how to search for multiple
    occurrences of the same string, and deal with longer texts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import `re`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Match a phone pattern as part of a group (in brackets). Note the use of `\d`
    as a special character for *any digit*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile a pattern and capture a case insensitive pattern with a `yes|no` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Match all the occurrences of cities and state abbreviations in the text. Note
    that they are separated by a single character and the name of the city always
    starts with an uppercase letter. Only four states are matched for simplicity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new special characters that were introduced are as follows. Note that the
    same letter in uppercase or lowercase means the opposite match, for example `\d`
    matches a digit, while `\D` matches a non digit.:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\d`: Marks any digit (0 to 9).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s`: Marks any character that''s a whitespace, including tabs and other whitespace
    special characters. Note that this is the reverse of `\S`, introduced in the previous
    recipe**.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w`: Marks any letter (includes digits, but excludes characters such as periods).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.`: Marks any character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To define groups, put the defined groups in brackets. Groups can be retrieved
    individually, making them perfect for matching a bigger pattern that contains
    a variable part that we''ll treat later, as demonstrated in step 2\. Note the
    difference with the step 6 pattern in the previous recipe. In this case, the pattern
    is not only the number, but includes the prefix, even if we then extract the number.
    Check out this difference, where there''s a number that''s not the number we want
    to capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Remember that group 0 (`.group()` or  `.group(0)`) is always the whole match.
    The rest of the groups are ordered as they appear.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns can be compiled as well. This saves some time if the pattern needs
    to be matched over and over. To use it that way, compile the pattern and then
    use that object to perform searches, as shown in steps 3 and 4\. Some extra flags
    can be added, such as making the pattern case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4's pattern requires a little bit of information. It's composed of two
    groups, separated by a single character. The special character `.` means it matches
    everything, in our example a period, a whitespace, and a comma. The second group
    is a straightforward selection of defined options, in this case US state abbreviations.
  prefs: []
  type: TYPE_NORMAL
- en: The first group starts with an uppercase letter (`[A-Z]`), and accepts any combination
    of letters or spaces (`[\w\s]+`), but not punctuation marks such as periods or
    commas. This matches the cities, including when composed of more than one word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this pattern starts on any uppercase letter and keeps matching until
    finding a state, unless separated by a punctuation mark, which may not be what''s
    expected, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4 also shows how to find more than one occurrence in a long text. While
    the `.findall()` method exists, it doesn''t return the full match object, while
    `.findalliter()` does. Commonplace now in Python 3, `.findalliter()` returns an
    iterator that can be used in a for loop or list comprehension. Note that `.search()` returns
    only the first occurrence of the pattern, even if more matches appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The special characters can be reversed if they are case swapped. For example,
    the reverse of the ones we used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\D`: Marks any non-digit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\W`: Marks any non-letter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\B`: Marks any character that''s not at the start or end of a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most commonly used special characters are typically `\d` (digits) and `\w`
    (letters and digits), as they mark common patterns to search for, and the plus
    sign for one or more.
  prefs: []
  type: TYPE_NORMAL
- en: Groups can be assigned names as well. This makes them more explicit at the expense
    of making the group more verbose in the following shape—`(?P<groupname>PATTERN)`.
    Groups can be referred to by name with `.group(groupname)` or by calling `.groupdict()` while
    maintaining its numeric position.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the step 4 pattern can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are a very extensive topic. There are whole technical books
    devoted to them and they can be notoriously deep. The Python documentation is
    good to be used as reference ([https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html))
    and to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel a little intimidated at the start, it's a perfectly natural feeling. Analyze
    each of the patterns with care, dividing it into different parts, and they will
    start to make sense. Don't be afraid to run a regex interactive analyzer!
  prefs: []
  type: TYPE_NORMAL
- en: Regexes can be really powerful and generic, but they may not be the proper tool
    for what you are trying to achieve. We've seen some caveats and patterns that
    have subtleties. As a rule of thumb, if a pattern starts to feel complicated,
    it's time to search for a different tool. Remember the previous recipes as well
    and the options they presented, such as `parse`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a third-party tool—parse* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of tasks can be best structured as a command-line interface that accepts
    different parameters to change the way it works, for example, scrapping one web
    page or another. Python includes a powerful `argparse` module in the standard
    library to create rich command-line argument parsing with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic use of `argparse` in a script can be shown in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the arguments that your script is going to accept, generating a new parser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the defined parser, returning an object with all the resulting arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the arguments to call the entry point of your script, which will apply the
    defined behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to use the following general structure for your scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function makes it easy to know what the entry point for the code
    is. The section under the `if` statement is only executed if the file is called
    directly, but not if it's imported. We'll follow this for all the steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script that will accept a single integer as a positional argument,
    and will print a hash symbol that amount of times. The `recipe_cli_step1.py` script
    is as follows, but note we are following the structure presented previously, and
    the `main` function is just printing the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the script and see how the parameter is presented. Calling the script
    with no arguments displays the automatic help. Use the automatic argument `-h`
    to display the extended help:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the script with the extra parameters works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the script to accept an optional argument for the character to print.
    The default will be `''#''`. The `recipe_cli_step2.py ` script will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The help is updated, and using the `-c` flag allows us to print different characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a flag that changes the behavior when present. The `recipe_cli_step3.py`
    script is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling it uppercases the character if the `-U` flag is added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in step 1 in the *How to do it…* section, the arguments are added
    to the parser through `.add_arguments`. Once all arguments are defined, calling
    `parse_args()` returns an object that contains the results (or exits if there's
    an error).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each argument should add a help description, but their behavior can change
    greatly:'
  prefs: []
  type: TYPE_NORMAL
- en: If an argument starts with a `-`, it is considered an optional parameter, like
    the `-c` argument in step 4\. If not, it's a positional argument, like the `number` argument
    in step 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For clarity, always define a default value for optional parameters. It will
    be `None` if you don't, but this may be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to always add a help parameter with a description of the parameter;
    help is automatically generated, as shown in step 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a type is present, it will be validated, for example, `number` in step 3\.
    By default, the type will be string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actions `store_true` and `store_false` can be used to generate flags, arguments
    that don't require any extra parameters. Set the corresponding default value as
    the opposite Boolean. This is demonstrated in the `U` argument in steps 6 and
    7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the property in the `args` object will be, by default, the name
    of the argument (without the dash, if it's present). You can change it with `dest`.
    For example, in step 6, the command-line argument `-U` is described as `uppercase`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the name of an argument for internal usage is very useful when using
    short arguments, such as single letters. A good command-line interface will use
    `-c`, but internally it's probably a good idea to use a more verbose label, such
    as `configuration_file`. Explicit is better than implicit!
  prefs: []
  type: TYPE_NORMAL
- en: Some arguments can work in coordination with others, as shown in step 3\. Perform
    all required operations to pass the main function as clear and concise parameters.
    For example, in step 3, only two parameters are passed, but one may have been
    modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create long arguments as well with double dashes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This will accept both `-v` and `--verbose`, and it will store the name `verbose`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding long names is a good way of making the interface more intuitive and easy
    to remember. It's easy to remember after a couple of times that there's a verbose
    option, and it starts with a `v`.
  prefs: []
  type: TYPE_NORMAL
- en: The main inconvenience when dealing with command-line arguments may be ending
    up with too many of them. This creates confusion. Try to make your arguments as
    independent as possible and not make too many dependencies between them, or handling
    the combinations can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, try to not create more than a couple of positional arguments,
    as they won't have mnemonics. Positional arguments also accept default values,
    but most of the time that won't be the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced details, check the Python documentation of `argparse` ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a virtual environment* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing third-party packages* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
