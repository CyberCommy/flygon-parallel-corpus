- en: Using SVG in HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this book, you''ve been exposed to the fundamental building blocks
    of SVG: the features and functionality that are defined in the SVG specification
    itself. While SVG can, and does, live on its own, it really shines when it''s
    unleashed on the modern web. The web now is a multiple-device, multiple form-factor,
    and multiple connection speed environment, and SVG helps to solve many thorny
    problems facing the modern web developer. To that end, the next few chapters will
    focus on integrating SVG with other core technologies: HTML, CSS, and JavaScript.
    This chapter is very much straightforward and focuses on working with SVG inside
    the context of an HTML document. Everything on the web starts with HTML, so making
    sure your SVG is happy inside your HTML is the way to go.'
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned about the basics of inserting SVG into your HTML documents
    as images or inline SVG elements in [Chapter 1](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit),
    *Introducing Scalable Vector Graphics*. This chapter adds some details on top
    of that foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SVG and accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of using SVG images for responsive web design and as part of a
    responsive images solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about working with inline SVG in the context of an HTML document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: SVG, HTML, and accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessibility on the web strives to ensure that people with disabilities can
    access sites and applications. The general goal is to provide content that is
    served and structured in such a way that users with disabilities can access it
    directly or, if direct access isn't possible because of their disability (for
    example, audio content is needed for a hearing-impaired user), to provide properly
    structured alternative content that conveys the same information. This structured
    alternative content can then be accessed through **Assistive Technology** (**AT**).
    The most common example of AT is the *screen reader. *
  prefs: []
  type: TYPE_NORMAL
- en: 'Screen readers exist for all platforms. Some free applications you can test
    with include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: NVDA (Windows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple VoiceOver (OS X)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orca (Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of SVG, a visual format, the focus is on providing, *when it's appropriate*,
    textual content that describes the image.
  prefs: []
  type: TYPE_NORMAL
- en: As you're hopefully aware, HTML itself has tools and best practices for accessibility.
    In addition to those in HTML, there is also a set of technologies called **Accessible
    Rich Internet Applications** (**ARIA)**, which defines ways to make the web and
    web applications more accessible to people with disabilities. ARIA provides a
    set of special accessibility attributes that, when added to HTML, provide accessibility
    information about the page or application. For example, the `role` attribute defines
    the *type* of object the element is (article, menu, or image).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*, there are two common ways to get your SVG into your
    HTML document: as the `src` of an image and as an inline SVG element (or elements).
    This section will add some notes about working with SVG, HTML, and ARIA attributes
    to ensure that your content is still accessible using both techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: SVG as an image src
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to get SVG into a document is as the `src` of an `img` element.
    Doing so, as we saw in [Chapter 1](3f798c1a-7805-4b48-9ae2-0ee4a1e09a38.xhtml), *Introducing
    Scalable Vector Graphics*, is as simple as referencing the `*.svg` element the
    same way you would reference any image as the `src` attribute on an `img` element.
  prefs: []
  type: TYPE_NORMAL
- en: As for accessibility, if you follow best practices with regards to accessibility
    and images, you can continue to do the same with SVG images. The `alt` attribute
    should be there and, if it's needed for AT, it should properly describe the content
    ([https://webaim.org/techniques/alttext/](https://webaim.org/techniques/alttext/)).
    You might wonder why you would have to do this, especially with an SVG image that
    already has descriptive text as part of its source. Note that any textual content
    in the SVG file is, in effect, locked away from a screen reader, so even if you're
    using SVG, a descriptive, markup-based image format, it behaves, in this case
    at least, just like a common bitmapped file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the alternative text, there''s just one wrinkle with older versions
    of Safari (older than Safari Desktop 9.1.1 or version 9.3.2 on iOS) that you should
    take into account. In those older versions, the `alt` text won''t be being read
    by VoiceOver, the Apple screen reader, unless the `role="img"` ARIA role was set
    on the `img` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inline SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inline SVG offers a broader palette for accessibility. For example, unlike the
    SVG as an `img src` scenario, that we just discussed, if there are one or more `<text>` elements
    in your SVG, then that text is available to be read directly by a screen reader.
    If the text is properly descriptive of the image, then you have already provided
    an accessible image. You don't need to do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the text in your SVG is not descriptive of the image or if your image has
    no text, then you can take advantage of two SVG elements, `title`, and `desc`,
    to provide accessible text. These elements, coupled with the `aria-labelledby` attribute,
    provide a two-leveled approach to accessibility. The following code example shows
    the basics of how this works. The image itself is an illustration of an apple.
    Rendered in a browser, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02823222-c153-42e5-9c00-010ab9b4b9d3.png)'
  prefs: []
  type: TYPE_IMG
- en: The markup is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The SVG element itself has two important attributes. It has a `role` of `img`,
    which indicates that the element is identified as a graphic. It also leverages
    the `aria-labelledby` attribute, which references two separate IDs, `"apple-title"`
    and `"apple-desc"`. The `aria-labelledby` attribute creates a relationship between
    the element it's a property of and other elements that label it.
  prefs: []
  type: TYPE_NORMAL
- en: We meet the first of those two elements as the first child of the  SVG element,
    the `title` element.  The `title` element is available for SVG elements to provide
    a textual description of the element. It is not rendered directly by the browser,
    but should be read by a screen reader and can be rendered in a tooltip, much like
    how text in an `alt` attribute shows up in some browsers. It has an `id` of `"apple-title"`.
    Following that is the optional `desc` element. `desc` allows you to provide a
    longer text description of the image. It has an `id` of `"apple-desc"`. It too
    can be read by a screen reader and doesn't get rendered directly into the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of interesting markup is `role="presentation"`, which is applied
    to each of the child `path` elements. Doing that pulls those elements out of the
    accessibility tree ([https://www.w3.org/TR/svg-aam-1.0/#exclude_elements](https://www.w3.org/TR/svg-aam-1.0/#exclude_elements))
    so, from an accessibility perspective, the SVG element is treated as one graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This section describes accessibility with static SVG images. There are additional
    accessibility techniques possible with dynamic SVG, including other ARIA attributes,
    such as ARIA-live regions ([https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)).
    Where applicable, you'll learn about those in the following chapters. That said,
    getting the basics right for static SVG is a great start and learning to test
    your SVG with a screen reader will put you on the right path.
  prefs: []
  type: TYPE_NORMAL
- en: SVG and responsive web design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Responsive web design** (**RWD**) is a technique for developing sites and
    applications that leverage  fluid layout grids and CSS3 media queries ([https://www.w3.org/TR/css3-mediaqueries/](https://www.w3.org/TR/css3-mediaqueries/))
    to create layouts that can adapt and respond to the characteristics of the device
    or user agent, stretching and shrinking to present layouts that work on a variety
    of screen sizes without prior knowledge of the device characteristics.'
  prefs: []
  type: TYPE_NORMAL
- en: When RWD started to take off, one of the issues that quickly bubbled up to the
    surface as a pain point was the difficulty of serving correctly sized images (for
    both file weight and dimensions), depending on any of the multitudes of variables
    that would impact the end user's experience. Screen resolution, pixel depth, and
    available bandwidth all combine to make the question of what size image to serve
    to a user a complex one.
  prefs: []
  type: TYPE_NORMAL
- en: What followed was a years-long quest for a markup pattern that would create
    responsive content images. *Content images* are images served with an `img` tag
    that are meant to be presented as content. This is compared to images used solely
    for design, which can and should already be handled with CSS. With media queries
    strongly supported, CSS already provides a number of tools to present the correct
    image depending on a number of factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the requirements for responsive images were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smallest possible file size**: This is really the core issue. It just manifests
    itself in many ways. In a perfect world, we would only ever send the smallest
    possible number of bytes needed to render the image at an acceptable quality level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Take advantage of the browser preloader**: All modern web browsers use a
    technique where the browser skips ahead, while simultaneously reading through
    the document and building out the DOM, and reads through the document, looking
    for additional assets that it can go ahead and start to download.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serve correctly sized images to multiple resolutions**: If you''re serving
    a big image to a `2048` pixel monitor, then you want it to be a big image of `1600`
    pixels or more. A big image on a tablet or phone, on the other hand, might only
    need to be `320` or `480` pixels wide. Sending the correct amount of data, in
    this case, can significantly improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serve the correct image for multiple pixel-ratio devices**: To produce clean
    images on devices with a high device pixel ratio, you need to send down proportionally
    larger files that are displayed for a given set of CSS pixels. Images that are
    crisp on a standard desktop display would show artifacts on a high pixel density
    display. Obviously, you can just send higher resolution images to all browsers,
    but those pixels come at a bandwidth price, so it''s much better to just send
    the correct images to the correct devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose different sizes of images or entirely different images at different
    breakpoints**: There is a desire to be able to show different images for different
    orientations and screen resolutions. On a large screen, in an article describing
    flora in Tuscon, Arizona, you might use a wide image that shows a variety of the
    hardy plant life you can find there. On a small screen in portrait orientation,
    where the impact of the variety would be lost as it would display only an inch
    high with little detail, an image of a Saguaro cactus with a strongly vertical
    aspect ratio might be a better choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use design breakpoints**: There has been plenty of development based around
    the concept of media query breakpoints. They''re one of the primary technologies
    at the heart of RWD. Images need to be controlled alongside all the other design
    changes that occur in a responsive site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The multiple solutions (the `picture` element and the `srcset` and `sizes` attributes)
    that came out of that quest are incredibly powerful. It took a while (a couple
    of years and lots of internet angst) but eventually, everything we needed to serve
    the *correct *image with the *correct* file size and the *correct *dimensions
    was available for us in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: It's not *easy. *It's a complicated problem, as it has got a complicated solution.
    The coding is complicated and it is complicated to understand and it requires
    multiple versions generated of every image you want to present on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how the new solutions work and then we'll see how SVG (where it's
    available to you because of image requirements) can make it a lot less complicated.
  prefs: []
  type: TYPE_NORMAL
- en: The srcset attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `srcset` attribute is a new attribute added to the `img` element. You can
    use it alongside the new `picture` element, and we will do so in a little bit.
    For now, let's look at it by itself. Like I said, this stuff is complicated, so
    it's worth taking the time to build up slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Like the standard `src` attribute, the `srcset` attribute tells the browser
    where to get the file to use for the contents of the `img` element. Unlike the
    single image that is referenced by `src`, however, the `srcset` attribute presents
    a comma delineated list of URLs. The `srcset` attribute also provides *hints*
    regarding the image size or pixel density.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example to understand how those hints work.
  prefs: []
  type: TYPE_NORMAL
- en: The `srcset` attribute in the following sample hints about the device pixel
    ratio. In this case, there are two options. The first option is `more-colors-small.jpg`,
    which is `600*350` (600 by 350) pixels wide and is meant to display at a standard
    resolution. The second image, `more-colors-large.jpg`, is `1200*700` pixels and
    is meant for higher resolution displays. It will still display at `600*350` *CSS*
    pixels but it's got enough additional image information to look clean in higher
    pixel density displays as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src` attribute acts as a fallback for browsers that don''t support `srcset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the solution for the device pixel ratio use case.
  prefs: []
  type: TYPE_NORMAL
- en: With `src` as a fallback for every browser that supports images and an `alt`
    attribute for those that don't, this is a good, backward-compatible solution.
  prefs: []
  type: TYPE_NORMAL
- en: The srcset and sizes attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve more complicated use cases, the `srcset` attribute can work in tandem
    with the new `sizes` attribute to use media queries to serve separate image sources,
    displayed with different relative dimensions based on the browser window. The
    code sample illustrates how this works.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the element starts with an `src` attribute for non-supporting
    browsers. In this case, I've chosen a smallish image to ensure that it loads speedily,
    no matter what device or browser. Following that there's the new `sizes` attribute.
    `sizes` accepts a media query/image size pair (or list of pairs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram breaks down the components. The first part is the media
    query. This media query should be familiar if you''ve used them in your CSS. If
    the query is `true`, then the image size is set to **60vw** (60% of **viewport
    width** (**vw**)). If the media query fails, the size falls back to the default
    size of **100vw**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbd2c9a2-3f27-441e-b3a2-757b5ca15f83.png)'
  prefs: []
  type: TYPE_IMG
- en: There can be any number of **media query/size pairs**. The first one to match
    wins and, if none match, then the fallback value is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `srcset` attribute here is more expansive. The list has a series of images
    between `200` pixels wide and `1600` pixels wide. The second part of the value
    pair in the source set, instead of indicating the preferred pixel density, hints
    to the browser the pixel width of the image (200w, 400w, and so on). It''s the
    up to browser to mix and match the best pixel width with the appropriate size
    at different dimensions and pixel densities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The length part of `size` can be specified in any valid CSS length, which adds
    to the possibilities and complexity of this attribute. This chapter will stick
    with `vw` measurements.
  prefs: []
  type: TYPE_NORMAL
- en: The picture element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its original concept, `picture` was designed as a parallel `img` element,
    modeled on the syntax of the HTML5 `video` and `audio` elements. The idea was
    to have a `picture` element wrapping a series of `source` elements, which would
    represent the options for the image source. It would wrap a default `img` element
    for non-supporting browsers. A `media` attribute on each source would hint to
    the browser the correct source to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For a variety of implementation-related reasons, this initial proposal was shot
    down. `srcset` filled in some of the void, but since it didn't solve all the responsive
    image use cases, there was always a hole in the specification landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Years passed and *eventually*, after many false starts, `picture` was resurrected
    and reworked to fill that hole.
  prefs: []
  type: TYPE_NORMAL
- en: Now, however, instead of being a replacement for `img`, `picture` is now an
    *enhancement* to the `img` element to help browsers sort out the best possible
    solution for the source of an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example. While the `srcset` examples worked with different
    resolution versions of the same image, this `picture` example aims to provide
    different images for different resolutions. Here, in larger browser windows, an
    image that is wider than it is tall will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaadf6a9-52c3-4e9d-b0d3-4942e8db8ae2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In browser windows smaller than 1,024 pixels, a square image will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1bec99b-43f4-4fc2-a239-7e6ec7a760c9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The markup for this is relatively complicated and needs some explaining.
  prefs: []
  type: TYPE_NORMAL
- en: In the `head`, notice the presence of the `picturefill.min.js` file. Picturefill
    ([https://github.com/scottjehl/picturefill](https://github.com/scottjehl/picturefill))
    is a Polyfill ([https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill))
    for the `picture` element,  which supplies JavaScript driven picture element support
    to non-supporting browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the HTML document, the `picture` element wraps the entire solution.
    It lets the browser know that it should use this `picture` element to sort out
    the proper source for the child `img` element. We don't get to the `img` element
    immediately, however. The first child element we encounter is the `source` element.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer perspective, `source` works the way the original proposal intended.
    If the media query matches, that `source` is used. If it doesn't match, you move
    onto the next media query in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you have a media query looking for pages with a minimum width of `1024`
    pixels. If the media query matches, the `srcset` attribute is used to let the
    browser choose between three separate source images, ranging from `600` pixels
    to `1600` pixels wide. Since this image is intended to be displayed at `50vw`,
    that will give good coverage for the majority of displays. Following that, there''s
    the fallback `img` element that also contains a `srcset`. If the browser doesn''t
    support `picture` and `source` or if the previous media queries don''t match,
    you use `srcset` attribute here to get the source for this image. The `sizes`
    attribute allows you to further adjust the display for the range of sizes smaller
    than `1024` pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While it''s complicated, this `picture` pattern solves the question of both
    different image sizes and different formats for separate art direction choices.
    Now that (lengthy) explanation is out of the way, let''s take a look at how SVG
    can solve some of those same problems with a lot less markup. You''ve already
    seen in [Chapter 1](https://cdp.packtpub.com/mastering_svg/wp-admin/post.php?post=29&action=edit),
    *Introducing Scalable Vector Graphics*, an example of an SVG image as the `src`
    of an `img` element scaling up and down at will. In fact, with SVG, responsive
    images are as simple as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It allows you to infinitely scale up and down with no loss of fidelity or extra
    bytes and there's no `srcset` needed! There are ways to improve that simple solution
    with CSS, which we'll see in the next chapter, but for now, just know that this
    pattern will work. From a 3,000+ pixel behemoth monitor to a tiny feature phone
    (assuming it supports SVG), the preceding markup will scale nicely.
  prefs: []
  type: TYPE_NORMAL
- en: What about the art direction use case? That's also much simpler with SVG. Because
    we don't have to provide multiple versions of the image (every SVG image can scale
    as much as needed), the markup for the art direction use case is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: We have the same `picture` element we saw before. There's one child `source`
    element that has a media query pointing to browsers larger than `1024` pixels.
    If that's `true`, then the landscape image will be used. Then, there's a child
    `img` element with a `srcset` pointing to a square image and `width` of 100%.
    If the media query on the first `source` element fails, we get to this image.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not as simple as a plain old `img` but it''s a lot simpler than the version
    with multiple bitmapped images in each `srcset`. Output two images and you''re
    ready to go with even the most complicated case, art direction, and scaling across
    multiple screen resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While SVG isn't available for every use case, it's by far the most flexible
    image format for RWD. From the simple `width="100%"` technique for scaling images
    based on one image source to the simpler implementation of the art direction use
    case utilizing the `picture` element, SVG offers enormous benefits in these multiple
    resolutions, multiple device world.
  prefs: []
  type: TYPE_NORMAL
- en: Additional details on inline SVG in an HTML document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've already learned, using inline SVG is just about as straightforward
    as HTML markup and is often going to be the best (or only, in the case of interactive
    SVG) option for you to embed SVG into your documents. That said, as with anything
    on the web, there are always some edge cases, notes, and gotchas that you need
    to keep in mind when working with inline SVG. This section outlines two such concerns.
    The first is about trying to leverage the browser's cache and the other is to
    be aware of the potentially large increase in DOM complexity when working with
    SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike an SVG image linked to as the `src` of an `img` element or referenced
    with CSS, inline SVG can't be cached and referenced on another page or different
    view of a single-page application. While there remains a performance benefit to
    minimizing the number of HTTP requests (which inline SVG does by dropping the
    need for a request to a separate SVG document), that's not always the most optimal
    pattern. If you're using the same SVG image multiple times across multiple pages,
    or multiple site visits, there's going to be a benefit in having a file that can
    be cached and read again later. This is especially true of larger, more complicated
    SVG images, which can have a large download footprint.
  prefs: []
  type: TYPE_NORMAL
- en: If you really need to use inline SVG (all interactive examples, for example),
    you can still try to leverage the browser cache in different ways by linking to
    external library SVG elements using the `use` element. You might be adding some
    HTTP requests up front, but you won't have to continually download and parse the
    inline markup defining those reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: And really, thinking about reusable components is a good way to think about
    structuring any aspect of your project so that's a benefit above and beyond leveraging
    the browser's cache.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While I've actually tried to limit the complexity of the SVG code samples you've
    seen so far in this book, you have already seen some very *busy *examples of SVG.
    In fact, when working with anything more complicated than a handful of `rect`, `circle`, or
    `text` elements, the size and/or readability of SVG code can go downhill very
    quickly.  This is especially true of generated code where it's not really meant
    for human consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'This complexity can be a problem in two separate ways: a more complicated authoring
    environment and a slowdown in the rendering and performance of your page.'
  prefs: []
  type: TYPE_NORMAL
- en: Authoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG documents can grow quite large, even for simple images. Depending on the
    number of effects and the number of elements, the markup used to draw an SVG image
    could quickly overwhelm everything else on the page. For that reason, it's worth
    keeping large SVG elements as separate document fragments and pulling them into
    your documents as needed. Depending on how they're being used, this might be with
    the `use` element inside a containing SVG document or might be a case of importing
    a document fragment using your page composition tool of choice. There are a large
    number of server-side and/or client-side solutions for bringing together pieces
    of markup and text together (for example, JavaScript template solutions, CMSs,
    blog platforms, and server-side scripting languages, such as PHP), so I'm not
    going to create an example of potentially limited use. I'll trust you'll leverage
    the one closest to your heart.
  prefs: []
  type: TYPE_NORMAL
- en: You'd still have to deal with it when inspecting the page, but it's much nicer
    than having 500 lines of markup in a 700-line file being taken up by an SVG illustration
    showing a supply chain diagram or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to problems with authoring, you can also run into browser performance
    problems with very complicated SVG. This is true whichever way you're importing
    them, since even SVG imported as an `img src` is more than just a collection of
    pixels, but this can become more acute if you're already doing a lot of interaction
    with the DOM. In general, the number of elements in your document directly affects
    the speed and responsiveness of the page ([https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing](https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing)).
    When you have many hundreds or many thousands of potentially interactive SVG elements
    on the page, each of which has to be calculated (some with very complicated calculations
    under the hood) and rendered by the browser, things can slow down very quickly
    indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you're not going to run into performance problems of this
    sort. At least I hope you are not. It *is* possible, however, so keep the possibility
    filed away and hopefully, you'll never have to use the knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about working with SVG in the context of an HTML
    document.  First, you learned about SVG accessibility with both inline SVG elements
    and SVG images as the `src` of an `img` element. This includes details on the
    `alt` attribute for `img` elements and details of the `title` and `desc` elements
    in inline SVG.
  prefs: []
  type: TYPE_NORMAL
- en: Following that you learned about the solutions for responsive images and how
    using SVG can greatly simplify the implementation of even the most complicated
    responsive image use case. Finally, you learned some other aspects of inline SVG
    to pay attention to when implementing these solutions in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll look at the important intersection of CSS and SVG. The next chapter
    will build on everything we've learned and will introduce some powerful new tools
    for you to add to your SVG toolbox.
  prefs: []
  type: TYPE_NORMAL
