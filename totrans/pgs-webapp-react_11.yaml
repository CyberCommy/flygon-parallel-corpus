- en: Chunking JavaScript to Optimize Performance with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the last chapter, the biggest problem with converting React
    applications to Progressive Web Apps is React; more specifically, it's the amount
    of JavaScript that intrinsically comes along with building a modern JavaScript
    application. Parsing and running that JavaScript is the biggest single bottleneck
    for Chatastrophe’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we took some measures to improve the perceived startup
    time of our application, by moving content out of our JavaScript and into our
    `index.html`. While this is a very effective method of displaying content to the
    user as quickly as possible, you'll note that we didn't do anything to actually
    change the size of our JavaScript, or reduce the time it takes to initialize all
    that React goodness.
  prefs: []
  type: TYPE_NORMAL
- en: Well, now's the time to do something about it. In this chapter, we'll look at
    how we can split up our JavaScript bundle for faster loading. We'll also introduce
    a new bit of Progressive Web App theory--the PRPL pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the PRPL pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is code splitting and how do we implement it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our own higher-order component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting code by route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading additional routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PRPL pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we introduced some basic principles for performative apps.
    You want your user to spend as little time as possible waiting, which means loading
    the essentials as fast as possible and deferring loading the rest of the application
    to "idle" time for the processor.
  prefs: []
  type: TYPE_NORMAL
- en: These two concepts form the 'I' and 'L' of the RAIL metric. We took a step toward
    improving the 'L' with the concept of the app shell. Now, we will move some of
    our 'L' (the initial load) into the 'I' (the idle time of our application) but,
    before we do that, let's introduce another acronym.
  prefs: []
  type: TYPE_NORMAL
- en: '**PRPL** stands for **Push**, **Render**, **Pre-cache**, **Lazy-load**; it''s
    a step-by-step process for how an ideal application should get the content it
    needs from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive in, however, I would like to caution the reader that the PRPL
    pattern is relatively new at the time of writing and may evolve quickly as Progressive
    Web Apps move into the mainstream. Like many of the concepts we've discussed in
    this book, it relies on experimental technology only available for certain browsers.
    This is cutting-edge stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how *Addy Osmani* puts it:'
  prefs: []
  type: TYPE_NORMAL
- en: For most real-world projects, it’s frankly too early to realize the PRPL vision
    in its purest, most complete form, but it’s definitely not too early to adopt
    the mindset, or to start chasing the vision from various angles. ([https://developers.google.com/web/fundamentals/performance/prpl-pattern/](https://developers.google.com/web/fundamentals/performance/prpl-pattern/))
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each letter in turn and explain what it means for us and our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Addy Osmani* defines the PUSH of PRPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “Push critical resources for the initial URL route.”
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this means that your first priority is loading only what you need
    to render your initial route as fast as possible. Sound familiar? This is exactly
    the principle we followed with our application shell.
  prefs: []
  type: TYPE_NORMAL
- en: A gentle definition of Push can be "load the critical content first, before
    anything else." This definition fits exactly with the app shell pattern, but it's
    not quite what *Osmani* means.
  prefs: []
  type: TYPE_NORMAL
- en: The following section is a theoretical introduction to server *push* technology.
    Since we don't have control over our server (AKA Firebase), we won't be implementing
    this approach, but it's good to know about for your future PWAs that communicate
    with your own server.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at our `index.html`, you can see that it references several assets.
    It asks for the `favicon`, the `icon.png`, and `secrets.js`. After Webpack builds,
    it also requests our main JavaScript `bundle.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How a website normally works is like this: the browser requests `index.html`.
    Once it gets the file, it goes through and asks the server for all the dependencies
    listed earlier, each as a separate request.'
  prefs: []
  type: TYPE_NORMAL
- en: The core inefficiency here is that `index.html` already contains all the information
    about its dependencies. In other words, when it responds with `index.html`, the
    server already "knows" what the browser will request next, so why not anticipate
    those requests and send all those dependencies along?
  prefs: []
  type: TYPE_NORMAL
- en: Enter HTTP 2.0 Server Push. This technology allows the server to create multiple
    responses to a single request. The browser asks for `index.html`, and gets `index.html`
    + `bundle.js` + `icon.png`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As *Ilya Grigorik* puts it, Server Push "obsoletes inlining" ([https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/](https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/)).
    No longer do we have to inline our CSS to save trips to the server; we can program
    our server to send everything we need for our initial route in a single trip.
    This is exciting stuff; for more information (with a quick tutorial), check out
    the preceding link.
  prefs: []
  type: TYPE_NORMAL
- en: Render
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After (ideally) pushing all the necessary resources to the client, we render
    our initial route. Again, we have covered this already, with a fast render, thanks
    to the app shell pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have rendered our initial route, we still have assets required for the
    other routes. Precaching means that once those assets are loaded, they will go
    straight into the cache and, if they're requested again, we load them from the
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover this in more detail in the next chapter, as we move into the world
    of caching.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy-load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's where the meat of this chapter will take place.
  prefs: []
  type: TYPE_NORMAL
- en: We want to load the resources needed for our initial route first, to get that
    initial rendering done as fast as possible. This means resources needed for other
    routes will not be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, this means that we want to load `LoginContainer` first (if
    the user is not logged in) and defer loading `UserContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: However, once that initial route is rendered and the user can see the login
    screen, we want to prepare for the future. If they then click over to the `UserContainer`,
    we want to display it as fast as possible. This means loading `UserContainer`
    resources in the background, once loading the initial route is done.
  prefs: []
  type: TYPE_NORMAL
- en: This process is called **lazy-loading**--loading resources that aren't needed
    immediately, but may be needed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The tool we use to do so is code splitting.
  prefs: []
  type: TYPE_NORMAL
- en: What is code splitting?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code splitting** is the act of splitting up our JavaScript file into meaningful
    chunks in order to improve performance, but why do we need it?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, when a user first accesses our application, we only need the JavaScript
    for the route they're currently on.
  prefs: []
  type: TYPE_NORMAL
- en: This means when they're on `/login`, we only need `LoginContainer.js` and its
    dependencies. We don't need `UserContainer.js`, so we want to immediately load
    `LoginContainer.js` and lazy-load `UserContainer.js`. However, our current Webpack
    setup creates a single `bundle.js` file. All our JavaScript is tied together and
    must be loaded together. Code splitting is a way to fix that. Instead of a single
    monolithic JavaScript file, we get multiple JavaScript files, one for each route.
  prefs: []
  type: TYPE_NORMAL
- en: So, we'll get one bundle for `/login`, one for `/user/:id`, and one for `/`.
    Additionally, we’ll get another `main` bundle with all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever route the user visits first, they'll get the bundle for that route
    and the main bundle. In the background, meanwhile, we'll load the bundles for
    the other two routes.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting does not necessarily have to take place on a route-by-route basis,
    but it makes the most sense for our application. Additionally, code splitting
    with Webpack and React Router in this way is relatively straightforward to do.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Webpack will handle this automatically for you, as long as you provide
    some basic setup. Let's get started with that setup!
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our strategy, as discussed earlier, goes like this: we want to split our `bundle.js`
    into separate chunks, based on the route.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of this section is to do two things: one, set up a naming convention
    for the chunks of JavaScript, and two, add support for conditional imports (more
    on those soon).'
  prefs: []
  type: TYPE_NORMAL
- en: Open up `webpack.config.prod.js` and let's do the first step (this only applies
    to the `PRODUCTION` build, so only modify our production Webpack config; we don't
    need code splitting in development).
  prefs: []
  type: TYPE_NORMAL
- en: 'As it stands, our output configuration looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create a single JavaScript file in our `build` folder, named `bundle.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change this whole section to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here?
  prefs: []
  type: TYPE_NORMAL
- en: First, we're moving our JavaScript output to `build/static/js`, just for organization
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re using two variables in our naming: `name` and `hash`. The name
    variable is automatically generated by Webpack, using a numbering convention for
    our chunks. We''ll see that in a second.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use a `hash` variable. Every single time Webpack builds, it generates
    a new hash--a string of random letters and numbers. We use those to name our files
    so that each build will have distinct filenames. This will be important in the
    next chapter because it means our users will never have the issue of the app having
    been updated, but the cache still holding on to the old files. Since the new files
    will have new names, they will be downloaded instead of whatever is in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're appending a `.chunk` to our code split files (the files for each
    route). This isn't necessary, but it's recommended if you want to do any special
    caching with your chunks.
  prefs: []
  type: TYPE_NORMAL
- en: All of the mentioned will make a lot more sense once our code splitting is complete,
    so let's get there as soon as possible! However, before we move on, we need to
    add one more thing to our Webpack config.
  prefs: []
  type: TYPE_NORMAL
- en: Babel stage 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained in the Webpack chapter, Babel is the tool we use to allow us
    to use cutting edge JavaScript features and then transpile those into a version
    of JavaScript the browser will understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use another cutting edge feature: conditional imports.
    Before we get started with those, however, we need to change our Babel configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript language is constantly evolving. The committee in charge of
    updating it is called TC39 and they develop updates according to the **TC39 process.**
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new JavaScript feature is suggested, at which point it is called "stage 0"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proposal is created for how it will work ("stage 1")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation is created ("stage 2")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is polished for inclusion ("stage 3")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is added to the language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any point in time, there are multiple features in every stage. The problem
    is that JavaScript developers are impatient, and any time they hear about a neat
    feature, they want to start using it, even if it’s in stage 3, or 2, or even 0.
  prefs: []
  type: TYPE_NORMAL
- en: Babel provides a way of doing so with its **stage** presets. You can install
    a preset for each stage and get access to all the features currently in that stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature we''re interested in (conditional imports) is currently in stage
    2\. In order to use it, we need to install the appropriate babel preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in both Webpack configs, add it under module | loaders | the JavaScript
    test | query | presets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add this to both `webpack.config.js` and `webpack.config.prod.js`.
    We'll need it in both production and development.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that done, it's time to ask what conditional imports are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we import all our dependencies at the top of each JavaScript file,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will always need React, so this import makes sense. It's static, in that
    it will never change, but the preceding means that React is a dependency of this
    file and it will always need to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, in `App.js`, we do the same with each container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Doing so means that those containers are a dependency of `App.js`, so Webpack
    will always bundle them together; we can't split them apart.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we want to import them conditionally, only when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism to do so is a little complicated, but it will look as follows, in
    essence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, how can we implement this?
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed higher-order components in [Chapter 5](part0086.html#2I0GC0-7dd7c66301294003b85168009fe95fa4),
    *Routing with React*, with the discussion of `withRouter` from React Router; now,
    we will build one, but first, let's take a quick refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order components are a fantastically useful pattern in React. If you
    learn to use them well, you'll open up a whole bunch of possibilities to keep
    a large code base maintainable and reusable, but they’re not as intuitive as regular
    components, so let's ensure that we cover them well.
  prefs: []
  type: TYPE_NORMAL
- en: At a most basic level, a higher-order component is a function that returns a
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have a `button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written using `class` syntax, if you''re more familiar with
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use a color prop to control the color of the text. Let's say we use this
    button all over our application. Often, we find ourselves setting the text to
    red--about 50% of the time.
  prefs: []
  type: TYPE_NORMAL
- en: We can simply continue to pass the `color=”red”` prop to our button. This will,
    in this contrived example, be the superior choice, but we can also make a higher-order
    component which, in more complex use cases, is the way to go (as we shall see).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a function called `RedColouredComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in a component as an argument. All it does is return a component
    class, which in turn returns that component with the `color=”red”` prop applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then render our button in another file, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can pass any component to `RedColouredComponent` and thus create a
    red-colored version.
  prefs: []
  type: TYPE_NORMAL
- en: Doing so opens up new worlds of composition--creating components out of combinations
    of higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: This is the essence of React, after all--composing UI out of reusable bits of
    code. Higher order components are a great way to keep our application clean and
    maintainable, but enough of contrived examples, let’s make our own now!
  prefs: []
  type: TYPE_NORMAL
- en: AsyncComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this section is to create a higher-order component that helps us
    with code splitting.
  prefs: []
  type: TYPE_NORMAL
- en: This component will only load its dependencies when it is rendered, or when
    we explicitly tell it to. This means that if we pass it `LoginContainer.js`, it
    will only load that file when the user navigates to `/login`, or if we tell it
    to load it.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this component will give us complete control over when our JavaScript
    files are loaded and opens up the world of lazy loading. However, it also means
    that whenever a route is rendered, the relevant files will be automatically loaded.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds abstract, let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in your `components/` directory called `AsyncComponent.js` and
    add the basic skeleton, as demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`asyncComponent` is a function that takes an import statement as an argument,
    which we call `getComponent`. We know that, as a higher-order component, it will
    return a `component` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The key for `AsyncComponent` will be the `componentWillMount` life cycle method.
    This is when `AsyncComponent` will know to go get the dependency file. In this
    way, the component waits until it is needed, before loading in any files.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what do we do with the component after we get it? Simple, store it
    in state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have not yet loaded the component, go import it (we''ll assume that `getComponent`
    returns a `Promise`). Once the import is complete, set the state to the imported
    component, which in turn means our `render` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All this should look familiar to you, except perhaps the `{...this.props}` in
    the `return` statement. This is the JavaScript spread operator. It's a complicated
    little thing (more on it at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator))
    but in this case, it basically means take the `this.props` object and copy all
    its keys and values onto the `props` of `Component`.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can pass props to the component returned by `asyncComponent` and
    have them passed to the `Component` rendered. Every prop applied to `AsyncComponent`
    will be applied to the `Component` in its `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full component, for reference, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Route splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's hop back to `App.js`, and bring it all together.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll eliminate App''s dependence on the three containers. Replace
    those imports with an import for `AsyncComponent` so that the top of the file
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define three `load()` functions, one for each container. These
    are the functions we''ll pass to `asyncComponent`. They must return a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Behold the magic of conditional imports. When these functions are called, the
    three JavaScript files will be imported. We then grab the export default from
    each file and `resolve()` the `Promise` with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can redefine our components inside `App.js`, as shown, after
    the preceding function declarations (which come after the import statements at
    the top of the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: No other changes are necessary! You can keep the app's `render` statement exactly
    the same. Now, when we refer to `ChatContainer`, it refers to the `AsyncComponent`
    wrapper around `loadChat…`, which will go get `ChatContainer.js` when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether it works. Run `yarn build`, and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have four JavaScript files instead of one. We have our `main.js` file, which
    contains `App.js` plus our necessary `node_modules`. Then, we have three chunks,
    one for each container.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the file sizes as well and you can see that we didn't gain all
    too much by this code splitting, a few kilobytes were shed from the main file.
    However, as our app grows, and each route becomes much more complicated, the benefits
    of code splitting will scale with it. How easy was that?
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading is the last piece of our PRPL puzzle and is the process of using
    our application's idle time to load the rest of the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you **`yarn deploy`** our application and navigate to the Network tab in
    DevTools, you''ll see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We load our main file and then whatever chunk is relevant to the current URL,
    but then we stop.
  prefs: []
  type: TYPE_NORMAL
- en: We're not loading the other routes during the idle time of our application!
    We need some way to trigger that loading process as soon as the initial route
    rendering is done, as soon as the `App` has mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think you know where this is going. In the `componentDidMount` method of
    `App`, we simply need to call our three loading methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever we're done rendering the current route, we'll get the other routes
    ready to go as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the Performance tab of DevTools again, you will see this reflected
    in the network requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To the left, the bottom yellow chunk is our `main.js` file being loaded. This
    means our app can start initialized. To the right, the three yellow blocks correspond
    to our three route chunks. The one we need is loaded first, followed soon after
    by the other two.
  prefs: []
  type: TYPE_NORMAL
- en: We're now using much more of our application’s idle time, spreading out the
    work of initializing our app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this chapter, taking enormous strides to a more performative
    app. We split up our JavaScript by route and streamlined the loading process so
    that we load what we need and defer the rest to idle time.
  prefs: []
  type: TYPE_NORMAL
- en: However, all of this was really just paving the way for the next section. We
    need our app to perform under all network conditions, even an absence of any network.
    How can we make our application work offline?
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dive into the world of caching and further improve our app's performance
    for any network condition, even the absence of a network.
  prefs: []
  type: TYPE_NORMAL
