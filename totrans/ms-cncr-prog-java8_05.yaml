- en: Chapter 4. Getting Data from the Tasks – The Callable and Future Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors,* and [Chapter 3](part0028_split_000.html#QMFO1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 3. Getting the Maximum from Executors"), *Getting the Maximum from Executors*,
    we introduced the executor framework to improve the performance of concurrent
    applications and showed you how to implement advanced characteristics to adapt
    this framework to your needs. In these chapters, all the tasks executed by the
    executor were based on the `Runnable` interface and its `run()` method that doesn''t
    return a value. However, the executor framework allows us to execute other kind
    of tasks that return a result based on the `Callable` and `Future` interfaces.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the `Callable` and `Future` interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First example – a best-matching algorithm for words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second example – building an inverted index of a collection of documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Callable and Future interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The executor framework allows programmers to execute concurrent tasks without
    creating and managing threads. You create tasks and send them to the executor.
    It creates and manages the necessary threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an executor, you can execute two kinds of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tasks based on the Runnable interface**: These tasks implement the `run()`
    method that doesn''t return any result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tasks based on the Callable interface**: These tasks implement the `call()`
    interface that returns an object as a result. The concrete type that will be returned
    by the `call()` method is specified by the generic type parameter of the `Callable`
    interface. To get the result returned by the task, the executor will return you
    an implementation of the `Future` interface for every task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous chapters, you learned how to create executors, send tasks based
    on the `Runnable` interface to it, and personalize the executor to adapt it to
    your needs. In this chapter, you will learn how to work with tasks based on the
    `Callable` and `Future` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The Callable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Callable` interface is very similar to the `Runnable` interface. The main
    characteristics of this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a generic interface. It has a single type parameter that corresponds to
    the return type of the `call()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It declares the `call()` method. This method will be executed by the executor
    when it runs the task. It must return an object of the type specified in the declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `call()` method can throw any checked exception. You can process the exceptions
    implementing your own executor and overriding the `afterExecute()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Future interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you send a `Callable` task to an executor, it will return you an implementation
    of the `Future` interface that allows you to control the execution and the status
    of the task and to get the result. The main characteristics of this interface
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: You can cancel the execution of the task using the `cancel()` method. This method
    has a `boolean` parameter to specify whether you want to interrupt the task if
    it's running or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check whether the task has been cancelled (with the `isCancelled()`
    method) or it has finished (with the `isDone()` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can get the value returned by the task using the `get()` method. There
    are two variants of this method. The first one doesn''t have parameters and returns
    the value returned by the task if it has finished its execution. If the task hasn''t
    finished its execution, it suspends the execution thread until the tasks finish.
    The second variant admits two parameters: a period of time and `TimeUnit` of that
    period. The main difference with the first one is that the thread waits for the
    period of time passed as a parameter. If the period ends and the task hasn''t
    finished its execution, the method throws a `TimeoutException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First example – a best-matching algorithm for words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main objective of a **best-matching algorithm** for words is to find the
    words most similar to a string passed as a parameter. To implement one of these
    algorithms you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A list of words**: In our case, we have used the **UK Advanced Cryptics Dictionary**
    (**UKACD**) that is a word list compiled for the crossword community. It has 250,353
    words and idioms. It can be downloaded for free from [http://www.crosswordman.com/wordlist.html](http://www.crosswordman.com/wordlist.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A metric to measure the similarity between two words**: We have used the
    Levenshtein distance that is used to measure the difference between two sequences
    of **chars**. The **Levenshtein distance** is the minimal number of insertions,
    deletions, or substitutions, which is necessary to transform the first string
    into the second string. You can find a brief description of this metric in [https://en.wikipedia.org/wiki/Levenshtein_distance](https://en.wikipedia.org/wiki/Levenshtein_distance).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, you will implement two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The first operation returns a list of the most similar words to a **char sequence**
    using the Levenshtein distance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second operation determines if a char sequence exists in our dictionary
    using the Levenshtein distance. It would be faster if we use the `equals()` method,
    but our version is a more interesting option for the objectives of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will implement serial and concurrent versions of these operations to verify
    that concurrency can help us in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The common classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all the tasks implemented in this example, you will use the following three
    basic classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `WordsLoader` class that loads the list of words into a list of `String`
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LevenshteinDistance` class that calculates the Levenshtein distance between
    two strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BestMatchingData` class that stores the results of the best-matching algorithms.
    It stores a list of words and the distance of these words with the input string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UKACD is in a file with a word per line, so the `WordsLoader` class implements
    the `load()` static method that receives the path of the file that contains the
    list of words and returns a list of string objects with the 250,353 words.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LevenshteinDistance` class implements the `calculate()` method that receives
    two string objects as parameters and returns an `int` value with the distance
    between these two words. This is the code for this classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BestMatchingData` class has only two attributes: a list of string objects
    to store a list of words and an integer attribute named distance to store the
    distance of these words with the input string.'
  prefs: []
  type: TYPE_NORMAL
- en: A best-matching algorithm – the serial version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we are going to implement the serial version of the best-matching algorithm.
    We are going to use this version as the starting point for the concurrent one
    and then we will compare the execution times of both versions to verify that concurrency
    help us to get better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have implemented the serial version of the best-matching algorithm in the
    following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BestMatchingSerialCalculation` class that calculates the list of most similar
    words to the input string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BestMatchingSerialMain` that includes the `main()` method that executes
    the algorithm, measures the execution time, and shows the results in the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze the source code of both classes.
  prefs: []
  type: TYPE_NORMAL
- en: The BestMatchingSerialCalculation class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class has only one method named `getBestMatchingWords`() that receives
    two parameters: a string with the sequence we take as a reference and the list
    of string objects with all the words of the dictionary. It returns a `BestMatchingData`
    object with the results of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the initialization of the internal variables, the algorithm processes
    all the words in the dictionary calculating the Levenshtein distance between these
    words and the string of reference. If the calculated distance for a word is less
    than the actual minimum distance, we clear the list of results and store the actual
    word into the list. If the calculated distance for a word is equal to the actual
    minimum distance, we add that word to the list of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create the `BestMatchingData` object to return the results of the
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The BestMachingSerialMain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the main class of the example. It loads the UKACD file, calls `getBestMatchingWords()`
    with the string received as a parameter, and shows the results in the console
    including the execution time of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used a new Java 8 language construct named **method reference** and
    a new `List.forEach()` method to output the result.
  prefs: []
  type: TYPE_NORMAL
- en: A best-matching algorithm – the first concurrent version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented two different concurrent versions of the best-matching algorithm.
    The first one is based on the `Callable` interface and the `submit()` method defined
    in the `AbstractExecutorService` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have implemented this version of the algorithm using the following three
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BestMatchingBasicTask` class that implements the tasks that implement the
    `Callable` interface and will be executed in the executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BestMatchingBasicConcurrentCalculation` class that creates the executor
    and necessary tasks and sends them to the executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BestMatchingConcurrentMain` class that implements the `main()` method to
    execute the algorithm and shows the results in the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the source code of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The BestMatchingBasicTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned before, this class will implement the tasks that will obtain
    the list of best-matching words. This task will implement the `Callable` interface
    parameterized with the `BestMatchingData` class. This means that this class will
    implement the `call()` method, and this method will return a `BestMatchingData`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each task will process a part of the dictionary and will return the results
    obtained for that part. We have used four internal attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first position (inclusive) of the dictionary it will analyze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last position (exclusive) of the dictionary it will analyze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary as a list of string objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference input string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `call()` method processes all the words between the `startIndex` and `endIndex`
    attributes and calculates the Levenshtein distance between those words and the
    input string. It will return only the nearest words to the input string. If during
    the process it finds a word nearer than the previous ones, it clears the result
    list and adds the new word to that list. If it finds a word that is at the same
    distance than the results found until now, it adds the word to the result list
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we create a `BestMatchingData` object with the list of words we
    have found and their distance to the input string and return that object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main difference with the tasks based on the `Runnable` interface is the
    return sentence included in the last line of the method. The `run()` method doesn't
    return a value, so those tasks cannot return a result. The `call()` method, on
    the other hand, returns an object (the class of that object is defined in the
    implements sentence), so this kind of tasks can return a result.
  prefs: []
  type: TYPE_NORMAL
- en: The BestMatchingBasicConcurrentCalculation class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class is responsible for the creation of the necessary tasks to process
    the complete dictionary, the executor to execute those tasks, and to control the
    execution of the tasks in the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It only has one method, `getBestMatchingWords()`, that receives two input parameters:
    the dictionary with the complete list of words and the reference string. It returns
    a `BestMatchingData` object with the results of the algorithm. First, we have
    created and initialized the executor. We have used the number of cores of the
    machine as the maximum number of threads we want to use on it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we calculate the size of the parts of the dictionary each task will process
    and creates a list of `Future` objects to store the results of the tasks. When
    you send a task based on the `Callable` interface to an executor, you will get
    an implementation of the `Future` interface. You can use that object to:'
  prefs: []
  type: TYPE_NORMAL
- en: Know whether the task has been executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the result of the execution of the task (the object returned by the `call()`
    method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel the execution of the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the tasks, send them to the executor using the `submit()` method,
    and add the `Future` object that method returns to the list of `Future` objects.
    The `submit()` method returns immediately. It doesn''t wait until the task is
    executed. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we have sent the tasks to the executor, we call the `shutdown()` method
    of the executor to finish its execution and iterate over the list of `Future`
    objects to get the results of each task. We have used the `get()` method without
    any parameter. This method returns the object returned by the `call()` method
    if the task has finished its execution. If the task is not finished, the method
    puts the current thread to sleep the calling thread until the task has finished
    and the results are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compose a result list with the results of the tasks, so we will only return
    the list with the words nearest to the reference string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create and return a `BestMatchingData` object with the results
    of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BestMatchingConcurrentMain` class is very similar to `BestMatchingSerialMain`
    presented before. The only difference is the class used (`BestMatchingBasicConcurrentCalculation`
    instead of `BestMatchingSerialCalculation`), so we don't include the source code
    here. Note that we used neither thread-safe data structures nor synchronization
    as our concurrent tasks worked on independent pieces of data, and the final results
    were merged in a sequential manner after the concurrent tasks were terminated.
  prefs: []
  type: TYPE_NORMAL
- en: A best-matching algorithm – the second concurrent version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented the second version of the best-matching algorithm using
    the `invokeAll()` method of the `AbstractExecutorService` (implemented in the
    `ThreadPoolExecutorClass`). In the previous version, we have used the `submit()`
    method that receives a `Callable` object and returns a `Future` object. The `invokeAll()`
    method receives a `List` of `Callable` objects as a parameter and returns a `List`
    of `Future` ones. The first `Future` is associated with the first `Callable` and
    so on. There is another important difference between these two methods. Although
    the `submit()` method returns immediately, the `invokeAll()` method returns when
    all the `Callable` tasks have ended their execution. This means that all the `Future`
    objects returned will return `true` if you call their `isDone()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this version, we have used the `BestMatchingBasicTask` class implemented
    in the previous example and have implemented the `BestMatchingAdvancedConcurrentCalculation`
    class. The differences with the `BestMatchingBasicConcurrentCalculation` class
    are in the creation of the tasks and in the process of the results. In the creation
    of tasks, now we create a list and store it on the tasks we want to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To process the results, we call the `invokeAll()` method and then go over the
    list of `Future` objects returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To execute this version, we have implemented `BestMatchingConcurrentAdvancedMain`.
    Its source code is very similar to the previous ones, so it's not included.
  prefs: []
  type: TYPE_NORMAL
- en: The word exists algorithm – a serial version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of this example, we have implemented another operation to check whether
    a string exists in our list of words. To check whether the word exists or not,
    we use the Levenshtein distance again. We consider that a word exists if it has
    a distance of `0` with a word of the list. It would be faster if we make the comparison
    using the `equals()` or `equalsIgnoreCase()` methods or reading the input words
    into a `HashSet` and using the `contains()` method (much more efficient than our
    version), but we consider that our version will be more useful for the purposes
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous examples, first, we have implemented the serial version of the
    operation to use it as a base to implement the concurrent one and compare the
    execution times of both versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the serial version, we have used two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ExistSerialCalculation` class, which implements the `existWord()` method
    that compare the input string with all the words in the dictionary until it finds
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExistSerialMain` class, which launches the examples and measure the execution
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze the source code of both the classes.
  prefs: []
  type: TYPE_NORMAL
- en: The ExistSerialCalculation class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class has only one method, that is, the `existWord()` method. It receives
    two parameters: the word we are looking for and the complete list of words. It
    goes over the full list, which calculates the Levenshtein distance between the
    input word and the words in the list until it finds the word (the distance is
    `0`), in which case it returns the `true` value, or it finishes the list of words
    without finding the word, in which case it returns the `false` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The ExistSerialMain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class implements the `main()` method to call the `exist()` method. It
    gets the first parameter of the main method as the word we want to look for and
    calls that method. It measures its execution time and shows the results in the
    console. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The word exists algorithm – the concurrent version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the concurrent version of this operation, we have to take into
    account its most important characteristic. We don't need to process the whole
    list of words. When we find the word, we can finish the process of the list and
    return the result. This operation which does not process the whole input data
    and stops when some condition is fulfilled is called a **short-circuit operation**.
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractExecutorService` interface defines an operation (implemented in
    the `ThreadPoolExecutor` class) that fits perfectly with this idea. Its the `invokeAny()`
    method. This method sends to the executor the list of `Callable` tasks that receives
    as a parameter and returns the result of the first task that has finished its
    execution without throwing an exception. If all the tasks throw an exception,
    this method throws an `ExecutionException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in previous examples, we have implemented different classes to implement
    this version of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ExistBasicTask` class that implements the tasks we are going to execute
    in the executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExistBasicConcurrentCalculation` class that creates the executor and the
    tasks, and send the tasks to the executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExistBasicConcurrentMain` class that executes the examples measuring its
    running time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ExistBasicTasks class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class implements the tasks that are going to search for the word. It implements
    the `Callable` interface parameterized with the `Boolean` class. The `call()`
    method will return the `true` value if the task finds the word. It uses four internal
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first word (included) in the list the task will process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last word (excluded) in the list the task will process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word the task will look for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `call` method will traverse the part of the list assigned to this task.
    It calculates the Levenshtein distance between the input word and the words of
    the list. If it finds the word, it will return the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: If the tasks process all its words and it doesn't find the word, it will throw
    an exception to adapt to the behavior of the `invokeAny()` method. If the task
    returns the `false` value in this case, the `invokeAny()` method will return the
    `false` value without waiting for the rest of the tasks. Maybe another task will
    find the word.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The ExistBasicConcurrentCalculation class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class will execute the search of the input word in the full list of words
    creating and executing the necessary tasks. It only implements one method named
    `existWord()`. It receives two parameters, the input string and the complete list
    of words, and returns a Boolean value indicating whether the word exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the executor to execute the tasks. We use the `Executor` class
    and create a `ThreadPoolExecutor` class with a maximum of threads determined by
    the number of available hardware threads of the machine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the same number of tasks as the threads are running in the
    executor. Each task will process an equal part of the list of words. We create
    the tasks and store them in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `invokeAny()` method to execute the tasks in the executor.
    If the methods return a Boolean value, the word exists. We return that value.
    If the method throws an exception, the word doesn''t exist. We print the exception
    in the console and return the `false` value. In both cases, we call the `shutdown()`
    method of the executor to terminate its execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The ExistBasicConcurrentMain class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class implements the `main()` method of this example. It's equal to the
    `ExistSerialMain` class with one difference that uses the `ExistBasicConcurrentCalculation`
    class instead of the `ExistSerialCalculation`, so its source code is not included.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's compare the different solutions (serial and concurrent) of the two operations
    we have implemented in this section. To test the algorithm, we have executed the
    examples using the JMH framework ([http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/))
    that allows you to implement micro benchmarks in Java. Using a framework for benchmarking
    is a better solution that simply measures time using methods as `currentTimeMillis()`
    or `nanoTime()`. We have executed them 10 times in a computer with a four-core
    processor and calculated the medium execution time of those 10 times. Let's analyze
    the results of the executions.
  prefs: []
  type: TYPE_NORMAL
- en: Best-matching algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, we have implemented three versions of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The serial version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent version, sending a task once at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent version, using the `invokeAll()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the algorithms, we have used three different strings that doesn''t
    exist in the list of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stitter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abicus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lonx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the words returned by the best-matching algorithm for each word:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stitter`: `sitter`, `skitter`, `slitter`, `spitter`, `stilter`, `stinter`,
    `stotter`, `stutter`, and `titter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abicus`: `abacus` and `amicus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lonx`: `lanx`, `lone`, `long`, `lox`, and `lynx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The medium execution times and their standard deviation in milliseconds are
    discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Stitter | Abicus | lonx |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Serial | 467.01 ± 23.40 | 408.03 ± 14.66 | 317.60 ± 28.78 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: `submit()` method | 209.72 ± 74.79 | 184.10 ± 90.47 | 155.61
    ± 65.43 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: `invokeAll()` method | 217.66 ± 65.46 | 188.28 ± 81.28 | 160.43
    ± 65.14 |'
  prefs: []
  type: TYPE_TB
- en: 'We can draw the following conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: The concurrent versions of the algorithm get a better performance than the serial
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent versions of the algorithm obtain similar results between them.
    All the concurrent versions have very high standard deviation values high. We
    can compare the concurrent version method with the serial version using the speed-up
    for the word `lonx` to see how concurrency improves the performance of our algorithm:![Best-matching
    algorithms](img/00011.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exist algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, we have implemented two versions of the algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: The serial version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent version, using the `invokeAny()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the algorithm, we have used some strings:'
  prefs: []
  type: TYPE_NORMAL
- en: The string `xyzt` that doesn't exist in the list of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `stutter` that exists in the list of words near the end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `abacus` that exists in the list of words very close to the start
    of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `lynx` that exists in the list of words just after the second half
    of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The medium execution times in milliseconds and their standard deviations are
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Word | Execution time (milliseconds) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Serial | `abacus` | 50.70 ± 13.95 |'
  prefs: []
  type: TYPE_TB
- en: '|   | `lynx` | 194.41 ± 26.02 |'
  prefs: []
  type: TYPE_TB
- en: '| `stutter` | 398.11 ± 23.4 |'
  prefs: []
  type: TYPE_TB
- en: '| `xyzt` | 315.62 ± 28.7 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent | `abacus` | 50.72 ± 7.17 |'
  prefs: []
  type: TYPE_TB
- en: '|   | `lynx` | 69.15 ± 62.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `stutter` | 126.74 ± 104.52 |'
  prefs: []
  type: TYPE_TB
- en: '| `xyzt` | 203.37 ± 76.67 |'
  prefs: []
  type: TYPE_TB
- en: 'We can draw the following conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: In general, the concurrent version of the algorithm provides better performance
    than the serial one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of a word in the list is a critical factor. With the `abacus` word,
    which appears at the beginning of the list, both algorithms give similar execution
    times, but with the `stutter` word, the difference is very big.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation in the concurrent case is very big.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we compare the concurrent version with the serial one for the word `lynx`
    using the speed-up, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exist algorithms](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second example – creating an inverted index for a collection of documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the **information retrieval** world, an **inverted index** is a common data
    structure used to speed up the searches of text in a collection of documents.
    It stores all the words of the document collection and a list of the documents
    that contains that word.
  prefs: []
  type: TYPE_NORMAL
- en: To construct the index, we have to parse all the documents of the collection
    and construct the index in an incremental way. For every document, we extract
    the significant words of that document (deleting the most common words, also called
    stop words and maybe applying a stemming algorithm) and then add those words to
    the index. If a word exists in the index, we add the document to the list of documents
    associated with that word. If a word doesn't exist, add the word to the list of
    words of the index and associate the document to that word. You can add parameters
    to the association, as the **term frequency** of the word in the document that
    provides you more information.
  prefs: []
  type: TYPE_NORMAL
- en: When you make a search of a word or a list of words in the document collection,
    you use the inverted index to obtain the list of documents associated with each
    word and create a unique list with the results of the search.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to use Java concurrency utilities to construct
    an inverted index file for a collection of documents. As the document collection,
    we have taken the Wikipedia pages with information about movies to construct a
    set of 100,673 documents. We have converted each Wikipedia page into a text file.
    You can download this document collection with all the information about the book.
  prefs: []
  type: TYPE_NORMAL
- en: To construct the inverted index, we don't delete any word and don't use any
    stemming algorithm too. We want to keep the algorithm as simple as possible to
    focus attention in the concurrency utilities.
  prefs: []
  type: TYPE_NORMAL
- en: The same principles explained here can be used to obtain other information about
    a document collection, for example, a vector representation of every document
    that can be used as an input for a **clustering algorithm**, as you will learn
    in [Chapter 6](part0041_split_000.html#173722-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 6. Optimizing Divide and Conquer Solutions – The Fork/Join Framework"),
    *Optimizing Divide and Conquer Solutions – The Fork/Join Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: As with other examples, you will implement serial and concurrent versions of
    these operations to verify that concurrency can help us in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Common classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both versions, serial and concurrent, have in common the classes to load the
    document collection into a Java object. We have used the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Document` class that stores the list of words contained in the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DocumentParse` class that converts a document stored in a file in a document
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze the source code of both the classes.
  prefs: []
  type: TYPE_NORMAL
- en: The Document class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Document` class is very simple. It has only two attributes and the methods
    to get and set the values of those attributes. These attributes are:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the file, as a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vocabulary (that is, the list of words used in the document) as a `HashMap`.
    The **key** are the **words** and the values are the number of times the word
    appears in the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DocumentParser class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, this class converts a document stored in a file in
    a document in a `Document` object. It splits this word into three methods. The
    first one is the `parse()` method that receives the path to the file as a parameter
    and returns a `HashMap` with the vocabulary of that document. This method reads
    the file line by line and uses the `parseLine()` method to convert each line in
    a list of words and add them to the vocabulary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseLine()` method processes the line extracting its words. We consider
    that a word is a sequence of alphabetical characters to continue with the simplicity
    of this example. We have used the `Pattern` class to extract the words and the
    `Normalizer` class to convert the words to lower case and delete the accents of
    the vowels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The serial version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The serial version of this example is implemented in the `SerialIndexing` class.
    This class has the `main()` method that reads all the documents, gets its vocabulary,
    and constructs the inverted index in an incremental way.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize the necessary variables. The collection of documents is
    stored in the data directory, so we store all the documents in an array of `File`
    objects. We also initialize the `invertedIndex` object. We use a `HashMap` where
    the keys are the words and the values are a list of string objects with the name
    of the files that contain the word as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we parse all the documents using the `DocumentParse` class and use the
    `updateInvertedIndex()` method to add the vocabulary obtained from each document
    into the inverted index. We measure the execution time of all the process. We
    have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we show the results of the execution in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `updateInvertedIndex()` method adds the vocabulary of a document into the
    inverted index structure. It processes all the words that form the vocabulary.
    If the word exists in the inverted index, we add the name of the document to the
    list of documents associated with that word. If the word doesn''t exists, we add
    the word and associate the document with that word as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first concurrent version – a task per document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to implement the concurrent version of the text indexing algorithm.
    Clearly, we can parallelize the process of every document. This includes reading
    the document from the file and processing every line to get the vocabulary of
    the document. The tasks can return that vocabulary as their result, so we can
    implement tasks based in the `Callable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have used three methods to send `Callable` tasks
    to the executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`submit()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAll()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAny()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to process all the documents, so we have to discard the `invokeAny()`
    method. The other two methods are inconvenient. If we use the `submit()` method,
    we have to decide when we process the results of the task. If we send a task per
    document, we can process the results:'
  prefs: []
  type: TYPE_NORMAL
- en: After sending every task, this is nonviable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the finalization of all the tasks, we have to store a lot of `Future`
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After sending a group of tasks, we have to include code to synchronize both
    operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these approaches have a problem: we process the results of the tasks in
    a sequential way. If we use the `invokeAll()` method, we are in a situation similar
    to point 2\. We have to wait for the finalization of all the tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: One possible option is to create other tasks to process the `Future` objects
    associated with every task, and the Java concurrency API provides us with an elegant
    solution to implement this solution with the `CompletionService` interface and
    its implementation, the `ExecutorCompletionService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `CompletionService` object is a mechanism that has an executor and allows
    you to decouple the production of tasks and the consumption of the results of
    those tasks. You can send tasks to the executor using the `submit()` method and
    get the results of the tasks when they finish using the `poll()` or `take()` methods.
    So, for our solution, we are going to implement the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A `CompletionService` object to execute the tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task per document to parse the document and generate its vocabulary. This
    task will be executed by the `CompletionService` object. These tasks are implemented
    in the `IndexingTask` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two threads to process the results of the tasks and construct the inverted index.
    These threads are implemented in the `InvertedIndexTask` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `main()` method to create and execute all the elements. This `main()` method
    is implemented in the `ConcurrentIndexingMain` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze the source code of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The IndexingTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class implements the tasks that will parse a document to obtain its vocabulary.
    It implements the `Callable` interface parameterized with the `Document` class.
    It has an internal attribute to store the `File` object that represents the document
    it has to parse. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `call()` method, it simply uses the `parse()` method of the `DocumentParser`
    class to parse the document and obtain the vocabulary and create and return the
    `Document` object with the data obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The InvertedIndexTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class implements the tasks that get the `Document` objects generated by
    the `IndexingTask` objects and construct the inverted index. This tasks will be
    executed as `Thread` objects (we don't use an executor in this case), so they
    are based in the `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InvertedIndexTask` class uses three internal attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: A `CompletionService` object parameterized with the `Document` class to get
    access to the objects returned by the `IndexingTask` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ConcurrentHashMap` to store the inverted index. The keys are the words and
    the values are `ConcurrentLinkedDeque` of string with the names of the files.
    In this case, we have to use concurrent data structures, and the ones used in
    the serial version are not synchronized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean value to indicate to the task that it can finish its work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` method uses the method `take()` from `CompletionService` to obtain
    the `Future` object associated with a task. We implement a loop that will be running
    until the thread is interrupted. Once the thread has been interrupted, it processes
    all the pending `Future` objects using the `take()` method again. We update the
    inverted index using the `updateInvertedIndex()` method with the object returned
    by the `take()` method. We have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `updateInvertedIndex` method receives the vocabulary obtained
    from a document, the inverted index, and the name of the file that has been processed
    as parameters. It processes all the words from the vocabulary. We use the `computeIfAbsent()`
    method to add the word to `invertedIndex` if it''s not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The ConcurrentIndexing class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the main class in the example. It creates and launches all the components,
    waits for its finalization, and prints the final execution time in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it creates and initializes all the variables needed for its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: An executor to run the `InvertedTask` tasks. As with the previous examples,
    we use the number of cores of the machine as the maximum number of work threads
    in the executor, but in this case, we leave one core to execute the independent
    threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `CompletionService` object to run the tasks. We use the executor created before
    to initialize this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ConcurrentHashMap` to store the inverted index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of `File` objects with all the documents we have to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we process all the files of the array. For every file, we create a `InvertedTask`
    object and send it to the `CompletionService` class using the `submit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create two `InvertedIndexTask` objects to process the results returned
    by the `InvertedTask` tasks and execute them as normal `Thread` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once we have launched all the elements, we wait for the finalization of the
    executor using the `shutdown()` and the `awaitTermination()` methods. The `awaitTermination()`
    method will return when all the `InvertedTask` tasks have finished its execution,
    so we can finish the threads that execute the `InvertedIndexTask` tasks. To do
    this, we interrupt these threads (see my comment about `InvertedIndexTask`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we write the size of the inverted index and the execution time of
    all the process in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The second concurrent version – multiple documents per task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented a second concurrent version of this example. The basic principles
    are the same as the first version, but, in this case, each task will process more
    that one document instead of only one. The number of documents processed by each
    task will be an input parameter of the main method. We have tested the results
    with 100, 1,000, and 5,000 documents per task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this new approach, we are going to implement three new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MultipleIndexingTask` class, which is equivalent to the `IndexingTask`
    class, but it will process a list of documents instead of only one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MultipleInvertedIndexTask` class, which is equivalent to the `InvertedIndexTask`
    class, but now the tasks will retrieve a list of `Document` objects instead of
    only one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MultipleConcurrentIndexing` class, which is equivalent to the `ConcurrentIndexing`
    class but using the new classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As much of the source code is similar to the previous version, we only show
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: The MultipleIndexingTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, this class is similar to the `IndexingTask` class
    presented before. The main difference is that it uses a list of `File` objects
    instead of only one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `call()` method returns a list of `Document` objects instead of only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The MultipleInvertedIndexTask class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned before, this class is similar to `InvertedIndexClass` presented
    earlier. The main difference is in the `run()` method. The `Future` object returned
    by the `poll()` method returns a list of `Document` objects, so we have to process
    the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The MultipleConcurrentIndexing class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, this class is similar to the `ConcurrentIndexing`
    class. The only difference is the utilization of the new classes and the use of
    the first parameter to determine the number of documents processed per task. We
    have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's compare the solutions of the three versions of the example we have implemented.
    As we mentioned earlier, like document collection, we have taken the Wikipedia
    pages with information about movies to construct a set of 100,673 documents. We
    have converted each Wikipedia page in a text file. You can download this document
    collection with all the information about the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have executed five different versions of the solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: The serial version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent version with one task per document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent version with multiple tasks per document, with 100, 1,000, and
    5,000 documents per task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the execution time of the five versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Execution time (milliseconds) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Serial | 69,480.50 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: one document per task | 49,655.49 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: 100 documents per task | 48,438.14 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: 1,000 documents per task | 49,362.37 |'
  prefs: []
  type: TYPE_TB
- en: '| Concurrent: 5,000 documents per task | 58,362.22 |'
  prefs: []
  type: TYPE_TB
- en: 'We can draw the following conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent versions always obtain better performance than the serial one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the concurrent versions, if we increase the number of documents per task,
    we obtain worse results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we compare the concurrent version with the serial one using the speed-up,
    the results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing the solutions](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Other methods of interest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have used some methods of the `AbstractExecutorService`
    interface (implemented in the `ThreadPoolExecutor` class) and `CompletionService`
    interfaces (implemented in the `ExecutorCompletionService`) to manage the results
    of `Callable` tasks. However, there are other versions of the methods we have
    used and other methods we want to mention here.
  prefs: []
  type: TYPE_NORMAL
- en: 'About the `AbstractExecutorService` interface, let''s discuss the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAll (Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method returns a list of `Future` objects associated with the list
    of `Callable` tasks passed as parameters when all the tasks have finished its
    execution or the timeout specified by the second and third parameters expires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAny (Collection<? Extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method returns the result of the first task of the list of `Callable`
    tasks passed as a parameter that finishes its execution without throwing an exception
    if it finishes before the timeout specified by the second and third parameters
    expires. If the timeout expires, the method throws a `TimeoutException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About the `CompletionService` interface, let''s discuss the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `poll()` method: We have used a version of this method with two parameters,
    but there is also a version without parameters. From the internal data structures,
    this version retrieves and removes the `Future` object of the next task that has
    finished since the last call to the `poll()` or `take()` methods. If no tasks
    have finished, its execution returns a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `take()` method: This method is similar to the previous one, but if no
    tasks have finished, it sleeps the thread until one task finishes its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the different mechanisms that you can use to work
    with tasks that return a result. These tasks are based on the `Callable` interface,
    which declares the `call()` method. This is a parameterized interface with the
    class returned by the `call` method.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute a `Callable` task in an executor, you will always obtain an
    implementation of the `Future` interface. You can use this object to cancel the
    execution of the task, know if the task has finished its execution or get the
    result returned by the `call()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You send `Callable` tasks to the executor using three different methods. With
    the `submit()` method, you send one task, and you will get immediately a `Future`
    object associated with this task. With the `invokeAll()` method, you send a list
    of tasks and will get a list of `Future` objects when all the tasks have finished
    its execution. With the `invokeAny()` method, you send a list of tasks, and you
    will receive the result (not a `Future` object) of the first task that finishes
    without throwing an exception. The rest of the tasks are canceled.
  prefs: []
  type: TYPE_NORMAL
- en: The Java concurrency API provides another mechanism to work with these kind
    of tasks. This mechanism is defined in the `CompletionService` interface and implemented
    in the `ExecutorCompletionService` class. This mechanism allows you to decouple
    the execution of tasks and the processing of their results. The `CompletionService`
    interface works internally with an executor and provides the `submit()` method
    to send tasks to the `CompletionService` interface and the `poll()` and `take()`
    methods to get the results of the tasks. These results are provided in the same
    order in which tasks finish their execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also learned to implement these concepts with two real-world examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A best-matching algorithm using the UKACD dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inverted index constructor, using a dataset with more than 1,00,000 documents
    with information of movies extracted from Wikipedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next chapter, you will learn how to execute algorithms in a concurrent
    way that can be divided into phases, for example, a keyword extraction algorithm.
    You can implement that algorithm in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – parse all the documents and extract all the words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 2 – calculate the importance of each word on each document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 3 – obtain the best keywords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main characteristic of these steps is that you must finish one completely
    before you can start the next one. Java concurrency API provides the `Phaser`
    class to facilitate the concurrent implementation of these algorithms. It allows
    you to synchronize all the tasks involved on it at the end of a phase, so none
    of them will start the next one until all have finished the current one.
  prefs: []
  type: TYPE_NORMAL
