- en: Adding a User Login and API Authentication with Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we allowed the user to save their favorite Vuebnb listings.
    This feature was only implemented in the frontend app though, so if the user reloaded
    the page their selections would be lost.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll create a user login system and persist saved items to
    the database so they can be retrieved after a page refresh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a user login system utilizing Laravel's built-in authentication features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a login form with CSRF protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vuex actions for asynchronous operations in the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the OAuth protocol for API authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Laravel Passport to allow authenticated AJAX requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to save listing items to the database, we first need a user model,
    as we want each user to have their own unique list. Adding a user model means
    we'll also need an authentication system so that users can sign in and out. Fortunately,
    Laravel provides a full-featured user model and authentication system out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the user model boilerplate files to see what modifications
    will be needed to fit them for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking first at the database migration, the user table schema already includes
    ID, name, email, and password columns.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/migrations/2014_10_12_000000_create_users_table.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This schema will be sufficient for our needs if we add an additional column
    for storing the saved listing IDs. Ideally, we'd store these in an array, but
    since relational databases don't have an array column type, we will instead store
    them as a serialized string, for example, [1, 5, 10] within a `text` column.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/migrations/2014_10_12_000000_create_users_table.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now take a look now at the `User` model class that Laravel provides.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/User.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default configuration is fine, but let's allow the `saved` attribute to
    be mass assignable by adding it to the `$fillable` array.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also get our model to serialize and deserialize the `saved` text when
    we read it or write it. To do this we can add a `$casts`attribute to the model
    and cast `saved` as an array.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/User.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can treat the `saved` attribute as an array, even though it''s stored
    as a string in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Seeder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a normal web app with a login system, you''d have a registration page so
    users can create their own accounts. To ensure this book doesn''t get too long,
    we''ll skip that feature and instead generate user accounts with a database seeder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can implement a registration page for Vuebnb yourself if you want. The Laravel
    documentation covers it quite thoroughly at [https://laravel.com/docs/5.5/authentication](https://laravel.com/docs/5.5/authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Let's create at least one account with a name, email, password, and an array
    of saved listings. Note that I've used the `make` method of the `Hash` facade
    to hash the password rather than storing it as plain-text. Laravel's default `LoginController`
    will automatically verify plain-text passwords against the hash during the login
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/seeds/UsersTableSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To run the seeder we need to call it from the main `DatabaseSeeder` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`database/seeds/DatabaseSeeder.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now rerun our migrations and seeder to install the user table and data
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm that our user table and data were created correctly, we''ll use
    Tinker to query the table. You should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Login system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our user model created, we can implement the rest of the login
    system. Again, Laravel includes this as an out-of-the-box feature, so there is
    only a small amount of configuration for us to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overview of how the login system works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user provides their email and password in a login form. We'll create this
    form with Vue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The form is submitted to the `/login` POST route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `LoginController` will then verify the user's credentials against the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the login is successful, the user is redirected to the home page. A session
    cookie is attached to the response, which is then passed to all outgoing requests
    to verify the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a diagrammatic representation of the login system for further clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d2939bb2-239e-4662-839b-ed986a6a665b.png)Figure 9.1\. Login flow'
  prefs: []
  type: TYPE_NORMAL
- en: LoginPage component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need a login page for our app, so let''s create a new page component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll begin by defining the template markup, which includes a form with fields
    for email and password, and a submit button. The form uses the HTTP POST method
    and is sent to the `/login`path. I've wrapped the form elements in a `div` with
    the `.form-controller` class to help with styling.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/LoginPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We don't need any JavaScript functionality just yet, so let's add our CSS rules
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/LoginPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We'll add a `login-container` class to our global CSS file so the footer for
    this page aligns correctly. We'll also add a CSS rule to ensure text inputs display
    correctly on iPhone. The login page will be the only place we'll have a text input,
    but let's add it as a global rule in case you decide to add other forms later.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's add this new page component to our router. We'll first import
    the component then add it to our `routes` array in the router configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the login page does not require any data from the server like the
    other pages of Vuebnb do. This means that we can skip the data-fetching step by
    modifying the logic of the first `if` statement in the navigation guard. It should
    now resolve straightaway if the name of the route is `login`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Server routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've added a login page at the `/login` route, we will need to create
    a matching server-side route. We will also need a route for the login form that
    posts to the same `/login` path.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, both of these routes are provided out-of-the-box by Laravel as part
    of its default login system. All we have to do to activate the routes is add the
    following line to the bottom of our web route file.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the effect of this code, we can use Artisan to show a list of the routes
    in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6f43ce1-9bb9-41e4-bf13-9f4f04b0ae0a.png)Figure 9.2\. Terminal output
    showing routes list'
  prefs: []
  type: TYPE_NORMAL
- en: You'll see all the routes that we've manually created, plus a few that we didn't,
    for example, *login*, *logout*, and *register*. These are the routes used by Laravel's
    authentication system that we just activated.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the GET/HEAD `/login`route, you'll see that it points to the `LoginController`controller.
    Let's take a look at that file.
  prefs: []
  type: TYPE_NORMAL
- en: '`App\Http\Controllers\Auth\LoginController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This class uses an  `AuthenticatesUsers` trait thatdefines the `showLoginForm`
    method that the `/login` route handler refers to. Let's overwrite that method
    so it simply returns our app view. Since this instance of the view doesn't need
    any data to be inlined in the head (the login form has no state), we will pass
    an empty array to the `data` template variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`App\Http\Controllers\Auth\LoginController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we can now see our complete login page by navigating the browser
    to `/login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb73b6fd-67d9-479c-82da-240cb763fd71.png)Figure 9.3\. Login page'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF (cross-site request forgery) is a type of malicious exploit where an attacker
    gets a user to unknowingly perform an action on a server that they're currently
    logged in to. This action will change something on the server that is advantageous
    to the attacker, for example, transfer money, change the password to one the attacker
    knows, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an attacker might hide a script in a web page or email and direct
    the user to it somehow. When it executes, this script could make a POST request
    to `importantwebsite.com/updateEmailAndPassword`. If the user is logged in to
    this site, the request may be successful.
  prefs: []
  type: TYPE_NORMAL
- en: One way to prevent this kind of attack is to embed a special token, essentially
    a random string, in any form that a user might submit. When the form is submitted,
    the token is checked against the user's session to make sure it matches. An attacker
    won't be able to forge this token in their script and should, therefore, be thwarted
    by this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Laravel, CSRF token creation and verification is managed by the `VerifyCsrfToken`
    middleware that is added to the web routes by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48ea4473-071f-4ed7-bafe-d910cdeec8e5.png)Figure 9.4\. CSRF prevention
    process'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the CSRF token in a form you can simply add `{{ csrf_field() }}`
    within the `form` tag. This will generate a hidden input field containing a valid
    CSRF token, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This won't work in our scenario, though, as our form is not inside a Blade view
    but inside a single-file component that will not get processed by Blade. As an
    alternative, we can add the CSRF token to the head of the page and assign it to
    the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/views/app.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can now retrieve this from within our Vue.js app and manually add it to the
    login form. Let's modify `LoginPage` to include a hidden `input` field in the
    form. We'll add some state to this component now, in which the token is included
    as a data property and bound to the hidden field.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/components/LoginPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to log in to our app using the credentials of the user we created
    in the seeder, we''ll get served this error page. Looking in the address bar,
    you''ll see that the route we''re on is `/home`, which is not a valid route within
    our app, hence the `NotFoundHttpException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99d47c43-15ff-4837-b68a-36b6f618ced3.png)Figure 9.5\. Invalid route'
  prefs: []
  type: TYPE_NORMAL
- en: Post-login redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user logs in, Laravel will redirect them to a page defined by the `$redirectTo`attribute
    in the login controller. Let's change this from `/home` to `/`.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Auth/Controllers/LoginController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's also update the `RedirectIfAuthenticated` middleware class so that if
    a logged-in user attempts to view the login page, they're redirect to `/` (instead
    of the default `/home` value.)
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Middleware/RedirectIfAuthenticated.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With that done, our login process will now work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication links to the toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now add login and logout links in the toolbar so Vuebnb users can easily
    access these features.
  prefs: []
  type: TYPE_NORMAL
- en: The login link is simply a `RouterLink` pointing to the `login` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logout link is a bit more interesting: we capture the click event from
    this link and trigger the submission of a hidden form. This form sends a POST
    request to the `/logout` server route, which logs the user out and redirects them
    back to the home page. Note that we must include the CSRF token as a hidden input
    for this to work.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Protecting the saved route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use our login system now to protect certain routes from guests, that
    is, unauthenticated users. Laravel provides the `auth` middleware, which can be
    applied to any route and will redirect a guest user to the login page if they
    attempt to access it. Let's apply this to our saved page route.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you log out of the application and attempt to access this route from the
    navigation bar of your browser, you'll find it redirects you back to `/login`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing authentication state to the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a complete mechanism for logging users in and out of Vuebnb. However,
    the frontend app is not yet aware of the user's authentication state. Let's remedy
    that now so we can add authentication-based features to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: auth meta property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin by adding the authentication state to the meta information we pass
    through in the head of each page. We'll utilize the `Auth` facade `check` method,
    which returns `true` if the user is authenticated, and assign this to a new `auth` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We'll also add an `auth` property to our Vuex store. We'll mutate it from the `addData` method
    which, as you'll recall from the previous chapter, is where we retrieve data from
    the document head or API. Since the API does not include meta data, we'll conditionally
    mutate the `auth` property to avoid accessing a potentially undefined object property.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, Vuex is now tracking the authentication state of the user.
    Be sure to test this out by logging in and out and noticing the value of `auth` in
    the Vuex tab of Vue Devtools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a51dc23b-ea82-4394-b040-bc876b474174.png)Figure 9.6\. Value of auth in
    Vue Devtools'
  prefs: []
  type: TYPE_NORMAL
- en: Responding to authenticated state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're tracking the authentication state of the user, we can get Vuebnb
    to respond to it. For one, let's make it so that a user can't save a listing unless
    they're logged in. To do this, we'll modify the behavior of the `toggleSaved`
    mutator method so that if the user is logged in they can save an item, but if
    not they are redirected to the login page via the `push` method of Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we'll have to import our router module at the top of the file to access
    its features.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We'll also make it so that either the login link or the logout link is shown
    in the toolbar, never both. This can be achieved by using `v-if` and `v-else` directives
    in the toolbar that depend on the `$store.state.auth` value.
  prefs: []
  type: TYPE_NORMAL
- en: It would also make sense to hide the saved page link unless the user is logged
    in, so let's do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the toolbar will look now, depending on whether the user is logged
    in or out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c0883d4-739c-4010-a983-62e5d8b00ef4.png)Figure 9.8\. Comparison
    of the logged in and logged out state in toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving saved items from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now work on retrieving the saved items from the database and displaying
    them in the frontend. To begin with, we'll add a new `saved` property to the metadata
    we put in the document head. This will be an empty array if the user is logged
    out, or the array of saved listing IDs associated with that user, if they're logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/ListingController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Back in the frontend, we'll put the logic for retrieving the saved items in
    the `beforeEach` router navigation guard. The reason we put it here and not in
    the `addData` mutation is that we don't want to directly assign the data to the
    store state, but instead call the `toggleSaved` mutation for each of the listings.
    You can't commit a mutation from another mutation, so this must be done outside
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's also remove the placeholder listing IDs we added to `saved` in the previous
    chapter so the store is empty upon initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we should find that the saved listings in the database now
    match those in the frontend if we check with Vue Devtools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/331bfe47-6056-44d8-a730-a77832088b03.png)Figure 9.8\. Vuex tab of
    Vue Devtools shows saved listings match database'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting saved listings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mechanism for persisting saved listings is as follows: when a listing is
    toggled in the frontend app, we trigger an AJAX request that POSTs the ID to a
    route on the backend. This route calls a controller that will update the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d82c6ee-a246-4db9-8fbf-4d2056374558.png)Figure 9.9\. Persisting
    saved listings'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin on the server side and add a route for the frontend to POST listing
    IDS to. We'll need to add the `auth` middleware so that only authenticated users
    can access this route (we'll discuss the meaning of `:api` shortly).
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/api.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is an API route, its full path will be `/api/user/toggle_saved`.
    We haven''t yet created the controller that this route calls, `UserController`,
    so let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this new controller, we'll add the `toggled_saved` handling method. Since
    this is an HTTP POST route, this method will have access to the form data. We'll
    make it so that the frontend AJAX call to this route includes an `id` field, which
    will be the listing ID we want to toggle. To access this field, we can use the `Input` facade,
    that is, `Input::get('id');`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're using the `auth` middleware on this route, we can retrieve the user
    model associated with the request by using the `Auth::user()` method. We can then
    either add or remove the ID from the user's `saved` listings, just as we do in
    the `toggledSaved` method in our Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: Once the ID is toggled, we can then use the model's `save` method to persist
    the update to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Controllers/UserController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Vuex actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](a05bfc41-f7fe-471f-a964-205c36fe528d.xhtml), *Managing Your Application
    State With Vuex*, we discussed the key principles of the Flux pattern, including
    the principle that mutations must be synchronous to avoid race conditions that
    make our application data unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a need to include asynchronous code in a mutator method, you should
    instead create an *action*. Actions are like mutations, but instead of mutating
    the state, they commit mutations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By abstracting asynchronous code into actions we can still centralize any state-altering
    logic in the store without tainting our application data through race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now use AJAX to make the request to `/api/user/toggle_saved` when a listing
    is saved. We'll put this logic into a Vuex action so that the `toggleSaved` mutation
    is not committed until the AJAX call resolves. We'll import the Axios HTTP library
    into the store to facilitate this.
  prefs: []
  type: TYPE_NORMAL
- en: Also, let's move the authentication check from the mutation to the action, as
    it makes sense to do this check before the AJAX call is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We now need to call the `toggledSaved` action, not the mutation, from our `ListingSave` component.
    Calling an action is done in exactly the same way as a mutation, only the terminology
    changes from `commit` to `dispatch`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this feature in the frontend is correct, but if we test it out
    and try and save an item we get a *401 Unauthenticated* error from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41cc0829-043d-44ae-ac6c-f008896dd103.png)Figure 9.10\. AJAX call
    results in a 401 Unauthenticated error'
  prefs: []
  type: TYPE_NORMAL
- en: API authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added the `auth` middleware to our `/api/user/toggle_saved` route to protect
    it from guest users. We also specified the `api` guard for this middleware, that
    is, `auth:api`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Guards* define how users are authenticated and are configured in the following
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '`config/auth.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our web routes use the *session* driver which maintains authentication state
    using session cookies. The session driver ships with Laravel and works out-of-the-box.
    API routes, though, use the *token* guard by default. We have not yet implemented
    this driver, hence our AJAX calls are unauthorized.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the session driver for API routes as well, but this is not recommended,
    as session authentication is not sufficient for AJAX requests. We're instead going
    to use the `passport` guard, which implements the OAuth protocol.
  prefs: []
  type: TYPE_NORMAL
- en: You may see `auth` used as a shorthand for `auth:web`, as the web guard is the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is an authorization protocol that allows third-party applications to access
    a user's data on a server without exposing their password. Access to this protected
    data is given in exchange for a special token that is granted to the application
    once it, and the user, have identified themselves to the server. A typical use
    case for OAuth is *social login*, for example,when you utilize a Facebook or Google
    login for your own website.
  prefs: []
  type: TYPE_NORMAL
- en: One challenge of making secure AJAX requests is that you can't store any credentials
    in the frontend source code, as it's trivial for an attacker to find these. A
    simple implementation of OAuth, where the third-party application is actually
    your own frontend app, is a good solution to the issue. This is the approach we'll
    be taking now for Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: While OAuth is a great solution for API authentication, it is also quite an
    in-depth topic that I can't fully cover in this book. I recommend you read this
    guide to get a better understanding: [https://www.oauth.com/](https://www.oauth.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel Passport is an implementation of OAuth that can easily be set up in
    a Laravel application. Let's install it now for use in Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Passport with Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Passport includes new database migrations that generate the tables needed to
    store OAuth tokens. Let''s run the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will install the encryption keys needed to generate secure
    tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, add the `Laravel\Passport\HasApiTokens` trait to
    the user model.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/User.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the `config/auth.php` configuration file, let's set the driver option
    of the API guard to `passport`. This ensures the `auth` middleware will use Passport
    as a guard for API routes.
  prefs: []
  type: TYPE_NORMAL
- en: '`config/auth.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Attaching tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth requires an access token to be sent to the frontend app when the user
    logs in. Passport includes a middleware that can handle this for you. Add the `CreateFreshApiToken` middleware
    to the web middleware group and the `laravel_token` cookie will be attached to
    outgoing responses.
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Http/Kernel.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For outgoing requests, we need to add some headers to our AJAX calls. We can
    make it so Axios automatically attaches these by default. `''X-Requested-With'':
    ''XMLHttpRequest''` ensures that Laravel knows the request was from AJAX, while `''X-CSRF-TOKEN'':
    window.csrf_token` attaches the CSRF token.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, our API requests should now be properly authenticated. To test
    this, let''s use Tinker to see which items we have saved for our first seeded
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you're logged in as that user and load Vuebnb in the browser. Toggle
    a few of your saved listing selections and rerun the query above. You should find
    that the database is now persisting the saved listing IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about authentication in full-stack Vue/Laravel apps,
    including session-based authentication for web routes, and token-based authentication
    for API routes using Laravel Passport.
  prefs: []
  type: TYPE_NORMAL
- en: We used this knowledge to set up a login system for Vuebnb, and to allow saved
    room listings to be persisted to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we also learned how to utilize CSRF tokens for securing forms,
    and about Vuex actions for adding asynchronous code to the store.
  prefs: []
  type: TYPE_NORMAL
- en: In the next, and final, chapter, we will learn how to deploy a full-stack Vue
    and Laravel app to production by deploying Vuebnb to a free Heroku PHP server.
    We will also begin serving images and other static content from a free CDN.
  prefs: []
  type: TYPE_NORMAL
