- en: Customizing Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting widget fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the options database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the cursor icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Text widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tags to the Text widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Tkinter widgets will display with a native look and feel. While
    this standard appearance could be enough for quick prototyping, we might want
    to customize some widget attributes, such as font, color, and background.
  prefs: []
  type: TYPE_NORMAL
- en: This customization does not affect only the widgets itself, but also its inner
    items. We will dive into the Text widget, which along with the Canvas widget is
    one of the most versatile Tkinter classes. The Text widget represents a multiline
    text area with formatted content, with several methods that make it possible to
    format characters or lines and add event-specific event bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Working with colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous recipes, we have set the colors of a widget using color names, such
    as white, blue, or yellow. These values are passed as strings to the `foreground`
    and `background` options, which modify the widget's text and background colors.
  prefs: []
  type: TYPE_NORMAL
- en: Color names are internally mapped to **RGB** values (an additive model that
    represents a color by its combination of red, green, and blue intensities), and
    this translation is based on a table that is platform-dependent. Therefore, if
    you want to consistently display the same color in different platforms, you can
    pass the RGB value to the widget options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to dynamically change the `foreground`
    and `background` options of a label that displays a fixed text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/2988a6bc-c48d-49b5-843b-b37f4a7f858a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Colors are specified in the RGB format and are selected by the user using a
    native color picker dialog. The following screenshot shows how this dialog looks
    on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/7be30749-7137-4489-9b0a-ed89b07827d5.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we will trigger the widget configuration with standard buttons—one
    for each option. The main difference with previous examples is that values can
    be directly chosen using the `askcolor` dialog from the `tkinter.colorchooser`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you want to check out the RGB value of a selected color, it is printed on
    the console when the dialog is confirmed, or none is shown if it is closed without
    selecting a color.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, both buttons use a partial function as callback. This
    is a utility from the `functools` module, which creates a new callable object
    that behaves like the original function, but with some fixed arguments. For instance,
    consider this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement performs the same action as the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We did this in order to reuse our `set_color()` method at the same time we introduce
    the `functools` module. These techniques are very useful in more complex scenarios,
    especially when you want to compose multiple functions and it is very clear that
    some arguments are already predefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'A minor detail to keep in mind is that we shorthanded `foreground` and `background`
    with `fg` and `bg`, respectively. These strings are unpacked with `**` when configuring
    the widget in this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`askcolor` returns a tuple with two items that represent the selected color—the
    first one is a tuple of integers that represent the RGB values, and the second
    one is the hexadecimal code as a string. Since the first representation cannot
    be directly passed to the widget options, we used the hexadecimal format.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case you want to translate a color name to the RGB format, you can use the
    `winfo_rgb()` method on a previously created widget. Since it returns a tuple
    of integers from 0 to 65535 to represent a 16-bit RGB value, you can convert it
    to the more common *#RRGGBB* hexadecimal representation by shifting 8 bits to
    the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used `{:02x}` to format each integer into two hexadecimal
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting widget fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Tkinter, it is possible to customize the font used in widgets that display
    text to the users, such as buttons, labels, and entries. By default, the font
    is system-specific, but you can change it using the `font` option.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application allows users to dynamically change the font family
    and size of a label with static text. Try around different values to see the results
    of the font configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/cd7bce85-0d22-479b-9990-315236013a54.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have two widgets to modify the font configuration: a drop-down option
    with font family names and a spinbox to enter the font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have set some default values for the Tkinter variables connected
    to each input.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FAMILIES` tuple contains the three font families that `Tk` guarantees
    to support on all platforms: `Times` (Times New Roman), `Courier`, and `Helvetica`.
    They can be switched with the `OptionMenu` widget, which is connected to the `self.family` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach is followed to set the font size with `Spinbox`. Both variables
    trigger the method that changes the `font` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The tuple passed to the `font` option can also define one or more of the following
    font styles: bold, roman, italic, underline, and strikethrough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the complete list of available font families for your platform
    with the `families()` method from the `tkinter.font` module. Since you need to
    instantiate the `root` window first, you can use the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter will not throw any error if you use a font family that is not included
    in the list of available families, but will try to match a similar font.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tkinter.font` module includes a `Font` class, which can be reused over
    multiple widgets. The main advantage of modifying a `font` instance is that it
    affects all the widgets that share it with the `font` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the `Font` class is very similar to using font descriptors. For
    example, this snippet creates a 18-pixel `Courier` bold font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve or change an option value, you can use the `cget` and `configure`
    methods as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the options database* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the options database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter defines a concept called *options database*, a mechanism used to customize
    the appearance of the application without having to specify it for each widget.
    It allows you to decouple some widget options from the individual widget configuration,
    providing standardized defaults based on the widget hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will build an application with several widgets that have
    different styling, which will be defined in the options database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/ed5977dc-0974-4b65-8e65-d56373bfdbf7.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example, we will add some options to the database through the `option_add()` method,
    which is accessible from all widget classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As a result, instead of configuring the font, `foreground` and `background`
    with the rest of the options, Tkinter will use the default values defined in the
    options database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by explaining each call to `option_add`. The first invocation
    adds an option that sets the `font` attribute to all the widgets—the wildcard
    represents any application name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next call restricts the match to an element with the `header` name—the
    more specific a rule is, the highest precedence it has. This name is later specified
    when instantiating the label with `name="header"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The same applies to `self.option_add("*subtitle.font", "helvetica 14 italic")`,
    so each option matches to a different named widget instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next options use the `Button` class name instead of an instance name. This
    way, you can refer to all widgets of a given class to provide some common defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned earlier, the options database uses the widget hierarchy
    to determine the options that apply to each instance, so if we have nested containers,
    they can also be used to restrict the options that take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: These configuration options are not applied to existing widgets, only to the
    ones created after modifying the options database. Therefore, we always recommend
    calling `option_add()` at the beginning of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some examples where each one is more specific than the preceding
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*Frame*background`: Matches the background of all the widgets within a frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*Frame.background`: Matches the background of all the frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*Frame.myButton.background`: Matches the background of the widget named `myButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*myFrame.myButton.background`: Matches the background of the widget named
    `myButton` inside the container named `myFrame`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of adding the options programmatically, it is also possible to define
    them in a separate text file using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This file should be loaded into the application using the `option_readfile()`
    method, and replaces all the calls to `option_add()`. In our example, let''s suppose
    the file is called `my_options_file` and it is placed in the same directory as
    our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the file does not exist or its format is invalid, Tkinter will raise `TclError`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with colors* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Setting widget fonts* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the cursor icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter allows you to customize the cursor icon while hovering over a widget.
    This behavior is sometimes enabled by default, like the Entry widget that displays
    an I-beam pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to display a busy cursor while it is performing
    a long-running operation, and a cursor with a question mark, typically used in
    help menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c660453b-6895-4f3e-a6ed-87a59c90693d.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mouse pointer icon can be changed using the `cursor` option. In our example,
    we used the `watch` value to display the native busy cursor and `question_arrow`
    to display the regular arrow with a question mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can check out a complete list of valid `cursor` values and the system-specific
    ones in the official Tcl/Tk documentation at [https://www.tcl.tk/man/tcl/TkCmd/cursors.htm](https://www.tcl.tk/man/tcl/TkCmd/cursors.htm).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a widget does not specify the `cursor` option, it takes the value defined
    in the parent container. Therefore, we can easily apply it to all widgets by setting
    it at the `root` window level. This is done by invoking `set_watch_cursor()` within
    the `perform_action()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception here is the `Help` button, which explicitly sets the cursor to `question_arrow`.
    This option can be directly set while instantiating the widget as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that if you click on the `Start!` button and place the mouse over the `Help`
    button before the scheduled method is invoked, the cursor will display as `help` instead
    of `watch`. This happens because if the `cursor` option of a widget is set, it
    takes precedence over the `cursor` defined in the parent container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we can save the current `cursor` value and change it to `watch`, and
    restore it later. The function that performs this operation can be called recursively
    in the child widget by iterating over the `winfo_children()` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added the `_old_cursor` property to each widget, so
    if you follow a similar approach, keep in mind that you cannot call `restore_cursor()`
    before `set_watch_cursor()`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Text widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Text widget offers an advanced functionality compared with other widget
    classes. It displays multiple lines of editable text that can be indexed by lines
    and columns. Additionally, you can refer to ranges of text using tags, which may
    define a customized appearance and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows basic use of the Text widget, where you can
    dynamically insert and remove text and retrieve the selected content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/a753a28a-5bb3-434a-8efd-712c2e758a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the `Text` widget, our application contains three buttons that call
    the methods to clear the whole text content, insert the `"Hello, world"` string in
    the current cursor position, and print the current selection made with the mouse
    or the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `Text` widget is initially empty, and it has a width of 50 characters and
    a height of 10 lines. Apart from allowing users to enter any type of text, we
    will dive into the methods used by each button to have a better understanding
    of how to interact with this widget.
  prefs: []
  type: TYPE_NORMAL
- en: The `delete(start, end)` method removes the content from the `start` index to
    the `end` index. If the second parameter is omitted, it only deletes the character
    at the `start` position.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we delete all the text by calling this method from the `1.0`
    index (column 0 of the first line) to the `tk.END` index, which refers to the
    last character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert(index, text)` method inserts the given text at the `index` position.
    Here, we call it with the `INSERT` index, which corresponds to the position of
    the insertion cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tag_ranges(tag)` method returns a tuple with the first and last indices
    of all the ranges with a given `tag`. We used the special `tk.SEL` tag to refer
    to the current selection. If there is no selection, this call would return an
    empty tuple. This is combined with the `get(start, end)` method, which returns
    the text in a given range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since the `SEL` tag corresponds to only one range, we can safely unpack it to
    call the `get` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tags to the Text widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to configure the behavior of a tagged range
    of characters within a `Text` widget.
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts are the same as those that apply to regular widgets, such as
    event sequences or configuration options, which have already been covered in previous
    recipes. The main difference is that we need to work with the text indices to
    identify the tagged content, instead of using object references.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how to use the text tags, we will create a `Text` widget that
    simulates the insertion of hyperlinks. When clicked, this link will open the selected
    URL with the default browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if the user enters the following content, the python.org text can
    be tagged as a hyperlink:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/8a673cd4-d0d1-438b-b1d9-44ae42a5aa4e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this application, we will define a tag named `"link"`, which represents
    a clickable hyperlink. This tag will be added to the current selection using a
    button, and the mouse click will trigger the event to open the link in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will initialize the tag by configuring the color and underline style.
    We add event bindings to open the clicked text with a browser and to change the
    cursor appearance while placing the mouse over the tagged text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `open_link` method, we transform the clicked position to the corresponding
    line and column using the `index` method of the `Text` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the position corresponding to the clicked index is `"@x,y"`, but we
    moved it to the next character. We do this because `tag_prevrange` returns the
    preceding range to the given index, so it will not return the current range if
    we click on the first character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will retrieve the text from the range and open it with the default
    browser using the `open` function from the `webbrowser` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the `webbrowser.open` function does not check whether the URL is valid,
    this application can be improved by including a basic hyperlink validation. For
    instance, you can use the `urlparse` function to verify that the URL has a network
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although this solution is not intended to handle some corner cases, it might
    serve as a first approach to discarding most invalid URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can use tags to create complex text-based programs, such as
    an IDE with syntax highlighting. In fact, IDLE—bundled in the default Python implementation—is
    based on Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Changing the cursor icon* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Introducing the Text widget* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
