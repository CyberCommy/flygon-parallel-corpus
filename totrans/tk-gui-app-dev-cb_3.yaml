- en: Customizing Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Working with colors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting widget fonts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the options database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the cursor icon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Text widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tags to the Text widget
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Tkinter widgets will display with a native look and feel. While
    this standard appearance could be enough for quick prototyping, we might want
    to customize some widget attributes, such as font, color, and background.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This customization does not affect only the widgets itself, but also its inner
    items. We will dive into the Text widget, which along with the Canvas widget is
    one of the most versatile Tkinter classes. The Text widget represents a multiline
    text area with formatted content, with several methods that make it possible to
    format characters or lines and add event-specific event bindings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Working with colors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous recipes, we have set the colors of a widget using color names, such
    as white, blue, or yellow. These values are passed as strings to the `foreground`
    and `background` options, which modify the widget's text and background colors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Color names are internally mapped to **RGB** values (an additive model that
    represents a color by its combination of red, green, and blue intensities), and
    this translation is based on a table that is platform-dependent. Therefore, if
    you want to consistently display the same color in different platforms, you can
    pass the RGB value to the widget options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to dynamically change the `foreground`
    and `background` options of a label that displays a fixed text:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/2988a6bc-c48d-49b5-843b-b37f4a7f858a.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Colors are specified in the RGB format and are selected by the user using a
    native color picker dialog. The following screenshot shows how this dialog looks
    on Windows 10:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/7be30749-7137-4489-9b0a-ed89b07827d5.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we will trigger the widget configuration with standard buttons—one
    for each option. The main difference with previous examples is that values can
    be directly chosen using the `askcolor` dialog from the `tkinter.colorchooser`
    module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want to check out the RGB value of a selected color, it is printed on
    the console when the dialog is confirmed, or none is shown if it is closed without
    selecting a color.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, both buttons use a partial function as callback. This
    is a utility from the `functools` module, which creates a new callable object
    that behaves like the original function, but with some fixed arguments. For instance,
    consider this statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding statement performs the same action as the following statement:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We did this in order to reuse our `set_color()` method at the same time we introduce
    the `functools` module. These techniques are very useful in more complex scenarios,
    especially when you want to compose multiple functions and it is very clear that
    some arguments are already predefined.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'A minor detail to keep in mind is that we shorthanded `foreground` and `background`
    with `fg` and `bg`, respectively. These strings are unpacked with `**` when configuring
    the widget in this statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`askcolor` returns a tuple with two items that represent the selected color—the
    first one is a tuple of integers that represent the RGB values, and the second
    one is the hexadecimal code as a string. Since the first representation cannot
    be directly passed to the widget options, we used the hexadecimal format.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case you want to translate a color name to the RGB format, you can use the
    `winfo_rgb()` method on a previously created widget. Since it returns a tuple
    of integers from 0 to 65535 to represent a 16-bit RGB value, you can convert it
    to the more common *#RRGGBB* hexadecimal representation by shifting 8 bits to
    the right:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we used `{:02x}` to format each integer into two hexadecimal
    numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Setting widget fonts
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Tkinter, it is possible to customize the font used in widgets that display
    text to the users, such as buttons, labels, and entries. By default, the font
    is system-specific, but you can change it using the `font` option.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application allows users to dynamically change the font family
    and size of a label with static text. Try around different values to see the results
    of the font configuration:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/cd7bce85-0d22-479b-9990-315236013a54.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have two widgets to modify the font configuration: a drop-down option
    with font family names and a spinbox to enter the font size:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we have set some default values for the Tkinter variables connected
    to each input.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FAMILIES` tuple contains the three font families that `Tk` guarantees
    to support on all platforms: `Times` (Times New Roman), `Courier`, and `Helvetica`.
    They can be switched with the `OptionMenu` widget, which is connected to the `self.family` variable.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach is followed to set the font size with `Spinbox`. Both variables
    trigger the method that changes the `font` label:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The tuple passed to the `font` option can also define one or more of the following
    font styles: bold, roman, italic, underline, and strikethrough:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can retrieve the complete list of available font families for your platform
    with the `families()` method from the `tkinter.font` module. Since you need to
    instantiate the `root` window first, you can use the following script:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tkinter will not throw any error if you use a font family that is not included
    in the list of available families, but will try to match a similar font.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tkinter.font` module includes a `Font` class, which can be reused over
    multiple widgets. The main advantage of modifying a `font` instance is that it
    affects all the widgets that share it with the `font` option.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the `Font` class is very similar to using font descriptors. For
    example, this snippet creates a 18-pixel `Courier` bold font:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To retrieve or change an option value, you can use the `cget` and `configure`
    methods as usual:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the options database* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the options database
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter defines a concept called *options database*, a mechanism used to customize
    the appearance of the application without having to specify it for each widget.
    It allows you to decouple some widget options from the individual widget configuration,
    providing standardized defaults based on the widget hierarchy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will build an application with several widgets that have
    different styling, which will be defined in the options database:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/ed5977dc-0974-4b65-8e65-d56373bfdbf7.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example, we will add some options to the database through the `option_add()` method,
    which is accessible from all widget classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a result, instead of configuring the font, `foreground` and `background`
    with the rest of the options, Tkinter will use the default values defined in the
    options database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by explaining each call to `option_add`. The first invocation
    adds an option that sets the `font` attribute to all the widgets—the wildcard
    represents any application name:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next call restricts the match to an element with the `header` name—the
    more specific a rule is, the highest precedence it has. This name is later specified
    when instantiating the label with `name="header"`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The same applies to `self.option_add("*subtitle.font", "helvetica 14 italic")`,
    so each option matches to a different named widget instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The next options use the `Button` class name instead of an instance name. This
    way, you can refer to all widgets of a given class to provide some common defaults:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we have mentioned earlier, the options database uses the widget hierarchy
    to determine the options that apply to each instance, so if we have nested containers,
    they can also be used to restrict the options that take precedence.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: These configuration options are not applied to existing widgets, only to the
    ones created after modifying the options database. Therefore, we always recommend
    calling `option_add()` at the beginning of your applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some examples where each one is more specific than the preceding
    one:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`*Frame*background`: Matches the background of all the widgets within a frame'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*Frame.background`: Matches the background of all the frames'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*Frame.myButton.background`: Matches the background of the widget named `myButton`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*myFrame.myButton.background`: Matches the background of the widget named
    `myButton` inside the container named `myFrame`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of adding the options programmatically, it is also possible to define
    them in a separate text file using the following format:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This file should be loaded into the application using the `option_readfile()`
    method, and replaces all the calls to `option_add()`. In our example, let''s suppose
    the file is called `my_options_file` and it is placed in the same directory as
    our script:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the file does not exist or its format is invalid, Tkinter will raise `TclError`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Working with colors* recipe
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Setting widget fonts* recipe
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the cursor icon
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter allows you to customize the cursor icon while hovering over a widget.
    This behavior is sometimes enabled by default, like the Entry widget that displays
    an I-beam pointer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows how to display a busy cursor while it is performing
    a long-running operation, and a cursor with a question mark, typically used in
    help menus:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c660453b-6895-4f3e-a6ed-87a59c90693d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mouse pointer icon can be changed using the `cursor` option. In our example,
    we used the `watch` value to display the native busy cursor and `question_arrow`
    to display the regular arrow with a question mark:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can check out a complete list of valid `cursor` values and the system-specific
    ones in the official Tcl/Tk documentation at [https://www.tcl.tk/man/tcl/TkCmd/cursors.htm](https://www.tcl.tk/man/tcl/TkCmd/cursors.htm).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a widget does not specify the `cursor` option, it takes the value defined
    in the parent container. Therefore, we can easily apply it to all widgets by setting
    it at the `root` window level. This is done by invoking `set_watch_cursor()` within
    the `perform_action()` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The exception here is the `Help` button, which explicitly sets the cursor to `question_arrow`.
    This option can be directly set while instantiating the widget as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that if you click on the `Start!` button and place the mouse over the `Help`
    button before the scheduled method is invoked, the cursor will display as `help` instead
    of `watch`. This happens because if the `cursor` option of a widget is set, it
    takes precedence over the `cursor` defined in the parent container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we can save the current `cursor` value and change it to `watch`, and
    restore it later. The function that performs this operation can be called recursively
    in the child widget by iterating over the `winfo_children()` list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we added the `_old_cursor` property to each widget, so
    if you follow a similar approach, keep in mind that you cannot call `restore_cursor()`
    before `set_watch_cursor()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Text widget
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Text widget offers an advanced functionality compared with other widget
    classes. It displays multiple lines of editable text that can be indexed by lines
    and columns. Additionally, you can refer to ranges of text using tags, which may
    define a customized appearance and behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows basic use of the Text widget, where you can
    dynamically insert and remove text and retrieve the selected content:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/a753a28a-5bb3-434a-8efd-712c2e758a2e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the `Text` widget, our application contains three buttons that call
    the methods to clear the whole text content, insert the `"Hello, world"` string in
    the current cursor position, and print the current selection made with the mouse
    or the keyboard:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `Text` widget is initially empty, and it has a width of 50 characters and
    a height of 10 lines. Apart from allowing users to enter any type of text, we
    will dive into the methods used by each button to have a better understanding
    of how to interact with this widget.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `delete(start, end)` method removes the content from the `start` index to
    the `end` index. If the second parameter is omitted, it only deletes the character
    at the `start` position.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we delete all the text by calling this method from the `1.0`
    index (column 0 of the first line) to the `tk.END` index, which refers to the
    last character:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `insert(index, text)` method inserts the given text at the `index` position.
    Here, we call it with the `INSERT` index, which corresponds to the position of
    the insertion cursor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `tag_ranges(tag)` method returns a tuple with the first and last indices
    of all the ranges with a given `tag`. We used the special `tk.SEL` tag to refer
    to the current selection. If there is no selection, this call would return an
    empty tuple. This is combined with the `get(start, end)` method, which returns
    the text in a given range:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `SEL` tag corresponds to only one range, we can safely unpack it to
    call the `get` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Adding tags to the Text widget
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to configure the behavior of a tagged range
    of characters within a `Text` widget.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: All the concepts are the same as those that apply to regular widgets, such as
    event sequences or configuration options, which have already been covered in previous
    recipes. The main difference is that we need to work with the text indices to
    identify the tagged content, instead of using object references.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how to use the text tags, we will create a `Text` widget that
    simulates the insertion of hyperlinks. When clicked, this link will open the selected
    URL with the default browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if the user enters the following content, the python.org text can
    be tagged as a hyperlink:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/8a673cd4-d0d1-438b-b1d9-44ae42a5aa4e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this application, we will define a tag named `"link"`, which represents
    a clickable hyperlink. This tag will be added to the current selection using a
    button, and the mouse click will trigger the event to open the link in a browser:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will initialize the tag by configuring the color and underline style.
    We add event bindings to open the clicked text with a browser and to change the
    cursor appearance while placing the mouse over the tagged text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Within the `open_link` method, we transform the clicked position to the corresponding
    line and column using the `index` method of the `Text` class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the position corresponding to the clicked index is `"@x,y"`, but we
    moved it to the next character. We do this because `tag_prevrange` returns the
    preceding range to the given index, so it will not return the current range if
    we click on the first character.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will retrieve the text from the range and open it with the default
    browser using the `open` function from the `webbrowser` module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the `webbrowser.open` function does not check whether the URL is valid,
    this application can be improved by including a basic hyperlink validation. For
    instance, you can use the `urlparse` function to verify that the URL has a network
    location:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although this solution is not intended to handle some corner cases, it might
    serve as a first approach to discarding most invalid URLs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个解决方案并不打算处理一些特殊情况，但它可能作为丢弃大多数无效URL的第一步。
- en: In general, you can use tags to create complex text-based programs, such as
    an IDE with syntax highlighting. In fact, IDLE—bundled in the default Python implementation—is
    based on Tkinter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您可以使用标签来创建复杂的基于文本的程序，比如带有语法高亮的IDE。事实上，IDLE——默认的Python实现中捆绑的——就是基于Tkinter的。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Changing the cursor icon* recipe
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更改光标图标*食谱'
- en: The *Introducing the Text widget* recipe
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍文本小部件*食谱'
