- en: '*Chapter 10*:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers a wide range of problems involving strings and arrays. Since
    Java strings and arrays are common topics for developers, I will briefly introduce
    them via several headlines that you must remember. However, if you need to deep
    dive into this topic, then consider the official Java documentation ([https://docs.oracle.com/javase/tutorial/java/](https://docs.oracle.com/javase/tutorial/java/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to tackle any problem involving
    Java strings and/or arrays. It is highly likely that they will show up in a technical
    interview. So, the topics that will be covered in this chapter are pretty short
    and clear:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and strings in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with a quick recap of strings and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code present in this chapter can be found on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and strings in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, arrays are objects and are dynamically created. Arrays can be assigned
    to variables of the `Object` type. They can have a single dimension (for example,
    `m[]`) or multiple dimensions (for example, as a three-dimensional array, `m[][][]`).
    The elements of an array are stored starting with index 0, so an array of length
    *n* stores its elements between indexes 0 and *n*-1 (inclusive). Once an array
    object is created, its length never changes. Arrays cannot be immutable except
    for the useless array of length 0 (for example, `String[] immutable = new String[0]`).
  prefs: []
  type: TYPE_NORMAL
- en: In Java, strings are immutable (`String` is immutable). A string can contain
    `char` data type (for example, calling `charAt(int index)` works as expected –
    `index` is the index varying from 0 to *string length* - 1). Unicode characters
    that exceed 65,535 until 1,114,111 (0x10FFFF) don't fit into 16 bits (Java `char`).
    They are stored as 32-bit integer values (known as *code points*). This aspect
    is detailed in the *Coding challenge 7 – Extracting code points of surrogate pairs*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful class for manipulating strings is `StringBuilder` (and the thread-safe
    `StringBuffer`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at some coding challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following 29 coding challenges, we''ll tackle a set of popular problems
    encountered in Java technical interviews done by medium to large companies (including
    Google, Amazon, Flipkart, Adobe, and Microsoft). Besides these 29 coding challenges
    (discussed in this book), you may like to check out the following non-exhaustive
    list of strings and arrays coding challenges that you can find in my other book,
    *Java Coding Problems* ([https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)),
    published by Packt as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Counting duplicate characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the first non-repeated character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing letters and words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a string contains only digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting vowels and consonants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the occurrences of a certain character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing white spaces from a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining multiple strings with a delimiter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether a string is a palindrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing duplicate characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a given character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the character with the most appearances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting an array of strings by length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking that a string contains a substring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting substring occurrences in a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether two strings are anagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring multiline strings (text blocks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating the same string *n* times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing leading and trailing spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the longest common prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying indentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding an element in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether two arrays are equal or mismatched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing two arrays lexicographically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum, maximum, and average of an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling and setting an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next greater element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing array size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 29 coding challenges tackled in this chapter are not covered in the preceding
    challenges and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Unique characters (1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if this string contains unique characters. The whitespaces can be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the following three valid given strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Strings
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is important to know that we can fetch any character between
    0 and 65,535 via the `charAt(int index)` method (`index` is the index varying
    from 0 to *string length* – 1) because these characters are represented in Java
    using the 16-bit `char` data type.
  prefs: []
  type: TYPE_NORMAL
- en: A simple solution to this problem consists of using a `Map<Character, Boolean>`.
    While we loop the characters of the given string via the `charAt(int index)` method,
    we try to put the character from `index` into this map and flip the corresponding
    `boolean` value from `false` to `true`. The `Map#put(K k, V v)` method returns
    `null` if there was no mapping for the given key (character). If there is a mapping
    for the given key (character), then `Map#put(K k, V v)` returns the previous value
    (in our case, `true`) associated with this key. So, when the returned value is
    not `null`, we can conclude that at least one character is duplicated, so we can
    say that the given string doesn't contain unique characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, before trying to put a character in the map, we ensure that its code
    ranges between 0 and 65,535 via `String#codePointAt(index i)`. This method returns
    the Unicode character at the specified `index` as an `int`, which is known as
    the *code point*. Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *UniqueCharacters*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Unique characters (2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if this string contains unique characters. The whitespaces can be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The solution presented in the preceding coding challenge covers
    this case as well. However, let''s try to come up with a solution specific to
    this case. The given string can contain only characters from *a-z*, so it can
    only contain ASCII codes from 97(*a*) to 122(*z*). Let''s consider that the given
    string is *afghnqrsuz*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we recall our experience from [*Chapter 9*](B15403_09_Final_JM_ePub.xhtml#_idTextAnchor181)*,
    Bit Manipulation*, then we can think of a bit mask that covers *a*-*z* letters
    with bits of 1, as shown in the following figure (the bits of 1 correspond to
    the letters of our string, *afghnqrsuz*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Unique characters bitmask'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Unique characters bit mask
  prefs: []
  type: TYPE_NORMAL
- en: If we represent each letter from *a-z* as a bit of 1, then we obtain a bit mask
    of the unique characters, similar to the one shown in the preceding image. Initially,
    this bit mask contains only 0s (since no letter has been processed, we have all
    bits equal to 0 or they're unset).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we peek at the first letter from the given string and we compute the subtraction
    between its ASCII code and 97 (the ASCII code of *a*). Let's denote this with
    *s*. Now, we create another bit mask by left shifting 1 by *s* positions. This
    will result in a bit mask that has the MSB of 1 followed by *s* bits of 0 (1000...).
    Next, we can apply the AND[&] operator between the bit mask of unique characters
    (which is initially 0000...) and this bit mask (1000...). The result will be 0000...
    since 0 & 1 = 0\. This is the expected result since this is the first processed
    letter, so there are no letters being flipped in the bit mask of unique characters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update the unique character's bit mask by flipping the bit from position
    *s* from 0 to 1\. This is done via the OR[|] operator. Now, the bit mask of unique
    characters is 1000.... There is a single bit of 1 since we flipped a single bit;
    that is, the one corresponding to the first letter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we repeat this process for each letter of the given string. If you
    encounter a duplicate, then the AND[&] operation between the bit mask of unique
    characters and the 1000... mask corresponding to the currently processed letter
    will return 1 (1 & 1 = 1). If this happens, then we have found a duplicate, so
    we can return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *UniqueCharactersAZ*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Encoding strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`char[]`, *str*. Write a snippet of code that replaces all whitespaces with
    a sequence, *%20*. The resulting string should be returned as a `char[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`char[]` represents the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The expected result is *%20%20String%20%20%20with%20spaces%20%20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We count the number of whitespaces in the given `char[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new `char[]` that's the size of the initial `char[]`, *str*,
    plus the number of whitespaces multiplied by 2 (a single whitespace occupies one
    element in the given `char[]`, while the *%20* sequences will occupy three elements
    in the resulting `char[]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we loop the given `char[]` and create the resulting `char[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *EncodedString*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – One edit away
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two given strings, *q* and *p*. Write a snippet of code
    that determines whether we can obtain two identical strings by performing a single
    edit in *q* or *p*. More precisely, we can insert, remove, or replace a single
    character in *q* or in *p*, and *q* will become equal to *p*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: To better understand the requirements, let''s consider several
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*tank, tanc* One edit: Replace *k* with *c* (or vice versa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tnk, tank* One edit: Insert *a* in *tnk* between *t* and *n* or remove *a*
    from *tank*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tank, tinck* More than one edit is needed!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tank, tankist* More than one edit is needed!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By inspecting these examples, we can conclude that we are one edit away if
    the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference in length between *q* and *p* is not bigger than 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q* and *p* are different in a single place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can easily check the difference in length between *q* and *p* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out whether *q* and *p* are different in a single place, we have to
    compare each character from *q* with each character from *p*. If we find more
    than one difference, then we return `false`; otherwise, we return `true`. Let''s
    see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *OneEditAway*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Shrinking a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** Consider a given string containing only letters *a-z* and whitespaces.
    This string contains a lot of consecutive repeated characters. Write a snippet
    of code that shrinks this string by counting the consecutive repeated characters
    and creating another string that appends each character and the number of consecutive
    occurrences. The whitespaces should be copied in the resulting string as they
    are (don''t shrink the whitespaces). If the resulting string is not shorter than
    the given string, then return the given string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider that the given string is *abbb vvvv s rttt rr eeee f*.
    The expected result will be *a1b3 v4 s1 r1t3 r2 e4 f1*. To count the consecutive
    characters, we need to loop this string character by character:'
  prefs: []
  type: TYPE_NORMAL
- en: If the current character and the next character are the same, then we increment
    a counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the next character is different from the current character, then we append
    the current character and the counter value to the final result, and we reset
    the counter to 0\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, after processing all the characters from the given string, we compare
    the length of the result with the length of the given string and we return the
    shortest string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StringShrinker*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Extracting integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given string containing whitespaces and *a-z* and *0-9*
    characters. Write a snippet of code that extracts integers from this string. You
    can assume that any sequence of consecutive digits forms a valid integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider that the given string is *cv dd 4 k 2321 2 11 k4k2 66
    4d*. The expected result will contain the following integers: 4, 2321, 2, 11,
    4, 2, 66, and 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A straightforward solution will loop the given string character by character
    and concatenate sequences of consecutive digits. A digit contains ASCII code between
    48 (inclusive) and 97 (inclusive). So, any character whose ASCII code is in the
    range [48, 97] is a digit. We can also use the `Character#isDigit(char ch)` method.
    When a sequence of consecutive digits is interrupted by a non-digit character,
    we can convert the harvested sequence into an integer and append it as a list
    of integers. Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *ExtractIntegers*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Extracting the code points of surrogate pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given string containing any kind of characters, including
    Unicode characters, that are represented in Java as *surrogate pairs*. Write a
    snippet of code that extracts the *code points* of the *surrogate pairs* in a
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given string contains the Unicode characters
    shown in the following image (the first three Unicode characters are represented
    in Java as *surrogate pairs*, while the last one is not):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Unicode characters (surrogate pairs)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Unicode characters (surrogate pairs)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we can write such a string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this problem, we must know several things, as follows (it is advisable
    to keep the following statements in mind since they are vital for solving problems
    that involve Unicode characters):'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters that exceed 65,535 until 1,114,111 (0x10FFFF) don't fit into
    16 bits, and so 32-bit values (known as *code points*) were considered for the
    UTF-32 encoding scheme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, Java doesn''t support UTF-32! Nevertheless, Unicode has come
    up with a solution for still using 16 bits to represent these characters. This
    solution implies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '16-bit *high surrogates*: 1,024 values (U+D800 to U+DBFF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '16-bit *low surrogates*: 1,024 values (U+DC00 to U+DFFF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, a *high surrogate* followed by a *low surrogate* defines what is known
    as a *surrogate pair*. These *surrogate pairs* are used to represent values between
    65,536 (0x10000) and 1,114,111 (0x10FFFF).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java takes advantage of this representation and exposes it via a suite of methods,
    such as `codePointAt()`, `codePoints()`, `codePointCount()`, and `offsetByCodePoints()`
    (take a look at the Java documentation for details).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `codePointAt()` instead of `charAt()`, `codePoints()` instead of `chars()`,
    and so on helps us write solutions that cover ASCII and Unicode characters as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the well-known two-hearts symbol (first symbol in the preceding
    image) is a Unicode surrogate pair that can be represented as a `char[]` containing
    two values: \uD83D and \uDC95\. The *code point* of this symbol is 128149\. To
    obtain a `String` object from this code point, call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Counting the code points in `str` can be done by calling `str.codePointCount(0,str.length())`,
    which returns 1, even if the `str` length is 2\. Calling `str.codePointAt(0)`
    returns 128149, while calling `str.codePointAt(1)` returns 56469\. Calling `Character.toChars(128149).length`
    returns 2 since two characters are needed to represent this *code point* as a
    Unicode *surrogate pair*. For ASCII and Unicode 16-bit characters, it will return
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this example, we can identify a *surrogate pair* quite easily, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *ExtractSurrogatePairs*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Is rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two given strings, *str1* and *str2*. Write a single
    line of code that tell us whether *str2* is a rotation of *str1*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that *str1* is *helloworld* and *str2* is *orldhellow*.
    Since *str2* is a rotation of *str1*, we can say that *str2* is obtained by cutting
    *str1* into two parts and rearranging them. The following image shows these words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Cutting str1 into two parts and rearranging them'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Cutting str1 into two parts and rearranging them
  prefs: []
  type: TYPE_NORMAL
- en: 'So, based on this image, let''s denote the left-hand side of the scissor as
    *p1* and the right-hand side of the scissor as *p2*. With these notations, we
    can say that *p1 = hellow* and *p2 = orld*. Moreover, we can say that *str1 =
    p1+p2 = hellow + orld* and *str2 = p2+p1 = orld + hellow*. So, no matter where
    we perform the cut of *str1*, we can say that *str1 = p1+p2* and *str2=p2+p1*.
    However, this means that *str1+str2 = p1+p2+p2+p1 = hellow + orld + orld + hellow
    = p1+p2+p1+p2 = str1 + str1*, so *p2+p1* is a substring of *p1+***p2+p1***+p2*.
    In other words, *str2* must be a substring of *str1+str1*; otherwise, it cannot
    be a rotation of *str1*. In terms of code, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is called *RotateString*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Rotating a matrix by 90 degrees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given *n* x *n* matrix of integers, *M*. Write a snippet
    of code that rotates this matrix by 90 degrees in a counterclockwise direction
    without using any extra space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: There are at least two solutions to this problem. One solution
    relies on the transpose of a matrix, while the other one relies on rotating the
    matrix ring by ring.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the matrix transpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s tackle the first solution, which relies on finding the transpose of
    the matrix, *M*. The transpose of a matrix is a notion from linear algebra that
    means we need to flip a matrix over its main diagonal, which results in a new
    matrix denoted as *M*T. For example, having the matrix *M* and indices *i* and
    *j*, we can write the following relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 Relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Matrix transpose relationship
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve obtained the transpose of *M*, we can reverse the columns of the
    transpose. This will give us the final result (the matrix *M* rotated by 90 degrees
    counterclockwise). The following image clarifies this relationship for a 5x5 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The transpose of a matrix on the left and the final result
    on the right'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The transpose of a matrix on the left and the final result on
    the right
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the transpose (*M*T), we can swap *M*[*j*][*i*] with *M*[*i*][*j*]
    via the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Reversing the columns of *M*T can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This solution has a time complexity of O(n2) and a space complexity of O(1),
    so we respect the problem requirements. Now, let's look at another solution to
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the matrix ring by ring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we think of a matrix as a set of concentric rings, then we can try to rotate
    each ring until the entire matrix is rotated. The following image is a visualization
    of this process for a 5x5 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Rotating a matrix ring by ring'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Rotating a matrix ring by ring
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start from the outermost ring and eventually work our way inward. To
    rotate the outermost ring, we swap index by index, starting from the top, (0,
    0). This way, we move the right edge in place of the top edge, the bottom edge
    in place of the right edge, the left edge in place of the bottom edge, and the
    top edge in place of the left edge. When this process is done, the outermost ring
    is rotated by 90 degrees counterclockwise. We can continue with the second ring,
    starting from index (1, 1), and repeat this process until we rotate the second
    ring. Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This solution has a time complexity of O(n2) and a space complexity of O(1),
    so we have respected the problem's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is called *RotateMatrix*. It also contains the solution
    for rotating the matrix 90 degrees clockwise. Moreover, it contains the solution
    for rotating the given matrix in a separate matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Matrix containing zeros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a given *n* x *m* matrix of integers, *M*. If *M*(*i,
    j*) is equal to 0, then the entire row, *i*, and column, *j*, should contain only
    zeros. Write a snippet of code that accomplishes this task without using any extra
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A naive approach consists of looping the matrix and for each
    (*i, j*) = 0, setting the row, *i*, and column, *j*, to zero. The problem is that
    when we traverse the cells of this row/column, we will find zeros and apply the
    same logic again. There is a big chance that we will end up with a matrix of zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such naive approaches, it is better to take an example and try to
    visualize the solution. Let''s consider a 5x8 matrix, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Matrix containing zeros'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Matrix containing zeros
  prefs: []
  type: TYPE_NORMAL
- en: The initial matrix has a 0 at (0, 4) and another one at (2, 6). This means that
    the solved matrix should contains only zeros on rows 0 and 2 and on columns 4
    and 6.
  prefs: []
  type: TYPE_NORMAL
- en: An easy-to-implement approach would be storing the locations of the zeros and,
    at a second traversal of the matrix, set the corresponding rows and columns to
    zero. However, storing the zeros means using some extra space, and this is not
    allowed by the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: With a little trick and some work, we can keep the space complexity set to O(1).
    The trick consists of using the first row and column of the matrix to mark the
    zeros found in the rest of the matrix. For example, if we find a zero at cell
    (*i*, *j*) with *i*≠0 and *j*≠0, then we set *M*[*i*][0] = 0 and *M*[0][*j*] =
    0\. Once we've done that for the entire matrix, we can loop the first column (column
    0) and propagate each zero that's found on the row. After that, we can loop the
    first row (row 0) and propagate each zero that's found on the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how about the potential initial zeros of the first row and column? Of course,
    we have to tackle this aspect as well, so we start by flagging whether the first
    row/column contains at least one 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we apply what we''ve just said. To do this, we loop the rest of
    the matrix, and for each 0, we mark it on the first row and column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can loop the first column (column 0) and propagate each zero that
    was found on the row. After that, we can loop the first row (row 0) and propagate
    each zero that was found on the column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the first row contains at least one 0, then we set the entire row
    to 0\. Also, if the first column contains at least one 0, then we set the entire
    column to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`setRowOfZero()` and `setColumnOfZero()` are quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The application is called *MatrixWithZeros*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Implementing three stacks with one array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`push()`, `pop()`, and `printStacks()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: There are two main approaches to providing the required implementation.
    The approach that we''ll address here is based on interleaving the elements of
    these three stacks. Check out the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Interleaving the nodes of the stacks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Interleaving the nodes of the stacks
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is a single array that holds the nodes of these three
    stacks, denoted as *Stack 1*, *Stack 2*, and *Stack 3*. The key to our implementation
    relies on the fact that each node that's pushed onto the stack (the array, respectively)
    has a backward link to its previous node. The bottom of each stack has a link
    to -1\. For example, for *Stack 1*, we know that value 2 at index 0 has a backward
    link to the dummy index -1, value 12 at index 1 has a backward link to the index
    0, and that value 1 at index 7 has a backward link to the index 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a stack node holds two pieces of information – the value and the backward
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the array manages a link to the next free slot. Initially,
    when the array is empty, we can only create free slots, so the links are shaped
    as follows (notice the `initializeSlots()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we push a node into one of the stacks, we need to find a free slot
    and mark it as not free. This is done by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pop a node from a stack, we must free that slot. This way, this slot
    can be reused by a future push. The relevant code is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete code, including the usage of `printStacks()`, is called *ThreeStacksInOneArray*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach to solving this problem is splitting the array of stacks into
    three distinct zones:'
  prefs: []
  type: TYPE_NORMAL
- en: The first zone is assigned to the first stack and lies at the left-hand side
    of the array endpoint (while we push into this stack, it grows in the right direction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second zone is assigned to the second stack and lies at the right-hand side
    of the array endpoint (while we push into this stack, it grows in the left direction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third zone is assigned to the third stack and lies in the middle of the
    array (while we push into this stack, it may grow in any direction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image will help you clarify these points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Splitting the array into three zones'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Splitting the array into three zones
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge of this approach consists of avoiding stack collisions by
    shifting the middle stack accordingly. Alternatively, we can divide the array
    into three fixed zones and allow the individual stack to grow in that limited
    space. For example, if the array size is *s*, then the first stack can be from
    0 (inclusive) to *s*/3 (exclusive), the second stack can be from *s*/3 (inclusive)
    to 2**s*/3 (exclusive), and the third stack can be from 2**s*/3 (inclusive) to
    *s* (exclusive). This implementation is available in the bundled code as *ThreeStacksInOneArrayFixed*.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the middle stack could be implemented via an alternating sequence
    for subsequent pushes. This way, we also mitigate shifting but we are decreasing
    homogeneity. However, challenge yourself and implement this approach as well.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an array of integers (positive and negative), *m*. Write
    a snippet of code that finds all the pairs of integers whose sum is equal to a
    given number, *k*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As usual, let''s consider an example. Let''s assume we have an
    array of 15 elements, as follows: -5, -2, 5, 4, 3, 7, 2, 1, -1, -2, 15, 6, 12,
    -4, 3\. Also, if *k*=10, then we have four pairs whose sum is 10: (-15 + 5), (-2
    + 12), (3 + 7), and (4 + 6). But how do we find these pairs?'
  prefs: []
  type: TYPE_NORMAL
- en: There are different approaches to solving this problem. For example, we have
    the brute-force approach (usually, interviewers don't like this approach, so use
    it only as a last resort – while the brute-force approach can be a good start
    for understanding the details of the problem, it is not accepted as the final
    solution). Conforming to brute force, we take each element from the array and
    try to make a pair with each of the remaining elements. As with almost any brute-force-based
    solution, this one has an unacceptable complexity time as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find a better approach if we consider sorting the given array. We can
    do this via the Java built-in `Arrays.sort()` method, which has a runtime of O(n
    log n). Having a sorted array allows us to use two pointers that scan the whole
    array based on the following steps (this technique is known as *two-pointers*
    and you''ll see it at work in several problems during this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: One pointer starts from index 0 (left pointer; let's denote it as *l*) and the
    other pointer starts from (*m.length* - 1) index (right pointer; let's denote
    it as *r*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *m*[*l*] *+ m*[*r*] *= k*, then we have a solution and we can increment the
    *l* position and decrement the *r* position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *m*[*l*] *+ m*[*r*]*<k*, then we increment *l* and keep *r* in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *m*[*l*] *+ m*[*r*]*>k*, then we decrement *r* and keep *l* in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat *steps 2-4* until *l>= r*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following image will help you implement these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Finding all pairs whose sum is equal to the given number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Finding all pairs whose sum is equal to the given number
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep an eye on this image while we see how it works for *k*=10:'
  prefs: []
  type: TYPE_NORMAL
- en: '*l* = 0, *r* = 14 → *sum* = *m*[0] + *m*[14] = -5 + 15 = 10 → *sum* = *k* →
    *l*++, *r*--'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 1, *r* = 13 → *sum* = *m*[1] + *m*[13] = -4 + 12 = 8 → *sum < k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 2, *r* = 13 → *sum* = *m*[2] + *m*[13] = -2 + 12 = 10 → *sum* = *k* →
    *l*++, *r*--'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 3, *r* = 12 → *sum* = *m*[3] + *m*[12] = -2 + 7 = 5 → *sum < k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 4, *r* = 12 → *sum* = *m*[4] + *m*[12] = -1 + 7 = 6 → *sum* < *k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 5, *r* = 12 → *sum* = *m*[5] + *m*[12] = 1 + 7 = 8 → *sum* < *k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 6, *r* = 12 → *sum* = *m*[6] + *m*[12] = 2 + 7 = 9 → *sum* < *k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 7, *r* = 12 → *sum* = *m*[7] + *m*[12] = 3 + 7 = 10 → *sum* = *k* → *l*++,
    *r*--'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 8, *r* = 11 → *sum* = *m*[8] + *m*[11] = 3 + 6 = 9 → *sum* < *k* → *l*++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 9, *r*= 11 → *sum* = *m*[9] + *m*[11] = 4 + 6 = 10 → *sum* = *k* → *l*++,
    *r*--'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*l* = 10, *r* = 10 → STOP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we put this logic into code, then we obtain the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *FindPairsSumEqualK*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Merging sorted arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Imagine that you have *k* sorted arrays of different lengths.
    Write an application that merges these arrays into O(nk log n), where *n* is the
    length of the longest array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s assume that the given arrays are the following five arrays
    denoted with *a*, *b*, *c*, *d*, and *e*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a*: {1, 2, 32, 46} *b*: {-4, 5, 15, 18, 20} *c*: {3} *d*: {6, 8} *e*: {-2,
    -1, 0}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '{-4, -2, -1, 0, 1, 2, 3, 5, 6, 8, 15, 18, 20, 32, 46}'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest approach consists of copying all the elements from these arrays
    into a single array. This will take O(nk), where *n* is the length of the longest
    array and *k* is the number of arrays. Next, we sort this array via an O(n log
    n) time complexity algorithm (for example, via Merge Sort). This will result in
    O(nk log nk). However, the problem requires us to write an algorithm that can
    perform in O(nk log n).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several solutions that perform in O(nk log n), and one of them is
    based on a Binary Min Heap (this is detailed in [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*). In a nutshell, a Binary Min Heap is a complete binary tree.
    A Binary Min Heap is typically represented as an array (let''s denote it as *heap*)
    whose root is at *heap*[0]. More importantly, for *heap*[*i*], we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*heap*[(*i* - 1) / 2]: Returns the parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*heap*[(2 * *i*) + 1]: Returns the left child node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*heap*[(2 * *i*) + 2]: Returns the right child node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, our algorithm follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the resulting array of size *n*k*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Binary Min Heap of size *k* and insert the first element of all the
    arrays into this heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the following steps *n*k* times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Get the minimum element from the Binary Min Heap and store it in the resulting
    array.
  prefs: []
  type: TYPE_NORMAL
- en: b. Replace the Binary Min Heap's root with the next element from the array that
    the element was extracted from (if the array doesn't have any more elements, then
    replace the root element with infinite; for example, with `Integer.MAX_VALUE`).
  prefs: []
  type: TYPE_NORMAL
- en: c. After replacing the root, *heapify* the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is too big to be listed in this book, so the following is just the
    end of its implementation (the heap structure and the `merge()` operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the `merge()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MergeKSortedArr*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Median
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider two sorted arrays, *q* and *p* (they can have different
    lengths). Write an application that computes the median value of these two arrays
    in logarithmic runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A median value separates the higher half of a data sample (for
    example, an array) from the lower half. For example, the following image shows
    the median value of an array with an odd number of elements (left-hand side) and
    with an even number of elements (right-hand side), respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Median values for odd and even arrays'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Median values for odd and even arrays
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for an array with *n* number of elements, we have the following two formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is odd, then the median value is given by (*n*+1)/2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is even, then the median value is given by [(*n*/2+(*n*/2+1)]/2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is quite easy to compute the median of a single array. But how do we compute
    it for two arrays of different lengths? We have two sorted arrays and we must
    find something out from them. Having the experience of a candidate that knows
    how to prepare for an interview should be enough to intuit that the well-known
    Binary Search algorithm should be considered. Typically, having sorted arrays
    is something you should take into consideration when implementing the Binary Search
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We can roughly intuit that finding the median value of two sorted arrays can
    be reduced to finding the proper conditions that must be respected by this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the median value divides input into two equal parts, we can conclude
    that the first condition imposes that the median value of the *q* array should
    be at the middle index. If we denote this middle index as *qPointer*, then we
    obtain two equal parts: [0, *qPointer*] and [*qPointer*+1*, q.length*]*.* If we
    apply the same logic to the *p* array, then the median value of the *p* array
    should be at the middle index as well. If we denote this middle index as *pPointer*,
    then we obtain two equal parts: [0, *pPointer*] and [*pPointer*+1, *p.length*].
    Let''s visualize this via the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Splitting arrays into two equal parts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Splitting arrays into two equal parts
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude from this diagram that the first condition that the median value
    should respect is *qLeft + pLeft = qRight + pRight*. In other words, *qPointer
    + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since our arrays aren''t the same length (they can be equal, but this
    is just a special case that should be covered by our solution as well), we cannot
    simply halve both of them. What we can do is assume that *p* >= *q* (if they are
    not given like this, then we just swap them to force this assumption). Furthermore,
    under the umbrella of this assumption, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*qPointer + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*)
    *→*'
  prefs: []
  type: TYPE_NORMAL
- en: 2 ** pPointer = q.length + p.length -* 2 ** qPointer →*
  prefs: []
  type: TYPE_NORMAL
- en: '*pPointer =* (*q.length + p.length*)*/*2 *- qPointer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, *pPointer* can fall in the middle and we can avoid this by adding 1,
    which means we have the following starting pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*qPointer* = ((*q.length* - 1) + 0)/2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pPointer* = (*q.length* + *p.length* + 1)/2 - *qPointer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *p*>=*q*, then the minimum (*q.length* + *p.length* + 1)/2 - *qPointer* will
    always lead to *pPointer* as a positive integer. This will eliminate array-out-of-bounds
    exceptions and respects the first condition as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, our first condition is not enough because it doesn''t guarantee that
    all the elements in the left array are less than the elements in the right array.
    In other words, the maximum of the left part must be less than the minimum of
    the right part. The maximum of the left part can be *q*[*qPointer*-1] or *p*[*pPointer*-1],
    while the minimum of the right part can be *q*[*qPointer*] or *p*[*pPointer*].
    So, we can conclude that the following conditions should be respected as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '*q*[*qPointer*-1] <= *p*[*pPointer*]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p*[*pPointer*-1] <= *q*[*qPointer*]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under these conditions, the median value of *q* and *p* will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p.length* + *q.length* is even: The average of the maximum of the left part
    and the minimum of the right part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p.length* + *q.length* is odd: The maximum of the left parts, max(*q*[*qPointer*-1],
    *p*[*pPointer*-1]).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to summarize this in an algorithm with three steps and an example.
    We start with *qPointer* as the middle of *q* (so as, [(*q.length* - 1) + 0)/2]
    and with *pPointer* as (*q.length* + *p.length* + 1)/2 - *qPointer*. Let''s go
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If *q*[*qPointer*-1] <= *p*[*pPointer*] and *p*[*pPointer*-1] <= *q*[*qPointer*],
    then we have found the perfect *qPointer* (the perfect index).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *p*[*pPointer*-1] >*q*[*qPointer*], then we know that *q*[*qPointer*] is
    too small, so *qPointer* must be increased and *pPointer* must be decreased. Since
    the arrays are sorted, this action will result in a bigger *q*[*qPointer*] and
    a smaller *p*[*pPointer*]. Moreover, we can conclude that *qPointer* can only
    be in the right part of *q* (from *middle*+1 to *q.length*). Go back to *step
    1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *q*[*qPointer*-1] >*p*[*pPointer*], then we know that *q*[*qPointer*-1] is
    too big. We must decrease *qPointer* to get *q*[*qPointer*-1] <= *p*[*pPointer*].
    Moreover, we can conclude that *qPointer* can be only in the left part of *q*
    (from 0 to *middle*-1). Go to *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's consider that *q*={ 2, 6, 9, 10, 11, 65, 67} and *p*={ 1, 5, 17,
    18, 25, 28, 39, 77, 88}, and let's apply the previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conforming to our preceding statements, we know that *qPointer* = (0 + 6) /
    2 = 3 and *pPointer* = (7 + 9 + 1) / 2 - 3 = 5\. The following image speaks for
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Computing the median value (step 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – Computing the median value (step 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1 of our algorithm specifies that *q*[*qPointer*-1] <= *p*[*pPointer*]
    and *p*[*pPointer*-1] <= *q*[*qPointer*]. Obviously, 9 < 28, but 25 > 10, so we
    apply *step 2* and afterward, go back to *step 1*. We increase *qPointer* and
    decrease *pPointer*, so *qPointerMin* becomes *qPointer* + 1\. The new *qPointer*
    will be (4 + 6) / 2 = 5 and the new *pPointer* will be (7 + 9 + 1)/2 - 5 = 3\.
    The following image will help you visualize this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Computing the median value (step 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.15_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Computing the median value (step 2)
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the new *qPointer* and new *pPointer* respect *step 1*
    of our algorithm since *q*[*qPointer*-1], which is 11, is less than *p*[*pPointer*],
    which is, 18; and *p*[*pPointer*-1], which is 17, is less than *q*[*qPointer*],
    which is 65\. With this, we found the perfect *qPointer* to be 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to find the maximum of the left-hand side and the minimum
    of the right-hand side and, based on the odd or even length of the two arrays,
    return the maximum of the left-hand side or the average of the maximum of the
    left-hand side and the minimum of the right-hand side. We know that the maximum
    of the left-hand side is max(*q*[*qPointer*-1], *p*[*pPointer*-1]), so max(11,
    17) = 17\. We also know that the minimum of the right-hand side is min(*q*[*qPointer*],
    *p*[*pPointer*]), so min(65, 18) = 18\. Since the sum of lengths is 7 + 9 = 16,
    we compute that the median value is the average of these two, so avg(17, 18) =
    17.5\. We can visualize this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Median value (final result)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.16_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Median value (final result)
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this algorithm into code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our solution performs in O(log(max(*q.length, p.length*)) time. The complete
    application is called *MedianOfSortedArrays*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Sub-matrix of one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given a matrix, *m* x *n*, containing
    only 0 and 1 (binary matrix). Write a snippet of code that returns the maximum
    size of the square sub-matrix so that it contains only elements of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given matrix is the one in the following
    image (5x7 matrix):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – The given 5x7 binary matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – The given 5 x 7 binary matrix
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the square sub-matrix only containing elements of 1 has a size
    of 3\. The brute-force approach, or the naive approach, would be to find all the
    square sub-matrices containing all 1s and determine which one has the maximum
    size. However, for an *m* x *n* matrix that has *z*=min(*m, n*), the time complexity
    will be O(z3mn). You can find the brute-force implementation in the code bundled
    with this book. Of course, challenge yourself before checking the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s try to find a better approach. Let''s consider that the given
    matrix is of size *n* x *n* and study several scenarios of a 4x4 sample matrix.
    In a 4x4 matrix, we can see that the maximum square sub-matrix of 1s can have
    a size of 3x3, so in a matrix of size *n* x *n*, the maximum square sub-matrix
    of 1s can have a size of *n*-1x *n*-1\. Moreover, the following image reveals
    two base cases that are true for an *m x n* matrix as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Maxim sub-matrix of 1s in a 4x4 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.18_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – Maxim sub-matrix of 1s in a 4 x 4 matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'These cases are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the given matrix contains only one row, then cells with 1's in them will
    be the maximum size of the square sub-matrix. Therefore, the maximum size is 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the given matrix contains only one column, then cells with 1's in them will
    be the maximum size of the square sub-matrix. Therefore, the maximum size is 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s consider that *subMatrix*[*i*][*j*] represents the maximum size
    of the square sub-matrix, with all 1s ending at cell (*i,j*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Overall recurrence relation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.19_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – Overall recurrence relation
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure allows us to establish a recurrence relation between the
    given matrix and an auxiliary *subMatrix* (a matrix that''s the same size as the
    given matrix that should be filled in based on the recurrence relation):'
  prefs: []
  type: TYPE_NORMAL
- en: It is not easy to intuit this, but we can see that if *matrix*[*i*][*j*] = 0,
    then *subMatrix*[*i*][*j*] = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *matrix*[*i*][*j*] = 1, then *subMatrix*[*i*][*j*]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = 1 + min(*subMatrix*[*i* - 1][*j*], *subMatrix*[*i*][*j* - 1], *subMatrix*[*i*
    - 1][*j* - 1])
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to our 5 x 7 matrix, then we obtain the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Resolving our 5x7 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.20_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.20 – Resolving our 5 x 7 matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Gluing together the preceding base cases and the recurrence relations results
    in the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an auxiliary matrix (*subMatrix*) of the same size as the given matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the first row and first column from the given matrix to this auxiliary
    *subMatrix* (these are the base cases).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each cell from the given matrix (starting at (1, 1)), do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Fill up the *subMatrix* conforming to the preceding recurrence relations.
  prefs: []
  type: TYPE_NORMAL
- en: b. Track the maximum element of *subMatrix* since this element gives us the
    maximum size of the sub-matrix containing all 1's.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation clarifies any remaining details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since we iterate *m***n* times to fill the auxiliary matrix, the overall complexity
    of this solution is O(mn). The complete application is called *MaxMatrixOfOne*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Container with the most water
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given *n* positive integers, *p*1,
    *p*2, ..., *p*n, where each integer represents a point at coordinate (*i, p*i)
    . Next, *n* vertical lines are drawn so that the two endpoints of line *i* are
    at (*i, p*i) and (*i*, 0). Write a snippet of code that finds two lines that,
    together with the X-axis, form a container that contains the most water.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given integers are 1, 4, 6, 2, 7, 3,
    8, 5, and 3\. Following the problem statements, we can sketch the *n* vertical
    lines (line 1: {(0, 1), (0, 0)}, line 2: {(1, 4), (1,0)}, line 3: {(2, 6), (2,
    0)}, and so on). This can be seen in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – The n vertical line representation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.21_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.21 – The n vertical line representation
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's see how we should interpret the problem. We have to find
    the container that contains the most water. This means that, in our 2D representation,
    we have to find the rectangle that has the maximum area. In a 3D representation,
    this container will have the maximum volume, so it will contain the most water.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about the solution in terms of the brute-force approach is quite straightforward.
    For each line, we compute the areas showing the rest of the lines while tracking
    the largest area found. This requires two nested loops, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that its runtime is O(n2). A better approach consists
    of employing a technique known as *two-pointers*. Don't worry – it is a pretty
    simple technique that it is quite useful to have in your toolbelt. You never know
    when you'll need it!
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that we are looking for the maximum area. Since we are talking about
    a rectangular area, this means that the maximum area must accommodate the best
    report between the *biggest width* and the *biggest height* as much as possible.
    The biggest width is from 0 to *n*-1 (in our example, from 0 to 8). To find the
    biggest height, we must adjust the biggest width while tracking the maximum area.
    For this, we can start from the biggest width, as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Area with the biggest width'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.22_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.22 – Area with the biggest width
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we demarcate the boundaries of the biggest width with two pointers,
    we can say that *i*=0 and *j*=8 (or *n*-1). In this case, the container that holds
    the water will have an area of *p*i* 8 = 1 * 8 = 8\. The container cannot be higher
    than *p*i = 1 because the water will flow out. However, we can increment *i* (*i*=1,
    *p*i=4) to obtain a higher container, and potentially a bigger container, as shown
    in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Increasing i to obtain a bigger container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.23_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.23 – Increasing i to obtain a bigger container
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, if *p*i ≤ *p*j, then we increment *i*; otherwise, we decrement
    *j*. By successively increasing/decreasing *i* and *j*, we can obtain the maximum
    area. From left to right and from top to bottom, the following image shows this
    statement at work for the next six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Computing areas while increasing/decreasing i and j'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.24_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.24 – Computing areas while increasing/decreasing i and j
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the top-left corner image, we decreased *j* since *p*i *> p*j*, p*1 *> p*8
    (4 > 3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-middle image, we increased *i* since *p*i *< p*j*, p*1 *< p*7 (4
    < 5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner image, we decreased *j* since *p*i *> p*j*, p*2 *> p*7
    (6 > 5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the bottom-left corner image, we increased *i* since *p*i *< p*j*, p*2 <
    *p*6 (6 < 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the bottom-middle image, we increased *i* since *p*i *< p*j*, p*3 *< p*6
    (2 < 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the bottom-right corner image, we increased *i* since *p*i *< p*j*, p*4 *<
    p*6 (7 < 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Done! If we increase *i* or decrease *j* one more time, then *i=j* and the
    area is 0\. At this point, we can see that the maximum area is 25 (top-middle
    image). Well, this technique is known as *two-pointers* and can be implemented
    in this case with the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the maximum area as 0*, i*=0 and *j=n*-1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While *i < j*, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Compute the area for the current *i* and *j*.
  prefs: []
  type: TYPE_NORMAL
- en: b. Update the maximum area accordingly (if needed).
  prefs: []
  type: TYPE_NORMAL
- en: c. If *p*i *≤ p*j, then *i++;* else, *j--*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n). The complete application is called *ContainerMostWater*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – Searching in a circularly sorted array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given a circularly sorted array of
    integers with no duplicates, *m*. Write a program that searches for the given
    *x* in O(log n) complexity time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If we could solve this problem in O(n) complexity time, then
    the brute-force approach is the simplest solution. A linear search in the array
    will give the index of the searched *x*. However, we need to come up with an O(log
    n) solution, so we need to tackle the problem from another perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: We have enough hints that point us to the well-known Binary Search algorithm,
    which we discussed in [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms* and in [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340),
    *Sorting and Searching*. We have a sorted array, we need to find a certain value,
    and we need to do it in O(log n) complexity time. So, there are three hints that
    point us to the Binary Search algorithm. Of course, the big issue is represented
    by the circularity of the sorted array, so we cannot apply a plain Binary Search
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider that *m* = {11, 14, 23, 24, -1, 3, 5, 6, 8, 9, 10} and *x*
    = 14, and we expected the output to be index 1\. The following image introduces
    several notations and serves as guidance in solving the problem at hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.25 – Circularly sorted array and Binary Search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.25_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.25 – Circularly sorted array and Binary Search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the sorted array is circular, we have a *pivot*. This is an index pointing
    to the head of the array. The elements from the left of the pivot have been rotated.
    When the array is not rotated, it will be {-1, 3, 5, 6, 8, 9, 10, **11, 14, 23,
    24**}. Now, let''s see the steps for the solution based on the Binary Search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: We apply the Binary Search algorithm, so we start by computing the *middle*
    of the array as (*left + right*) / 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether *x* = *m*[*middle*]. If so, we return the *middle*. If not,
    we continue with the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we check whether the right-half of the array is sorted. All the elements
    from the range [*middle, right*] are sorted if *m*[*middle*] <= *m*[*right*]:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If *x* > *m*[*middle*] and *x* <= *m*[*right*], then we ignore the left-half,
    set *left* = *middle* + 1, and repeat from *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: b. If *x* <= *m*[*middle*] or *x > m*[*right*], then we ignore the right-half,
    set *right = middle* - 1, and repeat from *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the right-half of the array is not sorted, then the left-half must be sorted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If *x >= m*[*left*]and *x < m*[*middle*], then we ignore the right-half,
    set *right = middle*- 1, and repeat from *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: b. If *x < m*[*left*]or *x >= m*[*middle*], then we ignore the left-half, set
    *left = middle* + 1, and repeat from *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: We repeat *steps 1-4* as long as we didn't find *x* or *left <= right*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's apply the preceding algorithm to our case.
  prefs: []
  type: TYPE_NORMAL
- en: So, *middle* is (*left + right*) / 2 = (0 + 10) / 2 = 5\. Since *m*[5] ≠14 (remember
    that 14 is *x*), we continue with *step 3*. Since *m*[5]<*m*[10], we conclude
    that the right-half is sorted. However, we notice that *x>m*[*right*] (14 >10),
    so we apply *step 3b*. Basically, we ignore the right-half and we set *right =
    middle* - 1 = 5 - 1 = 4\. We apply *step 1* again.
  prefs: []
  type: TYPE_NORMAL
- en: The new *middle* is (0 + 4) / 2 = 2\. Since *m*[2]≠14, we continue with *step
    3*. Since *m*[2] >*m*[4], we conclude that the left-half is sorted. We notice
    that *x*>*m*[*left*] (14 >11) and *x*<*m*[*middle*] (14<23), so we apply *step
    4a*. We ignore the right-half and we set *right*= *middle* - 1 = 2 - 1 = 1\. We
    apply *step 1* again.
  prefs: []
  type: TYPE_NORMAL
- en: The new *middle* is (0 + 1) / 2 = 0\. Since *m*[0]≠14, we continue with *step
    3*. Since *m*[0]<*m*[1], we conclude that the right-half is sorted. We notice
    that *x* > *m*[*middle*] (14 > 11) and *x* = *m*[*right*] (14 = 14), so we apply
    *step 3a*. We ignore the left-half and we set *left = middle* + 1 = 0 + 1 = 1\.
    We apply *step 1* again.
  prefs: []
  type: TYPE_NORMAL
- en: The new *middle* is (1 + 1) / 2 = 1\. Since *m*[1]=14, we stop and return 1
    as the index of the array where we found the searched value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *SearchInCircularArray*. Similar problems
    will ask you to find the maximum or the minimum value in a circularly sorted array.
    While both applications are available in the bundled code as *MaximumInCircularArray*
    and *MinimumInCircularArray*, it is advisable to use what you've learned so far
    and challenge yourself to find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 18 – Merging intervals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given an array of intervals of the
    [*start, end*] type. Write a snippet of code that merges all the intervals that
    are overlapping.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given intervals are [12,15], [12,17],
    [2,4], [16,18], [4,7], [9,11], and [1,2]. After we merge the overlapping intervals,
    we obtain the following result: [1, 7], [9, 11] [12, 18].'
  prefs: []
  type: TYPE_NORMAL
- en: We can start with the brute-force approach. It is quite intuitive that we take
    an interval (let's denote it as *p*i) and compare its end (*p*ei) with the starts
    of the rest of the intervals. If the start of an interval (from the rest of the
    intervals) is less than the end of *p*, then we can merge these two intervals.
    The end of the merged interval becomes the maximum of the ends of these two intervals.
    But this approach will perform in O(n2), so it will not impress the interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: However, the brute-force approach can give us an important hint for attempting
    a better implementation. At any moment of time, we must compare the end of *p*
    with the start of another interval. This is important because it can lead us to
    the idea of sorting the intervals by their starts. This way, we seriously reduce
    the number of comparisons. Having the sorted intervals allows us to combine all
    the intervals in a linear traversal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try and use a graphical representation of our sample intervals sorted
    in ascending order by their starts (*p*si<*p*si+1<*p*si+2). Also, each interval
    is always forward-looking (*p*ei>*p*si, *p*ei+1>*p*si+1, *p*ei+2>*p*si+2, and
    so on). This will help us understand the algorithm that we''ll cover soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Sorting the given intervals'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.26_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.26 – Sorting the given intervals
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding image, we can see that if the start of *p* is greater
    than the end of the previous *p*, (*p*si>*p*ei-1), then the start of the next
    *p* is greater than the end of the previous *p*, (*p*si+1>*p*ei-1), so there is
    no need to compare the previous *p* with the next *p*. In other words, if *p*i
    doesn't overlap with *p*i-1, then *p*i+1 cannot overlap with *p*i-1 because the
    start of *p*i+1 must be greater than or equal to *p*i.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *p*si is less than *p*ei-1, then we should update *p*ei-1 with the maximum
    between *p*ei-1 and *p*ei and move to *p*ei+1\. This can be done via a stack,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Using a stack to solve the problem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.27_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.27 – Using a stack to solve the problem
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps that occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 0**: We start with an empty stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: Since the stack is empty, we push the first interval ([1, 2]) into
    the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: Next, we focus on the second interval ([2, 4]). The start of [2,
    4] is equal to the end of the interval from the top of the stack, [1, 2], so we
    don''t push [2, 4] into the stack. We continue to compare the end of [1, 2] with
    the end of [2, 4]. Since 2 is less than 4, we update the interval [1, 2] to [1,
    4]. So, we merged [1, 2] with [2, 4].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: Next, we focus on interval [4, 7]. The start of [4, 7] is equal
    to the end of the interval from the top of the stack, [1, 4], so we don''t push
    [4, 7] into the stack. We continue to compare the end of [1, 4] with the end of
    [4, 7]. Since 4 is less than 7, we update the interval [1, 4] to [1, 7]. So, we
    merged [1, 4] with [4, 7].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**: Next, we focus on interval [9, 11]. The start of [9, 11] is greater
    than the end of the interval from the top of the stack, [1, 7], so intervals [1,
    7] and [9, 11] don''t overlap. This means that we can push interval [9, 11] into
    the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**: Next, we focus on interval [12, 15]. The start of [12, 15] is greater
    than the end of the interval from the top of the stack, [9, 11], so intervals
    [9, 11] and [12, 15] don''t overlap. This means that we can push interval [12,
    15] into the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 6**: Next, we focus on interval [12, 17]. The start of [12, 17] is equal
    to the end of the interval from the top of the stack, [12, 15], so we don''t push
    [12, 17] into the stack. We continue and compare the end of [12, 15] with the
    end of [12, 17]. Since 15 is less than 17, we update interval [12, 15] to [12,
    17]. So, here, we merged [12, 15] with [12, 17].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 7**: Finally, we focus on interval [16, 18]. The start of [16, 18] is
    less than the end of the interval from the top of the stack, [12, 17], so intervals
    [16, 18] and [12, 17] are overlapping. This time, we have to update the end of
    the interval from the top of the stack with the maximum between the end of this
    interval and [16, 18]. Since 18 is greater than 17, the interval from the top
    of the stack becomes [12, 17].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can pop the content of the stack to see the merged intervals, [[12,
    18], [9, 11], [1, 7]], as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.28 – The merged intervals'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.28_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.28 – The merged intervals
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these steps, we can create the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the given intervals in ascending order based on their starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the first interval into the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the rest of intervals, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the current interval does not overlap with the interval from the top of
    the stack, then push it into the stack.
  prefs: []
  type: TYPE_NORMAL
- en: b. If the current interval overlaps with the interval from the top of the stack
    and the end of the current interval is greater than that of the stack top, then
    update the top of the stack with the end of the current interval.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the stack contains the merged intervals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, this algorithm looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n log n) with an auxiliary space of O(n) for the
    stack. While the interviewer should be satisfied with this approach, he/she may
    ask you for optimization. More precisely, can we drop the stack and obtain a complexity
    space of O(1)?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we drop the stack, then we must perform the merge operation in-place. The
    algorithm that can do this is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the given intervals in ascending order based on their starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the rest of the intervals, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the current interval is not the first interval and it overlaps with the
    previous interval, then merge these two intervals. Do the same for all the previous
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: b. Otherwise, add the current interval to the output array of intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, this time, the intervals are sorted in descending order of their
    starts. This means that we can check whether two intervals are overlapping by
    comparing the start of the previous interval with the end of the current interval.
    Let''s see the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n log n) with an auxiliary space of O(1). The
    complete application is called *MergeIntervals*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 19 – Petrol bunks circular tour
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given *n* petrol bunks along a circular
    route. Every petrol bunk contains two pieces of data: the amount of fuel (*fuel*[])
    and the distance from that current petrol bunk to the next petrol bunk (*dist*[]).
    Next, you have a truck with an unlimited gas tank. Write a snippet of code that
    calculates the first point from where the truck should start in order to complete
    a full tour. You begin the journey with an empty tank at one of the petrol bunks.
    With 1 liter of petrol, the truck can go 1 unit of distance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider that you''ve been given the following data: *dist* =
    {5, 4, 6, 3, 5, 7}, *fuel* = {3, 3, 5, 5, 6, 8}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following images to get a better understanding of the context
    of this problem and to support us in finding a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29 – Truck circular tour sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.29_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.29 – Truck circular tour sample
  prefs: []
  type: TYPE_NORMAL
- en: From 0 to 5, we have six petrol bunks. On the left-hand side of the image, you
    can see a sketch of the given circular route and the distribution of the petrol
    bunks. The first petrol bunk has 3 liters of petrol, and the distance to the next
    petrol bunk is 5 units. The second petrol bunk has 3 liters of petrol, and the
    distance to the next petrol bunk is 4 units. The third petrol bunk has 5 liters
    of petrol, and the distance to the next petrol bunk is 6 units, and so on. Obviously,
    a vital condition if we wish to go from petrol bunk *X* to petrol bunk *Y* is
    that the distance between *X* and *Y* is less than or equal to the amount of fuel
    in the tank of the truck. For example, if the truck starts the journey from petrol
    bunk 0, then it cannot go to petrol bunk 1 since the distance between these two
    petrol bunks is 5 units and the truck can have only 3 liters of petrol in the
    tank. On the other hand, if the truck starts the journey from petrol bunk 3, then
    it can go to petrol bunk 4 because the truck will have 5 liters of petrol in the
    tank. Actually, as shown on the right-hand side of the image, the solution to
    this case is to start from petrol bunk 3 with 5 liters of petrol in the tank –
    take your time and complete the tour using some paper and a pen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The brute-force (or naive) approach can rely on a straightforward statement:
    we start from each petrol bunk and try to make the complete tour. This is simple
    to implement but its runtime will be O(n2). Challenge yourself to come up with
    a better implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem more efficiently, we need to understand and use the following
    facts:'
  prefs: []
  type: TYPE_NORMAL
- en: If the *sum of fuel ≥ the sum of distances*, then the tour can be completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If petrol bunk *X* cannot reach petrol bunk *Z* in the sequence of *X → Y →
    Z*, then *Y* cannot make it either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the first bullet is a commonsense notion, the second bullet requires
    some extra proof. Here is the reasoning behind the second bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: "If *fuel*[*X*] *< dist*[*X*], then *X* cannot even reach *Y*\L So to reach\
    \ *Z* from *X*, *fuel*[*X*] must be *≥ dist*[*X*]."
  prefs: []
  type: TYPE_NORMAL
- en: Given that *X* cannot reach *Z*, we have *fuel*[*X*] *+ fuel*[*Y*] *< dist*[*X*]
    *+ dist*[*Y*]*,* and *fuel*[*X*] *≥ dist*[*X*]. Therefore, *fuel*[*Y*] *< dist*[*Y*]
    and *Y* cannot reach *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these two points, we can come up with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this code, try to pass the given set of data through the code
    using some paper and a pen. Also, you may wish to try the following sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n). The complete application is called *PetrolBunks*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 20 – Trapping rainwater
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given a set of bars that are different
    heights (non-negative integers). The width of a bar is equal to 1\. Write a snippet
    of code that computes the amount of water that can be trapped within the bars.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given set of bars is an array, as follows:
    *bars* = { 1, 0, 0, 4, 0, 2, 0, 1, 6, 2, 3}. The following image is a sketch of
    these bars'' heights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30 – The given set of bars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.30_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.30 – The given set of bars
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rain is filling up between the spaces of these bars. So, after the rain
    has fallen, we will have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.31 – The given bars after rain'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.31_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.31 – The given bars after rain
  prefs: []
  type: TYPE_NORMAL
- en: So, here, we have a maximum amount of water equal to 16\. The solution to this
    problem depends on how we look at the water. For example, we can look at the water
    between the bars or at the water on top of each bar. The second view is exactly
    what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following image, which has some additional guidance regarding
    how to isolate the water on top of each bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32 – Water on top of each bar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.32_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.32 – Water on top of each bar
  prefs: []
  type: TYPE_NORMAL
- en: 'So, above bar 0, we have no water. Above bar 1, we have 1 unit of water. Above
    bar 2, we have 1 unit of water, and so on and so forth. If we sum up these values,
    then we get 0 + 1 + 1 + 0 + 4 + 2 + 4 + 3 + 0 + 1 + 0 = 16, which is the precise
    amount of water we have. However, to determine the amount of water on top of bar
    *x*, we must know the minimum between the highest bars on the left- and right-hand
    sides. In other words, for each of the bars, that is, 1, 2, 3 ... 9 (notice that
    we don''t use bars 0 and 10 since they are the boundaries), we have to determine
    the highest bars on the left- and right-hand sides and compute the minimum between
    them. The following image reveals our computations (the bar in the middle ranges
    from 1 to 9):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.33 – Highest bars on the left- and right-hand sides'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.33_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.33 – Highest bars on the left- and right-hand sides
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we can conclude that a simple solution would be to traverse the bars
    to find the highest bars on the left- and right-hand sides. The minimum of these
    two bars can be exploited as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the minimum is smaller than the height of the current bar, then the current
    bar cannot hold water on top of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the minimum is greater than the height of the current bar, then the current
    bar can hold an amount of water equal to the difference between the minimum and
    the height of the current bar on top of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, this problem can be addressed by computing the highest bars on the left-
    and right-hand sides of every bar. An efficient implementation of these statements
    consists of pre-computing the highest bars on the left- and right-hand sides of
    every bar in O(n) time. Then, we need to use the results to find the amount of
    water on the top of each bar. The following code should clarify any other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with an auxiliary space of O(n) for the *left*[]
    array. A similar Big O can be obtained by using an implementation based on a stack
    (the bundled code contains this implementation as well). How about writing an
    implementation that has O(1) space?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, instead of maintaining an array of size *n* to store all the left maximum
    heights, we can use two variables to store the maximum until that bar (this technique
    is known as *two-pointers*)*.* As you may recall, you observed this in some of
    the previous coding challenges. The two pointers are `maxBarLeft` and `maxBarRight`.
    The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with an O(1) space. The complete application
    is called *TrapRainWater*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 21 – Buying and selling stock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given an array of positive integers
    representing the price of a stock on each day. So, the *i*th element of the array
    represents the price of the stock on day *i*. As a general rule, you may not perform
    multiple transactions (a buy-sell sequence is known as a transaction) at the same
    time and you must sell the stock before you buy again. Write a snippet of code
    that returns the maximum profit in one of the following scenarios (usually, the
    interviewer will give you one of the following scenarios):'
  prefs: []
  type: TYPE_NORMAL
- en: You are allowed to buy and sell the stock only once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are allowed to buy and sell the stock only twice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are allowed to buy and sell the stock unlimited times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are allowed to buy and sell the stock only *k* times (*k* is given).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given array of prices is *prices*={200,
    500, 1000, 700, 30, 400, 900, 400, 550}. Let''s tackle each of the preceding scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Buying and selling the stock only once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock only once. This is quite simple and intuitive. The idea is to buy the stock
    when it is at its cheapest and sell it when it is at its most expensive. Let''s
    identify this statement via the following price-trend graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.34 – Price-trend graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.34_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.34 – Price-trend graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Conforming to the preceding graphic, we should buy the stock at a price of
    30 on day 5 and sell it at a price of 900 on day 7\. This way, the profit will
    be at its maximum (870). To determine the maximum profit, we can employ a simple
    algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the *cheapest price* at day 1 and no profit (*maximum profit* is 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate the rest of the days (2, 3, 4, ...) and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. For each day, update the *maximum profit* as the max(*current maximum profit,*
    (*today's price - cheapest price*)).
  prefs: []
  type: TYPE_NORMAL
- en: b. Update the *cheapest price* as the min(*current cheapest price, today's price*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply this algorithm to our data. So, we consider the *cheapest price*
    as 200 (price at day 1) and the *maximum profit* is 0\. The following image reveals
    the computations day by day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.35 – Computing the maximum profit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.35_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.35 – Computing the maximum profit
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 1**: The *minimum price* is 200; the *price on day 1 - minimum price*
    = 0; therefore, the *maximum profit* so far is 200.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 2**: The *minimum price* is 200 (since 500 > 200); the *price on day
    2 - minimum price* = 300; therefore, the *maximum profit* so far is 300 (since
    300 > 200).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 3**: The *minimum price* is 200 (since 1000 > 200); the *price on day
    3 - minimum price* = 800; therefore, the *maximum profit* so far is 800 (since
    800 > 300).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 4**: The *minimum price* is 200 (since 700 > 200); the *price on day
    4 - minimum price* = 500; therefore, the *maximum profit* so far is 800 (since
    800 > 500).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 5**: The *minimum price* is 30 (since 200 > 30); the *price on day 5
    - minimum price* = 0; therefore, the *maximum profit* so far is 800 (since 800
    > 0).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 6**: The *minimum price* is 30 (since 400 > 30); the *price on day 6
    - minimum price* = 370; therefore, the *maximum profit* so far is 800 (since 800
    > 370).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 7**: The *minimum price* is 30 (since 900 > 30); the *price on day 7
    - minimum price* = 870; therefore, the *maximum profit* so far is 870 (since 870
    > 800).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 8**: The *minimum price* is 30 (since 400 > 30); the *price on day 8
    - minimum price* = 370; therefore, the *maximum profit* so far is 870 (since 870
    > 370).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 9**: The *minimum price* is 30 (since 550 > 30); the *price on day 9
    - minimum price* = 520; therefore, the *maximum profit* so far is 870 (since 870
    >520).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *maximum profit* is 870.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n). Let's tackle the next scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Buying and selling the stock only twice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock only twice. The idea is to buy the stock when it is as its cheapest and
    sell it when it is at its most expensive. We do this twice. Let''s identify this
    statement via the following price-trend graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.36 – Price-trend graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.36_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.36 – Price-trend graph
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to the preceding graph, we should buy the stock at a price of 200
    on day 1 and sell it at a price of 1,000 on day 3\. This transaction brings a
    profit of 800\. Next, we should buy the stock at a price of 30 on day 5 and sell
    it at a price of 900 on day 7\. This transaction brings a profit of 870\. So,
    the maximum profit is 870+800=1670.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the *maximum profit*, we must find the two most profitable transactions.
    We can do this via dynamic programming and the *divide and conquer* technique.
    We *divide* the algorithm into two parts. The first part of the algorithm contains
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the *cheapest price* at day 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate the rest of the days (2, 3, 4, ...) and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Update the *cheapest price* as the min(*current cheapest price, today's price*).
  prefs: []
  type: TYPE_NORMAL
- en: b. Track the *maximum profit* for today as the max(*maximum profit of the previous
    day*, (*today price - cheapest price*)).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this algorithm, we will have an array (let's denote it as *left*[])
    representing the maximum profit that can be obtained before each day (inclusive
    of that day). For example, until day 3 (inclusive of day 3), the maximum profit
    is 800 since you can buy at a price of 200 on day 1 and sell at a price of 1,000
    on day 3, or until day 7 (inclusive of day 7), where the maximum profit is 870
    since you can buy at a price of 30 on day 5 and sell at a price of 900 on day
    7, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This array is obtained via *step 2b*. We can represent it for our data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.37 – Computing the maximum profit before each day, starting from
    day 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.37_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.37 – Computing the maximum profit before each day, starting from day
    1
  prefs: []
  type: TYPE_NORMAL
- en: 'The *left*[] array is useful for after we''ve covered the second part of the
    algorithm. Next, the second part of the algorithm goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the *most expensive price* on the last day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate the rest of the days from (*last*-1) to the *first* day(*last-1, last-2,
    last-3, ...*) and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Update the *most expensive price* as the max(*current most expensive price,
    today's price*).
  prefs: []
  type: TYPE_NORMAL
- en: b. Track the *maximum profit* for today as the max(*maximum profit of the next
    day, (most expensive price - today price*)).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this algorithm, we will have an array (let''s denote it as *right*[])
    representing the maximum profit that can be obtained after each day (inclusive
    of that day). For example, after day 3 (inclusive of day 3), the maximum profit
    is 870 since you can buy at a price of 30 on day 5 and sell at a price of 900
    on day 7, or after day 7 the maximum profit is 150 since you can buy at a price
    of 400 on day 8 and sell at a price of 550 on day 9, and so on. This array is
    obtained via *step 2b*. We can represent it for our data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.38 – Computing the maximum profit after each day, starting from
    last day'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.38_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.38 – Computing the maximum profit after each day, starting from the
    previous day
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have accomplished the *divide* part. Now, it''s time for the *conquer*
    part. The *maximum profit* that can be accomplished in two transactions can be
    obtained as the max(*left*[*day*]*+right*[*day*]). We can see this in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.39 – Computing the final maximum profit of transactions 1 and 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.39_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.39 – Computing the final maximum profit of transactions 1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n). Now, let's tackle the next scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Buying and selling the stock an unlimited amount of times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock an unlimited amount of times. You can identify this statement via the following
    price-trend graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.40 – Price-trend graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.40_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.40 – Price-trend graph
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to the preceding graphic, we should buy the stock at a price of 200
    on day 1 and sell it at a price of 500 on day 2\. This transaction brings in a
    profit of 300\. Next, we should buy the stock at a price of 500 on day 2 and sell
    it at a price of 1000 on day 3\. This transaction brings in a profit of 500\.
    Of course, we can merge these two transactions into one by buying at a price of
    200 on day 1 and selling at a price of 1000 on day 3\. The same logic can be applied
    until day 9\. The final maximum profit will be 1820\. Take your time and identify
    all the transactions from day 1 to day 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'By studying the preceding price-trend graphic, we can see that this problem
    can be viewed as an attempt to find all the ascending sequences. The following
    graph highlights the ascending sequences for our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.41 – Ascending sequences'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.41_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.41 – Ascending sequences
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding all the ascending sequences is a simple task based on the following
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the *maximum profit* as 0 (no profit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate all the days, starting from day 2, and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Compute the difference between the *today price* and the *preceding day price*
    (for example, at the first iteration, compute (the price of day 2 - the price
    of day 1), so 500 - 200).
  prefs: []
  type: TYPE_NORMAL
- en: b. If the computed difference is positive, then increment the *maximum profit*
    by this difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this algorithm, we will know the final *maximum profit*. If we
    apply this algorithm to our data, then we''ll obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.42 – Computing the final maximum profit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.42_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.42 – Computing the final maximum profit
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 1**: The *maximum profit* is 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 2**: The *maximum profit* is 0 + (500 - 200) = 0 + 300 = 300.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 3**: The *maximum profit* is 300 + (1000 - 500) = 300 + 500 = 800.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 4**: The *maximum profit* remains 800 since 700 - 1000 < 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 5**: The *maximum profit* remains 800 since 30 - 700 < 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 6**: The *maximum profit* is 800 + (400 - 30) = 800 + 370 = 1170.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 7**: The *maximum profit* is 1170 + (900 - 400) = 1170 + 500 = 1670.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 8**: The *maximum profit* remains 1670 since 400 - 900 < 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Day 9**: The *maximum profit* is 1670 + (550 - 400) = 1670 + 150 = 1820.'
  prefs: []
  type: TYPE_NORMAL
- en: The final *maximum profit* is 1820.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n). Next, let's tackle the last scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Buying and selling the stock only k times (k is given)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This scenario is the generalized version of the *Buying and selling the stock
    only twice*. scenario. Mainly, by solving this scenario, we also solve the *Buying
    and selling the stock only twice* scenario for *k*=2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our experience from the previous scenarios, we know that solving this
    problem can be done via Dynamic Programming. More precisely, we need to track
    two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: The first array will track the *maximum profit* of *p* transactions when the
    last transaction is on the *q*th day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second array will track the *maximum profit* of *p* transactions until the
    *q*th day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we denote the first array as `temp` and the second array as `result`, then
    we have the following two relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_OL
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For a better understanding, let''s put these relations into the context of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(kn). The complete application is called *BestTimeToBuySellStock*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 22 – Longest sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that you''ve been given an array of integers. Write a
    snippet of code that finds the longest sequence of integers. Notice that a sequence
    contains only consecutive distinct elements. The order of the elements in the
    given array is not important.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given array is { 4, 2, 9, 5, 12, 6,
    8}. The longest sequence contains three elements and it is formed from 4, 5, and
    6\. Alternatively, if the given array is {2, 0, 6, 1, 4, 3, 8}, then the longest
    sequence contains five elements and it is formed from 2, 0, 1, 4, and 3\. Again,
    notice that the order of the elements in the given array is not important.'
  prefs: []
  type: TYPE_NORMAL
- en: The brute-force or naive approach consists of sorting the array in ascending
    order and finding the longest sequence of consecutive integers. Since the array
    is sorted, a gap breaks a sequence. However, such an implementation will have
    a runtime of O(n log n).
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach consists of employing a *hashing* technique. Let''s use the
    following image as support for our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.43 – Sequence set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.43_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.43 – Sequence set
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we build a set from the given array {4, 2, 9, 5, 12, 6, 8}. As the preceding
    image reveals, the set doesn''t maintain the order of insertion, but this is not
    important for us. Next, we iterate the given array and, for each traversed element
    (let''s denote it as *e*), we search the set for *e*-1\. For example, when we
    traverse 4, we search the set for 3, when we traverse 2, we search for 1, and
    so on. If *e-*1 is not in the set, then we can say that *e* represents the start
    of a new sequence of consecutive integers (in this case, we have sequences starting
    with 12, 8, 4, and 2); otherwise, it is already part of an existing sequence.
    When we have the start of a new sequence, we continue to search the set for the
    consecutive elements: *e*+1, *e*+2, *e*+3, and so on. As long as we find consecutive
    elements, we count them. If e+*i* (1, 2, 3, ...) cannot be found, then the current
    sequence is complete, and we know its length. Finally, we compare this length
    with the longest length we''ve found so far and proceed accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with an auxiliary space of O(n). Challenge
    yourself and print the longest sequence. The complete application is called *LongestConsecutiveSequence*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 23 – Counting game score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider a game where a player can score 3, 5, or 10 points in
    a single move. Moreover, consider that you''ve been given a total score, *n*.
    Write a snippet of code that returns the number of ways to reach this score.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given score is 33\. There are seven
    ways to reach this score:'
  prefs: []
  type: TYPE_NORMAL
- en: (10+10+10+3) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (5+5+10+10+3) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (5+5+5+5+10+3) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (5+5+5+5+5+5+3) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (3+3+3+3+3+3+3+3+3+3+3) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (3+3+3+3+3+3+5+5+5) = 33
  prefs: []
  type: TYPE_NORMAL
- en: (3+3+3+3+3+3+5+10) = 33
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem with the help of Dynamic Programming. We create a
    table (an array) whose size is equal to *n*+1\. In this table, we store the counts
    of all scores from 0 to *n*. For moves 3, 5, and 10, we increment the values in
    the array. The code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with O(n) extra space. The complete application
    is called *CountScore3510*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 24 – Checking for duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if this array contains duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s assume that the given integer is *arr*={1, 4, 5, 4, 2,
    3}, so 4 is a duplicate. The brute-force approach (or the naive approach) will
    rely on nested loops, as shown in the following trivial code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very simple but it performs in O(n2) and O(1) auxiliary space.
    We can sort the array before checking for duplicates. If the array is sorted,
    then we can compare adjacent elements. If any adjacent elements are equal, we
    can say that the array contains duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This code performs in O(n log n) (since we sort the array) and O(1) auxiliary
    space. If we want to write an implementation that performs in O(n) time, we must
    also consider an auxiliary O(n) space. For example, we can rely on *hashing* (if
    you are not familiar with the concept of hashing, then please read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashSet` implementation, so there is no need to write a hashing
    implementation from scratch. But how is this `HashSet` useful? While we iterate
    the given array, we add each element from the array to `HashSet`. But if the current
    element is already present in `HashSet`, this means we found a duplicate, so we
    can stop and return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, this code performs in O(n) time and auxiliary O(n) space. But we can simplify
    the preceding code if we remember that `HashSet` doesn't accept duplicates. In
    other words, if we insert all the elements of the given array into `HashSet` and
    this array contains duplicates, then the size of `HashSet` will differ from the
    size of the array. This implementation and a Java 8-based implementation that
    has an O(n) runtime and an O(n) auxiliary space can be found in the code bundled
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about an implementation that has an O(n) runtime and an O(1) auxiliary
    space? This is possible if we take two important constraints of the given array
    into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: The given array doesn't contain negative elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements lies in the range [0, *n*-1], where *n=arr.length*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the umbrella of these two constraints, we can employee the following algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We iterate over the given array and for each *arr*[*i*], we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If *arr*[abs(*arr*[*i*])] is greater than 0, then we make it negative.
  prefs: []
  type: TYPE_NORMAL
- en: b. If *arr*[abs(*arr*[*i*])] is equal to 0, then we make it -(*arr.length*-1).
  prefs: []
  type: TYPE_NORMAL
- en: c. Otherwise, we return `true` (there are duplicates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider our array, *arr*={1, 4, 5, 4, 2, 3}, and apply the preceding
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*i*=0, since *arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 results in *arr*[1] =
    -*arr*[1] = -4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=1, since *arr*[abs(*arr*[1])] = *arr*[4] = 2 > 0 results in *arr*[4] =
    -*arr*[4] = -2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=2, since *arr*[abs(*arr*[5])] = *arr*[5] = 3 > 0 results in *arr*[5] =
    -*arr*[5] = -3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=3, since *arr*[abs(*arr*[4])] = *arr*[4] = -2 < 0 returns `true` (we found
    a duplicate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at *arr*={1, 4, 5, 3, 0, 2, 0}:'
  prefs: []
  type: TYPE_NORMAL
- en: '*i*=0, since *arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 results in *arr*[1] =
    -*arr*[1] = -4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=1, since *arr*[abs(*arr*[1])] = *arr*[4] = 0 = 0 results in *arr*[4] =
    -(*arr.length*-1) = -6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=2, since *arr*[abs(*arr*[2])] = *arr*[5] = 2 > 0 results in *arr*[5] =
    -*arr*[5] = -2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=3, since *arr*[abs(*arr*[3])] = *arr*[3] = 3 > 0 results in *arr*[3] =
    -*arr*[3] = -3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=4, since *arr*[abs(*arr*[4])] = *arr*[6] = 0 = 0 results in *arr*[6] =
    -(*arr.length*-1) = -6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=5, since *arr*[abs(*arr*[5])] = *arr*[2] = 5 > 0 results in *arr*[2] =
    -*arr*[2] = -5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*i*=6, since *arr*[abs(*arr*[6])] = *arr*[6] = -6 < 0 returns `true` (we found
    a duplicate).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s put this algorithm into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *DuplicatesInArray*.
  prefs: []
  type: TYPE_NORMAL
- en: For the following five coding challenges, you can find the solutions in the
    code bundled with this book. Take your time and challenge yourself to come up
    with a solution before checking the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 25 – Longest distinct substring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a string, *str*. The accepted characters
    of *str* belong to the extended ASCII table (256 characters). Write a snippet
    of code that finds the longest substring of *str* containing distinct characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As a hint, use the *sliding window* technique. If you are not
    familiar with this technique, then consider reading *Sliding Window Technique*
    by Zengrui Wang ([https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740))
    before continuing. The complete application is called *LongestDistinctSubstring*.
    You can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring)'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 26 – Replacing elements with ranks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array without duplicates, *m*.
    Write a snippet of code that replaces each element of this array with the element''s
    rank. The minimum element in the array has a rank of 1, the second minimum has
    a rank of 2, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TreeMap`. The complete application is called *ReplaceElementWithRank*. You
    can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank)'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 27 – Distinct elements in every sub-array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array, *m*, and an integer, *n*.
    Write a snippet of code that counts the number of distinct elements in every sub-array
    of size *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashMap` to store the frequency of the elements in the current window whose
    size is *n*. The complete application is called *CountDistinctInSubarray*. You
    can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray)'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 28 – Rotating the array k times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array, *m*, and an integer, *k*.
    Write a snippet of code that rotates the array to the right *k* times (for example,
    array {1, 2, 3, 4, 5}, when rotated three times, results in {3, 4, 5, 1, 2}).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As a hint, rely on the modulo (%) operator. The complete application
    is called *RotateArrayKTimes*. You can visit the following link to check the code:
    [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes).'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 29 – Distinct absolute values in sorted arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a sorted array of integers, *m*. Write
    a snippet of code that counts the distinct absolute values (for example, -1 and
    1 are considered a single value).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As a hint, use the *sliding window* technique. If you are not
    familiar with this technique, then consider reading *Sliding Window Technique*
    by Zengrui Wang ([https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740))
    before continuing. The complete application is called *CountDistinctAbsoluteSortedArray*.
    You can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to help you master various coding challenges involving
    strings and/or arrays. Hopefully, the coding challenges in this chapter have provided
    various techniques and skills that will be very useful in tons of coding challenges
    that fall under this category. Don't forget that you can enrich your skills even
    more via the book *Java Coding Problems* ([https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)),
    which is published by Packt as well. *Java Coding Problems* comes with 35+ strings
    and arrays problems that were not tackled in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss linked lists and maps.
  prefs: []
  type: TYPE_NORMAL
