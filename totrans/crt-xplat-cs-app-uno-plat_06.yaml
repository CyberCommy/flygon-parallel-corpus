- en: '*Chapter 4*: Mobilizing Your App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will show you how to develop apps with Uno Platform for mobile
    devices. Such apps can be quite different from ones that run on a desktop device
    or the web and bring their own challenges that you must take into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building for mobile devices running iOS and Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with remote data in occasionally connected environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling the app for the platform it is running on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the capabilities of the device that the app is running on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have created a mobile app that runs on Android
    and iOS devices, looks different on each platform, and communicates with a remote
    server to retrieve and send data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you already have your development environment set
    up, as well as the necessary project templates installed, as we covered in [*Chapter
    1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Introducing Uno Platform*.
    The source code for this chapter can be found at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter makes use of the following library: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also retrieves data from a remote web server that you can recreate
    with the code at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [https://bit.ly/3jKGRkI](https://bit.ly/3jKGRkI)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app we''ll be building in this chapter is called **Network Assist**. It''s
    an application that will be made available to all staff. It is particularly useful
    to those working at stations in a public-facing capacity. The real version of
    this app would have many features, but we''re only going to implement two:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing when the next trains will arrive at each station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and reporting details of events happening around the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this application will be used by staff members as they perform their jobs
    across the network, it will be built to run on Android and iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: What does "mobile" mean?
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to think of "mobile" as only being about the device an app is on,
    but to do so is limiting. "Mobile" can be a helpful shorthand for "Android and
    iOS devices." However, it's essential to remember more than phones (or tablets)
    are mobile. It's also the person who is using the device who is mobile. Considering
    the people who will be using the application is often more important than the
    device that it will be running on. The device is just one factor to consider.
    A person may use multiple devices as part of a process, thereby requiring the
    experience to be mobile as they move between devices – perhaps starting a task
    on one device and finishing it on another.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we're building the Network Assist app as a mobile one is primarily
    because the people who will use it will be travelling around all day. It's because
    the person is mobile that we're building a "mobile" app, that runs on a "mobile"
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than spending a lot of time explaining the functionality in advance,
    let's get on with building the app. We'll expand on the requirements as we write
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by creating the solution for the app:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, create a new project with the **Multi-Platform App (Uno Platform)**
    template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the project `NetworkAssist`. You can use a different name, but you'll need
    to adjust all subsequent code snippets accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all the platform head projects *except* for the **Android**, **iOS**,
    and **UWP** ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always keep the UWP head in the solution
  prefs: []
  type: TYPE_NORMAL
- en: Even if you're not going to release a UWP version of an app, there are two reasons
    to keep the UWP head in the solution. Firstly, this can be helpful when diagnosing
    any compilation errors, to check if the code has a fundamental problem or if the
    issue is related to the Uno-specific tooling. Secondly, and more importantly,
    Visual Studio can provide additional tooling and IntelliSense when the UWP head
    is selected. By having the UWP head in the project, your Uno Platform development
    experience will be more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the need to write more code than necessary, we'll add a reference to
    the shared library project. Right-click on the solution node in `UnoBookRail.Common.csproj`
    file, and click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the platform-specific projects, we need to add a reference to the
    common library project. Right-click on the **Android** project node in **Solution
    Explorer** and select **Add > Reference… > Projects**. Then, check the entry for
    **UnoBookRail.Common** and click **OK**. Now, *repeat this process for the iOS
    and UWP projects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the basic solution structure now ready, we can add some functionality to
    the main page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this will be a simple application, we will put all the functionality on a
    single page. The requirement for the design is that the app has tabs or buttons
    at the bottom of the screen to enable switching between the different areas of
    functionality. We'll put the different pieces of functionality in separate controls
    and change the control that's shown based on the button (or tab) the user presses.
  prefs: []
  type: TYPE_NORMAL
- en: This is appropriate because the user does not need to navigate backward through
    the tabs they have viewed already.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing for camera notches, cutouts, and safe areas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we add any of our own content, you may wish to run the app to check that
    everything compiles and can be debugged without issue. Depending on the device
    or simulator you run the app on, you may see something like the left-hand side
    of *Figure 4.1*, which shows the default app running on an iPhone 12 simulator.
    In this figure, you can see that the **Hello, World!** text overlaps (or crashes
    into) the time and goes behind the camera notch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have a device that allows you to test this, some emulators are
    available that have this notch. Other emulators will have a configurable option
    to allow testing with and without the cutout. Look under **Settings > System >
    Developer Options > Simulate a display with a cutout**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Before and after screenshots showing content allowing for the
    status bar and camera notch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_4.01_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Before and after screenshots showing content allowing for the status
    bar and camera notch
  prefs: []
  type: TYPE_NORMAL
- en: Our app won't have the **Hello, World!** text, but we don't want our content
    to be obscured. Fortunately, Uno Platform comes with a helper class that will
    allow space for camera notches, regardless of the device they are on or the position
    they are in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this helper class, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `xmlns:toolkit="using:Uno.UI.Toolkit"` to the `Page` element at the root
    of `MainPage.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `toolkit:VisibleBoundsPadding.PaddingMask="All"` to the `Grid` element inside
    the `Page` element. By setting a value of `All`, the helper will provide the appropriate
    space if the device is turned sideways, and the notch will be shown at the side
    of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the app now, you will see something like the right-hand side image
    in *Figure 4.1*, which demonstrates how adequate space has been added to the layout.
    This keeps the status bar or camera notch from obscuring our content.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken care of allowing notches on the screen, we can implement
    the functionality we need for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main page's content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we only have one page in the app, we''ll implement it now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing contents of `Grid` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The top row of the grid will contain the controls for the different elements
    of functionality. The bottom row will host the buttons for selecting the different
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: We're using a `CommandBar` as this is the UWP control that's best suited for
    providing buttons for selecting areas of functionality within the app. This is
    only an approximation of how we want things to look on iOS and Android, and we'll
    address those shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: XAML provides multiple ways of doing things that all produce comparable results.
    With the code in this chapter, we've used the simplest approach to provide a consistent
    output on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We now need custom controls for displaying the different pieces of functionality.
    Start by right-clicking on the `Views` so that it matches the convention for where
    to store UI-related controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wish, you can move the `MainPage` files into the `Views` folder, but
    it doesn't matter for the functionality of this app.
  prefs: []
  type: TYPE_NORMAL
- en: In the new folder, right-click and select `ArrivalsControl`. Repeat this to
    add a control named `QuickReportControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll now add the controls to `MainPage.xaml`. Declare a new XML namespace
    alias at the page level, with the value of `xmlns:views="using:Network Assist.Views"`.
    After the opening of the `Grid` tag and before `CommandBar`, add the following
    to create instances of our new controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code-behind file (`MainPage.xaml.cs`), we need to add the methods to
    handle the `Click` events referenced in the XAML for the AppBarButtons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll use click events and code-behind here as the logic is tightly coupled
    to the UI and won't benefit from having coded tests. It's possible and acceptable
    to use `ICommand` implementations and bindings to control when each control is
    shown, but it is up to you to implement it that way if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM and Code-Behind
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use a combination of code-behind files and the **Model-View-ViewModel**
    (**MVVM**) pattern. There are three reasons for this. Firstly, it allows us to
    keep the code shorter and simpler, so that it is easier for you to follow along.
    Secondly, it avoids the need to explain a specific MVVM framework or implementation,
    and we can instead focus on the code that's relevant to the application. Finally,
    it demonstrates that Uno Platform doesn't force you to work in a specific way.
    You can use the coding style, pattern, or framework you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: With the main page up and running, we can now add the functionality for displaying
    details of upcoming arrivals.
  prefs: []
  type: TYPE_NORMAL
- en: Showing upcoming arrival details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirements for showing upcoming arrivals are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of stations is displayed, and when one is selected, the arrival times
    of the next three trains in each direction are shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data can be refreshed to ensure the latest information is always available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time when the last piece of data was retrieved is displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompts are shown if no station is selected or there's a problem retrieving
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app indicates when it is retrieving data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see an example of the final functionality we''ll create by the end
    of this chapter in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Upcoming arrival details shown on an iPhone (left) and on an
    Android device (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.02_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Upcoming arrival details shown on an iPhone (left) and on an Android
    device (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'This user control for showing the upcoming arrivals is going to be the most
    complicated piece of UI in the app. It may seem like a lot of steps, but each
    one is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding two column definitions, and four row definitions to `Grid`
    in `ArrivalsControl.xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The top row will contain a `ComboBox` control for selecting the station and
    a `Button` element to request that the data be refreshed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two rows will use `TextBlocks` to show the time when data was last
    retrieved and if there was a problem retrieving data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`ListView` will use a couple of data templates that we''ll define at the control
    level. Add the following after the opening `UserControl` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth, and last, row contains a `ListView` that shows the upcoming arrival
    times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth row also contains a `Grid` that hosts other informational controls
    that are displayed over or instead of the `ListView` as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added quite a lot of XAML here. The first step to seeing how it looks
    is to wire up a ViewModel so that we can access the relevant properties and commands.
    Change the contents of `ArrivalsControlxaml.cs` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `using` declarations to the top of the file so that the compiler
    can find the types we just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We're now ready to create a ViewModel that will contain the remaining logic
    for the functionality. We'll start by creating a folder called `ViewModels`. Within
    that folder, create a class called `ArrivalsViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To avoid writing common code that''s needed when following the MVVM pattern,
    add a reference to the `Microsoft.Toolkit.Mvvm` NuGet package *in each of the
    platform head projects*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Update the `ArrivalsViewModel` class so that it inherits from `Microsoft.Toolkit.Mvvm.ComponentModel.ObservableObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ArrivalsViewModel` will use types from different places, so we need to reference
    the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by adding the following fields to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ViewModel` requires the following properties as they were referenced in
    the bindings of the XAML we defined previously. They will use the backing fields
    we just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the constructor to initialize the list of stations and the commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the method that handles retrieving and displaying the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that the data was retrieved from a singleton `DataService`
    class. We''ll start by creating a simple version of this that we''ll expand upon
    later. Common convention suggests putting this class in a directory called `Services`,
    though you could put this in the `ViewModels` folder as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `DataService` class, we can retrieve the arrival details,
    but we need to do a little bit more work to display them. There is one more class
    we need. This is `StationArrivalDetails`, and it allows us to group the information
    by the platform and direction the train is traveling in. Create this in the `ViewModels`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: CollectionViewSource with grouped data in Uno
  prefs: []
  type: TYPE_NORMAL
- en: Displaying grouped lists with Uno Platform is more complicated than on UWP.
    If you've previously used a `CollectionViewSource` in a UWP app, you've probably
    defined it in XAML and not as an `IEnumerable<object>`. Unfortunately, it's necessary
    to define our `CollectionViewSource` as an `IEnumerable<IEnumerable>` for Uno
    Platform to correctly render all the groups and headers on Android and iOS. Without
    doing this, we'd see the group headings missing on iOS and only the first group's
    contents on Android.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working app, but there are two improvements we'll make in the
    next two sections. There, we'll improve the look of the app and use some native
    controls, but before that, we'll switch to use "as live" data from a remote source
    and not data that ships with the app.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving remote data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very few apps only work with the data that they ship with. The value the **Network
    Assist** provides is based on giving real-time information. There is a lot more
    value in knowing when trains will actually arrive rather than just when they are
    scheduled to arrive. To gather this information, the app must connect to a remote
    source of real-time data.
  prefs: []
  type: TYPE_NORMAL
- en: Most mobile applications connect to external data sources, and the most common
    way to do this is over HTTP(S). If you're only developing an application that
    runs on desktop, you might be able to assume that a connection is always available.
    For mobile apps, it's necessary to consider the device as being **occasionally
    connected**.
  prefs: []
  type: TYPE_NORMAL
- en: As it's impossible to assume that an app will have a connection available or
    that it will be fast, it's necessary to account for this when designing an app.
    These issues apply to all mobile apps and are not something unique to developing
    with Uno Platform. The correct way to handle the occasional connectivity and availability
    of data will vary by application. It's too big an issue for us to fully cover
    here but important to bring up. At a minimum, accounting for occasional connectivity
    means needing to consider retrying failed connection requests and managing data.
    The code we wrote previously in the `LoadArrivalsDataAsync` method already does
    a crude form of caching, by not getting rid of the current information when refreshing
    the data until a successful request is made and newer data is available to display.
    While the information shown in the app can become outdated very quickly, it's
    considered more appropriate for the app to show something that it acknowledges
    is a few minutes out of date than to show nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In another app, it may be more appropriate to save data in a file or database
    so that it can be retrieved and shown when remote data is not available. [*Chapter
    5*](B17132_05_Final_VK_ePub.xhtml#_idTextAnchor083), *Making Your App Ready for
    the Real World*, shows how you may do this using an SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at how the app can handle failures in connecting to the remote data
    shortly, but first, we'll look at how to connect to the remote data.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a remote data source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GitHub repository for this book at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform)
    includes a **WebAPI** project that will return train arrival data for the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose to run the code and access it via your local machine, or you
    can connect to the version available at [https://unobookrail.azurewebsites.net/](https://unobookrail.azurewebsites.net/).
    If you''re connecting to the hosted version, note that it bases data on the local
    time for the server, and this may be different from where you are. If the server
    continually says there is a long time until the next train as it''s the early
    hours of the morning where the server is, you''ll see more varied data if you
    run the project yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use `System.Net.Http.HttpClient` to connect to the server. To be able
    to do this, we must add package references to `System.Net.Http` in the *Android
    and iOS* projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As the data that''s returned by the API is in JSON format, we''ll also add
    a reference to the `Newtonsoft.Json` library in *all platform projects* so that
    we can deserialize the responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to retrieve remote data. The changes will all be in the `DataService.cs`
    file. Start by adding an instance of an `HttpClient`. We will use this for all
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To connect to the server, we need to specify where it is. As we will eventually
    be making multiple requests, it's sensible to define the server domain in a single
    place. We'll do this by `__ANDROID__` constant, which is available to the `#if`
    preprocessor directive. See [*Chapter 2*](B17132_02_Final_VK_ePub.xhtml#_idTextAnchor033)*,
    Writing Your First Uno Platform App*, for more on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're connecting to a locally hosted WebAPI instance from an Android emulator,
    it's necessary to use the IP address of `10.0.2.2` to connect. This is a special
    IP address that the emulator uses to refer to the host machine. You can use conditional
    compilation to specify this, as in the preceding snippet. If you're connecting
    to an external server, you can set the address directly and don't need any conditional
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the `GetArrivalsForStationAsync` method to get the live data.
    *Replace* the current implementation with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app now, the data will come from the remote location. You might
    notice that data retrieval is no longer instantaneous and that a busy indicator
    is shown while waiting. We added the code for showing the progress indicator in
    the original version of the app but haven't seen it displayed until now. This
    highlights another potential issue when working with data that takes time to retrieve.
    *It is crucial to keep the user informed when something is happening*. We're using
    a `ProgressRing` here to indicate that something is happening. Without this, the
    user may be wondering if anything is happening and become frustrated or press
    the refresh button repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've retrieved data from a remote source and kept the user informed
    while this is happening, but we need to do more for when things go wrong. So,
    we'll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Polly to handle exceptions and retry requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The need to handle exceptions and retry failed requests is common across almost
    all applications. Fortunately, many solutions exist to handle some of the complexity
    for us. **Polly** ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly))
    is a popular, open source library for handling transient errors that we''ll use
    in our app. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a reference to the `Polly.Extensions.Http` package to
    *all the platform projects*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This extends the standard Polly capabilities and simplifies handling HTTP-related
    faults.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now update the `GetArrivalsForStationAsync` method again so that it uses
    a Polly `HandleTransientHttpError`. This tells Polly to retry the request if the
    HTTP response is a server error (HTTP 5xx) or a timeout error (HTTP 408).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The call to `WaitAndRetryAsync` tells Polly to retry up to three times. We also
    specify a delay between each request using an `policy.ExecuteAsync` and pass it
    the action we wish to apply the policy to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the request fails for a reason not covered by our policy, the code we created
    earlier causes a message to be shown at the top of the screen, as shown in the
    following screenshot, that indicates the problem. Other applications may need
    to log or report such problems differently, but it''s rarely appropriate to do
    nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – App showing a message to indicate a connectivity problem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – App showing a message to indicate a connectivity problem
  prefs: []
  type: TYPE_NORMAL
- en: We now have an app that provides useful data from a remote source, and in a
    reliable way. The final thing we want to do is improve how it looks on different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Making your app look like it belongs on each platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything in the app has used the default styling provided by Uno Platform.
    Because Uno Platform bases everything on UWP and WinUI, our apps have been styled
    based on the Fluent Design system as this is the default on Windows. This is fine
    if we want our apps to look this way, but what if we want our apps to use the
    default styles for Android or iOS? Fortunately, Uno Platform has a solution for
    us. It provides libraries in the **Material** and **Cupertino** styles that we
    can apply to our apps. While these are native for Android and iOS devices, respectively,
    they can be used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now use the resources these libraries provide to apply the Material Design
    styling to the Android version of our app, and the Cupertino styles to the iOS
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Material styles to the Android version of the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a reference to the `Uno.Material` package to the *Android
    project*. Note that this is a prerelease package, so enable this if you''re searching
    via the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `Uno.Material` library knows how to style controls, it doesn''t contain
    all the assets and references to use them. For this, *add* the `Xamarin.AndroidX.Lifecycle.LiveData`
    and `Xamarin.AndroidX.AppCompat.AppCompatResources` packages *to the Android project*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the styles in the Android library, we must add them to the styles available
    in the app by referencing them in `App.xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Some controls will pick up Material styling automatically, while others will
    need to have the styles applied directly. To show this, we'll apply a specific
    style to the refresh `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `ArrivalsControl.xaml`, *add the Android namespace alias* to the top of
    the file. We will only use this when running on Android. Then, apply the style
    to the `Button` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than using the Windows `CommandBar`, the Material Design system has
    a separate control that is more appropriate for showing navigation-related buttons
    at the bottom of the screen. This is called `BottomNavigationBar`. We''ll start
    by adding this to `MainPage.xaml` and wrapping the existing `CommandBar` in a
    `Grid` that will only be shown on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you run the app now, you'll see that the button and navigation bar are purple.
    This is part of a color scheme defined in the `Uno.Material` library. You can
    use your own color scheme by including a `ResourceDictionary` that provides different
    values for the predefined Material colors. Then, you can reference this when you
    add the resources shown in *step 2*. A guide to doing this can be found at [https://platform.uno/docs/articles/features/uno-material.html#getting-started](https://platform.uno/docs/articles/features/uno-material.html#getting-started).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've improved the app's look on Android, let's do the same for iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Cupertino styles to the iOS version of the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A separate package includes the Cupertino styles, so we must add a reference
    to `Uno.Cupertino` *in the iOS project*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the Material package in the previous section, we need to load the resources
    from this package in `App.xaml` by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This package doesn't include a native tab bar control (a `UITabBar`) yet, but
    we can easily create something that matches Apple's Human Interface Guidelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Add* the following to `MainPage.xaml`, after the `win:Grid` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: using Windows.UI.Xaml.Data;
  prefs: []
  type: TYPE_NORMAL
- en: 'public class CupertinoButtonColorConverter : IValueConverter'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public object Convert(object value, Type targetType,
  prefs: []
  type: TYPE_NORMAL
- en: object parameter, string language)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (value?.ToString() == parameter?.ToString())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return App.Current.Resources[
  prefs: []
  type: TYPE_NORMAL
- en: '"CupertinoBlueBrush"];'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return App.Current.Resources[
  prefs: []
  type: TYPE_NORMAL
- en: '"CupertinoSecondaryGrayBrush"];'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public object ConvertBack(object value, Type
  prefs: []
  type: TYPE_NORMAL
- en: targetType, object parameter, string language)
  prefs: []
  type: TYPE_NORMAL
- en: => throw new NotImplementedException();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the Android project, the Cupertino styles won''t be automatically applied
    to the buttons in the app. However, rather than applying styles to each `Button`
    element directly, we can create an *implicit style* that will be applied to all
    the `Button` elements throughout the app. To do this, *modify* `App.xaml` to add
    the style, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Implicit styles can be used for any platform so, if you wanted, you could do
    a similar thing in the Android version of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an app that looks like it belongs on each platform, and it can display
    content we retrieve from an external server. Now, let's look at how we can use
    the device's capabilities to create data and send it to a remote source.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing device capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of functionality we'll add to the app is different from what
    we've done so far. So far we've looked at consuming data, but we'll now look at
    creating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement from the company for this part of the app is that it provides
    a way for staff to capture information whenever an incident occurs. An "incident"
    could be anything that the business may need to record or know about. It could
    be something minor such as a customer tripping while on company property to a
    major accident. All these incidents have something in common: that it''s beneficial
    to capture details when they happen rather than relying on people remembering
    details later. The goal is that giving staff a way to capture an image or some
    text as quickly and simply as possible will increase the amount of information
    that''s captured. The software will augment the captured information with the
    time and location of the incident and add who recorded it. This will be aggregated
    and further documented in a separate backend system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple way of meeting these requirements as a way of demonstrating
    how Uno Platform provides a way to use UWP APIs on different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: To use the camera and get the location of the device, we need to indicate that
    the app will require the permissions that are necessary to do this. The way we
    specify permissions is done slightly differently on each platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Android, open the project's `info.plist` and open it with `Package.appxmanfiest`,
    go to `CameraCaptureUI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the UI by adding the following to `Grid` in `QuickReportControl.xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In `QuickReportControl.xaml.cs`, let''s add the code to handle what happens
    when the user clicks on the button to add a photo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now create a method to encapsulate the logic to retrieve the device''s
    location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to add the event handler for the `"success"` when valid data
    is submitted. The app checks for this and displays an appropriate message to the
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may think it will be more convenient to allow the user to speak to the app
    and record their voice. This is a sensible suggestion and something that could
    easily be added in the future. We're not including it here as most devices have
    built-in capabilities to use speech to text to enter details. It can be quicker
    and easier to use the existing functionality of a device rather than duplicating
    what's already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this final piece of functionality now complete, our app is finished. You
    can see how it looks when run in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Quick Report screen running on an iPhone (left) and showing
    a selected image, and an Android device (right) showing the entry of some dictated
    text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – The Quick Report screen running on an iPhone (left) and showing
    a selected image, and an Android device (right) showing the entry of some dictated
    text
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an app that works on both iOS and Android devices.
    This allowed you to learn what it means to create "mobile" apps, work with remote
    data, apply native platform theming to apps, and use native device capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build another mobile app. This will be different
    from the ones we've made so far in that it is intended to be used by customers
    rather than the company's staff. Among other things, we'll use this app as an
    opportunity to look at accessibility, localization, and using an SQLite database.
  prefs: []
  type: TYPE_NORMAL
