- en: 6\. Streams and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Write and read data to/from files or the console using the Standard I/O Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format and parse data using the in-memory I/O interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend standard I/O streams for user-defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop applications that use the I/O Standard Library from multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll develop flexible and maintainable applications using
    the I/O Standard Library, work with streams, learn how the I/O library can be
    used in multithreaded applications, and finally learn to format and parse data
    using the Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we covered one of the most challenging topics – concurrency
    in C++. We looked at the main multithreaded concepts and differentiated between
    synchronous, asynchronous, and threaded execution in C++. We learned the key points
    about synchronization, data hazards, and race conditions. Finally, we looked at
    working with threads in modern C++. In this chapter, we will go deeper and learn
    how to handle I/O in multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to `streams` and `I/O` in C++. I/O is the general
    concept of input and output operations. The main purpose of this part of the Standard
    Library is to provide a clear interface regarding the input and output of data.
    But this is not the only goal. There are a lot of situations where I/O can help
    us in our applications. It's hard to imagine any application that doesn't write
    errors or exceptional situations into the log file with the purpose of sending
    it to the development team for analysis. In GUI applications, we always need to
    format the displayed information or parse the user input. In complex and large
    applications, we usually need to log internal data structures, and so on. In all
    these cases, we employ the I/O portion of the `Standard Library`.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our chapter with a brief introduction to the Input/Output portion
    of the Standard Library. We will learn about the I/O and explore their main concepts
    and terms. Then, we will consider which types are supported by default and how
    we can extend streams to user-defined types. Next, we will study the structure
    of the I/O library and check the headers and classes available for our use. Finally,
    we will investigate how to work with streams, read and write to a file, create
    multithreaded applications with input and output operations, and format and parse
    text data.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be concluded with a challenging and exciting activity in which
    we will improve our `Art Gallery Simulator` project from the previous chapter
    and create a robust, clear, multithreaded, and easy to use `Logger`. We will develop
    a class with a clear interface that can be accessed from any place in the project.
    Next, we will adapt it to work with several threads. Finally, we will integrate
    our robust logger into the Art Gallery Simulator project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the I/O part of the C++ Standard Library and learn
    what opportunities are open to us with this set of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the I/O Portion of the Standard Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In computer science, I/O is the term that implies the communication between
    programs, devices, computers, and so on. In C++, we employ standard input and
    standard output terms to describe the I/O process. Standard input means the streams
    of data that are transferred into the program. To get this data, the program should
    perform the read operation. Standard output means the streams of data that are
    transferred from a program to an external device, such as a file, display, socket,
    printer, and so on. To output this data, the program should perform the write
    operation. Standard input and output streams are inherited from the main process
    and are common for all child threads. Take a look at the following diagram to
    get a better understanding of the considered terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: I/O communication between devices'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the C++ Standard Library, most of the I/O classes are generalized class templates.
    All of them are logically divided into two categories – abstractions and implementations.
    We are already familiar with the abstraction classes and know that we can use
    them for different purposes without recompiling the code. The same is true for
    the I/O library. Here, we have six abstract classes that are the basis of the
    I/O operations in C++. We will not deep dive into these interfaces. Usually, we
    use more high-level classes for our operations and appeal to them only if we need
    to implement our own derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ios_base** abstract class is responsible for managing stream status flags,
    formatting flags, callbacks, and private storage. The **basic_streambuf** abstract
    class provides an interface for buffering input or output operations and provides
    access to the source of input, such as a file, socket, or sink of output, such
    as a string or vector. The **basic_ios** abstract class implements facilities
    for work with derived classes from the **basic_streambuf** interface. The **basic_ostream**,
    **basic_istream**, and **basic_iostream** abstract classes are wrappers for derived
    classes from the **basic_streambuf** interface and provide a high-level input/output
    interface, respectively. Let''s briefly consider them and their relationships,
    which are shown in the following class diagram. You can see that all of them,
    except for **ios_base**, are template classes. Under the name of each class, you
    can find the file name where this class is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the UML notation, we use the `<<interface>>` keyword to show that class is
    an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Class diagram of I/O abstract interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Class diagram of I/O abstract interfaces'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Implementation classes are logically divided into the following categories:
    **File I/O**, **String I/O**, **Synchronized I/O**, **I/O manipulators**, and
    predefined standard stream objects. All of them are derived from the aforementioned
    abstract classes. Let''s consider each of them in detail in the upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Standard Stream Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start our acquaintance with the I/O Standard Library with the already
    familiar `std::cout` class from the `<iostream>` header file. We use it for outputting
    the data to the Terminal. You may also be aware about the `std::cin` class for
    reading user input – but not everyone knows that `std::cout` and `std::cin` are
    predefined standard stream objects that are used for formatting input and output
    to the Terminal. The <iostream> header file also contains `std::cerr` and `std::clog`
    stream objects, which are used for logging errors. As usual, there are also their
    analogs for wide characters with a prefix of "`w`": `wcout`, `wcin`, `wcerr`,
    and `wclog`. All of these objects are automatically created and initialized at
    system startup. Although it is safe to use these objects from multiple threads,
    the output can be mixed. Let''s revise how to use them. Since they are only overloaded
    for built-in types, we should write our own overrides for user-defined types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::cout` stream object is often used with the `std::endl` manipulator.
    It inserts a newline character in the output sequence and flushes it. Here is
    an example of using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Originally, the `std::cin` object reads all input character sequence, symbol
    by symbol. But it has overloads for built-in types and can read values such as
    `numbers`, `strings`, `characters`, and so on. There is a little trick in reading
    strings; `std::cin` reads the string until the next whitespace or newline symbol.
    So, if you need it to read a string, you have to do it in a loop, read it word
    by word, or use the `std::getline()` function, which takes the `std::cin` object
    as the first parameter and the destination string as the second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The right shift operator, `>>`, of the `std::cin` stream object reads only one
    word from a line. Use `std::getline(std::cin, str)` to read the whole line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `std::cin` with different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we read the name using the `std::getline()` function because
    the user can input two or three words. We also read the age and then read the
    sex using the right shift operator, `>>`, because we need to read only a single
    word. We then print the read data to ensure that everything went well.
  prefs: []
  type: TYPE_NORMAL
- en: The **std::cerr** and **std::clog** stream objects differ in only one way –
    **std::cerr** immediately flushes the output sequence, while **std::clog** buffers
    it and flushes only when the buffer is full. When it comes to usage, they are
    very similar to **std::cout**. The only difference is that the messages from **std::cerr**
    and **std::clog** (in most of the IDEs) are red in color.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the output from these stream objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The output from the std::cerr and std::clog stream objects'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, let's perform an exercise to consolidate everything we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Overriding the Left Shift Operator, <<, for User-Defined Types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will write a very useful portion of code that you can
    use anywhere to output user-defined types. First of all, we will create a class
    with the name `Track` that represents a musical track. It will have the following
    private members: `name`, `singer`, `length`, and `date`. Then, we will override
    the left shift operator, `<<`, for this class. Next, we will create an instance
    of this class and output it using the `std::cout` stream object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to execute this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers: `<iostream>` for output to a console and `<string>`
    for string support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `Track` class and add the private section variables for keeping
    information about the `track`, that is, `m_Name`, `m_Singer`, `m_Date`, and `m_LengthInSeconds`.
    In the public section, add a constructor with parameters that initialize all the
    private variables. Also, add the `public` section getters for all class members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the most difficult part of the exercise: writing the overload function
    for the `Track` type. This is a `template` function that has two type parameters:
    `charT` and `Traits`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We made this function inline to let the compiler know that we want it to perform
    optimization on this function. The return type of this function is a reference
    to a `std::basic_ostream<charT, Traits>` class. The name of this function is operator
    `<<`. This function takes two parameters: the first is the reference to the `std::basic_ostream<charT,
    Traits>` class and the second is a copy of the `Track` variable. The full function
    declaration is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the function definition. Use the `os` variable, just like we use the
    `std::cout` object, and format the output as you wish. Then, return the `os` variable
    from the function. The complete code of the overloaded operator, `<<`, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the `main` function and create and initialize the instance of the
    `Track` type with the name `track_001`. Finally, use `std::cout` to print the
    `track_001` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and execute the application. Run it. You will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The result of executing Exercise 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Great job. Here, we considered using predefined standard stream objects and
    learned how to write our own overloaded shift operators for user-defined types.
    Let's move on and examine reading and writing to a file with the C++ Standard
    IO Library.
  prefs: []
  type: TYPE_NORMAL
- en: File I/O Implementation Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File streams manage input and output to files. They provide an interface that
    implements the `basic_ifstream` for input operations, `basic_ofstream` for output
    operations, `basic_fstream` for both input and output operations, and `basic_filebuf`
    for the implementation of a raw file device. All of them are defined in the `<fstream>`
    header file. The Standard Library also provides typedefs for char and `wchar_t`
    types, that is, `ifstream`, `fstream`, and `ofstream`, and the same names with
    a "`w`" prefix for wide characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a file stream in two ways. The first way is to do this in one
    line, that is, to open a file and connect a stream to a file by just passing the
    filename to a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is creating an object and then calling the `open()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'IO streams have bool variables: a **goodbit**, an **eofbit**, a **failbit**,
    and a **badbit**. They are used to check the state of the stream after each operation
    and indicate which error happened on the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the object''s creation, we can check the stream status by checking the
    `failbit` or checking the stream associated with the open file. To check a `failbit`,
    call the `fail()` function on the `file` stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the stream is associated with the open file, call the `is_open()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Input, output, and bidirectional file streams can also be opened in different
    modes by using flags. They are declared in the `ios_base` namespace. Besides the
    `ios_base::in` and `ios_base::out` flags, we also have the `ios_base::ate`, `ios_base::app`,
    `ios_base::trunc`, and `ios_base::binary` flags. The `ios_base::trunc` flag removes
    the content of the file. The `ios_base::app` flag always writes the output to
    the end of the file. Even if you decide to change the position in the file, you
    cannot do this. The `ios_base::ate` flag sets the position of the file descriptor
    to the end of the file but allows you to modify the position later. Finally, the
    `ios_base::binary` flag suppresses any formatting of the data so that it's read
    or wrote in "raw" format. Let's consider all the possible combinations of open
    modes.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `std::ofstream` is opened in `ios_base::out` mode, `std::ifstream`
    is opened in `ios_base::in` mode, and `std::fstream` is opened in `ios_base::in|ios_base::out`
    mode. The `ios_base::out|ios_base::trunc` mode creates the file if it doesn't
    exist or removes all the content from the existing file. The `ios_base::out|ios_base::app`
    mode creates the file if it doesn't exist or opens the existing file and allows
    you to write only at the end of the file. Both of the aforementioned modes can
    be combined with the `ios_base::in` flag, so the file will be opened in read and
    write mode simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to open the file using the aforementioned modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve opened the file stream in the required mode, we can start reading
    or writing to a file. The file streams allow us to change our position in the
    file. Let''s consider how we can do this. To get the current file''s position,
    we can call the `tellp()` function in `ios_base::out` mode and the `tellg()` function
    in `ios_base::in` mode. It can be used later so that we can return to this position
    if needed. We can also find the exact position in a file by using the `seekp()`
    function in `ios_base::out` mode and the `seekg()` function in `ios_base::in`
    mode. It takes two parameters: the number of characters to shift and from which
    file position it should count. There are allowed three types of positions to `seek:
    std::ios_base::beg`, that is, the beginning of file, `std::ios_base::end`, that
    is, the end of file, and `std::ios_base::cur`, that is, the current position.
    Here is an example of calling the `seekp()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we ask to set the current file's position at the fifth character
    from the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to the file, we can use the overloaded left shift operator, `<<`,
    for general formatted output, the `put()` function to write a single character,
    or the `write()` function to write a block of characters. Using the left shift
    operator is the most convenient way to write data to file as you can pass any
    built-in type as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `put()` and `write()` functions can only be used with character values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read from a file, we can use the overloaded right shift operator, `>>`,
    or use a set of functions for reading characters, such as `read()`, `get()`, and
    `getline()`. The right shift operator is overloaded for all built-in types and
    we can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the file stream is closed when the execution leaves the scope of visibility,
    so we don't need to perform any additional actions to close the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be attentive while reading data from a file. The right shift operator, `>>`,
    only reads a string until a whitespace or newline character. To read the full
    string, you could use a loop or read each word in a separate variable, like we
    did in *Exercise 1*, *Overriding the Left Shift Operator ,<<, for User-Defined
    Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's practice reading and writing data to a file using the C++ IO Standard
    Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Reading and Writing User-Defined Data Types to a File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll write a piece of code for a book shop. We need to
    store information about book prices in a file and then read that information from
    a file when needed. To implement this, we will create a class that represents
    a book with a name, author, year of publishing, and a price. Next, we will create
    an instance of this class and write it to a file. Later, we will read the information
    about the book from the file into the instance of the book class. Perform the
    following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers: `<iostream>` for output to a console, `<string>`
    for string support, and `<fstream>` for I/O file library support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Book` class, which represents the book in a book shop. In the
    private section, define four variables with self-explanatory names: `m_Name`,
    `m_Author`, `m_Year`, and `m_Price`. In the public section, define a constructor
    with parameters, which initializes all class members. Also, in the `public` section,
    define getters for all the class members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function and declare the `pricesFile` variable, which holds
    the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an instance of the `book` class and initialize it with `book name`,
    `author name`, `year`, and `price`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Write this class instance to a file. Create an instance of the `std::ofstream`
    class. Open our file with the `pricesFile` variable name. Check if the stream
    is successfully opened and print an error message if not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write all the information about the `book_001` book to a file using getters
    with spaces between each item and a newline symbol at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Compile and execute the application. Now, go to the project folder and find
    where the '**prices.txt**' file is located. In the following screenshot, you can
    see the location of the created file in the project directory:![](img/C14583_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.5: Location of the created file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Open it in **Notepad**. In the following screenshot, you can see what the output
    to the file looks like:![](img/C14583_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.6: The result of the output of the user-defined type to the file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, let''s read this data to the variable. Create an instance of the `std::ifstream`
    class. Open the file called `pricesFile`. Check if the stream has been successfully
    opened and print an error message if not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the local variables that will be used for the input from a file, namely
    `name`, `authorName`, `authorSurname`, `year`, and `price`. Their names are self-explanatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, read the data from the file into variables in the order they are in the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Book` instance called `book_002` and initialize it with those read
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the read operation successfully executed, print the `book_002`
    variable to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and execute the application again. In the console, you will see the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The result of executing Exercise 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, we wrote and read custom formatted data from a file without
    any difficulties. We created our own custom type, wrote it to the file using the
    `std::ofstream` class, and checked that everything was wrote successfully. Then,
    we read those data from a file to our custom variable using the `std::ifstream`
    class, output it to the console, and ensured that everything was read correctly.
    By doing this, we learned how to read and write data to a file using the I/O Standard
    Library. Now, let's move on and learn about the in-memory portion of the I/O library.
  prefs: []
  type: TYPE_NORMAL
- en: String I/O Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The I/O Standard Library allows input and output – not only to devices such
    as files but also to memory, in particular, to the `std::string` objects. In this
    case, the string can be a source for input operations as well as a sink for output
    operations. In the `<sstream>` header file, stream classes are declared that manage
    input and output to strings. They, like the file streams, also provides an interface
    that implements RAII – the string opens for reading or writing upon the stream''s
    creation and closes on its destruction. They are represented in the Standard Library
    by the following classes: `basic_stringbuf`, which implements a raw string interface,
    `basic_istringstream` for input operations, `basic_ostringstream` for output operations,
    and `basic_stringstream` for both input and output operations. The Standard Library
    also provides typedefs for `char` and `wchar_t` types: `istringstream`, `ostringstream`,
    and `stringstream` and the same names with the "w" prefix for wide characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object of the `std::istringstream` class, we should pass the initializer
    string as a constructor parameter or set it later using the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to read values from the stream, use the right shift operator, `>>`, which
    is overloaded for all built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an object of the `std::ostringstream` class, we just declare a variable
    of its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to write data to the string, use the left shift operator, `<<`, which
    is overloaded for all built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the resulting string, use the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::stringstream` object works bidirectional, so it has both a default
    constructor and a constructor that takes the string. We can create the default
    `std::stringstream` object by declaring the variable of this type and then use
    it for reading and writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can create `std::stringstream` using the constructor with a string
    parameter. Then, we can use it for reading and writing as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create a default `std::stringstream` object and initialize
    it by setting a string using the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the ss object for reading and writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply open modes for these kinds of streams. Their functionality
    is similar to that of file streams but with a little difference. `ios_base::binary`
    is irrelevant in the case of working with string streams and `ios_base::trunc`
    is ignored. Thus, we can open any of the string streams in four modes: `ios_base::app`,
    `ios_base::ate`, and `ios_base::in/ios_base::out`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's practice reading and writing data to a string using the C++ IO Standard
    Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Creating a Function for Replacement Words in a String'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a function that parses the given string
    and replaces the given word by other words. To complete this exercise, we create
    a callable class that takes three parameters: the original string, the word to
    be replaced, and the word that will be used for replacing. As a result, the new
    string should be returned. Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers: `<iostream>` for the output to a Terminal and
    `<sstream>` for I/O string support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the callable class with the name `Replacer`. It has only one function
    – an overloaded parentheses operator, (), that returns a string and takes three
    parameters: the original string, the word to be replaced, and the word to be used
    for replacing. The function declaration looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `istringstream` object, that is, `iss`, and set the `originalString`
    variable as the source of input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ostringstream` object, that is, `oss`, that will hold the converted
    string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the loop, while there is possible input, perform a read of the word
    to the word variable. Check if this word is equal to the `wordToBeReplaced` variable.
    If so, replace it with the `wordReplaceBy` variable and write to the `oss` stream.
    If they are unequal, write the original word to the `oss` stream. After each word,
    add a whitespace character since the `iss` stream truncates them. Finally, return
    the result. The complete class is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function. Create an instance of the `Replacer` class with
    a name of worker. Define the `foodList` variable and initialize it by the string
    that contains a list of food; some items should be repeated. Define the `changedList`
    string variable and initialize it by the return value of the `worker()` function.
    Use `std::cout` to display the result in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile, build, and run the exercise. As a result, you will get the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8: The result of executing Exercise 3](img/C14583_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The result of executing Exercise 3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Well done! Here, we learned how to use string streams for formatting input and
    output. We created an application that easily replaces words in a sentence, strengthened
    our knowledge, and now we are ready to learn about I/O manipulators so that we
    can improve our skills regarding working with threads.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Manipulators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we've learned about simple input and output using streams, but they
    are not sufficient in many cases. For more complex I/O data formatting, the Standard
    Library has a big set of I/O manipulators. They are functions that have been developed
    to work with shift operators, both left (<<) and right (>>), to control how streams
    behave. I/O manipulators are divided into two types – those that are invoked without
    arguments and those that needs arguments. Some of them work both for input and
    output. Let's briefly consider their meaning and usage.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Manipulators for Changing the Numeric Base of the Stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `<ios>` header, there are declared functions for changing the numeric
    base of the stream: `std::dec`, `std::hex`, and `std::oct`. They are invoked without
    arguments and set the numeric base of the stream to decimal, hexadecimal, and
    octal, respectively. In the `<iomanip>` header, the `std::setbase` function is
    declared, which is invoked with the following arguments: 8, 10, and 16\. They
    are interchangeable and work for both input and output operations.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `<ios>` header, there is also the `std::showbase` and `std::noshowbase`
    functions, which control displaying the numeric base of the stream. They only
    affect hexadecimal and octal integer output, except the zero value, and monetary
    input and output operations. Let's complete an exercise and learn how to use them
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Displaying Entered Numbers in Different Numeric Bases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will develop an application that, in the infinite loop,
    asks the user to enter an integer in one of the following numeric bases: decimal,
    hexadecimal, or octal. After reading the input, it displays this integer in other
    numeric representations. To perform this exercise, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `<iostream>` header for streaming support. Declare the enumeration
    called `BASE` and define three values: `DECIMAL`, `OCTAL`, and `HEXADECIMAL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a function called `displayInBases` that takes two parameters – integer
    and base. Next, define the switch statement, which tests the received numeric
    base and displays the given integer in the other two numeric representations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function and define the integer variable that will be used
    for reading user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an infinite while loop. Inside the loop, ask the user to enter a decimal
    value. Read the input as a decimal integer. Pass it to the `displayInBases` function.
    Next, ask the user to enter a hexadecimal value. Read the input as a hexadecimal
    integer. Pass it to the `displayInBases` function. Finally, ask the user to enter
    an octal value. Read the input as an octal integer. Pass it to the `displayInBases`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application. Follow the output and enter, for example, 12
    in different numeric representations. The output should be as follows:![Figure
    6.9: The result of executing Exercise 4, part 1](img/C14583_06_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.9: The result of executing Exercise 4, part 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, let''s change `std::dec`, `std::oct`, and `std::hex` in the `std::setbase()`
    function to check whether the output will be the same. First, add the `<iomanip>`
    header for `std::setbase()` support. Next, in the main function in the loop, replace
    `std::dec` with `std::setbase(10)`, `std::hex` with `std::setbase(16)`, and `std::oct`
    with `std::setbase(8)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, build and run the application. Follow the output and enter the same
    integer (12) in different numeric representations. The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10: The result of executing Exercise 4, part 2](img/C14583_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The result of executing Exercise 4, part 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, compare the results. As you can see, the output is identical. By doing
    this, we made sure that these functions are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Manipulators for Floating-Point Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `<ios>` header, there are declared functions for changing floating-point
    digit formatting: `std::fixed`, `std::scientific`, `std::hexfloat`, and `std::defaultfloat`.
    They are invoked without arguments and set `floatfield` to fixed, scientific,
    fixed and scientific, and default values, respectively. There is also the `std::
    showpoint` and `std::noshowpoint` functions, which control displaying floating-point
    digits. They only affect the output. The `std::noshowpoint` function only affects
    floating-point digits without the fractional part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `<iomanip>` header, there is a declared `std:: setprecision` function
    that is invoked with a number that represents precision. When the digits to the
    right of the point are dropped, the result is rounded off. If the number is too
    big to be represented in the normal way, the precision specification is ignored,
    and the number is displayed in a more convenient way. You only need to set precision
    once and change it only when you need another precision. When you choose a data
    type to store a floating-point variable, you should notice some tricks. In C++,
    there are three data types that can represent floating-point values: float, double,
    and long double.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The float is usually 4 bytes, double is 8 bytes, and long double is 8, 12,
    or 16 bytes. So, the precision of each of those is limited. The float type can
    accommodate a maximum of 6-9 significant digits, the double type can accommodate
    a maximum of 15-18 significant digits, and the long double type can accommodate
    a maximum of 33-36 significant digits. Take a look at the following table if you
    wish to compare the difference between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Comparison table of the floating-point types](img/C14583_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Comparison table of the floating-point types'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you need precision for more than six significant digits, favor double,
    otherwise you will get unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Let's complete an exercise and learn how to use them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Displaying Entered Floating-Point Numbers with Different Formatting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will write an application that, in the infinite loop,
    asks the user to enter a floating-point number. After reading the input, it displays
    this number with different formatting types. To perform this exercise, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `<iostream>` header for streaming support and `<iomanip>` for `std::setprecision`
    support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare a template `formattingPrint` function that has a template parameter
    called `FloatingPoint` and takes a parameter variable of this type. Next, store
    the previous precision in an auto variable by calling the `precision()` function
    in the `std::cout` object. Then, display the given number in different formats
    in the Terminal: with the point, without a point, and in the fixed, scientific,
    hexfloat, and defaultfloat formats. Next, in the for loop, from 0 to 22, display
    the given number with precision and the size of the loop counter. After the loop
    exits, set the precision back using the value we stored earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function. Declare a `float` variable called `floatNum`, a
    double variable called `doubleNum`, and a long double variable called `longDoubleNum`.
    Then, in the infinite while loop, ask the user to input a floating-point number,
    read the input to `longDoubleNum`, and pass it to the `formattingPrint` function.
    Next, initialize `doubleNum` by using the `longDoubleNum` value and pass it to
    the `formattingPrint` function. Next, initialize `floatNum` by using the `longDoubleNum`
    value and pass it to the `formattingPrint` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application. Follow the output and enter the floating-point
    value with `22` significant digits, for example, `0.2222222222222222222222`. We
    will get a long output. Now, we need to split it for analysis. Here is a screenshot
    of part of the long double value''s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12: The result of executing Exercise 5, part 1](img/C14583_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The result of executing Exercise 5, part 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can see that, with the default, the fixed and `defaultfloat` formations
    only output six significant digits. With scientific formatting, the output of
    the value looks as expected. When we call `setprecision(0)` or `setprecision(1)`,
    we expect that no one digit will be outputted after the point. But with numbers
    less than 1 setprecision, this will leave one digit after the point. By doing
    this, we will see the correct output until 21 precision. This means that on our
    system, the maximum precision for a long double is 20 significant digits. Now,
    let''s analyze the output for the double value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: The result of executing Exercise 5, part 2](img/C14583_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: The result of executing Exercise 5, part 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here, we can see the same results for formatting, but different for precision.
    The inaccurate output starts from precision 17\. This means that, on our system,
    the maximum precision for double is 16 significant digits. Now, let''s analyze
    the output for float value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: The result of executing Exercise 5, part 3](img/C14583_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The result of executing Exercise 5, part 3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see the same results for formatting, but different ones for precision.
    The inaccurate output starts from precision 8\. This means that, on our system,
    the maximum precision for the float is 8 significant digits. The results on different
    systems should be different. An analysis of them will help you choose the correct
    data type for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Never use the float data type for representing money or exchange rates; you
    may get the wrong result.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Manipulators for Boolean Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `<ios>` header, there are declared functions for changing boolean formatting:
    `std::boolalpha` and `std::noboolalpha`. They are invoked without arguments and
    allow us to display boolean values in textual or digital ways, respectively. They
    are used for both input and output operations. Let''s consider an example of using
    these I/O manipulators for output operations. We will display the Boolean both
    as text and as a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and running this example, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the default formatting of bool variables is performed with
    the `std::noboolalpha` flag. To use these functions in input operations, we need
    to have a source string that contains true/false words or 0/1 symbols. The `std::boolalpha`
    and `std::noboolalpha` function calls in the input operation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you then output these variables, you will see that they were initialized
    correctly by reading boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: I/O Manipulators for Field Width and Fill Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Standard Library, there are also functions for manipulating by the width
    of the outputted field, which characters should be used in the case when the width
    is more than the output data, and in which place these filling characters should
    be inserted. These functions will be useful when you want to align your output
    to the left or right position or when you want to replace spaces with some other
    symbols. For example, let''s say you need to print prices in two columns. If you
    use standard formatting, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn''t look very good and it''s hard to read. If we apply the formatting,
    the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks better. Again, you may want to check which characters are being
    used to fill in empty spaces and which are actually spaces that you inserted between
    digits. Let''s set the filling character to "*", for example. You will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see that the blank space is filled with stars. Now that we''ve
    considered where it can be useful to format width and fill with output, let''s
    consider how we can do that with I/O manipulators. The `std::setw` and `std::setfill`
    functions are declared in the `<iomanip>` header. `std::setw` takes an integer
    value as a parameter and sets the width of the stream to exact n characters. There
    are a few cases where the width will be set to 0\. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the shift operator is called with `std::string` or `char`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `std::put_money()` function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `std::quoted()` function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `<ios>` header, there are declared functions for changing the place
    where filling characters should be inserted: `std::internal`, `std::left`, and
    `std::right`. They are only used for output operations and only affect integer,
    floating-point, and monetary values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider an example of using all of them together. Let''s output
    positive, negative, floating-point, and hexadecimal values with a width of 10
    and replace the filling character with "`#`":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After building and running this example, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: I/O Manipulators for Other Numeric Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to output a positive numeric value with a "+" sign, you can use
    another I/O manipulator from the `<ios>` header – the `std::showpos` function.
    The opposite of meaning manipulator also exists – the `std::noshowpos` function.
    They both have an effect on the output. Their use is very easy. Let''s consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we made the output with default formatting, then with the `std::showpos`
    flag, and finally with the `std::noshowpos` flag. If you build and run this small
    example, you will see that, by default, the `std::noshowpos` flag is set. Look
    at the result of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also want to output uppercase characters for floating-point or hexadecimal
    digits so that you can use functions from the `<ios>` header: `std::uppercase`
    and `std::nouppercase`. They only work on the output. Let''s consider a small
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we output floating-point and hexadecimal digits with and without the
    `std::uppercase` flag. By default, the `std::nouppercase` flag is set. Look at
    the result of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: I/O Manipulators for Whitespace Processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Standard Library, there are functions for processing whitespaces. The
    `std::ws` function from the `<istream>` header only works with input streams and
    discards leading whitespaces. The `std::skipws` and `std::noskipws` functions
    from the `<ios>` header are used to control reading and writing leading whitespaces.
    They work for both input and output streams. When the `std::skipws` flag is set,
    the stream ignores whitespaces in front of the input of the character sequence.
    By default, the `std::skipws` flag is set. Let''s consider an example of using
    these I/O manipulators. First, we will read the input with default formatting
    and output what we have read. Next, we will clear our strings and read data with
    the `std::noskipws` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After building and running this example, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, if we set the `std::noskipws` flag,
    we will read whitespaces as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `<iomanip>` header, an unusual manipulator for this header has been
    declared: `std::quoted`. When this function is applied to the input, it wraps
    a given string in quotes with escaping characters. If the input string already
    contains escaped quotes, it reads them as well. In order to understand this, let''s
    consider a small example. We will initialize a source string with some text without
    quotes and another string will initialize with text with escaped quotes. Next,
    we will read them by using `std::ostringstream` without a flag is set and provide
    the output via `std::cout`. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do the same output but with `std::quoted` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will have a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that the first string is wrapped by quotes and that the substring
    "right here" from the second string is stored with escape characters?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you know how to wrap any string in the quotes. You can even write your
    own wrapper to decrease the number of lines when you use `std::quoted()`. For
    example, we moved the work with the stream to a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we do the following when we need we call our wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now, it looks much better. The first topic has come to an end, so let's revise
    what we have just learned. In practice, we learned about the usage of predefined
    stream objects, I/O operations with files with inner memory, I/O formatting, and
    the I/O of user-defined types. Now that we have a complete understanding of how
    to work with the I/O library in C++, we will consider what to do when the standard
    stream is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: Making Additional Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the provided interface of streams is not enough for resolving your task,
    you may want to create an additional stream that will reuse one of the existing
    interfaces. You may need to output or provide input from a specific external device,
    or you may need to add the Id of the thread that invoked the I/O operation. There
    are a few ways to do that. You may create a new class that will aggregate one
    of the existing streams as a private member. It will implement all the needed
    functions, such as shift operators, through already existing stream functions.
    Another way to do this is to inherit one of the existing classes and override
    all the virtual functions in a way you need them.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you have to choose the appropriate class to be used. Your choice
    should depend on which modification you want to add. Choose `std::basic_istream`,
    `std::basic_ostream`, and `std::basic_iostream` if you need to modify input or
    output operations. Choose `std::ios_base` if you want to modify the state information,
    control information, private storage, and so on. Choose `std::basic_ios` if you
    want to modify something related to the stream buffer. After you choose the correct
    base class, inherit one of the aforementioned classes to create an additional
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: There's one more thing you have to know – how to initialize correctly standard
    streams. In terms of the initialization of a file or string stream and basic stream
    classes, there are some big differences. Let's review them. To initialize the
    object of class that is derived from the file stream class, you need to pass the
    file name. To initialize the object of the class that is derived from the string
    stream class, you need to call the default constructor. Both of them have their
    own stream buffers, so they don't need additional manipulation on initialization.
    To initialize the object of the class that is derived from the basic stream class,
    you need to pass a pointer to a stream buffer. You can create a variable of the
    buffer or you may use the buffer of the predefined stream objects, such as `std::cout`
    or `std::cerr`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review these two methods of creating additional streams in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to Make an Additional Stream – Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composition means that you declare some of the standard stream objects in the
    private section of your class as a class member. When you choose an appropriate
    standard stream class, go to its header and notice which constructor it has. Then,
    you need to correctly initialize this member in the constructor of your class.
    To use your class as a stream object, you need to implement basic functions such
    as the shift operator, `str()`, and so on. As you may remember, every stream class
    has overloaded shift operators for built-in types. They also have overloaded shift
    operators for predefined functions such as `std::endl`. You need to be able to
    use your class as a real stream object. Instead of declaring all 18 overloaded
    shift operators, we just need to create one template. Also, to allow for the use
    of predefined manipulators, we must declare a shift operator that takes a pointer
    to a function.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't look very hard, so let's try to implement such a "wrapper" for
    the `std::ostream` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Composing the Standard Stream Object in the User-Defined Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create own stream object that wraps the `std::ostream`
    object and adds additional features. We will create a class called `extendedOstream`
    that will output data to the Terminal and insert the following data in front of
    each piece of output: date and time and thread ID. To complete this exercise,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers: `<iostream>` for `std::endl` support, `<sstream>`
    for `std::ostream` support, `<thread>` for `std::this_thread::get_id()` support,
    `<chrono>` for `std::chrono::system_clock::now()`, and `<ctime>` for converting
    timestamps into readable representations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the `extendedOstream` class. Declare the `std::ostream` variable
    called `m_oss` and the bool variable called `writeAdditionalInfo`. This bool variable
    will be used to indicate whether extended data should be printed or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the public section, define a default constructor and initialize `m_oss`
    with `std::cout` to redirect output to the Terminal. Initialize `writeAdditionalInfo`
    with `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a template overloaded left shift operator, `<<`, that returns a reference
    to `extendedOstream` and takes a template parameter called value. Then, if `writeAdditionalInfo`
    is `true`, output the time, thread ID, and the given value, and then set `writeAdditionalInfo`
    to `false`. If `writeAdditionalInfo` is `false`, output only the given value.
    This function will be used for the output of all built-in types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another overloaded left shift operator that takes a pointer to the function
    as a parameter and returns the reference to `std::ostream`. In the function body,
    set `writeAdditionalInfo` to `true`, call the given function, and pass `m_oss`
    as an argument. This overloaded operator will be used for predefined functions
    such as `std::endl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the private section, define the `fTime` function, which returns std::string.
    It gets a system time. Format it into a readable representation and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In the private section, define the `threadId()` function, which returns a string.
    Get the `id` of the current thread, format it, and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function. To test how our stream object works, create an object
    of the `extendedOstream` type called `oss`. Output different data, for example,
    integer, float, hexadecimal, and bool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a thread, initialize it with a lambda function, and put the same
    output inside the lambda. Don''t forget to join the thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build and run the application. You will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: The result of executing Exercise 6'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Consider each line of the output. You can see the next format of the output:
    "[date and time][thread ID]output data". Ensure that the thread ID differs from
    thread to thread. Then, the data was output in the expected format. So, as you
    can see, it''s not too hard to implement your own I/O stream object using the
    composition of the standard stream.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Make an Additional Stream – Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance means that you create your own stream class and inherit it from
    one of the standard stream objects that has a virtual destructor. Your class must
    be a template class and have template parameters, just like in the parent class.
    To use all your inherited functions with the object of your class, the inheritance
    should be public. In the constructor, you should initialize the parent class,
    depending on the class type – with the file name, with the stream buffer, or by
    default. Next, you should override those basic functions that you would change
    according to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The most common case where we need to inherit standard stream classes is when
    we want to implement I/O operations for a new device, such as a socket or printer.
    All of the defined standard stream classes are responsible for formatting input
    and output and have overloads for strings, files, and the Terminal. Only the `std::basic_streambuf`
    class is responsible for work with devices, so we need to inherit this class,
    write our own implementation, and set it as a stream buffer for standard classes.
    The core functionality of `streambuf` classes is to transport characters. It can
    use buffers to store characters between flushing or can flush immediately after
    each call. These concepts are called buffered and unbuffered characters transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'The buffered characters transport for output operations works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Characters are buffered into the internal buffer by the `sputc()` function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the buffer is full, `sputc()` invokes the protected virtual member, that
    is, `overflow()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `overflow()` function transfers all buffer content to the external device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `pubsync()` function is called, it calls the protected virtual member
    known as `sync()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sync()` function transfers all buffer content to the external device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The unbuffered characters transport for output operations works slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: Characters are passed to the `sputc()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sputc()` function immediately calls the protected virtual member known
    as `overflow()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `overflow()` function transfers all buffer content to the external device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, for buffered and unbuffered characters transport for output operations,
    we should override the `overflow()` and sync() functions, which do the actual
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The buffered characters transport for input operations works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sgetc()` function reads the character from the internal buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sgetc()` function invokes the `sungetc()` function, which makes the consumed
    character available again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the internal buffer is empty, the `sgetc()` function invokes the `underflow()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `underflow()` function reads characters from the external device to the
    internal buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `sgetc()` and `underflow()` functions always return the same character.
    To read different characters each time, we have another pair of functions: `sbumpc()`
    and `uflow()`. The algorithm of reading characters with them is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sbumpc()` function reads the character from the internal buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sbumpc()` function invokes the `sputbackc()` function, which makes the
    next character available for input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the internal buffer is empty, the `sbumpc()` function invokes the `uflow()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `uflow()` function reads characters from the external device to the internal
    buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The unbuffered characters transport for input operations works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sgetc()` function invokes a protected virtual member known as `underflow()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `underflow()` function reads characters from the external device to the
    internal buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sbumpc()` function invokes a protected virtual member known as `uflow()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `uflow()` function reads characters from the external device to the internal
    buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of any errors, the protected virtual member known as `pbackfail()`
    is invoked, which handles error situations. So, as you can see, to override the
    `std::basic_streambuf` class, we need to override the virtual members that work
    with external devices. For the input `streambuf`, we should override the `underflow()`,
    `uflow()`, and `pbackfail()` members. For the output `streambuf`, we should override
    the `overflow()` and `sync()` members.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider all of these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Inheriting the Standard Stream Object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a class called `extended_streambuf` that inherits
    from `std::basic_streambuf`. We will use a buffer of the `std::cout` stream object
    and override the overflow() function so that we can write data to an external
    device (`stdout`). Next, we will write an `extended_ostream` class that inherits
    from the `std::basic_ostream` class and set a stream buffer to `extended_streambuf`.
    Finally, we will make minor changes to our wrapper class and use `extended_ostream`
    as a private stream member. To complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required headers: `<iostream>` for `std::endl` support, `<sstream>`
    for `std::ostream` and `std::basic_streambuf` support, `<thread>` for `std::this_thread::get_id()`
    support, `<chrono>` for `std::chrono::system_clock::now()`, and `<ctime>` for
    converting timestamps into a readable state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a template class called `extended_streambuf` that inherits from the
    `std::basic_streambuf` class. Override a public member called `overflow()` that
    writes a character to the output stream and returns the EOF or the written character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a template class called `extended_ostream` that is derived from
    the `std::basic_ostream` class. In the private section, define a member of the
    `extended_streambuf` class, namely buffer. Initialize the `std::basic_ostream`
    parent class with a buffer member. Next, in the constructor body, invoke the `init()`
    function from the parent class with buffer as an argument. Also, overload the
    `rdbuf()` function, which returns a pointer to the buffer variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Rename an `extendedOstream` class to the logger to avoid misunderstandings
    with similar names. Leave the existing interface as is but replace the `std::ostream&`
    member with our own stream, that is, `object - extended_ostream`. The complete
    class looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function and change the `extendedOstream` object to the `logger`
    object. Leave the rest of the code as is. Now, build and run the exercise. You
    will see the output that was given in the previous exercise but in this case,
    we used our own stream buffer, our own stream object, and a wrapper class that
    adds additional information to the output. Look at the result of the execution
    that''s shown in the following screenshot and compare it with the previous result.
    Make sure they are similar. If they are, that means we did a good job and our
    inherited classes work as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16: The result of executing Exercise 7](img/C14583_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: The result of executing Exercise 7'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this topic, we have done a lot and learned how to create additional streams
    in different ways. We considered all the appropriate classes for inheritance and
    which class is better to use for different needs. We also learned how to inherit
    from basic streambuf classes to implement work with external devices. Now, we
    will learn how to use I/O streams in an asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Asynchronous I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a lot of cases where I/O operations can take a lot of time, for example,
    creating a backup file, searching a huge database, reading large files, and so
    on. You can use threads to execute I/O operations without blocking the application's
    execution. But for some applications, it's not a suitable way to handle long I/O,
    for example, when there can are thousands of I/O operations per second. In those
    cases, C++ developers use asynchronous I/O. It saves thread resources and ensure
    that the thread of the execution cannot be blocked. Let's consider what synchronous
    and asynchronous I/O is.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from Chapter 5, The Philosophers' Dinner – Threads and Concurrency,
    synchronous operation means that some thread invokes the operation and waits for
    it to complete. It may be a single-threaded or multi-threaded application. The
    main point is that the thread is waiting for the I/O operation to complete.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous execution takes place when an operation does not block the
    execution of the working thread. The thread that performs the asynchronous I/O
    operation sends an asynchronous request and continues with another task. When
    the operation has finished, the initial thread will be notified about the finish
    and it can handle the results as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: From this, it looks like asynchronous I/O is much better than synchronous, but
    it depends on the situation. If you need to perform lots of fast I/O operations,
    it would be more suitable to follow the synchronous way due to the overhead of
    processing kernel I/O requests and signals. Thus, you need to consider all possible
    scenarios while developing an architecture for your application.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library doesn't support asynchronous I/O operations. So, to leverage
    asynchronous I/O, we need to consider alternative libraries or write our own implementations.
    First, let's consider platform-dependent implementations. Then, we will look at
    cross-platform libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous I/O on Windows Platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Windows supports I/O operations for a variety of devices: files, directories,
    drives, ports, pipes, sockets, terminals, and so on. In general, we use the same
    interface for I/O for all of these devices, but some settings differ from device
    to device. Let''s consider an I/O operation on a file in Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in Windows, we need to open a device and get a Handler for it. Different
    devices open in different ways. To open a file, directory, drive, or port, we
    use the `CreateFile` function from the `<Windows.h>` header. To open a pipe, we
    use the `CreateNamedPipe` function. To open a socket, we use the socket() and
    accept() functions. To open a terminal, we use the `CreateConsoleScreenBuffer`
    and `GetStdHandle` functions. All of them return a device handler that is used
    in all the functions for work with that device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateFile` function takes seven parameters that manage the work with
    the opened device. The function declaration looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is `pszName` – the path to the file. The second parameter
    calls `dwDesiredAccess` and manages access to the device. It can take one of the
    following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The third parameter, `dwShareMode`, manages how the OS should handle all the
    new `CreateFile` invocations when the file is already open. It can take one of
    the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth parameter, `psa`, is usually set to `NULL`. The fifth parameter,
    `dwCreationDisposition`, manages whether the file be opened or created. It can
    take one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The sixth parameter, `dwFlagsAndAttributes`, manages the cache or work with
    the file. It can take one of the following values for managing caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take one of the following values for managing work with files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'It can take one of the following values for file attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The last parameter, `hFileTemplate`, takes a handler to the open file or `NULL`
    as parameters. If the file handler is passed, the `CreateFile` function ignores
    all the attributes and flags and the use the attributes and flags of the open
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all regarding `CreateFile` parameters. If it cannot open a device,
    it returns `INVALID_HANDLE_VALUE`. The following example demonstrates how to open
    a file for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to perform an input operation, we use the `ReadFile` function. It takes
    the file descriptor as the first parameter, the source buffer as the second parameter,
    the maximum number of bytes to read as the third parameter, the number of reading
    bytes as the fourth parameter, and the `NULL` value for synchronous execution
    or the pointer to a valid and unique OVERLAPPED structure as the last parameter.
    If the operation succeeds, the `ReadFile` returns true, or false otherwise. The
    following example demonstrates how to input from the previously opened file for
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform the output operation, we use the `WriteFile` function. It has the
    same declaration as `ReadFile`, but the third parameter sets the number of bytes
    to write and the fifth parameter is a number of written bytes. The following example
    demonstrates how to output to a previously opened file for writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To write cached data to a device, use the `FlushFileBuffer` function. It takes
    a single parameter – the file descriptor. Let''s move to the asynchronous I/O.
    To let the OS know that you plan to work with the device asynchronously, you need
    to open it with the `FILE_FLAG_OVERLAPPED` flag. Now, opening the file for writing
    or reading looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the same operations to perform reading or writing to files, that is,
    `ReadFile` and `WriteFile`, with the only difference that the number of reads
    or wrote bytes are set to NULL and we must pass a valid and unique `OVERLAPPED`
    object. Let''s consider what the structure of the OVERLAPPED object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The Internal member is set to `STATUS_PENDING`, which means that the operation
    hasn't started yet. The number of read or wrote bytes will be written into the
    `InternalHigh` member. `Offset` and `OffsetHigh` are ignored in asynchronous operations.
    The `hEvent` member is used for receiving events about the completion of the asynchronous
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The order of the I/O operations is not guaranteed, so you cannot rely on this.
    If you plan to write to a file at one place, and read from a file at another place,
    you cannot rely on the order.
  prefs: []
  type: TYPE_NORMAL
- en: There is one unusual thing in working with `ReadFile` and `WriteFile` in asynchronous
    mode. They return a non-zero value if the I/O request was performed synchronously.
    If they return `FALSE`, you need to invoke the `GetLastError` function to check
    why `FALSE` was returned. If the error code is `ERROR_IO_PENDING`, this means
    that the I/O request was successfully handled, is in a pending state, and will
    be performed later.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that you should remember is that you can't move or remove the
    `OVERLAPPED` object or buffer with data until the I/O operation finishes. For
    each I/O operation, you should create a new OVERLAPPED object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s consider the ways in which the system notifies us about completing
    the I/O operation. There are a few such mechanisms: releasing the device, releasing
    the event, producing an alert, and using I/O ports.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteFile` and `ReadFile` functions set a device to the "occupied" state.
    When the I/O operation is finished, the driver sets a device to the "free" state.
    We can check if the finished I/O operation is invoking the `WaitForSingleObject`
    or `WaitForMultipleObject` functions. The following example demonstrates this
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This is the easiest way to check if the I/O operation has finished. But this
    approach makes the calling thread wait on the `WaitForSingleObject` call, so it
    becomes a synchronous call. Moreover, you can initiate a few I/O operations for
    this device, but you cannot be sure that the thread will wake up on the needed
    release of the device.
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateEvent` function and set it to the `OVERLAPPED` object. Then, when the
    I/O operation has finished, the system releases this event by calling the `SetEvent`
    function. Next, when the calling thread needs to get the result of an executing
    I/O operation, you invoke `WaitForSingleObject` and pass the descriptors for this
    event. The following example demonstrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It's a pretty easy approach if you wish to notify the calling thread about the
    end of the I/O operation. But this is not the ideal way to do this because when
    there are a lot of these operations, you need to create an event object for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadFileEx` and `WriteFileEx` to the input/output. They are similar to the
    standard `ReadFile` and `WriteFile`, but we don''t pass the variable that stores
    the number of read or wrote characters and we pass an address of the callback
    function. This callback function is called a completion routine and has the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '`ReadFileEx` and `WriteFileEx` pass the address of the callback function to
    the device driver. When the operation has finished on the device, the driver adds
    the address of the callback function to the APC queue and the pointer to the OVERLAPPED
    structure. Then, the OS invokes this function and passes the number of read or
    wrote bytes, error code, and pointer to the OVERLAPPED structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The main cons of this approach are writing callback functions and using a lot
    of global variables because callback functions have a small amount of information
    in the context. Another reason not to use this approach is that only the calling
    thread can receive the notification regarding completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve gone over the bad, let''s look at the best approach for handling
    I/O results – I/O ports. The I/O completion ports are developed to be used with
    thread pools. To create such a port, we use `CreateIoCompletionPort`. The declaration
    of this function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This function creates an I/O completion port and associates the device with
    this port. To complete this action, we need to call it twice. To create the new
    completion port, we invoke the `CreateIoCompletionPort` function and pass `INVALID_HANDLE_VALUE`
    as the first parameter, NULL as a second parameter, 0 as a third parameter, and
    pass the number of the threads for this port. Passing 0 as the fourth parameter
    will set the number of threads equal to the number of processors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the I/O completion port, it is recommended to use the number of threads
    that is equal to the number of processors, multiplied twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to associate this port with the input/output device. So, we invoke
    the `CreateIoCompletionPort` function for the second time and pass a descriptor
    of the device, a descriptor of the created completion port, the constant that
    will indicate reading or writing to the device, and 0 as the number of threads.
    Then, when we need to get the result of completion, we call `GetQueuedCompletionStatus`
    from our port descriptor. If the operation completes, the function returns a result
    immediately. If it doesn''t, then the thread waits to complete. The following
    example demonstrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous I/O on Linux Platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The asynchronous I/O on Linux supports input and output to different devices
    such as sockets, pipes, and TTYs, except files. Yes, this is pretty strange, but
    Linux developers decided that I/O operations with files are fast enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open an I/O device, we use the open() function. It has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is a filename, while the second parameter is a bitmask that
    controls how the file should be opened. If the system cannot open the device,
    open() returns a value of -1\. In the case of success, it returns a device descriptor.
    The possible flags for open mode are `O_RDONLY`, `O_WRONLY`, and `O_RDWR`.
  prefs: []
  type: TYPE_NORMAL
- en: To perform input/output operations, we use the `POSIX` interface called `aio`.
    They have a defined set of functions such as `aio_read`, `aio_write`, `aio_fsync`,
    and so on. They are used to initiate the asynchronous operations. To get the result
    of execution, we can use signal notification or the instantiation of a thread.
    Alternatively, we can choose not to be notified at all. All of them are declared
    in the `<aio.h>` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all of these take the `aiocb` structure (asynchronous IO control block)
    as a parameter. It controls the IO operations. The declaration of this structure
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `aio_fildes` member is a descriptor to the opened device, while the `aio_offset`
    member is an offset in the device where read or write operations should be done.
    The `aio_buf` member is a pointer to the buffer to read or write from. The `aio_nbytes`
    member is the size of the buffer. The `aio_reqprio` member is the priority of
    the execution of this IO operation. The `aio_sigevent` member is a structure that
    points out how the calling thread should be notified about the finish. The `aio_lio_opcode`
    member is a type of I/O operation. The following example demonstrates how to initialize
    the `aiocb` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a buffer for reading file content, namely `fileContent`. Then,
    we created an `aiocb` structure called `aiocbObj`. Next, we opened a file for
    reading and checked if this operation was successful. Then, we set the pointer
    to a buffer and a buffer size. The buffer size tells the driver how many bytes
    should be read or wrote. Next, we pointed out that we will read from the beginning
    of the file by setting the offset to 0\. Then, we set the notification type in
    `SIGEV_SIGNAL`, which means we would like to get a signal notification about the
    finish operation. Then, we set the signal number, which should trigger the notification
    about the finish. In our case, it's `SIGUSR1` – the user-defined signal. Next,
    we set the pointer to the `aiocb` structure to the signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: After the creation and correct initialization of an `aiocb` structure, we can
    perform input or output operations. Let's complete an exercise to understand how
    to use async I/O on Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Asynchronously Reading from a File in Linux'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will develop an application that reads data from a file
    in an asynchronous way and outputs the read data to the console. When the read
    operation is performed, the driver notifies the application using the triggering
    signal. To do this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include all the required headers: `<aio.h>` for asynchronous reading and writing
    support, `<signal.h>` for signal support, `<fcntl.h>` for operations with files,
    `<unistd.h>` for symbolic constants support, `<iostream>` for output to the Terminal,
    `<chrono>` for time options, and `<thread>` for threading support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a bool variable called `isDone` that will indicate when the operation
    has been completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the function that will be our signal handler, that is, `aioSigHandler`.
    It will be called when the async operation is done. Signal handlers should have
    the following signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is a signal number, the second parameter is a structure
    that contains information about why the signal was generated, and the last parameter
    is additional information. It can be cast to a pointer of the `ucontext_t` structure
    so that we can receive the thread context that was interrupted by this signal.
    In `aioSigHandler`, check whether the signal regarding the async I/O operation
    is constant using `SI_ASYNCIO`. If so, output a message. Next, set `isDone` to
    `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another helping function called `initSigAct`. It will initialize the
    `sigaction` structure. This structure defines which signal will be sent on the
    I/O operation''s finish and which handler should be called. Here, we chose `SIGUSR1`
    – a user-defined signal. In `sa_flags`, set that we want this signal to be delivered
    on action restart or information received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the helping function called `fillAiocb`, which fills in the `aiocb`
    structure with the given parameters. It will take the reference to the aiocb structure,
    the file descriptor, the pointer to a buffer, and the buffer''s size as parameters.
    Set `sigev_signo` in `SIGUSR1`, which we initialized previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `main` function. Define the variable called `buf_size`, which holds
    the buffer size. Create a buffer of that size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable called `fileName` that holds a file called "`Test.txt`".
    Then, open this file with read-only access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `sigaction` structure and initialize it using the `initSigAct` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `aiocb` structure and initialize it using the `fillAiocb` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a `read` operation using the `aio_read` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the loop, evaluate the `isDone` variable. If it is false, make the
    thread sleep for `3ms`. By doing this, we will wait for the I/O operation to finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running this exercise, create a `Test.txt` file in the project directory
    and write different symbols. For example, our file contains the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here, there's alphabetical characters, numerical characters, special symbols,
    spaces, tabulation characters, and newline characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build and run this exercise in your IDE. Your output will be similar to
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: The result of executing Exercise 8'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see that the file was successfully opened for reading and that we successfully
    set the `SIGUSR1` signal and handler for it. Then, we received signal number 30,
    that is, the `SI_ASYNCIO` signal. Finally, we can output what we have read and
    compare it with the file content. By doing this, we can ensure that all the data
    was read correctly.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for async I/O in Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can find more information about asynchronous IO in Linux by going to Linux''s
    man pages: http://man7.org/linux/man-pages/man7/aio.7.html.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn about what we can use for cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Cross-Platform I/O Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already considered the platform-specific decision for asynchronous I/O.
    Now, to write a cross-platform application, you can use these platform-specific
    approaches and use them with preprocessor directives; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the headers, you can declare the same interface for platform-specific
    implementations. You can also implement your own AIO library, which will use some
    state machines or queue in the separate thread. Also, you can use some of the
    free libraries that implement the necessary features. The most popular library
    is `Boost.Asio`. It provides a lot of interfaces for asynchronous work, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency without threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP, UDP, and ICMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s briefly consider its interface for I/O operations. We can use the interface
    of the `Asio` library for synchronous and asynchronous operations. All of the
    I/O operations start from the `io_service` class, which provides core I/O functionality.
    It is declared in the `<boost/asio/io_service.hpp>` header file. The synchronous
    I/O invokes the `run()` function of the `io_service` object for a single operation
    that blocks the calling thread until the job is done. The asynchronous I/O uses
    the `run()`, `run_one()`, `poll()`, and `poll_one()` functions. The `run()` function
    runs the event loop to process request handlers. The `run_one()` function does
    the same, but the event loop should process only one handler. The `poll()` function
    runs the event loop to execute all the ready handlers. `poll_one()` does the same
    but only for one handler. The following example demonstrates the usage of all
    these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to run the event handler before the actual I/O operations are
    called. Use the working class with the `io_service` class to implement this feature
    in your code. The work class guarantees that the run function will not return
    until you''ve decided that there will not be any future I/O operations. For example,
    you can make the working class a member of another class and remove it from the
    destructor. So, during the lifetime of your class, `io_service` will be running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to perform any I/O operations, we need the exact the I/O device, for
    example, file, socket, and so on. There are many classes that implement work with
    different I/O devices, for example, `boost::asio::ip::tcp::socket` from the `<boost/asio/ip/tcp.hpp>`
    header. Next, to read and write to the socket, we make use of `boost::asio::async_read`
    and `boost::asio::async_write`. They take a socket, `boost::asio::buffer`, and
    the callback function as parameters. When the async operation is performed, the
    callback function is invoked. We can pass a lambda function as a callback function
    or bind an existing function using the boost::bind function. `boost::bind` creates
    a callable object. The following example demonstrates how to write to a socket
    using `Boost::Asio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used lambda functions as callbacks for async I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Boost.Asio` is well-documented at https://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html.
    There are lots of examples with different IO devices and different approaches.
    You can refer to this documentation if you decide to use `Boost.Asio` in your
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've considered different ways we can implement asynchronous I/O operations.
    Depending on your requirements, environment, and allowed utilities, you can choose
    the appropriate way to implement asynchronous I/O in your applications. Remember
    that if you choose to perform many fast I/O operations, it's better to do them
    in a synchronous way as it doesn't take up a lot of system resources. Now that
    we know how to leverage asynchronous I/O, let's learn how to use I/O in multithreaded
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction of Threads and I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The I/O Standard Library is not thread-safe. In the documentation of the Standard
    Library, we can find an explanation that states that the concurrent access to
    the stream or stream buffer can lead to a data race and, as a result, an undefined
    behavior. To avoid this, we should synchronize access to the streams and buffers
    using the techniques that we learned about in *Chapter 5*, *The Philosophers'
    Dinner – Threads and Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk a little bit about the `std::cin` and `std::cout` objects. Each
    call to them is thread-safe, but let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we see that `std::cout` is called once, but each call to the
    shift operator is actually a different call to the `std::cout` object. So, we
    can rewrite this line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does exactly the same as the previous single line, that is, if you
    call this single line from the different threads, your output will be mixed and
    unclear. You can modify it to make it really thread-safe like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: So, if you output to the Terminal using the second method, your output will
    be clear and thread-safe. This behavior can vary, depending on the compiler or
    std library version. You also have to know that `std::cout` and `std::cin` are
    synchronized among them. This means that invoking `std::cout` always flushes the
    `std::cin` stream and the invocation of `std::cin` always flushes the `std::cout`
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach is to wrap all I/O operations in a guard class that will control
    access to the stream using mutexes. If you need to output to the Terminal from
    multiple threads using `std::cout`, you can implement a very simple class that
    does nothing but lock the mutex and invoke `std::cout`. Let's complete an exercise
    and create such class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Developing a Thread-Safe Wrapper for std::cout'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will develop a simple `std::cout` wrapper that produces
    a thread-safe output. We will write a small test function to check how it works.
    Let''s start and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include all the required headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's think about our wrapper. We can create a variable of this class somewhere
    and pass it to each created thread. However, this is a bad decision because in
    complex applications, this will take a lot of effort. We can also do this as a
    singleton so that we have access to it from everywhere. Next, we have to think
    about the content of our class. Actually, we can use the classes that we created
    in *Exercise 7*, *Inheriting the Standard Stream Object*. In that exercise, we
    overloaded `std::basic_streambuf` and `std::basic_ostream` and set `std::cout`
    as the output device. We can add a mutex to the overloaded function and use it
    as is. Note that we don't need any additional logic – just the output data using
    `std::cout`. To do this, we can create a simpler class. If we did not set the
    output device, applying the left shift operator will not take effect and will
    store the data to be outputted in the internal buffer. Great! Now, we need to
    think about how to get this buffer to output using `std::cout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a function such as `write()` that will lock a mutex and output to
    `std::cout` from the internal buffer. The usage of this function will look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one function that will always be called automatically, and we can put
    the code of the write function into it. It''s a destructor. In this case, we combine
    the creation and destruction into a single line. The usage of such an object will
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our `mtcout` (multithreaded cout) class. It has a public
    default constructor. In the private section, it has a static mutex variable. As
    you may recall, the static variable is shared among all the instances of the class.
    In the destructor, we lock the mutex and output using cout. Add a prefix to the
    output – the ID of the current thread and a space character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the `mutex` variable outside the class. We are doing this because
    we must declare a static variable in any source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the main function. Create a lambda called `func`. It will test our `mtcout`
    class. It takes string as a parameter and outputs this string in the loop from
    `0` to `1000` using `mtcout`. Add the same output using `std::cout` and comment
    it out. Compare the output in both cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Create four threads and pass a lambda function as a parameter. Pass different
    strings to each thread. Finally, join all four threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the exercise for the first time. You will get the following output:![Figure
    6.18: The result of executing Exercise 9, part 1](img/C14583_06_18.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.18: The result of executing Exercise 9, part 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see that each of threads outputs its own message. This message
    has not been interrupted and the output looks clear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, uncomment the output with `std::cout` in the lambda and comment out the
    output using `mtcout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, build and run the application. Now, you will get a "dirty", mixed output,
    like the following:![Figure 6.19: The result of executing Exercise 9, part 2](img/C14583_06_19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.19: The result of executing Exercise 9, part 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can see this mixed output because we don''t output a single string; instead,
    we invoke `std::cout` four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Sure, we can format the string before outputting it, but it is more convenient
    to use the mtcout class and not have to worry about formatting. You can create
    similar wrappers for any stream so that you can perform I/O operations safely.
    You can change the output and add any additional information, such as the ID of
    the current thread, time, or whatever you need. Employ the things we learned about
    in *Chapter 5*, *The Philosophers' Dinner – Threads and Concurrency*, to synchronize
    the I/O operations, extend streams and make the output more useful for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the activity for this chapter, we will use macro definitions to simplify
    and beautify our code, so let''s do a refresher on how to use them. Macro definitions
    are preprocessor directives. The syntax of the macro definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Here, [name] is any meaningful name and[expression] is any small function or
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preprocessor faces the macro name, it replaces it with the expression.
    For example, let''s say you have the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you use it in a few places in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preprocessor finishes its work, the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The preprocessor does the same work for functions. For example, let''s say
    you have a macro for getting the maximum number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you use it in a few places in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preprocessor finishes its work, the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'As an expression, you can use any valid expression, such as a function call,
    inline function, value, and so on. If you need to write the expression in more
    than one line, use the back-slash operator, "\". For example, the max definition
    we can write in two lines is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The macro definitions came from the C language. It's better to use const variables
    or inline functions instead. However, there are still cases when it's more convenient
    to use macro definitions, for example, in loggers when you wish to define different
    logging levels.
  prefs: []
  type: TYPE_NORMAL
- en: Now. we know everything we need to complete the activity. So, let's sum up what
    we have learned in this chapter and let's improve the project that we wrote in
    *Chapter 5*, *The Philosophers' Dinner – Threads and Concurrency*. We'll be developing
    a thread-safe logger and integrating it into our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: The Logging System for The Art Gallery Simulator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we are going to develop a logger that will output formatted
    logs to the Terminal. We will output logs in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: We will implement macro definitions for different logging levels that will be
    used instead of straightforward calls. This logger will be thread-safe, and we
    will invoke it from different threads simultaneously. Finally, we will integrate
    it into the project – The Art Gallery Simulator. We will run the simulation and
    observe pretty-printed logs. We will create an additional stream, use streams
    with concurrency, and format the output. We will implement almost everything that
    we have learned about in this chapter. We will also employ a synchronization technique
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, before attempting this activity, ensure that you have completed all the
    previous exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement this application, let''s describe our classes. We have
    the following newly created classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: Descriptions of the classes that should be implemented](img/C14583_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: Descriptions of the classes that should be implemented'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We also have the following classes already implemented in The Art Gallery Simulator
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: The table of already implemented classes in The Art Gallery Simulator
    project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s add our new classes to the class diagram before we start the implementation.
    All of the described classes with relationships are composed in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: The class diagram](img/C14583_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: The class diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To receive the output in the desired format, the `LoggerUtils` class should
    have the following `static` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: Descriptions of the LoggerUtils member functions](img/C14583_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: Descriptions of the LoggerUtils member functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Define and implement the `LoggerUtils` class, which provides an interface for
    output formatting. It contains static variables that format given data into the
    required representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define and implement the `StreamLogger` class, which provides a thread-safe
    interface for output to the Terminal. It should format the output like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: In a separate header file, declare the macro definitions for different logging
    levels that return a temporary object of the `StreamLogger` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate the implemented logger into the classes from the Art Gallery simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace all invocations of `std::cout` with the appropriate macro definition
    calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After implementing the aforementioned steps, you should get some output on
    the Terminal regarding the logs from all the implemented classes. Take a look
    and ensure that the logs are outputted in the desired format. The expected output
    should as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24: The result of the application''s execution](img/C14583_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: The result of the application''s execution'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 696.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about I/O operations in C++. We considered the I/O
    Standard Library, which provides an interface for synchronous I/O operations.
    Also, we considered platform-dependent native tools for asynchronous I/O, and
    the `Boost.Asio` library for cross-platform asynchronous I/O operations. We also
    learned how to use I/O streams in multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at the basic features that the Standard Library provides
    for I/O operations. We learned about predefined stream objects such as `std::cin`
    and `std::cout`. In practice, we learned how to work with standard streams and
    override shift operators for easy read and write custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we practiced how to create additional streams. We inherited from the basic
    stream class, implemented our own stream buffer class, and practiced their usage
    in the exercises. We learned about the most appropriate stream classes for inheritance
    and considered their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we considered the approaches of asynchronous I/O operations on different
    operating systems. We briefly considered using the cross-platform I/O library
    known as `Boost.Asio`, which provides an interface for both synchronous and asynchronous
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about how to perform I/O operations in multithreaded applications.
    We put all of these new skills into practice by building a multithreaded logger.
    We created a logger abstraction and employed it in the Art Gallery simulator.
    As a result, we created an easy, clear, and robust logging system that allows
    us to easily debug the application using logs. In all, we employed everything
    we learned about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''re going to be taking a closer look at testing and
    debugging applications. We will start by learning about assertions and safety
    netting. Then, we will practice writing unit tests and mocks for interfaces. After,
    we will practice debugging applications in the IDE: we will use breakpoints, watchpoints,
    and data visualization. Finally, we will write an activity that will master our
    skills of testing code.'
  prefs: []
  type: TYPE_NORMAL
