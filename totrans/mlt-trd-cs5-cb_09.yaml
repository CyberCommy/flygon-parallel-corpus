- en: Chapter 9. Using Asynchronous I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will review asynchronous input/output operations in detail.
    You will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with files asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an asynchronous HTTP server and client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a database asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a WCF service asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we already discussed how important it is to use asynchronous
    input/output operations properly. Why does it matter so much? To have a solid
    understanding, let us consider two kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: If we run an application on the client, one of the most important things is
    to have a responsive user interface. This means that no matter what is happening
    with the application, all user interface elements, such as buttons and progress
    bars, keep running fast, and the user gets an immediate reaction from the application.
    This is not easy to achieve! If you try to open the notepad text editor in Windows
    and try to load a text document that is several megabytes in size, the application
    window will be frozen for a significant amount of time because the whole text
    is being loaded from the disk first, and only then the program starts to process
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: This is an extremely important issue, and in this situation, the only solution
    is to avoid blocking the UI thread at all costs. This in turn means that to prevent
    blocking the UI thread, every UI-related API must allow only asynchronous calls.
    This is the key reason behind redesigning the APIs in the Windows 8 operating
    system by replacing almost every method with asynchronous analogs. But does it
    affect the performance if our application uses multiple threads to achieve this
    goal? Of course it does! However, we could pay the price considering that we have
    only one user. It is good if the application could use all the power of the computer
    to be more effective as all this power is intended for the single user who runs
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at the second case then. If we run the application on the server,
    we have a completely different situation. We have scalability as a top priority,
    which means that a single user should consume as little resource as possible.
    If we start to create many threads for each user, we simply cannot scale well.
    It is a very complex problem to balance our application resources consumption
    in an efficient way. For example, in ASP.NET, which is a web application platform
    from Microsoft, we use a pool of worker threads to serve clients' requests. This
    pool has a limited amount of worker threads, and we have to minimize the time
    of usage for each worker thread to achieve scalability. This means that we have
    to return it to the pool as soon as possible so that it could serve another request.
    If we start an asynchronous operation that requires computation, we will have
    a very inefficient workflow. First we take a worker thread from the thread pool
    to serve a client request. Then we take another worker thread and start an asynchronous
    operation on it. Now we have two worker threads serving our request, and it is
    good if the first thread is doing something useful! Unfortunately, the common
    situation is that we simply wait for the asynchronous operation to complete, and
    we consume two worker threads instead of one. In this scenario, asynchrony is
    actually worse than synchronous execution! We do not need to load all the CPU
    cores as we are already serving many clients and thus, are using all the CPU computing
    power. We do not need to keep the first thread responsive as we have no user interface.
    Then why should we use asynchrony in server applications?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we should use asynchrony when there is an asynchronous input/output
    operation. Today, modern computers usually have a hard-disk drive that stores
    the files and a network card that sends and receives data over the network. Both
    of these devices have their own microcomputers that manage input/output operations
    on a very low level and signal the operating system about the results. This is
    again quite a complicated topic; but to keep the concept clear we could say that
    there is a way for the programmer to start an input/output operation and provide
    the operating system with a code to call back when the operation is completed.
    Between starting an I/O task and its completion, there is no CPU work involved;
    it is done in the corresponding disk and network-controller microcomputers. This
    way of executing an I/O task is called an I/O thread; they are implemented using
    the .NET thread pool and in turn use an infrastructure from the operating system
    called the I/O completion ports.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET, as soon as an asynchronous I/O operation is started from a worker
    thread, it can be returned immediately to the thread pool! While the operation
    is going on, this thread can serve other clients. Finally, when the operation
    signals completion, the ASP.NET infrastructure gets a free worker thread from
    the thread pool (which could be different from the one that started the operation),
    and it finishes the operation.
  prefs: []
  type: TYPE_NORMAL
- en: All right; we now understand how important I/O threads are for server applications.
    Unfortunately, it is very hard to see if any given API uses I/O threads under
    the hood. The only way besides studying the source code is simply to know which
    .NET Framework class library leverages the I/O threads. In this chapter, we will
    see how to use some of those APIs. We will learn how to work with files asynchronously,
    how to use network I/O to create an HTTP server and call Windows Communication
    Foundation service, and how to work with asynchronous API to query a database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important issue to consider is parallelism. For a number of reasons,
    intensive parallel disk operation might have very poor performance. Please be
    aware that parallel I/O operations are often very ineffective, and it might be
    reasonable to work with I/O sequentially, but in an asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks us through how to create a file, and how to read and write
    data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to work with files asynchronously, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, we create four files in different manners and fill them
    up with random data. In the first case, we use the `FileStream` class and its
    methods, converting an Asynchronous Programming Model API to a task; in the second
    case, we do the same, but we provide `FileOptions.Asynchronous` to the `FileStream`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to use the `FileOptions.Asynchronous` option. If we omit
    this option, we can still work with the file in an asynchronous manner, but this
    is just an asynchronous delegate invocation on a thread pool! We use the I/O asynchrony
    with the `FileStream` class only if we provide this option (or `bool useAsync`
    in another constructor overload).
  prefs: []
  type: TYPE_NORMAL
- en: The third case uses some simplifying APIs such as the `File.Create` method and
    the `StreamWriter` class. It still uses I/O threads, which we are able to check
    by using the `stream.IsAsync` property. The last case illustrates that oversimplifying
    is also bad. Here we do not leverage the I/O asynchrony by imitating it with the
    help of asynchronous delegate invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Now we perform parallel asynchronous reading from files, summing their content,
    and then sum it with each other. Finally, we delete all the files. As there is
    no asynchronous delete file in any non-Windows store application, we simulate
    the asynchrony using the `Task.Run` factory method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an asynchronous HTTP server and client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to create a simple asynchronous HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to create a simple asynchronous HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the `System.Net.Http` framework library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we implement a very simple web server by using the `HttpListener` class.
    There is also a `TcpListener` class for the TCP socket I/O operations. We configure
    our listener to accept connections from any host to the local machine on port
    `1234`. Then we start the listener in a separate worker thread so that we can
    control it from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous I/O operation happens when we use the `GetContextAsync` method.
    Unfortunately, it does not accept `CancellationToken` for cancellation scenarios;
    so when we want to stop the server, we just call `_listener.Abort` method that
    abandons all the connection and stops the server.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an asynchronous request to this server, we use the `HttpClient` class
    located in the `System.Net.Http` assembly and the same namespace. We use the `GetAsync`
    method to issue an asynchronous HTTP `GET` request. There are methods for the
    other HTTP requests such as `POST`, `DELETE`, and `PUT`. `HttpClient` has many
    other options such as serializing and deserializing an object using different
    formats such as XML and JSON, specifying a proxy server address, credentials,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you can see that the server has been started up. In
    the server code, we use the `GetContextAsync` method to accept new client connections.
    This method returns when a new client connects, and we simply output a very basic
    HTML with the current date and time to the response. Then we request the server
    and print the response headers and content. You can also open your browser and
    browse to the `http://localhost:1234/` URL. You will see the same response displayed
    in the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a database asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks us through the process of creating a database, populating
    it with data, and reading data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a running Visual Studio 2012\. No
    other prerequisites are required. The source code for this recipe can be found
    at `BookSamples\Chapter9\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the process of creating a database, populating it with data,
    and reading data asynchronously, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program works with a software called SQL Server 2012 LocalDb. It is installed
    with Visual Studio 2012 and should work fine. However in case of errors, you might
    want to repair this component from the installation wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with configuring paths to our database files. We place database files
    in the program-execution folder. There will be two files: one for the database
    itself and another for the transaction log file. We also configure two connection
    strings that define how we connect to our databases. The first one is to connect
    to the LocalDb engine to detach our database; if it already exists, delete and
    then recreate it. We leverage the I/O asynchrony while opening the connection
    and while executing the SQL commands using the `OpenAsync` and `ExecuteNonQueryAsync`
    methods respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: After this task is complete, we are attaching a newly created database. Here
    we create a new table and insert a few data in it. In addition to the previously
    mentioned methods, we use `ExecuteScalarAsync` to asynchronously get a scalar
    value from the database engine, and we use the `SqlDataReader.ReadAsync` method
    to read a data row from the database table asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If we had a large table with large binary values in its rows in our database,
    then we would use the `CommandBehavior.SequentialAcess` enumeration to create
    the data reader and the `GetFieldValueAsync` method to get large field values
    from the reader asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a WCF service asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to create a WCF service, host it in a console
    application, make service metadata available to clients, and how to consume it
    in an asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a running Visual Studio 2012\. There
    are no other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter9\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to work with a WCF service, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add references to the `System.ServiceModel` library. Right-click on the `References`
    folder in the project and select the **Add reference…** menu option. Add references
    to the `System.ServiceModel` library. You can use the search function in the reference
    manager dialog as shown in the following screenshot:![How to do it...](img/7644OT_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows Communication Foundation or WCF is a framework that allows us to call
    remote services in different ways. One of them, which was very popular some time
    ago, was used to call remote services via HTTP using an XML-based protocol called
    **Simple Object Access Protocol** (**SOAP)**. It is quite common when a server
    application calls another remote service, and it could be done using I/O threads
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2012 has rich support for WCF services; for example, you can add
    references to such services with the **Add Service Reference** menu option. You
    could do it with our service as well because we provide service metadata.
  prefs: []
  type: TYPE_NORMAL
- en: To create such a service we need to use a `ServiceHost` class that will be hosting
    our service. We describe what service we will be hosting by providing a service
    implementation type and the base URI by which the service would be addressed.
    Then we configure the metadata endpoint and the service endpoint. Finally, we
    handle the `Faulted` event in case of errors and run the host service.
  prefs: []
  type: TYPE_NORMAL
- en: To consume this service, we create a client, and here is where the main trick
    happens. On the server side, we have a service with the usual synchronous method
    called `Greet`. This method is defined in the service contract, `IHelloWorldService`.
    However, if we want to leverage an asynchronous network I/O, we have to call this
    method asynchronously. We can do that by creating a new service contract with
    matching namespace and service name, where we define both the synchronous and
    task-based asynchronous methods. In spite of the fact that we do not have an asynchronous
    method definition on a server side, we follow the naming convention, and the WCF
    infrastructure understands that we want to create an asynchronous proxy method.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we create an `IHelloWorldServiceClient` proxy channel, and WCF
    correctly routes an asynchronous call to the server-side synchronous method. If
    you leave the application running, you can open the browser and access the service
    using its URL that is `http://localhost:1234/HelloWorld`. There will be a service
    description opened, and you can browse to the XML metadata that allows us to add
    a service reference from Visual Studio 2012\. If you try to generate the reference,
    you will see a slightly more complicated code, but it is autogenerated and easy
    to use.
  prefs: []
  type: TYPE_NORMAL
