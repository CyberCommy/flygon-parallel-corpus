- en: Permissions, SELinux, and AppArmor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppArmor and modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux and modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking SELinux is running, and the importance of keeping it running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting SELinux permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early days, way back in the mists of the 90s, Linux didn''t have a great
    deal in terms of access control...then came permissions and attributes. Permissions
    and attributes are the elements of a file that dictate what access the system
    and users have to that file (or folder), and what it''s capable of doing to the
    file in terms of interaction. At a basic level, you use `ls` to view information
    on permissions (more on this later), but for now, see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will learn about permissions from the basic Linux offerings,
    to SELinux and AppArmor. We'll also look at troubleshooting issues that might
    be caused by SELinux or AppArmor. We will also learn the importance of not disabling
    extended permission controls.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of security, locking down your system is obviously important, and at
    its extreme, you could create a system where every program is ignorant of every
    other program (effectively having each program siloed).
  prefs: []
  type: TYPE_NORMAL
- en: While security is never a bad thing, a balance is crucial. You don't want to
    start stressing over the permissions of every file in an Ubuntu install, there's
    literally thousands and you'd go mad before you finished... unless it's literally
    your sole job to do this, or you want an especially dull hobby, in which case
    go nuts!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we''re going to use the following `Vagrantfile`; note
    that we only use two machines: CentOS to highlight SELinux features and abilities,
    and an Ubuntu installation for AppArmor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the `provisionScript` used here is to fix a slight problem
    with one of the sections in this chapter. If you experience issues surrounding
    this script, feel free to remove it from your configuration (there is a note later
    on about this, in the relevant section, where we talk about `.autorelabel`).
  prefs: []
  type: TYPE_NORMAL
- en: Linux file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, we're going to go right back to basics by taking a look at the default
    Linux file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to use a file and a directory on our CentOS box,
    to highlight some important and basic knowledge that we can use going forward.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions on Unix and Unix-like systems are different from those found
    on Windows and other OS installations. If you connect a hard drive formatted with
    a Unix file-system (such as XFS) to a Windows box, it is unlikely it will be able
    to read the permissions on the files accurately (unless you've got software to
    do it for you). These lines have been blurred a bit in recent years, thanks to
    things like the Windows Subsystem for Linux included in Windows 10, but the principle
    is basically true.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jump onto your CentOS box. For the sake of this section, everything we discuss
    is universal across Linux distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file, a directory, and a file in that directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With your files from the *Getting ready* section in place, run an `ls -l` on
    what we''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`-l`, used here, means using a long-listing format, and is used not just to
    print the files and folders found, but to give us a more complete picture.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to break this down, because at first glance, it can appear quite
    confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: exampledir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with `exampledir`, let's look at the permissions and ownership of this
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have an array of letters, a number `2`, and then two names, `vagrant` and
    `vagrant`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `d` at the beginning is an easy one; it indicates that the listed item is
    actually a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, we have three elements that appear similar, and the first of these are
    the user permissions. Here, the permissions are read, write, and execute.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the user will be able to `touch` (create) files in the directory,
    `mv` (rename) them, `ls` (list) them, `cat`/`less` (read) them, and even `rm`
    (delete) them should they wish.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the group permissions, here again as read, write, and execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thirdly, we have the permissions of everyone, and in this case anyone can read,
    or change into the directory.
  prefs: []
  type: TYPE_NORMAL
- en: They won't be able to create, rename, or delete existing files, because they
    don't have the write (`w`) permission.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that even experienced sysadmins forget. If you're in a group
    that can access the contents of a file within a directory, but the directory's
    own permissions don't allow this, you're not going to be able to complete the
    action. I've heard some quite notable groans of realization related to this little
    tidbit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the `.` at the end of the block. Right now, we don''t have to
    worry about this too much, but it indicates that the directory has a security
    context applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The digit, in this case `2`, refers to the number of locations pointing to
    the inode (the place on the disk where the data is actually stored). The reason
    why it''s `2` in this case is because two entries are created every time a directory
    is made, viewable with `ls -la`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see two special entries, `.` and `..`, which refer to this directory,
    and the parent directory, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There are therefore two links to this directory; the first is from the parent
    (`/home/vagrant/exampledir`) and the second is from within the directory itself
    (`/home/vagrant/exampledir/.`). Confused yet?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for a much easier bit, the `vagrant vagrant` entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These are simply the user, then the group, whose permissions are reflected in
    the `drwxrwxr-x.` block. There is no entry for everyone as that would be pointless.
  prefs: []
  type: TYPE_NORMAL
- en: examplefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on to `examplefile`, we have the following:.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see much the same as `exampledir`, with a few changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `d` has been replaced by `a`—character, meaning we're dealing with an actual
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The permissions for the user and group are read only and write, meaning the
    file can be read and modified, but it can't yet be executed by the user and group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The permissions for everyone else are only read, meaning the file can have `cat`/`less`
    applied, but it can't be modified or executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we can see a `1` for the number of links, which makes sense as
    the underlying inode isn't referenced from elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few more things to mention that are useful to know, even if we don't
    touch on them here.
  prefs: []
  type: TYPE_NORMAL
- en: Root access to directories and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `god/super/almighty` user (`root`) has pretty much carte blanche access
    to everything on the system, meaning that a common shortcut you might see people
    enacting is the following, should they get frustrated at their inability to read
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This would work, because `root` has that power, but it's a bad habit to get
    into using `sudo` for everything. Be selective with it, and think about what you're
    doing before you arbitrarily stick `sudo` in front of things because you're frustrated.
    (Mostly, this is a message to myself, because I'm just as guilty of this as anyone.)
  prefs: []
  type: TYPE_NORMAL
- en: Other execute characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of the humble `x` in the execute column, it's possible to also see other
    characters, the most common of which are `s` and `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at these permissions for the `wall` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how the group has `s` set in place of an `x`.
  prefs: []
  type: TYPE_NORMAL
- en: This is known as the `setuid` and `setgid` bit, depending on if it's in the
    user or group triad, and effectively it changes the executing user's permissions
    to those of the owner or group, again depending on the triad. In this case, those
    users executing the `wall` command get the permissions of the `tty` group (allowing
    `wall` to output to all `ttys`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I''m using `wall` as the vagrant user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `t` entry, or sticky bit, is again quite rare, but it is set most commonly
    on the `/tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `.` character refers to this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It sets it so that only the owner of a file in `/tmp` can rename or remove
    that file, meaning if I create a file in `/tmp` as the `vagrant` user, another
    person can''t come along and remove my file (except `root`). Visually, it looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more than these two other execute characters, but these are the most
    common.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating files is all well and good, but eventually we'll come across a use
    case where the default permissions just aren't acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is SSH, which will downright refuse to function unless
    some particularly rigid file permissions are in place on your public and private
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: So, here come "The Three Musketeers", in the form of `chown`, `chmod`, and `chattr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to be really annoying, and lose friends easily, insist on calling
    these by their full titles: change ownership, change mode, and change attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to again use our CentOS VM from our `Vagrantfile`,
    as everything we're doing is universally applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your CentOS VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Move into the `/home` directory (up one level) and create a file, a directory,
    and a file in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re also going to create another dummy user that we can use to explain what
    we''re doing in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note the password we've set here is 'correcthorsebatterystaple'.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll run through the three commands ( `chown`, `chmod`, and `chattr`) in order.
  prefs: []
  type: TYPE_NORMAL
- en: chown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting at the easiest bit, we're going to look at the ownership of the files
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by listing what we have already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we wanted to make it so our vagrant user could write to the `permissionfile`,
    instead of its current ability to only read it. Note the following for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We would use `chown` to make this change, by passing the user and group we
    want to change the file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we, as the vagrant user, can now write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But, other users (that aren''t `root`) can''t write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using `su` to execute a command as the Packt user, and we're showing
    that though we tried to `echo IMPOSSIBLE` to the file, it failed. We used the
    full path for `permissionfile` to make sure we didn't create the file in the Packt
    user's `home` directory.
  prefs: []
  type: TYPE_NORMAL
- en: chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re being a bit unfair on the old Packt user here, so let''s give everyone
    the ability to write to the file, rather than just `vagrant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to write to the file as any user, instead of just vagrant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: chattr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m starting to think we''ve been much too lenient here, so let''s completely
    lock down the file so no one (even almighty `root`) can mess with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've made the file immutable!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this using the `lsattr` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And, not even `root` is able to modify the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There are various attributes that can be applied to a file with `chattr`, but
    I'd put money on the immutable option being the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the attribute, use `chattr` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running through each of the commands again, let's take a brief look at what
    we did.
  prefs: []
  type: TYPE_NORMAL
- en: chown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we changed the ownership of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using `chown` in its most basic way, dictating which user and group
    the file should belong to. The values are colon-separated, though if you're backward
    like me, you occasionally use the deprecated and incorrect full stop (`.`)instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can just specify a user if you want to leave the group alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we changed our file so that anyone could write to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed certain octal values to the `permissionfile` in order to change
    the rights for the user, group, and everyone else in turn.
  prefs: []
  type: TYPE_NORMAL
- en: I won't go into great detail on this, but effectively, the first digit indicates
    what values the user's triad should be, then the group's triad, then everyone
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Our user gets the value of `6` that translates to read/write; our group can
    only read `4` and everyone else can read/write `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because each of the values has a numeric equivalent, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` = `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` = `2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r` = `4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the `6` value is `4`+`2`, or `r`/`w`, and the `4` value is only `r`.
  prefs: []
  type: TYPE_NORMAL
- en: You could set `777`, which would mean `r`/`w`/`x` for everything and everyone,
    and it's frequently done by people who don't understand file permissions properly.
    It's not a good practice, and should be dissuaded outside of troubleshooting.
    If I find a box where someone has run `chmod 777` on a file in production, that
    person is getting their access revoked and a quick primer on permissions plonked
    into their calendar.
  prefs: []
  type: TYPE_NORMAL
- en: chattr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, we changed one of the file's attributes, specifically making the file
    immutable to even `root`, before we removed the flag again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more flags than just immutable; all of them listed in the `chattr`
    main page, and some of them can be useful in niche situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: A file can only be appended to (useful for logs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: To compress and uncompress transparently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Results in the file''s blocks are zeroed and written back to disk on file
    deletion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not all attributes are honored by all file systems; check if your filesystem
    supports them too (hint: `ext4` doesn''t support quite a few).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are one or two more things to note, before we wrap this section.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding octal notation (if you hate it) in chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You don''t absolutely have to use the octal format in the `chmod` world; it
    does give you other options that are easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command would give the user and others the read/write rights,
    and the group the read rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, you might add a value to the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This would grant the group the additional ability to execute the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Hierarchical permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a directory, and a file in that directory, so let's take a quick
    look at understanding directory permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, our `permissiondir` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t currently rename this file, despite us wanting to, as it''s too long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s set the write permission on this file for everyone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Huh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so the reason for this is because it''s actually the directory permissions
    stopping us from moving the file, not the file permissions. We have to modify
    the directory that the file is contained in, as the permissions won''t let us
    rename (`mv`) a file as they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should be able to move the file, because our permissions are now extremely
    liberal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing we didn't cover in this section were **access control lists** (**ACLs**)
    that can be used to further extend a file's permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by putting a small command in our `permissionfile` to make it execute
    something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we want to view our entire access control list for a file; we would use
    `getfacl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the owner is `vagrant`, and the user has `rw`.
  prefs: []
  type: TYPE_NORMAL
- en: But, what if we wanted Packt to be able to execute the file, without impacting
    the other permissions? At the moment, Packt can't because it's not in the `root`
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential solution is `setfacl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see a little `+` sign with `ls`, showing us that the file has extended
    access controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can see those using `getfacl` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that our `vagrant` user can''t execute the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But, our Packt user can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to jump onto both our CentOS and Ubuntu VMs, to
    highlight some important differences in approach to users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered users and groups in terms of file permissions, but it's a good
    idea to run over what we know about users and groups in brief.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to delve into a short primer on users and groups,
    determining which user a process is running as, how it changes to that user, and
    finding which users exist on your system by using `/etc/passwd` and similar commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use Vagrant to connect to your Ubuntu and CentOS VMs, in different windows
    or one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over a few short sections, we're going to look at different elements of users
    and groups.
  prefs: []
  type: TYPE_NORMAL
- en: whoami
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever need to know who you are, ask yourself through deep reflection and
    inner contemplation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to know what users are logged into a server as (or running a command
    as), it''s a lot easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Users on a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show what users are in place on a system, check out `/etc/passwd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On CentOS, it''ll look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And, on Ubuntu, it''ll look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Most of these users you will not have created yourself; they are system users
    for the most part, or bundled with software you've installed.
  prefs: []
  type: TYPE_NORMAL
- en: Groups on a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Groups are discovered in a similar fashion to users, and again, you won't have
    created most of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For CentOS, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And for Ubuntu, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: I've emboldened the first big difference between this Ubuntu and CentOS system,
    namely the `wheel` and `admin` groups. `wheel` doesn't exist on our Ubuntu system,
    because it's been replaced by the `admin` group; this means that the `visudo`
    file on Ubuntu references the members of the `admin` group instead of `wheel`.
    Something to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Daemons using users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our Ubuntu system, the `syslogd` daemon is run using the `syslog` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm this by locating our `rsyslogd` process and checking the user
    in the leftmost column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can see why this user is found by checking out the `/etc/rsyslog.conf`
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you wanted to quickly exclude processes running as `root`, you might use
    a quick one-liner such as the following (though it's not perfect by any means).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is on our CentOS VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, different users and groups will have specific uses, deliberately
    segregated so that they're not too powerful in their own right. If you've got
    a multi-tenanted system (which is very rare these days) with more than one person
    logging on to do their day-to-day work, you want to make sure that person can't
    make life harder for everyone else, by doing something silly like overwriting
    the logs on the box.
  prefs: []
  type: TYPE_NORMAL
- en: You might solve this issue by putting all human users in one group, and while
    allowing them their own users with limited access, you could then give the group
    access to things such as shared directories and applications they might need to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Processes have the option to drop their privilege, though not all will do so
    out of the box, and if you want to go this extra mile, it's usually a lot of work
    to set up. Here, we saw `syslog` starting up (as `root`) then immediately lowering
    its own privilege level to that of the `syslog` user and group.
  prefs: []
  type: TYPE_NORMAL
- en: The reason `rsyslogd` has to start as `root` is because it binds to a port lower
    than `1024`, which are the restricted ports only accessible to `root` programs.
  prefs: []
  type: TYPE_NORMAL
- en: Some distributions and operating systems take this approach a lot more strictly
    than others, but as with everything security-related, it's like another layer
    to the onion of being secure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at this user, on your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It's got an underscore, the only one to have one in the entirety of the `/etc/passwd`
    file; why might that be?
  prefs: []
  type: TYPE_NORMAL
- en: One potential reason is that it's a system account and the application maintainer
    or developer decided to denote this with an underscore character, as is the case
    with other operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor and modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use AppArmor on Ubuntu and determine what effect
    it has on our system.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor is installed by default on Ubuntu. It was originally developed by SUSE,
    but Canonical seem to have stuck their flag firmly in the AppArmor planet, introducing
    it in Ubuntu 7.04 and turning it on by default in 7.10 (2007).
  prefs: []
  type: TYPE_NORMAL
- en: Like SELinux, AppArmor is a way of introducing mandatory access controls (MAC)
    into Linux; it has been included in the kernel since 2.6.36.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to be using our Ubuntu VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First thing''s first, let''s make sure that `apparmor` is running, using our
    old pal, `systemctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what profiles are loaded, and what mode they''re running in, use `apparmor_status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how AppArmor can limit applications, let''s make a modification
    to the `tcpdump` profile and restart AppArmor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did here was remove the ability of `tcpdump` to capture, making it
    pretty useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the kernel log, we can see the denial from us trying to run `tcpdump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note the capibility name, `net_raw`, that we removed with `sed` earlier.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiles for AppArmor are written and loaded into the kernel using the `apparmor_parser`
    program. Mostly, these will be profiles located in `/etc/apparmor.d/`; though
    if a program doesn't have a profile, AppArmor doesn't stop it from running.
  prefs: []
  type: TYPE_NORMAL
- en: When the actual systemd unit is started, an `init.d` script is run (located
    at `/etc/init.d/apparmor`), which does the actual calling of `apparmor_parser`.
  prefs: []
  type: TYPE_NORMAL
- en: When profiles are run in enforcement mode, as the preceding fifteen are, they
    must adhere to the policy definition, or they will not be able to act outside
    the policy's requirements, and violations are logged. If profiles are in complain
    mode, the policy is not enforced, but violations are logged for later perusal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiles are generally named by replacing the executable''s slash location
    with dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the top few lines of the `tcpdump` profile, we can start
    to see how profiles are built up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We can see first that the name of the binary is specified, then a select amount
    of includes (which are rules that could be used across other programs too).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have `capability`, including the one we commented out. There are a
    list of capabilities, viewable in the `man (7) capabilities` page where they're
    listed with names like `CAP_NET_RAW` and `CAP_SETGID`, but here they're lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: When we removed this `capability`, `tcpdump` lost the capability to use RAW
    and PACKET sockets, as well as to bind to any address for transparent proxying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further down, we can see how the author of the file has used comments, and
    flags for `tcpdump`, to describe what they''re allowing with what permission.
    In the following example, they''re allowing the use of `gzip` and `bzip2` specifically,
    so that the `-z` option works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The syntax can be compared and understood using the surprisingly detailed `apparmor.d`
    man page.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While AppArmor is nice and it definitely does what it advertises, there are
    some caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: It relies on developers to write and supply profiles (or others who contribute
    the time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiles have to be bulletproof before they can be included in the default installation,
    which could be the reason there are so few even after a decade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's fairly unknown and most people don't even bother with it outside of the
    defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also goes off path, rather than inode, meaning you can do things such as
    create a hardlink to bypass restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Admittedly, if you''re on a box and have `sudo`, it''s pretty much game over
    at that point anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You might ask why you need something like this on your system if it's so easy
    to tweak and bypass, but the answer is relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a web server on the public internet, there's a good chance it might
    get attacked at some point, and when that happens, you might be completely up
    to date and get hit by a zero-day exploit (however unlikely). Your web server
    could then be compromised, and the individual attacking you might then use it
    to try and set up a different process, running on a different port, or even use
    it to start reading files that it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory access controls go a long way to ensuring this doesn't happen, and
    life gets just that bit more frustrating for the person on the other end of the
    attack. They might have your web server, but that's all they've got.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux and modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like AppArmor, **Security-Enhanced Linux** (**SELinux**) is a way to introduce
    mandatory access controls into Linux, only it has a couple of key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It's more widely used and loathed than AppArmor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's primarily used on Red Hat-based distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're in the enterprise world, or thinking of going there, SELinux is a
    great tool to add to your tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: You might recall that we've already touched on SELinux previously, making a
    couple of small changes to allow things like SSH to run on different ports; here,
    we're exploring it further.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to use our CentOS VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your CentOS VM, forwarding `8080` as you do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure NGINX and some utilities are installed, and that NGINX is started
    for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to change the port on which NGINX listens by default, to show how
    much of a pain SELinux can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check that NGINX is running on port `80` (the default) by using `curl`
    and printing the return code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Using `-I` here means that we don't pull in a screen full of code, and instead
    we just get the pertinent information, like the return code (`200` being OK).
  prefs: []
  type: TYPE_NORMAL
- en: Cool, so that's all working normally, and SELinux isn't getting in the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want NGINX to listen on a different port? Say the one we forwarded?
    Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our `curl` command again with the new port should report an error (obviously,
    as the service failed to start):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Odd...but not really.
  prefs: []
  type: TYPE_NORMAL
- en: This is because NGINX is only allowed to run on certain ports, `80` being one,
    `8080` being another, and so on. `5858` is obscure and weird; why would a web
    server want to run on it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we have to update SELinux to allow NGINX to run on the new
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Oh damn, it looks like `5858` is already defined for something else (in this
    case Node.js – curse you Node.js!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, this isn''t the end of the world, we just have to modify the port
    rather than add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can restart NGINX, and it should work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also visit it in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b5564f2-b3e8-47cd-a5a2-d9bb5e33f22a.png)'
  prefs: []
  type: TYPE_IMG
- en: Yep, it says Fedora, and yes, it's wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's the first step, but now we've decided that instead of the default
    NGINX welcome page, we want it to show our file in `/srv/webserver/arbitrary-location/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create this directory structure and put a simple file in there
    to serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s check the permissions we have on the existing page location, and
    make sure they''re the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll make sure ours are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll update our NGINX config to log to this new location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we restart our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give our `curl` a go, omitting the `-I` this time so we get our page
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Oops...that doesn't look right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, SELinux is to blame, but the fix is a fairly simple set of
    commands that we can use to correct the `fcontext` of the file in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying our `curl` now should give us our message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can view it in our browser like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5778bc90-f8c0-4a88-a7d6-bb5d0719bda6.png)'
  prefs: []
  type: TYPE_IMG
- en: If this isn't worthy of Tate Modern, I don't know what is.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we changed the port and restarted the service, we got some errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note the specific `Permission denied` entry on the `5858` port.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query SELinux port types and their number, using the `semanage` command
    we installed as part of the utilities installation earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that while `80` and other ports are permitted as HTTP ports,
    `5858` wasn't there initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we added the additional port just shown, this command looked different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: So, SELinux now allows this port to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the file, we can check what `fcontext` NGINX needs files to have,
    using the `ls -Z` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seen here, we run it against the default files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This is a good way to determine what context you need to give the new files
    you create.
  prefs: []
  type: TYPE_NORMAL
- en: When we applied our new policy rule and restored the policy values to the system,
    our file was suddenly capable of being used by NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELinux isn't really as bad as everyone thinks, and it's come a long way since
    the days when things used to silently fail for no obvious reason. Generally, there's
    a plethora of tools and debugging programs available to you these days when it
    comes to finding the correct configuration for your system and programs, though
    they can (and do) fill books by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: If you take anything away from this section, understand that disabling SELinux
    isn't the answer (that is, setting it to permissive mode), and that outside of
    a development environment, all you're doing is making life less secure for yourself
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '`semanage` also isn''t the only way to manage SELinux policies, but it''s very
    easy to use and quite a neat way to introduce yourself to the wonderful world
    of policy files.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, desktop systems don't use SELinux, with the exception of Fedora,
    so if you really want to start messing around with it, fire up a VM with Fedora
    installed and take a look at tools such as `audit2allow` and `chcon`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking SELinux is running, and the importance of keeping it running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at how we check that SELinux is enabled
    and running on our system, and we're going to use the logs that SELinux writes
    to during its operation. At the same time, we're going to use `setroubleshoot`
    to help us in determining what might be the issue with what we're trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: To again stress, there was a period when SELinux started to become a thing,
    and people dismissed it immediately. Most online guides would begin with the immortal
    words "be sure to check SELinux is disabled". Thankfully, that mentality has mostly
    died out now, and people have come to accept SELinux as their one-true-god.
  prefs: []
  type: TYPE_NORMAL
- en: It's extremely tempting, when you come across an issue caused by SELinux, to
    simply disable it. This is doubly true if the issue is on a production server,
    and you're under pressure to fix it. Abstain from the easy solution of disabling
    SELinux, as doing so will only going to come around and bit you in the future.
  prefs: []
  type: TYPE_NORMAL
- en: That said, I will now touch on how to disable SELinux (to aid with troubleshooting!).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to use our CentOS VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your CentOS VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If not installed from the previous section, make sure NGINX and our various
    tools are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, and easily, you can check the current status of SELinux with `sestatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that it's `enabled`, and the mode that it's operating in is `enforcing`,
    meaning that violations of the policy are denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable SElinux on the fly (temporarily,) there''s a relatively easy command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: But this will change again at boot-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s leave it enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Next, we're going to change the port that we want NGINX to use (again), restart
    NGINX, watch it fail, and see how we'd go about determining the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the port can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: If you didn't change the port in the previous section (you're starting fresh),
    then you'll want to substitute the `5858` shown here for `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restarting NGINX is easiest with  `systemctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can do now is determine why it failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This might give you a lot of results, especially if you''ve been running the
    box for some time, but near to the end should be a report that looks similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Emboldened at the top is the one-line summary of what `sealert` thinks the issue
    is; in this case, it's right.
  prefs: []
  type: TYPE_NORMAL
- en: It then gives you a `semanage` command, similar to what we used earlier, to
    modify the policy.
  prefs: []
  type: TYPE_NORMAL
- en: It also gives you two commands, `ausearch` and `semodule`, that you can use
    to generate a local policy, which is effectively used alongside the base policy,
    but which can be included with things like Ansible installation scripts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you have an Ansible role that installs NGINX on a custom port,
    but it's okay because you can bundle the text-based policy alongside the configuration,
    and load it in the Ansible configuration run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try restarting NGINX, and `curl` our new port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Woop!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux''s configuration (in terms of if it''s running and in what mode) is
    set in the `/etc/selinux/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If you want to disable SELinux permanently, this is the file that you would
    change, flipping `enforcing` to `permissive` or even `disabled`.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the custom policy we loaded, we're looking at something a bit
    more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command made two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `.pp` file is a compiled policy, ready to be loaded, and the `.te` file
    is a human-readable file for your confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: When we loaded the policy using the `semodule -i` command, we activated it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see your active policies with `semodule` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`audit2allow` does its best, but it doesn''t always get policy files quite
    right (or it creates them with too much power, effectively making SELinux useless).
    Always get someone to sanity-check your configuration prior to loading it, unless
    you''re really, really confident.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I said at the start that it's important to ensure SELinux is running and to
    make sure you keep it running.
  prefs: []
  type: TYPE_NORMAL
- en: The problems that arise from disabling it and leaving it disabled should be
    obvious, but just to paint you a picture, note the following.
  prefs: []
  type: TYPE_NORMAL
- en: It's the end of the day on a Friday, just before the Christmas break, and most
    of the staff have already left after making some final checks to make sure your
    e-commerce site stays up during the Christmas and Boxing Day rush of people returning
    unwanted presents.
  prefs: []
  type: TYPE_NORMAL
- en: You're about to clock off when you notice an issue with the site, leading customers
    to believe they can get three hundred points off the latest Nintendo console,
    and you can't be having any of that nonsense.
  prefs: []
  type: TYPE_NORMAL
- en: You go in and make a manual change, adding an extra config file to correctly
    load the prices, and you restart the service.
  prefs: []
  type: TYPE_NORMAL
- en: The service doesn't come back up.
  prefs: []
  type: TYPE_NORMAL
- en: Panic sets in.
  prefs: []
  type: TYPE_NORMAL
- en: Your stomach drops out.
  prefs: []
  type: TYPE_NORMAL
- en: Someone in the distance lets out a bellow.
  prefs: []
  type: TYPE_NORMAL
- en: With speed and dexterity, you disable SELinux, restarting the service and bringing
    everything back online. The site is up, and the console now shows the right price.
  prefs: []
  type: TYPE_NORMAL
- en: Phew—you go home and eat several mince pies to celebrate.
  prefs: []
  type: TYPE_NORMAL
- en: Then, no one notices SELinux is disabled all year, until it comes time to push
    another version of the software next Christmas, using your CI/CD infrastructure
    that also makes sure SELinux is enabled. When that happens, the site goes down.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone panics and no one is sure what happened, but you don't care because
    you long since quit the company for making you work stupid hours, and you've decided
    to move to Japan to start a fruit-growing business.
  prefs: []
  type: TYPE_NORMAL
- en: Everything catches fire.
  prefs: []
  type: TYPE_NORMAL
- en: See what you did?
  prefs: []
  type: TYPE_NORMAL
- en: Leave SELinux enabled!
  prefs: []
  type: TYPE_NORMAL
- en: Resetting SELinux permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to talk about resetting SELinux permissions, and
    touch upon how you might reset a `root` password on a box you've forgotten the
    password for, while accounting for SELinux, which will hinder you otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect to your CentOS VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First off, it's important to understand that with SELinux, we effectively have
    a running-ish configuration and a saved configuration. When you're running your
    system, it's important that any changes you make to SELinux are saved, to be loaded
    in the event of an SELinux relabel.
  prefs: []
  type: TYPE_NORMAL
- en: To see this in action, let's copy some contexts around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by taking a look at the context our `.bashrc` file has (because it''s
    immediately available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four parts to this: we have a user (`unconfined_u`), a role (`object_r`),
    a type (`user_home_t`), and the sensitivity of the resource (`s0.`) The type is
    what''s important to us here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to change the type; we can do it on the fly by copying the type
    from another file (in this case, the `authorized_keys` file, which looks like
    this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Note now that when we look at our `.bashrc` file, the SELinux context has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'But `chcon` isn''t permanent, and what we''ve effectively done is change the
    running configuration of SELinux, meaning we can reset it with a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You may recall that earlier, we did this the other way around, using `semanage`
    to add a new context to a file, then using `restorecon` to apply that context.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to go about fixing temporary context changes is to relabel your
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our change again, copying the `authorized_keys` context once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s put a very specific file in a very specific location, and reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your machine comes back up, take a look at the file''s context again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: And, you'll also discover the `.autorelabel` file we added has been automatically
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The `Vagrantfile` for this chapter very specifically removes some console options
    as part of the bootstrap process for the CentOS VM. This is because if you don't,
    the `.autorelabel` function won't work. If you experience problems with this fix,
    try it on a physical machine or a vanilla VM (*in a development environment!*).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What `restorecon` does is check a file's context against what it expects to
    be true, and if it finds anything amiss, it will correct it with the static configuration
    it knows about.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the `.autorelabel` function, we effectively ran the `fixfiles relabel`
    command across our system at boot-time, prior to our touched file being deleted.
    What you'll notice is that this boot may take longer as it has more of a job to
    do when coming up.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `restorecon` will only restore the `type` context and leave the
    others as it found them. This can be overridden with the `-F` flag.
  prefs: []
  type: TYPE_NORMAL
- en: We also mentioned resetting the `root` user's password, which is made oh-so-annoying
    by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you've forgotten the `root` password to your box; the way to go about
    fixing this is to boot into single-user mode, change the password, and reboot...or
    at least, that used to be the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the steps involved look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the GRUB entry for your installation before it times out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `linux16` line is `rw` instead of `ro`, and change the `init`
    to something like `/bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue the boot process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your `/` directory is mounted as `rw`, and you can edit files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `passwd` to update the `root` password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `touch .autorelabel` in the `/` directory, and reboot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check you can log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you skip the `touch .autorelabel` step, it won't work, and you'll have to
    start again.
  prefs: []
  type: TYPE_NORMAL
- en: In the grand scheme of things, it's not much, but it can be infuriating in the
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: Roundup - permissions, SELinux, and AppArmor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At what point is it too late?
  prefs: []
  type: TYPE_NORMAL
- en: When have you exhausted every possible avenue for resolving your problem?
  prefs: []
  type: TYPE_NORMAL
- en: Do you have decent backups that you've checked and confirmed work?
  prefs: []
  type: TYPE_NORMAL
- en: Are you tearing your hair out?
  prefs: []
  type: TYPE_NORMAL
- en: Has it been three days, and have you not seen daylight since Tuesday?
  prefs: []
  type: TYPE_NORMAL
- en: Permissions can be tricky and awkward, and sometimes it's just better to say,
    "Screw it, this system is too far gone, I'm starting again." My general rule of
    thumb for this sort of thing is how many meals I have skipped trying to fix something,
    and if it's more than one, that's too many meals skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Before now, I've done stupid things, as I think I've made painfully clear throughout
    this book so far. I've chmod'd entire systems to `777` recursively (which breaks
    a lot), I've deleted directories in an effort to free up space, only to discover
    that directory was actually rather important to the system's good health (I won't
    share which one, but it had files and non-files inside it). I've even stopped
    an accidental `rm` of much more than I intended to `rm` and stressed myself blue
    trying to work out how much of the filesystem I'd actually hosed.
  prefs: []
  type: TYPE_NORMAL
- en: In short, I've broken systems to the point where they're technically fixable,
    but where the time it would take outweighs the heartache of doing a recovery.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux, AppArmor, and simple blanket Linux permissions can leave you scouring
    the internet for obscure error messages, in the hope someone else has come across
    the exact same problem as you, and that they've decided to share their solution
    (as long as it isn't "It's fine, I fixed it, closing this thread").
  prefs: []
  type: TYPE_NORMAL
- en: But all that said, the macOS systems, and even POSIX standard file permissions,
    are important. It can be time-consuming and annoying, but using tools such as
    `audit2allow` can greatly reduce your blood pressure, while adding to your awesomeness,
    and learning the correct `chmod` incantations can speed up your troubleshooting
    tenfold.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, the software you install from the official repositories is
    going to be set up sensibly, and as long as the third party is worth their salt,
    you might even find that other repositories you add later include appropriate
    SELinux permissions on their software. The situation is so much better than it
    was when SELinux first started to be a thing.
  prefs: []
  type: TYPE_NORMAL
- en: I remember when people recommended disabling SELinux as step one on their guides,
    and I'm glad we're beyond those days, but sometimes it can be tempting.
  prefs: []
  type: TYPE_NORMAL
- en: Those moments when you're at your wit's end, and you just want your application
    to work, can be the most tempting moments to disable SELinux. Hold firm, be steadfast,
    and tell yourself you're not going to be beaten by a computer.
  prefs: []
  type: TYPE_NORMAL
- en: It's not like you're up against HAL 9000.
  prefs: []
  type: TYPE_NORMAL
