- en: Chapter 3. Working with PHP Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hinting at data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using return value data typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own iterator using generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will consider recipes that take advantage of PHP's **functional
    programming** capabilities. Functional, or **procedural**, programming is the
    traditional way PHP code was written prior to the introduction of the first implementation
    of **object-oriented programming** (**OOP**) in PHP version 4\. Functional programming
    is where program logic is encapsulated into a series of discreet **functions**,
    which are generally stored in a separate PHP file. This file can then be included
    in any future scripts, allowing the functions that are defined to be called at
    will.
  prefs: []
  type: TYPE_NORMAL
- en: Developing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most difficult aspect is deciding how to break up programming logic into
    functions. The mechanics of developing a function in PHP, on the other hand, are
    quite easy. Just use the `function` keyword, give it a name, and follow it with
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code itself goes inside curly braces as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define one or more **parameters**. To make one of them optional, simply
    assign a default value. If you are not sure what default value to assign, use
    `NULL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You cannot redefine functions. The only exception is when duplicate functions
    are defined in separate namespaces. This definition would generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t know how many parameters will be supplied to your function, or
    if you want to allow for an infinite number of parameters, use `...` followed
    by a variable name. All parameters supplied will appear as an array in the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can call itself. This is referred to as **recursion**. The following
    function performs a recursive directory scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usage of the `static` keyword inside functions has been in the language for
    more than 12 years. What `static` does is to initialize the variable once (that
    is, at the time `static` is declared), and then retain the value between function
    calls within the same request.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to retain the value of a variable between HTTP requests, make sure
    the PHP session has been started and store the value in `$_SESSION`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are constrained when defined within a PHP **namespace**. This characteristic
    can be used to your advantage to provide additional logical separation between
    libraries of functions. In order to *anchor* the namespace, you need to add the
    `use` keyword. The following examples are placed in separate namespaces. Notice
    that even though the function name is the same, there is no conflict as they are
    not visible to each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define `someFunction()` in namespace `Alpha`. We save this to a separate
    PHP file, `chap_03_developing_functions_namespace_alpha.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define `someFunction()` in namespace `Beta`. We save this to a separate
    PHP file, `chap_03_developing_functions_namespace_beta.php`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call `someFunction()` by prefixing the function name with the namespace
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is considered best practice to place function libraries (and classes too!)
    into separate files: one file per namespace, and one class or function library
    per file.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to define many classes or function libraries in a single namespace.
    The only reason you would develop into a separate namespace is if you want to
    foster logical separation of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is considered best practice to place all logically related functions into
    a separate PHP file. Create a file called `chap_03_developing_functions_library.php`
    and place these functions (described previously) inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '`someName()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someOtherName()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someInfinite()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someDirScan()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someTypeHint()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file is then included in the code that uses these functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To call the `someName()` function, use the name and supply the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `someOtherName()` function using one or two parameters, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `someInfinite()` function accepts an infinite (or variable) number of parameters.
    Here are a couple of examples calling this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can call `someDirScan()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hinting at data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases when developing functions, you might reuse the same library of
    functions in other projects. Also, if you work with a team, your code might be
    used by other developers. In order to control the use of your code, it might be
    appropriate to make use of a **type hint**. This involves specifying the data
    type your function expects for that particular parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameters in functions can be prefixed by a type hint. The following type
    hints are available in both PHP 5 and PHP 7:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a call to the function is made, and the wrong parameter type is passed,
    a `TypeError` is thrown. The following example requires an array, an instance
    of `DateTime`, and an anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't have to provide a type hint for every single parameter. Use this technique
    only where supplying a different data type would have a negative effect on the
    processing of your function. As an example, if your function uses a `foreach()`
    loop, if you do not supply an array, or something which implements `Traversable`,
    an error will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 7, presuming the appropriate `declare()` directive is made, **scalar**
    (that is, integer, float, boolean, and string) type hints are allowed. Another
    function demonstrates how this is accomplished. At the top of the code library
    file which contains the function in which you wish to use scalar type hinting,
    add this `declare()` directive just after the opening PHP tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can define a function that includes scalar type hints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, assuming strict type hinting has been declared, boolean type hinting
    works a bit differently from the other three scalar types (that is, integer, float,
    and string). You can supply any scalar as an argument and no `TypeError` will
    be thrown! However, the incoming value will automatically be converted to the
    boolean data type once passed into the function. If you pass any data type other
    than scalar (that is, array or object) a `TypeError` will be thrown. Here is an
    example of a function that defines a `boolean` data type. Note that the return
    value will be automatically converted to a `boolean`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, you can place the three functions, `someTypeHint()`, `someScalarHint()`,
    and `someBoolHint()`, into a separate file to be included. For this example, we
    will name the file `chap_03_developing_functions_type_hints_library.php`. Don't
    forget to add `declare(strict_types=1)` at the top!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our calling code, you would then include the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To test `someTypeHint()`, call the function twice, once with the correct data
    types, and the second time with incorrect types. This will throw a `TypeError`,
    however, so you will need to wrap the function calls in a `try { ... } catch ()
    { ...}` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output shown at the end of this sub-section, when passing
    the correct data types there is no problem. When passing the incorrect types,
    a `TypeError` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP 7, certain errors have been converted into an `Error` class, which is
    processed in a somewhat similar manner to an `Exception`. This means you can catch
    an `Error`. `TypeError` is a specific descendant of `Error` that is thrown when
    incorrect data types are passed to functions.
  prefs: []
  type: TYPE_NORMAL
- en: All PHP 7 `Error` classes implement the `Throwable` interface, as does the `Exception`
    class. If you are not sure if you need to catch an `Error` or an `Exception`,
    you can add a block which catches `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next you can test `someScalarHint()`, calling it twice with correct and incorrect
    values, wrapping the calls in a `try { ... } catch () { ...}` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the first call to the function works, and the second throws a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: When type hinting for boolean values, any scalar value passed will *not* cause
    a `TypeError` to be thrown! Instead, the value will be interpreted into its boolean
    equivalent. If you subsequently return this value, the data type will be changed
    to boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, call the `someBoolHint()` function defined previously, and pass
    any scalar value in as an argument. The `var_dump()` method reveals that the data
    type is always boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now try the same function call, but pass in a non-scalar data type,
    a `TypeError` is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the overall output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP 7.1 introduced a new type hint `iterable` which allows arrays, `Iterators`
    or `Generators` as arguments. See this for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/iterable](https://wiki.php.net/rfc/iterable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a background discussion on the rationale behind the implementation of scalar
    type hinting, have a look at this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/scalar_type_hints_v5](https://wiki.php.net/rfc/scalar_type_hints_v5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using return value data typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 allows you to specify a data type for the return value of a function.
    Unlike scalar type hinting, however, you don't need to add any special declarations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example shows you how to assign a data type to a function return value.
    To assign a return data type, first define the function as you would normally.
    After the closing parenthesis, add a space, followed by the data type and a colon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP 7.1 introduced a variation on return data typing called **nullable types**.
    All you need to do is to change `string` to `?string`. This allows the function
    to return either `string` or `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything returned by the function, regardless of its data type inside the function,
    will be converted to the declared data type as a return value. Notice, in this
    example, the values of `$a`, `$b`, and `$c` are added together to produce a single
    sum, which is returned. Normally you would expect the return value to be a numeric
    data type. In this case, however, the return data type is declared as `string`,
    which overrides PHP''s type-juggling process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign classes as a return data type. In this example, we assign
    a return type of `DateTime`, part of the PHP `DateTime` extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `makesDateTime()` function would be a potential candidate for scalar type
    hinting. If `$year`, `$month`, or `$day` are not integers, a `Warning` is generated
    when `setDate()` is called. If you use scalar type hinting, and the wrong data
    types are passed, a `TypeError` is thrown. Although it really doesn't matter whether
    a warning is generated or a `TypeError` is thrown, at least the `TypeError` will
    cause the errant developer who is misusing your code to sit up and take notice!
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function has a return data type, and you return the wrong data type in
    your function code, a `TypeError` will be thrown at runtime. This function assigns
    a return type of `DateTime`, but returns a string instead. A `TypeError` will
    be thrown, but not until runtime, when the PHP engine detects the discrepancy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the return data type class is not one of the built-in PHP classes (that is,
    a class that is part of the SPL), you will need to make sure the class has been
    auto-loaded, or included.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, place the functions mentioned previously into a library file called
    `chap_03_developing_functions_return_types_library.php`. This file needs to be
    included in the `chap_03_developing_functions_return_types.php` script that calls
    these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can call `returnsString()`, supplying a `DateTime` instance and a format
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the output is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can call `convertsToString()` and supply three integers as arguments.
    Notice that the return type is string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](graphics/B05314_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate that, you can assign a class as a return value, call `makesDateTime()`
    with three integer parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](graphics/B05314_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, call `wrongDateTime()` with three integer parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a `TypeError` is thrown at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP 7.1 adds a new return value type, `void`. This is used when you do not wish
    to return any value from the function. For more information, please refer to [https://wiki.php.net/rfc/void_return_type](https://wiki.php.net/rfc/void_return_type).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on return type declarations, see the following articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/return_types](https://wiki.php.net/rfc/return_types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For information on nullable types, please refer to this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/nullable_types](https://wiki.php.net/rfc/nullable_types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **iterator** is a special type of class that allows you to **traverse** a
    *container* or list. The keyword here is *traverse*. What this means is that the
    iterator provides the means to go through a list, but it does not perform the
    traversal itself.
  prefs: []
  type: TYPE_NORMAL
- en: The SPL provides a rich assortment of generic and specialized iterators designed
    for different contexts. The `ArrayIterator`, for example, is designed to allow
    object-oriented traversal of arrays. The `DirectoryIterator` is designed for filesystem
    scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Certain SPL iterators are designed to work with others, and add value. Examples
    include `FilterIterator` and `LimitIterator`. The former gives you the ability
    to remove unwanted values from the parent iterator. The latter provides a pagination
    capability whereby you can designate how many items to traverse along with an
    offset that determines where to start.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are a series of *recursive* iterators, which allow you to repeatedly
    call the parent iterator. An example would be `RecursiveDirectoryIterator` which
    scans a directory tree all the way from a starting point to the last possible
    subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first examine the `ArrayIterator` class. It's extremely easy to use. All
    you need to do is to supply an array as an argument to the constructor. After
    that you can use any of the methods that are standard to all SPL-based iterators,
    such as `current()`, `next()`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `ArrayIterator` converts a standard PHP array into an iterator. In a certain
    sense, this provides a bridge between procedural programming and OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of a practical use for the iterator, have a look at this example.
    It takes an iterator and produces a series of HTML `<ul>` and `<li>` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can simply wrap the `ArrayIterator` instance into a simple
    `foreach()` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`CallbackFilterIterator` is a great way to add value to any existing iterator
    you might be using. It allows you to wrap any existing iterator and screen the
    output. In this example we''ll define `fetchCountryName()`, which iterates through
    a database query which produces a list of country names. First, we define an `ArrayIterator`
    instance from a query that uses the `Application\Database\Connection` class defined
    in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building a Foundation*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a filter method, `nameFilterIterator()`, which accepts a partial
    country name as an argument along with the `ArrayIterator` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`LimitIterator` adds a basic pagination aspect to your applications. To use
    this iterator, you only need to supply the parent iterator, an offset, and a limit.
    `LimitIterator` will then only produce a subset of the entire data set starting
    at the offset. Taking the same example mentioned in step 2, we''ll paginate the
    results coming from our database query. We can do this quite simply by wrapping
    the iterator produced by the `fetchCountryName()` method inside a `LimitIterator`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when using `LimitIterator`. It needs to have the *entire* data set
    in memory in order to effect a limit. Accordingly, this would not be a good tool
    to use when iterating through large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators can be *stacked*. In this simple example, an `ArrayIterator` is processed
    by a `FilterIterator`, which in turn is limited by a `LimitIterator`. First we
    set up an instance of `ArrayIterator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we plug the `ArrayIterator` into a `FilterIterator` instance. Note that
    we are using the new PHP 7 anonymous class feature. In this case the anonymous
    class extends `FilterIterator` and overrides the `accept()` method, allowing only
    letters with even-numbered ASCII codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we supply the `FilterIterator` instance as an argument to `LimitIterator`,
    and provide an offset (`2` in this example) and a limit (`6` in this example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then define a simple function to display output, and call each iterator
    in turn to see the results on a simple array produced by `range(''A'', ''Z'')`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a variation that produces every other letter by stacking a `FilterIterator`
    on top of an `ArrayIterator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s yet another variation that only produces `F H J L N P`, which demonstrates
    a `LimitIterator` that consumes a `FilterIterator`, which in turn consumes an
    `ArrayIterator`. The output of these three examples is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](graphics/B05314_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Returning to our example that produces a list of country names, suppose, instead
    of only the country name, we wished to iterate through a multi-dimensional array
    consisting of country names and ISO codes. The simple iterators mentioned so far
    would not be sufficient. Instead, we will use what are known as **recursive**
    iterators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, we need to define a method that uses the database connection
    class mentioned previously to pull all columns from the database. As before, we
    return an `ArrayIterator` instance populated with data from the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance one would be tempted to simply wrap a standard `ArrayIterator`
    instance inside `RecursiveArrayIterator`. Unfortunately, this approach only performs
    a **shallow** iteration, and doesn''t give us what we want: an iteration through
    all elements of the multi-dimensional array that is returned from a database query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although this returns an iteration where each item represents a row from the
    database query, in this case we wish to provide an iteration that will iterate
    through all columns of all rows returned by the query. In order to accomplish
    this, we'll need to roll out the big brass by way of a `RecursiveIteratorIterator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Monty Python fans will revel in the rich irony of this class name as it brings
    back fond memories of the *The Department of Redundancy Department*. Fittingly,
    this class causes our old friend the `RecursiveArrayIterator` class to work overtime
    and perform a **deep** iteration through all levels of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a practical example, you can develop a test script which implements filtering
    and pagination using iterators. For this illustration, you could call the `chap_03_developing_functions_filtered_and_paginated.php`
    test code file.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, following best practices, place the functions described above
    into an include file called `chap_03_developing_functions_iterators_library.php`.
    In the test script, be sure to include this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data source is a table called `iso_country_codes`, which contains ISO2,
    ISO3, and country names. The database connection could be in a `config/db.config.php`
    file. You could also include the `Application\Database\Connection` class discussed
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP 7 you can define constants as arrays. In this example, `ITEMS_PER_PAGE`
    was defined as an array, and used to generate an HTML `SELECT` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can process input parameters for the country name and the number
    of items per page. The current page number will start at `0` and can be incremented
    (next page) or decremented (previous page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you''re ready to fire up the database connection and run a simple `SELECT`
    query. This should be placed in a `try {} catch {}` block. You can then place
    the iterators to be stacked inside the `try {}` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready for the HTML. In this simple example we present a form that
    lets the user select the number of items per page and the country name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in order to test the recursive iteration of the country database lookup,
    you will need to include the iterator''s library file, as well as the `Application\Database\Connection`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, you should wrap your database query in a `try {} catch {}` block.
    You can then place the code to test the recursive iteration inside the `try {}`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what you can expect to see in terms of output from `RecursiveArrayIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the output after using `RecursiveIteratorIterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing your own iterator using generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding set of recipes we demonstrated the use of iterators provided
    in the PHP 7 SPL. But what if this set doesn't provide you with what is needed
    for a given project? One solution would be to develop a function that, instead
    of building an array that is then returned, uses the `yield` keyword to return
    values progressively by way of iteration. Such a function is referred to as a
    **generator**. In fact, in the background, the PHP engine will automatically convert
    your function into a special built-in class called `Generator`.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages to this approach. The main benefit is seen when
    you have a large container to traverse (that is, parsing a massive file). The
    traditional approach has been to build up an array, and then return that array.
    The problem with this is that you are effectively doubling the amount of memory
    required! Also, performance is affected in that results are only achieved once
    the final array has been returned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we build on the library of iterator-based functions, adding
    a generator of our own design. In this case we will duplicate the functionality
    described in the section above on iterators where we stacked an `ArrayIterator`,
    `FilterIterator`, and `LimitIterator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because we need access to the source array, the desired filter, page number,
    and number of items per page, we include the appropriate parameters into a single
    `filteredResultsGenerator()` function. We then calculate the offset based on the
    page number and limit (that is, number of items per page). Next, we loop through
    the array, apply the filter, and continue the loop if the offset has not yet been
    reached, or break if the limit has been reached:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice the primary difference between this function and others is the
    `yield` keyword. The effect of this keyword is to signal the PHP engine to produce
    a `Generator` instance and encapsulate the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the use of the `filteredResultsGenerator()` function we'll have
    you implement a web application that scans a web page and produces a filtered
    and paginated list of URLs hoovered from `HREF` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: First you need to add the code for the `filteredResultsGenerator()` function
    to the library file used in the previous recipe, then place the functions described
    previously into an include file, `chap_03_developing_functions_iterators_library.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define a test script, `chap_03_developing_functions_using_generator.php`,
    that includes both the function library as well as the file that defines `Application\Web\Hoover`,
    described in [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building
    a Foundation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You will then need to gather input from the user regarding which URL to scan,
    what string to use as a filter, how many items per page, and the current page
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **null coalesce** operator (`??`) is ideal for getting input from the Web.
    It does not generate any notices if not defined. If the parameter is not received
    from user input, you can supply a default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Web security should always be a priority consideration. In this example you
    can use `strip_tags()` and also force the data type to integer `(int)` as measures
    to sanitize user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are then in a position to define variables used in links for previous and
    next pages in the paginated list. Note that you could also apply a *sanity check*
    to make sure the next page doesn''t go off the end of the result set. For the
    sake of brevity, such a sanity check was not applied in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create an `Application\Web\Hoover` instance and grab `HREF`
    attributes from the target URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define HTML output that renders an input form and runs our generator
    through the `htmlList()` function described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
