- en: Atomic Operations - Working with the Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of optimization and thread-safety depends on one''s understanding of
    the underlying hardware: from aligned memory access on some architectures, to
    knowing which data sizes and thus C++ types can be safely addressed without performance
    penalties or the need for mutexes and similar.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looks at how one can make use of the characteristics of a number
    of processor architectures in order to, for example, prevent the use of mutexes
    where atomic operations would prevent any access conflicts regardless. Compiler-specific
    extensions such as those in GCC are also examined.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The types of atomic operations and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to target a specific processor architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler-based atomic operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic operations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Briefly put, an atomic operation is an operation which the processor can execute
    with a single instruction. This makes it atomic in the sense that nothing (barring
    interrupts) can interfere with it, or change any variables or data it may be using.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Applications include guaranteeing the order of instruction execution, lock-free
    implementations, and related uses where instruction execution order and memory
    access guarantees are important.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Before the 2011 C++ standard, the access to such atomic operations as provided
    by the processor was only provided by the compiler, using extensions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Visual C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Microsoft''s MSVC compiler there are the interlocked functions, as summarized
    from the MSDN documentation, starting with the adding features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAdd` | Performs an atomic addition operation on the specified
    `LONG` values. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddAcquire` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddRelease` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddNoFence` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers (covered in this chapter). |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: These are the 32-bit versions of this feature. There are also 64-bit versions
    of this and other methods in the API. Atomic functions tend to be focused on a
    specific variable type, but variations in this API have been left out of this
    summary to keep it brief.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the acquire and release variations. These provide the guarantee
    that the respective read or write access will be protected from memory reordering
    (on a hardware level) with any subsequent read or write operation. Finally, the
    no fence variation (also known as a memory barrier) performs the operation without
    the use of any memory barriers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Normally CPUs perform instructions (including memory reads and writes) out of
    order to optimize performance. Since this type of behavior is not always desirable,
    memory barriers were added to prevent this instruction reordering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the atomic `AND` feature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAnd` | Performs an atomic `AND` operation on the specified `LONG`
    values. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndAcquire` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndRelease` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndNoFence` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: 'The bit-test features are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndComplement` | Tests the specified bit of the specified
    `LONG` value and complements it. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndResetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndResetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    using memory release semantics. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with release memory ordering semantics. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndReset` | Tests the specified bit of the specified `LONG`
    value and sets it to `0`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSet` | Tests the specified bit of the specified `LONG`
    value and sets it to `1`. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: 'The comparison features can be listed as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchange` | Performs an atomic compare-and-exchange operation
    on the specified values. The function compares two specified 32-bit values and
    exchanges with another 32-bit value based on the outcome of the comparison. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeAcquire` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed with acquire memory ordering semantics. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeRelease` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The exchange is performed with release memory ordering semantics. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointer` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerAcquire` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerRelease` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified pointer
    values and exchanges with another pointer value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: 'The decrement features are:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrement` | Decrements (decreases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrementAcquire` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with acquire memory ordering semantics. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrementRelease` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with release memory ordering semantics. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedDecrementRelease` | 将指定的32位变量的值减1作为原子操作。操作使用释放内存排序语义执行。'
- en: '| `InterlockedDecrementNoFence` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedDecrementNoFence` | 将指定的32位变量的值减1作为原子操作。操作是原子执行的，但不使用内存屏障。'
- en: 'The exchange (swap) features are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 交换（交换）功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '**Interlocked function** | **描述**'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '---'
- en: '| `InterlockedExchange` | Sets a 32-bit variable to the specified value as
    an `atomic` operation. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchange` | 将32位变量设置为指定值作为原子操作。'
- en: '| `InterlockedExchangeAcquire` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed with acquire memory ordering
    semantics. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeAcquire` | 将32位变量设置为指定值作为原子操作。操作使用获取内存排序语义执行。'
- en: '| `InterlockedExchangeNoFence` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed atomically, but without using
    memory barriers. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeNoFence` | 将32位变量设置为指定值作为原子操作。操作是原子执行的，但不使用内存屏障。'
- en: '| `InterlockedExchangePointer` | Atomically exchanges a pair of pointer values.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangePointer` | 原子交换一对指针值。'
- en: '| `InterlockedExchangePointerAcquire` | Atomically exchanges a pair of pointer
    values. The operation is performed with acquire memory ordering semantics. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangePointerAcquire` | 原子交换一对指针值。操作使用获取内存排序语义执行。'
- en: '| `InterlockedExchangePointerNoFence` | Atomically exchanges a pair of addresses.
    The operation is performed atomically, but without using memory barriers. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangePointerNoFence` | 原子交换一对地址。操作是原子执行的，但不使用内存屏障。'
- en: '| `InterlockedExchangeSubtract` | Performs an atomic subtraction of two values.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeSubtract` | 执行两个值的原子减法。'
- en: '| `InterlockedExchangeAdd` | Performs an atomic addition of two 32-bit values.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeAdd` | 执行两个32位值的原子加法。'
- en: '| `InterlockedExchangeAddAcquire` | Performs an atomic addition of two 32-bit
    values. The operation is performed with acquire memory ordering semantics. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeAddAcquire` | 执行两个32位值的原子加法。操作使用获取内存排序语义执行。'
- en: '| `InterlockedExchangeAddRelease` | Performs an atomic addition of two 32-bit
    values. The operation is performed with release memory ordering semantics. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeAddRelease` | 执行两个32位值的原子加法。操作使用释放内存排序语义执行。'
- en: '| `InterlockedExchangeAddNoFence` | Performs an atomic addition of two 32-bit
    values. The operation is performed atomically, but without using memory barriers.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedExchangeAddNoFence` | 执行两个32位值的原子加法。操作是原子执行的，但不使用内存屏障。'
- en: 'The increment features are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 增量功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '**Interlocked function** | **描述**'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '---'
- en: '| `InterlockedIncrement` | Increments (increases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedIncrement` | 将指定的32位变量的值增加1作为原子操作。'
- en: '| `InterlockedIncrementAcquire` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using acquire memory ordering semantics. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedIncrementAcquire` | 将指定的32位变量的值增加1作为原子操作。操作使用获取内存排序语义执行。'
- en: '| `InterlockedIncrementRelease` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using release memory ordering semantics. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedIncrementRelease` | 将指定的32位变量的值增加1作为原子操作。操作使用释放内存排序语义执行。'
- en: '| `InterlockedIncrementNoFence` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedIncrementNoFence` | 将指定的32位变量的值增加1作为原子操作。操作是原子执行的，但不使用内存屏障。'
- en: 'The `OR` feature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR`功能：'
- en: '| **Interlocked function** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '**Interlocked function** | **描述**'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '---'
- en: '| `InterlockedOr` | Performs an atomic `OR` operation on the specified `LONG`
    values. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedOr` | 对指定的`LONG`值执行原子`OR`操作。'
- en: '| `InterlockedOrAcquire` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedOrAcquire` | 对指定的`LONG`值执行原子`OR`操作。操作使用获取内存排序语义执行。'
- en: '| `InterlockedOrRelease` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedOrRelease` | 对指定的`LONG`值执行原子`OR`操作。操作使用释放内存排序语义执行。'
- en: '| `InterlockedOrNoFence` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedOrNoFence` | 对指定的`LONG`值执行原子`OR`操作。操作是原子执行的，但不使用内存屏障。'
- en: 'Finally, the exclusive `OR` (`XOR`) features are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，独占`OR`（`XOR`）功能包括：
- en: '| **Interlocked function** | **Description** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '**Interlocked function** | **描述**'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '---'
- en: '| `InterlockedXor` | Performs an atomic `XOR` operation on the specified `LONG`
    values. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedXor` | 对指定的`LONG`值执行原子`XOR`操作。'
- en: '| `InterlockedXorAcquire` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`InterlockedXorAcquire` | 对指定的`LONG`值执行原子`XOR`操作。操作使用获取内存排序语义执行。'
- en: '| `InterlockedXorRelease` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedXorNoFence` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: GCC
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Visual C++, GCC also comes with a set of built-in atomic functions. These
    differ based on the underlying architecture that the GCC version and the standard
    library one uses. Since GCC is used on a considerably larger number of platforms
    and operating systems than VC++, this is definitely a big factor when considering
    portability.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: For example, not every built-in atomic function provided on the x86 platform
    will be available on ARM, partially due to architectural differences, including
    variations of the specific ARM architecture. For example, ARMv6, ARMv7, or the
    current ARMv8, along with the Thumb instruction set, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the C++11 standard, GCC used `__sync-prefixed` extensions for atomics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These operations fetch a value from memory and perform the specified operation
    on it, returning the value that was in memory. These all use a memory barrier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These operations are similar to the first set, except they return the new value
    after the specified operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These comparison operations will write the new value if the old value matches
    the provided value. The Boolean variation returns true if the new value has been
    written.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function creates a full memory barrier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method is actually an exchange operation unlike what the name suggests.
    It updates the pointer value and returns the previous value. This uses not a full
    memory barrier, but an acquire barrier, meaning that it does not release the barrier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function releases the barrier obtained by the previous method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'To adapt to the C++11 memory model, GCC added the `__atomic` built-in methods,
    which also changes the API considerably:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First are the generic load, store, and exchange functions. They are fairly self-explanatory.
    Load functions read a value in memory, store functions store a value in memory,
    and exchange functions swap the existing value with a new value. Compare and exchange
    functions make the swapping conditional.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions are essentially the same as in the old API, returning the result
    of the specific operation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And again, the same functions, updated for the new API. These return the original
    value (fetch before operation).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike the similarly named function in the old API, this function performs a
    real test and set operation instead of the exchange operation of the old API's
    function, which still requires one to release the memory barrier afterwards. The
    test is for some defined value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function clears the pointer address, setting it to `0`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A synchronization memory barrier (fence) between threads can be created using
    this function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function creates a memory barrier between a thread and signal handlers
    within that same thread.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The function checks whether objects of the specified size will always create
    lock-free atomic instructions for the current processor architecture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is essentially the same as the previous function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Memory order
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory barriers (fences) are not always used in the C++11 memory model for
    atomic operations. In the GCC built-in atomics API, this is reflected in the `memorder`
    parameter in its functions. The possible values for this map directly to the values
    in the C++11 atomics API:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`__ATOMIC_RELAXED`: Implies no inter-thread ordering constraints.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_CONSUME`: This is currently implemented using the stronger `__ATOMIC_ACQUIRE`
    memory order because of a deficiency in C++11''s semantics for `memory_order_consume`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_ACQUIRE`: Creates an inter-thread happens-before constraint from
    the release (or stronger) semantic store to this acquire load'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_RELEASE`: Creates an inter-thread happens-before constraint to acquire
    (or stronger) semantic loads that read from this release store'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_ACQ_REL`: Combines the effects of both `__ATOMIC_ACQUIRE` and `__ATOMIC_RELEASE`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_SEQ_CST`: Enforces total ordering with all other `__ATOMIC_SEQ_CST`
    operations.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list was copied from the GCC manual's chapter on atomics for GCC
    7.1\. Along with the comments in that chapter, it makes it quite clear that trade-offs
    were made when implementing both the C++11 atomics support within its memory model
    and in the compiler's implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Since atomics rely on the underlying hardware support, there will never be a
    single piece of code using atomics that will work across a wide variety of architectures.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Other compilers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more compiler toolchains for C/C++ than just VC++ and GCC, of
    course, including the Intel Compiler Collection (ICC) and other, usually proprietary
    tools.. These all have their own collection of built-in atomic functions. Fortunately,
    thanks to the C++11 standard, we now have a fully portable standard for atomics
    between compilers. Generally, this means that outside of very specific use cases
    (or maintenance of existing code), one would use the C++ standard over compiler-specific
    extensions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: C++11 atomics
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the native C++11 atomics features, all one has to do is include
    the `<atomic>` header. This makes available the `atomic` class, which uses templates
    to adapt itself to the required type, with a large number of predefined typedefs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '| **Typedef name** | **Full specialization** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_bool` | `std::atomic<bool>` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char` | `std::atomic<char>` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_schar` | `std::atomic<signed char>` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uchar` | `std::atomic<unsigned char>` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_short` | `std::atomic<short>` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ushort` | `std::atomic<unsigned short>` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int` | `std::atomic<int>` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint` | `std::atomic<unsigned int>` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_long` | `std::atomic<long>` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ulong` | `std::atomic<unsigned long>` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_llong` | `std::atomic<long long>` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ullong` | `std::atomic<unsigned long long>` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char16_t` | `std::atomic<char16_t>` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char32_t` | `std::atomic<char32_t>` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_wchar_t` | `std::atomic<wchar_t>` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int8_t` | `std::atomic<std::int8_t>` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint8_t` | `std::atomic<std::uint8_t>` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int16_t` | `std::atomic<std::int16_t>` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint16_t` | `std::atomic<std::uint16_t>` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int32_t` | `std::atomic<std::int32_t>` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint32_t` | `std::atomic<std::uint32_t>` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int64_t` | `std::atomic<std::int64_t>` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint64_t` | `std::atomic<std::uint64_t>` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least8_t` | `std::atomic<std::int_least8_t>` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least8_t` | `std::atomic<std::uint_least8_t>` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least16_t` | `std::atomic<std::int_least16_t>` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least16_t` | `std::atomic<std::uint_least16_t>` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least32_t` | `std::atomic<std::int_least32_t>` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least32_t` | `std::atomic<std::uint_least32_t>` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least64_t` | `std::atomic<std::int_least64_t>` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least64_t` | `std::atomic<std::uint_least64_t>` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast8_t` | `std::atomic<std::int_fast8_t>` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast8_t` | `std::atomic<std::uint_fast8_t>` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast16_t` | `std::atomic<std::int_fast16_t>` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast16_t` | `std::atomic<std::uint_fast16_t>` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast32_t` | `std::atomic<std::int_fast32_t>` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast32_t` | `std::atomic<std::uint_fast32_t>` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast64_t` | `std::atomic<std::int_fast64_t>` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast64_t` | `std::atomic<std::uint_fast64_t>` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_intptr_t` | `std::atomic<std::intptr_t>` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uintptr_t` | `std::atomic<std::uintptr_t>` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_size_t` | `std::atomic<std::size_t>` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ptrdiff_t` | `std::atomic<std::ptrdiff_t>` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_intmax_t` | `std::atomic<std::intmax_t>` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uintmax_t` | `std::atomic<std::uintmax_t>` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: 'This `atomic` class defines the following generic functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `operator=` | Assigns a value to an atomic object. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `is_lock_free` | Returns true if the atomic object is lock-free. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `store` | Replaces the value of the atomic object with a non-atomic argument,
    atomically. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `load` | Atomically obtains the value of the atomic object. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `operator T` | Loads a value from an atomic object. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `exchange` | Atomically replaces the value of the object with the new value
    and returns the old value. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `compare_exchange_weak``compare_exchange_strong` | Atomically compares the
    value of the object and swaps values if equal, or else returns the current value.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: With the C++17 update, the `is_always_lock_free` constant is added. This allows
    one to inquire whether the type is always lock-free.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the specialized `atomic` functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `fetch_add` | Atomically adds the argument to the value stored in the `atomic`
    object and returns the old value. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `fetch_sub` | Atomically subtracts the argument from the value stored in
    the `atomic` object and returns the old value. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `fetch_and` | Atomically performs bitwise `AND` between the argument and
    the value of the `atomic` object and returns the old value. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `fetch_or` | Atomically performs bitwise `OR` between the argument and the
    value of the `atomic` object and returns the old value. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `fetch_xor` | Atomically performs bitwise `XOR` between the argument and
    the value of the `atomic` object and returns the old value. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `operator++``operator++(int)``operator--``operator--(int)` | Increments or
    decrements the atomic value by one. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `operator+=``operator-=``operator&=``operator&#124;=``operator^=` | Adds,
    subtracts, or performs a bitwise `AND`, `OR`, `XOR` operation with the atomic
    value. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: Example
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic example using `fetch_add` would look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of this example code would be `5`. As we can see here, we can implement
    a basic counter this way with atomics, instead of having to use any mutexes or
    similar in order to provide thread synchronization.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Non-class functions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the `atomic` class, there are also a number of template-based
    functions defined in the `<atomic>` header which we can use in a manner more akin
    to the compiler''s built-in atomic functions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `atomic_is_lock_free` | Checks whether the atomic type''s operations are
    lock-free. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `atomic_storeatomic_store_explicit` | Atomically replaces the value of the
    `atomic` object with a non-atomic argument. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `atomic_load``atomic_load_explicit` | Atomically obtains the value stored
    in an `atomic` object. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `atomic_exchange``atomic_exchange_explicit` | Atomically replaces the value
    of the `atomic` object with a non-atomic argument and returns the old value of
    `atomic`. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `atomic_compare_exchange_weak``atomic_compare_exchange_weak_explicit``atomic_compare_exchange_strong``atomic_compare_exchange_strong_explicit`
    | Atomically compares the value of the `atomic` object with a non-atomic argument
    and performs an atomic exchange if equal or `atomic` load if not. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_add``atomic_fetch_add_explicit` | Adds a non-atomic value to
    an `atomic` object and obtains the previous value of `atomic`. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_sub``atomic_fetch_sub_explicit` | Subtracts a non-atomic value
    from an `atomic` object and obtains the previous value of `atomic`. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_and``atomic_fetch_and_explicit` | Replaces the `atomic` object
    with the result of logical `AND` with a non-atomic argument and obtains the previous
    value of the atomic. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_or``atomic_fetch_or_explicit` | Replaces the `atomic` object
    with the result of logical `OR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_xor``atomic_fetch_xor_explicit` | Replaces the `atomic` object
    with the result of logical `XOR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `atomic_flag_test_and_set``atomic_flag_test_and_set_explicit` | Atomically
    sets the flag to `true` and returns its previous value. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `atomic_flag_clear``atomic_flag_clear_explicit` | Atomically sets the value
    of the flag to `false`. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `atomic_init` | Non-atomic initialization of a default-constructed `atomic`
    object. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `kill_dependency` | Removes the specified object from the `std::memory_order_consume`
    dependency tree. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `atomic_thread_fence` | Generic memory order-dependent fence synchronization
    primitive. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `atomic_signal_fence` | Fence between a thread and a signal handler executed
    in the same thread. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: The difference between the regular and explicit functions is that the latter
    allows one to actually set the memory order to use. The former always uses `memory_order_seq_cst`
    as the memory order.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Example
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example using `atomic_fetch_sub`, an indexed container is processed
    by multiple threads concurrently, without the use of locks:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example code uses a vector filled with integers of size *N* as the data
    source, filling it with 1s. The atomic counter object is set to the size of the
    data vector. After this, 10 threads are created (initialized in place using the
    vector's `emplace_back` C++11 feature), which run the `reader` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In that function, we read the current value of the index counter from memory
    using the `atomic_fetch_sub_explicit` function, which allows us to use the `memory_order_relaxed`
    memory order. This function also subtracts the value we pass from this old value,
    counting the index down by 1.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: So long as the index number we obtain this way is higher or equal to zero, the
    function continues, otherwise it will quit. Once all the threads have finished,
    the application exits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Atomic flag
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::atomic_flag` is an atomic Boolean type. Unlike the other specializations
    of the `atomic` class, it is guaranteed to be lock-free. It does not however,
    offer any load or store operations.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it offers the assignment operator, and functions to either clear, or
    `test_and_set` the flag. The former thereby sets the flag to `false`, and the
    latter will test and set it to `true`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Memory order
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This property is defined as an enumeration in the `<atomic>` header:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the GCC section, we already touched briefly on the topic of memory order.
    As mentioned there, this is one of the parts where the characteristics of the
    underlying hardware architecture surface somewhat.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, memory order determines how non-atomic memory accesses are to be
    ordered (memory access order) around an atomic operation. What this affects is
    how different threads will see the data in memory as they''re executing their
    instructions:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| **Enum** | **Description** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_relaxed` | Relaxed operation: there are no synchronization
    or ordering constraints imposed on other reads or writes, only this operation''s
    atomicity is guaranteed. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_consume` | A load operation with this memory order performs
    a *consume operation* on the affected memory location: no reads or writes in the
    current thread dependent on the value currently loaded can be reordered before
    this load. Writes to data-dependent variables in other threads that release the
    same atomic variable are visible in the current thread. On most platforms, this
    affects compiler optimizations only. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_acquire` | A load operation with this memory order performs
    the *acquire operation* on the affected memory location: no reads or writes in
    the current thread can be reordered before this load. All writes in other threads
    that release the same atomic variable are visible in the current thread. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_release` | A store operation with this memory order performs
    the *release operation*: no reads or writes in the current thread can be reordered
    after this store. All writes in the current thread are visible in other threads
    that acquire the same atomic variable and writes that carry a dependency into
    the atomic variable become visible in other threads that consume the same atomic.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_acq_rel` | A read-modify-write operation with this memory order
    is both an *acquire operation* and a *release operation*. No memory reads or writes
    in the current thread can be reordered before or after this store. All writes
    in other threads that release the same atomic variable are visible before the
    modification and the modification is visible in other threads that acquire the
    same atomic variable. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_seq_cst` | Any operation with this memory order is both an
    *acquire operation* and a *release operation*, plus a single total order exists
    in which all threads observe all modifications in the same order. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: Relaxed ordering
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With relaxed memory ordering, no order is enforced among concurrent memory accesses.
    All that this type of ordering guarantees is atomicity and modification order.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: A typical use for this type of ordering is for counters, whether incrementing--or
    decrementing, as we saw earlier in the example code in the previous section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Release-acquire ordering
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_acquire`, all
    memory writes (non-atomic and relaxed atomic) that happened *before* the atomic
    store from the point of view of thread A, become *visible side-effects* in thread
    B. That is, once the atomic load has been completed, thread B is guaranteed to
    see everything thread A wrote to memory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: This type of operation is automatic on so-called strongly ordered architectures,
    including x86, SPARC, and POWER. Weakly-ordered architectures, such as ARM, PowerPC,
    and Itanium, will require the use of memory barriers here.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Typical applications of this type of memory ordering include mutual exclusion
    mechanisms, such as a mutex or atomic spinlock.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Release-consume ordering
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_consume`, all
    memory writes (non-atomic and relaxed atomic) that are *dependency-ordered* before
    the atomic store from the point of view of thread A, become *visible side-effects*
    within those operations in thread B into which the load operation *carries dependency.*
    That is, once the atomic load has been completed, those operators and functions
    in thread B that use the value obtained from the load are guaranteed to see what
    thread A wrote to memory.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: This type of ordering is automatic on virtually all architectures. The only
    major exception is the (obsolete) Alpha architecture. A typical use case for this
    type of ordering would be read access to data that rarely gets changed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: As of C++17, this type of memory ordering is being revised, and the use of `memory_order_consume`
    is temporarily discouraged.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Sequentially-consistent ordering
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic operations tagged `memory_order_seq_cst` not only order memory the same
    way as release/acquire ordering (everything that happened before a store in one
    thread becomes a *visible side effect* in the thread that did a load), but also
    establishes a *single total modification order* of all atomic operations that
    are so tagged.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This type of ordering may be necessary for situations where all consumers must
    observe the changes being made by other threads in exactly the same order. It
    requires full memory barriers as a consequence on multi-core or multi-CPU systems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: As a result of such a complex setup, this type of ordering is significantly
    slower than the other types. It also requires that every single atomic operation
    has to be tagged with this type of memory ordering, or the sequential ordering
    will be lost.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Volatile keyword
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `volatile` keyword is probably quite familiar to anyone who has ever written
    complex multithreaded code. Its basic use is to tell the compiler that the relevant
    variable should always be loaded from memory, never making assumptions about its
    value. It also ensures that the compiler will not make any aggressive optimizations
    to the variable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: For multithreaded applications, it is generally ineffective, however, its use
    is discouraged. The main issue with the volatile specification is that it does
    not define a multithreaded memory model, meaning that the result of this keyword
    may not be deterministic across platforms, CPUs and even toolchains.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Within the area of atomics, this keyword is not required, and in fact is unlikely
    to be helpful. To guarantee that one obtains the current version of a variable
    that is shared between multiple CPU cores and their caches, one would have to
    use an operation like `atomic_compare_exchange_strong`, `atomic_fetch_add`, or
    `atomic_exchange` to let the hardware fetch the correct and current value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: For multithreaded code, it is recommended to not use the volatile keyword and
    use atomics instead, to guarantee proper behavior.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at atomic operations and exactly how they are integrated
    into compilers to allow one's code to work as closely with the underlying hardware
    as possible. The reader will now be familiar with the types of atomic operations,
    the use of a memory barrier (fencing), as well as the various types of memory
    ordering and their implications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The reader is now capable of using atomic operations in their own code to accomplish
    lock-free designs and to make proper use of the C++11 memory model.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take everything we have learned so far and move
    away from CPUs, instead taking a look at GPGPU, the general-purpose processing
    of data on video cards (GPUs).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
