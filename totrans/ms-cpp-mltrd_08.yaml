- en: Atomic Operations - Working with the Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of optimization and thread-safety depends on one''s understanding of
    the underlying hardware: from aligned memory access on some architectures, to
    knowing which data sizes and thus C++ types can be safely addressed without performance
    penalties or the need for mutexes and similar.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looks at how one can make use of the characteristics of a number
    of processor architectures in order to, for example, prevent the use of mutexes
    where atomic operations would prevent any access conflicts regardless. Compiler-specific
    extensions such as those in GCC are also examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: The types of atomic operations and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to target a specific processor architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler-based atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Briefly put, an atomic operation is an operation which the processor can execute
    with a single instruction. This makes it atomic in the sense that nothing (barring
    interrupts) can interfere with it, or change any variables or data it may be using.
  prefs: []
  type: TYPE_NORMAL
- en: Applications include guaranteeing the order of instruction execution, lock-free
    implementations, and related uses where instruction execution order and memory
    access guarantees are important.
  prefs: []
  type: TYPE_NORMAL
- en: Before the 2011 C++ standard, the access to such atomic operations as provided
    by the processor was only provided by the compiler, using extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Visual C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Microsoft''s MSVC compiler there are the interlocked functions, as summarized
    from the MSDN documentation, starting with the adding features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAdd` | Performs an atomic addition operation on the specified
    `LONG` values. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddAcquire` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddRelease` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAddNoFence` | Performs an atomic addition operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers (covered in this chapter). |'
  prefs: []
  type: TYPE_TB
- en: These are the 32-bit versions of this feature. There are also 64-bit versions
    of this and other methods in the API. Atomic functions tend to be focused on a
    specific variable type, but variations in this API have been left out of this
    summary to keep it brief.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the acquire and release variations. These provide the guarantee
    that the respective read or write access will be protected from memory reordering
    (on a hardware level) with any subsequent read or write operation. Finally, the
    no fence variation (also known as a memory barrier) performs the operation without
    the use of any memory barriers.
  prefs: []
  type: TYPE_NORMAL
- en: Normally CPUs perform instructions (including memory reads and writes) out of
    order to optimize performance. Since this type of behavior is not always desirable,
    memory barriers were added to prevent this instruction reordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the atomic `AND` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAnd` | Performs an atomic `AND` operation on the specified `LONG`
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndAcquire` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndRelease` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedAndNoFence` | Performs an atomic `AND` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  prefs: []
  type: TYPE_TB
- en: 'The bit-test features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndComplement` | Tests the specified bit of the specified
    `LONG` value and complements it. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndResetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndResetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `0`. The operation is `atomic`, and it is performed
    using memory release semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSetAcquire` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSetRelease` | Tests the specified bit of the specified
    `LONG` value and sets it to `1`. The operation is `atomic`, and it is performed
    with release memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndReset` | Tests the specified bit of the specified `LONG`
    value and sets it to `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedBitTestAndSet` | Tests the specified bit of the specified `LONG`
    value and sets it to `1`. |'
  prefs: []
  type: TYPE_TB
- en: 'The comparison features can be listed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchange` | Performs an atomic compare-and-exchange operation
    on the specified values. The function compares two specified 32-bit values and
    exchanges with another 32-bit value based on the outcome of the comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeAcquire` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeRelease` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The exchange is performed with release memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangeNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified 32-bit
    values and exchanges with another 32-bit value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointer` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerAcquire` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with acquire memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerRelease` | Performs an atomic compare-and-exchange
    operation on the specified pointer values. The function compares two specified
    pointer values and exchanges with another pointer value based on the outcome of
    the comparison. The operation is performed with release memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedCompareExchangePointerNoFence` | Performs an atomic compare-and-exchange
    operation on the specified values. The function compares two specified pointer
    values and exchanges with another pointer value based on the outcome of the comparison.
    The operation is performed atomically, but without using memory barriers |'
  prefs: []
  type: TYPE_TB
- en: 'The decrement features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrement` | Decrements (decreases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrementAcquire` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrementRelease` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    with release memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedDecrementNoFence` | Decrements (decreases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  prefs: []
  type: TYPE_TB
- en: 'The exchange (swap) features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchange` | Sets a 32-bit variable to the specified value as
    an `atomic` operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeAcquire` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed with acquire memory ordering
    semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeNoFence` | Sets a 32-bit variable to the specified value
    as an `atomic` operation. The operation is performed atomically, but without using
    memory barriers. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangePointer` | Atomically exchanges a pair of pointer values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangePointerAcquire` | Atomically exchanges a pair of pointer
    values. The operation is performed with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangePointerNoFence` | Atomically exchanges a pair of addresses.
    The operation is performed atomically, but without using memory barriers. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeSubtract` | Performs an atomic subtraction of two values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeAdd` | Performs an atomic addition of two 32-bit values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeAddAcquire` | Performs an atomic addition of two 32-bit
    values. The operation is performed with acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeAddRelease` | Performs an atomic addition of two 32-bit
    values. The operation is performed with release memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedExchangeAddNoFence` | Performs an atomic addition of two 32-bit
    values. The operation is performed atomically, but without using memory barriers.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The increment features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedIncrement` | Increments (increases by one) the value of the specified
    32-bit variable as an `atomic` operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedIncrementAcquire` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using acquire memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedIncrementRelease` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    using release memory ordering semantics. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedIncrementNoFence` | Increments (increases by one) the value of
    the specified 32-bit variable as an `atomic` operation. The operation is performed
    atomically, but without using memory barriers. |'
  prefs: []
  type: TYPE_TB
- en: 'The `OR` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedOr` | Performs an atomic `OR` operation on the specified `LONG`
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedOrAcquire` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedOrRelease` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedOrNoFence` | Performs an atomic `OR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, the exclusive `OR` (`XOR`) features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interlocked function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedXor` | Performs an atomic `XOR` operation on the specified `LONG`
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedXorAcquire` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with acquire memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedXorRelease` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed with release memory ordering semantics.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `InterlockedXorNoFence` | Performs an atomic `XOR` operation on the specified
    `LONG` values. The operation is performed atomically, but without using memory
    barriers. |'
  prefs: []
  type: TYPE_TB
- en: GCC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Visual C++, GCC also comes with a set of built-in atomic functions. These
    differ based on the underlying architecture that the GCC version and the standard
    library one uses. Since GCC is used on a considerably larger number of platforms
    and operating systems than VC++, this is definitely a big factor when considering
    portability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, not every built-in atomic function provided on the x86 platform
    will be available on ARM, partially due to architectural differences, including
    variations of the specific ARM architecture. For example, ARMv6, ARMv7, or the
    current ARMv8, along with the Thumb instruction set, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the C++11 standard, GCC used `__sync-prefixed` extensions for atomics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These operations fetch a value from memory and perform the specified operation
    on it, returning the value that was in memory. These all use a memory barrier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These operations are similar to the first set, except they return the new value
    after the specified operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These comparison operations will write the new value if the old value matches
    the provided value. The Boolean variation returns true if the new value has been
    written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a full memory barrier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method is actually an exchange operation unlike what the name suggests.
    It updates the pointer value and returns the previous value. This uses not a full
    memory barrier, but an acquire barrier, meaning that it does not release the barrier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function releases the barrier obtained by the previous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To adapt to the C++11 memory model, GCC added the `__atomic` built-in methods,
    which also changes the API considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First are the generic load, store, and exchange functions. They are fairly self-explanatory.
    Load functions read a value in memory, store functions store a value in memory,
    and exchange functions swap the existing value with a new value. Compare and exchange
    functions make the swapping conditional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These functions are essentially the same as in the old API, returning the result
    of the specific operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And again, the same functions, updated for the new API. These return the original
    value (fetch before operation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the similarly named function in the old API, this function performs a
    real test and set operation instead of the exchange operation of the old API's
    function, which still requires one to release the memory barrier afterwards. The
    test is for some defined value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function clears the pointer address, setting it to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A synchronization memory barrier (fence) between threads can be created using
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a memory barrier between a thread and signal handlers
    within that same thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The function checks whether objects of the specified size will always create
    lock-free atomic instructions for the current processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is essentially the same as the previous function.
  prefs: []
  type: TYPE_NORMAL
- en: Memory order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory barriers (fences) are not always used in the C++11 memory model for
    atomic operations. In the GCC built-in atomics API, this is reflected in the `memorder`
    parameter in its functions. The possible values for this map directly to the values
    in the C++11 atomics API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__ATOMIC_RELAXED`: Implies no inter-thread ordering constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_CONSUME`: This is currently implemented using the stronger `__ATOMIC_ACQUIRE`
    memory order because of a deficiency in C++11''s semantics for `memory_order_consume`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_ACQUIRE`: Creates an inter-thread happens-before constraint from
    the release (or stronger) semantic store to this acquire load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_RELEASE`: Creates an inter-thread happens-before constraint to acquire
    (or stronger) semantic loads that read from this release store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_ACQ_REL`: Combines the effects of both `__ATOMIC_ACQUIRE` and `__ATOMIC_RELEASE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ATOMIC_SEQ_CST`: Enforces total ordering with all other `__ATOMIC_SEQ_CST`
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list was copied from the GCC manual's chapter on atomics for GCC
    7.1\. Along with the comments in that chapter, it makes it quite clear that trade-offs
    were made when implementing both the C++11 atomics support within its memory model
    and in the compiler's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Since atomics rely on the underlying hardware support, there will never be a
    single piece of code using atomics that will work across a wide variety of architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Other compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more compiler toolchains for C/C++ than just VC++ and GCC, of
    course, including the Intel Compiler Collection (ICC) and other, usually proprietary
    tools.. These all have their own collection of built-in atomic functions. Fortunately,
    thanks to the C++11 standard, we now have a fully portable standard for atomics
    between compilers. Generally, this means that outside of very specific use cases
    (or maintenance of existing code), one would use the C++ standard over compiler-specific
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 atomics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the native C++11 atomics features, all one has to do is include
    the `<atomic>` header. This makes available the `atomic` class, which uses templates
    to adapt itself to the required type, with a large number of predefined typedefs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Typedef name** | **Full specialization** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_bool` | `std::atomic<bool>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char` | `std::atomic<char>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_schar` | `std::atomic<signed char>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uchar` | `std::atomic<unsigned char>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_short` | `std::atomic<short>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ushort` | `std::atomic<unsigned short>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int` | `std::atomic<int>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint` | `std::atomic<unsigned int>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_long` | `std::atomic<long>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ulong` | `std::atomic<unsigned long>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_llong` | `std::atomic<long long>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ullong` | `std::atomic<unsigned long long>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char16_t` | `std::atomic<char16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_char32_t` | `std::atomic<char32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_wchar_t` | `std::atomic<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int8_t` | `std::atomic<std::int8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint8_t` | `std::atomic<std::uint8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int16_t` | `std::atomic<std::int16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint16_t` | `std::atomic<std::uint16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int32_t` | `std::atomic<std::int32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint32_t` | `std::atomic<std::uint32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int64_t` | `std::atomic<std::int64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint64_t` | `std::atomic<std::uint64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least8_t` | `std::atomic<std::int_least8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least8_t` | `std::atomic<std::uint_least8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least16_t` | `std::atomic<std::int_least16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least16_t` | `std::atomic<std::uint_least16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least32_t` | `std::atomic<std::int_least32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least32_t` | `std::atomic<std::uint_least32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_least64_t` | `std::atomic<std::int_least64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_least64_t` | `std::atomic<std::uint_least64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast8_t` | `std::atomic<std::int_fast8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast8_t` | `std::atomic<std::uint_fast8_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast16_t` | `std::atomic<std::int_fast16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast16_t` | `std::atomic<std::uint_fast16_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast32_t` | `std::atomic<std::int_fast32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast32_t` | `std::atomic<std::uint_fast32_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_int_fast64_t` | `std::atomic<std::int_fast64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uint_fast64_t` | `std::atomic<std::uint_fast64_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_intptr_t` | `std::atomic<std::intptr_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uintptr_t` | `std::atomic<std::uintptr_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_size_t` | `std::atomic<std::size_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_ptrdiff_t` | `std::atomic<std::ptrdiff_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_intmax_t` | `std::atomic<std::intmax_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::atomic_uintmax_t` | `std::atomic<std::uintmax_t>` |'
  prefs: []
  type: TYPE_TB
- en: 'This `atomic` class defines the following generic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `operator=` | Assigns a value to an atomic object. |'
  prefs: []
  type: TYPE_TB
- en: '| `is_lock_free` | Returns true if the atomic object is lock-free. |'
  prefs: []
  type: TYPE_TB
- en: '| `store` | Replaces the value of the atomic object with a non-atomic argument,
    atomically. |'
  prefs: []
  type: TYPE_TB
- en: '| `load` | Atomically obtains the value of the atomic object. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator T` | Loads a value from an atomic object. |'
  prefs: []
  type: TYPE_TB
- en: '| `exchange` | Atomically replaces the value of the object with the new value
    and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `compare_exchange_weak``compare_exchange_strong` | Atomically compares the
    value of the object and swaps values if equal, or else returns the current value.
    |'
  prefs: []
  type: TYPE_TB
- en: With the C++17 update, the `is_always_lock_free` constant is added. This allows
    one to inquire whether the type is always lock-free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the specialized `atomic` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_add` | Atomically adds the argument to the value stored in the `atomic`
    object and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_sub` | Atomically subtracts the argument from the value stored in
    the `atomic` object and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_and` | Atomically performs bitwise `AND` between the argument and
    the value of the `atomic` object and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_or` | Atomically performs bitwise `OR` between the argument and the
    value of the `atomic` object and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_xor` | Atomically performs bitwise `XOR` between the argument and
    the value of the `atomic` object and returns the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator++``operator++(int)``operator--``operator--(int)` | Increments or
    decrements the atomic value by one. |'
  prefs: []
  type: TYPE_TB
- en: '| `operator+=``operator-=``operator&=``operator&#124;=``operator^=` | Adds,
    subtracts, or performs a bitwise `AND`, `OR`, `XOR` operation with the atomic
    value. |'
  prefs: []
  type: TYPE_TB
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic example using `fetch_add` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result of this example code would be `5`. As we can see here, we can implement
    a basic counter this way with atomics, instead of having to use any mutexes or
    similar in order to provide thread synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Non-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the `atomic` class, there are also a number of template-based
    functions defined in the `<atomic>` header which we can use in a manner more akin
    to the compiler''s built-in atomic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_is_lock_free` | Checks whether the atomic type''s operations are
    lock-free. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_storeatomic_store_explicit` | Atomically replaces the value of the
    `atomic` object with a non-atomic argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_load``atomic_load_explicit` | Atomically obtains the value stored
    in an `atomic` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_exchange``atomic_exchange_explicit` | Atomically replaces the value
    of the `atomic` object with a non-atomic argument and returns the old value of
    `atomic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_compare_exchange_weak``atomic_compare_exchange_weak_explicit``atomic_compare_exchange_strong``atomic_compare_exchange_strong_explicit`
    | Atomically compares the value of the `atomic` object with a non-atomic argument
    and performs an atomic exchange if equal or `atomic` load if not. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_add``atomic_fetch_add_explicit` | Adds a non-atomic value to
    an `atomic` object and obtains the previous value of `atomic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_sub``atomic_fetch_sub_explicit` | Subtracts a non-atomic value
    from an `atomic` object and obtains the previous value of `atomic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_and``atomic_fetch_and_explicit` | Replaces the `atomic` object
    with the result of logical `AND` with a non-atomic argument and obtains the previous
    value of the atomic. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_or``atomic_fetch_or_explicit` | Replaces the `atomic` object
    with the result of logical `OR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_fetch_xor``atomic_fetch_xor_explicit` | Replaces the `atomic` object
    with the result of logical `XOR` with a non-atomic argument and obtains the previous
    value of `atomic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_flag_test_and_set``atomic_flag_test_and_set_explicit` | Atomically
    sets the flag to `true` and returns its previous value. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_flag_clear``atomic_flag_clear_explicit` | Atomically sets the value
    of the flag to `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_init` | Non-atomic initialization of a default-constructed `atomic`
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `kill_dependency` | Removes the specified object from the `std::memory_order_consume`
    dependency tree. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_thread_fence` | Generic memory order-dependent fence synchronization
    primitive. |'
  prefs: []
  type: TYPE_TB
- en: '| `atomic_signal_fence` | Fence between a thread and a signal handler executed
    in the same thread. |'
  prefs: []
  type: TYPE_TB
- en: The difference between the regular and explicit functions is that the latter
    allows one to actually set the memory order to use. The former always uses `memory_order_seq_cst`
    as the memory order.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example using `atomic_fetch_sub`, an indexed container is processed
    by multiple threads concurrently, without the use of locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example code uses a vector filled with integers of size *N* as the data
    source, filling it with 1s. The atomic counter object is set to the size of the
    data vector. After this, 10 threads are created (initialized in place using the
    vector's `emplace_back` C++11 feature), which run the `reader` function.
  prefs: []
  type: TYPE_NORMAL
- en: In that function, we read the current value of the index counter from memory
    using the `atomic_fetch_sub_explicit` function, which allows us to use the `memory_order_relaxed`
    memory order. This function also subtracts the value we pass from this old value,
    counting the index down by 1.
  prefs: []
  type: TYPE_NORMAL
- en: So long as the index number we obtain this way is higher or equal to zero, the
    function continues, otherwise it will quit. Once all the threads have finished,
    the application exits.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic flag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::atomic_flag` is an atomic Boolean type. Unlike the other specializations
    of the `atomic` class, it is guaranteed to be lock-free. It does not however,
    offer any load or store operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it offers the assignment operator, and functions to either clear, or
    `test_and_set` the flag. The former thereby sets the flag to `false`, and the
    latter will test and set it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Memory order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This property is defined as an enumeration in the `<atomic>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the GCC section, we already touched briefly on the topic of memory order.
    As mentioned there, this is one of the parts where the characteristics of the
    underlying hardware architecture surface somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, memory order determines how non-atomic memory accesses are to be
    ordered (memory access order) around an atomic operation. What this affects is
    how different threads will see the data in memory as they''re executing their
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Enum** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_relaxed` | Relaxed operation: there are no synchronization
    or ordering constraints imposed on other reads or writes, only this operation''s
    atomicity is guaranteed. |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_consume` | A load operation with this memory order performs
    a *consume operation* on the affected memory location: no reads or writes in the
    current thread dependent on the value currently loaded can be reordered before
    this load. Writes to data-dependent variables in other threads that release the
    same atomic variable are visible in the current thread. On most platforms, this
    affects compiler optimizations only. |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_acquire` | A load operation with this memory order performs
    the *acquire operation* on the affected memory location: no reads or writes in
    the current thread can be reordered before this load. All writes in other threads
    that release the same atomic variable are visible in the current thread. |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_release` | A store operation with this memory order performs
    the *release operation*: no reads or writes in the current thread can be reordered
    after this store. All writes in the current thread are visible in other threads
    that acquire the same atomic variable and writes that carry a dependency into
    the atomic variable become visible in other threads that consume the same atomic.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_acq_rel` | A read-modify-write operation with this memory order
    is both an *acquire operation* and a *release operation*. No memory reads or writes
    in the current thread can be reordered before or after this store. All writes
    in other threads that release the same atomic variable are visible before the
    modification and the modification is visible in other threads that acquire the
    same atomic variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `memory_order_seq_cst` | Any operation with this memory order is both an
    *acquire operation* and a *release operation*, plus a single total order exists
    in which all threads observe all modifications in the same order. |'
  prefs: []
  type: TYPE_TB
- en: Relaxed ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With relaxed memory ordering, no order is enforced among concurrent memory accesses.
    All that this type of ordering guarantees is atomicity and modification order.
  prefs: []
  type: TYPE_NORMAL
- en: A typical use for this type of ordering is for counters, whether incrementing--or
    decrementing, as we saw earlier in the example code in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Release-acquire ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_acquire`, all
    memory writes (non-atomic and relaxed atomic) that happened *before* the atomic
    store from the point of view of thread A, become *visible side-effects* in thread
    B. That is, once the atomic load has been completed, thread B is guaranteed to
    see everything thread A wrote to memory.
  prefs: []
  type: TYPE_NORMAL
- en: This type of operation is automatic on so-called strongly ordered architectures,
    including x86, SPARC, and POWER. Weakly-ordered architectures, such as ARM, PowerPC,
    and Itanium, will require the use of memory barriers here.
  prefs: []
  type: TYPE_NORMAL
- en: Typical applications of this type of memory ordering include mutual exclusion
    mechanisms, such as a mutex or atomic spinlock.
  prefs: []
  type: TYPE_NORMAL
- en: Release-consume ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an atomic store in thread A is tagged `memory_order_release` and an atomic
    load in thread B from the same variable is tagged `memory_order_consume`, all
    memory writes (non-atomic and relaxed atomic) that are *dependency-ordered* before
    the atomic store from the point of view of thread A, become *visible side-effects*
    within those operations in thread B into which the load operation *carries dependency.*
    That is, once the atomic load has been completed, those operators and functions
    in thread B that use the value obtained from the load are guaranteed to see what
    thread A wrote to memory.
  prefs: []
  type: TYPE_NORMAL
- en: This type of ordering is automatic on virtually all architectures. The only
    major exception is the (obsolete) Alpha architecture. A typical use case for this
    type of ordering would be read access to data that rarely gets changed.
  prefs: []
  type: TYPE_NORMAL
- en: As of C++17, this type of memory ordering is being revised, and the use of `memory_order_consume`
    is temporarily discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Sequentially-consistent ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic operations tagged `memory_order_seq_cst` not only order memory the same
    way as release/acquire ordering (everything that happened before a store in one
    thread becomes a *visible side effect* in the thread that did a load), but also
    establishes a *single total modification order* of all atomic operations that
    are so tagged.
  prefs: []
  type: TYPE_NORMAL
- en: This type of ordering may be necessary for situations where all consumers must
    observe the changes being made by other threads in exactly the same order. It
    requires full memory barriers as a consequence on multi-core or multi-CPU systems.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of such a complex setup, this type of ordering is significantly
    slower than the other types. It also requires that every single atomic operation
    has to be tagged with this type of memory ordering, or the sequential ordering
    will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Volatile keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `volatile` keyword is probably quite familiar to anyone who has ever written
    complex multithreaded code. Its basic use is to tell the compiler that the relevant
    variable should always be loaded from memory, never making assumptions about its
    value. It also ensures that the compiler will not make any aggressive optimizations
    to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: For multithreaded applications, it is generally ineffective, however, its use
    is discouraged. The main issue with the volatile specification is that it does
    not define a multithreaded memory model, meaning that the result of this keyword
    may not be deterministic across platforms, CPUs and even toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: Within the area of atomics, this keyword is not required, and in fact is unlikely
    to be helpful. To guarantee that one obtains the current version of a variable
    that is shared between multiple CPU cores and their caches, one would have to
    use an operation like `atomic_compare_exchange_strong`, `atomic_fetch_add`, or
    `atomic_exchange` to let the hardware fetch the correct and current value.
  prefs: []
  type: TYPE_NORMAL
- en: For multithreaded code, it is recommended to not use the volatile keyword and
    use atomics instead, to guarantee proper behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at atomic operations and exactly how they are integrated
    into compilers to allow one's code to work as closely with the underlying hardware
    as possible. The reader will now be familiar with the types of atomic operations,
    the use of a memory barrier (fencing), as well as the various types of memory
    ordering and their implications.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is now capable of using atomic operations in their own code to accomplish
    lock-free designs and to make proper use of the C++11 memory model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take everything we have learned so far and move
    away from CPUs, instead taking a look at GPGPU, the general-purpose processing
    of data on video cards (GPUs).
  prefs: []
  type: TYPE_NORMAL
