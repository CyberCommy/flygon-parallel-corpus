- en: Network Validation with Batfish and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all previous chapters of this book, we have used multiple recipes to outline
    how to perform network validation using Ansible—we have done this by utilizing
    the different modules available within Ansible. In all of these cases, we performed
    network validation after pushing the configuration into the network devices. We
    then collected the network state and validated that it was aligned with our intended
    state. However, we may want to validate the network state *prior* to pushing the
    configuration on the devices. As well as this, it might be necessary to validate
    that the intended network state is as desired without even touching our network.
    But how do we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Batfish is an open source project that targets this use case. Its main aim
    is to provide an offline network validation tool to validate multiple aspects
    of the network configuration. Batfish can provide a validation and correctness
    guarantee for security, compliance, and traffic forwarding for the network. It
    uses the device configuration from our network devices to build a neutral data
    model and forwarding tree for our network, which we can then use to validate the
    network state and validate the correct traffic forwarding within our network.
    The following diagram outlines the high-level architecture of Batfish, and how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2bc47aa-c25f-432b-8b20-04af58125533.png)'
  prefs: []
  type: TYPE_IMG
- en: Batfish uses a client/server model. With this, we run a Batfish server instance
    (written in Java), and we communicate with the server using a client-side **software
    development kit** (**SDK**) called **Pybatfish** (written in Python). We then
    initialize a snapshot of our network using our network configuration files, and,
    based on this network snapshot, the Batfish server computes a data model for our
    network. Using the client, we can start to ask questions to validate our network
    using this vendor-neutral data model.
  prefs: []
  type: TYPE_NORMAL
- en: The Batfish team has developed multiple Ansible modules that wrap around the
    **Pybatfish** client library to retrieve the data model generated by the Batfish
    server. The modules allow us to perform different queries against this network
    model to validate our network state. The diagram that appears next outlines the
    interaction between Ansible, Pybatfish, and the Batfish server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will outline how to install Batfish and how to integrate
    it with Ansible in order to start using it to validate the network state, prior
    to pushing the configuration to our devices. This combination is very powerful,
    and can easily be extended to build complete **continuous integration/continuous
    deployment** (**CI/CD**) pipelines for network configuration changes. Batfish
    can be an integral part to provide pre-validation prior to pushing the configuration
    to network devices in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the following network topology, which we used in *[Chapter
    4](c37fb79b-fda8-46cb-8ff2-742a3a4e6b97.xhtml), Building Data Center Networks
    with Arista and Ansible, *to outline how we can validate this sample leaf-spine
    network topology using Ansible and Batfish:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](assets/892d5c1c-8d25-43c5-be84-50ed78c1311b.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main recipes covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Batfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Batfish with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the network configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a network snapshot for Batfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the network snapshot with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting network facts from Batfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating traffic forwarding with Batfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating **access control lists** (**ACLs**) with Batfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code described in this chapter can be found at this URL: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch10_batfish](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch10_batfish).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is based on the following software releases:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CentOS 7.7 machine hosting a Batfish container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista **virtualized extensible operating system** (**vEOS**) running EOS 4.20.1F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3bhke1A](https://bit.ly/3bhke1A)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Batfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to install the Batfish container (the server
    component in the Batfish architecture) and start it, in order to start to interact
    with it from Ansible. This is a mandatory foundation step in order to start validating
    our network using Batfish.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As outlined in this chapter introduction, we will install Batfish on a separate
    Linux machine. This machine needs to have internet connectivity in order to be
    able to install Docker and pull down the Batfish container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install Docker on the CentOS Linux machine, as demonstrated at the following
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Docker is installed and operational, download the Docker container, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Batfish container, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batfish provides multiple options for installing and running the Batfish server.
    However, the simplest and most recommended method is to run a Docker container
    that houses the Batfish server. In order to run this Docker container, we first
    need to install Docker on the CentOS Linux machine. In our case, Docker can be
    installed on different Linux distributions, and also on macOS and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Once Docker is installed, we download the Batfish container to our Linux machine
    using the `docker pull` command and start the Docker container using the `docker
    run` command. We must expose **Transmission Control Protocol** (**TCP**) ports
    `9996` and `9997` from the container and map them on the Linux machine, using
    the `-p` directive. We map these ports to the same ports on the Linux machine.
    These ports are used to interact with the Batfish server from the remote client
    (the *Pybatfish* client library installed on the Ansible control machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'Batfish provides two Docker containers: `batfish/batfish` and `batfish/allinone`.
    The `batfish/allinone` container has the Batfish server and the Pybatfish client
    library. It also has the Jupyter Notebook Python library installed, along with
    some sample notebooks, to start interacting with the Batfish server. However,
    we will not be using this approach. Instead, we will be using the `batfish/batfish`
    container, which only has the Batfish server.'
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Batfish and how to install it, please visit
    the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/batfish/docker](https://github.com/batfish/docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/batfish/batfish/blob/master/README.md](https://github.com/batfish/batfish/blob/master/README.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Batfish with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to integrate Batfish with Ansible, we need to install the required Python
    packages. Doing so will allow Ansible to communicate with the Batfish server.
    In this recipe, we will outline how to install these Python packages, as well
    as how to install the required Ansible roles needed to run the required Batfish
    Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, the Ansible controller must have
    internet connectivity. This will allow us to install the required dependencies
    for Batfish.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the Batfish client python3 package on the Ansible controller, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the `batfish` Ansible roles to the `roles` folder, as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are setting up the integration between Ansible and Batfish.
    This is accomplished through two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Ansible controller, we need to install the `pybatfish` Python library,
    which is the Batfish client-side SDK that interacts with the Batfish server. This
    package is required by the Ansible modules. These will be used to interact with
    the Batfish server in our playbooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, we install the `batfish` roles that the Batfish team has developed
    in order to interact with the Batfish server and validate network device configuration.
    This Ansible role contains all the required Python scripts to run the custom Ansible
    modules for Batfish. In order to install this role onto the Ansible control machine,
    we are using `ansible-galaxy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can validate that `pybatfish` is installed correctly like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now explore the installed role downloaded by `ansible-galaxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the list of Python source code for this role, which is found in the
    `library` folder for this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these two steps covered, the Ansible controller is ready to start interacting
    with the Batfish server that we deployed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Since we didn't specify any additional arguments on the `ansible-galaxy install`
    command, the roles will be installed on the `~/.ansible/roles` path by default.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on Pybatfish and the Ansible roles developed by Batfish
    and to be used with Ansible, please check this page: [https://github.com/batfish/batfish/blob/master/README.md](https://github.com/batfish/batfish/blob/master/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the network configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start our analysis and validation with Batfish, we need to provide the configuration
    for our network devices to the Batfish server. In this recipe, we will outline
    how to generate this configuration using Ansible. Batfish is an offline network
    validation tool, and having a complete network configuration is one of the mandatory
    steps for achieving the correct network validation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no specific requirements here, other than having Ansible installed
    on the Ansible control machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new folder named `ch10_batfish` that will hold all our variables and
    playbooks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate all the variables to describe our network in the `group_vars/all.yml` file
    and the `host_vars` folder. Here, we are using the exact same variables that were
    outlined in [*Chapter* 4](c37fb79b-fda8-46cb-8ff2-742a3a4e6b97.xhtml), *Building
    Data Center Networks with Arista and Ansible*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `roles` folder inside the `ch10_batfish` folder, in order to house
    all the roles that we will create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new role named `generate_fabric_config`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Build all the Jinja2 templates inside the `templates` folder to create the interfaces,
    management, and **Border Gateway Protocol** (**BGP**) configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include all the required tasks to build the configuration in the `tasks/main.yml`
    file. Again, we are using the exact same steps and modules already discussed in
    [*Chapter* 4](c37fb79b-fda8-46cb-8ff2-742a3a4e6b97.xhtml), *Building Data Center
    Networks with Arista and Ansible,* to build the configuration for this sample
    network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `ansible_host` inventory, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new playbook named `pb_build_fabric_config.yml`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are using Ansible to generate the configuration for the network
    devices in our sample topology. We are also using the exact same data and variables
    structure that we have discussed in [Chapter 4](c37fb79b-fda8-46cb-8ff2-742a3a4e6b97.xhtml),
    *Building Data Center Networks with Arista and Ansible*. We group all our infrastructure
    definition using the YAML files inside the `group_vars` and `host_vars` folders.
    We are also using the exact same Jinja2 templates that have been used in [Chapter
    4](c37fb79b-fda8-46cb-8ff2-742a3a4e6b97.xhtml),* Building Data Center Networks
    with Arista and Ansible*,in order to generate the configuration snippet for interfaces,
    BGP, and the management configuration for our devices.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `ansible-galaxy init` command to build the role skeleton, and we
    use the `--init-path` directive to specify where to create this new role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output outlines the structure of our new role to generate the
    configuration for our devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we create a new playbook to generate the device configuration,
    and we use the `connection` local parameter since we need to capture the configuration
    of the network devices on the Ansible controller node. Once we have run the playbook,
    we are left with the configuration for all our devices on the `configs` folder,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a network snapshot for Batfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow Batfish to analyze the network using the devices' configuration files,
    these files need to be structured in a specific order. This makes it easy for
    the Batfish server to ingest this data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to properly structure and prepare our network
    configuration files to be consumed by the Batfish service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The device configuration should already be generated, as demonstrated in the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook named `pb_batfish_analyis.yml`, and add the following
    task to create a new folder. This folder will house the network configuration
    that will be analyzed by `batfish`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook named `pb_batfish_analyis.yml` with the following task
    to copy all the configuration files to the new folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to start our analysis of our network, we create a new playbook that
    is used to execute all the required tasks and validate the network configuration
    with Batfish. In this playbook, we use the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: We run the playbook on all the nodes in our network. This is because we will
    need to reference the parameters for each node in subsequent tasks (such as loopback
    **internet protocols** (**IPs**)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the `ansible_connection` parameter to `local` as we don't need to connect
    to our devices, and all the tasks will run locally on the Ansible machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify the IP address of the Batfish server machine hosting the `batfish`
    container. This will be used in all subsequent tasks to communicate with the Batfish
    server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Batfish to start analyzing the configuration of our devices, the configuration
    files for our devices need to be structured in a specific order in one directory.
    This step is often referred to as preparing the network snapshot for Batfish analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a new playbook for the Batfish analysis. In the first task,
    we create the `configs` folder, which will be the base used by Batfish to retrieve
    the configuration for our network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second task, we use the `copy` module to copy the configuration files
    of our network devices over to the `configs` folder. Once we run the playbook
    with the tasks specified, we will get the following directory structure needed
    for Batfish analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In all the tasks, we are using the `run_once` parameter as we want to create
    the folder and copy the files only once. If we omit this option, we will run these
    tasks per each node in our inventory, which is not optimal in this case.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the directory structure needed by Batfish for network
    snapshots, please visit this link: [https://pybatfish.readthedocs.io/en/latest/notebooks/interacting.html#Uploading-configurations](https://pybatfish.readthedocs.io/en/latest/notebooks/interacting.html#Uploading-configurations).'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the network snapshot with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to open a session between Ansible and the
    Batfish server. In addition to this, we will look at how to initialize the network
    snapshot that we prepared in the previous step, as well as how to send it to the
    Batfish server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As outlined in the previous recipe, the device configuration is generated, and
    the network snapshot is packaged at this point. Furthermore, IP reachability is
    now also provided between the Ansible controller and the Batfish server on TCP
    ports 9996 and 9997.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_batfish_analyis.yml` playbook with the following task to start
    the session with the Batfish server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_batfish_analyis.yml` playbook to initialize the network snapshot
    on the Batfish server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the playbook, we are using the `batfish.base` Ansible role (which we have
    downloaded from `ansible-galaxy`) that interacts with the Batfish server. This
    role provides multiple modules that we use to start the integration between the
    Ansible control machine and the Batfish server.
  prefs: []
  type: TYPE_NORMAL
- en: The first module is `bf_session`. This module opens the session between the
    Batfish client (Ansible, in this case) and the Batfish server, in order to start
    to exchange data between the two. The second module, `br_init_snapshot`, initializes
    the network snapshot (device configuration files) that we have created on the
    Ansible controller. It then sends them to the Batfish server in order to start
    analysis on the Batfish server and for the Batfish server to build the neutral
    data model for our network, based on these configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bf_init_session` module returns the status of how Batfish parsed the configuration
    and whether there was any problem in decoding the configuration. We capture this
    return value in the `bf_snapshot` variable. The following snippet outlines the
    status of parsing that was performed by Batfish on the supplied network snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can ignore the warning we received since it will not impact our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting network facts from Batfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batfish can generate a vendor-neutral data model that represents the critical
    facts discovered from the configuration files supplied to Batfish. In this recipe,
    we will outline how to collect these facts discovered by Batfish and how to use
    this information to validate the network configuration on the devices as per the
    intended state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network configuration is already generated and the network snapshot is already
    synced with the Batfish server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_batfish_analyis.yml` playbook with the following task to collect
    facts generated by Batfish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_batfish_analysis.yml` playbook with the following task to validate
    the interface configuration that was generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batfish processes the network snapshot (device configuration) and generates
    a vendor-neutral data model for the different sections of the configuration. These
    are considered to be the facts that Batfish has generated and collected from the
    input configuration files. We use the `bf_extract_facts` Ansible module to extract
    the facts, and we can then save it to a directory for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we saved the Batfish analysis in the `bf_facts` folder, and the
    module generated a unique YAML file that contains this neutral data model for
    each device. The following snippet outlines the interface data model for one of
    the devices (`leaf01`) in our sample topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This same data structure is returned by the module, and we save this result
    in a new variable called `bf_facts`. We use the data in this variable to validate
    the intended network state of our devices, based on the configuration that we
    have generated. We also use the `assert` module to loop through all our interfaces
    for each node that we have declared in our data model. We then compare the value
    for these parameters from the generated data model of Batfish to make sure that
    all our interfaces are operational and that all the IP addresses are configured
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Batfish also provides different built-in `assert` tests to perform validation
    on the data model that it generates. This allows it to provide a more simple and
    robust validation for the critical issues that might affect the network. Here
    is a task that uses these built-in `assert` that are already available with Batfish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see two assertions in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_no_undefined_references`:This validates that all configuration blocks
    are present and valid. For example, all prefix lists are present and there is
    no undefined reference to a missing prefix list. This ensures that the configuration
    generated is sane and doesn''t include any undefined reference to an object that
    is not declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert_no_incompatible_bgp_sessions`: This assertion validates that all the
    BGP sessions are configured correctly and there is no mismatch between the configuration
    of the BGP peers. This also ensures that the generated configuration is valid
    and the resulting BGP session will be operational.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we need to validate that these tests will catch errors in the configuration,
    we can do so by shutting down a link between a leaf and spine switch in our master
    configuration files, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This configuration change should bring down the underlay BGP session between
    the `leaf01` and `spine01` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our playbook again with the preceding task, we will see the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that the first assertion was successful, meaning
    that there were no undefined references in our configuration. However, the second
    assertion failed, since there is now a BGP session that is failing.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding all the available assertions supported by Batfish
    Ansible modules, please check the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/batfish/ansible/blob/master/docs/bf_assert.rst](https://github.com/batfish/ansible/blob/master/docs/bf_assert.rst)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/batfish/ansible/blob/master/docs/assertions.rst](https://github.com/batfish/ansible/blob/master/docs/assertions.rst)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating traffic forwarding with Batfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to validate traffic forwarding in the network.
    This is accomplished in Batfish using the forwarding tables that Batfish generates
    from the device configuration. It is very useful to validate proper traffic forwarding
    within the network prior to any change.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network configuration is already generated and the network snapshot is already
    synced with the Batfish server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_batfish_analyis.yml` playbook with the following task to validate
    traffic forwarding within our topology:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Batfish provides a built-in validation method to validate the proper traffic
    forwarding between endpoints within your network topology. This is achieved using
    the `assert_all_flows_succeed` method. This method validates that all the flows
    between given endpoints are successful. In order for Batfish to validate the traffic
    flow for any given flow, we need to provide the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The start node location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source IP for the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination IP addresses for the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batfish will use the data model that it generated to build the forwarding table
    for all the nodes in our network topology and to validate that the flows we are
    testing will be forwarded within the network.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample topology, we want to validate that all the flows from all the
    nodes' loopback IP addresses can reach the destination loopback IP address on
    all the remote nodes. We use the `with_nested` looping construct to loop across
    all the nodes in our inventory and to loop across all the loopback IP addresses
    within the `lo_ip` data structure. This will test from all the nodes within our
    inventory if we can reach the remote loopbacks of all the other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this test, we will see that all the flows are working fine except
    for traffic from `spine01` to `spine02` and the reverse traffic from `spine02`
    to `spine01`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On the live network, we can check the routing on the live nodes to validate
    our findings from Batfish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After checking our network configuration, we can see that the preceding output
    is correct. This is possible since we are using a route-map on all the `leaf`
    switches to only advertise the local loopback IP address, and we are not re-advertising
    any other IP address from the `leaf` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, there is no BGP session between the `spine` nodes, thus there is
    no traffic path between them. So, in order to complete our test and make it successful,
    we will only test all flows originating from the `leaf` nodes toward all the destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not test traffic originating from the `spine` nodes. Here, you can
    see the modified task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After running the test again, all the flows pass and the task is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Validating ACLs with Batfish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to use Batfish to validate ACL entries and
    validate the correct traffic handling by these ACLs' definition. This allows us
    to use Batfish and Ansible as auditing tools to enforce correct security compliance
    for our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The device configuration is generated and the network snapshot is packaged,
    as outlined in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update our network configuration on `leaf03` and `leaf04` with the following
    ACLs'' entries to secure the web **virtual local area network** (**VLAN**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_batfish_analyis.yml` playbook with the following task to validate
    correct egress ACL behavior for our web VLAN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_batfish_analyis.yml` playbook with the following task to validate
    correct ingress ACL behavior for our VLAN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Batfish is yet another great tool for validating the correct traffic handling
    of traffic processed by ACLs. This allows us to validate whether or not a specific
    flow is permitted or denied by a specific ACL. Batfish also provides a powerful
    tool to validate network changes involving ACLs. Furthermore, it can be used as
    a safeguard against implementing rogue ACL changes that could impact the live
    traffic on the network or lead to violations in our security policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `bf_assert` Batfish module again—however, in this case, for validating
    ACL. We use two other `assert` methods implemented in this module, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `assert_filter_permits` method tests and validates that a specific flow
    is correctly allowed by our ACL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assert_filter_denies` method tests and validates that a specific flow is
    denied by our ACL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our playbook, we create two separate tasks. The first one uses the `assert_filter_permits` method
    to validate that all traffic from the internet to our web server's subnet is permitted.
    We use the `headers` parameter in order to specify the IP header information for
    all the flows that we want to be validated.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the second task using the `assert_filter_denies` method, and
    this tests that a specific web server is blocked from communicating with any destination.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our playbook with the newly updated tasks, we can see that all of
    them are completed successfully, which outlines that the ACL behavior in our sample
    network is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to validate that our filters are working correctly, we will introduce
    a problem in one of our ACL filters by allowing **Hypertext Transfer Protocol
    Secure** (**HTTPS**) traffic to our denied web servers (`172.20.10.10`), as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our playbook again, we can see that we have an error in the last
    task. This error shows that specific traffic flow has been allowed when it was
    expected to be denied by our ACL, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows that we can create more sophisticated assertion rules
    in order to enforce the correct security policy within our network. Furthermore,
    we can utilize Batfish to validate the correct enforcement of this policy across
    our network.
  prefs: []
  type: TYPE_NORMAL
