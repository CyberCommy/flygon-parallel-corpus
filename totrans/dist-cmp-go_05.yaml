- en: Introducing Goophr
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a solid understanding about goroutines, channels, REST, and
    some of the tools for developing Go applications, let's use this knowledge to
    build a distributed web application. The purpose of this application will be to
    index and search documents. In this chapter, we will lay down the design of how
    such an application will be structured, and we will also look at a few remaining
    topics and tools that we will be using in our project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter can be broadly classified into two sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Goophr?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build an application to index and search documents. This is a feature
    that we use every time we access the internet using one of the search portals
    such as Google, Bing, or DuckDuckGo. This is also a feature which some sites provide
    with the help of a search engine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: We will build a search engine application in the next few chapters by drawing
    inspiration from existing technologies such as Google, the Solr search engine,
    and goroutines. The name of our application is a play on these three technologies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Imagine searching for a phrase on any search portal; on submitting our query
    we get a list of links with snippets of text containing terms from our search
    phrase. Many times the first few links tend to be the relevant web page or document
    that we were looking for. How is it possible to get the list of the most relevant
    documents? The way in which Google or other search engines achieve this is quite
    complicated; they have a large team of Computer Scientists constantly fine-tuning
    the search engine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: We will not be aiming to build anything as complicated as that. By having a
    humble and practical goal, we can create a minimal yet usable search engine. However,
    first let's define the purpose and criteria for our application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have briefly described the application we want to build and the
    reason for building it, let''s look at the list of features we want to implement
    as part of the search engine:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: It should accept links to documents provided in the POST request and download
    them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should process and index the downloaded documents
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should handle search queries and respond with a list of documents with snippets
    containing the search terms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned list of documents should be in the order of greater occurrence
    of search terms in the document
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though we listed four functionalities, we can club the application into two
    main components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Goophr Concierge**: This is the component responsible for indexing and returning
    the list of documents for search queries'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goophr Librarian**: This is the component responsible for handling user interaction
    and interacting with the first component'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two components will run as two REST servers and all interactions will follow
    the REST protocol. So let's define API definitions for our components! In [Chapter
    4](../Text/Ch04.xhtml), *The RESTful Web*, you noticed that the approach we used
    to define various API endpoints and data definition for communicating via REST
    protocol was pretty verbose and cumbersome. Wouldn't it be better if we had a
    formal way to write API definitions? The good news is that with the prevalence
    of REST protocol, there are many solutions, and one of these solutions is the
    most widely used industry standard—OpenAPI format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI specification
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI lets us define RESTful APIs in a standardized manner, and they can be
    defined without being tied down to any particular programming language or framework
    being used. This provides us with a powerful abstraction to define an API that
    can have the initial implementation of the RESTful server in Java or Python; also
    we can port the codebase to Go, with little to no change in the behavior of the
    service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let's list the general structure of an OpenAPI specification and use it to redefine
    the `Books API` described in [Chapter 4](../Text/Ch04.xhtml), *The RESTful Web*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `Books API` title, we can define the following elements to
    describe the API:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The URL to our server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic information about the intent of the API
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths available in our API
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods available per each of the paths in the API
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possible description and example payloads for the requests and responses
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The schema of the requests and responses payloads
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these points in mind, let''s look at the OpenAPI specification for `Books
    API`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Goophr Concierge API definition
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Goophr Concierge is the user-facing component, and it has two responsibilities—to
    index new documents and to return query results. Informally, we can define the
    API as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/feeder`: This is the API endpoint to upload documents by user'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request adds new documents if the payload is complete and correct
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/query`: The user searches for phrases or terms that are queried against
    this API endpoint'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request contains payload with search terms, and a list of documents
    will be returned
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This simple API description is for our understanding. Now let''s look at how
    this would be formulated using the OpenAPI specification:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the help of the API description, the preceding OpenAPI definition should
    be self-explanatory. Details regarding the OpenAPI specification can be found
    at [https://swagger.io/specification/](https://swagger.io/specification/). We
    can use tools provided by Swagger ([https://editor.swagger.io/](https://editor.swagger.io/))
    to get a better visual representation of our API definition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of the Goophr Concierge OpenAPI as viewed in
    Swagger Editor:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23d4410-fd76-4101-b6a9-2dca72407769.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Viewing OpenAPI on Swagger Editor
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Goophr Librarian API definition
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Goophr Librarian is the actual maintainer of the index for a set of documents,
    and its responsibilities are to add terms to the index and to return query results
    for the search terms based on the terms available in the index.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Informally, we can define the API as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/index`**:** Goophr Concierge calls this API endpoint to add terms to
    the actual index'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request adds terms to index
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/query`: Goophr Concierge calls this endpoint to query search terms submitted
    by the user'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request returns results for search terms
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the OpenAPI definition for Goophr Librarian:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two API specifications describe how the two components will interact with
    each other and also the user. However, this is not the complete picture because
    even though we have shown only two API definitions, the actual implementation
    will have three instances of Librarian!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interacts with Goophr by interacting with Concierge via `/api/feeder`
    and `/api/query`*.* Concierge can further interact with the three librarian instances
    via `/api/index` and `/api/query`*.* The figure below shows what the application
    will look like in broad terms:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5f63f8-a3fa-4923-939e-b37b459c3f87.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: The design of the Goophr application
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Consider when we need to build a real web application that will be used by multiple
    users; in this case, we'll want to have multiple instances of our services running
    so that they can serve all the users simultaneously. We might also have split
    our application into multiple APIs, and we need to have a good understanding on
    how to design our system to handle such distributed workload. So, in order to
    understand how to deal with such a system, we will work with three instances of
    Librarian.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the previous diagram, we have designed our application to consist of
    one instance of Goophr Concierge and three instances of Goophr Librarian. In order
    to keep our code manageable, we will split the source code into two main entities
    and a `docker-compose` file at the root level:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`Concierge`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Librarian`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.yaml`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 1](../Text/Ch01.xhtml)*, Developer Environment for Go*, we discussed
    how to create and run docker images. The `docker run ...` works great for single
    images, but it might get complicated when we want to create a network of docker
    images that interact with one another. In order to keep the setup simple, we will
    make use of `docker-compose` ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)).
    In a nutshell, `docker-compose` requires a **YAML** (**Yet Another Markup Language**)
    file with specifics such as what to name the running docker images, what ports
    to run them on, and which `Dockerfile` to use to build these docker images.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](../Text/Ch01.xhtml)*，Go的开发环境*中，我们讨论了如何创建和运行docker镜像。`docker run ...`对于单个镜像效果很好，但当我们想要创建一个相互交互的docker镜像网络时，可能会变得复杂。为了保持设置简单，我们将使用`docker-compose`（[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)）。简而言之，`docker-compose`需要一个**YAML**（**另一种标记语言**）文件，其中包含具体信息，例如要给正在运行的docker镜像命名，要在哪些端口上运行它们，以及要使用哪个`Dockerfile`来构建这些docker镜像。
- en: 'The following is the `docker-compose.yaml` file we will be using in our project:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们项目中将使用的`docker-compose.yaml`文件：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that `a_m_librarian`, `n_z_librarian`, and `others_librarian` are built
    from the same docker image defined by `librarian/Dockerfile`. This makes our life
    easier than using raw `docker` commands to start and configure multiple instances.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`a_m_librarian`，`n_z_librarian`和`others_librarian`都是从由`librarian/Dockerfile`定义的相同docker镜像构建的。这比使用原始的`docker`命令启动和配置多个实例更容易。
- en: 'Here is the project structure that we will be starting with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要开始的项目结构：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though we have an elaborate structure set up, for now, the only files that
    have any useful code are `concierge/main.go`, `concierge/Dockerfile`, `librarian/main.go`,
    and `librarian/Dockerfile` (for convenience, from here on, we will denote the
    files using shorthand notation `{concierge,librarian}`/`{main.go,Dockerfile}`.
    This notation is inspired from Bash.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经建立了一个精心设计的结构，但目前，唯一具有任何有用代码的文件是`concierge/main.go`，`concierge/Dockerfile`，`librarian/main.go`和`librarian/Dockerfile`（为了方便起见，从现在开始，我们将使用简写符号`{concierge,librarian}`/`{main.go,Dockerfile}`来表示这些文件。这种表示法受到Bash的启发。）
- en: Let's take a look at `main.go` and `Dockerfile`. These two files will be almost
    identical for both components. For brevity, we will show each of the two types
    of the files once, and show where the differences lie.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`main.go`和`Dockerfile`。这两个文件对于两个组件来说几乎是相同的。为了简洁起见，我们将分别展示这两种文件，并展示它们的区别所在。
- en: 'Let''s start with `main.go`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main.go`开始：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s look at `Dockerfile`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`Dockerfile`：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the complete codebase, we should see an output similar to the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行完整的代码库，我们应该会看到类似以下的输出：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by describing the application that we will be building
    in the next three chapters. Then we split the application into two major components—Goophr
    Concierge and Goophr Librarian. Next we looked at the project structure that we
    will be using for our application. We also discussed OpenAPI, the industry standard
    for describing REST APIs, and used it to define our APIs for Concierge and Librarian.
    Finally, we looked at how to run our distributed application using `docker-compose`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先描述了我们将在接下来的三章中构建的应用程序。然后我们将应用程序分成了两个主要组件——Goophr Concierge和Goophr Librarian。接下来，我们看了一下我们将在应用程序中使用的项目结构。我们还讨论了OpenAPI，这是描述REST
    API的行业标准，并用它来定义我们的Concierge和Librarian的API。最后，我们看了一下如何使用`docker-compose`运行我们的分布式应用程序。
- en: In the next chapter, we will look at Goophr Concierge, which will interact with
    users to upload documents, and respond to the search queries from users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Goophr Concierge，它将与用户交互以上传文档，并响应用户的搜索查询。
