- en: Introducing Goophr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a solid understanding about goroutines, channels, REST, and
    some of the tools for developing Go applications, let's use this knowledge to
    build a distributed web application. The purpose of this application will be to
    index and search documents. In this chapter, we will lay down the design of how
    such an application will be structured, and we will also look at a few remaining
    topics and tools that we will be using in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter can be broadly classified into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Goophr?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build an application to index and search documents. This is a feature
    that we use every time we access the internet using one of the search portals
    such as Google, Bing, or DuckDuckGo. This is also a feature which some sites provide
    with the help of a search engine.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a search engine application in the next few chapters by drawing
    inspiration from existing technologies such as Google, the Solr search engine,
    and goroutines. The name of our application is a play on these three technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine searching for a phrase on any search portal; on submitting our query
    we get a list of links with snippets of text containing terms from our search
    phrase. Many times the first few links tend to be the relevant web page or document
    that we were looking for. How is it possible to get the list of the most relevant
    documents? The way in which Google or other search engines achieve this is quite
    complicated; they have a large team of Computer Scientists constantly fine-tuning
    the search engine.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be aiming to build anything as complicated as that. By having a
    humble and practical goal, we can create a minimal yet usable search engine. However,
    first let's define the purpose and criteria for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have briefly described the application we want to build and the
    reason for building it, let''s look at the list of features we want to implement
    as part of the search engine:'
  prefs: []
  type: TYPE_NORMAL
- en: It should accept links to documents provided in the POST request and download
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should process and index the downloaded documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should handle search queries and respond with a list of documents with snippets
    containing the search terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned list of documents should be in the order of greater occurrence
    of search terms in the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though we listed four functionalities, we can club the application into two
    main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goophr Concierge**: This is the component responsible for indexing and returning
    the list of documents for search queries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goophr Librarian**: This is the component responsible for handling user interaction
    and interacting with the first component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two components will run as two REST servers and all interactions will follow
    the REST protocol. So let's define API definitions for our components! In [Chapter
    4](../Text/Ch04.xhtml), *The RESTful Web*, you noticed that the approach we used
    to define various API endpoints and data definition for communicating via REST
    protocol was pretty verbose and cumbersome. Wouldn't it be better if we had a
    formal way to write API definitions? The good news is that with the prevalence
    of REST protocol, there are many solutions, and one of these solutions is the
    most widely used industry standard—OpenAPI format.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAPI lets us define RESTful APIs in a standardized manner, and they can be
    defined without being tied down to any particular programming language or framework
    being used. This provides us with a powerful abstraction to define an API that
    can have the initial implementation of the RESTful server in Java or Python; also
    we can port the codebase to Go, with little to no change in the behavior of the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Let's list the general structure of an OpenAPI specification and use it to redefine
    the `Books API` described in [Chapter 4](../Text/Ch04.xhtml), *The RESTful Web*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `Books API` title, we can define the following elements to
    describe the API:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL to our server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic information about the intent of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths available in our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods available per each of the paths in the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possible description and example payloads for the requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The schema of the requests and responses payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these points in mind, let''s look at the OpenAPI specification for `Books
    API`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Goophr Concierge API definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Goophr Concierge is the user-facing component, and it has two responsibilities—to
    index new documents and to return query results. Informally, we can define the
    API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/feeder`: This is the API endpoint to upload documents by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request adds new documents if the payload is complete and correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/query`: The user searches for phrases or terms that are queried against
    this API endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request contains payload with search terms, and a list of documents
    will be returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This simple API description is for our understanding. Now let''s look at how
    this would be formulated using the OpenAPI specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the API description, the preceding OpenAPI definition should
    be self-explanatory. Details regarding the OpenAPI specification can be found
    at [https://swagger.io/specification/](https://swagger.io/specification/). We
    can use tools provided by Swagger ([https://editor.swagger.io/](https://editor.swagger.io/))
    to get a better visual representation of our API definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of the Goophr Concierge OpenAPI as viewed in
    Swagger Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23d4410-fd76-4101-b6a9-2dca72407769.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing OpenAPI on Swagger Editor
  prefs: []
  type: TYPE_NORMAL
- en: Goophr Librarian API definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Goophr Librarian is the actual maintainer of the index for a set of documents,
    and its responsibilities are to add terms to the index and to return query results
    for the search terms based on the terms available in the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Informally, we can define the API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/index`**:** Goophr Concierge calls this API endpoint to add terms to
    the actual index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request adds terms to index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/query`: Goophr Concierge calls this endpoint to query search terms submitted
    by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The POST request returns results for search terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the OpenAPI definition for Goophr Librarian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The two API specifications describe how the two components will interact with
    each other and also the user. However, this is not the complete picture because
    even though we have shown only two API definitions, the actual implementation
    will have three instances of Librarian!
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interacts with Goophr by interacting with Concierge via `/api/feeder`
    and `/api/query`*.* Concierge can further interact with the three librarian instances
    via `/api/index` and `/api/query`*.* The figure below shows what the application
    will look like in broad terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b5f63f8-a3fa-4923-939e-b37b459c3f87.png)'
  prefs: []
  type: TYPE_IMG
- en: The design of the Goophr application
  prefs: []
  type: TYPE_NORMAL
- en: Consider when we need to build a real web application that will be used by multiple
    users; in this case, we'll want to have multiple instances of our services running
    so that they can serve all the users simultaneously. We might also have split
    our application into multiple APIs, and we need to have a good understanding on
    how to design our system to handle such distributed workload. So, in order to
    understand how to deal with such a system, we will work with three instances of
    Librarian.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the previous diagram, we have designed our application to consist of
    one instance of Goophr Concierge and three instances of Goophr Librarian. In order
    to keep our code manageable, we will split the source code into two main entities
    and a `docker-compose` file at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Concierge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Librarian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.yaml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 1](../Text/Ch01.xhtml)*, Developer Environment for Go*, we discussed
    how to create and run docker images. The `docker run ...` works great for single
    images, but it might get complicated when we want to create a network of docker
    images that interact with one another. In order to keep the setup simple, we will
    make use of `docker-compose` ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)).
    In a nutshell, `docker-compose` requires a **YAML** (**Yet Another Markup Language**)
    file with specifics such as what to name the running docker images, what ports
    to run them on, and which `Dockerfile` to use to build these docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `docker-compose.yaml` file we will be using in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that `a_m_librarian`, `n_z_librarian`, and `others_librarian` are built
    from the same docker image defined by `librarian/Dockerfile`. This makes our life
    easier than using raw `docker` commands to start and configure multiple instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the project structure that we will be starting with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have an elaborate structure set up, for now, the only files that
    have any useful code are `concierge/main.go`, `concierge/Dockerfile`, `librarian/main.go`,
    and `librarian/Dockerfile` (for convenience, from here on, we will denote the
    files using shorthand notation `{concierge,librarian}`/`{main.go,Dockerfile}`.
    This notation is inspired from Bash.)
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at `main.go` and `Dockerfile`. These two files will be almost
    identical for both components. For brevity, we will show each of the two types
    of the files once, and show where the differences lie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the complete codebase, we should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we started by describing the application that we will be building
    in the next three chapters. Then we split the application into two major components—Goophr
    Concierge and Goophr Librarian. Next we looked at the project structure that we
    will be using for our application. We also discussed OpenAPI, the industry standard
    for describing REST APIs, and used it to define our APIs for Concierge and Librarian.
    Finally, we looked at how to run our distributed application using `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at Goophr Concierge, which will interact with
    users to upload documents, and respond to the search queries from users.
  prefs: []
  type: TYPE_NORMAL
