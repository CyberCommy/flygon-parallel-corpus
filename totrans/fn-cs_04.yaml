- en: Chapter 4. Extending Object Functionality with Extension Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already mentioned in the previous chapter, we are going to discuss
    extension methods in greater detail in this chapter. It will be helpful when we
    talk about LINQ, the essential technique of functional programming in C#, in the
    next chapter. The following are the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing the use of extension methods and getting this new method in IntelliSense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking extension methods from other assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new methods for an interface, collection, enumeration, and other objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of extension methods in relation to functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The limitations of extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting closer to extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An extension method is a capability that can extend the ability of an existing
    class or type without making any modification to the existing class or type. This
    means that an extension method enables us to add methods to the existing class
    or type without having to either create a new derived type or recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods were introduced in C# 3.0 and can be applied to our own types
    or existing types in .NET. The extension method will be used a lot in functional
    programming since it suits the method chaining concept, which we have already
    used in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in
    C#") , *Tasting Functional Style in C#* , when refactoring code in a functional
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an extension method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extension methods have to be declared in a static, nongeneric, and non-nested
    class. They are a static method inside a static class. To create an extension
    method, first we have to create a `public static` class since the extension methods
    have to be included in the `static` class. After the `public static` class is
    successfully created, we define a method inside the class and add the `this` keyword
    to the first method argument to indicate that it is an `extension` method. The
    first argument in the method that has the `this` keyword has to refer to a specific
    instance of the class we want to extend. In order to make the explanation clearer,
    let''s take a look at the following code, creating a extension method that we
    can find in the `Palindrome.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s dissect the preceding code to understand how the extension method
    is created. First, we have to successfully create the `public static` class, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `static` method inside the class, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding method, we add the `this` keyword in the first
    argument of the method. This indicates that the method is an `extension` method.
    Also, the type of the first argument, which is string, indicates that the type
    we want to extend is the `string` data type. Now, by defining the `IsPalindrome()`
    extension method for the `string` type, all instances of string have the `IsPalindrome()`
    method. Let''s take a look at the following code to prove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `Main()` function will examine all members of the `strArray`
    array, whether or not it is palindrome. We can call the `IsPalindrome()` method
    from the `s` variable in which it''s a `string` type variable. The code snippet
    when the `IsPalindrome()` method is invoked from an instance of the string type
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `Palindrome.csproj` project, we can get the following output
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an extension method](img/Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the palindrome is a word or another sequence of characters that will be
    the same whether we read backward or forward, only `level` , `madam` , and `radar`
    will return `true` if we invoke the `IsPalindrome()` method to them. Our extension
    method has been successfully created and run.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods in the code IntelliSense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create an extension method for instance, to a type there will be no
    apparent difference compared to the existing methods in a class or type. This
    is because we will do the same thing when invoking extension methods or methods
    that are actually defined in a type. However, we can inspect the code IntelliSense
    to understand whether or not the method inside the type is an extension method
    since the extension method will be displayed in the IntelliSense. The following
    screenshot is the method list for the string instance when the `IsPalindrome()`
    extension method has not been defined yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extension methods in the code IntelliSense](img/Image00038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following screenshot is the method list for the string instance when
    the `IsPalindrome()` extension method has been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extension methods in the code IntelliSense](img/Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding two images that the extension will be listed in
    the code IntelliSense of Visual Studio. However, we can now find the distinction
    between extension methods and methods that are actually defined in a type that
    is the icon. There is an arrow pointing down at the icon of extension methods
    although we cannot find it in the method that is actually defined in a type. This
    is because the icon is different but the way we invoke the method is totally the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Calling extension methods in the other assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully created the `IsPalindrome()` extension method in the previous
    section. It's quite easy to call the extension method since it's defined inside
    the same namespace as the caller method. In other words, the `IsPalindrome()`
    extension method and the `Main()` method are in the same namespace. We don't need
    to add a reference to any module since the method is there along with the caller.
    However, in common practice, we can create extension methods in the other assemblies,
    which we usually call class library. The use of the library will ease the use
    of the extension method since it can be reused, so we can use the extension method
    in many projects.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create an extension method in the `Class Library` and call
    it in another project. Let''s create a new `Class Library` project named `ReferencingNamespaceLib.csproj`
    and insert the following code into the `ExtensionMethodsClass.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we create the `ConvertToHex()` extension
    method inside the `ExtensionMethodsClass` class in the `ReferencingNamespaceLib`
    namespace. The use of the `ConvertToHex()` extension method is to convert each
    character in the string to ASCII code and store it in the byte array. Now let''s
    take a look at the following code, which will call the extension method, which
    we can find in the `ReferencingNamespace.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we call the `ConvertToHex()` extension
    method from the instance of string, which is `strData` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in order to invoke the `ConvertToHex()` method from the string instance,
    we have to refer to the `ReferencingNamespaceLib` assembly and also import the
    namespace of the reference assembly. To import the assembly, we have to use `using`
    along with `ReferencingNamespaceLib` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `ReferencingNamespace.csproj` project, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Referencing a namespace](img/Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, each character in C# sentences is converted into ASCII code invoked
    the extension method we created for the string type by referencing a namespace
    in both hexadecimal and decimal formats. This also proves that we have successfully
    in another assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Piggybacking a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can, if we want, piggyback on the namespace where the string type lives,
    which is the `System` namespace, so that we don''t need to import a custom namespace
    to use the extension method. Piggybacking a namespace is also good for our standard
    programming approach. Let''s refactor our previous `ReferencingNamespaceLib.csproj`
    code using the following code, which we can find in the `PiggybackingNamespaceLib.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we observe the class name, the `ConvertToHex()` method signature, or the
    implementation of the method, we will find that there''s no difference between
    the `ReferencingNamespaceLib.csproj` and `PiggybackingNamespaceLib.csproj` projects.
    However, if we look at the namespace name, we will find that now it''s `System`
    instead of `PiggybackingNamespaceLib` . The reason we use the `System` namespace
    is to create an extension method in the selected namespace. Since we want to extend
    the ability of the string type that lives in the `System` namespace, we have to
    extend the `System` namespace as well. We do not need to import the `System` namespace
    using a `using` keyword since the `ConvertToHex()` method lives in the `System`
    namespace. Now, let''s take a look at the following code in order to invoke the
    `ConvertToHex()` method inside the `System` namespace, which we can find in the
    `PiggybackingNamespace.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We refactor the preceding code from the `ReferencingNamespace.csproj` project,
    and again, we don''t find any differences between the `PiggybackingNamespace.csproj`
    and `ReferencingNamespace.csproj` projects except that there is no import to the
    custom namespace in the `PiggybackingNamespace.csproj` project, which the `ReferencingNamespace.csproj`
    project has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need to import the custom namespace since we create the extension
    method in the `System` namespace. However, we still need to refer to the assembly
    where the extension method is defined. We can expect an output like what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Piggybacking a namespace](img/Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully invoked the `ConvertToHex()` extension method and found
    it useful for getting the ASCII code from the string data type.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the interface, collection, and object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only can classes and types apply an extension method, but interfaces, collections,
    and any other objects can be functionally extended using an extension method as
    well. We are going to discuss this in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can extend the method in an interface in the same way we extend the method
    in a class or type. We still need the `public static` class and the `public static`
    method. By extending the interface abilities, we can use the extension method
    just after we create it without the need to create the implementation inside the
    class that we inherit from the interface, since the implementation is done when
    we declare the extension method. Let''s take a look at the following `DataItem`
    class, which we can find in the `ExtendingInterface.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the following `IDataSource` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `IDataSource` interface has only one signature of the method,
    which is named `GetItems()` , returning `IEnumerable<DataItem>` . Now, we can
    create a class to inherit the `IDataSource` interface, which we give a name, `ClubMember`
    ; it has the implementation of the `GetItems()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding class, the `GetItems()` method will yield all the data in
    the  `DataItemList` , whose content will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are ten `DataItem` classes in the `DataItemList` . We can display all
    the items in the `DataItemList` with the help of the `GetItems()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can can see in the preceding code, since we have inherited the `ClubMember`
    class to the `IDataSource` interface and have implemented the `GetItems()` method,
    the instance of `ClubMember` , which is `cm` , can invoke the `GetItems()` method.
    The output will be like what is shown in the following screenshot when we run
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the interface](img/Image00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to add the method to the interface without having to modify
    it, we can create a method extension to the interface. Consider that we are going
    to add the `GetItemsByGender()` method to the `IDataSource` interface; we can
    create the extension method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating the preceding extension method, the instance of the `ClubMember`
    class now has a method named `GetItemsByGender()` . We can use this extension
    method in the same way as we use the method class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetItemsByGender()` method will return the `IEnumerable` interface of
    the selected gender of `DataItemList` . Since we only need to get all female members
    in the list, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the interface](img/Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now extend the method in the interface, and there's no need to implement
    the method in the inherited class since it has been done in the extension method
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous discussion, we discovered that we apply the `IEnumerable` interface
    in order to collect all the data we need. We can also extend the `IEnumerable`
    interface, which is a collection type, so that we can add a method in an instance
    of a collection type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code in the `ExtendingCollection.csproj` project and we
    still use `DataItem.cs` and `IDataSource.cs` , which we use in the `ExtendingInterface.csproj`
    project. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the extension method for the `IEnumerable` type. To prevent
    the occurrence of an error, we have to cast the type of all sources'' items using
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also extend the `IEnumerable<T>` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding method, we can extend the `IEnumerable<T>` type to have
    a method named `GetAllItemsByGender_IEnumTemplate()` , which is used to get the
    items by a specific gender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to invoke these two extension methods. However, before we
    call them, let''s create the following two classes, named `ClubMember1` and `ClubMember2`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to invoke the `GetAllItemsByGender_IEnum()` and `GetAllItemsByGender_IEnumTemplate()`
    extension methods. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, first we create a `sources` variable containing the
    array of `IDataSource` . We get the data for `sources` from the `ClubMember1`
    and `ClubMember2` classes. Since the source is a collection of `IDataSource` ,
    the `GetAllItemsByGender_IEnum()` method can be applied to it. If we run the preceding
    `Main()` method, the following output will be displayed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the collection](img/Image00044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully invoked the `GetAllItemsByGender_IEnum()` extension method.
    Now, let''s try to invoke the `GetAllItemsByGender_IEnumTemplate` extension method
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the `sources` variable in the yet-to-be-displayed code, in the same
    way as we declared it in the previous `Main()` method. Also, we can apply the
    `GetAllItemsByGender_IEnumTemplate()` extension method to the source variable.
    The output will be as follows if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending the collection](img/Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By comparing the two images of the output, we can see that there's no difference
    between them, although they extend the different collection types.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not only can we extend an interface and a collection, we can actually extend
    an object as well, which means that we can extend everything. To discuss this,
    let''s take a look at the following code, which we can find in the `ExtendingObject.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a method extension named `WriteToConsole()` , which can be applied
    to all objects in C# since it extends the `Object` class. To use it, we can apply
    it to various objects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dissect the preceding code, let''s run this `Main()` method, and
    we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending an object](img/Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding code, we can see that all objects that are `UInt64` , `DateTime`
    , `DataItem` , and `IEnumerable<IDataSource>` can invoke the `WriteToConsole()`
    extension method that we declare use the `this` object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating an extension method in the object type causes all types in the framework
    to be able to access the method. We have to ensure that the implementation of
    the method can be applied to the different types supported by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using extension methods in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method chaining in functional programming relies on extension methods. As we
    have already discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting
    Functional Style in C#") , *Tasting Functional Style in C#* , method chaining
    will make our code easier to read since it can decrease the lines of code. For
    the sake of code readability in the extension method, let''s take a look at the
    following code, which we can find in the `CodeReadability.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the `static` method inside the `static` class. It is
    not an extension method since we don''t use the `this` keyword in the method argument.
    We can find it in the `HelperMethods.cs` file. The use of the `TrimAllSpace()`
    method is to remove all white space characters from the string, while the use
    of the `Capitalize()` method is to make the first letter of a string uppercase
    in the sentence. We also have exactly same methods as `HelperMethods` , which
    we can find in the `ExtensionMethods.cs` file. Let''s look at the following code,
    in which we declare `TrimAllSpace()` and `Capitalize()` as the extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create code that will trim all the whitespace in the given string
    and then capitalize each string in the sentence. The following is the code implemented
    in the `HelperMethods` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare a string array named `sentences` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advantages of using extension methods in functional programming](img/Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can, if we want, simplify the preceding `Main()` method, which uses `HelperMethods`
    , using extension methods we have already created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `Main()` method, we will get eactly the same output
    on the console. However, we have refactored the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the extension method, we just need this one-line code to replace the
    the four lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The point is that we have reduced the line of code so it now becomes simpler
    and more readable and the flow of the process is clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of the extension method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the extension method is a powerful tool to achieve our functional programming,
    this technique still has some limitations. Here, we elaborate on the limitations
    the extension methods face so that we can avoid their use.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a static class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discuss extension methods further, we know that an extension method is
    a static method that has public accessibility inside the static class that has
    public accessibility as well. The extension method will appear in the type or
    class we target. However, not all classes can be extended using the extension
    method. The existing static class will not be able to be extended. For example,
    the `Math` class has been provided by .NET. Even though the class has provided
    a mathematical functionality we usually use, it might be that, sometimes, we need
    to add another functionality to the `Math` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since the `Math` class is a static class, it''s nearly impossible
    to extend this class by adding a single method to it. Suppose we want to add the
    `Square()` method to find the result of multiplying a number by itself. Here is
    the code, which we can find in the `ExtendingStaticClass.csproj` project, if we
    try to add the extension method to the `Math` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile the preceding code, there will be an error similar to what
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending a static class](img/Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The error message says that the `Math` static method cannot be used as a parameter
    of the `Square()` extension method. What we can do to overcome this limitation
    is now extend the types instead of the `Math` class. We can extend the `int` types
    by adding the `Square()` method instead of extending the `Math` class. Here''s
    the code to extend the `int` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we extend the `int` types so that if we want to invoke the `Square()`
    method, we can invoke it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, using this technique, we also need to extend the other types, such
    as `float` and `double` , to accommodate the `Square()` functionality in various
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the method implementation in the existing class or type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the extension method can be applied to the existing classes and types,
    we cannot modify the implementation of the existing method the class or type has.
    We can try it using the following code, which we can find in the `ModifyingExistingMethod.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we try to replace the existing `ToString()` method,
    which the string type has, with a `ToString()` extension method such as the one
    in the preceding code. Fortunately, the code will be able to be compiled successfully.
    Now, let''s add the following code to the `Main()` method in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, if we run the project, the `ToString()` extension method will never
    be executed. We will get the output from the existing `ToString()` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extension methods give us an easy way to add a new method to an existing class
    or type without having to modify the original class or type. Besides, we don't
    need to recompile the code since just after we create the extension method it
    will be recognized by the code in the project. An extension method has to be declared
    as a static method inside a static class. As there is no apparent difference compared
    to the existing methods in a class or type, the method will also appear in the
    IntelliSense.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods can also be declared in another assembly, and we have to refer
    to the namespace of the static class defined the method stored in the other assemblies.
    However, we can use the piggyback namespace technique, which uses the existing
    namespace so that we don't need to refer to any other namespace anymore. Not only
    can we extend the class and type functionality, but we can also extend the interface,
    collection, and any objects in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Like other C# technologies, extension methods also have their advantages and
    limitations. One of the advantages related to functional programming is that the
    extension method will make our code apply method chaining so that it can apply
    the functional approach. However, we cannot extend a static and we cannot modify
    the method implementation in an existing class or type, which is a limitation
    of the extension method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig into LINQ techniques since we already have
    enough understanding of delegates, lambda expressions, and extension methods.
    We will also discuss the convenient way to code a functional program provided
    by LINQ.
  prefs: []
  type: TYPE_NORMAL
