- en: '22'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation for Functional Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed the importance of unit tests and integration
    tests in software development and discussed how they ensure the reliability of
    your code base. We also discussed how unit and integration tests are integral
    parts of all software production stages and are run each time the code base is
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other important tests, called functional tests. They are run
    only at the end of each sprint to verify that the output of the sprint actually
    satisfies the specifications that were agreed upon with the stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is specifically dedicated to functional tests and to the techniques
    for defining, executing, and automating them. More specifically, this chapter
    covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unit testing tools to automate functional tests in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case â€“ automating functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to design both manual and automatic
    tests to verify that the code produced by a sprint complies with its specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are encouraged to read *Chapter 18*, *Testing Your Code with Unit Test Cases
    and TDD*, before proceeding with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2019's free Community Edition or better,
    with all the database tools installed. Here, we will modify the code of *Chapter
    18*, *Testing Your Code with Unit Test Cases and TDD*, which is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 18*, *Testing Your Code with Unit Test Cases and TDD*, we discussed
    the advantages of automatic tests, how to design them, and their challenges. Functional
    tests use the same techniques and tools as unit and integration tests but differ
    from them in that they are run only at the end of each sprint. They have the fundamental
    role of verifying that the current version of the whole software complies with
    its specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Since functional tests also involve the **user interface** (**UI**), they need
    further tools to simulate, somehow, the way the user acts in the UI. We will discuss
    this point further throughout the chapter. The need for extra tools is not the
    only challenge the UI brings with it, because UIs also see frequent and major
    changes. Thus, we mustn't design tests that depend on the UI's graphical details
    or we might be forced to completely rewrite all the tests at each UI change. That's
    why it is sometimes better to renounce automatic tests and fall back to manual
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether automatic or manual, functional testing must be a formal process that
    is performed for the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional tests represent the most important part of the contract between
    stakeholders and the development team, the other part being the verification of
    non-functional specifications. The way this contract is formalized depends on
    the nature of the relationship between the development team and stakeholders:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a supplier-customer relationship, the functional tests become
    part of the supplier-customer business contract for each sprint, and a team that
    works for the customer writes them. If the tests fail, then the sprint is rejected
    and the supplier must run a supplementary sprint to fix all problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no supplier-customer business relationship because the development
    team and the stakeholder belong to the same company, there is no business contract.
    In this case, the stakeholder together with the team writes an internal document
    that formalizes the requirements of the sprint. If the tests fail, usually, the
    sprint is not rejected but the results of the tests are used to drive the specifications
    for the next sprints. Of course, if the failure percentage is high, the sprint
    may be rejected and should be repeated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formalized functional tests that run at the end of each sprint prevent any results
    achieved in previous sprints from being destroyed by new code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using an agile development methodology, maintaining an updated battery
    of functional tests is the best way to get a formal representation of the final
    system specifications since, during agile development, the specifications of the
    final system are not decided before development starts but are the result of the
    system's evolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the output of the first sprints may differ a lot from the final system
    in these early stages, it is not worth spending too much time writing detailed
    manual tests and/or automatized tests. Therefore, you may limit the user stories
    to just a few examples that will be used both as inputs for software development
    and as manual tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As system functionalities become more stable, it is worth investing time in
    writing detailed and formal functional tests for them. For each functional specification,
    we must write tests that verify their operation in extreme cases. For instance,
    in a cash withdrawal use case, we must write tests that verify all possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Not enough funds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Card expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrong credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated wrong credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following picture sketches the whole process with all possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_22.1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.1: Withdrawal example'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of manual tests, for each of the preceding scenarios, we must give
    all the details of all the steps involved in each operation and, for each step,
    the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: An important decision is whether you want to automate all or a part of the functional
    tests, since it is very expensive to write automated tests that simulate a human
    operator that interacts with a system's UI. The final decision depends on the
    cost of the test implementation divided by the expected number of times it will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of CI/CD, the same functional test can be executed several times
    but, unluckily, functional tests are strictly tied to the way the UI is implemented,
    and, in modern systems, the UI is changed frequently. Therefore, in this case,
    a test is executed with exactly the same UI no more than a couple of times.
  prefs: []
  type: TYPE_NORMAL
- en: In order to overcome all the problems related to the UI, some functional tests
    can be implemented as **subcutaneous tests**, that is, as tests that bypass the
    UI. For instance, some functional tests for an ASP.NET Core application can call
    controller action methods directly instead of sending an actual request through
    a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, subcutaneous tests can't verify all possible implementation errors,
    since they can't detect errors in the UI itself. Moreover, in the case of a web
    application, subcutaneous tests usually suffer from other limitations because
    they bypass the whole HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, in the case of ASP.NET Core applications, if we call controller
    action methods directly, we bypass the whole ASP.NET Core pipeline that processes
    each request before passing it to the right action method. Therefore, authentication,
    authorization, CORS, and the behavior of other middleware in the ASP.NET Core
    pipeline will not be analyzed by the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete automated functional test of a web application should do the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Start an actual browser on the URL to be tested
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait so that any JavaScript on the page completes its execution
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, send commands to the browser that simulate the behavior of a human operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after each interaction with the browser, automatic tests should wait
    so that any JavaScript that was triggered by the interaction completes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While browser automatization tools exist, tests implemented with browser automatization,
    as mentioned earlier, are very expensive and difficult to implement. Therefore,
    the suggested approach of ASP.NET Core MVC is to send actual HTTP requests to
    an actual copy of the web application, with a .NET HTTP client instead of using
    a browser. Once the HTTP client receives an HTTP response, it parses it in a DOM
    tree and verifies that it received the right response.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference with the browser automatization tools is that the HTTP client
    is not able to run any JavaScript. However, other tests may be added to test the
    JavaScript code. These tests are based on test tools that are specific to JavaScript,
    such as **Jasmine** and **Karma**.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to automatize functional tests for web applications
    with a .NET HTTP client, while a practical example of functional test automation
    is shown in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Using unit testing tools to automate functional tests in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated functional tests use the same test tools as unit and integration tests.
    That is, these tests can be embedded in the same xUnit, NUnit, or MSTests projects
    that we described in *Chapter 18*, *Testing Your Code with Unit Test Cases and
    TDD*. However, in this case, we must add further tools that are able to interact
    with and inspect the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, we will focus on web applications since they
    are the main focus of this book. Accordingly, if we are testing web APIs, we just
    need `HttpClient` instances since they can easily interact with web API endpoints
    in both XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of ASP.NET Core MVC applications that return HTML pages, the interaction
    is more complex, since we also need tools for parsing and interacting with the
    HTML page DOM tree. The `AngleSharp` NuGet package is a great solution since it
    supports state-of-the-art HTML and minimal CSS and has extension points for externally
    provided JavaScript engines, such as Node.js. However, we don't advise you to
    include JavaScript and CSS in your tests, since they are strictly tied to target
    browsers, so the best option for them is to use JavaScript-specific test tools
    that you can run directly in the target browsers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic options for testing a web application with the `HttpClient`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Staging application**. An `HttpClient` instance connects with the actual
    *staging* web application through the internet/intranet, together with all other
    humans who are beta-testing the software. The advantage of this approach is that
    you are testing the *real stuff*, but tests are more difficult to conceive since
    you can''t control the initial state of the application before each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controlled application**. An `HttpClient` instance connects with a local
    application that is configured, initialized, and launched before every single
    test. This scenario is completely analogous to the unit test scenario. Test results
    are reproducible, the initial state before each test is fixed, tests are easier
    to design, and the actual database can be replaced by a faster and easier-to-initialize
    in-memory database. However, in this case, you are far from the actual system''s
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good strategy is to use a **controlled application**, where you have full
    control of the initial state, for testing all extreme cases, and then use a **staging
    application** for testing random average cases on the *real stuff*.
  prefs: []
  type: TYPE_NORMAL
- en: The two sections that follow describe both approaches. The two approaches differ
    only in the way that you define the fixtures of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the staging application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, your tests need just an instance of `HttpClient`, so you must
    define an efficient fixture that supplies `HttpClient` instances, avoiding the
    risk of running out of Windows connections. We faced this problem in the *.NET
    Core HTTP clients* section of *Chapter 14*, *Applying Service-Oriented Architectures
    with .NET Core*. It can be solved by managing `HttpClient` instances with `IHttpClientFactory`
    and injecting them with dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a dependency injection container, we can enrich it with the capability
    of efficiently handling `HttpClient` instances with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `AddHTTPClient` extension belongs to the `Microsoft.Extensions.DependencyInjection`
    namespace and is defined in the `Microsoft.Extensions.Http` NuGet package. Therefore,
    our test fixture must create a dependency injection container, call `AddHttpClient`,
    and finally build the container. The following fixture class does this job (please
    refer to the *Advanced test preparation and tear-down scenarios* section of *Chapter
    18*, *Testing Your Code with Unit Test Cases and TDD*, if you don''t remember
    fixture classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding definition, your tests should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In `Test1`, once you get an HTTP client, you can test the application by issuing
    an HTTP request and then by analyzing the response returned by the application.
    More details on how to process the response returned by the server will be given
    in the *Use case* section.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to test an application that runs in a controlled
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a controlled application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we create an ASP.NET Core server within the test application and
    test it with an `HTTPClient` instance. The `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package contains all that we need to create both an HTTP client and the
    server running the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Mvc.Testing` contains a fixture class that does the job
    of launching a local web server and furnishing a client for interacting with it.
    The predefined fixture class is `WebApplicationFactory<T>`. The generic `T` argument
    must be instantiated with the `Startup` class of your web project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests look like the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to analyze the HTML of the returned pages, you must also reference
    the `AngleSharp` NuGet package. We will see how to use it in the example of the
    next section. The simplest way to cope with databases in this type of test is
    to replace them with in-memory databases that are faster and automatically cleared
    whenever the local server is shut down and restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by creating a new deployment environment, say, `AutomaticStaging`,
    and an associate configuration file that is specific to the tests. After having
    created this new deployment environment, go to the `ConfigureServices` method
    of your application''s `Startup` class and locate the place where you add your
    `DBContext` configuration. Once you''ve located that place, add an `if` there
    that, if the application is running in the `AutomaticStaging` environment, replaces
    your `DBContext` configuration with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, you can also add all the required instructions to clear
    a standard database in the constructor of a custom fixture that inherits from
    `WebApplicationFactory<T>`. Note that deleting all database data is not as easy
    as it might appear, because of integrity constraints. You have various options,
    but none is the best for all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the whole database and recreate it using migrations, that is, `DbContext.Database.Migrate()`.This
    always works, but it is slow and requires a database user with high privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable database constraints and then clear all tables in any order. This technique
    sometimes doesn't work and requires a database user with high privileges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all data in the right order, thus without violating all database constraints.
    This is not difficult if you keep an ordered delete list of all tables while the
    database grows and you add tables to the database. This delete list is a useful
    resource that you may also use to fix issues in database update operations and
    to remove old entries during production database maintenance. Unfortunately, this
    method also fails in the rare case of circular dependencies, such as a table that
    has a foreign key referring to itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I prefer method 3 and revert to method 2 only in the rare case of difficulties
    due to circular dependencies. As an example of method 3, we can write a fixture
    that inherits from `WebApplicationFactory<Startup>` and deletes all test records
    of the application of *Chapter 18*, *Testing Your Code with Unit Test Cases and
    TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is enough to delete the data of packages, destinations, and events if you
    don''t need to test the authentication/authorization subsystem. The deletion order
    is straightforward; events must be deleted first since nothing depends on them,
    and then we can delete packages that depend on destinations, and finally the destinations
    themselves. The code is quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We get a `DBContext` instance from the services inherited from `WebApplicationFactory<Startup>`,
    so you can perform database operations. The only way to delete all data from a
    table simultaneously is through a direct database command. Therefore, since in
    this case we can't use the `SaveChanges` method to enclose all changes in a single
    transaction, we are forced to create a transaction manually.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the class above by adding it to the use case of the next chapter,
    which is based on the code of *Chapter 18*, *Testing Your Code with Unit Test
    Cases and TDD*, too.
  prefs: []
  type: TYPE_NORMAL
- en: Use case â€“ automating functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add a simple functional test to the ASP.NET Core test
    project of *Chapter 18*, *Testing Your Code with Unit Test Cases and TDD*. Our
    test approach is based on the `Microsoft.AspNetCore.Mvc.Testing` and `AngleSharp`
    NuGet packages. Please make a new copy of the whole solution.
  prefs: []
  type: TYPE_NORMAL
- en: The test project already references the ASP.NET Core project under `test` and
    all the required xUnit NuGet packages, so we need to add just the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a new class file called `UIExampleTest.cs`. We need `using`
    statements to reference all the necessary namespaces. More specifically, we need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using PackagesManagement;`: This is needed to reference your application classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using Microsoft.AspNetCore.Mvc.Testing;`: This is needed to reference the
    client and server classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using AngleSharp;` and `using AngleSharp.Html.Parser;`: These are needed to
    reference `AngleSharp` classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO`: This is needed in order to extract HTML from HTTP responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using Xunit`: This is needed to reference all `xUnit` classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summing up, the whole `using` block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the standard fixture class we introduced in the previous *Testing
    a controlled application* section to write the following test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to write a test for the home page! This test verifies that
    the home URL returns a successful HTTP result and that the home page contains
    a link to the package management page, which is the `/ManagePackages` relative
    link.
  prefs: []
  type: TYPE_NORMAL
- en: It is fundamental to understand that automatic tests must not depend on the
    details of the HTML, but that they must verify just logical facts, in order to
    avoid frequent changes after each small modification of the application HTML.
    That's why we just verify that the necessary links exist without putting constraints
    on where they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our home page test `TestMenu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step of each test is the creation of a client. Then, if the test
    needs the analysis of some HTML, we must prepare the so-called `AngleSharp` browsing
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration object specifies options such as cookie handling and other
    browser-related properties. At this point, we are ready to require the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a first step, we verify that the response we received contains a success
    status code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method call throws an exception in the case of an unsuccessful
    status code, hence causing the test to fail. HTML analysis needs to be extracted
    from the response. The following code shows a simple way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must pass the extracted HTML to our previous `AngleSharp` browsing
    context object, so it can build a DOM tree. The following code shows how to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `OpenAsync` method executes a DOM-building activity with the settings contained
    in `context`. The input for building the DOM document is specified by the lambda
    function passed as an argument to `OpenAsync`. In our case, `req.Content(...)`
    builds a DOM tree from the HTML string passed to the `Content` method, which is
    the HTML contained in the response received by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a `document` object is obtained, we can use it as we would use it in JavaScript.
    In particular, we can use `QuerySelector` to find an anchor with the required
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains is to verify that `node` is not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done it! If you want to analyze pages that require a user to be logged
    in or other more complex scenarios, you need to enable cookies and automatic URL
    redirects in the HTTP client. This way, the client will behave like a normal browser
    that stores and sends cookies and that moves to another URL whenever it receives
    a `Redirect` HTTP response. This can be done by passing an options object to the
    `CreateClient` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding setup, your tests can do everything a normal browser can
    do. For instance, you can design tests where the HTTP client logs in and accesses
    pages that require authentication since `HandleCookies=true` lets the authentication
    cookie be stored by the client and be sent in all subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains the importance of functional tests, and how to define
    detailed manual tests to be run on the output of each sprint. At this point, you
    should be able to define automatic tests to verify that, at the end of each sprint,
    your application complies with its specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Then, this chapter analyzed when it is worth automating some or all functional
    tests and described how to automate them in ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: A final example showed how to write ASP.NET Core functional tests with the help
    of `AngleSharp` to inspect the responses returned by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After many chapters discussing the best practices and approaches to developing
    solutions using C# 9 and .NET 5, together with the most up to date cloud environments
    in Azure, you have finally reached the end of this book.
  prefs: []
  type: TYPE_NORMAL
- en: As you've probably already noticed during your career, it is not a simple task
    to develop software on time, on budget, and with the functionalities your customer
    needs. The primary aim of this book goes beyond showing best practices in the
    elementary areas of the software development cycle. It also demonstrates how to
    use the features and benefits of the tools mentioned, to help you design scalable,
    secure, and high-performance enterprise applications with smart software design
    consideration. That is why the book covers different approaches in each broad
    area, beginning with the user requirements and finishing with the software in
    production, deployed and monitored continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about delivering software continuously, this book has emphasized the
    need of best practices for coding, testing, and monitoring your solution. It is
    not only a matter of developing a project; as a software architect, you will be
    responsible for the decisions you have made until this software is discontinued.
    Now, it is up to you decide the practices and patterns that best fit your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it always worth automating UI functional tests in the case of quick CI/CD
    cycles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the disadvantage of subcutaneous tests for ASP.NET Core applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the suggested technique for writing ASP.NET Core functional tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the suggested way of inspecting the HTML returned by a server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details on the `Microsoft.AspNetCore.Mvc.Testing` NuGet package and `AngleSharp`
    can be found in their respective official documentation at [https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests)
    and [https://anglesharp.github.io/](https://anglesharp.github.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Readers interested in JavaScript tests can refer to the Jasmine documentation:
    [https://jasmine.github.io/](https://jasmine.github.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Share your experience**Thank you for taking the time to read this book.
    If you enjoyed this book, help others to find it. Leave a review at [https://www.amazon.com/dp/1800566042](https://www.amazon.com/dp/1800566042).
    |'
  prefs: []
  type: TYPE_TB
