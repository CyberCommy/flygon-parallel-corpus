- en: Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been writing applications targeting the web platform for many years,
    you'll have seen just how many changes the web has gone through. What started
    off as a simple document viewer now sees us having to deal with complex build
    steps, state management patterns, continuous review of performance and compatibility,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the popularity of JavaScript and subsequent tooling means that there
    are templates and tried-and-tested techniques that we can use to optimize our
    application and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vue-pwa` template from the Vue CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of Progressive Web Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ngrok to view localhost applications on any device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Firebase hosting to deploy web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration and what it means for large-scale projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically running tests on each Git `commit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically deploying to Firebase hosting on each Git `commit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive Web Applications (PWAs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PWAs can be defined as applications that use the capabilities of the modern
    web to deliver thoughtful, engaging, and interactive experiences. My definition
    of PWAs is one that encompasses the principle of progressive enhancement. We could
    certainly take advantage of everything that PWAs have to offer, but we don't have
    to (or at least not all at once).
  prefs: []
  type: TYPE_NORMAL
- en: This means that not only are we continuing to improve our application over time,
    but adhering to these principles forces us to think in the perspective of a user
    who has bad internet connectivity, wants an offline-first experience, needs home-screen
    accessible apps, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the Vue CLI makes this process easy for us, as it provides a PWA
    template. Let''s create a new Vue application with the appropriate template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this chapter, we'll be looking at the benefits that this template
    gives us, and ways we can make both our application and operations more progressive.
  prefs: []
  type: TYPE_NORMAL
- en: Web application manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have seen the benefits of applications that use a web app manifest already—if
    you've ever been on a website that asks you to install this on your home screen
    or if you've noticed that the color of the address bar change from default gray
    to a different color on Android Chrome, that's a progressive app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head over to `static/manifest.json` and investigate the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have the option to give our application `name` and `short_name`; these will
    be shown when installing on the home screen of a device.
  prefs: []
  type: TYPE_NORMAL
- en: The `icons` array is used to provide varying sizes of our icon for a high-definition
    experience across devices. The `start_url` defines the file to be loaded upon
    startup when installed on a user's home screen and thus points toward `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: We can change how our application appears when running on a device as a PWA
    with the display attribute. There are various options available, such as `browser`,
    `standalone`, `minimal-ui`, and `fullscreen`. Each one changes how our application
    is displayed on the device; [(https://developers.google.com/web/fundamentals/web-app-manifest/)](https://developers.google.com/web/fundamentals/web-app-manifest/)
  prefs: []
  type: TYPE_NORMAL
- en: 'here''s an example of both browser and standalone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c9ee94d-9fc1-4205-b005-b02e594ca17b.jpg)Display options—the web
    app manifest'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also take advantage of the `background_color` option to change the color
    of the splash screen background when our PWA starts, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff35908d-7857-4d28-8de5-d8ba20026233.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to change the color of the toolbar, we can use the `theme_color`
    option (we'll look at an example as we move ahead).
  prefs: []
  type: TYPE_NORMAL
- en: There are other options you can pass to your web app manifest and you should
    customize these based on the needs of your project. You can find more information
    about the web app manifest on MDN at [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest).
  prefs: []
  type: TYPE_NORMAL
- en: Testing on a device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to test our application on a device without worrying about deployment,
    we could use a tool, such as ngrok, to create a tunnel between our localhost and
    the outside world. This allows us to view our application on any device with a
    public URL, and once we close the connection, the URL and subsequent application
    disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Download ngrok by navigating to [https://ngrok.com/download](https://ngrok.com/download)
    and following the installation steps for your platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ngrok also can be installed via `npm` typing :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As our Vue application is running on port `8080`, we can start ngrok and tell
    it to serve from that port. Run the following command in your Terminal with ngrok
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the following result in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/590ca896-1bf2-4b16-82f3-f1ed6210898d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then navigate to this URL on any device and see the following results
    on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/01bef090-dc5b-4f04-85e7-29a8ccc3b00d.png)'
  prefs: []
  type: TYPE_IMG
- en: Isn't this much more of a native experience? Now we have a colored address/status
    bar by default. We also get access to much more with the power of `ServiceWorker`
    in production mode. Before we dive into that, let's look at how we can deploy
    our application to a more permanent URL using Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a platform by Google that allows us to take advantage of everything
    from real-time databases, remote configuration, push notifications, and much more.
    Perhaps more important for our use case is the potential for static file deployment,
    and this is something we'll be taking advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: The platform has three different packages available, each offering different
    levels of service, with the first tier being free and then the following two tiers
    requiring payment.
  prefs: []
  type: TYPE_NORMAL
- en: Start off by navigating to [https://firebase.google.com](https://firebase.google.com)
    and logging in with a Google account by clicking on SIGN IN, and then, click GO
    TO CONSOLE at the top right.
  prefs: []
  type: TYPE_NORMAL
- en: We can then create a new Firebase project by selecting + Add Project on the
    Firebase dashboard and subsequently selecting a project name and country.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then navigate to Project Overview, where we can choose to add Firebase
    to our project and a variety of other options. We''re looking for hosting, as
    we''re interested in deploying our static content. From the left-side menu, click
    on Hosting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab2db5b9-7017-4dfa-8cc8-365832a10d2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll be on this screen quite a bit, as it allows us to revert deployments
    as well as see other usage metrics. Since we haven''t made our first deployment
    yet, the screen will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f572484c-22ef-4e0d-93e2-ce4456de2aa4.png)'
  prefs: []
  type: TYPE_IMG
- en: If we click on GET STARTED, we will receive a message stating that we need to
    download the Firebase tools. This is a CLI that allows us to manage our Firebase
    project from within the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Firebase tools by running the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then follow the steps outlined in the next step of the hosting wizard,
    but we won''t be using the deployment step just yet. The wizard should look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43546367-de51-43c4-88a0-adc78faae885.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start off by logging in to the Firebase console by running the following
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Select a Google account and give it appropriate permissions. You should then
    be provided the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d5ec4dcb-64d6-4a21-ba96-27426bedf170.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then initialize a new Firebase project inside of our `vue-pwa` project.
    Run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can use the keyboard to navigate to hosting and select it
    with the spacebar. This should make the circle green and it tells Firebase that
    we'd like to set up hosting within our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/826a6ff0-0808-420e-b37a-1b39cd4ab76b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then have to match our local project with the one that''s inside of our
    Firebase dashboard. Select the project you created earlier from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a172175d-09f8-4b35-b194-088123863f48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should then ask you questions related to the setup—answer them like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa4c1662-0734-419f-bcb4-1d06be3865b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve now got the ability to deploy to Firebase at will. We''ll need to build
    our project for production to appropriately generate a `dist` folder with the
    contents of our application. Let''s run the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to deploy to Firebase, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After a short while, you should be given a navigable URL that contains our
    application served over HTTPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0cf75f6-3328-4737-bbb0-fc4b2294a661.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our Firebase dashboard has also been updated to reflect our deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e582605-e4f4-45f8-a9ca-0e9ab0070b81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we then navigate to the URL, we should get our project as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d3cb016-af9e-462c-9559-5759a1554014.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, because we built our application using a production build, we can disconnect
    it from Wi-Fi or check the offline box inside of your Developer Tools. Upon doing
    so, we will find that our application still runs as expected because we have a
    `ServiceWorker` running on all production builds.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration (CI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of CI platforms available, such as Travis, GitLab, Jenkins,
    and countless others. Each platform often serves a common goal, that is, automating
    deployment and the challenges that come along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we could deploy our site, run our tests, and continue with other items
    in our forever increasing build steps. Not only is this a tedious process, but
    it also gives us many opportunities to make mistakes. Furthermore, it also means
    that each step has to be documented for every member of the team, the documentation
    has to be kept up to date and is not exactly scalable across an organization.
  prefs: []
  type: TYPE_NORMAL
- en: For our examples, we'll be using Travis CI, and the first objective that I'd
    like to tackle is automatically running our unit tests. To do this, we'll need
    one or more unit tests inside of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered testing our Vue.js applications in the preceding chapter, so wouldn''t
    it be nice to automatically run our tests each time we push a new build? Let''s
    quickly set up some tests inside of our project and integrate it with Travis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add a new script that runs `jest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `jest` configuration to your `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can update our `babel` configuration inside of `.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make a sample test inside of `components/__test__/Hello.spec.js`
    that simply checks whether `msg` inside of our data matches a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we can then run `npm test` to execute our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba19775a-fe4a-45de-9bc8-9b714c48c367.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use continuous integration with Travis CI, we'll need to upload our project
    to GitHub. If you haven't already got Git on your machine, download it from [https://git-scm.com/](https://git-scm.com/)
    and subsequently create a GitHub account at [https://github.com](https://github.com).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new repository for your project at [https://github.com/new](https://github.com/new),
    or by clicking on the New repository button by clicking on the + at the top-right
    corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then give our repository a name and make the visibility either Public
    or Private:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c6d0311-8217-432f-b93e-4f8225b04c3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we click on the Create repository button, we're greeted with a variety
    of ways in which we can upload our repository to GitHub. The only problem is that
    we haven't made our PWA project a Git repository yet.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this inside Visual Studio Code or the command line. In Visual Studio
    Code, click on the New repository button. If you've just installed Git, you may
    need to restart your editor for this button to appear. This is how it should appear
    inside of Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3d74b11-3111-427a-8a0c-69d85f7e7deb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then make a new commit with a simple message, such as First commit,
    and subsequently click on the tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e4d55968-1c84-4824-a5af-69653acc9f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then push these changes up to the repository on GitHub by following
    the steps highlighted inside...or push an existing repository from the command
    line given in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b91594d3-5c01-4183-a84d-06c8fb3ff64c.png)'
  prefs: []
  type: TYPE_IMG
- en: Any future changes to our repository will be pushed to this remote repository.
    This is important because when we create our Travis account, it'll automatically
    get access to all of our GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s navigate to [https://travis-ci.org/](https://travis-ci.org/) and click
    on Sign in with GitHub.After giving Travis any necessary permissions, you should
    then be able to see a list of repositories attached to your account. We can tell
    Travis that we''d like it to watch for changes in this repository by flicking
    the switch to green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc84b945-494c-4bd3-96d4-93f1134903a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Travis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing to do is add an appropriate `.travis.yml` configuration file
    to our project. This will tell Travis what to do each time we push a build to
    GitHub. As such, there are two distinct phases that happen when we build with
    Travis:'
  prefs: []
  type: TYPE_NORMAL
- en: Travis installs any dependencies inside of our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis runs the build script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can hook into various stages of the build process such as `before_install`,
    `install`, `before_script`, `script`, `before_cache`, `after_success`, `after_failure`,
    `before_deploy`, `deploy`, `after_deploy`, and `after_script`. All of these are
    relatively self-explanatory, but if it seems like a lot to take in—don't worry,
    we'll only be hooking into a select few of these stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a file named `.travis.yml` to the root of our project and add options
    one step at a time. We can start off by defining the language of our project and
    as we''re using Node, the subsequent Node environment version also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `node_js` version I've selected matches the same as my environment (this
    can be checked with `node -v`), but if you need to target a specific version of
    Node (or more than one version), you can add them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add that we''d only like to trigger builds on the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will need to tell Travis what script to run from `package.json`. As
    we''d like to run our tests, we''ll be running the test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s state that we''d like to receive email notifications for every
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then push these changes to our repository and sync it with the origin,
    we should be able to watch our Travis console as it runs our tests. It may take
    a few minutes for Travis to start the build as follows, so be patient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28aff7c1-1f18-4322-b4be-5b0197661987.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we scroll down to the bottom of the log, you can see that our project was
    built for both productions and our tests run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3aea6f8a-e2c9-45b5-a82e-009aada9e3e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We can now run our tests and hook into various stages of the build
    process with Travis CI. Given that we're building our project for production on
    Travis, we should be able to deploy this build to Firebase automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `Hello.vue` component to have a new message (and also make
    our test fail):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Automatic deployment to Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can let Travis handle our deployment automatically, but we''ll need a way
    to give Travis access to our deployment token. We can get this token for CI environments
    by running the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After logging in to your Google account once again, you should be given a token
    inside of the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Keep the token for now, as we'll need it in a second.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate back to the Travis CI dashboard, and go to the settings for your project.
    Inside of the settings, we'll need to add an environment variable that we can
    then reference inside of our deployment script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FIREBASE_TOKEN` environment variable with the value equal to the token
    we got from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3a7bf3b-42b6-4cff-a3ed-c2ac301a3bde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then update our `.travis.yml` file to install the firebase tools in
    our CI environment, and if everything is successful, then deploy them to our Firebase
    hosting environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Make a new commit after changing this file and sync the repositories. This should
    then trigger a new build on Travis, and we can watch for the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ced00187-969a-42df-808a-e10cece1989a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our deployment failed **because our test(s) failed.** Note how our application
    hosted on Firebase didn't change at all. This is intended and is why we placed
    the deployment step inside `after_success` because if we have failing tests, we
    most likely don't want to be pushing this code to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our test(s) and push a new `commit` to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As all of our scripts passed with an exit code of 0 (no errors), the `after_success`
    hook was fired, pushing our project to Firebase Hosting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be614da3-476a-4cbe-a3a4-6aefd5a38048.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we check our application at the appropriate URL, we should see an updated
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5253fa7f-de41-4e35-adca-685c208b7ddc.png)'
  prefs: []
  type: TYPE_IMG
- en: Service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building our application for production using the `vue-pwa` template, it
    includes `ServiceWorker`. This is essentially a script that runs in the background
    and allows us to take advantage of offline-first approaches, push notifications,
    background sync, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will now also prompt our user to install the application on
    their home screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41b5d1ea-53c3-4d1f-87e2-f16dc8b9f890.png)'
  prefs: []
  type: TYPE_IMG
- en: If we are disconnected from the internet, we'd also get an offline-first experience,
    as the application still continues to function. This is one of the major benefits
    we get when using the `vue-pwa` template, and if you'd like to read more about
    `ServiceWorker` and see how you can customize this to your needs, Google has a
    great onboarding guide at [https://developers.google.com/web/fundamentals/primers/service-workers/](https://developers.google.com/web/fundamentals/primers/service-workers/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we investigated the PWA template from the Vue CLI and subsequently
    looked at how we can automatically deploy and test our application as it continues
    to grow. These principles allow us to continually ensure that we can spend more
    time developing features and less time maintaining deployment documentation and
    following rudimentary tasks each time.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we'll cover Nuxt, a framework that allows us to create
    server-side rendered/static applications using Vue. Nuxt also has an interesting
    folder-based routing structure, which gives us a lot of power when creating Vue
    applications.
  prefs: []
  type: TYPE_NORMAL
