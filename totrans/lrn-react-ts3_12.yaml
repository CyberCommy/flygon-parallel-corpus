- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1: TypeScript Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the five primitive types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`string`: Represents a sequence of Unicode characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: Represents both integers and floating-point numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: Represents a logical true or false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`: Represents a value that hasn''t been initialized yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`: Represents no value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will the inferred type be for the `flag`variable be in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`flag` will be inferred as the `boolean` type.'
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between an interface and a type alias?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main difference is that type aliases can't be extended or implemented from,
    like you can with interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: What is wrong with the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The constructor requires `name` and `unitPrice` to be passed. Here are two ways
    to resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the values in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the parameters optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we want our TypeScript program to support IE11, what should the `--target` compiler
    option be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should be `es5` because IE11 only supports up to ES5 features.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to get the TypeScript compiler to transpile ES6 JavaScript files?
    If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes! We can use the `--allowJS` setting to get the compiler to transpile JavaScript
    files.
  prefs: []
  type: TYPE_NORMAL
- en: How can we prevent`console.log()`statements from getting into our code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use tslint and the `"no-console"` rule to enforce this. This would be
    the rule in `tslint.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 2: What is New in TypeScript 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following function that draws a point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the following `point`variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How can we call the `drawPoint` function in a terse manner?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create another version of the `drawPoint` function that can call
    by passing the x, y, and z point values as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Internally in the implementation of `drawPoint` we draw the point from a tuple
    data type, `[number, number, number]`. How can we define the method parameter(s)
    with the required tuple?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In your implementation of `drawPoint`, how can you make the `z` point optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a function called `getData` that calls a web API to get some data. The
    number of different API resources is still growing, so we''ve chosen to use `any` as
    the return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How can we make `getData`more type-safe by leveraging the `unknown` type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What `build` flag can we use to determine which projects are out of date and
    need to be rebuilt without doing a rebuild?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3:  Getting Started with React and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, what are the `TSLint` settings for allowing debugger statements
    and logging to the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In JSX, how can we display a button with a label from a prop called `buttonLabel`
    in a class component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How can we make the `buttonLabel` prop optional and default to Do It?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a `?` before the type annotation in the interface for the props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a static `defaultProps` object at the top of the class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In JSX, how can we display the preceding button only if the state called `doItVisible`
    is true? Assume we already have a state type declared containing `doItVisible`
    and it has already been initialized in the constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How would we create a click handler for this button?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have a state type declared containing `doItDisabled`. It has also been initialized
    in the constructor. How would we set this state to disable the Do it button after
    we click it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the button is clicked when it is disabled, is the click handler still be
    invoked?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Which life cycle method would be used in a class component to add event handlers
    to a none React web component that lives in our React component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidMount`'
  prefs: []
  type: TYPE_NORMAL
- en: Which life cycle method would we then use to remove this event handler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentWillUnmount`'
  prefs: []
  type: TYPE_NORMAL
- en: We have a function component called `Counter`. It needs to contain a piece of
    state called `count` and a function to update it called `setCount`. How can we
    define this state and default the initial count to 10?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `Counter` component, we have a `decrement` function that needs
    to reduce `count` by 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How can this be implemented?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 4: Routing with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following `Route` that shows a list of customers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Will the `CustomersPage` component render when the page is `"/customers"`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Will the `CustomersPage` component render when the page is `"/customers/24322"`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: We only want the `CustomersPage` component to render when the path is `"/customers"`.
    How can we change the attributes on `Route` to achieve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `exact` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What would be the `Route` that could handle the path `"/customers/24322"`?
    It should put `"24322"` in a route parameter called `customerId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can then use `RouteComponentProps` as the `CustomerPage` props type and get
    access to `customerId` via `props.match.params.``customerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we catch paths that don't exist so that we can inform the user?
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure all the `Route` components are wrapped in a `Switch` component. We
    can then add a `Route` to a component that renders a not found message to the
    user as the last `Route` in Switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How would we implement a `search` query parameter in `CustomersPage`? So, `"/customers/?search=Cool
    Company"` would show customers the name Cool Company.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First we need the props type to be `RouteComponentProps` in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can the use `URLSearchParams` to get the `search` query parameter and do
    the search in the `componentDidMount` life cycle method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After a while we decide to change the `"customer"` paths to `"clients"`. How
    can we implement this so that users can still use the existing `"customer"` paths
    but have the paths automatically redirect to the new `"client"` paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `Redirect` component to redirect the old paths to the new paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 5: Advanced Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have an interface that represents a course result as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The grades can only be A, B, C, or D. How can we create a stronger typed version
    of the `grade` property in this interface?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following functions, which validate that numbers and strings are
    populated with a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How can we combine these into a single function called `isPopulated` with signature
    overloads?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use overload signatures and then a union type for `field` in the main
    function. We can then use the `typeof` type guard in the function to deal with
    the different branches of logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How can we implement a more flexible version of the `isPopulated` function with
    generics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use a generic function with a `typeof` type guard for the special branch
    of code for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the follow type alias of stages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How can we programmatically turn this into the union type `'Pending' | 'Started'
    | 'Completed'`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `keyof` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following union type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How can we programmatically create the following type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can map the type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 6: Component Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What special property does React give us to access a components children?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A property called `children`
  prefs: []
  type: TYPE_NORMAL
- en: How many components can share state with React context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As many components as we like that are under the provider component in the component hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: When consuming the React context, what pattern does it use to allow us to render
    our content with the context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The render props pattern
  prefs: []
  type: TYPE_NORMAL
- en: How many render props can we have in a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As many as we like
  prefs: []
  type: TYPE_NORMAL
- en: How many children props do we have in a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'We only used `withLoader` on the product page. We have the following function
    in `ProductData.ts` to get all the products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Can you use this to implement a loader spinner on the products page by consuming
    the `withLoader` HOC.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we split `ProductPage` into a container and presentational component.
    The presentational component will render the product list exporting it wrapped
    in the `withLoader` HOC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then can consume this in `ProductPage` as follows in its `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Is it possible to create a loader spinner using the children props pattern?
    So, the consuming JSX would be something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If so, have a go at implementing it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 7:  Working with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extend our generic `Field` component to include a number editor using the native
    number input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firstly, add `"Number"` to the `type` prop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the `"Number"` type when rendering the `input`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implement an urgency field on the Contact Us form to indicate how urgent a response
    is. The field should be numeric.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following field immediately after the notes field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Implement a new validator function in the generic `Form` component, that validates
    a number is between two other numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following function in `Form.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Implement a validation rule on the urgency field to ensure it is between 1 and
    10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firstly import the `between` validator into `ContactUs.tsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the rule on urgency in the `validationRules` prop in `ContactUs.tsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Our validation triggers when a users clicks in and out of a field without typing
    anything. How can we just trigger validation, still when a field loses focus but
    only when it has been changed? Have a go at an implementation for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to track whether a field has been touched in the form state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the `touched` values for each field to `false` in the constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setValue` method, we update the `touched` value to `true` for the field
    being updated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the validate method, we check whether the field has been touched
    and if not, we return an empty array to indicate the field is valid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 8: React Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is the `type` property in action objects required? And does this property need
    to be called `type`? Can we call it something else?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `type` property is required in the action objects and must be called `type`.
  prefs: []
  type: TYPE_NORMAL
- en: How many properties can the action object contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As many as we like! It needs to include at least one for the `type` property.
    It can then include as many other properties as we need in order for the reducer
    to change the state but this is generally lumped in one additional property. So,
    generally an action will have one or two properties.
  prefs: []
  type: TYPE_NORMAL
- en: What is an action creator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An action creator is a function that returns an action object. Components invoke
    these functions in order to make a change to the state in the store.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we need Redux Thunk in our Redux store in our React shop app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, a Redux store can't manage asynchronous action creators. Middleware
    needs to be added to the Redux store in order to facilitate asynchronous action
    creators. Redux Thunk is the middleware we added to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Could we have used something else other than Redux Thunk?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes! We could have created our own middleware. There are other well-established
    libraries that we could have used as well, such as Redux Saga.
  prefs: []
  type: TYPE_NORMAL
- en: In our `basketReducer` we have just implemented, why didn't we just use the `push` function
    to add the item to the basket state? What is wrong with the highlighted line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This mutates the product's state directly and makes the function impure. This
    is because we have changed the state argument, which lives outside the scope of
    our function. Breaking this rule, in this case, results in the basket summary
    not incrementing on the rendered page when the Add to basket button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9: Interacting with RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will the output be in the console if we run the following code in a browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We'd get a message saying that an uncaught error (Oops) has occurred. `The console.log` statement
    wouldn't be reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that post 9999 doesn''t exist, what would be the output in the console if
    we ran the following code in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/5e6e8f9f-dbfa-40f8-927c-05b97d901a61.png)'
  prefs: []
  type: TYPE_IMG
- en: The key thing is that an HTTP error doesn't get handled in the `catch` method
    with the `fetch` function.
  prefs: []
  type: TYPE_NORMAL
- en: If we did a similar exercise with `axios`, what would be the output in the console
    when running the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/3d06e29a-9e9a-45e6-82e9-dcdaa2d86a29.png)'
  prefs: []
  type: TYPE_IMG
- en: The key thing is that an HTTP error does get handled in the `catch` method with
     `axios`.
  prefs: []
  type: TYPE_NORMAL
- en: What is a benefit of using the native `fetch` over `axios`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are targeting modern browsers (and not IE) and only require simple REST
    API interaction then `fetch` is arguably more favorable than `axios` because our
    code isn't dependent on third-party code.  It will also probably run a little
    faster because there is less non-native code being executed.
  prefs: []
  type: TYPE_NORMAL
- en: How can we add a bearer token to the following `axios` request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter is an object literal that has a `header` property that
    can contain HTTP headers for the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the following `axios` `PUT` request to update a post title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The body hasn't changed though – it's just the title we want to update. How
    can we change this to a `PATCH` request to make this REST call more efficient?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented a function component to display a post. It uses the following
    code to get the post from a REST API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with the preceding code?
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter in the `useEffect` function is missing, which means the
    REST API will be called every time the component is rendered. An empty array should
    be supplied as the second parameter so that the REST API is only called on the
    first render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 10: Interacting with GraphQL APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the GitHub GraphQL Explorer, create a query to return the last five open
    issues in the React project. Return the issue title and the URL in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Enhance the last query, make the number of issues that is returned a parameter,
    and make this default to 5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mutation in the GitHub GraphQL Explorer to unstar a starred repository.
    The mutation should take a repository ID as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: What part of the HTTP request does the GraphQL query go in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP body
  prefs: []
  type: TYPE_NORMAL
- en: What part of the HTTP request does the GraphQL mutation go in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP body
  prefs: []
  type: TYPE_NORMAL
- en: How can we make the response from the `react-apollo` `Query` component type
    safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another component that extends `Query` passing in a type for the result
    as a generic parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We can then use the `MyQuery` component in our JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Is caching on or off by default when you scaffold a project with `react-boost`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On'
  prefs: []
  type: TYPE_NORMAL
- en: What prop can we use on the `Mutation` component to update the local cache?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `update` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11: Unit Testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we are implementing a Jest test and we have a variable called `result`, which
    we want to check isn't `null`. How can we do this with Jest matcher functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we have variable called `person` that is of type `IPerson`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to check that the `person` variable is `{ id: 1, name: "bob" }`. How
    can we do this with Jest matcher functions?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Is it possible to carry out our check in the last question with a Jest snapshot
    test? If so how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented a component called `CheckList`, which renders text from
    an array in a list. Each list item has a checkbox so that the user can select
    list items. The component has a function prop called `onItemSelect` that is called
    when a user selects an item by checking the checkbox. We are implementing a test
    to verify that the `onItemSelect` prop works. The following line of code renders
    the component in the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How can we use a Jest mock function for `handleListItemSelect` and check that
    it is called?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the implementation of `SimpleList` in the last question, the `onItemSelect` function
    takes in a parameter called `item` which is the `string` value that the user has
    selected. In our test, let's pretend we have already simulated the user selecting
    `"Banana"` . How can we check the `onItemSelect` function was called with the
    item parameter being `"Banana"`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In the implementation of `SimpleList` in the last two questions, the text is
    displayed using a label that is tied to the checkbox is using the `for` attribute.
    How can we use functions in React Testing Library to firstly locate the `"Banana"`
    checkbox and then check it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we found out the coverage was low in our code that rendered
    posts from the JSONPlaceholder REST API. One of the areas that wasn''t covered
    was handling HTTP error codes in the `componentDidMount` function when we get
    the posts from the REST API. Create a test to cover this area of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A test ID needs to be added to the `App` component code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
