- en: '*Chapter 7*: Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：集合'
- en: In the previous chapter, we learned about generic programming in C#. One of
    the most important applications of generics is creating generic collections. A
    **collection** is a group of objects. We learned how to use arrays in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
    However, arrays are sequences of a fixed size and in most cases, we need to work
    with sequences of variable size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了C#中的泛型编程。泛型的最重要的应用之一就是创建泛型集合。**集合**是一组对象。我们学习了如何在[*第2章*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036)，*数据类型和运算符*中使用数组。然而，数组是固定大小的序列，在大多数情况下，我们需要处理可变大小的序列。
- en: The .NET frameworks provide generic classes that represent various types of
    collections, such as list, queue, set, map, and others. Using these classes, we
    can easily perform operations such as insert, update, delete, sort, and search
    on a collection of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架提供了代表各种类型集合的泛型类，如列表、队列、集合、映射等。使用这些类，我们可以轻松地对对象集合执行插入、更新、删除、排序和搜索等操作。
- en: 'You will learn about the following generic collections in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下泛型集合：
- en: The `List<T>` collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`集合'
- en: The `Stack<T>` collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`集合'
- en: The `Queue<T>` collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>`集合'
- en: The `LinkedList<T>` collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`集合'
- en: The `Dictionary<TKey, TValue>` collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`集合'
- en: The `HashSet<T>` collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet<T>`集合'
- en: By the end of this chapter, you will have a good understanding of the most important
    collections in .NET, what data structures they model, what the differences are
    between them, and when you should use them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对.NET中最重要的集合有很好的理解，它们模拟了什么数据结构，它们之间的区别是什么，以及何时应该使用它们。
- en: All the collections mentioned previously are not thread-safe. This means they
    cannot be used in multi-threaded scenarios when a thread might be reading while
    another might be writing to the same collection, without using external synchronization
    mechanisms. However, .NET also provides several thread-safe collections in the
    `System.Collections.Concurrent` namespace that use efficient locking or lock-free
    synchronization mechanisms, and, in many scenarios, provide better performance
    than the generic collections with external locks. In this chapter, we will also
    provide a walkthrough of these collections and learn about the scenarios when
    it's suitable to use them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的所有集合都不是线程安全的。这意味着它们不能在多线程场景中使用，当一个线程可能在读取时，另一个线程可能在写入相同的集合，而不使用外部同步机制。然而，.NET还提供了几个线程安全的集合，它们位于`System.Collections.Concurrent`命名空间中，使用高效的锁定或无锁同步机制，在许多情况下，提供比使用外部锁更好的性能。在本章中，我们还将介绍这些集合，并了解何时适合使用它们。
- en: Let's start with an overview of the generic collection library by looking at
    the `System.Collections.Generic` namespace, which is where all the generic collections
    are located.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看`System.Collections.Generic`命名空间来概述泛型集合库，这是所有泛型集合的所在地。
- en: Introducing the System.Collections.Generic namespace
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍System.Collections.Generic命名空间
- en: 'The generic collection classes that we will present in this chapter are a part
    of the `System.Collections.Generic` namespace. This namespace contains interfaces
    and classes that define generic collections and operations. All the generic collections
    implement a series of generic interfaces, which are also defined in this namespace.
    These can be broadly grouped into two categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章介绍的泛型集合类是`System.Collections.Generic`命名空间的一部分。该命名空间包含定义泛型集合和操作的接口和类。所有泛型集合都实现了一系列泛型接口，这些接口也在该命名空间中定义。这些接口可以大致分为两类：
- en: '**Mutable**, which support operations for changing the content of the collection
    such as adding new, or removing existing elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变的，支持更改集合内容的操作，如添加新元素或删除现有元素。
- en: '**Read-only collections**, which do not provide methods for changing the content
    of the collection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读集合，不提供更改集合内容的方法。
- en: 'The interfaces that represent mutable collections are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表示可变集合的接口如下：
- en: '`IEnumerable<T>`: This is the base interface for all the other interfaces and
    exposes an enumerator that supports iterating through the elements of a collection
    of `T` type.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`：这是所有其他接口的基本接口，并公开一个支持遍历`T`类型集合元素的枚举器。'
- en: '`ICollection<T>`: This defines methods for manipulating generic collections—`Add()`,
    `Clear()`, `Contains()`, `CopyTo()`, and `Remove()`—as well as properties, such
    as `Count`. These members should be *self-explanatory*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICollection<T>`：这定义了操作泛型集合的方法——`Add()`、`Clear()`、`Contains()`、`CopyTo()`和`Remove()`——以及`Count`等属性。这些成员应该是*不言自明*的。'
- en: '`IList<T>`: This represents a generic collection whose elements can be accessed
    by an *index*. It defines three methods: `IndexOf()`, which retrieves the index
    of an element, `Insert()`, which inserts an element at the specified index, and
    `RemoveAt()`, which removes the element at the specified index, in addition, it
    also provides an indexer for direct element access for direct element access.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IList<T>`：表示可以通过*索引*访问其元素的泛型集合。它定义了三种方法：`IndexOf()`，用于检索元素的索引，`Insert()`，用于在指定索引处插入元素，`RemoveAt()`，用于移除指定索引处的元素，此外，它还提供了一个用于直接访问元素的索引器。'
- en: '`ISet<T>`: This is the base interface that abstracts set collections. It defines
    methods such as `Add()`, `ExceptWith()`, `IntersetWith()`, `UnionWith()`, `IsSubsetOf()`,
    and `IsSupersetOf()`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISet<T>`：这是抽象集合集合的基本接口。它定义了诸如`Add()`、`ExceptWith()`、`IntersetWith()`、`UnionWith()`、`IsSubsetOf()`和`IsSupersetOf()`等方法。'
- en: '`IDictionary<TKey, TValue>`: This is the base interface that abstracts a collection
    of key-value pairs. It defines the `Add()`, `ContainsKey()`, `Remove()`, and `TryGetValue()`
    methods, as well as an indexer and the `Keys` and `Values` properties, which return
    the collection of keys and values, respectively.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between these interfaces is shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B12346.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces that represent read-only collections are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`IReadOnlyCollection<T>`: This represents a read-only generic collection of
    elements. It only defines one member: the `Count` property.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyList<T>`: This represents a read-only generic collection of elements
    that can be accessed by an index. It only defines one member: a read-only indexer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyDictionary<TKey, TValue>`: This represents a read-only generic collection
    of key-value pairs. This interface defines the `ContainsKey()` and `TryGetValue()`
    methods, as well as the `Keys` and `Values` properties and a read-only indexer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, the relationship of these interfaces is shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The hierarchy of interfaces for read-only generic collections.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B12346.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The hierarchy of interfaces for read-only generic collections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Each generic collection implements several of these interfaces. For instance,
    `List<T>` implements `IList<T>`, `ICollection<T>`, `IEnumerable<T>`, `IReadOnlyCollection<T>`,
    and `IReadOnlyList<T>`. The following diagram shows all the interfaces being implemented
    by the generic collections that we will learn about in this chapter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A class diagram showing the most important generic collections'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: and the interfaces they implement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B12346.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – A class diagram showing the most important generic collections
    and the interfaces they implement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The inheritance hierarchy shown in these diagrams is actually a simplification
    of the actual one. All the generic collections have a non-generic equivalent.
    For instance, `IEnumerable<T>` is the generic equivalent of `IEnumerable`, `ICollection<T>`
    is the generic equivalent of `ICollection`, `IList<T>` is the generic equivalent
    of `Ilist`, and so on. These are legacy interfaces that are implemented by legacy
    collections such as `ArrayList`, `Queue`, `Stack`, `DictionaryBase`, `Hashtable`,
    and so on, all of which are available in the `System.Collections` namespace. These
    non-generic legacy collections are not strongly typed. Using generic collections
    is preferred for several reasons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: They offer the benefit of type safety. There is no need to derive from a base
    collection and implement type-specific members.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have better performance for value types because there is no boxing and
    unboxing of elements, a process that is necessary with a non-generic collection.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the generic collections provide functionalities that are not available
    in the non-generic ones, such as methods that accept delegates that can be used
    for searching or performing an action of each element.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you need to pass collections as arguments to functions or return collections
    from functions, you should avoid using concrete implementations and prefer using
    interfaces. `IEnumerable<T>` is suitable when you only want to iterate through
    the elements, but if you need to do that multiple times, you could use `IReadOnlyCollection<T>`.
    Read-only collections should be preferred in two cases:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: When a method does not modify the collection passed as an argument
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you return a collection if the collection is already in memory and the
    caller is not supposed to modify it
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, the most suitable interface varies from case to case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will introduce each of the most widely used type-safe
    generic collections. The non-generic collections are of little interest outside
    legacy code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍最常用的类型安全的泛型集合。非泛型集合在遗留代码之外几乎没有什么意义。
- en: The List<T> collection
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List<T> 集合
- en: The `List<T>` generic class represents a collection of elements that can be
    accessed by their index. `List<T>` is very similar to arrays, except that the
    size of the collection is not fixed but variable, and it can grow or decrease
    as elements are added or removed. In fact, the implementation of `List<T>` uses
    an array to store the elements. When the number of elements exceeds the size of
    the array, a new and larger array is allocated, and the content of the previous
    array is copied to the new one. This means that `List<T>` stores the elements
    in contiguous memory locations. However, for value types, these locations contain
    the values, but for reference types, they contain references to the actual objects.
    Multiple references to the same object can be added to a list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 泛型类表示可以通过索引访问其元素的集合。`List<T>` 与数组非常相似，只是集合的大小不是固定的，而是可变的，可以随着元素的添加或删除而增长或减少。事实上，`List<T>`
    的实现使用数组来存储元素。当元素的数量超过数组的大小时，将分配一个新的更大的数组，并将先前数组的内容复制到新数组中。这意味着 `List<T>` 在连续的内存位置中存储元素。但是，对于值类型，这些位置包含值，但对于引用类型，它们包含对实际对象的引用。可以将对同一对象的多个引用添加到列表中。'
- en: 'The `List<T>` class implements a series of generic and non-generic interfaces,
    as shown in the following declaration of the class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 类实现了一系列泛型和非泛型接口，如下面的类声明所示：'
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A list can be created in several ways:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过几种方式创建：
- en: Using the default constructor, which results in an empty list with a default
    capacity.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认构造函数，这会导致一个具有默认容量的空列表。
- en: By specifying a particular capacity but no initial elements, which again leaves
    the list empty.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定特定的容量但没有初始元素，这会再次使列表为空。
- en: From a collection of elements.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一系列元素中。
- en: 'In the following example, `numbers` is an empty list of integers and `words`
    is an empty list of strings:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`numbers` 是一个空的整数列表，`words` 是一个空的字符串列表：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On the other hand, the following sample initializes the list with some elements.
    The first list will contain six integers and the second list will contain two
    strings:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例初始化了一些元素的列表。第一个列表将包含六个整数，第二个列表将包含两个字符串：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class supports all the typical operations that you would expect from such
    a collection—adding, removing, and searching elements. There are several ways
    to add elements to the list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类支持你从这样的集合中期望的所有典型操作——添加、删除和搜索元素。有几种方法可以向列表中添加元素：
- en: '`Add()` adds an element to the end of the list.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()` 将元素添加到列表的末尾。'
- en: '`AddRange()` adds a collection of elements (in the form of an `IEnumerable<T>`)
    to the end of the list.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRange()` 将一系列元素（以 `IEnumerable<T>` 的形式）添加到列表的末尾。'
- en: '`Insert()` inserts an element at the specified position. The position must
    be a valid index, within the bounds of the list; otherwise, an `ArgumentOutOfRangeException`
    exception is thrown.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert()` 在指定位置插入一个元素。位置必须是有效的索引，在列表的范围内；否则，将抛出 `ArgumentOutOfRangeException`
    异常。'
- en: '`InsertRange()`inserts a range of elements (in the form of an `IEnumerable<T>`)
    at the specified index, which must be within the bounds of the list.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertRange()` 在指定的索引处插入一系列元素（以 `IEnumerable<T>` 的形式），该索引必须在列表的范围内。'
- en: All these operations may require the reallocation of the internal array that
    stores elements if its capacity is exceeded. `Add()` is an *O(1)* operation if
    no allocation is needed and *O(n)* when allocation is necessary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内部数组的容量超过了，所有这些操作可能需要重新分配存储元素的内部数组。如果不需要分配空间，`Add()` 是一个 *O(1)* 操作，当需要分配空间时，为
    *O(n)*。
- en: '`AddRange()` is *O(n)* if no allocation is necessary and *O(n+k)* if allocations
    are needed. `Insert()` is always an *O(n)* operation, and `InsertRange()` is *O(n)*
    if no allocation is needed and *O(n+k)* if an allocation is necessary. In this
    notation, *n* is the number of elements in the list and *k* is the number of elements
    to add. We can see an example of these operations in the following sample:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要分配空间，`AddRange()` 的时间复杂度为 *O(n)*，如果需要分配空间，则为 *O(n+k)*。`Insert()` 操作始终为
    *O(n)*，`InsertRange()` 如果不需要分配空间，则为 *O(n)*，如果需要分配空间，则为 *O(n+k)*。在这个表示法中，*n* 是列表中的元素数量，*k*
    是要添加的元素数量。我们可以在以下示例中看到这些操作的示例：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Removing the elements is also possible in several ways using different methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的方法也可以以几种方式删除元素：
- en: '`Remove()` removes the specified element from the list.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从列表中删除指定的元素。'
- en: '`RemoveAt()` removes the element at the specified index, which must be within
    the bounds of the list.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAt()` 删除指定索引处的元素，该索引必须在列表的范围内。'
- en: '`RemoveRange()` removes the specified number of elements, starting with the
    given index.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveRange()` 删除指定数量的元素，从给定的索引开始。'
- en: '`RemoveAll()` removes all the elements in the list that meet the requirements
    of the supplied predicate.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveAll()` 删除列表中满足提供的谓词要求的所有元素。'
- en: '`Clear()` removes all the elements in the list.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 删除列表中的所有元素。'
- en: 'All these operations are performed in *O(n)*, where *n* is the number of elements
    in the list. The exception is `RemoveAt()`, where *n* is `Count - index`. The
    reason for this is that the elements must be moved within the internal array after
    one has been removed. Examples of using these functions are shown in the following
    snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都在 *O(n)* 中执行，其中 *n* 是列表中的元素数量。`RemoveAt()` 是一个例外，其中 *n* 是 `Count - index`。原因是在删除一个元素后，必须在内部数组中移动元素。使用这些函数的示例在以下代码片段中显示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is possible to search for elements in the list by specifying a predicate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定谓词来搜索列表中的元素。
- en: Information box
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: A **predicate** is a delegate that returns a bool. They are typically used when
    you filter elements, such as when you search through a collection.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**谓词** 是返回布尔值的委托。它们通常用于过滤元素，例如在搜索集合时。'
- en: 'There are several methods that can be used to search elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`Find()` returns the first element that matches the predicate or the default
    value of `T` if none is found.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindLast()` returns the last element that matches the predicate or the default
    value of `T` if none is found.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindAll()` returns a `List<T>` with all the elements that match the predicate
    or an empty list if none is found.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these methods are performed in *O(n)*, as shown in the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is possible to search for the zero-based index of an element as well. There
    are several methods that allow us to do that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`IndexOf()` returns the index of the first element that is equal to the supplied
    argument.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LastIndexOf()` returns the last index of the searched element.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindIndex()` returns the index of the first element that satisfies the supplied
    predicate.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindLastIndex()` returns the index of the last element that satisfies the
    supplied predicate.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinarySearch()` returns the index of the first element that satisfies the
    supplied element or a comparer using binary search. This function assumes that
    the list is already sorted; otherwise, the result is incorrect.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinarySearch()` is performed in *O(log n)*, while all the others are performed
    in *O(n)*. This is because they use linear search. They all return `-1` if no
    element that satisfies the search criteria is found. Examples are shown in the
    following listing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are methods that allow us to modify the content of the list, such as
    by sorting the elements or reverting them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`Sort()` sorts the list according to a default or specified criteria. There
    are several overloads that allow us to specify either a comparison delegate or
    an `IComparer<T>` object, or even a sub-range of the list to sort. This operation
    is performed in *O(n log n)* in most cases but *O (n2)* in the worst-case scenario.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reverse()` reverses the elements in the list. There is an overload that allows
    you to specify a sub-range to revert. This operation is performed in *O(n)*.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of using these functions are shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are more methods in the `List<T>` class than those shown here. However,
    going through all of them is beyond the scope of this book. You should look up
    the official documentation of the class online for a complete reference to all
    the members of this class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The Stack<T> collection
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a linear data structure that allows us to insert and delete items
    in a particular order. New items are added at the top of the stack. If we want
    to remove an item from the stack, we can only remove the top item. Since insertion
    and deletion is allowed from only one end, the item to be inserted last will be
    the item to be deleted first. Therefore, the stack is called a **Last in**, **First
    Out (LIFO)** collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts a stack, where *push* represents adding an item
    to the stack and *pop* represents deleting an item from the stack:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The conceptual representation of a stack.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B12346.png)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The conceptual representation of a stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '.NET provides the generic `Stack<T>` class for working with stacks. This class
    contains several constructors that allow us to create either an empty stack or
    a stack initialized with a collection of elements. Take a look at the following
    code snippet, where we are creating a stack of strings with three initial elements
    and an empty stack of integers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The primary operations that are supported by the stack are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`Push()`: Inserts an item at the top of the stack. This is an *O(1)* operation
    if no reallocation is necessary and *O(n)* otherwise.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pop()`: Removes and returns the item from the top of the stack. This is an
    *O(1)* operation.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek()`: Returns an item from the top of the stack without removing it. This
    is an *O(1)* operation.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: Removes all the elements from the stack. This is an *O(n)* operation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand how these work with the help of the following example where,
    on the left, you can see the contents of the stack after each operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Pop()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the stack is empty. In .NET Core, since version 2.0, two alternative non-throwing
    methods are available—`TryPop()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an `out` argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The Queue<T> collection
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A queue is a linear data structure where insertion and deletion of elements
    is performed from two different ends. A new item is added from the rear end of
    the queue and deletion of existing items occurs from the front. Therefore, the
    item to be inserted first will be the item to be deleted first. Because of this,
    the queue is called a **First in**, **First Out (FIFO)** collection. The following
    diagram depicts a queue, where **Enqueue** represents adding an item to the queue
    and **Dequeue** represents deleting an item from the queue:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The conceptual representation of a queue.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B12346.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The conceptual representation of a queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET, the class that implements a generic queue is `Queue<T>`. Similarly,
    with `Stack<T>`, there are overloaded constructors that allow us to create an
    empty queue or a queue initialized with elements from an `IEnumerable<T>` collection.
    Take a look at the following code snippet, where we are creating a queue of strings
    with three initial elements and an empty queue of integers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The primary operations that are supported for the queue are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue()`: Inserts an item at the end of the queue. This operation is *O(1)*
    unless the internal array needs to be reallocated, in which case it becomes an
    *O(n)* operation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dequeue()`: Removes and returns an item from the front of the queue. This
    is an *O(1)* operation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek()`: Returns an item from the front of the queue without removing it.
    This is an *O(1)* operation.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: Removes all the elements from the queue. This is an *O(n)* operation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how these methods work, let''s look at the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Dequeue()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the queue is empty. In .NET Core, since version 2.0, two alternatives non-throwing
    methods are available—`TryDequeue()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an out argument.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, `Stack<T>` and `Queue<T>` have very similar
    implementations, although the semantics are different. Their public members are
    almost the same, with the difference being that the stack operations are called
    `Push()` and `Pop()` and the queue operations are called `Enqueue()` and `Dequeue()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The LinkedList<T> collection
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A linked list is a linear data structure that consists of a group of nodes
    where each node contains data as well as the address of one or more nodes. There
    are four types of linked list, as described here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Singly Linked List**: This contains nodes that store a value and a reference
    to the next node in the sequence of nodes. The reference to the next node of the
    last node will point to null.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doubly Linked List**: Here, each node contains two links – the first link
    points to the previous node and the next link points to the next node in the sequence.
    The reference to the previous node of the first node and the reference to the
    next node of the last node will point to null.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular Singly Linked List**: The reference to the next node of the last
    node will point to the first node, thus forming a circular chain.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doubly Circular Linked List**: In this type of linked list, the reference
    to the next node of the last node will point to the first node and the reference
    to the previous node of the first node will point to the last node.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A conceptual representation of the doubly linked list is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表的概念表示如下：
- en: '![Figure 7.6 – A conceptual representation of a doubly linked-list.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 双向链表的概念表示。'
- en: '](img/Figure_7.6_B12346.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B12346.jpg)'
- en: Figure 7.6 – A conceptual representation of a doubly linked-list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 双向链表的概念表示。
- en: Here, each node contains a value and two pointers. The **Next** pointer contains
    a reference to the next node in the sequence and allows easy navigation in the
    forward direction of the linked list. The **Prev** pointer contains a reference
    to the previous node in the sequence and allows us to move backward in the linked
    list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个节点包含一个值和两个指针。**Next** 指针包含对序列中下一个节点的引用，并允许在链表的正向方向上进行简单导航。**Prev** 指针包含对序列中前一个节点的引用，并允许我们在链表中向后移动。
- en: .NET provides the `LinkedList<T>` class, which represents a doubly linked list.
    This class contains items of the `LinkedListNode<T>` type. Insertion and removal
    operations are performed in *O(1)* and searching is performed in *O(n)*. Nodes
    can be removed and reinserted either in the same linked list object or another.
    The list maintains an internal count, so retrieving the size of the list using
    the `Count` property is also an *O(1)* operation. The linked list does not support
    cycles, splitting, chaining, or anything else that can leave the list in an inconsistent
    state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了 `LinkedList<T>` 类，表示双向链表。该类包含 `LinkedListNode<T>` 类型的项。插入和删除操作在 *O(1)*
    中执行，搜索在 *O(n)* 中执行。节点可以从同一链表对象或另一个链表中移除和重新插入。列表维护内部计数，因此使用 `Count` 属性检索列表的大小也是
    *O(1)* 操作。链表不支持循环、分割、链接或其他可能使列表处于不一致状态的操作。
- en: 'The `LinkedListNode<T>` class has the following four properties:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedListNode<T>` 类具有以下四个属性：'
- en: '`List`: This property will return the reference to the `LinkedList<T>` object
    to which `LinkedListNode<T>` belongs.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`：此属性将返回对 `LinkedList<T>` 对象的引用，该对象属于 `LinkedListNode<T>`。'
- en: '`Next`: Represents the reference to the next node in the `LinkedList<T>` object
    or `null` if the current node is the last node.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next`：表示对 `LinkedList<T>` 对象中下一个节点的引用，如果当前节点是最后一个节点，则为 `null`。'
- en: '`Previous`: Represents the reference to the previous node in the `LinkedList<T>`
    object or `null` if the current node is the first node.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Previous`：表示对 `LinkedList<T>` 对象中前一个节点的引用，如果当前节点是第一个节点，则为 `null`。'
- en: '`Value`: This property is of type `T` and represents the value contained in
    the node.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`：此属性的类型为 `T`，表示节点中包含的值。'
- en: For value types, `LinkedListNode<T>` contains the actual value, whereas for
    reference types, it contains a reference to the object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于值类型，`LinkedListNode<T>` 包含实际值，而对于引用类型，它包含对对象的引用。
- en: 'The class has overloaded constructors that enable us to create an empty linked
    list or one initialized with a sequence of elements, in the form of an `IEnumerable<T>`.
    Take a look at the following sample to see some examples:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有重载的构造函数，使我们能够创建一个空的链表或一个以 `IEnumerable<T>` 形式的元素序列进行初始化的链表。看一下以下示例，看一些示例：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding new elements to the linked list is possible in several ways using the
    following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法可以以多种方式向链表添加新元素：
- en: '`AddFirst()` adds a new node or value at the beginning of the list.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddFirst()` 在列表开头添加一个新节点或值。'
- en: '`AddLast()` adds a new node or value at the end of the list.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddLast()` 在列表末尾添加一个新节点或值。'
- en: '`AddAfter()` adds a new node or value in the list after the specified node.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddAfter()` 在指定节点之后的列表中添加一个新节点或值。'
- en: '`AddBefore()` adds a new node or value in the list before the specified node.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddBefore()` 在指定节点之前的列表中添加一个新节点或值。'
- en: 'We can see examples of the overload that adds a new value for each of these
    methods in the following sample:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到为这些方法添加新值的重载的示例：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Searching for elements in a linked list can be performed using one of the following
    methods:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法之一在链表中搜索元素：
- en: '`Contains()`: This checks whether a specified value is found in the list and
    returns a Boolean value to indicate success or failure.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains()`：这检查指定的值是否在列表中，并返回一个布尔值以指示成功或失败。'
- en: '`Find()`: This finds and returns the first node that contains the specified
    value.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Find()`：查找并返回包含指定值的第一个节点。'
- en: '`FindLast()`: This finds and returns the last node that contains the specified
    value.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindLast()`：查找并返回包含指定值的最后一个节点。'
- en: 'Examples of using these functions are shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些函数的示例：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Removing elements from the list can be done in several ways using the following
    methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法可以以多种方式从列表中移除元素：
- en: '`RemoveFirst()` removes the first node in the list.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveFirst()` 从列表中移除第一个节点。'
- en: '`RemoveLast()` removes the last node in the list.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveLast()` 移除列表中的最后一个节点。'
- en: '`Remove()` removes the specified node or the first occurrence of the specified
    value from the list.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从列表中移除指定的节点或指定值的第一个出现。'
- en: '`Clear()` removes all the elements from the list.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 从列表中移除所有元素。'
- en: 'You can see all these methods at work in the following listing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下列表中看到所有这些方法的工作方式：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The linked list class also has several properties, including `Count`, which
    returns the number of elements in the list, `First`, which returns the first node,
    and `Last`, which returns the last node. If the list is empty, then `Count` is
    `0` and `First` and `Last` are both set to `null`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 链表类还具有几个属性，包括 `Count`，它返回列表中的元素数量，`First`，它返回第一个节点，以及 `Last`，它返回最后一个节点。如果列表为空，则
    `Count` 为 `0`，`First` 和 `Last` 都设置为 `null`。
- en: The Dictionary<TKey, TValue> collection
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>` 集合'
- en: A dictionary is a collection of key-value pairs that allows fast lookup based
    on a key. Adding, searching, and deleting an item are very fast operations and
    are performed in *O(1)*. The exception here is adding a new value if the capacity
    must be increased, in which case it becomes *O(n)*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一组键值对，允许根据键进行快速查找。添加、搜索和删除项目都是非常快速的操作，并且在 *O(1)* 中执行。唯一的例外是在必须增加容量时添加新值，此时它变为
    *O(n)*。
- en: In .NET, the generic `Dictionary<TKey,TValue>` class implements a dictionary.
    `TKey` represents the type of the key and `TValue` represents the type of the
    value. The elements of the dictionary are `KeyValuePair<TKey,TValue>` objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，泛型`Dictionary<TKey,TValue>`类实现了一个字典。`TKey`表示键的类型，`TValue`表示值的类型。字典的元素是`KeyValuePair<TKey,TValue>`对象。
- en: '`Dictionary<TKey, TValue>` has several overloaded constructors that allow us
    to create an empty dictionary or a dictionary filled with some initial values.
    The default constructor of this class will create an empty dictionary. Take a
    look at the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>`有几个重载的构造函数，允许我们创建一个空字典或一个填充了一些初始值的字典。该类的默认构造函数将创建一个空字典。看一下以下代码片段：'
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we are creating an empty dictionary called `languages` that has a key
    of the `int` type and a value of the `string` type. We can also initialize a dictionary
    at the time of declaration. Consider the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为`languages`的空字典，它具有`int`类型的键和`string`类型的值。我们还可以在声明时初始化字典。考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are creating a dictionary that is initialized with four values that
    have the keys `1`, `2`, `3`, and `4`. This is semantically equivalent to the following
    initialization:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个字典，该字典初始化了四个具有键`1`、`2`、`3`和`4`的值。这在语义上等同于以下初始化：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A dictionary must contain unique keys; however, the value can be *duplicated*.
    Similarly, a key cannot be `null`, but a value (if it is of a reference type)
    can be `null`. To add, remove, or search for dictionary values, we can use the
    following methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 字典必须包含唯一的键；但是，值可以是*重复*的。同样，键不能是`null`，但是值（如果是引用类型）可以是`null`。要添加、删除或搜索字典值，我们可以使用以下方法：
- en: '`Add()`: This adds a new value with the specified key to the dictionary. If
    the key is `null` or the key already exists in the dictionary, an exception is
    thrown.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()`：这向字典中添加具有指定键的新值。如果键为`null`或键已存在于字典中，则会抛出异常。'
- en: '`Remove()`: This removes the value with the specified key.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()`：这删除具有指定键的值。'
- en: '`Clear()`: This removes all the values from the dictionary.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`：这从字典中删除所有值。'
- en: '`ContainsKey()`: This checks if the dictionary contains the specified key and
    returns a Boolean value to indicate that.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsKey()`：这检查字典是否包含指定的键，并返回一个布尔值以指示。'
- en: '`ContainsValue()`: This checks if the dictionary contains the specified value
    and returns a Boolean value to indicate that. The method performs a linear search;
    therefore, it is an *O(n)* operation.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContainsValue()`：这检查字典是否包含指定的值，并返回一个布尔值以指示。该方法执行线性搜索；因此，它是一个*O(n)*操作。'
- en: '`TryGetValue()`: This checks whether the dictionary contains the specified
    key and if so, it returns the associated value as an `out` argument. The method
    returns `true` if the value was successful fetched or `false` otherwise. If the
    key is not present, the output parameter is set to the default value of the `TValue`
    type (that is, `0` for numerical types, `false` for bool, and `null` for reference
    types).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryGetValue()`：这检查字典是否包含指定的键，如果是，则将关联的值作为`out`参数返回。如果成功获取了值，则该方法返回`true`，否则返回`false`。如果键不存在，则输出参数设置为`TValue`类型的默认值（即数值类型为`0`，布尔类型为`false`，引用类型为`null`）。'
- en: In .NET Core 2.0 and newer, there is one additional method called `TryAdd()`
    that attempts to add a new value to the dictionary. The method succeeds only if
    the key is not already present. It returns a Boolean value to indicate success
    or failure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 2.0及更高版本中，还有一个名为`TryAdd()`的额外方法，它尝试向字典中添加新值。该方法仅在键尚未存在时成功。它返回一个布尔值以指示成功或失败。
- en: 'The class also contains a set of properties, the most important of them being
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含一组属性，其中最重要的是以下属性：
- en: '`Count`: This returns the number of key-value pairs in the dictionary.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：这返回字典中键值对的数量。'
- en: '`Keys`: This returns a collection (of the `Dictionary<TKey,TValue>.KeyCollection`
    type) containing all the keys in the dictionary. The order of the keys in this
    collection is not specified.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Keys`：这返回一个集合（类型为`Dictionary<TKey,TValue>.KeyCollection`）包含字典中的所有键。此集合中键的顺序未指定。'
- en: '`Values`: This returns a collection (of the `Dictionary<TKey,TValue>.ValueCollection`
    type) containing all the values in the dictionary. The order of the values in
    this collection is not specified but it is guaranteed to be in the same order
    as their associated keys in the `Keys` collection.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Values`：这返回一个集合（类型为`Dictionary<TKey,TValue>.ValueCollection`）包含字典中的所有值。此集合中值的顺序未指定，但保证与`Keys`集合中的关联键的顺序相同。'
- en: '`Item[]`: This is an indexer that gets or sets the value associated with the
    specified key. The indexer can be used to add values to the dictionary. If the
    key does not exist, a new key-value pair is added. If the key already exists,
    the value is overwritten.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Item[]`：这是一个索引器，用于获取或设置与指定键关联的值。索引器可用于向字典中添加值。如果键不存在，则会添加新的键值对。如果键已存在，则值将被覆盖。'
- en: 'Take a look at the following sample, where we are creating a dictionary and
    then adding key-value pairs in several ways:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例，我们在创建一个字典，然后以几种方式添加键值对：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Initially, the dictionary contained the pairs [1, C#] [2, Java] [3, Python]
    [4, C++] and then we added [5, JavaScript] twice. However, because the second
    time `TryAdd()` is used, the operation will occur without any exception being
    thrown. We then used the indexer to add another pair, [6, F#], and also changed
    the value of the existing key, that is, 5, from JavaScript to TypeScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，字典包含了对[1, C#] [2, Java] [3, Python] [4, C++]的配对，然后我们两次添加了[5, JavaScript]。但是，因为第二次使用了`TryAdd()`，操作将在不抛出任何异常的情况下发生。然后我们使用索引器添加了另一对[6,
    F#]，并且还更改了现有键（即5）的值，即从JavaScript更改为TypeScript。
- en: 'We can search through the dictionary with the methods mentioned earlier:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面提到的方法搜索字典：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also iterate through the elements of a dictionary using an enumerator,
    in which case the key-value pairs are retrieved as `KeyValuePair<TKey, TValue>`
    objects:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过枚举器遍历字典的元素，在这种情况下，键值对被检索为`KeyValuePair<TKey, TValue>`对象：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To remove elements, we can use either `Remove()` or `Clear()`, with the latter
    for removing all the key-value pairs from the dictionary:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除元素，我们可以使用`Remove()`或`Clear()`，后者用于从字典中删除所有键值对：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another hash-based collection, which only maintains a collection of keys or
    unique values, is `HashSet<T>`. We will look at it in the following section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基于哈希的集合，只维护键或唯一值的集合，是`HashSet<T>`。我们将在下一节中看到它。
- en: The HashSet<T> collection
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashSet<T>集合
- en: A set is a collection that contains only distinct items that can be in any order.
    .NET provides the `HashSet<T>` class for working with sets. This class contains
    methods to handle the elements of the set but also methods to model mathematical
    set operations such as **union** or **intersection**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个只包含不同项的集合，可以是任何顺序。.NET提供了`HashSet<T>`类来处理集合。该类包含处理集合元素的方法，还包含建模数学集合操作如**并集**或**交集**的方法。
- en: 'Like all the other collections, `HashSet<T>` contains several overloaded constructors
    that allow us to create either an empty set or a set filled with initial values.
    To declare an empty set, we use the default constructor (which is the constructor
    without parameters):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他集合一样，`HashSet<T>`包含多个重载的构造函数，允许我们创建空集或填充有初始值的集合。要声明一个空集，我们使用默认构造函数（即没有参数的构造函数）：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we can also initialize the set with some values, as shown in the following
    example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用一些值初始化集合，如下例所示：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To work with a set, we can use the following methods:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用集合，我们可以使用以下方法：
- en: '`Add()` adds a new element to the set if the element is not already present.
    The function returns a Boolean value to indicate success or failure.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add()` 如果元素尚未存在，则将新元素添加到集合中。该函数返回一个布尔值以指示成功或失败。'
- en: '`Remove()` removes the specified element from the set.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove()` 从集合中移除指定的元素。'
- en: '`RemoveWhere()` removes all the elements that match the supplied predicate
    from the set.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveWhere()` 从集合中删除与提供的谓词匹配的所有元素。'
- en: '`Clear()` removes all the elements from the set.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()` 从集合中移除所有元素。'
- en: '`Contains()` checks whether the specified element is present in the set.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains()` 检查指定的元素是否存在于集合中。'
- en: 'We can see these methods in action in the following sample:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到这些方法的运行情况：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As mentioned previously, the `HashSet<T>` class provides the following methods
    for mathematical set operations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`HashSet<T>`类提供了以下数学集合操作的方法：
- en: '`UnionWith()`: This performs the union of two sets. The current set object
    is modified by adding all the elements from the supplied set that are not present
    in the set.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnionWith()`: 这执行两个集合的并集。当前集合对象通过添加来自提供的集合中不在集合中的所有元素来进行修改。'
- en: '`IntersectWith()`: This performs the intersection of two sets. The current
    set object is modified so that it contains only the elements that are also present
    in the supplied set.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntersectWith()`: 这执行两个集合的交集。当前集合对象被修改，以便它仅包含在提供的集合中也存在的元素。'
- en: '`ExceptWith()`: This performs set subtraction. The current set object is modified
    by removing all the elements that are also present in the supplied set.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExceptWith()`: 这执行集合减法。当前集合对象通过移除在提供的集合中也存在的所有元素来进行修改。'
- en: '`SymmetricExceptWith()`: This performs set symmetric difference. The current
    set object is modified to contain only elements that are present either in the
    set or in the supplied set but not in both.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SymmetricExceptWith()`: 这执行集合对称差。当前集合对象被修改为仅包含存在于集合或提供的集合中的元素，但不包含两者都存在的元素。'
- en: 'Examples of using these methods are shown in the following listing:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的示例在以下清单中显示：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition to these mathematical set operations, the class also provides methods
    for determining set equality, overlapping, or whether a set is a subset or superset
    of another. Some of these methods are listed here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些数学集合操作，该类还提供了用于确定集合相等性、重叠或一个集合是否是另一个集合的子集或超集的方法。其中一些方法列在这里：
- en: '`Overlaps()` determines whether the current set and the supplied set contain
    any common elements. The method returns `true` if at least one common element
    exists or `false` otherwise.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlaps()` 确定当前集合和提供的集合是否包含任何共同元素。如果至少存在一个共同元素，则该方法返回`true`，否则返回`false`。'
- en: '`IsSubsetOf()` determines if the current set is a subset of another set, which
    means that all its elements are also present in the other set. An empty set is
    a subset of any set.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSubsetOf()` 确定当前集合是否是另一个集合的子集，这意味着它的所有元素也存在于另一个集合中。空集是任何集合的子集。'
- en: '`IsSupersetOf()` determines if the current set is a superset of another set,
    which means that the current set contains all the elements of the other set.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSupersetOf()` 确定当前集合是否是另一个集合的超集，这意味着当前集合包含另一个集合的所有元素。'
- en: 'Examples of using these methods are shown in the following snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的示例在以下片段中显示：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `HashSet<T>` class contains other methods and properties. You should check
    the online documentation for a complete reference of the class members.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>`类包含其他方法和属性。您应该查看在线文档以获取该类成员的完整参考。'
- en: Choosing the right collection type
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的集合类型
- en: 'So far, we have looked at the most widely used generic collection types, although
    the base class library provides several more. The key question that arises after
    looking at each of them individually is when these collections should be used.
    In this section, we will provide some guidelines for choosing the right collection.
    Let''s take a look:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过最常用的泛型集合类型，尽管基类库提供了更多。在单独查看每个集合后出现的关键问题是何时应该使用这些集合。在本节中，我们将提供一些选择正确集合的指南。让我们来看一下：
- en: '`List<T>` is the default collection to use when you need to store elements
    contiguously and access them directly and you don''t have other specific constraints.
    Elements of the list can be accessed directly by their index. Adding and removing
    elements at the end is very efficient, but doing so at the beginning or middle
    is costly because it involves moving at least some of the elements.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack<T>` is the typical choice when you need a sequential list with the elements
    typically discarded after being retrieved in a LIFO manner. Elements are added
    and removed from the top of the stack, both operations requiring constant time.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue<T>` is a good choice when you need a sequential list with the elements
    also discarded after being retrieved but in a FIFO manner. Elements are added
    at the end and removed from the top of the queue. Both operations are very fast.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkedList<T>` is useful when you need to add and remove many elements from
    the middle of the list and do it quickly. However, this comes at the expense of
    the ability to randomly access the elements of the list (by their index). The
    linked list does not store its elements contiguously and you must traverse the
    list from one end in order to find an element.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>` should be used when you need to store values associated
    with a key. Inserts, deletes, and lookups are very fast – they require constant
    time, regardless of the size of the dictionary. The implementation uses a hash
    table, which means the keys are hashed and therefore the type of the key must
    implement `GetHashCode()` and `Equals()`. Alternatively, you need to provide an
    `IEqualityComparer` implementation upon the construction of the dictionary object.
    The elements of a dictionary are stored unordered, which prevents you from traversing
    the values in the dictionary in a particular order.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashSet<T>` is the collection you can use when you need a list of unique values.
    Inserts, deletes, and lookups are very efficient. The elements are stored unordered
    but contiguously. A hash set is logically similar to a dictionary, where the values
    are also the keys, although it is a non-associative container. For this reason,
    the type of its elements must implement `GetHashCode()` and `Equals()`, or, alternatively,
    you must provide an `IEqualityComparer` implementation upon the construction of
    the hash set.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table summarizes the information from the previous list:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_7Table_1_01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: If performance is key for your application, then, regardless of the choice you
    make based on guidelines and best practices, it is important to measure to see
    if the chosen collection type fits your requirements. Also, keep in mind that
    there are more collections in the base class library than the ones discussed in
    this chapter. `SortedList<TKey, TValue>`, `SortedDictionary<TKey, TValue>`, and
    `SortedSet<T>` could also be valuable in some particular scenarios.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Using thread-safe collections
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generic collections we have seen so far are not thread-safe. This means
    that when they're used in multithreading scenarios, you need to protect access
    to these collections with external locks, which in many cases can *degrade* performance.
    .NET offers several thread-safe collections that use efficient locking and lock-free
    synchronization mechanisms to achieve thread-safety. These collections are provided
    in the `System.Collections.Concurrent` namespace and should be used in scenarios
    where more than one thread is accessing a collection concurrently. However, the
    actual benefit may be smaller or greater than a standard collection being protected
    with an external lock. A discussion about this is provided later in this section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The topic of multithreading and asynchronous programming will be addressed in
    [*Chapter 12*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215), *Multithreading
    and Async Programming*, where you will learn about threads and tasks, synchronization
    mechanisms, the await/async model, and others.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Although the collections from the `System.Collections.Concurrent` namespace
    are thread-safe, it is not guaranteed that access to their elements through extension
    methods or explicit interface implementations is also thread-safe and they may
    require additional explicit synchronization by the caller.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The thread-safe generic collections are available and are discussed in the following
    subsections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: IProducerConsumerCollection<T>
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not an actual collection, but an interface that defines methods to manipulate
    thread-safe collections. It provides two methods called `TryAdd()` and `TryTake()`
    that enable adding and removing elements to a collection in a thread-safe way
    and also support cancellation with a `CancellationToken` object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it has a `ToArray()` method, which copies the element from the
    underlying collection to a new array, and overloads for `CopyTo()`, which copies
    elements of the collection to an array starting at a specified index. All implementations
    must make sure that all the methods of this interface are thread-safe. This interface
    is implemented by `ConcurrentBag<T>`, `ConcurrentStack<T>`, `ConcurrentQueue<T>`,
    and `BlockingCollection<T>`. You can also provide your own implementation if the
    standard ones do not meet your needs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: BlockingCollection<T>
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a class that implements the producer-consumer pattern defined by the
    `IProducerConsumerCollection<T>` interface. It is actually a simple wrapper over
    the `IProducerConsumerCollection<T>` interface and does not have an internal underlying
    storage; instead, it must be provided with one (a collection that implements the
    `IProducerConsumerCollection<T>` interface). If no implementation is provided,
    it uses the `ConcurrentQueue<T>` class by default.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The `BlockingCollection<T>` class supports **bounding** and **blocking**. Bounding
    means that you can set the capacity of the collection. That means when the collection
    reaches its maximum capacity, any producer (a thread that adds elements to the
    collection) will block until a consumer (a thread that removes elements from the
    collection) removes an element.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, any consumer that wants to remove an element blocks when
    the collection is empty until a producer adds an element to the collection. Adding
    and removing can be done with either `Add()` and `Take()` or the `TryAdd()` and
    `TryTake()` versions, which, unlike the former, support cancellation. There is
    also a `CompleteAdding()` method that marks the collection as complete, in which
    case further adding is no longer possible, and attempts to remove elements will
    no longer block when the collection is empty.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example to understand how this works. In the following
    sample code, we have a task that is producing elements to a `BlockingCollection<int>`
    and two tasks that are consuming from it. The collection is created as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This uses the default constructor of the class, which will instantiate it using
    the `ConcurrentQueue<int>` class as the underlying storage for the collection.
    The producer task is using the blocking collection to add numbers, which in this
    particular case are the first 12 elements of the Fibonacci sequence. Notice that,
    at the end, we are calling `CompleteAdding()` to mark the collection as complete.
    Further attempts to add would fail:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first consumer is a task that iterates indefinitely through the collection,
    taking one element at a time. The call to `Take()` blocks the calling thread if
    the collection is empty. However, if the collection is empty and it has been marked
    as complete, the operation will throw `InvalidOperationException`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second consumer is a task that does very similar work. However, instead
    of using an infinite loop, it uses a `foreach` statement. This is possible because
    `BlockingCollection<T>` has a method called `GetConsumingEnumerable()` that retrieves
    `IEnumerable<T>` that makes it possible to remove items from the collection with
    a `foreach` loop or `Parallel.ForEach`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the infinite loop, the enumerator provides items until the collection
    is marked as completed. If the collection is empty but not marked as completed,
    then the operation blocks until one item becomes available. The retrieving operation
    can also be canceled by using a `CancellationToken` object when calling `GetConsumingEnumerable()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Having these three tasks, we should wait for them all to complete:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A possible output from executing this sample is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A possible output from the execution of the preceding snippet.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B12346.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – A possible output from the execution of the preceding snippet.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the output will vary for different runs (meaning that the order
    of processing the elements will not be the same and from the same task).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentQueue<T>
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a thread-safe implementation of a queue (which is a FIFO collection).
    It provides three methods: `Enqueue()`, to add elements to the end of the collection,
    `TryPeek()`, to try to return the element at the beginning of the queue without
    removing it, and `TryDequeue()`, to try to remove and return the element at the
    beginning of the collection. It also provides an explicit implementation for the
    `IProducerConsumerCollection<T>` interface.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentStack<T>
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class implements a thread-safe stack (which is a LIFO collection). It
    provides four methods: `Push()`, to add an element at the top of the stack, `TryPeek()`,
    to try to return the element at the top without removing it, `TryPop()`, to try
    to remove and return the element at the top, and `TryPopRange()`, to try to remove
    and return multiple objects from the top of the stack. In addition, it also provides
    an explicit implementation for the `IProducerConsumerCollection<T>` interface.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentBag<T>
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class represents a thread-safe unordered collection of objects. This can
    be useful when you want to store objects, including duplicates, and their order
    is not important. The implementation is optimized for scenarios where the same
    thread is both the producer and consumer of the elements in the bag. Adding is
    done with `Add()` and removing is done with `TryPeek()` and `TryTake()`. You can
    also remove all the elements of the bag with a call to `Clear()`. Like the concurrent
    stack and queue implementation, this class also provides an explicit implementation
    for the `IProducerConsumerCollection<T>` interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentDictionary<TKey, TValue>
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This represents a thread-safe collection of key-value pairs. It provides methods
    such as `TryAdd()`, to try to add a new key-value pair, `TryUpdate()`, to try
    to update an existing item, `AddOrUpdate()`, to either add a new or update an
    existing item, and `GetOrAdd()`, to either retrieve an existing item or add a
    new one if the key is not found.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: These operations are atomic and thread-safe with the exception of their overloads,
    which take delegates. These are executed outside the locks, and therefore their
    code is not part of the atomicity of the operation. In addition, `TryGetValue()`
    attempts to get the value of a specified key, and `TryRemove()` attempts to remove
    and return the value associated with the specified key.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right concurrent collection type
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen what the concurrent collections are, the important question
    is when these should be used, especially in relation to the non-thread-safe collections.
    In general, you can use them as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` for when bounding and blocking scenarios are necessary.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentQueue<T>` should be preferred over `Queue<T>` with an external lock
    when the processing time is at least 500 `ConcurrentQueue<T>` performs best if
    one thread enqueues and another is dequeuing.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>` should be preferred over `Stack<T>` with an external lock
    if the same thread can either add or remove elements, in which case it is faster
    for both small and large processing times. However, if one thread adds and another
    thread removes elements, then `ConcurrentStack<T>` and `Stack<T>` with an external
    lock will perform relatively the same. But when the number of threads increases,
    `Stack<T>` might actually perform better.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary<TKey, TValue>` performs better than `Dictionary<TKey,
    TValue>` in all scenarios where adding and updating is done concurrently from
    multiple threads, although if the updates are frequent but the reads are rare,
    the benefits are very small. If both reads and updates are frequent, then `ConcurrentDictionary<TKey,
    TValue>` is significantly faster. `Dictionary<TKey, TValue>` is only suitable
    for scenarios where all the threads perform only reads and no updates.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentBag<T>` is suitable for scenarios where the same thread is both
    adding and consuming elements. However, in scenarios where a thread only either
    adds or removes, then it is slower than all the other concurrent collections.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the preceding list represents only guidelines and general
    behavior and it might not apply in all cases. In general, when you deal with concurrency
    and parallelism, you need to account for the particular aspects of your scenarios.
    Whatever algorithms and data structures you are using, you must profile their
    execution to see how it performs, both in relation to a sequential implementation
    or other concurrent alternatives.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about generic collections in .NET, the data structures
    they model, and the interfaces they implement. We looked at the most important
    collections in the `System.Collections.Generic` namespaces, `List<T>`, `Stack<T>`,
    `Queue<T>`, `LinkedList<T>`, `Dictionary<TKey, TValue>`, and `HashSet<T>`, and
    learned how to use them and perform operations such as adding, removing, or searching
    elements. In the last part of this chapter, we also looked at the `System.Collection.Concurrent`
    namespace and the thread-safe collections it provides. Then, we learned about
    the particularities of each collection and the typical scenarios where they are
    suitable to be used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore some advanced topics such as delegates
    and events, tuples, regular expressions, pattern matching, and extension methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under which namespace are the generic collections present?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base interface for all the other interfaces that define functionalities
    for generic collections?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using generic collections instead of non-generic collections?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `List<T>` and how do you add and remove elements to or from it?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Stack<T>` and how do you add and remove elements to or from it?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Queue<T>?` What is the difference between its `Dequeue()` and `Peek()`
    methods?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `LinkedList<T>`? What methods can you use to add elements to the collection?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Dictionary<K, V>` and what type are its elements?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `HashSet<T>` and how does it differ from `Dictionary<K, V>`?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `BlockingCollection<T>`? What concurrent scenarios is it suitable for?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
