- en: '*Chapter 7*: Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about generic programming in C#. One of
    the most important applications of generics is creating generic collections. A
    **collection** is a group of objects. We learned how to use arrays in [*Chapter
    2*](B12346_02_Final_JC_ePub.xhtml#_idTextAnchor036), *Data Types and Operators*.
    However, arrays are sequences of a fixed size and in most cases, we need to work
    with sequences of variable size.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET frameworks provide generic classes that represent various types of
    collections, such as list, queue, set, map, and others. Using these classes, we
    can easily perform operations such as insert, update, delete, sort, and search
    on a collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the following generic collections in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `List<T>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Stack<T>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Queue<T>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LinkedList<T>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Dictionary<TKey, TValue>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HashSet<T>` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the most important
    collections in .NET, what data structures they model, what the differences are
    between them, and when you should use them.
  prefs: []
  type: TYPE_NORMAL
- en: All the collections mentioned previously are not thread-safe. This means they
    cannot be used in multi-threaded scenarios when a thread might be reading while
    another might be writing to the same collection, without using external synchronization
    mechanisms. However, .NET also provides several thread-safe collections in the
    `System.Collections.Concurrent` namespace that use efficient locking or lock-free
    synchronization mechanisms, and, in many scenarios, provide better performance
    than the generic collections with external locks. In this chapter, we will also
    provide a walkthrough of these collections and learn about the scenarios when
    it's suitable to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an overview of the generic collection library by looking at
    the `System.Collections.Generic` namespace, which is where all the generic collections
    are located.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the System.Collections.Generic namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generic collection classes that we will present in this chapter are a part
    of the `System.Collections.Generic` namespace. This namespace contains interfaces
    and classes that define generic collections and operations. All the generic collections
    implement a series of generic interfaces, which are also defined in this namespace.
    These can be broadly grouped into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutable**, which support operations for changing the content of the collection
    such as adding new, or removing existing elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only collections**, which do not provide methods for changing the content
    of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interfaces that represent mutable collections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IEnumerable<T>`: This is the base interface for all the other interfaces and
    exposes an enumerator that supports iterating through the elements of a collection
    of `T` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ICollection<T>`: This defines methods for manipulating generic collections—`Add()`,
    `Clear()`, `Contains()`, `CopyTo()`, and `Remove()`—as well as properties, such
    as `Count`. These members should be *self-explanatory*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IList<T>`: This represents a generic collection whose elements can be accessed
    by an *index*. It defines three methods: `IndexOf()`, which retrieves the index
    of an element, `Insert()`, which inserts an element at the specified index, and
    `RemoveAt()`, which removes the element at the specified index, in addition, it
    also provides an indexer for direct element access for direct element access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISet<T>`: This is the base interface that abstracts set collections. It defines
    methods such as `Add()`, `ExceptWith()`, `IntersetWith()`, `UnionWith()`, `IsSubsetOf()`,
    and `IsSupersetOf()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDictionary<TKey, TValue>`: This is the base interface that abstracts a collection
    of key-value pairs. It defines the `Add()`, `ContainsKey()`, `Remove()`, and `TryGetValue()`
    methods, as well as an indexer and the `Keys` and `Values` properties, which return
    the collection of keys and values, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between these interfaces is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – The hierarchy of generic collection interfaces in the System.Collections.Generic
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces that represent read-only collections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IReadOnlyCollection<T>`: This represents a read-only generic collection of
    elements. It only defines one member: the `Count` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyList<T>`: This represents a read-only generic collection of elements
    that can be accessed by an index. It only defines one member: a read-only indexer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IReadOnlyDictionary<TKey, TValue>`: This represents a read-only generic collection
    of key-value pairs. This interface defines the `ContainsKey()` and `TryGetValue()`
    methods, as well as the `Keys` and `Values` properties and a read-only indexer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, the relationship of these interfaces is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The hierarchy of interfaces for read-only generic collections.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The hierarchy of interfaces for read-only generic collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each generic collection implements several of these interfaces. For instance,
    `List<T>` implements `IList<T>`, `ICollection<T>`, `IEnumerable<T>`, `IReadOnlyCollection<T>`,
    and `IReadOnlyList<T>`. The following diagram shows all the interfaces being implemented
    by the generic collections that we will learn about in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A class diagram showing the most important generic collections'
  prefs: []
  type: TYPE_NORMAL
- en: and the interfaces they implement.
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – A class diagram showing the most important generic collections
    and the interfaces they implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inheritance hierarchy shown in these diagrams is actually a simplification
    of the actual one. All the generic collections have a non-generic equivalent.
    For instance, `IEnumerable<T>` is the generic equivalent of `IEnumerable`, `ICollection<T>`
    is the generic equivalent of `ICollection`, `IList<T>` is the generic equivalent
    of `Ilist`, and so on. These are legacy interfaces that are implemented by legacy
    collections such as `ArrayList`, `Queue`, `Stack`, `DictionaryBase`, `Hashtable`,
    and so on, all of which are available in the `System.Collections` namespace. These
    non-generic legacy collections are not strongly typed. Using generic collections
    is preferred for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They offer the benefit of type safety. There is no need to derive from a base
    collection and implement type-specific members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have better performance for value types because there is no boxing and
    unboxing of elements, a process that is necessary with a non-generic collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the generic collections provide functionalities that are not available
    in the non-generic ones, such as methods that accept delegates that can be used
    for searching or performing an action of each element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you need to pass collections as arguments to functions or return collections
    from functions, you should avoid using concrete implementations and prefer using
    interfaces. `IEnumerable<T>` is suitable when you only want to iterate through
    the elements, but if you need to do that multiple times, you could use `IReadOnlyCollection<T>`.
    Read-only collections should be preferred in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When a method does not modify the collection passed as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you return a collection if the collection is already in memory and the
    caller is not supposed to modify it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, the most suitable interface varies from case to case.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will introduce each of the most widely used type-safe
    generic collections. The non-generic collections are of little interest outside
    legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: The List<T> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `List<T>` generic class represents a collection of elements that can be
    accessed by their index. `List<T>` is very similar to arrays, except that the
    size of the collection is not fixed but variable, and it can grow or decrease
    as elements are added or removed. In fact, the implementation of `List<T>` uses
    an array to store the elements. When the number of elements exceeds the size of
    the array, a new and larger array is allocated, and the content of the previous
    array is copied to the new one. This means that `List<T>` stores the elements
    in contiguous memory locations. However, for value types, these locations contain
    the values, but for reference types, they contain references to the actual objects.
    Multiple references to the same object can be added to a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `List<T>` class implements a series of generic and non-generic interfaces,
    as shown in the following declaration of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A list can be created in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the default constructor, which results in an empty list with a default
    capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By specifying a particular capacity but no initial elements, which again leaves
    the list empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a collection of elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, `numbers` is an empty list of integers and `words`
    is an empty list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following sample initializes the list with some elements.
    The first list will contain six integers and the second list will contain two
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class supports all the typical operations that you would expect from such
    a collection—adding, removing, and searching elements. There are several ways
    to add elements to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add()` adds an element to the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddRange()` adds a collection of elements (in the form of an `IEnumerable<T>`)
    to the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Insert()` inserts an element at the specified position. The position must
    be a valid index, within the bounds of the list; otherwise, an `ArgumentOutOfRangeException`
    exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertRange()`inserts a range of elements (in the form of an `IEnumerable<T>`)
    at the specified index, which must be within the bounds of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these operations may require the reallocation of the internal array that
    stores elements if its capacity is exceeded. `Add()` is an *O(1)* operation if
    no allocation is needed and *O(n)* when allocation is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '`AddRange()` is *O(n)* if no allocation is necessary and *O(n+k)* if allocations
    are needed. `Insert()` is always an *O(n)* operation, and `InsertRange()` is *O(n)*
    if no allocation is needed and *O(n+k)* if an allocation is necessary. In this
    notation, *n* is the number of elements in the list and *k* is the number of elements
    to add. We can see an example of these operations in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the elements is also possible in several ways using different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Remove()` removes the specified element from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveAt()` removes the element at the specified index, which must be within
    the bounds of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveRange()` removes the specified number of elements, starting with the
    given index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveAll()` removes all the elements in the list that meet the requirements
    of the supplied predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()` removes all the elements in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these operations are performed in *O(n)*, where *n* is the number of elements
    in the list. The exception is `RemoveAt()`, where *n* is `Count - index`. The
    reason for this is that the elements must be moved within the internal array after
    one has been removed. Examples of using these functions are shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to search for elements in the list by specifying a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: A **predicate** is a delegate that returns a bool. They are typically used when
    you filter elements, such as when you search through a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several methods that can be used to search elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Find()` returns the first element that matches the predicate or the default
    value of `T` if none is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindLast()` returns the last element that matches the predicate or the default
    value of `T` if none is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindAll()` returns a `List<T>` with all the elements that match the predicate
    or an empty list if none is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these methods are performed in *O(n)*, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to search for the zero-based index of an element as well. There
    are several methods that allow us to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IndexOf()` returns the index of the first element that is equal to the supplied
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LastIndexOf()` returns the last index of the searched element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindIndex()` returns the index of the first element that satisfies the supplied
    predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindLastIndex()` returns the index of the last element that satisfies the
    supplied predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinarySearch()` returns the index of the first element that satisfies the
    supplied element or a comparer using binary search. This function assumes that
    the list is already sorted; otherwise, the result is incorrect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinarySearch()` is performed in *O(log n)*, while all the others are performed
    in *O(n)*. This is because they use linear search. They all return `-1` if no
    element that satisfies the search criteria is found. Examples are shown in the
    following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are methods that allow us to modify the content of the list, such as
    by sorting the elements or reverting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sort()` sorts the list according to a default or specified criteria. There
    are several overloads that allow us to specify either a comparison delegate or
    an `IComparer<T>` object, or even a sub-range of the list to sort. This operation
    is performed in *O(n log n)* in most cases but *O (n2)* in the worst-case scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reverse()` reverses the elements in the list. There is an overload that allows
    you to specify a sub-range to revert. This operation is performed in *O(n)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of using these functions are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are more methods in the `List<T>` class than those shown here. However,
    going through all of them is beyond the scope of this book. You should look up
    the official documentation of the class online for a complete reference to all
    the members of this class.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack<T> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a linear data structure that allows us to insert and delete items
    in a particular order. New items are added at the top of the stack. If we want
    to remove an item from the stack, we can only remove the top item. Since insertion
    and deletion is allowed from only one end, the item to be inserted last will be
    the item to be deleted first. Therefore, the stack is called a **Last in**, **First
    Out (LIFO)** collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts a stack, where *push* represents adding an item
    to the stack and *pop* represents deleting an item from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The conceptual representation of a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B12346.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The conceptual representation of a stack.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET provides the generic `Stack<T>` class for working with stacks. This class
    contains several constructors that allow us to create either an empty stack or
    a stack initialized with a collection of elements. Take a look at the following
    code snippet, where we are creating a stack of strings with three initial elements
    and an empty stack of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary operations that are supported by the stack are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Push()`: Inserts an item at the top of the stack. This is an *O(1)* operation
    if no reallocation is necessary and *O(n)* otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pop()`: Removes and returns the item from the top of the stack. This is an
    *O(1)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek()`: Returns an item from the top of the stack without removing it. This
    is an *O(1)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: Removes all the elements from the stack. This is an *O(n)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand how these work with the help of the following example where,
    on the left, you can see the contents of the stack after each operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Pop()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the stack is empty. In .NET Core, since version 2.0, two alternative non-throwing
    methods are available—`TryPop()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an `out` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The Queue<T> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A queue is a linear data structure where insertion and deletion of elements
    is performed from two different ends. A new item is added from the rear end of
    the queue and deletion of existing items occurs from the front. Therefore, the
    item to be inserted first will be the item to be deleted first. Because of this,
    the queue is called a **First in**, **First Out (FIFO)** collection. The following
    diagram depicts a queue, where **Enqueue** represents adding an item to the queue
    and **Dequeue** represents deleting an item from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The conceptual representation of a queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The conceptual representation of a queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET, the class that implements a generic queue is `Queue<T>`. Similarly,
    with `Stack<T>`, there are overloaded constructors that allow us to create an
    empty queue or a queue initialized with elements from an `IEnumerable<T>` collection.
    Take a look at the following code snippet, where we are creating a queue of strings
    with three initial elements and an empty queue of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary operations that are supported for the queue are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue()`: Inserts an item at the end of the queue. This operation is *O(1)*
    unless the internal array needs to be reallocated, in which case it becomes an
    *O(n)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dequeue()`: Removes and returns an item from the front of the queue. This
    is an *O(1)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek()`: Returns an item from the front of the queue without removing it.
    This is an *O(1)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: Removes all the elements from the queue. This is an *O(n)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how these methods work, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Dequeue()` and `Peek()` methods throw an `InvalidOperationException` exception
    if the queue is empty. In .NET Core, since version 2.0, two alternatives non-throwing
    methods are available—`TryDequeue()` and `TryPeek()`. These methods return a Boolean
    value indicating whether a top element was found and if so, it is returned as
    an out argument.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, `Stack<T>` and `Queue<T>` have very similar
    implementations, although the semantics are different. Their public members are
    almost the same, with the difference being that the stack operations are called
    `Push()` and `Pop()` and the queue operations are called `Enqueue()` and `Dequeue()`.
  prefs: []
  type: TYPE_NORMAL
- en: The LinkedList<T> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A linked list is a linear data structure that consists of a group of nodes
    where each node contains data as well as the address of one or more nodes. There
    are four types of linked list, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singly Linked List**: This contains nodes that store a value and a reference
    to the next node in the sequence of nodes. The reference to the next node of the
    last node will point to null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doubly Linked List**: Here, each node contains two links – the first link
    points to the previous node and the next link points to the next node in the sequence.
    The reference to the previous node of the first node and the reference to the
    next node of the last node will point to null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular Singly Linked List**: The reference to the next node of the last
    node will point to the first node, thus forming a circular chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doubly Circular Linked List**: In this type of linked list, the reference
    to the next node of the last node will point to the first node and the reference
    to the previous node of the first node will point to the last node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A conceptual representation of the doubly linked list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – A conceptual representation of a doubly linked-list.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – A conceptual representation of a doubly linked-list.
  prefs: []
  type: TYPE_NORMAL
- en: Here, each node contains a value and two pointers. The **Next** pointer contains
    a reference to the next node in the sequence and allows easy navigation in the
    forward direction of the linked list. The **Prev** pointer contains a reference
    to the previous node in the sequence and allows us to move backward in the linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: .NET provides the `LinkedList<T>` class, which represents a doubly linked list.
    This class contains items of the `LinkedListNode<T>` type. Insertion and removal
    operations are performed in *O(1)* and searching is performed in *O(n)*. Nodes
    can be removed and reinserted either in the same linked list object or another.
    The list maintains an internal count, so retrieving the size of the list using
    the `Count` property is also an *O(1)* operation. The linked list does not support
    cycles, splitting, chaining, or anything else that can leave the list in an inconsistent
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LinkedListNode<T>` class has the following four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`: This property will return the reference to the `LinkedList<T>` object
    to which `LinkedListNode<T>` belongs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Next`: Represents the reference to the next node in the `LinkedList<T>` object
    or `null` if the current node is the last node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Previous`: Represents the reference to the previous node in the `LinkedList<T>`
    object or `null` if the current node is the first node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Value`: This property is of type `T` and represents the value contained in
    the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For value types, `LinkedListNode<T>` contains the actual value, whereas for
    reference types, it contains a reference to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class has overloaded constructors that enable us to create an empty linked
    list or one initialized with a sequence of elements, in the form of an `IEnumerable<T>`.
    Take a look at the following sample to see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding new elements to the linked list is possible in several ways using the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddFirst()` adds a new node or value at the beginning of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddLast()` adds a new node or value at the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddAfter()` adds a new node or value in the list after the specified node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddBefore()` adds a new node or value in the list before the specified node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see examples of the overload that adds a new value for each of these
    methods in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Searching for elements in a linked list can be performed using one of the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Contains()`: This checks whether a specified value is found in the list and
    returns a Boolean value to indicate success or failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Find()`: This finds and returns the first node that contains the specified
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindLast()`: This finds and returns the last node that contains the specified
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of using these functions are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing elements from the list can be done in several ways using the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RemoveFirst()` removes the first node in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveLast()` removes the last node in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove()` removes the specified node or the first occurrence of the specified
    value from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()` removes all the elements from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see all these methods at work in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The linked list class also has several properties, including `Count`, which
    returns the number of elements in the list, `First`, which returns the first node,
    and `Last`, which returns the last node. If the list is empty, then `Count` is
    `0` and `First` and `Last` are both set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The Dictionary<TKey, TValue> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dictionary is a collection of key-value pairs that allows fast lookup based
    on a key. Adding, searching, and deleting an item are very fast operations and
    are performed in *O(1)*. The exception here is adding a new value if the capacity
    must be increased, in which case it becomes *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, the generic `Dictionary<TKey,TValue>` class implements a dictionary.
    `TKey` represents the type of the key and `TValue` represents the type of the
    value. The elements of the dictionary are `KeyValuePair<TKey,TValue>` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>` has several overloaded constructors that allow us
    to create an empty dictionary or a dictionary filled with some initial values.
    The default constructor of this class will create an empty dictionary. Take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating an empty dictionary called `languages` that has a key
    of the `int` type and a value of the `string` type. We can also initialize a dictionary
    at the time of declaration. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a dictionary that is initialized with four values that
    have the keys `1`, `2`, `3`, and `4`. This is semantically equivalent to the following
    initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary must contain unique keys; however, the value can be *duplicated*.
    Similarly, a key cannot be `null`, but a value (if it is of a reference type)
    can be `null`. To add, remove, or search for dictionary values, we can use the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add()`: This adds a new value with the specified key to the dictionary. If
    the key is `null` or the key already exists in the dictionary, an exception is
    thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove()`: This removes the value with the specified key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()`: This removes all the values from the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsKey()`: This checks if the dictionary contains the specified key and
    returns a Boolean value to indicate that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContainsValue()`: This checks if the dictionary contains the specified value
    and returns a Boolean value to indicate that. The method performs a linear search;
    therefore, it is an *O(n)* operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryGetValue()`: This checks whether the dictionary contains the specified
    key and if so, it returns the associated value as an `out` argument. The method
    returns `true` if the value was successful fetched or `false` otherwise. If the
    key is not present, the output parameter is set to the default value of the `TValue`
    type (that is, `0` for numerical types, `false` for bool, and `null` for reference
    types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In .NET Core 2.0 and newer, there is one additional method called `TryAdd()`
    that attempts to add a new value to the dictionary. The method succeeds only if
    the key is not already present. It returns a Boolean value to indicate success
    or failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class also contains a set of properties, the most important of them being
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Count`: This returns the number of key-value pairs in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Keys`: This returns a collection (of the `Dictionary<TKey,TValue>.KeyCollection`
    type) containing all the keys in the dictionary. The order of the keys in this
    collection is not specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Values`: This returns a collection (of the `Dictionary<TKey,TValue>.ValueCollection`
    type) containing all the values in the dictionary. The order of the values in
    this collection is not specified but it is guaranteed to be in the same order
    as their associated keys in the `Keys` collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Item[]`: This is an indexer that gets or sets the value associated with the
    specified key. The indexer can be used to add values to the dictionary. If the
    key does not exist, a new key-value pair is added. If the key already exists,
    the value is overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following sample, where we are creating a dictionary and
    then adding key-value pairs in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the dictionary contained the pairs [1, C#] [2, Java] [3, Python]
    [4, C++] and then we added [5, JavaScript] twice. However, because the second
    time `TryAdd()` is used, the operation will occur without any exception being
    thrown. We then used the indexer to add another pair, [6, F#], and also changed
    the value of the existing key, that is, 5, from JavaScript to TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can search through the dictionary with the methods mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also iterate through the elements of a dictionary using an enumerator,
    in which case the key-value pairs are retrieved as `KeyValuePair<TKey, TValue>`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove elements, we can use either `Remove()` or `Clear()`, with the latter
    for removing all the key-value pairs from the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Another hash-based collection, which only maintains a collection of keys or
    unique values, is `HashSet<T>`. We will look at it in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The HashSet<T> collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set is a collection that contains only distinct items that can be in any order.
    .NET provides the `HashSet<T>` class for working with sets. This class contains
    methods to handle the elements of the set but also methods to model mathematical
    set operations such as **union** or **intersection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all the other collections, `HashSet<T>` contains several overloaded constructors
    that allow us to create either an empty set or a set filled with initial values.
    To declare an empty set, we use the default constructor (which is the constructor
    without parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also initialize the set with some values, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with a set, we can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add()` adds a new element to the set if the element is not already present.
    The function returns a Boolean value to indicate success or failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remove()` removes the specified element from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoveWhere()` removes all the elements that match the supplied predicate
    from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear()` removes all the elements from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains()` checks whether the specified element is present in the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see these methods in action in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, the `HashSet<T>` class provides the following methods
    for mathematical set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnionWith()`: This performs the union of two sets. The current set object
    is modified by adding all the elements from the supplied set that are not present
    in the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntersectWith()`: This performs the intersection of two sets. The current
    set object is modified so that it contains only the elements that are also present
    in the supplied set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExceptWith()`: This performs set subtraction. The current set object is modified
    by removing all the elements that are also present in the supplied set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SymmetricExceptWith()`: This performs set symmetric difference. The current
    set object is modified to contain only elements that are present either in the
    set or in the supplied set but not in both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of using these methods are shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to these mathematical set operations, the class also provides methods
    for determining set equality, overlapping, or whether a set is a subset or superset
    of another. Some of these methods are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Overlaps()` determines whether the current set and the supplied set contain
    any common elements. The method returns `true` if at least one common element
    exists or `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsSubsetOf()` determines if the current set is a subset of another set, which
    means that all its elements are also present in the other set. An empty set is
    a subset of any set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsSupersetOf()` determines if the current set is a superset of another set,
    which means that the current set contains all the elements of the other set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of using these methods are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `HashSet<T>` class contains other methods and properties. You should check
    the online documentation for a complete reference of the class members.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right collection type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have looked at the most widely used generic collection types, although
    the base class library provides several more. The key question that arises after
    looking at each of them individually is when these collections should be used.
    In this section, we will provide some guidelines for choosing the right collection.
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<T>` is the default collection to use when you need to store elements
    contiguously and access them directly and you don''t have other specific constraints.
    Elements of the list can be accessed directly by their index. Adding and removing
    elements at the end is very efficient, but doing so at the beginning or middle
    is costly because it involves moving at least some of the elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack<T>` is the typical choice when you need a sequential list with the elements
    typically discarded after being retrieved in a LIFO manner. Elements are added
    and removed from the top of the stack, both operations requiring constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Queue<T>` is a good choice when you need a sequential list with the elements
    also discarded after being retrieved but in a FIFO manner. Elements are added
    at the end and removed from the top of the queue. Both operations are very fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkedList<T>` is useful when you need to add and remove many elements from
    the middle of the list and do it quickly. However, this comes at the expense of
    the ability to randomly access the elements of the list (by their index). The
    linked list does not store its elements contiguously and you must traverse the
    list from one end in order to find an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>` should be used when you need to store values associated
    with a key. Inserts, deletes, and lookups are very fast – they require constant
    time, regardless of the size of the dictionary. The implementation uses a hash
    table, which means the keys are hashed and therefore the type of the key must
    implement `GetHashCode()` and `Equals()`. Alternatively, you need to provide an
    `IEqualityComparer` implementation upon the construction of the dictionary object.
    The elements of a dictionary are stored unordered, which prevents you from traversing
    the values in the dictionary in a particular order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashSet<T>` is the collection you can use when you need a list of unique values.
    Inserts, deletes, and lookups are very efficient. The elements are stored unordered
    but contiguously. A hash set is logically similar to a dictionary, where the values
    are also the keys, although it is a non-associative container. For this reason,
    the type of its elements must implement `GetHashCode()` and `Equals()`, or, alternatively,
    you must provide an `IEqualityComparer` implementation upon the construction of
    the hash set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table summarizes the information from the previous list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_7Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If performance is key for your application, then, regardless of the choice you
    make based on guidelines and best practices, it is important to measure to see
    if the chosen collection type fits your requirements. Also, keep in mind that
    there are more collections in the base class library than the ones discussed in
    this chapter. `SortedList<TKey, TValue>`, `SortedDictionary<TKey, TValue>`, and
    `SortedSet<T>` could also be valuable in some particular scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using thread-safe collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generic collections we have seen so far are not thread-safe. This means
    that when they're used in multithreading scenarios, you need to protect access
    to these collections with external locks, which in many cases can *degrade* performance.
    .NET offers several thread-safe collections that use efficient locking and lock-free
    synchronization mechanisms to achieve thread-safety. These collections are provided
    in the `System.Collections.Concurrent` namespace and should be used in scenarios
    where more than one thread is accessing a collection concurrently. However, the
    actual benefit may be smaller or greater than a standard collection being protected
    with an external lock. A discussion about this is provided later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: The topic of multithreading and asynchronous programming will be addressed in
    [*Chapter 12*](B12346_12_Final_JC_ePub.xhtml#_idTextAnchor215), *Multithreading
    and Async Programming*, where you will learn about threads and tasks, synchronization
    mechanisms, the await/async model, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Although the collections from the `System.Collections.Concurrent` namespace
    are thread-safe, it is not guaranteed that access to their elements through extension
    methods or explicit interface implementations is also thread-safe and they may
    require additional explicit synchronization by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-safe generic collections are available and are discussed in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: IProducerConsumerCollection<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not an actual collection, but an interface that defines methods to manipulate
    thread-safe collections. It provides two methods called `TryAdd()` and `TryTake()`
    that enable adding and removing elements to a collection in a thread-safe way
    and also support cancellation with a `CancellationToken` object.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it has a `ToArray()` method, which copies the element from the
    underlying collection to a new array, and overloads for `CopyTo()`, which copies
    elements of the collection to an array starting at a specified index. All implementations
    must make sure that all the methods of this interface are thread-safe. This interface
    is implemented by `ConcurrentBag<T>`, `ConcurrentStack<T>`, `ConcurrentQueue<T>`,
    and `BlockingCollection<T>`. You can also provide your own implementation if the
    standard ones do not meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: BlockingCollection<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a class that implements the producer-consumer pattern defined by the
    `IProducerConsumerCollection<T>` interface. It is actually a simple wrapper over
    the `IProducerConsumerCollection<T>` interface and does not have an internal underlying
    storage; instead, it must be provided with one (a collection that implements the
    `IProducerConsumerCollection<T>` interface). If no implementation is provided,
    it uses the `ConcurrentQueue<T>` class by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `BlockingCollection<T>` class supports **bounding** and **blocking**. Bounding
    means that you can set the capacity of the collection. That means when the collection
    reaches its maximum capacity, any producer (a thread that adds elements to the
    collection) will block until a consumer (a thread that removes elements from the
    collection) removes an element.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, any consumer that wants to remove an element blocks when
    the collection is empty until a producer adds an element to the collection. Adding
    and removing can be done with either `Add()` and `Take()` or the `TryAdd()` and
    `TryTake()` versions, which, unlike the former, support cancellation. There is
    also a `CompleteAdding()` method that marks the collection as complete, in which
    case further adding is no longer possible, and attempts to remove elements will
    no longer block when the collection is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example to understand how this works. In the following
    sample code, we have a task that is producing elements to a `BlockingCollection<int>`
    and two tasks that are consuming from it. The collection is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the default constructor of the class, which will instantiate it using
    the `ConcurrentQueue<int>` class as the underlying storage for the collection.
    The producer task is using the blocking collection to add numbers, which in this
    particular case are the first 12 elements of the Fibonacci sequence. Notice that,
    at the end, we are calling `CompleteAdding()` to mark the collection as complete.
    Further attempts to add would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first consumer is a task that iterates indefinitely through the collection,
    taking one element at a time. The call to `Take()` blocks the calling thread if
    the collection is empty. However, if the collection is empty and it has been marked
    as complete, the operation will throw `InvalidOperationException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The second consumer is a task that does very similar work. However, instead
    of using an infinite loop, it uses a `foreach` statement. This is possible because
    `BlockingCollection<T>` has a method called `GetConsumingEnumerable()` that retrieves
    `IEnumerable<T>` that makes it possible to remove items from the collection with
    a `foreach` loop or `Parallel.ForEach`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the infinite loop, the enumerator provides items until the collection
    is marked as completed. If the collection is empty but not marked as completed,
    then the operation blocks until one item becomes available. The retrieving operation
    can also be canceled by using a `CancellationToken` object when calling `GetConsumingEnumerable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these three tasks, we should wait for them all to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output from executing this sample is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A possible output from the execution of the preceding snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.7_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – A possible output from the execution of the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the output will vary for different runs (meaning that the order
    of processing the elements will not be the same and from the same task).
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentQueue<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a thread-safe implementation of a queue (which is a FIFO collection).
    It provides three methods: `Enqueue()`, to add elements to the end of the collection,
    `TryPeek()`, to try to return the element at the beginning of the queue without
    removing it, and `TryDequeue()`, to try to remove and return the element at the
    beginning of the collection. It also provides an explicit implementation for the
    `IProducerConsumerCollection<T>` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentStack<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class implements a thread-safe stack (which is a LIFO collection). It
    provides four methods: `Push()`, to add an element at the top of the stack, `TryPeek()`,
    to try to return the element at the top without removing it, `TryPop()`, to try
    to remove and return the element at the top, and `TryPopRange()`, to try to remove
    and return multiple objects from the top of the stack. In addition, it also provides
    an explicit implementation for the `IProducerConsumerCollection<T>` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentBag<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class represents a thread-safe unordered collection of objects. This can
    be useful when you want to store objects, including duplicates, and their order
    is not important. The implementation is optimized for scenarios where the same
    thread is both the producer and consumer of the elements in the bag. Adding is
    done with `Add()` and removing is done with `TryPeek()` and `TryTake()`. You can
    also remove all the elements of the bag with a call to `Clear()`. Like the concurrent
    stack and queue implementation, this class also provides an explicit implementation
    for the `IProducerConsumerCollection<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentDictionary<TKey, TValue>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This represents a thread-safe collection of key-value pairs. It provides methods
    such as `TryAdd()`, to try to add a new key-value pair, `TryUpdate()`, to try
    to update an existing item, `AddOrUpdate()`, to either add a new or update an
    existing item, and `GetOrAdd()`, to either retrieve an existing item or add a
    new one if the key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: These operations are atomic and thread-safe with the exception of their overloads,
    which take delegates. These are executed outside the locks, and therefore their
    code is not part of the atomicity of the operation. In addition, `TryGetValue()`
    attempts to get the value of a specified key, and `TryRemove()` attempts to remove
    and return the value associated with the specified key.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right concurrent collection type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen what the concurrent collections are, the important question
    is when these should be used, especially in relation to the non-thread-safe collections.
    In general, you can use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` for when bounding and blocking scenarios are necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentQueue<T>` should be preferred over `Queue<T>` with an external lock
    when the processing time is at least 500 `ConcurrentQueue<T>` performs best if
    one thread enqueues and another is dequeuing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>` should be preferred over `Stack<T>` with an external lock
    if the same thread can either add or remove elements, in which case it is faster
    for both small and large processing times. However, if one thread adds and another
    thread removes elements, then `ConcurrentStack<T>` and `Stack<T>` with an external
    lock will perform relatively the same. But when the number of threads increases,
    `Stack<T>` might actually perform better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary<TKey, TValue>` performs better than `Dictionary<TKey,
    TValue>` in all scenarios where adding and updating is done concurrently from
    multiple threads, although if the updates are frequent but the reads are rare,
    the benefits are very small. If both reads and updates are frequent, then `ConcurrentDictionary<TKey,
    TValue>` is significantly faster. `Dictionary<TKey, TValue>` is only suitable
    for scenarios where all the threads perform only reads and no updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentBag<T>` is suitable for scenarios where the same thread is both
    adding and consuming elements. However, in scenarios where a thread only either
    adds or removes, then it is slower than all the other concurrent collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the preceding list represents only guidelines and general
    behavior and it might not apply in all cases. In general, when you deal with concurrency
    and parallelism, you need to account for the particular aspects of your scenarios.
    Whatever algorithms and data structures you are using, you must profile their
    execution to see how it performs, both in relation to a sequential implementation
    or other concurrent alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about generic collections in .NET, the data structures
    they model, and the interfaces they implement. We looked at the most important
    collections in the `System.Collections.Generic` namespaces, `List<T>`, `Stack<T>`,
    `Queue<T>`, `LinkedList<T>`, `Dictionary<TKey, TValue>`, and `HashSet<T>`, and
    learned how to use them and perform operations such as adding, removing, or searching
    elements. In the last part of this chapter, we also looked at the `System.Collection.Concurrent`
    namespace and the thread-safe collections it provides. Then, we learned about
    the particularities of each collection and the typical scenarios where they are
    suitable to be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore some advanced topics such as delegates
    and events, tuples, regular expressions, pattern matching, and extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under which namespace are the generic collections present?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the base interface for all the other interfaces that define functionalities
    for generic collections?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using generic collections instead of non-generic collections?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `List<T>` and how do you add and remove elements to or from it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Stack<T>` and how do you add and remove elements to or from it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Queue<T>?` What is the difference between its `Dequeue()` and `Peek()`
    methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `LinkedList<T>`? What methods can you use to add elements to the collection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `Dictionary<K, V>` and what type are its elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `HashSet<T>` and how does it differ from `Dictionary<K, V>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `BlockingCollection<T>`? What concurrent scenarios is it suitable for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
