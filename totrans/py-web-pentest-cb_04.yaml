- en: Chapter 4. SQL Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking jitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying URL-based SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Boolean SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Blind SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Injection is the loud and noisy attack that beats you over the head in every
    tech-related media provider you see. It is one of the most common and most devastating
    attacks of recent history and continues to thrive in new installations. This chapter
    focuses on both performing and supporting SQL Injection attacks. We will create
    scripts that encode attack strings, perform attacks, and time normal actions to
    normalize attack times.
  prefs: []
  type: TYPE_NORMAL
- en: Checking jitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only difficult thing about performing time-based SQL Injections is that
    plague of gamers everywhere, lag. A human can easily sit down and account for
    lag mentally, taking a string of returned values, and sensibly going over the
    output and working out that *cgris* is *chris*. For a machine, this is much harder;
    therefore, we should attempt to reduce delay.
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating a script that makes multiple requests to a server, records
    the response time, and returns an average time. This can then be used to calculate
    fluctuations in responses in time-based attacks known as **jitter**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Identify the URLs you wish to attack and provide to the script through a `sys.argv`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is an example of the output produced when using this
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04044_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import the libraries we require for this script, as with every other script
    we''ve done in this book so far. We set the counter `I` to zero and create an
    empty list for the times we are about to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the counter `I`, we run `100` requests to the target URL and append the
    response time of the request to list we created earlier. `R.elapsed` is a `timedelta`
    object, not an integer, and therefore must be called with `.total_seconds()` in
    order to get a usable number for our later average. We then add one to the counter
    to account for this loop and so that the script ends appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the loop is complete, we calculate the average of the `100` requests by
    calculating the total values of the list with `sum` and dividing it by the number
    of values in the list with `len`.
  prefs: []
  type: TYPE_NORMAL
- en: We then return a basic output for ease of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very basic way of performing this action and only really performs
    the function as a standalone script to prove a point. To be performed as part
    of another script, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Identifying URL-based SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we've looked at fuzzing before for XSS and error messages. This time, we're
    doing something similar but with SQL Injection, instead. The crux of any SQLi
    starts with a single quotation mark, tick, or apostrophe, depending on your personal
    choice of word. We throw a tick into the URL targeted and check the response to
    see what version of SQL is running if successful.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that sends the basic SQL Injection string to our targeted
    URL, record the output, and compare to known phrases in error messages to identify
    the underlying system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import our libraries and set our URL manually. We can set it as a `sys.argv`
    variable if needs be; however, I have hardcoded it here to show the expected format.
    We set the initial injection string as a single quotation mark and print that
    the test is starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We make our first request as our provided URL and the apostrophe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few lines are our detection methods to identify what the underlying
    database is. The MySQL standard error is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, our detection attempt reads in the text of response and searches
    for the `MySQL` string and, if so, prints out that the attempt was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For MS SQL, an example error message is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are multiple potential error messages, we need to identify one
    constant that occurs across as many of them as possible. For this, I have chosen
    `native client,` though `Microsoft SQL` could also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard error message for PostgreSQL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, for what is always a syntax error in SQL, the only solution
    that regularly uses the `syntax` word is `PostGRES,` which allows us to use that
    as the distinguishing word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The last system we check is Oracle. An example error message for Oracle is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'ORA is the prefix for the majority of Oracle errors and therefore can be used
    as the identifier here. There are only a few fringe cases where a non-ORA error
    message would apply to a trailing tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the event in which none of these apply, we have a final `else` statement
    that declares the parameter is not injectable and that an error was made in picking
    this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tying this script in with the spider found in [Chapter 1](ch01.html "Chapter 1. Gathering
    Open Source Intelligence"), *Gathering Open Source Intelligence*, would make for
    a quick efficient way of identifying injectable URLs across a web page. A method
    of identifying parameters to inject would be necessary, which can be achieved
    through simple regex manipulation in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: A set of useful SQLi test pages were made by Audi-1 and can be found at [https://github.com/Audi-1/sqli-labs](https://github.com/Audi-1/sqli-labs).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Boolean SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when all you can get from a page is a yes or no. It's heartbreaking
    until you realize that that's the SQL equivalent of saying *I LOVE YOU*. All SQLi
    can be broken down into yes or no questions, depending on how patient you are.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that takes a `yes` value and a URL and returns results
    based on a predefined attack string. I have provided an example attack string
    but this will change, depending on the system you are testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script is how yours should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, the user must identify a string that only occurs when the SQLi is
    successful. Alternatively, the script may be altered to respond to the absence
    of proof of a failed SQLi. We provide this string as a `sys.argv` variable. We
    also create the two iterators that we will use in this script and have set them
    to `1`, as MySQL starts counting from `1` instead of `0` like the failed system
    it is. We also create an empty list for our future answer and instruct the user
    that the script is starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our payload here basically requests the length of the password we are attempting
    to return and compares it to a value that will be iterated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then repeat the next loop forever as we have no idea how long the password
    is. We submit the payload to the target URL in a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time we check to see if the `yes` value we set originally is present in
    the response text and, if so, we end the while loop setting the current value
    of `i` as the parameter length. The `break` command is the part that ends the
    `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t detect the `yes` value, we add `1` to `i` and continue the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the identified length of the target string, we iterate through each character
    and, using the `asciivalue`, each possible value of that character. For each value,
    we submit it to the target URL. Because the ascii table only runs up to `127`,
    we cap the loop to run until the `asciivalue` has reached `126`. If it reaches
    `127`, something has gone wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We check to see if our yes string is present in the response and, if so, break
    to go onto the next character. We append our successful message to our answer
    string in character form, converting it with the `chr` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `yes` value is not present, we add to `asciivalue` to move on to the
    next potential character for that position and pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we reset `asciivalue` for each loop, and then when the loop hits the
    length of the string, we finish, printing the whole recovered string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Potentially, this script could be altered to handle iterating through tables
    and recovering multiple values through better crafted SQL Injection strings. Ultimately,
    this provides a base plate, as with the later Blind SQL Injection script, for
    developing more complicated and impressive scripts to handle challenging tasks.
    See the *Exploiting Blind SQL Injection* script for an advanced implementation
    of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Blind SQL Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, life hands you lemons; blind SQL Injection points are some of those
    lemons. When you're reasonably sure you've found an SQL Injection vulnerability
    but there are no errors and you can't get it to return your data, in these situations
    you can use timing commands within SQL to cause the page to pause in returning
    a response and then use that timing to make judgments about the database and its
    data.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that makes requests to the server and returns differently
    timed responses, depending on the characters it's requesting. It will then read
    those times and reassemble strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import the required libraries and declare the lists that we need
    to fill later on. We also have a function here that states that the script has
    indeed started. With some time-based functions, the user can be left waiting a
    while. In this script, I have also included cookies using the `request` library.
    For this sort of attack, it is likely that authentication is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We set our payload up in a dictionary along with a submit button. The attack
    string is simple enough to understand with some explanation. The initial tick
    has to be escaped to be treated as text within the dictionary. That tick breaks
    the SQL command initially and allows us to input our own SQL commands. Next, we
    say that in the event of the first command failing, perform the following command
    with `OR`. We then tell the server to sleep for one second for every character
    in the first row in the password column. Finally, we close the statement with
    a semicolon and comment out any trailing characters with a hash (or pound if you''re
    American and/or wrong):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set length of time the server took to respond as the `firstreponsetime`
    parameter. We will use this to understand how many characters we need to brute-force
    through this method in the following chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a loop that will set `x` to be all numbers from `1` to the length
    of the string identified and perform an action for each one. We start from `1`
    here because MySQL starts counting from `1` rather than zero, like Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We make a similar payload as before, but this time we are saying sleep for
    the ascii value of `X` character of the password in the password column, row one.
    So, if the first character was a lower case a, then the corresponding ascii value
    is 97, and therefore the system would sleep for 97 seconds. If it was a lower
    case b, it would sleep for 98 seconds, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We submit our data each time for each character place in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the response time from each request to record how long the server sleeps
    and then convert that time back from an ascii value into a letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For each iteration, we print out the password as it is currently known and
    then eventually print out the full password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script provides a framework that can be adapted to many different scenarios.
    Wechall, the web app challenge website, sets a time-limited, Blind SQLi challenge
    that has to be completed in a very short time period. The following is our original
    script, which has been adapted to this environment. As you can see, I''ve had
    to account for smaller time differences in differing values and server lag, and
    also incorporated a checking method to reset the testing value each time and submit
    it automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Encoding payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One method of halting SQL Injection is filtering through either server side
    text manipulation or **Web App Firewalls** (**WAFs**). These systems target specific
    phrases commonly associated with attacks such as `SELECT`, `AND`, `OR`, and spaces.
    These can be easily evaded by replacing these values with less obvious ones, thus
    highlighting the issue with blacklists in general.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that takes attack strings, looks for potentially escaped
    strings, and provides alternative attack strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is an example of the output produced when using this
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04044_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script requires no libraries! How shocking! We create an empty list for
    the values that we are about to create and dictionary of the substitute values
    that we intend to add. I've put five example values in. Spaces and `%20` are commonly
    escaped by WAFs as URLs tend to not include spaces unless something inappropriate
    is being requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, tuned systems may escape SQL specific words such as `SELECT`,
    `AND`, and `OR`. These are the very basic values and can be added to or replaced
    as you see fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve hardcoded the original string as an example, so we can see how it works.
    I''ve included a valid SQLi string with all of the above values embedded to prove
    it''s usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a second version of the original string, so that we can create a
    cumulative result and a standalone result for each substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We take each dictionary item in turn and assign each key and value to the parameters
    key and value, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We look to see if the initial term is present and then, if so, replace it with
    the key value. For example, if a space is present, we will replace it with `%50`,
    which is the tab character URL-encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This string, each iteration, will reset to the original value that we set at
    the beginning of the script. We then take that string and add to the list we created
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform the same actions as the preceding with the iterative string that
    replaces itself each turn to create a multi-encoded version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we make the list unique by turning it into a set and return it to
    the user row by row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, this can be made into an internal function rather than being used as
    a standalone script. This can alternatively be achieved by using the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
