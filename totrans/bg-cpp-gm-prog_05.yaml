- en: Chapter 5. Collisions, Sound, and End Conditions – Making the Game Playable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the final phase of the first project. By the end of this chapter you
    will have your first completed game. Once you have Timber!!! up-and-running, be
    sure to read the last section of this chapter as it will suggest ways to make
    the game better. We will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the rest of the sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the player input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the flying log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling death
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding features and improving Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the player (and other sprites)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add the code for the player's sprite, as well as a few more sprites and
    textures at the same time. This next, quite large, block of code also adds a gravestone
    sprite for when the player gets squished, an ax sprite to chop with, and a log
    sprite that can whiz away each time the player chops.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that after the `spritePlayer` object we also declare a `side` variable,
    `playerSide,` to keep track of where the player is currently standing. Furthermore,
    we add some extra variables for the `spriteLog` object, including, `logSpeedX`,
    `logSpeedY`, and `logActive` to store how fast the log will move, and whether
    it is currently moving. The `spriteAxe` also has two related `float` constant
    variables to remember where the ideal pixel position is on both the left and the
    right.
  prefs: []
  type: TYPE_NORMAL
- en: Add this next block of code just before the `while(window.isOpen())` code as
    we have done so often before. Note that all the code in this next listing is new,
    not just the highlighted code. I haven't provided any extra context for the next
    block of code as `while(window.isOpen())` should be easy to identify. The highlighted
    code is the code we have just specifically discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the entirety of this code, just before the `while(window.isOpen())` line,
    and make a mental note of the highlighted lines we have briefly discussed. It
    will make the rest of the chapter''s code easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we can draw all our new sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the player and other sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we add the code to move the player and use all our new sprites, let's
    draw them. This is so that, as we add code to update/change/move the sprites,
    we will be able to see what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code to draw the four new sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and you will see our new sprites in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the player and other sprites](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are really close to a working game now.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the player's input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lots of different things depend on the movement of the player, such as when
    to show the ax, when to begin animating the log, and when to move all the branches
    down a place. It therefore makes sense to set up the keyboard handling for the
    player chopping. Once this is done, we can put all the features we just mentioned
    into the same part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think for a moment about how we detect keyboard presses. In each frame
    we test whether a particular keyboard key is currently being held down. If it
    is, we take action. If the ***Esc*** key is being held down, we quit the game,
    or if the ***Enter*** key is being held down we restart the game. So far, this
    has been sufficient for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a problem with this approach when we try and handle the chopping
    of the tree. The problem has always been there, it just didn't matter until now.
    Depending on how powerful your PC is, the game loop could be executing thousands
    of times per second. Each and every pass through the game loop during which a
    key is held down, it is detected and the related code will execute.
  prefs: []
  type: TYPE_NORMAL
- en: So actually, every time you press ***Enter*** to restart the game, you are most
    likely restarting it well in excess of a hundred times. This is because even the
    briefest of presses will last a significant fraction of a second. You can verify
    this by running the game and holding down the ***Enter*** key. Note that the time
    bar doesn't move. This is because the game is being restarted over and over again,
    hundreds, or even thousands, of times a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t use a different approach for the player chopping, then just one
    attempted chop will bring the entire tree down in a mere fraction of a second.
    We need to be a bit more sophisticated. What we will do is allow the player to
    chop then, when he does so, disable the code that detects a key press. We will
    then detect when the player removes his finger from a key and then re-enable the
    detection of key presses. Here are the steps laid out clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the player to use the left or right arrow keys to chop a log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player chops, disable key press detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the player to remove their finger from a key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re enable chop detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This might sound complicated, but with SFML's help it will be really straightforward.
    Let's implement this now, one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted line of code, which declares a `bool` variable, and `acceptInput`,
    which will be used to determine when to listen for chops and when to ignore them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our Boolean set up we can move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Handling setting up a new game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we''re ready to handle chops, add the highlighted code to the `if` block
    that starts a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code we used a `for` loop to set the tree with no branches.
    This is fair to the player because, if the game started with a branch right above
    his head, it would be considered unsporting. Then we simply move the gravestone
    off the screen and the player into his starting location on the left. The last
    thing this new code does is to set `acceptInput` to `true`. We are now ready to
    receive chopping key presses.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the player chopping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can prepare to handle the left and right cursor key presses. Add this
    simple `if` block, which only executes when `acceptInput` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `if` block that we just coded, add the highlighted code to
    handle what happens when the player presses the right cursor key (**→**) on the
    keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Quite a bit is happening in that previous code, so let's go through it. First
    we detect if the player has chopped on the right hand side of the tree. If he
    has, then we set `playerSide` to `side::RIGHT`. We will respond to the value of
    `playerSide` later in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add 1s to the score with `score ++`. The next line of code is slightly
    mysterious, but all that is happening is that we are adding to the amount of time
    remaining. We are rewarding the player for taking action. The problem for the
    player, however, is that the bigger the score gets, the less additional time is
    added on. You can play with this formula to make the game easier or harder.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the ax is moved into its right-hand side position with `spriteAxe.setPosition`
    and the player sprite is also moved into its right-hand position.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `updateBranches` to move all the branches down one place and spawn
    a new random branch (or space) at the top of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `spriteLog` is moved into its starting position, camouflaged against the
    tree, and its `speedX` variable is set to a negative number, so that it whizzes
    off to the left. Also, `logActive` is set to true so that the log-moving code,
    which we will write soon, animates the log each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `acceptInput` is set to `false`. At this point, the player can make
    no more chops. We have solved the problem of the presses being detected too frequently
    and we will see how we re-enable chopping soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, still inside the `if(acceptInput)` block that we just coded, add the highlighted
    code to handle what happens when the player presses the left cursor key (**←**)
    on the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is just the same as the code that handles the right-hand side
    chop, except that the sprites are positioned differently and the `logSpeedX` variable
    is set to a positive value, so that the log whizzes to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a key being released
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the above work beyond the first chop, we need to detect when the player
    releases a key and set `acceptInput` back to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This is slightly different to the key handling we have seen so far. SFML has
    two different ways of detecting keyboard input from the player. The first way
    we have already seen. It is dynamic and instantaneous, exactly what we need to
    respond immediately to a key press.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next code uses the other method. *Enter* the next highlighted code at
    the top of the `Handle the players input` section and then we will go through
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First we declare an object of the type `Event` called `event`. Then we call
    the `window.pollEvent` function, passing in our new object, `event`. The `pollEvent`
    function puts data into the `event` object, which describes an operating system
    event. This could be a key press, key release, mouse movement, mouse click, game
    controller action or something that happened to the window itself (it could be
    resized and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we wrap our code in a `while` loop is because there might be
    many events stored in a queue. The `window.pollEvent` function will load them,
    one at a time, into `event`. We will see each pass through the loop, if we are
    interested in the current event, and respond if we are. When `window.pollEvent`
    returns `false`, that means there are no more events in the queue and the `while`
    loop will exit.
  prefs: []
  type: TYPE_NORMAL
- en: This `if` condition `(event.type == Event::KeyReleased && !paused)` is `true`
    when both a key has been released and also the game is not paused.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` block we set `acceptInput` back to `true` and hide the ax sprite
    off screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the game now and gaze in awe at the moving tree, swinging ax, and
    animated player. It won't, however, squash the player, and the log needs to move
    when chopped as well.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the chopped logs and the ax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player chops, `logActive` is set to `true`, so we can wrap some code
    in a block that only executes when `logActive` is `true`. Furthermore, each chop
    sets `logSpeedX` to either a positive or negative number, so the log is ready
    to fly away from the tree in the correct direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this next highlighted code, right after we update the branch sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code sets the position of the sprite by getting its current x and y location
    with `getPosition,` and then adding to it using `logSpeedX` and `logSpeedY`, respectively,
    multiplied by `dt.asSeconds`.
  prefs: []
  type: TYPE_NORMAL
- en: After the log sprite has been moved in each frame, the code uses an `if` block
    to see if the sprite has disappeared out of view on either the left or the right.
    If it has, the log is moved back to its starting point ready for the next chop.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game you will be able to see the log flying off to the appropriate
    side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating the chopped logs and the ax](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now for a more sensitive subject.
  prefs: []
  type: TYPE_NORMAL
- en: Handling death
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game has to end badly, with either the player running out of time (which
    we have already handled), or getting squished by a branch.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the player getting squished is really simple. All we want to know
    is whether the last branch in the `branchPositions` array equals `playerSide`.
    If it does, the player is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code that detects this and then we will talk about everything
    we do when the player is squished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the code does, after the player's demise, is to set `paused`
    to `true`. Now the loop will complete this frame and won't run the update part
    of the loop again until a new game is started by the player.
  prefs: []
  type: TYPE_NORMAL
- en: Then we move the gravestone into position, near where the player was standing,
    and hide the player sprite off-screen.
  prefs: []
  type: TYPE_NORMAL
- en: We set the string of `messageText` to `"SQUISHED!!"` and then use the usual
    technique to center it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the game and play it for real. This image shows the player's
    final score and his gravestone, as well as the **SQUISHED** message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling death](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is just one more problem. Is it just me, or is it a little bit quiet?
  prefs: []
  type: TYPE_NORMAL
- en: Simple sound FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add three sounds. Each sound will be played on a particular game event.
    A simple thud sound whenever the player chops, a gloomy losing sound when the
    player runs out of time, and a retro crushing sound when the player is squished
    to death.
  prefs: []
  type: TYPE_NORMAL
- en: How SFML sound works?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SFML plays sound effects using two different classes. The first class is the
    `SoundBuffer` class. This is the class that holds the actual audio data from the
    sound file. It is the `SoundBuffer` that is responsible for loading the `.wav`
    files into the PC's RAM in a format that can be played without any further decoding
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In a minute, when we write code for the sound effects, we will see that, once
    we have a `SoundBuffer` object with our sound stored in it, we will then create
    another object of the type `Sound`. We can then associate this `Sound` object
    with a `SoundBuffer` object. Then, at the appropriate moment in our code, we will
    be able to call the `play` function of the appropriate `Sound` object.
  prefs: []
  type: TYPE_NORMAL
- en: When to play the sounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we will see very soon, the C++ code to load and play sounds is really simple.
    What we need to consider, however, is when to call the `play` function. Where
    in our code will we put the function calls to `play`? Following are some of the
    features we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: The chop sound can be called from the key presses of the left and right cursor
    keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The death sound can be played from the `if` block that detects that a tree has
    mangled the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The out-of-time sound can be played from the `if` block that detects that the
    `timeRemaining` is less than zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can write our sound code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the sound code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we add another `#include` directive to make the SFML sound-related classes
    available. Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we declare three different `SoundBuffer` objects, load three different
    sound files into them, and associate three different objects of the type `Sound`
    with the related objects of the type `SoundBuffer`. Add the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can play our first sound effect. Add the single line of code as shown
    next to the `if` block that detects that the player has pressed the left cursor
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add exactly the same code at the end of the next block of code that starts `if
    (Keyboard::isKeyPressed(Keyboard::Left))` to make a chopping sound when the player
    chops on the left-hand side of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the code that deals with the player running out of time and add the highlighted
    code, shown next, to play the out-of-time-related sound effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to play the death sound when the player is squished, add the highlighted
    code to the `if` block that executes when the bottom branch is on the same side
    as the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have finished the first game. Let's discuss some possible enhancements
    before we move on to the second project.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the game and the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at these suggested enhancements for the Timber!!! project. You
    can see the enhancements in action in the `Runnable` folder of the download bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speeding up the code**: There is a part of our code that is slowing down
    our game. It doesn''t matter for this simple game, but we can speed things up
    by putting the `sstream` code in a block that only executes occasionally. After
    all, we don''t need to update the score hundreds of times a second!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Debugging console**: Let''s add some more text so we can see the current
    frame rate. As with the score, we don''t need to update this too often. Once every
    hundred frames will do.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding more trees in the background**: Simply add some more tree sprites
    and draw them in whatever position looks good (you could have some nearer the
    camera, some further away).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improving the visibility of the HUD text**: We can draw simple `RectangleShape`
    objects behind the score and the FPS counter; black with a bit of transparency
    will look quite good.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Making the cloud code more efficient**: As we alluded to a few times already,
    we can use our knowledge of arrays to make the cloud code a lot shorter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the game in action with extra trees, clouds, and a transparent
    background for the text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving the game and the code](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see the code for these enhancements, take a look in the `Timber Enhanced
    Version` folder for the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I admit that the array solution for the clouds was more efficient. But do
    we really need three separate arrays, one for active, one for speed, and one for
    the sprite itself?
  prefs: []
  type: TYPE_NORMAL
- en: A) If we look at the properties/variables that various objects have, for example
    `Sprite` objects, we will see they are numerous. Sprites have position, color,
    size, rotation, and many more as well. But it would be just perfect if they had
    `active`, `speed,` and perhaps more as well. The problem is that the coders at
    SFML can't possibly predict all the ways that we will use their `Sprite` class.
    Fortunately, we can make our own classes. We could make a class called `Cloud`
    that has a Boolean for `active` and an `int` for speed. We can even give our `Cloud`
    class an SFML `Sprite` object. We could then simplify our cloud code even further.
    We will look at designing our own classes in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we added the finishing touches and graphics to the Timber!!!
    game. If, prior to this book, you had never coded a single line of C++ then you
    can give yourself a big pat on the back. In just five modest chapters you have
    gone from zero knowledge to a working game.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will not be congratulating ourselves for too long because in the
    next chapter we will move straight on to some slightly more hardcore C++, which
    we can use to build more complicated and fuller-featured games.
  prefs: []
  type: TYPE_NORMAL
