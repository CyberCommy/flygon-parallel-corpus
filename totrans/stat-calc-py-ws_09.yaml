- en: 9\. Intermediate Statistics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will progress through to some intermediate statistical concepts.
    We will learn what the law of large numbers tells us about the value of the sample
    mean as a sample gets larger.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply the central limit theorem
    to describe the distribution of the sample mean, create confidence intervals to
    describe the possible value of the average with some degree of confidence, use
    hypothesis testing to evaluate conclusions based on the evidence that our sample
    provides, and use regression equations to analyze data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have described and explored data using descriptive
    statistics and visual techniques. We have also looked at probability, randomness,
    and using simulations of random variables to solve problems. The idea of distributions
    was also examined, which plays a much bigger role later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at applying statistical ideas, there are some important questions
    to answer concerning methodology. Some examples of these questions could include
    "how large should I make my sample?" or "how confident can we be in the results?".
    For this chapter, we will look at how we can apply two of the most important theorems
    in statistics, starting with their practical implications before moving onto solving
    common problems using the more useful techniques that are derived from these important
    ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain what the law of large numbers is and clarify
    how sample size affects the sample mean. The central limit theorem will be discussed,
    along with its application in confidence intervals and hypothesis testing. Using
    Python, we will construct functions to calculate our confidence intervals to describe
    sample statistics and margin of error in a poll. Hypothesis tests will be conducted
    in Python to evaluate the evidence of a collected sample against a set of contradictory
    hypotheses. Finally, using the linear regression capabilities of Python, we will
    create a linear model to predict new data values.
  prefs: []
  type: TYPE_NORMAL
- en: Law of Large Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many schemes and systems that people claim can make you a big winner
    at the casino. But what these people fail to see is the reason why casinos are
    lucrative money-makers; the odds are always on the casino's side, ensuring that
    the casino will come out ahead and always win (in the long run). What the casinos
    have come to depend on is something called the law of large numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we figure out how the casinos always make themselves winners in the
    long run, we need to define several terms. The first is **sample average**, or
    **sample mean**. The sample mean is what everybody thinks of when they think of
    the average. You calculate the sample mean by adding up the results and dividing
    by the number of results. Let''s say we flip a coin 10 times and it comes up heads
    7 times. We calculate the sample mean, or the average number of heads per flip,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Formula for sample mean'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Formula for sample mean'
  prefs: []
  type: TYPE_NORMAL
- en: The sample average is typically denoted as *x̄*, pronounced *x bar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second term we need to understand is **expected value**. Expected value
    is the theoretical value we can expect our average to be, based on probability.
    For the discrete examples, like our coin flipping experiment, we calculate it
    by taking the sum of each result multiplied by the probability of it occurring.
    For our coin flipping example, we take the number of heads on each side of the
    coin, 1 for heads and 0 for tails, and multiply it by the probability of each
    side occurring, 0.5 for each side in this instance. To write it out mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Formula for expected value'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Formula for expected value'
  prefs: []
  type: TYPE_NORMAL
- en: We can expect 0.5 heads per coin flip, which makes sense since we have a 50%
    chance of obtaining heads in any given coin flip.
  prefs: []
  type: TYPE_NORMAL
- en: Another term is **sample**, which is a collection of results. In this instance,
    the collection of coin flip results is our sample. One important characteristic
    of a sample is its size, or the number of results you have. We have 10 coin flips,
    so our sample size is 10\. The final term is the idea of **independence**, which
    is the notion that one result in no way impacts another result. Our coin flips
    are independent; getting heads on the first coin flip is in no way going to impact
    the result of the 10th coin flip.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our sample average and expected value are not the same. While getting
    7 heads out of a sample of 10 coin flips may seem unlikely, it is not an impossible
    result. Yet we know that about half of our sample should be heads. What happens
    if we keep flipping our coin 10 more times? Or even 100 or 1,000 more times? The
    answer to this is provided by the law of large numbers. **The law of large numbers**
    states that the value of the sample mean will converge to our expected value as
    the size of the sample grows. In other words, as we flip our coin more and more,
    the sample average should get closer and closer to 0.5.
  prefs: []
  type: TYPE_NORMAL
- en: Python and Random Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will use the random library several times, but it is not
    truly random at all—it is what we call pseudo-random. A **pseudo-random** number
    is a number that is typically generated from an algorithm. We initialize the algorithm
    using a number called a **seed**. A lot of the time, the seed is based on the
    time or date the program is executed. However, Python (and most other languages)
    allows you to set the seed equal to whatever number you want. If you initialize
    your algorithm with the same seed, then the same pseudo-random numbers will be
    generated every time. This is useful when you are working with random numbers
    and want to produce the same results every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: The Law of Large Numbers in Action'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s expand upon our coin flipping experiment in Python. First, let''s create
    a coin flipping simulator. Open up your Jupyter notebook and type the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to import the `random` Python package and set the `seed` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a variable for our sample size and, for this instance, set it
    equal to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an empty list so that we can collect the results of our coin flip
    experiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two variables to compile the results (the number of heads and the average
    number of heads per flip, respectively):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we print the results to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your notebook should get you results that look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are generating random numbers in this simulation, the results that
    you get may vary. Getting 4 heads out of 10 coin tosses (a sample mean of 0.4
    heads per flip) is something that seems plausible, but is different than our expected
    value of 0.5\. But notice what happens when we change the sample size from 10
    to 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the entire program again (make sure to include the line with `random.seed(54321)`)
    and this time, the result will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the sample average (`0.51`) is now a lot closer to the expected
    value (`0.50`) with a sample size of 100 rather than 10\. This is a prime example
    of the law of large numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2VCT9An.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2NOMGhk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Coin Flipping Average over Time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go back to our coin flipping simulator code and build it out to keep a
    running sample average as we flip our coin. We are going to flip a coin 20,000
    times and graph the sample mean using a line graph to show how it changes over
    time and compares to our expected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `random` and `matplotlib` Python packages and set the random seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the sample size or the number of coin flips:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variables that we are going to use to collect the results of
    our simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the simulation and collect the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the results to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a line graph that shows the sample mean over time, along with marking
    our expected value using a dashed line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our notebook will yield the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will generate the following graph, which shows how the average number
    of heads per coin flip changes as our sample size gets bigger (denoted by the
    solid line). Notice that after approximately 2,000 coin flips, the sample mean
    matches the expected value (about 0.5 heads per coin flip):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Average number of heads per coin flip over a sample size'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Average number of heads per coin flip over a sample size'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2BZcR2h.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/31AIxpc.
  prefs: []
  type: TYPE_NORMAL
- en: A Practical Application of the Law of Large Numbers Seen in the Real World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best casino games to analyze through the lens of probability is roulette.
    Playing the game is relatively simple. The centerpiece of the game is a giant
    wheel with spaces and labels 1 through 36, 0, and 00 (double zero). The odd numbers
    are colored red, the even numbers are colored black, and both zero spaces are
    colored green. The wheel is spun and a ball is dropped into the wheel space moving
    the opposite direction to which the wheel is spinning. Eventually, the ball drops
    down into one of the 38 spots on the wheel. The result of where the ball lands
    is what people are betting on. They can place many different types of bets, ranging
    from landing on one specific number or which color space the ball will land on.
    The casino pays out according to the type of bet you have placed. When most people
    see roulette for the first time, a lot of them ask the question, "What's the deal
    with the two green spaces?" We will see clearly in a couple of pages why the green
    spaces are very important to casinos, but first let's talk about what we can expect
    from playing Roulette.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a little simplicity to the game, we are going to bet on the ball landing
    on a red number every single time. The payout on winning such a bet is 1:1, so
    if we bet $5 and win, we get to keep our $5 and win $5 more. If we lose the bet,
    we win nothing and lose the $5 bet. If we bet on red, here are the following probabilities
    of what can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bet on red and if the ball lands on red, we win: ![1](image/B15968_09_InlineEquation1.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bet on red and if the ball lands on black, we lose: ![2](image/B15968_09_InlineEquation1a.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bet on red and if the ball lands on green, we lose: ![3](image/B15968_09_InlineEquation2.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the outcomes in terms of the money we can win or lose when placing
    a $1 bet:'
  prefs: []
  type: TYPE_NORMAL
- en: Bet on red and if the ball lands on red, we win $1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bet on red and if the ball lands on black, we lose $1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bet on red and if the ball lands on green, we lose $1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of a discrete distribution. To calculate the expected value
    of a discrete distribution, you multiply the value of the outcome by the probability
    with which it occurs. If you look at the preceding two lists, we have the probability
    and the value of each outcome in our game of roulette, so now we can calculate
    the expected amount of money we can win or lose for a typical game of roulette:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(probability of landing on red * winnings or losses when we land on red) +
    (probability of landing on black * winnings or losses when we land on black) +
    (probability of landing on green * winnings or losses when we land on green)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we calculate the expected amount we can win based on the probabilities
    we''ve calculated, we''ll get the *(0.474*1)+(0.474*-1)+(0.053*-1) ≈ -0.05* value:'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding calculation tells us that we can expect to lose about 5 cents
    for every $1 bet on red. If we increase our bet, we can expect to lose more money.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Calculating the Average Winnings for a Game of Roulette If We
    Constantly Bet on Red'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rework our simulation code to simulate playing games of roulette and
    track the overall average amount of money we win or lose per game. Then, we will
    graph the results like we did for the coin flipping scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `random` and `matplotlib` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable for the sample size and set it to `10`. Create a variable
    called `bet` and set it to $1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variables that we will use to collect the results of our simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the simulation and collect the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the results of the simulation and the expected value of the average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Graph the expected value of the net change in money per game and the sample
    average of the net change in money per game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your notebook and you will get the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Running average net per game of roulette over 10 games played'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Running average net per game of roulette over 10 games played'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the solid line represents the average winnings per
    game during the 10 games we played. The dashed line represents how much money
    we can expect to win or lose per game. We should be losing about 5 cents per game
    but, in this specific scenario, we ended up losing 20 cents in total, much less
    than losing 5 cents per game. If you remove `random.seed(54321)` from the code
    and rerun the simulation, the results will be different. Feel free to experiment
    and change the amount you bet each time and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/3dTdlEb.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2ZtkOEV.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this isn''t reflective of what happens in a casino. No casino only opens
    for 10 games of roulette a day. So, what happens to our graph if we change the
    number of games from 10 to 100,000? Setting the sample size variable to 100,000
    and rerunning the code yields a graph that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Running average net per game of roulette over 100,000 games played'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: Running average net per game of roulette over 100,000 games played'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the blue line quickly converges to the average dollar net per game
    of -0.05\. Specifically, this simulation yielded a -0.054 dollar net, not too
    far off our expected value. In practical terms, the casino will gain money and
    gamblers will lose money on a per game basis in the long run. Now, back to the
    question of the green spaces. If we removed them from the game, there would be
    18 red and 18 black spaces. Let''s recalculate our expected value under these
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(probability of landing on red * winnings or losses when we land on red) +*'
  prefs: []
  type: TYPE_NORMAL
- en: '*(probability of landing on black * winnings or losses when we land on black)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Formula to calculate the expected value'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Formula to calculate the expected value'
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that without the green spaces, neither the casino nor the
    gamblers will win or lose any money in the long run; both parties will walk away
    with the same amount of money they started with.
  prefs: []
  type: TYPE_NORMAL
- en: Central Limit Theorem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By way of a quick review of the previous section, the law of large numbers tells
    us that as our sample gets larger, the closer our sample mean matches up with
    the population average. While this tells us what we should expect the value of
    the sample mean to be, it does not tell us anything at all about the distribution.
    For that, we need the central limit theorem. The **central limit theorem** (**CLT**)
    states that if we have a large enough sample size, the distribution of the sample
    mean is approximately normal, with a mean of the population mean and a standard
    deviation of the population standard deviation divided by the square root of *n*.
    This is important because not only do we know the typical value that our population
    mean can take, but we know the shape and variance of the distribution as well.
  prefs: []
  type: TYPE_NORMAL
- en: Normal Distribution and the CLT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 8*, *Foundational Probability Concepts and Their Applications*,
    we looked at a type of continuous distribution known as *normal distribution*,
    also known as a bell curve or a Gaussian curve (all three of these names mean
    the same thing). While there are many instances of normal distribution that appear,
    that's not the main reason why it is special. The reason that normal distribution
    is special is because the distribution of many statistics follows a normal distribution,
    including the sample mean.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the distribution of the sample mean turns out to be vital in many of
    the typical statistical problems that we end up solving day to day. We take the
    mean and the variance information and put it together to have some idea of how
    our sample mean will vary from sample to sample. This tells us whether a sample
    mean is something we expect to show up or something that we are not expecting
    and need to study closer. We can take two different samples from supposedly identical
    populations and prove that they are, in fact, significantly different to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Random Sampling from a Uniform Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can illustrate and verify the CLT by constructing a couple of simulations
    in Python, which is what we will do in the following exercises. The first simulation
    we are going to run is to take a random sample from a uniform distribution. A
    **uniform distribution** is one where every outcome is equally likely to be picked.
    If we were to graph a uniform distribution, it would look like a straight horizontal
    line going across the page. Some examples of uniform distributions are a dice
    roll, flipping a coin, or typical random number generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Showing the Sample Mean for a Uniform Distribution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s draw a random sample from a random number generator that generates random
    numbers between 0 and 100 and calculates the sample average:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following Python packages that we will be using and set the `seed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable for the size of each sample and the total number of samples
    that you want to take. Since the CLT states that we need a sufficiently large
    sample, we have selected a sample size of 30\. Next, we are going to need a lot
    of sample means to graph and have set that value equal to 10,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the list we will use to collect our sample means and run through
    our simulation the specified number of times, collecting the sample mean of each
    sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a histogram of the sample means that we collected. Over the top of the
    histogram, we will overlay what the CLT says the distribution of the sample mean
    should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code in our notebook will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Distribution of sample average from 10,000 samples from a uniform
    distribution with a sample size of 30'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Distribution of sample average from 10,000 samples from a uniform
    distribution with a sample size of 30'
  prefs: []
  type: TYPE_NORMAL
- en: The expected distribution given to us by the CLT almost perfectly overlays the
    histogram of the results of our simulation. Feel free to experiment and change
    the sample size and the number of sample means used to generate the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/31JG77I.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/3ggAq5m.
  prefs: []
  type: TYPE_NORMAL
- en: Random Sampling from an Exponential Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that the CLT worked for the sample mean taken from a uniform distribution,
    but what about something that looks nothing like a uniform distribution? The CLT
    does not restrict the distribution of the sample we are drawing from, so would
    it work for something that looks nothing like a normal distribution? Let''s look
    at the exponential distribution. The **exponential distribution** is a distribution
    that falls very quickly as it goes left to right before leveling off and approaching,
    but not quite touching, zero. The following graph is of a typical exponential
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Example of exponential distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: Example of exponential distribution'
  prefs: []
  type: TYPE_NORMAL
- en: There a lot of examples of exponential distributions in the real world. Examples
    include how fast hot liquids cool, radioactive decay, and modeling the failure
    of mechanical parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Taking a Sample from an Exponential Distribution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will randomly sample an exponential distribution. The
    following is the code that we can use to simulate drawing from an exponential
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Python packages that we will need. In order to see the effects of
    taking a smaller sample, we will set the sample size to `5` (refer to the following
    code), but keep the number of samples at `10000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variable that we will use to collect the results of our simulation.
    Run the simulation, but this time sample from an exponential distribution rather
    than a uniform distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a histogram of the sample means we collected and overlay what the CLT
    says we should expect from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code that we typed in our Jupyter notebook will give us the following
    graph:![Figure 9.9: Distribution of sample average from 10,000 samples from an
    exponential distribution with a sample size of 5'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Distribution of sample average from 10,000 samples from an exponential
    distribution with a sample size of 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous exercise entitled *Exercise 9.04*, *Showing the Sample Mean
    for a Uniform Distribution*, the orange line tells us what the CLT expects us
    to have. While our green histogram is similar to what we should expect, it is
    clearly skewed to the right and not a bell-shaped curve at all. But remember that
    the CLT requires us to take a large enough sample. Clearly, 5 is not large enough,
    so let''s increase our sample size from 5 to 50 and rerun the code. Doing so should
    yield something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Distribution of sample average from 10,000 samples from an exponential
    distribution with a sample size of 50'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: Distribution of sample average from 10,000 samples from an exponential
    distribution with a sample size of 50'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks a lot closer to what we expected. Clearly, a sample size of 50 is
    big enough, while a sample size of 5 is not. But a question might be running through
    your head right now: "What sample size is large enough and how will we know?".
    The answer really depends on the underlying distributions; the more skewed the
    underlying distribution, the larger sample you must take to ensure a large enough
    sample for the CLT.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2D2phXE.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2NRcvNP.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we will go through how to calculate the sample size you
    would need to take for a desired result, but we only consider the CLT to apply
    to samples of size 30 or more.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence Intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw with the previous simulations, our sample mean can vary from sample
    to sample. While, in a simulation, we have the luxury of taking 10,000 samples,
    we cannot do that in the real world; it would be far too expensive and time-consuming.
    Typically, we are given only enough resources to gather one sample. So how can
    we be confident in the results of our sample? Is there any way we can account
    for this variability when reporting our sample mean?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the CLT gives us an idea of the variance in our sample
    mean. We can apply the CLT and take sampling variability into account by using
    a confidence interval. More generally, a **confidence interval** is a range of
    values for a statistic (an example of a statistic is a sample mean) based on a
    distribution that has some degree of confidence of how likely it is to contain
    the true value for the mean. We are not always going to be calculating confidence
    intervals for just the sample mean; the idea applies to any statistic that you
    calculate from a sample (the only difference is how you calculate it). Confidence
    intervals can be used to calculate how big a sample we need to take and what the
    margin of error is.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Confidence Interval of a Sample Mean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first type of confidence interval we will calculate is a **z-confidence
    interval**, which will give us an interval (or range) of values for our sample
    mean based on the standard normal model (sometimes referred to as a z-distribution).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to calculate a z-confidence interval for our sample mean, we are going
    to need to know four things:'
  prefs: []
  type: TYPE_NORMAL
- en: The sample mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The population variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The critical value or some level of confidence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sample mean and size are calculated from the sample that we collect. The
    population variance isn''t something we calculate from our sample; the population
    variance is a value that is given to us. Typically, it is some accepted value
    for variance given from prior studies and research. The final piece of the puzzle
    is the critical value, or the confidence level; this is where the normal distribution
    and the CLT come in. To get an idea of what a critical value is, let''s look at
    a standard normal distribution (which is a normal distribution that always has
    a mean of 0 and a variance of 1) and the area under its curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Example of a standard normal model'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: Example of a standard normal model'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know in our normal distribution that our mean is in the center (it is 0
    in this case). The area underneath the curve from -1 to 1 accounts for 68% of
    the total area. Another way of putting this is that 68% of the values described
    by this distribution are between -1 and 1\. About 95% of the values are between
    -2 and 2\. Applying this to the distribution of the sample mean, we can find the
    range that 95% of our sample means will take. Referring back to *Figure 9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Distribution of sample average from 10,000 samples from a uniform
    distribution with a sample size of 30'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Distribution of sample average from 10,000 samples from a uniform
    distribution with a sample size of 30'
  prefs: []
  type: TYPE_NORMAL
- en: If we look, the center of our bell curve is 50, which is the expected value
    of a uniform distribution that goes from 0 to 100\. The expected standard deviation
    for a uniform distribution that goes from 0 to 100 would be about 5.27 (![4](image/B15968_09_InlineEquation3.png)).
    So, applying the same logic as before, about 68% of our values are between 45
    and 55, and about 95% of our values are between 40 and 60\. These ranges are our
    confidence intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more formal equation for calculating a z-confidence interval is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Formula for calculating z-confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: Formula for calculating z-confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x̄* is the sample mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* is the sample size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*σ* is the population standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Z* is the critical value of our confidence level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our final confidence interval is going to be two numbers: an upper limit where
    we add the two terms together, and a lower limit where we subtract the two terms.
    Luckily, this is something we can write a function for in Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes the following as input: the data we have gathered, along
    with the population standard deviation (given to us), and a level of confidence.
    It will print what the confidence level is to the console and return it as a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Finding the Confidence Interval of Polling Figures'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are running a political campaign and decide to run 30 focus groups with
    about 10 people in each group. You get the results and want to report to your
    candidate the number of people who would vote for them in a typical 10-person
    group. Since there is some variability in each focus group, you decide that the
    most accurate way is to give a 95% z-confidence interval. You assume from past
    experience that the standard deviation is 2.89\. Let''s model this using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `random` Python package and set the seed to `39809`. This will ensure
    that we get the same results every time we run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize our sample list and collect our samples from our focus groups. From
    there, we just enter the information into our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, then the following should be printed when
    you run your notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that in a typical focus group, anywhere between 4 to 6 people
    in each group will vote for our candidate. This signals to you that the campaign
    should keep working harder to convince more people to vote for your candidate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2Zp6XiU.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/3eUBL1B.
  prefs: []
  type: TYPE_NORMAL
- en: Small Sample Confidence Interval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The z-confidence interval works for when you have a large enough sample (remember
    our rule of thumb of a sample size of 30 or greater); but what if the sample you
    have is not large enough? Then you can use a **t-confidence interval**, which
    is basically the same as the z-confidence interval with two exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The t-confidence interval does not assume that you know the population standard
    deviation, so we use the sample standard deviation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the t-distribution to calculate the critical value rather than the z
    (standard normal) distribution. The difference between the two is that the t-distribution
    is less concentrated around the mean to account for not knowing the population
    standard deviation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to know two things in order to calculate a t-confidence interval; the
    first is the degrees of freedom, which is calculated as the sample size minus
    1 (*n-1*). The second is the confidence level. The formula for a t-confidence
    interval is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: Formula for calculating t-confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: Formula for calculating t-confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x̄* is the sample mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t*n-1 is the critical value with *n-1* degrees of freedom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*s* is the sample standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* is the sample size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like with the z-interval, our final answer is going to be a lower and
    upper limit. We will write a function in Python to do all the calculation work
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the same sample list as the z-confidence interval. The `t_confidence_interval`
    function is used in the same way as our z-confidence interval function; we will
    enter a list of the data for which we want to calculate the t-confidence interval
    and specify our confidence level. There is no need to include a population standard
    deviation; the t-confidence interval uses the sample standard deviation and will
    calculate it for us automatically. The correct usage of the `t_confidence_interval`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do everything correctly, the following should output in your notebook
    when you run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the t-confidence interval is wider than our z-confidence interval.
    This is because we have more uncertainty in using the sample standard deviation
    to estimate the standard deviation of the population than using the known value.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about the t-confidence interval is that not only can it be used
    for small samples or situations where you do not know the population standard
    deviation; it can be used in any situation where you would use a z-confidence
    interval. In fact, as your sample size gets larger, the closer the t-distribution
    gets to the z (standard normal) distribution. So, if you are ever unsure of the
    value of the population standard deviation that you are given or find while looking
    at prior research, you can always play it safe and use the t-confidence interval.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence Interval for a Proportion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go back to the example of the political campaign. After the different
    focus groups gave you results that were not definitive, a new poll came out that
    has your candidate winning the race, with 54% of the sample of 350 people saying
    they will vote for your candidate, while your opponent got the other 46%. You
    want to calculate a confidence interval for this proportion so you can consider
    sampling variability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know how to calculate the confidence interval of a sample mean, but how
    do we calculate a confidence interval for a proportion? The percentage of a sample
    is different than the mean value of a sample. Luckily for us, there is a formula
    for calculating a confidence interval for a proportion of a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: Formula for calculating confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: Formula for calculating confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p̂* is the sample proportion. In this example, it is the 54% of people that
    voted for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* is the sample size. For this example, it is the 350 people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Z* is our critical value from the standard normal distribution. We calculate
    this the same way as the z-confidence interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some conditions that need to be met before we can apply this:'
  prefs: []
  type: TYPE_NORMAL
- en: The observations in our sample are independent—so, in our example, one person's
    answer did not influence another person's answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need at least 10 successes and 10 failures—so we need at least 10 people
    that vote for us and 10 people that would vote for your opponent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, we can create a function in Python to do the calculations for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the other functions we created, we do not feed in a list of our data
    values. Instead, we can enter our statistics directly and set a confidence level.
    To create a confidence interval for our poll, we enter the information like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following results will be printed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that we can be 95% confident that the true value of the proportion
    of the vote our candidate would get is between 48.8% and 59.2%. Hence, the results
    of the poll are inconclusive, and it shows us we still have more work to do to
    convince people to vote for our candidate. Note that this is where polls typically
    get the margin of error. The **margin of error** is the distance from our point
    estimator (*p̂* in this example) and either boundary (since the confidence interval
    is symmetrical; it does not matter whether we use the upper or lower bound). For
    this poll, our margin of error would be *0.592 - 0.54 = 0.052*.
  prefs: []
  type: TYPE_NORMAL
- en: So, the margin of error for the preceding poll would be about 5.2%. This is
    something to keep in mind when you are taking in the results of any poll, whether
    political or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Hypothesis Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we ran simulations where the sample mean changed from
    sample to sample, despite sampling from the same population. But how will we know
    if a sample mean we calculate is significantly different from a preconceived value
    or even a different sample? How will we know if a difference is variability in
    action, or if the measures are different? The answer lies in conducting a hypothesis
    test.
  prefs: []
  type: TYPE_NORMAL
- en: A **hypothesis test** is a statistical test that is designed to determine whether
    a statistic is significantly different from what we expect. Examples of hypothesis
    tests include checking to see whether the sample mean is significantly different
    from a pre-established standard or compare two different samples to see whether
    they are statistically different or the same.
  prefs: []
  type: TYPE_NORMAL
- en: Parts of a Hypothesis Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main parts to any hypothesis test: the hypotheses, the test
    statistic, and the p-value. The *hypotheses* are what you are conducting the tests
    on to see whether they should be rejected or accepted. There are always two hypotheses
    for any test: a **null hypothesis** (typically referred to as using the symbol
    *H*0) and an **alternative hypothesis** (typically referred to as using the symbol
    *H*A). The null hypothesis is what we have always assumed or known to be true;
    in other words, it is what our pre-established standard is. The alternative hypothesis
    is the alternative we are going to compare to our null; in practical terms, it
    is the thing that we want to prove to be true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of several hypotheses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are the leader of a manufacturing company and you have a process that typically
    uses up 15 liters of fuel per hour. Your company is testing changes to this process
    to try and use less fuel. They took a sample of 24 hours and found that the new
    process used 13.7 liters of fuel per hour. The company needs to know if that reduction
    is significant or whether it can be attributed to variance in the process. Your
    null hypothesis would be what the process typically uses: *H*O*: μ = 15*. We want
    to try and prove that the new process uses less fuel, so our alternative hypothesis
    is: *H*A*: μ < 15*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Richard is a commercial baker in your city. He is wondering whether to invest
    in new equipment for the bread-making portion of his factory. Normally, his factory
    can make about 15,000 loaves of bread during one shift. Richard sent one of his
    shifts to try the new equipment for 5 shifts and they could make, on average,
    17,500 loaves per shift. You tell Richard to test to see whether this is significantly
    different; the null hypothesis would be based on what he typically makes (*H*O*:
    μ=15000*), and the alternative hypothesis would be what he wants to try and prove
    (*H*A*: μ = 15000*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linda is an analyst for a quality control department in her company. A part
    that the company makes needs to be 15 inches long. Since the company cannot measure
    every part that is made, Linda takes a sample of 100 parts and finds that the
    average length of this sample is 14.89 inches. She tells you that they expect
    each part to be 15 inches (*H*O*: μ = 15*), and they want to try and figure out
    whether the sample is evidence that the average part is not typically 15 inches
    (*H*A*:μ ≠ 15*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the preceding situations depicts one of the three typical hypotheses
    tests that you will encounter: an upper-tailed test, a lower-tailed test, and
    a two-tailed test, respectively. Knowing the type of test you are conducting is
    necessary so that you can write your hypothesis and calculate your p-value correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: The **test statistic** is a number that describes how our observed sample compares
    to what we assume or know to be true about the mean we are testing. It is the
    part that is going to vary the most between the different tests that we conduct;
    it is based on the specific statistic we are testing and the test used. This is
    the most mathematical part of the statistics test, typically represented by a
    formula. The **p-value** is the last part of our hypothesis test; it is typically
    defined as the probability of seeing a sample like the one we collected if we
    assume the null hypothesis is true. We compare this value to some level of significance
    (0.05 is the most frequently used significance level); if our p-value is smaller
    than our level of significance, then we reject the null hypothesis and have evidence
    that the alternative hypothesis is true. Likewise, if our p-value is larger than
    our level of significance, we fail to reject the null hypothesis and do not have
    any evidence that the alternative hypothesis is true.
  prefs: []
  type: TYPE_NORMAL
- en: The Z-Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like our z-confidence interval, there is a hypothesis test based on the
    standard normal model called the **z-test**. Just like the z-confidence interval,
    the z-test assumes that we know the population standard deviation and we have
    a large enough sample (again, the rule of thumb is a sample size of at least 30).
    The basic setup for a z-test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*H*O*:μ = μ*O (don''t worry; *μ*O is what we typically think the mean is and
    is just a number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*H*A*: μ < μ*O or *H*A*: μ > μ*O or *H*A*: μ ≠ μ*O (*μ*O will always match
    what we have for the null hypothesis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test statistics: ![5](image/B15968_09_InlineEquation4.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x̄* is the sample average.'
  prefs: []
  type: TYPE_NORMAL
- en: '*σ* is the known population standard deviation.'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* is the sample size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'P value: ![6](image/B15968_09_InlineEquation5.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While none of this math is hard once you get the hang of it, we can use Python
    to make the calculations very simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.07: The Z-Test in Action'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a random sample from a distribution with a known population mean
    and see whether our z-test can select the correct hypothesis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start this exercise by importing all the libraries we are going to need
    in order to be able to run our code and set the `seed` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a function to do our z-test for us. The inputs will be a sample
    (in the form of a list), the population standard deviation (remember, specifying
    this is one of the requirements for the z-tests), the value of our hypothesis,
    the significance level of our test, and the test type (upper-, lower-, or two-tailed
    test). We will calculate the sample mean and sample size from the given list.
    Then, we will take the inputs and calculate our test statistic. Then, based on
    what hypothesis test we are deciding to do, we calculate a p-value accordingly.
    Finally, we compare our p-value to the level of significance, and if it is less
    than our level of significance, we reject the null hypothesis. Otherwise, we fail
    to reject the null hypothesis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We draw a random sample size of `50` from a normal distribution with a mean
    of `15` and a standard deviation of `1`. We will print the sample mean to the
    console so we know what it is (it will be different every time you run this code
    since we take a random sample every time). We use our z-test function to conduct
    a lower-tailed test since we want to see whether our mean is significantly less
    than `16`. We specify the list that contains our data (`data1`), the population
    standard deviation (we know this is `1`), the value of the hypothesis (we want
    to see whether it is significantly less than `16`), the level of significance
    (most of the time this will be `0.05`), and finally the type of test (since we
    want to see whether the mean is lower than `16`, this is a lower-tailed test):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, we should get something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since the p-value of our test statistic is less than 0.05 (written out from
    the scientific notation, it's 0.0000000000000509), we know that the sample mean
    of 15.06 is significantly less than 16, based on our sample size of 50\. Since
    we took the sample from a population with a mean of 15, the test result was what
    we expected it to be. Again, since we are taking a random sample in the beginning,
    your results may vary, but, for most samples, this test should be rejecting the
    null hypothesis. In the tuple that is returned, the first value is the test statistic
    and the second is our p-value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s test to see whether our mean is significantly larger than `14`.
    Following the same pattern as the lower-tailed test, our code will appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, the following output is displayed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For our final z-test, we will perform a two-tailed test and see whether our
    sample mean differs significantly from `15`. In this test, we really do not have
    a preference whether it is higher or lower than `15`; we just want to see whether
    it is different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This result makes sense because we sampled for a population where the mean was
    15.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2C24ItD.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/2NNyntn.
  prefs: []
  type: TYPE_NORMAL
- en: Proportional Z-Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common use of the z-test is not in testing the significance of a sample
    mean, but the significance of a percentage. The assumptions required for this
    are the same as the requirements for a proportional z-confidence interval: random
    sample, independence, and at least 10 successes and 10 failures. We would calculate
    the test statistics for this test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Formula to calculate test statistics'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Formula to calculate test statistics'
  prefs: []
  type: TYPE_NORMAL
- en: 'We would calculate the p-value the same way as the z-test for a sample mean.
    We do not need to create a function for this test; one already exists in the `statsmodels.stats.proportion`
    Python package called `proportions_ztest`. The syntax for this function is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` is the number of successes in our sample.'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is the size of our sample.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Po` is the hypothesized value we want to test against.'
  prefs: []
  type: TYPE_NORMAL
- en: The alternative specifies a lower-tailed, upper-tailed, or two-tailed test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this function is a tuple; the first element is the test statistic,
    and the second element is the p-value. Let''s go back to our polling example:
    your campaign conducted a poll of their own and sampled 350 people. Out of 350
    people, 193 people said they would vote for you. We want to see whether this sample
    we collected is evidence that a majority of people are going to vote for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assign the results of our z-test to a variable called `results`. We
    call the function where `193` is the number of successes/people who will vote
    for us, and the sample size is `350`. Since we want to test to see whether our
    sample is evidence that we have the majority of the vote, we want to perform an
    upper-tailed test where the hypothesized value is `0.50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is run, the following is printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our p-value is about 0.027, which is a significant result at 0.05\. This tells
    us that our sample is evidence that we have the majority of the vote.
  prefs: []
  type: TYPE_NORMAL
- en: The T-Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the z-test is useful for conducting a hypothesis test on a proportion,
    it is not very practical when testing a sample mean because we typically do not
    know the standard deviation of the population. There are other times where our
    sample size is very small. For this situation, we can use a t-test, which is analogous
    to our t-confidence interval. Just like with the t-confidence interval, you do
    not need to know the population standard deviation; you can use the sample to
    estimate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the t-test is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Formula to calculate t-test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: Formula to calculate t-test'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x̄* is the sample mean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*μ*O is the hypothesized value we are testing against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*s* is the sample standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* is the sample size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will calculate the p-value using a t-distribution instead of a standard
    normal distribution. However, we are not going to focus too much on the mechanics
    of this specific test, as it is like the other hypothesis tests we have covered.
    We are going to create a function to conduct our t-test, similar to our z-test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sample` is a list of the measures of your sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hypoth_value` is the value you are testing against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sig_level` is the significance level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_type` is the type of test—lower, upper, or two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 9.08: The T-Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will examine two different samples: one large sample and one small sample.
    Both samples will be randomly selected from a normal distribution from a mean
    of 50 and a standard deviation of 10\. The only difference between the two samples
    is that the large sample will have a size of 100 and the smaller sample will have
    a size of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the libraries we will use, set the seed, and then randomly
    generate our large sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create functions for our t-test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run three different tests: one to see whether the sample mean differs
    significantly from `50`, whether the sample mean is significantly lower than `51`,
    and whether the sample mean is significantly higher than `48`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first test is insignificant, and we do not have evidence that the mean is
    significantly different to `50`. The second test is insignificant as well; the
    sample is not evidence that the mean is significantly greater than `51`. The last
    test is significant; the sample is evidence that the mean is significantly higher
    than `48`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the same three tests, only this time we will use a sample
    with a size of `5` (we will use the first `5` elements from the large sample):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The results for the first two tests do not change, while the third test did
    change despite the nearly identical sample mean. The reason for the difference
    is due to the small sample size; since there is less certainty due to the small
    sample, the test is more conservative and less likely to reject the null hypothesis.
    This can be shown in our equation for our test statistic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Formula to calculate test statistics for t-test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: Formula to calculate test statistics for t-test'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the denominator ![7](image/B15968_09_InlineEquation6.png); if *n* is
    smaller, then the value of ![8](image/B15968_09_InlineEquation6a.png) will be
    larger (for a constant *s*). This causes the value of the denominator for the
    test statistic to be larger, leading to a smaller test statistic overall.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/38mMShg.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/3gkBdlK.
  prefs: []
  type: TYPE_NORMAL
- en: 2-Sample T-Test or A/B Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final test we will be looking at is the 2-sample t-test. This is a hypothesis
    test that compares the means of two different samples and can tell you whether
    one mean is significantly higher, significantly lower, or significantly different
    than the other mean. One of the applications of this is something known as A/B
    testing. A/B testing is where you show two different groups two different versions
    of a website or app, and collect some sort of measure of performance. Examples
    of measures of performance could be something like the amount of money spent,
    the number of people that clicked on an ad, or the amount of money people spent
    on micro transactions inside your mobile game. Once you have collected the data,
    you test the two sample means and see whether the differences between the two
    different versions are significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The null and alternative hypotheses work a little bit differently for a two-sample
    test than they do for a one-sample test. Instead of comparing a sample mean to
    a value, you are comparing it to another mean. How we typically show this is by
    comparing the difference to zero. Using some algebra, you can figure out how the
    alternative hypotheses should be set up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upper-tailed (mean 1 is greater than mean 2): ![13](image/B15968_09_InlineEquation7.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lower-tailed (mean 1 is less than mean 2): ![14](image/B15968_09_InlineEquation8.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two-tailed (mean 1 differs from mean 2): ![15](image/B15968_09_InlineEquation9.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the 2-sample t-test, the null hypothesis will always be set to 0 (![9](image/B15968_09_InlineEquation10.png)).
    In other words, the null hypothesis is saying that there is no difference between
    the two means, and the other is saying that there is a difference. The test statistic
    for the 2-sample t-test is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![10](image/B15968_09_InlineEquation11.png) with a degree of freedom ![16](image/B15968_09_InlineEquation12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The good news for this is that we do not have to calculate this by hand, nor
    do we have to go through the trouble of creating our own function to do this.
    There is a function in the `scipy.stats` package for this very test. The function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x1` is a list of the data in the first sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x2` is a list of the data in the second sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `equal_var` to `False` since we do not know whether the variance of the
    two samples is the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function returns two values: the signed test statistic and the p-value.
    Some people may have noticed that there is no option to specify which test you
    are performing. That is because this function always assumes that you are conducting
    a two-tailed test. So how can you use this to get the results of your one-tailed
    test? Since the t-distribution is symmetrical, the p-value for a one-tailed test
    would be half of the p-value of a two-tailed test. The second thing to look at
    is the sign of the test statistic. For a lower-tailed test, you would only reject
    the null hypothesis if the test statistic is negative. Likewise, for an upper-tailed
    test, you would only reject the null hypothesis if the test statistic is positive.
    So, for single-tailed tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower**: Reject the null hypothesis if ![a](image/B15968_09_InlineEquation13.png)
    is less than your significance level and your test statistic is negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upper**: Reject the null hypothesis if ![b](image/B15968_09_InlineEquation13a.png)
    is less than your significance level and your test statistic is positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 9.09: A/B Testing Example'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two samples, one drawn from a normal distribution with a mean of 50,
    and another drawn from a distribution with a mean of 100\. Both samples have a
    size of 100\. In this exercise, we are going to determine whether the sample mean
    of one sample is significantly different, lower, or higher than the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the libraries we will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s draw our random samples and print the sample means so we know what they
    are. Remember to set the seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will perform a 2-sample t-test using the function from the `scipy` package
    and print the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since, by default, the function does a two-tailed test, we know that the mean
    of sample 1 is significantly different to the mean of sample 2\. If we wanted
    to do a lower-tailed test (where the mean of sample 1 is significantly less than
    sample 2), we would use the same code. The only difference is that we would divide
    the p-value by 2 and check to see whether our test statistic is negative. Since
    our p-value divided by 2 is less than 0.05 and our test statistic is negative,
    we know that the mean of sample 1 is significantly less than the mean of sample
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to test whether the mean of sample 2 is significantly greater than
    the mean of sample 1, we just switch the position of sample 1 and sample 2 in
    the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Just like with the lower-tailed test, we would divide the p-value by 2\. However,
    we would check to see that the test statistic is positive. Since the p-value divided
    by 2 is less than 0.05 and the test statistic is positive, we know that the mean
    of sample 2 is significantly more than the mean of sample 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/3iuHmOr.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/3ghpdl4.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Linear Regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at describing and testing sample statistics, but what if we
    want to use characteristics of the data to describe one other characteristic?
    For example, how does the price of a mobile app impact the number of downloads?
    To do that, we would model the data using linear regression. **Linear regression**
    is where we use a linear equation of one or more independent variables to describe
    a single dependent variable. Typically, our regression equation is in slope-intercept
    form, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: Formula for linear regression'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.19: Formula for linear regression'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: β1 is the slope of our equation, typically called a coefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: βO is the intercept of the equation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How do we come up with the values for our coefficient and intercept? It starts
    with the **residuals**—which is the difference between the predicted y values
    and the actual y values. Another way to look at residuals is that this is the
    amount that our equation''s prediction is off by. While we will not go into much
    detail here, we use calculus to figure out the values of *β*1, *β*O that minimize
    the total sum of all the residuals. We are not necessarily restricted to one coefficient
    either; we can have multiple (two or more) coefficients, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: Formula for linear regression with multiple coefficients'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: Formula for linear regression with multiple coefficients'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we can use Python to do all the calculations for us, specifically the
    linear model function in the `sklearn` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.10: Linear Regression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are tasked with trying to predict the pH levels of red wine using the wine's
    other characteristics. The dataset can be downloaded from the GitHub repository
    at https://packt.live/3imVXv5.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the wine quality dataset provided by the UCI Machine Learning Repository
    (http://archive.ics.uci.edu/ml). Irvine, CA: University of California, School
    of Information and Computer Science. *P. Cortez, A. Cerdeira, F. Almeida, T. Matos,
    and J. Reiss*. Modeling wine preferences by data mining from physicochemical properties.
    In Decision Support Systems, Elsevier, 47(4):547-553, 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the packages we need and read in the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Subset the data to the two columns we need (we are going to try to use the
    amount of citric acid to predict the `pH` level). Set the `pH` level as our dependent
    variable and citric acid as the independent variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Fit the linear model and graph the data as a scatter plot and our linear regression
    model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21: The linear equation seems to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.21: The linear equation seems to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the picture, you notice that the line fits the data well. Let's
    add another independent variable; in this case, the amount of residual sugar,
    and see whether it improves the prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we set our independent variables as citric acid and residual sugar
    and fit the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a three-dimensional scatter plot and graph the line in the `3d` space
    to check to see whether it fits our data well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22: The linear equation doesn''t seem to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.22: The linear equation doesn''t seem to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the picture, our linear model does not seem to fit the data as
    well as the first model we fitted. Based on this, residual sugar is probably not
    going to be involved in our final model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to https://packt.live/2Anl3ZA.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at https://packt.live/3eOmPlv.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Standardized Test Performance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are given the task of describing the results of the 2015 PISA test and investigating
    possible effects of the prevalence of internet infrastructure on test scores.
  prefs: []
  type: TYPE_NORMAL
- en: To download the dataset, go to the GitHub repository at https://packt.live/3gi2hCg,
    download the `pisa_test_scores.csv` file, and save that file to your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This PISA test scores dataset is based on data provided by the World Bank (https://datacatalog.worldbank.org/dataset/education-statistics).
    World Bank Edstats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have that file saved, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the typical score of a student in reading, science, and mathematics
    using a confidence interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a hypothesis test, evaluate whether the prevalence of internet infrastructure
    can lead to higher test scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a linear model that uses reading and writing scores to predict the
    mathematics score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 688.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the law of large numbers and how the stability
    of the sample mean statistic is affected by sample size. Through the CLT, the
    theoretical underpinnings of confidence intervals and hypothesis testing were
    examined. Confidence intervals were used to describe sample statistics, such as
    sample mean, sample proportion, and margin of error. Hypothesis testing was conducted
    to evaluate two opposing hypotheses using the evidence of a collected sample.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter begins your study of calculus, where you will examine such
    topics as the instantaneous rate of change and finding the slope of a curved line.
    After studying that, we will look at integration, which is finding the area underneath
    a curve. Finally, we will use derivatives to find optimal values of complicated
    equations and graphs.
  prefs: []
  type: TYPE_NORMAL
- en: NKJ24
  prefs: []
  type: TYPE_NORMAL
- en: VBM37
  prefs: []
  type: TYPE_NORMAL
