- en: Displaying Media in VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR中显示媒体
- en: In the previous chapters, we focused on creating real-time 3D media for VR,
    and spent a lot of time looking at player characters, interface elements, and
    building the world. Now, we're going to shift gears a bit and explore another
    important application for VR—displaying movies both on flat screens and in immersive
    environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们专注于为VR创建实时3D媒体，并花了很多时间研究玩家角色、界面元素和构建世界。现在，我们要稍微转变一下，探索VR的另一个重要应用——在平面屏幕和沉浸式环境中显示电影。
- en: VR is very good at this. Because it's possible to create a nearly infinite space
    within the headset, users can experience movies and media on enormous virtual
    screens with no distractions to take them out of the experience. These screens
    can take any shape as well. In addition to flat and curved screens, photos and
    movies of entire environments can be presented in a sphere surrounding the player
    so that they feel totally immersed in the space. In this chapter, we're going
    to learn how to create these things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: VR在这方面非常出色。因为在头戴式显示器中可以创建一个几乎无限的空间，用户可以在巨大的虚拟屏幕上体验电影和媒体，没有任何干扰会让他们脱离体验。这些屏幕也可以采用任何形状。除了平面和弯曲屏幕外，还可以在球体中呈现整个环境的照片和电影，使玩家完全沉浸在其中。在本章中，我们将学习如何创建这些内容。
- en: 'In particular, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，我们将涵盖以下主题：
- en: Displaying video on a virtual screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟屏幕上显示视频
- en: Displaying video with stereo depth from side-to-side and over/under video sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从侧面到侧面和上下视频源显示具有立体深度的视频
- en: Displaying media in 360-degree spherical environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在360度球形环境中显示媒体
- en: Displaying 360-degree media in stereo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在立体声中显示360度媒体
- en: Creating interactive controls to allow the player to start, stop, and rewind
    their media
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建交互控件，允许玩家启动、停止和倒回媒体
- en: Let's get to it and learn how to play movies!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何播放电影吧！
- en: Setting up the project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'For this chapter''s project, we don''t need anything from our previous work,
    so we''re going to begin simply by creating a new project with the following settings:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的项目，我们不需要从之前的工作中获取任何内容，所以我们将简单地创建一个具有以下设置的新项目：
- en: Blank Blueprint template
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白蓝图模板
- en: Mobile / Tablet hardware target
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动/平板硬件目标
- en: Scalable 3D or 2D graphics target
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的3D或2D图形目标
- en: With Starter Content (we'll use some of the starter content in this one)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用起始内容（我们将在其中使用一些起始内容）
- en: 'We still need to set our settings appropriately for VR, as we do with each
    project. Here''s the cheat sheet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要适当地设置VR的设置，就像我们对每个项目都这样做一样。这是一个备忘单：
- en: Project | Description | Settings | Start in VR: True
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 | 描述 | 设置 | 在VR中启动：是
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 正向渲染器 | 正向着色：是
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 环境遮蔽静态分数：否
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 实例化立体声：是
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 轮询遮蔽查询：是
- en: Allow the project to restart once all of these settings have been set. Once
    your project has reopened, you'll be ready to begin learning about how media works
    in Unreal Engine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有这些设置后，允许项目重新启动。一旦你的项目重新打开，你就可以开始学习虚幻引擎中媒体的工作原理了。
- en: Playing movies in Unreal Engine
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在虚幻引擎中播放电影
- en: We're going to begin by learning how we can play movies and other media in Unreal
    Engine in general. Of course, to get started, we're going to need a movie to play.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何在虚幻引擎中播放电影和其他媒体开始。当然，要开始，我们需要一个要播放的电影。
- en: Video files come in a confusing array of configurations, and there are a few
    things you should know about them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 视频文件以令人困惑的方式呈现，你应该了解其中的一些事情。
- en: Understanding containers and codecs
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器和编解码器
- en: The first point of confusion most people run into when they start learning about
    video files is not understanding that the container that a video file is wrapped
    in doesn't necessarily tell you much about how it was encoded. Let's take a moment
    to talk about this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们开始学习视频文件时，最常遇到的困惑是不理解视频文件所包含的容器并不能告诉你它是如何编码的。让我们花点时间来谈谈这个问题。
- en: Video files consist of a lot of information, all packed into one file. There's
    the stream of images representing the video track. Often, there's audio, sometimes
    there are subtitles, and sometimes there's other additional information as well.
    All of this information gets bundled together inside a wrapping format called
    a **container**. You've no doubt seen video files with the `.mp4` extension. That's
    the extension used by the MPEG-4 container format. AVI is Microsoft's standard
    container format, and there are many others.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 视频文件包含大量信息，全部打包到一个文件中。有代表视频轨道的图像流。通常还有音频，有时还有字幕，有时还有其他附加信息。所有这些信息都被捆绑在一个称为“容器”的封装格式中。你肯定见过扩展名为“.mp4”的视频文件。那是MPEG-4容器格式使用的扩展名。AVI是微软的标准容器格式，还有许多其他格式。
- en: 'Here''s the thing to remember, though: the container format specifies how these
    different parts of information are held together in the file, but it doesn''t
    tell us how the video and audio streams were actually made. Just because you see
    the `.mp4` extension on a file doesn''t necessarily mean it''s going to work for
    what you''re trying to use it for. There''s another factor you need to take into
    consideration: the **codec**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但要记住的是，容器格式规定了文件中这些不同信息部分如何组合在一起，但它并不告诉我们视频和音频流实际是如何制作的。仅仅因为你在文件上看到了“.mp4”扩展名，并不意味着它一定适用于你想要使用它的用途。还有另一个因素需要考虑：编解码器。
- en: The word **codec** is a shortened combination of the words **compressor** and
    **decompressor**. Video files in their raw state can become huge. How big? Let's
    run some numbers. Say we have a 1080p video file. Its dimensions are 1920 x 1080
    pixels. That's 2,073,600 pixels per frame. Let's say that we're displaying this
    video file in 24-bit color (8 bits per channel), which allows us to display a
    little over 16 million colors, which comes out to about 50 MB per frame. If we're
    running at 30 frames per second, that's going to eat up around 1.49 gigabytes
    per second. You're going to run out of space in a big hurry doing that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单词**编解码器**是**压缩器**和**解压缩器**两个词的缩写组合。原始状态的视频文件可能会变得非常庞大。有多大呢？让我们来算一下。假设我们有一个1080p的视频文件。它的尺寸是1920
    x 1080像素。每帧有2073600个像素。假设我们以24位色（每通道8位）显示这个视频文件，这允许我们显示超过1600万种颜色，大约每帧50MB。如果我们以每秒30帧的速度运行，那么每秒将消耗约1.49GB的空间。这样做你会很快就用完空间。
- en: We deal with this by compressing video files heavily when we store them, and
    then decompressing them in real time when it's time to stream them to the screen.
    This work is handled by the codec. Its compressor component is responsible for
    taking the raw source video and packing it into a format that can fit on disc,
    and its decompressor component handles unpacking it so that it can be displayed.
    Discussions of how video codecs work fill entire books of their own, so we're
    not going to get into the weeds on this, but the part that you do need to know
    is that while many codecs exist, not all of them work with all software solutions,
    and not all of them work on all hardware configurations. The most commonly used
    codec, and the most broadly compatible, is called **H.264**, but many codecs exist.
    Some are designed to be broadly used and some are very specifically made for certain
    applications, such as video editing. It's worthwhile spending a bit of time learning
    about these.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们存储视频文件时，我们通过对其进行大量压缩，然后在实时流传输到屏幕时进行解压缩来处理这个问题。这项工作由编解码器来处理。它的压缩组件负责将原始源视频打包成适合存储在光盘上的格式，而解压缩组件则负责解包以便显示。关于视频编解码器的工作原理的讨论可以填满整整一本书，所以我们不会深入探讨这个问题，但你需要知道的是，虽然存在许多编解码器，但并不是所有的编解码器都适用于所有的软件解决方案，也不是所有的编解码器都适用于所有的硬件配置。最常用的编解码器，也是最广泛兼容的，被称为**H.264**，但还有许多其他编解码器。有些编解码器被设计为广泛使用，而有些则是专门为某些应用程序（如视频编辑）而制作的。值得花一点时间了解这些编解码器。
- en: So, now you know a secret about video files. The container doesn't necessarily
    tell you about the codec, and you need to know about both to know whether the
    file will work. (So the next time you ask someone what kind of video file they've
    given you, and they answer that they've given you an `.mp4`, you'll know they
    haven't really answered your question.) Some container formats only work on specific
    operating systems or hardware, while others, such as `.mp4`, will work nearly
    anywhere.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你知道了关于视频文件的一个秘密。容器并不一定告诉你编解码器的信息，你需要了解两者才能知道文件是否能正常工作。（所以下次当你问别人给你什么类型的视频文件时，他们回答给了你一个“.mp4”时，你会知道他们并没有真正回答你的问题。）一些容器格式只能在特定的操作系统或硬件上工作，而其他一些格式，比如“.mp4”，几乎可以在任何地方工作。
- en: For video files you intend to use with Unreal Engine, you should generally choose
    to wrap them in the `.mp4` container and compress them using the **H.264** codec. For
    more information on supported codecs, check out the following link: [https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference](https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你打算在虚幻引擎中使用的视频文件，通常应选择将它们封装在“.mp4”容器中，并使用**H.264**编解码器进行压缩。有关支持的编解码器的更多信息，请查看以下链接：[https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference](https://docs.unrealengine.com/en-US/Engine/MediaFramework/TechReference)。
- en: We're not going to cover the topic of compressing your own video files here
    in this book – there's quite a lot to say about that, and quite a lot of information
    available online about how to do it. If you have access to the Adobe Creative
    Suite, the included Adobe Media Encoder application is an excellent tool for converting
    video into nearly any format you need. If you need a free video encoder, AVC Free
    is excellent and commonly used. You can find it at the following link: [https://www.any-video-converter.com/products/for_video_free/](https://www.any-video-converter.com/products/for_video_free/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中涵盖有关压缩自己的视频文件的内容 - 关于这方面有很多要说的，也有很多关于如何做的信息可以在网上找到。如果你可以访问Adobe Creative
    Suite，其中包含的Adobe Media Encoder应用程序是一个将视频转换为几乎任何所需格式的优秀工具。如果你需要一个免费的视频编码器，AVC Free是一个很好且常用的选择。你可以在以下链接找到它：[https://www.any-video-converter.com/products/for_video_free/](https://www.any-video-converter.com/products/for_video_free/)。
- en: Finding a video file to test with
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找用于测试的视频文件
- en: Let's find a file that meets these standards. If we navigate to the "Video For
    Everybody" Test Page, we can find a suitable video for testing. Go to [http://camendesign.com/code/video_for_everybody/test.html](http://camendesign.com/code/video_for_everybody/test.html) and
    find the Download Video link for the `.mp4` container format. Right-click the
    link and select Save Link As... to save the `big_buck_bunny.mp4` video file to
    your hard drive.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一个符合这些标准的文件。如果我们导航到“Video For Everybody”测试页面，我们可以找到一个适合测试的视频。转到[http://camendesign.com/code/video_for_everybody/test.html](http://camendesign.com/code/video_for_everybody/test.html)，找到“.mp4”容器格式的下载视频链接。右键点击链接，选择“另存为...”将“big_buck_bunny.mp4”视频文件保存到硬盘上。
- en: 'If you don''t already have the VLC Media Player installed on your system, download
    and install it from: [https://www.videolan.org/vlc/index.html](https://www.videolan.org/vlc/index.html).
    In practice, you could use any video player to check your files, but VLC is a
    good tool to know about. It''ll play nearly anything and gives you good information
    about the file you''re playing. Refer to the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统上还没有安装VLC媒体播放器，请从以下链接下载并安装：[https://www.videolan.org/vlc/index.html](https://www.videolan.org/vlc/index.html)。实际上，你可以使用任何视频播放器来检查你的文件，但VLC是一个很好的工具。它几乎可以播放任何格式的视频，并提供有关正在播放的文件的良好信息。请参考以下步骤：
- en: Open the video file you just downloaded in VLC and play it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VLC中打开刚刚下载的视频文件并播放。
- en: 'Pause the video somewhere and hit *Ctrl* + *J* to open its Codec information:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停视频并按*Ctrl* + *J*打开其编解码器信息：
- en: '![](img/4295505a-7d98-4ee1-9997-0a90fc9ede18.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/4295505a-7d98-4ee1-9997-0a90fc9ede18.png)
- en: You can see here that this file has been encoded using H.264, and we can see
    from its file extension that it's using an `.mp4` container. This file should
    work correctly for us on any platform in Unreal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处看到，该文件使用H.264进行编码，并且从其文件扩展名可以看出它使用了“.mp4”容器。这个文件应该在虚幻的任何平台上都能正常工作。
- en: Adding a video file to an Unreal project
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视频文件添加到虚幻项目
- en: Let's add this file to our Unreal project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此文件添加到我们的虚幻项目中。
- en: For other asset types, you use the `Import` method from within Unreal Editor
    to add them to your project, but video files are different. To add a video file
    to an Unreal project, you must manually place it in a subdirectory of the `Content`
    folder named `Movies`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他资产类型，您可以使用虚幻编辑器中的“导入”方法将它们添加到项目中，但视频文件不同。要将视频文件添加到虚幻项目中，您必须手动将其放置在名为“Movies”的“Content”文件夹的子目录中。
- en: The name and location are important. The engine will look for movies in `Content/Movies` by
    default, and your movies may not package correctly if you put them in another
    location.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和位置很重要。引擎默认会在“Content/Movies”中查找电影，如果将它们放在其他位置，可能无法正确打包。
- en: From your Content Browser, make sure you're at the root `Content` folder and
    right-click to create a new folder.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中，确保您在根“Content”文件夹中，右键单击创建一个新文件夹。
- en: 'Name it `Movies`, as shown in the following screenshot:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，将其命名为“Movies”：
- en: '![](img/80a8ac75-1f4e-4798-be6a-3424678c30a0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/80a8ac75-1f4e-4798-be6a-3424678c30a0.png)
- en: From your Windows Explorer, find the `.mp4` file you downloaded, and move it
    to your project's `Content\Movies` directory. (You can right-click this directory
    in your Content Browser and select Show in Explorer to navigate to the directory.)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Windows资源管理器中找到您下载的“.mp4”文件，并将其移动到项目的“Content/Movies”目录中。（您可以右键单击内容浏览器中的此目录，然后选择“在资源管理器中显示”以导航到该目录。）
- en: Creating a File Media Source asset
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件媒体源资产
- en: 'Now, return to the Unreal Editor, and in your `Content/Movies` directory, right-click
    and select Create Advanced Asset | Media | File Media Source to create a new file
    media source asset. It''s often easier to name file media sources using the same
    names as their source assets, so it makes sense to name it `big_buck_bunny` since
    that''s the name of the file we''re about to attach:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回虚幻编辑器，在您的“Content/Movies”目录中，右键单击并选择创建高级资产 | 媒体 | 文件媒体源以创建一个新的文件媒体源资产。通常更容易使用与其源资产相同的名称命名文件媒体源，因此将其命名为“big_buck_bunny”是有意义的，因为这是我们即将附加的文件的名称：
- en: '![](img/119994b5-0f77-47f5-baef-e148450a59b4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/119994b5-0f77-47f5-baef-e148450a59b4.png)
- en: 'Open it up and use the ellipsis (...) button to select the video file you placed
    in your `Content/Movies` directory as its File Path:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它并使用省略号(...)按钮选择您放置在“Content/Movies”目录中的视频文件作为其文件路径：
- en: '![](img/2056807e-b88a-4ed4-b074-e0f85028d826.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/2056807e-b88a-4ed4-b074-e0f85028d826.png)
- en: A File Media Source asset is simply a resolver that allows a media player to
    find a movie on disk. Media players point to file media sources, and those file
    media sources point to the actual file in the `Movies` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件媒体源资产只是一个解析器，允许媒体播放器在磁盘上找到电影。媒体播放器指向文件媒体源，而文件媒体源指向“Movies”目录中的实际文件。
- en: 'File media sources also provide a few additional options:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文件媒体源还提供了一些其他选项：
- en: The advanced Precache File option can be used to force the entire media file
    into memory and play from there.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级“预缓存文件”选项可用于将整个媒体文件强制加载到内存中并从那里播放。
- en: The Player Overrides list allows you to force a specific player to decode the
    media on a specific platform. Leave these alone unless you're sure you need to
    override the automatic choice.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Player Overrides”列表允许您强制特定播放器在特定平台上解码媒体。除非您确定需要覆盖自动选择，否则请将其保持不变。
- en: 'Three other media source types exist, and while we''re not going to dive into
    them in depth here, you should know about them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他三种媒体源类型，虽然我们不会在这里深入研究它们，但您应该了解它们：
- en: '**Img** Media Sources are used to display image sequences – individual images
    intended to be streamed in series as a movie. For detailed information on playing
    image sequences, check out the following link: [https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/ImgMediaSource/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/ImgMediaSource/index.html).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Img**媒体源用于显示图像序列-作为电影连续播放的单个图像。有关播放图像序列的详细信息，请查看以下链接：[https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/ImgMediaSource/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/ImgMediaSource/index.html)。'
- en: '**Stream** Media Sources allow you to specify a video file hosted at a specific
    URL for playback. For more information, check out the following link: [https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/StreamMediaSource/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/StreamMediaSource/index.html).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流**媒体源允许您指定托管在特定URL上的视频文件进行播放。有关更多信息，请查看以下链接：[https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/StreamMediaSource/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/StreamMediaSource/index.html)。'
- en: '**Platform** Media Sources allow you to specify different media to play on
    different hardware platforms. Check out the following link for details: [https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/PlatformMedia/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/PlatformMedia/index.html).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**媒体源允许您指定在不同的硬件平台上播放不同的媒体。请查看以下链接以获取详细信息：[https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/PlatformMedia/index.html](https://api.unrealengine.com/INT/Engine/MediaFramework/HowTo/PlatformMedia/index.html)。'
- en: Creating a Media Player
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建媒体播放器
- en: 'Now that we have a media source set up, let''s create a Media Player to play
    it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好媒体源，让我们创建一个媒体播放器来播放它：
- en: 'Right-click in your `Content/Movies` directory and select Create Advanced Asset
    | Media | Media Player. We''ll be using the same media player for all of our media
    sources, so a general name such as `MediaPlayer` is fine. Refer to the following
    screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Content/Movies”目录中右键单击，选择“创建高级资产 | 媒体 | 媒体播放器”。我们将为所有媒体源使用相同的媒体播放器，因此通用名称如“MediaPlayer”就可以了。参考以下截图：
- en: '![](img/7b558498-cc11-4ec0-98db-63b96dcdd1f8.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b558498-cc11-4ec0-98db-63b96dcdd1f8.png)'
- en: 'When you create it, a new dialog will appear, asking whether you whether you''d
    like to create a Media Texture asset to handle the video output. Let''s allow
    it to do so, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时，会出现一个新的对话框，询问您是否要创建一个媒体纹理资产来处理视频输出。让它这样做，如下图所示：
- en: '![](img/c7e0e588-13b0-4e27-af01-1d491afdb502.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7e0e588-13b0-4e27-af01-1d491afdb502.png)'
- en: We could just as well have created it by creating a Media/Media Texture asset
    from our content browser, but this saved us a step.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过从内容浏览器创建一个媒体/媒体纹理资产来创建它，但这样可以节省一步。
- en: Using Media Textures
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用媒体纹理
- en: 'Media Texture assets display the streamed video or images from their bound
    Media Player asset. If you open the one we just created, you''ll see that it''s
    bound to the Media Player we just created:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体纹理资产显示其绑定的媒体播放器资产中的流媒体视频或图像。如果您打开刚刚创建的媒体纹理，您会看到它绑定到我们刚刚创建的媒体播放器：
- en: '![](img/9e3838eb-6072-46c9-b3cc-deaa1ba7d252.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e3838eb-6072-46c9-b3cc-deaa1ba7d252.png)'
- en: Don't worry if your media texture looks blank. It won't display anything until
    you've played something on its associated Media Player.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的媒体纹理看起来是空白的，不要担心。在关联的媒体播放器上播放了一些内容之前，它不会显示任何内容。
- en: In general, you're going to want to leave your properties of Media Texture alone.
    Make sure it's bound to your Media Player, but you're unlikely to need to change
    any of its other properties.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该保持媒体纹理的属性不变。确保它绑定到您的媒体播放器，但您不太可能需要更改其其他属性。
- en: Testing your Media Player
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的媒体播放器
- en: 'Open up the new Media Player asset you just created. You should see the file
    media source we set up a moment ago in its list of available media sources. Select
    it and play it to verify that it''s playable in Unreal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 打开刚刚创建的新媒体播放器资产。您应该在可用媒体源列表中看到我们刚刚设置的媒体源文件。选择它并播放以验证它在虚幻引擎中可以播放：
- en: '![](img/15bf0d29-ee25-4c02-8c13-5b1b7c6333d1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15bf0d29-ee25-4c02-8c13-5b1b7c6333d1.png)'
- en: Ensure that Play on Open is selected for this file source, and turn on the Loop option
    as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为此文件源选择了“打开时播放”选项，并同时打开“循环”选项。
- en: Once we've verified that the video file plays in our media player, let's add
    it to an object in the world.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了视频文件在媒体播放器中播放，让我们将其添加到世界中的一个对象中。
- en: Adding video to an object in the world
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视频添加到世界中的对象
- en: Since we included Starter Content in this project, instead of launching with
    a blank map, our project launches with a simple map named Minimal Default by default,
    which contains a pair of chairs and a table. We can use this as a starting point
    for our movie playback map. Save the map by selecting File | Save Current As... and
    save it as `Content/Chapter08/Maps/MoviePlayback2D`. (Remember, it's a good idea
    to put your work into a subdirectory of your `Content` directory for your project.
    Otherwise, you're going to have a mess when you migrate something else in.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个项目中包含了起始内容，所以我们的项目启动时不会启动一个空白地图，而是默认启动一个名为“Minimal Default”的简单地图，其中包含一对椅子和一张桌子。我们可以将其作为我们电影播放地图的起点。选择“文件
    | 另存为当前...”保存地图，保存为`Content/Chapter08/Maps/MoviePlayback2D`。（记住，将您的工作放入项目的`Content`目录的子目录中是个好主意。否则，当您迁移其他内容时，会变得一团糟。）
- en: If you'd like, feel free to use the starter content to arrange a more comfortable
    theater or viewing room set. We're not going to cover that here, but if you're
    up for it, create a living room or movie theater set, or anything that sparks
    your imagination.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用起始内容来布置一个更舒适的剧院或观影室。我们不会在这里涵盖这个内容，但如果您愿意，可以创建一个客厅或电影院场景，或者任何激发您想象力的场景。
- en: 'What we do need in our scene is a screen to display our media. Follow these
    steps to create one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景中需要一个屏幕来显示我们的媒体。按照以下步骤创建一个：
- en: From the Modes panel, select Place | Basic | Plane, and drag a plane onto the
    scene.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模式面板中选择“放置 | 基本 | 平面”，并将一个平面拖动到场景中。
- en: Set its Location to `(X=-730.0, Y=0.0, Z=210.0)` (or wherever fits the environment
    you've built).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为`(X=-730.0, Y=0.0, Z=210.0)`（或适合您构建的环境的位置）。
- en: Set its Rotation to `(Pitch=0.0, Yaw=-90, Roll=90)` (in the editor, this reads
    as `X=90.0, Y=0.0, Z=-90.0`).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其旋转设置为`(Pitch=0.0, Yaw=-90, Roll=90)`（在编辑器中，这读作`X=90.0, Y=0.0, Z=-90.0`）。
- en: Set its Scale to `(X=8.0, Y=4.5, Z=1.0)`. By doing this, we've matched the shape
    of the screen to the 16:9 aspect ratio of the video we intend to play.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为`(X=8.0, Y=4.5, Z=1.0)`。通过这样做，我们将屏幕的形状与我们打算播放的16:9宽高比的视频相匹配。
- en: 'Now, we''re going to assign our Media Texture to this plane:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把我们的媒体纹理分配给这个平面：
- en: Drag the Media Texture we created for our Media Player onto the plane.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们为媒体播放器创建的媒体纹理拖动到平面上。
- en: A material will automatically be created to display the texture.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自动创建一个材质来显示纹理。
- en: This is how you get media into a 3D scene. Assign a material or a material instance
    that uses a Media Texture as a source, and make sure that the Media Texture points
    back at a Media Player.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将媒体添加到3D场景中的方法。分配一个使用媒体纹理作为源的材质或材质实例，并确保媒体纹理指向一个媒体播放器。
- en: Using a media playback material
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用媒体播放材质
- en: We should look at this material for a moment. Open it up. If you look at its
    material properties, you can see that it's an ordinary Surface material using
    the Default Lit shading model. There's nothing special here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微看一下这个材质。打开它。如果您查看其材质属性，您会发现它是一个使用默认光照模型的普通表面材质。这里没有什么特别的。
- en: 'The Texture Sample, on the other hand, is interesting:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，纹理样本很有趣：
- en: '![](img/73ddbe24-a1f9-4d42-ba09-ecdc288c3044.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73ddbe24-a1f9-4d42-ba09-ecdc288c3044.png)'
- en: The important details here are that its Texture source has been set to our media
    texture, and its Sampler Type has been set to `External`. This is what will allow
    it to display our media in real time. We're going to do more work with this material
    shortly, but for now you can close it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound to our media playback
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also want to be able to play sound in our scene. Follow these steps to do
    so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: With our screen actor still selected, click the Add Component button in its
    details panel.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a Media Sound component and set its Media Player property to our media
    player:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c12ba22d-91c5-4783-a63f-0ab77c7b26e8.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: This Media Sound component will play whatever audio the associated media player
    is streaming. By default, it handles stereo audio, but it can be used for mono
    or surround audio sources as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set everything up and placed an object in the world with video
    material and a sound component, let's get our media player playing our test video.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Playing media
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to start simply here, and just make the movie play when the level
    starts. Later on, we''re going to do more to control our media player. Follow
    these steps to get started:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Open Level Blueprint, as shown in the following screenshot:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8e4fde2-2bbc-47a3-a6ff-3c58027502b9.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Create a new variable and set its type to Media Player | Object Reference:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/468083f7-fc09-4a90-b026-7e225176b7cf.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Compile the blueprint and change the variable's default value from `None` to
    the media player we created a moment ago.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag the media player variable onto your event graph.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find or create the Event BeginPlay node.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from your Media Player variable and call Open Source on it.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the call''s Media Source to the file media source we created from our movie:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59ba5fd7-06e4-4ead-ae84-d1051406354f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Launch it in your VR Preview, and let''s see what happens:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a021a75-c653-4784-98c3-6fbf35abfc43.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Nice. The video is playing. We''ll take a moment to review what we did to set
    this up, and then we''re going to look at ways to improve it. Refer to the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d28eb0ce-ff29-45b6-b634-d735808cefdb.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Media playback works as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Any media you want to play in engine begins as a file in `Content/Movies`. The
    source movie isn't imported into the engine and doesn't appear in your content
    browser.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To access it in the engine, you create a File Media Source asset that points
    to the media file on disk.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Media is played through a Media Player object that you can control through Blueprint
    calls.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Media Texture assets sample the video from their associated Media Player. These
    are included in materials.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MediaSound components on objects play audio from their associated Media Player.
    These are usually added to the object acting as a screen in your scene.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going deeper with the playback material
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at a few things we can do with our media playback materials.
    The right choices to make here entirely depend on what effect you're trying to
    create, so we'll talk about a few things you might want to do, but you'll want
    to decide on your own whether they fit what you're going for.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to talk about is how the screen responds to light. The
    material we created for our Media Texture uses the Default Lit shading model.
    What this means is that lights in the environment that fall on this material will
    affect it as they normally would. If the aesthetic effect you're going for is
    that this is a physical screen in the space, this may be exactly what you want,
    but if the purpose of your application is to show the media itself, you may not
    want any stray light falling on the screen and changing the way its colors appear
    to the viewer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we''re talking about. From your Modes panel, drag
    a Point Light onto the scene and put it right in front of your screen:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faa3e5ea-f7e6-4759-9655-054992d80619.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: You'll see that the light creates a specular highlight on the screen, just as
    it would for any other surface in the scene. Things get worse if we turn off the
    rest of the lights in the scene. Now, parts of our screen are going dark, while
    others are obscured by the highlights from our remaining lights.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现光线在屏幕上产生了镜面高光，就像在场景中的其他表面上一样。如果我们关闭场景中的其他灯光，情况会变得更糟。现在，我们屏幕的某些部分变暗了，而其他部分则被剩余灯光的高光遮挡。
- en: 'If this is how we want it, that''s fine, but if it isn''t, we can correct this
    by changing our material to use an unlit shading model and feeding the video signal
    into its emissive channel. Let''s give it a try:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这就是我们想要的，那就没问题，但如果不是，我们可以通过将材质更改为使用无光照模型，并将视频信号输入到其自发光通道中来进行修正。让我们试试看：
- en: Open your media material.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的媒体材质。
- en: 'With the output node selected, change the material''s Details | Material |
    Shading Model from Default Lit to Unlit:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出节点后，将材质的详细信息 | 材质 | 着色模型从默认光照改为无光照：
- en: '![](img/7eed7b1a-02e4-460e-914a-1344c5bfc119.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eed7b1a-02e4-460e-914a-1344c5bfc119.png)'
- en: You'll see that its Base Color input becomes disabled. *Alt* + click that input
    to disconnect your Texture Sample from it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会发现它的基础颜色输入变为禁用状态。*Alt* + 单击该输入以断开与纹理采样的连接。
- en: Feed the results of your texture sample into the material's Emissive Color input
    instead.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理采样的结果输入到材质的自发光颜色输入中。
- en: 'Save the material and return to your scene. Now, because your material uses
    the Unlit model, it''s no longer affected by lights in the world. The media appears
    exactly as it does in its source:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存材质并返回到场景。现在，因为你的材质使用了无光照模型，它不再受世界中的灯光影响。媒体的显示与其源文件完全一致：
- en: '![](img/c9999575-bdfa-40e2-b8e5-5a4a82ac8787.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9999575-bdfa-40e2-b8e5-5a4a82ac8787.png)'
- en: Adding additional controls to our video appearance
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的控制来调整视频外观
- en: 'We can also use our material graph to exercise a lot of additional control
    over how the video signal appears. Let''s take a look at this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用材质图表来对视频信号的显示进行更多的控制。让我们来看看这个：
- en: Return to your material.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的材质。
- en: Hold down the *S* key and click in the workspace to create a scalar parameter.
    Name it `Brightness` and set its default value to `1.0`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*S*键并在工作区中单击以创建一个标量参数。将其命名为`Brightness`并将其默认值设置为`1.0`。
- en: Hold the *M* key and click to create a multiplier node.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*M*键并单击以创建一个乘法节点。
- en: Multiply your output of Texture Sample by the `Brightness` parameter you just
    made.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的纹理采样的输出乘以刚刚创建的`Brightness`参数。
- en: Hold the *S* key and click to create another scalar parameter. Name this one
    `Contrast` and leave its default at `0.0`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*S*键并单击以创建另一个标量参数。将其命名为`Contrast`，并将其默认值设置为`0.0`。
- en: Right-click in the graph and create a `CheapContrast_RGB` node.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击并创建一个`CheapContrast_RGB`节点。
- en: Connect the result of the Multiply node to its In (V3) input, and feed your
    `Contrast` parameter into its Contrast input.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将乘法节点的结果连接到其In (V3)输入，并将你的`Contrast`参数输入到其对比度输入。
- en: 'Feed the result into the material''s Emissive Color input:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果输入到材质的自发光颜色输入中：
- en: '![](img/66cc6e54-8343-4f89-a985-7c79bb8072b4.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66cc6e54-8343-4f89-a985-7c79bb8072b4.png)'
- en: As you can see, we've now created a simple material that uses two scalar parameters
    to allow our user to control the image's brightness and contrast.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在创建了一个简单的材质，使用两个标量参数来允许用户控制图像的亮度和对比度。
- en: 'Let''s create a material instance from this material so that we can see the
    effect of these parameters in real time:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个材质创建一个材质实例，以便我们可以实时看到这些参数的效果：
- en: Right-click your material in the Content Browser and select Material Instance
    Actions | Create Material Instance.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击你的材质，选择材质实例操作 | 创建材质实例。
- en: Drag the material instance onto your screen to assign it to the object.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质实例拖动到屏幕上以将其分配给对象。
- en: Open the material instance and try changing the `Brightness` and `Contrast`
    values you just created. (Remember that you need to check the box beside a parameter
    to enable modification.)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开材质实例并尝试更改刚刚创建的`Brightness`和`Contrast`值。（记住，你需要勾选参数旁边的复选框才能启用修改。）
- en: 'Switch the material''s preview mesh to a cube primitive so that you can see
    what you''re doing more easily:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质的预览网格切换为立方体原语，以便更容易看到你正在做的事情：
- en: '![](img/5c7fa939-7659-4aea-872b-b667bf252f2c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7fa939-7659-4aea-872b-b667bf252f2c.png)'
- en: There's quite a lot we can do here, and we encourage you to explore and learn
    more about what you can do.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多我们可以做的事情，我们鼓励你去探索和学习更多关于你可以做什么的内容。
- en: Now that you know the basics of playing video in Unreal Engine, let's start
    diving into some VR-specific work and learn how to display video in stereo 3D.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在虚幻引擎中播放视频的基础知识，让我们开始深入一些针对虚拟现实的工作，并学习如何以立体3D的方式显示视频。
- en: Displaying stereo video
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示立体视频
- en: Let's begin by creating another map to hold our stereo video screen. With your
    `MoviePlayback2D` scene open, hit File | Save Current As... and save the map as
    `MoviePlayback3D`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建另一个地图来容纳我们的立体视频屏幕。在你的`MoviePlayback2D`场景中，点击文件 | 另存为...，将地图保存为`MoviePlayback3D`。
- en: 'Now, we need to find a stereo video file to test with. They''re out there on
    the web, but they can be challenging to find since we need to download ours. stereomaker.net
    has a few example files here: [http://stereomaker.net/sample/](http://stereomaker.net/sample/).
    Let''s pull down the Cycling in Hibaya Park video from here. We can also find
    more example files here: [http://photocreations.ca/3D/index.html](http://photocreations.ca/3D/index.html).
    Download the Bellagio Fountains, Las Vegas, Nevada 3D 2048 x 2048 clip. This will
    give us a side-by-side stereo clip and an over/under stereo clip that we can use
    for our experiments. The Hibaya clip is wrapped in an `.AVI` container, but as
    long as we''re running the clip on Windows, that will work. To run it on another
    platform, we''d have to use an application such as Adobe Media Encoder or AVC
    to convert it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Place each of these files in your `Content/Movies` directory.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a File Media Source asset for each of your new video files. Again, it's
    often easier to use a name for the file media source that matches the movie clip
    on disk.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open up your media player. You should see these new clips in its available
    file list, and you should be able to play them. You should see two frames side-by-side,
    representing the left and right stereo images (make sure you do this first test
    with a side-by-side stereo video – we''ll handle over/under later on):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e48c311-c995-4fa1-8562-a698e39aa6d8.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: The trick now will be to interpret the side-by side or over/under images as
    stereo images and feed one frame to the left eye while we feed the other to the
    right.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We're going to handle that in our material. Specifically, what we want to do
    is modify the texture coordinates we feed to the texture's UV map.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: A UV map determines the way a texture aligns itself on a mesh in a 3D space.
    By manipulating the texture coordinates we're using to apply textures in our material,
    we can choose to display only parts of the texture at a time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Open up your media player material.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Since we want this material to be able to handle mono video sources as well,
    we're going to use a Static Switch Parameter to switch between mono and stereo
    modes. This will allow us to use this material as a master material but set up
    individual material instances that handle whatever specific settings we want.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Static Switch Parameters are valuable tools that you can use to build a lot
    of behavior into a master material, and derive material instances from it that
    handle specific cases. As an added benefit, when those materials are compiled,
    anything that's turned off by your static switches simply doesn't even compile
    into the material instance, so you get it essentially for free. What this means
    is that you can make fairly complex master materials and only pay for the parts
    you use by using static switches to turn off functionality that you're not using.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a switch to our material so that we can create a stereo path without
    messing up our mono display:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the material editing graph and create a Static Switch Parameter.
    Name it `SplitStereoMedia`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a Texture Coordinate node, and feed its output into the
    switch parameter's False input. This will display in the graph as a TexCoord node.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it's time to split the image. When images are rendered to the VR headset,
    they're rendered in two separate passes, and we can use this information to determine
    which side of the image to display.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Displaying half of the video
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To split the image, we first need to get access to the two separate axes of
    our texture coordinates so that we can manipulate them individually:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Drag the output from the Texture Coordinate input and create a BreakOutFloat2Components
    node from it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold down the *M* key and click to create a Multiply node.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Break node's R output to the Multiply node's A input and set its
    Const B parameter to 0.5.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Append Vector node and connect the multiplier's output to the A input,
    and the G output from the Break node to its B input.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the result of the Append node into the Split Stereo Media switch's True
    input.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the result of the Switch node into the UVs input of Texture Sample:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/684588f3-1f2d-45fc-a84b-90d86478bb8c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: What we've just done here is split our texture coordinates into two channels,
    labeled R and G. We then cut the R channel in half while leaving the G channel
    alone, and then reassembled the vector and told our texture sample to use the
    result to map the image to the object it's applied to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this to see what it does:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Open your scene's Level Blueprint. It should still contain the Open Source call
    to the Media Player.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch its Media Source to your side-by-side video. Since we need a place to
    set our Static Switch parameter, we need a new material instance to display our
    side-by-side image.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the material instance we made a moment ago when we adjusted our contrast
    and brightness.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this one `MI_MediaPlayer_SBS` or something similar to remind us that it's
    intended to display side-by-side stereo media.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it up and set its SplitStereoMedia switch parameter to true.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign it to your screen object.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test it out. You should now see only the video's left frame displayed on the
    screen. You won't see any stereo depth yet since we're still displaying the same
    image to each eye.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a different half of the video to each eye
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s get the right frame to display in the right eye:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Return to your material.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the material graph and create a Custom node.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Code property, enter the following: `return ResolvedView.StereoPassIndex;`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Output Type to CMOT Float 1.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Description to StereoPassIndex.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates a Material Expression Custom node that will return a `0` when we're
    rendering the left eye, and a `1` when we're rendering the right eye. We can use
    this information to choose which half of the frame we display for each eye.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Hold down the *M* key and click to create a Multiply node.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the output from StereoPassIndex into its A input, and set its Const B
    parameter to 0.5:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2596c43f-929c-4ed5-ae88-8240fa87646d.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Now, hold down the *A* key and click to create an Add node.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the result of the multiplied R channel from the texture coordinates into
    its A input.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the result of the multiplied stereo pass index into its B input.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feed the result of the Add node into the Append node''s A input:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fce2da5c-8bf6-4b1e-9a47-d968fa3a534b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Test it again. You should now see stereo depth in the video image when you view
    it in your VR headset.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment to make sense of what we just created here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: When we break our texture coordinates and modify the R value, we're modifying
    the horizontal axis of the texture mapping. By multiplying it by 0.5, we're splashing
    half of the texture over the entire surface of the mesh. The Stereo Pass Index
    node we made returns a value of 0 for the left stereo pass, and 1 for the right
    stereo pass, so when we multiply this value by 0.5, we get either a 0 for the
    left eye or an 0.5 for the right eye. When we then add this value to our texture
    coordinate's R component, we're offsetting it by half its width. So, when the
    left eye is rendered, it simply divides the texture space in half, and when the
    right eye is rendered, it divides it in half and offsets it by half, displaying
    the right frame. This is how we're getting our stereo image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Displaying over/under stereo video
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modifying our material to handle over/under stereo video is fairly easy. We
    just need to do our operation on the G channel instead of the R channel. Follow
    these steps to get started:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Reopen your media player material.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Static Switch Parameter node. Name it `OverUnderStereo`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag the SplitStereoMedia switch''s True input to move it into the
    OverUnderStereo switch''s False input.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the output from the OverUnderStereo switch to the SplitStereoMedia
    switch''s True input:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将OverUnderStereo开关的输出连接到SplitStereoMedia开关的True输入：
- en: '![](img/ae258fcc-2219-420b-86fd-ee22c072de84.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae258fcc-2219-420b-86fd-ee22c072de84.png)'
- en: If OverUnderStereo is set to False, our material continues to use the side-by-side
    split we set up a moment ago. Now, let's set up its behavior when this is set
    to True.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果OverUnderStereo设置为False，我们的材质将继续使用我们刚刚设置的并排分割。现在，让我们设置它在设置为True时的行为。
- en: Select the chain of nodes that includes the BreakOutFloat2Components node, all
    the way to the Append node, and hit *Ctrl + W* to duplicate them.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包括BreakOutFloat2Components节点在内的节点链，一直到Append节点，并按下Ctrl + W进行复制。
- en: Connect the R output from the BreakOut node directly to the Append node's A
    input.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BreakOut节点的R输出直接连接到Append节点的A输入中。
- en: Connect the G output from the BreakOut node to the Multiply node's A input.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BreakOut节点的G输出连接到Multiply节点的A输入。
- en: Connect the output from the Add node to the Append node's B input.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Add节点的输出连接到Append节点的B输入。
- en: We've just swapped things, so we're now performing the same operation on the
    vertical axis as we'd previously performed on the horizontal axis.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚交换了一些东西，所以我们现在在垂直轴上执行与之前在水平轴上执行的相同操作。
- en: Feed the output of the Multiply node from your Stereo Pass Index into the new
    Add node's B input.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立体通道索引的Multiply节点的输出输入到新的Add节点的B输入中。
- en: Feed the Texture Coordinates into your BreakOut node's input.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理坐标输入到BreakOut节点的输入中。
- en: 'Feed the output of the Append node into your OverUnderStereo switch''s True
    input:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Append节点的输出输入到OverUnderStereo开关的True输入中：
- en: '![](img/fbdb464b-83a9-424e-b7a5-83b53a64338f.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbdb464b-83a9-424e-b7a5-83b53a64338f.png)'
- en: This material can now handle mono, side-by-side stereo, and over/under stereo
    sources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个材质可以处理单眼、并排立体和上下立体的源。
- en: 'Now, let''s test this out:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来测试一下：
- en: Close your material and in your Content Browser, duplicate one of the material
    instances you've already made from it.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭您的材质，并在内容浏览器中复制其中一个已经创建的材质实例。
- en: Ensure that its SplitStereoMedia parameter is set to True, and set its OverUnderStereo
    parameter to True.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保其SplitStereoMedia参数设置为True，并将其OverUnderStereo参数设置为True。
- en: Assign it to your screen object in your scene.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其分配给场景中的屏幕对象。
- en: Open your scene's Level Blueprint and switch the Media Source on your Open Source
    node to your over/under stereo video.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开场景的Level Blueprint，并将Open Source节点上的Media Source切换为您的上下立体视频。
- en: Launch it into VR preview mode. We should now see our over/under stereo video
    playing correctly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 进入VR预览模式。现在我们应该能够正确播放我们的上下立体视频。
- en: Displaying 360 degree spherical media in VR
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR中显示360度球形媒体
- en: So far, we've done a decent job of reproducing 2D and 3D traditional screens
    in VR, but let's take things a step further and do something we can't easily do
    in the outside world. One of the most compelling and common uses of VR is to display immersive
    360 degree video that surrounds the viewer. Even in mono, this can create a fairly
    deep sense of presence in users, and can be produced fairly easily using an ordinary
    camera and stitching software, or a dedicated camera that's been purpose-built
    to create spherical images.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在VR中已经相当好地复制了2D和3D传统屏幕，但让我们进一步迈出一步，做一些在现实世界中不容易做到的事情。VR最引人注目和常见的用途之一是显示环绕观众的沉浸式360度视频。即使是单眼，这也可以在用户中产生相当深的存在感，并且可以使用普通相机和拼接软件或专用相机相对容易地制作出球形图像。
- en: Displaying spherical media, for the most part, works exactly as it does on the
    flat screen, but of course we'll need new geometry for our screen.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 显示球形媒体，在大多数情况下，与在平面屏幕上的显示方式完全相同，但当然我们需要新的几何形状来显示屏幕。
- en: Finding 360 degree video
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找360度视频
- en: First, let's find a video to play. A few good options live here: [https://www.mettle.com/360vr-master-series-free-360-downloads-page/](https://www.mettle.com/360vr-master-series-free-360-downloads-page/).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找一个要播放的视频。这里有几个不错的选择：[https://www.mettle.com/360vr-master-series-free-360-downloads-page/](https://www.mettle.com/360vr-master-series-free-360-downloads-page/)。
- en: 'The Crystal Shower Falls link takes us to a Vimeo page that allows us to download
    the video. For our test here, the 1080p version should be fine:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Crystal Shower Falls链接带我们到一个Vimeo页面，允许我们下载视频。对于我们的测试，1080p版本应该没问题：
- en: Download the video and place it in your `Content/Movies` directory.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载视频并将其放置在`Content/Movies`目录中。
- en: Create a File Media Source for your video.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的视频创建一个文件媒体源。
- en: Check it in your Media Player to be sure it plays.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在媒体播放器中检查它以确保它可以播放。
- en: Now, we need an environment to display it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个环境来显示它。
- en: Create a new empty level and name it `MoviePlayback2DSpherical` (or anything
    you like, really – it's your map).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空级别并将其命名为`MoviePlayback2DSpherical`（或者任何您喜欢的名称 - 这是您的地图）。
- en: Creating a spherical movie screen
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个球形电影屏幕
- en: 'Now, we''re going to take an ordinary sphere and modify it to flip its normals
    inward so that we can see our material while we''re inside the sphere:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将采取一个普通的球体并修改它，使其法线向内翻转，这样我们就可以在球体内部看到我们的材质：
- en: From your Modes panel, grab a Basic | Sphere actor and place it in your scene.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Modes面板中，选择Basic | Sphere角色并将其放置在场景中。
- en: Look at its Details panel, and under Static Mesh, hit the Browse to Asset button
    (the magnifier) to navigate the Content Browser to the sphere's static mesh. We're
    going to make a copy of it.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看其详细信息面板，在Static Mesh下，点击浏览资源按钮（放大镜）以导航到内容浏览器中的球体静态网格。我们要创建一个副本。
- en: Drag the Sphere static mesh from `Engine Content/BasicShapes` into your project's
    `Content` directory (`Content/Chapter08/Environments` would be a good choice).
    Select Copy Here to make a copy of the sphere.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Sphere静态网格从`Engine Content/BasicShapes`拖动到项目的`Content`目录中（`Content/Chapter08/Environments`是一个不错的选择）。选择“复制到此处”以创建球体的副本。
- en: Rename it `MovieSphere`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`MovieSphere`。
- en: Open it up.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: From your Static Mesh editor, select the Mesh Editing tab.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的静态网格编辑器中，选择Mesh Editing选项卡。
- en: Activate Edit Mode by hitting the toolbar button.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击工具栏按钮激活编辑模式。
- en: Drag to select all of the mesh's faces.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动以选择所有网格面。
- en: 'Hit the Flip button to invert their normals:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击翻转按钮以翻转它们的法线：
- en: '![](img/d056a7ea-49e4-488a-acb6-db04d862e487.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d056a7ea-49e4-488a-acb6-db04d862e487.png)'
- en: Save it and close the Static Mesh editor.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭静态网格编辑器。
- en: Place an instance of your MovieSphere mesh in your level and delete the old
    Sphere.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的关卡中放置一个MovieSphere网格的实例，并删除旧的球体。
- en: Set its Location to (X=0.0, Y=0.0, Z=0.0) and its Scale to (X=200.0, Y=200.0,
    Z=200.0).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（X=0.0，Y=0.0，Z=0.0），并将其比例设置为（X=200.0，Y=200.0，Z=200.0）。
- en: With the MovieSphere selected, set its Materials_Element 0 to your MI_MediaPlayer_Mono
    material instance.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MovieSphere，将其Materials_Element 0设置为你的MI_MediaPlayer_Mono材料实例。
- en: Hit Add Component, add a MediaSound component, and set its associated Media
    Player to your media player.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加组件，添加一个MediaSound组件，并将其关联的媒体播放器设置为你的媒体播放器。
- en: Now, just as we did with our previous scenes, we need to tell the media player
    to load our media.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们之前的场景一样，我们需要告诉媒体播放器加载我们的媒体。
- en: In your map's Level Blueprint, create a variable named `MediaPlayer`, set its
    Type to Media Player | Object Reference, compile it, and set its Default Value
    to your Media Player.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图的Level Blueprint中，创建一个名为`MediaPlayer`的变量，将其类型设置为Media Player | Object Reference，编译它，并将其默认值设置为你的媒体播放器。
- en: Call Open Source on your Media Player variable with your new 360 video as its
    Media Source.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的360度视频作为其媒体源，通过Open Source调用你的媒体播放器变量。
- en: Execute this call from your Event BeginPlay.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的Event BeginPlay中执行此调用。
- en: Test your scene. You should now see the movie playing all around you.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的场景。现在你应该能够看到电影在你周围播放。
- en: Playing stereoscopic 360 degree video
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放立体360度视频
- en: Now, we're going to do the same thing for stereoscopic 360 degree video. At
    the time of writing, stereoscopic 360 degree video is much less common than its
    2D counterpart, in part because it consumes so much more disk space, and also
    because it's significantly more difficult to produce, but it's reasonable to expect
    that things will continue to evolve.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要为立体360度视频做同样的事情。在撰写本文时，立体360度视频比其2D对应物要少得多，部分原因是它占用了更多的磁盘空间，而且制作起来更加困难，但可以合理地期望事情将继续发展。
- en: In the meantime, we can find a viable test file here: [https://www.dareful.com/products/free-virtual-reality-video-sequoia-national-park-vr-360-stereoscopic](https://www.dareful.com/products/free-virtual-reality-video-sequoia-national-park-vr-360-stereoscopic).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们可以在这里找到一个可行的测试文件：[https://www.dareful.com/products/free-virtual-reality-video-sequoia-national-park-vr-360-stereoscopic](https://www.dareful.com/products/free-virtual-reality-video-sequoia-national-park-vr-360-stereoscopic)。
- en: As always, download the file, put it in your Content/Movies directory, create
    a File Media Source asset that points to it, and test it in your Media Player
    to ensure that it plays on your system.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，下载文件，将其放在Content/Movies目录中，创建一个指向它的File Media Source资产，并在媒体播放器中测试以确保它在你的系统上播放。
- en: 'Next, let''s make a copy of our 2D spherical test map to use for our 3D test:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们复制一份我们的2D球形测试地图，用于我们的3D测试：
- en: Take the MoviePlayback2DSpherical map and hit File | Save Current As... to MoviePlayback3DSpherical.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MoviePlayback2DSpherical地图另存为MoviePlayback3DSpherical。
- en: Select the MovieSphere asset and change its assigned material to your OverUnder
    material instance.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MovieSphere资产，并将其分配的材料更改为你的OverUnder材料实例。
- en: Open the level blueprint and change the Open Source node to point to our new
    file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开级别蓝图，并将Open Source节点更改为指向我们的新文件。
- en: 'Let''s test it. We have spherical 3D, but our stereo is flipped (on this file,
    at least). Everything that should be close looks far away. We can correct this
    by adding another option to our master material:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。我们有球形的3D效果，但是我们的立体声是反转的（至少在这个文件中是这样）。所有应该靠近的东西看起来都很远。我们可以通过向主材料添加另一个选项来纠正这个问题：
- en: Open your media master material.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的媒体主材料。
- en: Add a new Static Switch Parameter and name it FlipStereo.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的静态开关参数，并将其命名为FlipStereo。
- en: Drag the output from your StereoPassIndex node into the FlipStereo switch's
    False input.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将StereoPassIndex节点的输出拖动到FlipStereo开关的False输入中。
- en: Create a OneMinus node, drag the output from StereoPassIndex into its input,
    and connect its output to the FlipStereo switch's True input.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个OneMinus节点，将StereoPassIndex的输出拖动到其输入中，并将其输出连接到FlipStereo开关的True输入。
- en: 'Connect the FlipStereo switch''s output to the Multiply node:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将FlipStereo开关的输出连接到Multiply节点：
- en: '![](img/4bd3f97c-6e26-415d-bda0-0ec5f83a9b2e.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bd3f97c-6e26-415d-bda0-0ec5f83a9b2e.png)'
- en: What we've done here is simply set up an option so that if FlipStereo is true,
    we'll receive a 1 for the left eye and a 0 for the right eye instead of the other
    way around.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是设置了一个选项，如果FlipStereo为true，我们将接收到左眼为1，右眼为0，而不是相反。
- en: 'Now, let''s create another material instance to hold this option setting and
    apply it to our sphere:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个材料实例来保存这个选项设置，并将其应用到我们的球体上：
- en: Duplicate your OverUnder material instance and name it something like MI_MediaPlayer_OverUnderFlipped.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的OverUnder材料实例，并将其命名为MI_MediaPlayer_OverUnderFlipped之类的名称。
- en: Open up the new material instance and set its FlipStereo parameter to True.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的材料实例，并将其FlipStereo参数设置为True。
- en: 'Apply it to your movie sphere:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其应用到你的电影球体上：
- en: '![](img/09007cba-e69e-45a0-9d28-24d8666e51de.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09007cba-e69e-45a0-9d28-24d8666e51de.png)'
- en: Test the map – you should now be seeing the stereo imagery sorted correctly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 测试地图-现在你应该能够正确地看到立体图像。
- en: Spend some time looking around. This video runs at a fairly high bitrate, so
    you may experience occasional frame drops and there are a few perspective glitches,
    but the stereo effect is pretty compelling. It's clear that we're going to be
    able to do some astonishing work as this tech evolves.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间四处看看。这个视频的比特率相当高，所以你可能会偶尔遇到帧率下降的情况，还有一些透视错误，但立体效果非常引人注目。很明显，随着这项技术的发展，我们将能够做出一些令人惊叹的工作。
- en: Controlling your Media Player
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制你的媒体播放器
- en: Before we wrap things up for this chapter, let's give our players a few ways
    to control their Media Player.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们给玩家一些控制媒体播放器的方法。
- en: We could do this work from within the level blueprint, and that's what we've
    been doing so far, but that's not an ideal solution if we're going to have multiple
    maps in our project. We're going to wind up copying and pasting Blueprint code
    from one level to another, and if we update one of them, we have to remember to
    update the rest. This is bad practice.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: A much better idea is to create a manager actor that contains all the code we
    need to manage our media player, and that we can just drop into any level that
    needs to support it. This way, we're writing our code once, and as we update it,
    the effects are seen everywhere. Let's do this.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Media Manager
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new Blueprints subdirectory inside our project''s content directory:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Right-click inside it and select Create Basic Asset | Blueprint Class.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For its Parent Class, select Actor.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `BP_MediaManager`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Up until this point, we''ve been using our level blueprints to open media on
    our media player. We''re going to move that functionality into our media manager
    first:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Open up BP_MediaManager.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable named `MediaPlayer` and set its Type to Media Player |
    Object Reference.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile it and set its default value to your media player.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another new variable named `FileMediaSource` and set its Type to File
    Media Source | Object Reference.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Instance Editable to True for this variable since we're going to need to
    set different values on it for each map.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Category to Config so that it's clear to the user that they have to
    edit this value.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve set up our variables, let''s use this actor''s BeginPlay to
    load our media. To start with, we''re just going to recreate what we''ve already
    been doing in our level Blueprints:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Open the Event Graph of BP_MediaManager.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag the MediaPlayer variable onto the graph.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call Open Source on it.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Ctrl* + drag your File Media Source variable onto the graph.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click it and select Convert to Validated Get. (We don't want to try and
    open a file media source if we haven't set it yet.)
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the execution line from Event BeginPlay into your File Media Source Get.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the getter's Is Valid execution line into your Open Source call's execution
    input.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the output of GET into your Open Source call's Media Source input.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a Print String node.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its In String value to Media Manager's file media source is not set!.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the Is Not Valid execution line of GET to the Print String we just created:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0bba401a-4b4a-45da-8506-da227ef389cf.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: Now, if we place this actor in any level and set its File Media Source, it will
    start playing that source on the project's Media Player. If there's an object
    in that level with a material reading a Media Texture that points to this media
    player, whatever we're playing will show up there.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you set up a system that could fail if the developer or user fails
    to do something, as is the case here with our File Media Source variable, get
    in the habit of using validated gets and printing out warnings if the get fails.
    You'll save yourself a lot of debugging time if you train yourself to write code
    that tells you on its own when something is wrong.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s put a Media Manager in our current level and replace the work we''re
    doing in the Level Blueprint:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Drag an instance of BP_MediaManager into your scene and zero out its Location.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Config | File Media Source to whichever media source you were previously
    playing in the scene.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the scene's Level Blueprint and delete the code we previously put there
    on BeginPlay.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the scene. The media should still play, but now the Media Manager is handling
    opening the source.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for your other test levels so that they're all using the Media Manager
    blueprint.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Now that each of our levels is using an instance of our Media Manager class
    to operate the Media Player, we can much more easily add functionality that will
    apply everywhere.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Let's do this now.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Pause and Resume function
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s give our users a way to pause and play the video:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给用户提供暂停和播放视频的方法：
- en: Open BP_MediaManager.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_MediaManager。
- en: In its Details panel, set Input | Auto Receive Input to Player 0 and Block Input
    to True.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细面板中，将输入|自动接收输入设置为Player 0，并将阻止输入设置为True。
- en: Right-click in its Event Graph and select Input | Keyboard Events | Space Bar
    to create a new keyboard event.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其事件图中右键单击，选择输入|键盘事件|空格键创建一个新的键盘事件。
- en: Right-click again and select Input | Gamepad Events | MotionController (R) Trigger
    to create another input event.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击，选择输入|游戏手柄事件|MotionController（R）触发器创建另一个输入事件。
- en: '*Ctrl* + drag your media player variable onto your graph.'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Ctrl* +将媒体播放器变量拖动到图表上。'
- en: Drag its output and create an Is Playing node.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动其输出并创建一个正在播放节点。
- en: Connect a Branch node to the Is Playing node's result.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个分支节点连接到正在播放节点的结果。
- en: Connect the Pressed execution line of Space Bar to the Branch node's execution
    input. Do the same for the Trigger input.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Space Bar的Pressed执行线连接到分支节点的执行输入。对于触发器输入也是如此。
- en: Drag another connector from your Media Player variable and create a Pause node
    for it.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从媒体播放器变量中拖动另一个连接器，并为其创建一个暂停节点。
- en: Connect your Branch node's True execution line to the Pause node's execution
    input.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支节点的True执行线连接到暂停节点的执行输入。
- en: Drag another connector from the Media Player variable (or create a reroute node
    and branch from it) and create a Play call.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从媒体播放器变量拖动另一个连接器（或创建一个重定向节点并从中分支出）并创建一个播放调用。
- en: 'Connect the Branch node''s False execution line to the Play node:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支节点的False执行线连接到播放节点：
- en: '![](img/27992c6b-7ab6-4256-a16e-75d420392544.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27992c6b-7ab6-4256-a16e-75d420392544.png)'
- en: We've done a few things here that are worth talking about.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些值得讨论的事情。
- en: First, we're using a different means of capturing keyboard and motion controller
    input than we previously have. For everything we've done up until now, we've relied
    on the Project Settings and the `DefaultInput.ini` file to capture input from
    our hardware devices and remap it to named input events. In truth, this remains
    a better way to do it, but we wanted to show you another way it could be done.
    Very often, it can make sense to prototype your systems using input events mapped
    directly in your Blueprints like this one, and then once you've got your systems
    worked out, move them into your Project Settings so it's easier to remap them
    for different controllers.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了与之前不同的捕获键盘和动作控制器输入的方法。到目前为止，我们所做的一切都依赖于项目设置和`DefaultInput.ini`文件来捕获来自硬件设备的输入并将其重新映射到命名的输入事件。事实上，这仍然是一种更好的方法，但我们想向您展示另一种可能的方法。很多时候，使用直接在蓝图中映射的输入事件原型化系统是有意义的，一旦您的系统工作正常，将它们移入项目设置中，这样更容易为不同的控制器重新映射它们。
- en: It's important to note as well that this object is only able to hear input because
    we set its Auto Receive Input. Otherwise, it won't listen for input from other
    devices by default.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，只有因为我们设置了其自动接收输入，这个对象才能够接收输入。否则，默认情况下它不会监听其他设备的输入。
- en: What we're doing here is querying the Media Player to see whether it's playing
    anything at present, pausing it if it is, and playing it if it isn't.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是查询媒体播放器，看它是否正在播放任何内容，如果是，则暂停它，如果不是，则播放它。
- en: While we're not going to cover it here because it would become a project on
    its own, if you wanted to create a button-based user interface and use a widget
    interaction component to allow the user to interact with the controls, you could
    do so by having this Media Manager object own the interface and using the button
    events to manage the media player's behavior.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在这里涵盖它，因为它将成为一个独立的项目，但如果您想创建基于按钮的用户界面并使用小部件交互组件允许用户与控件进行交互，您可以通过使此媒体管理器对象拥有界面并使用按钮事件来管理媒体播放器的行为来实现。
- en: This is a fairly simple example, but it demonstrates a few ways you can interact
    with a media player. You can query its status, control playback, open new media,
    and even assign events to it so that it responds when it finishes loading media.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的示例，但它演示了您可以与媒体播放器交互的几种方式。您可以查询其状态，控制播放，打开新媒体，甚至为其分配事件，以便在加载媒体完成时响应。
- en: Assigning events to a media player
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为媒体播放器分配事件
- en: Let's demonstrate a way we can use an event on our media player. We're going
    to turn off our Media Player's Play on Open setting, and instead have our Media
    Manager play a file once it's finished opening. This is an important pattern to
    learn because large media files won't be ready to play immediately after you call
    Open Source. Depending on how big they are and how fast the hard drive they're
    stored on is, they're going to take a moment to open, so it's good practice after
    you open a file to instruct your media player to listen for when the file finishes
    loading, and to start playing it then.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示一种使用媒体播放器上的事件的方法。我们将关闭媒体播放器的“打开时播放”设置，并改为在打开后让媒体管理器播放文件。这是一个重要的模式，因为大型媒体文件在调用Open
    Source后不会立即准备好播放。根据它们的大小和存储它们的硬盘的速度，它们将需要一段时间来打开，因此在打开文件后，指示媒体播放器监听文件加载完成并开始播放是一个好的做法。
- en: In practice, the Play on Open setting already does this, but it's valuable for
    you to learn about this pattern so that you can use it when you need to do something
    more complex with your media player.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，“打开时播放”设置已经实现了这一点，但对于您来说，了解这种模式是很有价值的，这样您就可以在需要对媒体播放器进行更复杂操作时使用它。
- en: 'Let''s set it up:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置它：
- en: Open your media player asset and turn off its Play on Open setting.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的媒体播放器资源并关闭其“打开时播放”设置。
- en: If you test one of your maps now, you'll see that the media no longer plays
    until you tap the *spacebar* or pull the trigger to start it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在测试您的地图之一，您会发现媒体不再播放，直到您点击空格键或拉动触发器才会开始播放。
- en: Open BP_MediaManager and find the Open Source call you're making on Event BeginPlay.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_MediaManager并找到在事件BeginPlay上进行的Open Source调用。
- en: Connect a Branch node to its Return Value.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个分支节点连接到其返回值。
- en: The Open Source call is going to return True if it found the file to open and
    is will opening it, and False if it couldn't. We only want our Media Player to
    wait for the file to open if we know it's actually opening it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Drag a connector from your Media Player variable and select Media | Media Player
    | Bind Event to OnMediaOpened.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from the Bind node's Event input and select Add Event | Add
    Custom Event.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `MediaOpened`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a connector from your Media Player variable and call Play on it.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the execution output from your custom event to the Play call''s input:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6fe223d6-2bfa-4190-a586-caea4c58c79f.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Test it. Your media should play when it finishes opening. In practice, it will
    behave exactly as it did when Play on Open was still true, but there's some important
    stuff to talk about here.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Most function calls will continue their execution only when they've finished
    whatever job it was they were supposed to do. Open Source is a little different.
    This is what's known as an **Async Task**. When you call Open Source, the execution
    will continue immediately, but the task itself will take an indeterminate amount
    of time to finish. You'll run into this a lot when opening large files, accessing
    URLs on the web, or doing any other task where you really don't know when you
    begin how long it's actually going to take. An **asynchronous** (**Async**) task
    starts up when you call it, and then finishes at some point in the future. The
    object that you call an Async task on is pretty much always going to have some
    sort of event it throws when the task finishes so that you can do whatever you
    need to do when it's done.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Open Source task on a Media Player object, the OnMediaOpened
    event is called when the source finishes opening. By binding a custom event to
    this event, we're telling it to trigger that event in our blueprint when the media
    finishes opening, and call the `Play` method on the media player when this happens.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: When creating custom events for bindings, it's a good idea to create them by
    dragging out the event connector and creating the custom event from there, as
    we did in this example. This is because many bindings will require that their
    bound events include certain inputs (this is called a signature), and if you just
    create a basic custom event that doesn't match the required signature, it won't
    let you bind it. If you create your custom events directly from the event connector,
    it will automatically set up the correct signature for you. In this case, the
    bound event for OnMediaOpened is required to pass an Opened URL argument.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: This is an important pattern and it's worth learning. Video files are big, and
    sometimes operations on them are going to take time. Get to know the events you
    can bind on your media player objects, and make sure you're doing whatever it
    is you're trying to do once you know the job has finished and succeeded.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: You will, at some point in your travels, come across a developer who handles
    asynchronous tasks by putting delays into their blueprints. They will discover
    through trial and error that the call they're trying to make works if they delay
    it and fails if they try to do it immediately, so they just stick a delay on there
    with some random duration and call the bug fixed. You, however, are not going
    to do this. It's amateur hour stuff, and will just fail later on if they try to
    open a larger file or something else changes. The correct way to deal with async
    tasks is always to find out what event gets called when they finish, and then
    bind whatever else you need to do to that event. Never use a delay to solve a
    problem unless you can describe in positive terms why you know the delay is the
    correct solution. The correct solution is almost always a bound event that will
    work no matter how long the task takes.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: You've now seen examples of each of the ways you can interact with a media player
    object. We've polled its status, made calls to it, and bound additional code to
    its events so that we can respond when the media player tells us something has
    happened. There's more you can do with media players, and we encourage you to
    play with this. Try binding an event to its OnEndReached, or some other bindable
    event. Try using Get Time and Duration calls on the Media Player to create a progress
    bar. There's a lot you can do with this.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot about how video files play in Unreal Engine.
    We learned a bit about containers and codecs and how to understand what a video
    file contains, and then we learned a variety of ways to play them back, both on
    flat screens and on spheres. We learned how we can create materials to display
    3D video as well as 2D, and learned how to create a media manager class to manage
    their playback.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn about how multiplayer networking works
    in Unreal.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
