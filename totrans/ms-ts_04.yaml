- en: Chapter 4. Writing and Using Declaration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most appealing facets of JavaScript development is the myriad of
    external JavaScript libraries that have already been published, such as jQuery,
    Knockout, and Underscore. The TypeScript designers knew that introducing "syntactic
    sugar" to the TypeScript language would bring a range of benefits to the developer
    experience. These benefits include IDE features such as Intellisense, as well
    as detailed compile time error messages. We have already seen how to use this
    syntax for most of the TypeScript language features such as classes, interfaces,
    and generics, but how do we apply this "sugar" to existing JavaScript libraries?
    The answer is relatively simple—declaration files.
  prefs: []
  type: TYPE_NORMAL
- en: A declaration file is a special type of file used by the TypeScript compiler.
    It is marked with a `.d.ts` extension, and is then used by the TypeScript compiler
    within the compilation step. Declaration files are similar to header files used
    in other languages; they simply describe the syntax and structure of available
    functions and properties, but do not provide an implementation. Declaration files,
    therefore, do not actually generate any JavaScript code. They are there simply
    used to provide TypeScript compatibility with external libraries, or to fill in
    the gaps for JavaScript code that TypeScript does not know about. In order to
    use any external JavaScript library within TypeScript, you will need a declaration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore declaration files, show the reasoning behind
    them, and build one based on some existing JavaScript code. If you are familiar
    with declaration files and how to use them, then you may be interested in the
    *Declaration Syntax Reference* section. This section is designed as a quick reference
    guide to the module definition syntax. Since writing declaration files is a rather
    small part of TypeScript development, we do not write them very often. The *Declaration
    Syntax Reference* section shows sample declaration file syntax for the equivalent
    JavaScript syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern websites use some sort of server engine to generate the HTML for
    their web pages. If you are familiar with the Microsoft stack of technologies,
    then you would know that ASP.NET MVC is a very popular server-side engine, used
    to generate HTML pages based on master pages, partial pages, and MVC views. If
    you are a Node developer, then you may be using one of the popular Node packages
    to help you construct web pages through templates, such as Jade or Embedded JavaScript
    (EJS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within these templating engines, you may sometimes need to set JavaScript properties
    on the HTML page as a result of your backend logic. As an example, let''s assume
    that you keep a list of contact e-mail addresses on your backend database, and
    then surface these to your frontend HTML page through a JavaScript global variable
    named `CONTACT_EMAIL_ARRAY`. Your rendered HTML page would then include a `<script>`
    tag that contains this global variable and contact e-mail addresses. You may have
    some JavaScript that reads this array, and then renders the values in a footer.
    The following HTML sample shows what a generated script within an HTML page may
    end up looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This HTML has a script block and within this script block, some JavaScript.
    The JavaScript is simply a variable named `CONTACT_EMAIL_ARRAY` that contains
    some strings. Let''s assume that we wanted to write some TypeScript that can read
    this global variable. Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a class named `GlobalLogger` with a single static function
    named `logGlobalsToConsole`. The function simply iterates through the `CONTACT_EMAIL_ARRAY`
    global variable, and logs the items in the array to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile this TypeScript code, we will generate the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This error indicates that the TypeScript compiler does not know anything about
    the variable named `CONTACT_EMAIL_ARRAY`. It does not even know that it is an
    array. As this piece of JavaScript is outside any TypeScript code, we will need
    to treat it in the same way as "external" JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve our compilation problem, and make this `CONTACT_EMAIL_ARRAY` variable
    visible to TypeScript, we will need to use a declaration file. Let''s create a
    file named `globals.d.ts` and include the following TypeScript declaration within
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to notice is that we are using a new TypeScript keyword: `declare`.
    The `declare` keyword tells the TypeScript compiler that we want to define the
    type of something, but that the implementation of this object (or variable or
    function) will be resolved at runtime. We have declared a variable named `CONTACT_EMAIL_ARRAY`
    that is typed to be an array of strings. This `declare` keyword does two things
    for us: it allows the use of the variable `CONTACT_EMAIL_ARRAY` within TypeScript
    code, and it also strongly types this variable to be an array of strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 1.0 version and upwards of the TypeScript compiler will scan our source
    code directory for `.d.ts` files and automatically include them in the compilation
    step. In previous versions, it was necessary to include a comment as a reference
    to these files, but this reference comment line is no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this `globals.d.ts` file in place, our code compiles correctly. If we
    now run this in a browser, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, by using a declaration file named `globals.d.ts`, we have been able to describe
    the structure of an "external" JavaScript variable to the TypeScript compiler.
    This JavaScript variable is defined outside any of our TypeScript code, yet we
    are still able to work with the definition of this variable within TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: This is what declaration files are used for. We are basically telling the TypeScript
    compiler to use the definitions found within a declaration file within the compilation
    step, and that the actual variables themselves will only be available at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Definition files also bring Intellisense or code completion functionality to
    our IDE for external JavaScript libraries and code.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript code blocks in HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples we have just seen are an example of tight coupling between the generated
    HTML content (that contains JavaScript code in script blocks) on your web page,
    and the actual running JavaScript. You may argue, however, that this is a design
    flaw. If the web page needed an array of contact e-mails, then the JavaScript
    application should simply send an AJAX request to the server for the same information
    in JSON format. While this is a very valid argument, there are cases where including
    content in the rendered HTML is actually faster.
  prefs: []
  type: TYPE_NORMAL
- en: There used to be a time where the Internet seemed to be capable of sending and
    receiving vast amounts of information in the blink of an eye. Bandwidth and speed
    on the Internet were growing exponentially, and desktops were getting larger amounts
    of RAM and faster and faster processors. As developers during this stage of the
    Internet highway, we stopped thinking about how much RAM a typical user had on
    their machine. We also stopped thinking about how much data we were sending across
    the wire. This was because Internet speeds were so fast and browser processing
    speed was seemingly limitless.
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, and then along came the mobile phone –and it felt like we were back in
    the 1990s -with incredibly slow Internet connections, tiny screen resolutions,
    limited processing power, very little RAM (and popular arcade gaming experiences
    like *Elevator Action*, found at [https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en](https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en).
    The point of this story is that as modern web developers, we still need to be
    mindful of browsers that run on mobile phones. These browsers are sometimes running
    on very limited Internet connections, meaning that we must carefully measure the
    size of our JavasScript libraries, JSON data, and HTML pages, to ensure that our
    applications are fast and usable, even on mobile browsers.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of including JavaScript variables or smaller static JSON data
    within the rendered HTML page often provides us with the fastest way to render
    a screen on an older browser, or in the modern age, a mobile phone. Many popular
    sites use this technique to quickly render the general structure of the page (header,
    side panels, footers, and so on) before the main content is delivered through
    asynchronous JSON requests. This technique works well because it renders the page
    faster and gives the user faster feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Structured data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s enhance this simple array of contact e-mails with a little more relevant
    data. For each of these e-mail addresses, we now want to include some text that
    we will render within the footer of our page, along with the e-mail addresses.
    Consider the following HTML code with a global variable that uses a JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a global variable named `CONTACT_DATA` that is an array
    of JSON objects. Each JSON object has a property named `DisplayText` and a property
    named `Email`. As we have done before, we will now need to include a definition
    of this variable in our `globals.d.ts` declaration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start with an interface definition named `IContactData` to represent the
    properties of an individual item in the `CONTACT_DATA` array. Each item has a
    `DisplayText` property that is of the type `string`, as well as an `Email` property
    which is also of type `string`. Our `IContactData` interface, therefore, matches
    the original object properties of a single item in the JSON array. We then declare
    a variable named `CONTACT_DATA` and set its type to be an array of the `IContactData`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to work with the `CONTACT_DATA` variable within TypeScript.
    Let''s now create a class to process this data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `ContactLogger` has a single static method named `logContactData`.
    Within this method, we loop through all of the items in the `CONTACT_DATA` array,
    using the `length` property that is inherent in all JavaScript arrays. We then
    create a variable named `contactDataItem` that is strongly typed to be of type
    `IContactData`, and assign the value of the current array item to it. Being of
    type `IContactData`, the `contactDataItem` will now have two properties, `DisplayText`
    and `Email`. We simply log these values to the console. The output of this code
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing your own declaration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any development team, there will come a time when you will need to either
    bug-fix, or enhance a body of code that has already been written in JavaScript.
    If you are in this situation, then you would want to try and write new areas of
    code in TypeScript, and integrate them with your existing body of JavaScript.
    To do so, however, you will need to write your own declaration files for any existing
    JavaScript that you need to reuse. This may seem like a daunting and time-consuming
    task, but when you are faced with this situation, just remember to take small
    steps, and define small sections of code at a time. You will be surprised at how
    simple it really is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, let''s assume that you need to integrate an existing helper
    class—one that is reused across many projects, is well-tested, and is a development
    team standard. This class has been implemented as a JavaScript closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript code snippet defines a JavaScript object named `ErrorHelper`
    that has two methods. The `containsErrors` method takes an object named `response`
    as an argument, and tests to see whether it has a property called `responseText`.
    If it does, it then checks to see whether the `responseText` property itself has
    a property named `failure`. If this `failure` property is a string containing
    the text `"true"`, or if the `failure` property is a boolean with the value `true`,
    then this function returns `true`; in other words, we are evaluating the `response.responseText.failure`
    property. The `ErrorHelper` closure also has a function called `trace` that can
    be called with a string, or a response object similar to what the `containsErrors`
    function is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this `ErrorHelper` function is missing a key piece of documentation.
    What is the structure of the object being passed into these two methods, and what
    properties does it have? Without some form of documentation, we are forced to
    reverse engineer the code to determine what the structure of the `response` object
    looks like. If we can find some sample usages of the `ErrorHelper` class, this
    may help us to guess this structure. As an example of how this `ErrorHelper` is
    used, consider the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start with a variable named `failureMessage` that has a single property
    `reponseText`. The `responseText` property in turn has two child properties: `failure`
    and `errorMessage`. Our next variable `failureMessageString` has the same structure,
    but defines the `responseText.failure` property to be a string, instead of a boolean
    value. Finally, our `successMessage` object just defines the `responseText.failure`
    property to be `false`, but it does not have an `errorMessage` property.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript JSON format, property names are required to have quotes around
    them, whereas in JavaScript these optional. Therefore, the structure `{"failure"
    : true}` is syntactically equivalent to the structure `{failure : true}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last couple of lines of the preceding code snippet show how the `ErrorHelper`
    closure is used. All we need to do is call the `ErrorHelper.containsErrors` method
    with our variable, and if the result is `true`, log the message to the console
    via the `ErrorHelper.trace` function. Our output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing your own declaration file](img/9665OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ErrorHelper console output
  prefs: []
  type: TYPE_NORMAL
- en: The module keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test this JavaScript `ErrorHelper` closure using TypeScript, we will need
    an HTML page that includes both the `ErrorHelper.js` file, and a TypeScript generated
    JavaScript file. Assuming that our TypeScript file is called `ErrorHelperTypeScript.ts`,
    our HTML page would then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This HTML is very simple, and includes both the existing `ErrorHelper.js` JavaScript
    file, as well as the TypeScript generated `ErrorHelperTypeScript.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `ErrorHelperTypeScript.ts` file, let''s use the `ErrorHelper` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet shows a stripped down version of our original JavaScript
    sample. In fact, we can just copy and paste the original JavaScript code into
    our TypeScript file. We first create a `failureMessage` object with the correct
    properties, and then simply call the `ErrorHelper.containsErrors` method, and
    the `ErrorHelper.trace` method. If we were to compile our TypeScript file at this
    stage, we would receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This error is indicating that there is no valid TypeScript type named `ErrorHelper`,
    even though we have the full source of `ErrorHelper` in our JavaScript file. TypeScript
    by default, will look through all the TypeScript files in our project to find
    class definitions, but it will not parse JavaScript files. We will need a new
    TypeScript definition file in order to correctly compile this code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This definition file is not included in the HTML file at all; it is only used
    by the TypeScript compiler and does not generate any JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Without a set of helpful documentation on our `ErrorHelper` class, we will need
    to reverse-engineer a TypeScript definition purely by reading the source code.
    This is obviously not an ideal situation, and is not recommended, but at this
    stage, it is all we can do. In these situations, the best starting point is simply
    to look at the usage samples and work our way up from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the usage of the `ErrorHelper` closure in JavaScript, there are
    two key pieces that should be included in our declaration file. The first is a
    set of function definitions for the `containsErrors` and `trace` functions. The
    second is a set of interfaces to describe the structure of the `response` object
    that the `ErrorHelper` closure relies upon. Let''s start with the function definitions,
    and create a new TypeScript file named `ErrorHelper.d.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration file starts with the `declare` keyword that we have seen before,
    but then uses a new TypeScript keyword: `module`. The `module` keyword must be
    followed by a module name, which in this case is `ErrorHelper`. This module name
    must match the closure name from the original JavaScript that we are describing.
    In all of our usages of the `ErrorHelper`, we have always pre-fixed the functions
    `containsErrors` and `trace` with the closure name `ErrorHelper` itself. This
    module name is also known as a namespace. If we had another class named `AjaxHelper`
    that also included a `containsErrors` function, we would be able to distinguish
    between the `AjaxHelper.containsErrors` and the `ErrorHelper.containsErrors` functions
    by using these namespaces, or module names.'
  prefs: []
  type: TYPE_NORMAL
- en: The second line of the preceding code snippet indicates that we are defining
    a function called `containsErrors` that takes one parameter. The third line of
    this module declaration indicates that we are defining another function named
    `trace` that takes one parameter. With this definition in place, our TypeScript
    code sample will compile correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we have correctly defined the two functions that are available to users
    of the `ErrorHelper` closure, we are missing the second piece of information about
    the functions available on the `ErrorHelper` closure—the structure of the `response`
    argument. We are not strongly typing the arguments for either of the `containsErrors`
    or `trace` functions. At this stage, our TypeScript code can pass anything into
    these two functions because it does not have a definition for the `response` or
    `message` arguments. We know, however, that both these functions query these arguments
    for a specific structure. If we pass in an object that does not conform to this
    structure, then our JavaScript code will cause runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem and to make our code more stable, let''s define an interface
    for these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an interface named `IResponse` that has a single property of
    `responseText`—the same name as the original JSON object. This `responseText`
    property is strongly typed to be of type `IFailureMessage`. The `IFailureMessage`
    interface is strongly typed to have two properties: `failure`, which is a `boolean`,
    and `errorMessage`, which is of type `string`. These interfaces correctly describe
    the proper structure of the `response` argument for the `containsErrors` function.
    We can now modify our original declaration for the `containsErrors` function to
    use this interface on the `response` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The function definition for `containsErrors` now strongly types the response
    argument to be of type `IResponse`, which we defined earlier. This modification
    to the definition file will now force any further usage of the `containsErrors`
    function to send in a valid argument that conforms to the `IResponse` structure.
    Let''s write some intentionally incorrect TypeScript code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating a variable named `anotherFailure` and specify its type
    to be of type `IResponse`. Even though we are using a definition file to define
    this interface, the rules that are applied by the TypeScript compiler, are no
    different to what we have seen before. The first line in this code snippet will
    generate the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interfaces](img/9665OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compile errors for an incorrect responseText object
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from this fairly verbose but informative error message, the structure
    of the `anotherFailure` variable is causing all the errors. Even though we have
    correctly referenced the `responseText` property of `IResponse`, the `responseText`
    property is strongly typed to be of type `IFailureMessage`, which requires both
    a `failure` property and an `errorMessage` property; hence the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix these errors by including the required properties of `failure` and
    `errorMessage` within the variable `anotherFailure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our TypeScript now compiles correctly. The variable `anotherFailure` now has
    all of the required properties in order to use the `ErrorHelper` functions correctly.
    By creating a strongly typed declaration file for the existing `ErrorHelper` class,
    we can ensure that any further TypeScript usage of the existing `ErrorHelper`
    JavaScript closure will not generate runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Function overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are not quite finished with the declaration file for the `ErrorHelper` just
    yet. If we take a look at the original JavaScript usage of the `ErrorHelper`,
    we will notice that the `containsErrors` function also allows for the `failure`
    property of `responseText` to be a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile this code now, we will get the following compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Function overrides](img/9665OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compile errors for multiple definitions of responseText
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding definition of the variable `failureMessageString`, the type
    of the `"failure"` property is `"true"`, which is of type `string` , and not `true`,
    which is of type `boolean`. In order to allow for this variant on the original
    `IFailureMessage` interface, we will need to modify our declaration file. Firstly,
    we will need two new interfaces that specify the `failure` property to be of type
    `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IResponseString` interface is almost identical to the `IResponse` interface,
    except that it uses the `IFailureMessageString` type for the property `responseText`.
    This `IFailureMessageString` interface is also almost identical to the original
    `IFailureMessage` interface, except that the `failure` property is of type `string`.
    We will now need to modify our declaration file to allow both call signatures
    on the `containsErrors` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As with interface and class definitions, modules also allow for function overrides.
    The module `ErrorHelper` now has one function definition for `containsErrors`
    that uses the original `IResponse` interface, and a second function definition
    that uses the new `IReponseString` interface. This new version of the module definition
    will allow both variants of the `failure` message structure to compile correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also take advantage of union types in this example, and simplify our
    previous declaration for the `containsErrors` function to a single definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rounding out our definition file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now focus our attention on the `trace` function. The `trace` function
    can accept both versions of the `IResponse` interface, or it can simply accept
    a string. Let''s update the definition file for the `trace` function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have updated the `trace` function to allow three different variants
    of the message type—a normal `string`, an `IResponse` type, or an `IResponseString`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our definition file for the `ErrorHelper` JavaScript class.
  prefs: []
  type: TYPE_NORMAL
- en: Module merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we now know, the TypeScript compiler will automatically search through all
    the `.d.ts` files in your project to pick up declaration files. If these declaration
    files contain the same module name, the TypeScript compiler will merge these two
    declaration files and use a combined version of the module declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a file named `MergedModule1.d.ts` that contains the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And a second file named `MergedModule2.d.ts` that contains the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler will merge these two modules as if they were a single
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow both `functionA` and `functionB` to be valid functions of the
    same `MergedModule` namespace and allow the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules can also merge with interfaces, classes, and enums. Classes, however,
    cannot merge with other classes, variables, or interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Syntax Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating declaration files and using the `module` keyword, there are a
    number of rules that can be used to mix and match definitions. We have covered
    one of them already—function overrides. As a TypeScript programmer, you will generally
    only write module definitions every now and then, and on occasion, need to add
    a new definition to an existing declaration file.
  prefs: []
  type: TYPE_NORMAL
- en: This section, therefore, is designed to be a quick reference guide to this declaration
    file syntax, or a cheat-sheet. Each section contains a description of the module
    definition rule, a JavaScript syntax snippet, and then the equivalent TypeScript
    declaration file syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this reference section, simply match the JavaScript that you are trying
    to emulate from the JavaScript syntax section, and then write your declaration
    file with the equivalent definition syntax. We will start with the function overrides
    syntax as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Function overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaration files can include multiple definitions for the same function. If
    the same JavaScript function can be called with different types, you will need
    to declare a function override for each variant of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each function definition must have a unique function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Nested namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Module definitions can contain nested module definitions, which then translate
    to nested namespaces. If your JavaScript uses namespaces, then you will need to
    define nested module declarations to match the JavaScript namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class definitions are allowed within module definitions. If your JavaScript
    uses classes, or the new operator, then the new-able classes will need to be defined
    in your declaration file.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Class namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class definitions are allowed within nested module definitions. If your JavaScript
    classes have a preceding namespace, you will need to declare nested modules to
    match the namespaces first, and then you can declare classes within the correct
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Class constructor overloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class definitions can contain constructor overloads. If your JavaScript classes
    can be constructed using different types, or with multiple parameters, you will
    need to list each of these variants in your declaration file as constructor overloads.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Class properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes can contain properties. You will need to list each property of your
    class within your class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes can contain functions. You will need to list each function of your JavaScript
    class within your class declaration, in order for the TypeScript compiler to accept
    calls to these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions or properties that are considered as private do not need to be exposed
    via the declaration file, and can simply be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Static properties and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class methods and properties can be static. If your JavaScript functions or
    properties can be called without needing an instance of an object to work with,
    then these properties or functions will need to be marked as static.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Global functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions that do not have a namespace prefix can be declared in the global
    namespace. If your JavaScript defines global functions, these will need to be
    declared without a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Function signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function can use a function signature as a parameter. JavaScript functions
    that use callback functions or anonymous functions, will need to be declared with
    the correct function signature.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Optional properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes or functions can contain optional properties. Where JavaScript object
    parameters are not mandatory, these will need to be marked as optional properties
    in the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Merging functions and modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function definition with a specific name can be merged with a module definition
    of the same name. This means that if your JavaScript function can be called with
    parameters and also has properties, then you will need to merge a function with
    a module.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The declaration file syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have outlined what you need to know in order to write and
    use your own declaration files. We discussed JavaScript global variables in rendered
    HTML and how to access them in TypeScript. We then moved on to a small JavaScript
    helper function and wrote our own declaration file for this JavaScript. We finished
    off the chapter by listing a few module definition rules, highlighting the required
    JavaScript syntax, and showing what the equivalent TypeScript declaration syntax
    would be. In the next chapter, we will look at how to use existing third-party
    JavaScript libraries, and how to import existing declaration files for these libraries
    into your TypeScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
