- en: '*Chapter 7*: Java Variables, Operators, and Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the next, we are going to learn and practice the core fundamentals
    of Java data and how to manipulate that data. In this chapter, we will focus on
    creating and understanding the data itself, and in the next chapter, we will see
    how to manipulate and respond to it.
  prefs: []
  type: TYPE_NORMAL
- en: We will also quickly recap on what we learned in the earlier chapters about
    Java, and then dive into learning how to write our very own Java code. The principles
    we are about to learn are not limited to Java but are applicable to other programming
    languages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will be comfortable writing Java code that creates
    and uses data within Android. This chapter takes you through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Java syntax and jargon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and using data with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing values in variables with operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn some Java.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007).
  prefs: []
  type: TYPE_NORMAL
- en: Java is everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core Java fundamentals that we are about to learn apply when working within
    classes that we inherit from (such as `AppCompatActivity`), as well as classes
    that we write ourselves (as we will start to do in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: As it is more logical to learn the basics before we write our own classes, we
    will be using an extended `Activity` class, `AppCompatActivity`, to add some Java
    code in a mini project. We will use the `Log` and `Toast` classes again to see
    the results of our coding in the overridden `onCreate` method of the `Activity`
    class, to trigger the execution of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When however, we move on to [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming* and start to write our own classes, as well as understand
    more about how classes written by others work, everything we have learned here
    will apply then too—in fact, all the Java that you learn in this chapter and the
    next will apply, if you strip it out of the `Activity` class and paste it into
    another Java environment, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any of the major desktop operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many modern TVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sat nav
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart fridges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java will work there too!
  prefs: []
  type: TYPE_NORMAL
- en: Calling all Java gurus
  prefs: []
  type: TYPE_NORMAL
- en: If you have already done some Java programming and understand the following
    keywords (`if`, `else`, `while`, `do while`, `switch`, and `for`), you can probably
    skip to [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187), *Object-Oriented
    Programming*. Alternatively, you might like to skim over this information as a
    refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get on with learning how to code in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Java syntax and jargon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we will use plain English to discuss some technical things.
    You will never be asked to read a technical explanation of a Java or Android concept
    that has not been previously explained in non-technical language.
  prefs: []
  type: TYPE_NORMAL
- en: So far, on a few occasions I have asked that you accept a simplified explanation
    to offer a fuller explanation at a more appropriate time, as I have done with
    classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms, and to join in and learn from these communities, you need
    to understand the terms they use. So, the approach this book takes is to learn
    a concept or appreciate an idea using entirely plain-speaking language, but at
    the same time introduce the jargon/technical term as part of the learning.
  prefs: []
  type: TYPE_NORMAL
- en: Java syntax is the way we put together the language elements of Java to produce
    code that works in the Dalvik **virtual machine** (**VM**). The Java syntax is
    a combination of the words we use and the formation of those words into sentence-like
    structures that make up our code.
  prefs: []
  type: TYPE_NORMAL
- en: These Java "words" are many in number, but taken in small chunks are certainly
    easier to learn than any human-spoken language. We call these words **keywords**.
  prefs: []
  type: TYPE_NORMAL
- en: I am confident that if you can read then you can learn Java, because learning
    Java is much easier. What, then, separates someone who has finished an elementary
    Java course and an expert programmer?
  prefs: []
  type: TYPE_NORMAL
- en: The exact same things that separate a student of language and a master poet.
    Expertise in Java comes not in the number of Java keywords we know how to use
    but in the way we use them. Mastery of the language comes through practice, further
    study, and using the keywords more skillfully. Many consider programming an art
    as much as a science, and there is some truth to this.
  prefs: []
  type: TYPE_NORMAL
- en: More code comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you become more advanced at writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide up our code into separate classes, very often across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code comments** are parts of the Java program that do not have any function
    in the program execution. A compiler ignores these comments. They serve to help
    a programmer to document, explain, and clarify their code, to make it more understandable
    to themselves later or to other programmers who might need to use or change it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen a single-line comment. This is reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comment begins with the two `//` forward-slash characters. The
    comment ends at the end of the line. So, anything on that line is for humans only,
    whereas anything on the next line (unless it''s another comment) needs to be syntactically
    correct Java code, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use multiple single-line comments, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Remember this code, which tells Android to load our layout?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding situation, the layout will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We saw this in [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*,* *Beautiful
    Layouts with CardView and ScrollView,* when we temporarily commented out one of
    our methods.
  prefs: []
  type: TYPE_NORMAL
- en: There is another type of comment in Java, known as a **multiline comment**.
    A multiline comment is useful for longer comments that span multiple lines and
    for adding things such as copyright information at the top of a code file. As
    with a single-line comment, a multiline comment can be used to temporarily disable
    code—in this case, usually across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in between the leading `/*` and the ending `*/` is ignored by the
    compiler. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is no limit to the number of lines in a multiline comment; which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly in the text, but you will often find
    liberally sprinkled comments within the code itself that add further explanation,
    insight, or context. So, it's always a good idea to read all the code thoroughly
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: All the best Java programmers liberally sprinkle their code with comments!
  prefs: []
  type: TYPE_NORMAL
- en: Storing and using data with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of a `variableA`. These names are like our programmer's window
    into the memory of the user's Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are values in memory, ready to be used or altered when necessary by
    using their name.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory has a highly complex system of addressing, which fortunately
    we do not need to interact with. Java variables allow us to devise our own convenient
    names for all the data we need our program to work with. The **Dalvik VM** (**DVM**)
    will handle all the technicalities to interact with the operating system, and
    the operating system will in turn interact with the physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can think of our Android device''s memory as a huge warehouse, just
    waiting for us to add our variables. When we assign names to our variables, they
    are stored in the warehouse, ready for when we need them. When we use our variable''s
    name, the device knows exactly what we are referring to. We can then tell it to
    do things such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign a value to `variableA`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `variableA` to `variableB`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the value of `variableB` and take an action based on the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …and more, as we will soon see
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a typical app, we might have a variable named `unreadMessages`, perhaps to
    hold the number of unread messages a user has. We could add to it when a new message
    arrives, take away from it when the user reads a message, and show it to the user
    somewhere in the app layout so that they know how many unread messages they have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some situations that might arise:'
  prefs: []
  type: TYPE_NORMAL
- en: A user gets three new messages, so add `3` to the value of `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user logs in to the app, so use `Toast` to display a message along with the
    value stored in `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user sees that a bunch of messages are from someone they don't like, and deletes
    six messages. We could then subtract 6 from `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are arbitrary examples of names for variables, and if you don't use any
    of the characters or keywords that Java restricts, you can actually call your
    variables whatever you like.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, it is best to adopt a **naming convention** so that your
    variable names will be consistent. In this book, we will use a loose convention
    of variable names, starting with a lowercase letter. When there is more than one
    word in the variable's name, the second word will begin with an uppercase letter.
    This is called **camel casing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unreadMessages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contactName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFriend`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hard to imagine that even a simple app will have quite a few variables.
    In the previous section, we introduced the `unreadMessages` variable as a hypothetical
    example. What if an app has a list of contacts and needs to remember each of their
    names? We might then need variables for each contact.
  prefs: []
  type: TYPE_NORMAL
- en: And what about when an app needs to know whether a contact is also a friend
    or just a regular contact? We might need code that tests for friend status and
    then adds messages from that contact into an appropriate folder so that the user
    knows if they were messages from a friend or not.
  prefs: []
  type: TYPE_NORMAL
- en: Another common requirement in a computer program, including Android apps, is
    the true or wrong false.
  prefs: []
  type: TYPE_NORMAL
- en: To cover this and many other types of data you might want to store or manipulate,
    Java has **types**.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many types of variables, and we can even invent our own types as well.
    But for now, we will look at the most used built-in Java types, and to be fair,
    they cover just about every situation we are likely to run into for a while. Providing
    some examples is the best way to explain types.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed the hypothetical `unreadMessages` variable. This variable
    is of course a number, so we have to tell the Java compiler this by giving it
    an appropriate type.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the hypothetical `contactName` variable will of course hold
    the characters that make up a contact's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type that holds a regular number is called an `int` type such as `unreadMessages`,
    meant for numbers, we will certainly run into trouble, as we can see from the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_7.01_B16773.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Storing contact name
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Java was designed to make it impossible for such errors to make
    it into a running program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main types of variables in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: An `int` type is for storing integers, whole numbers. This type uses
    32 pieces (**bits**) of memory and can therefore store values a little in excess
    of 2 billion, including negative values too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: As the name hints at, `long` data types can be used when even larger
    numbers are needed. A `long` type uses 64 bits of memory, and 2 to the power of
    63 is what we can store in this. If you want to see what that looks like, here
    it is: 9,223,372,036,854,775,807\. Perhaps surprisingly, there are uses for long
    variables, but the point is that if a smaller variable will do, we should use
    it because our program will use less memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering when you might use numbers of this size. The obvious
    examples would be math or science applications that do complex calculations, but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. A millisecond
    is one-thousandth of a second, so there have been quite a few of them since 1970.
  prefs: []
  type: TYPE_NORMAL
- en: '`float`: This is for floating-point numbers—that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole-number part, the range of a number possible in a `float`
    type is therefore decreased compared to non-floating-point numbers. So, unless
    our variable will use the extra precision, `float` would not be our data type
    of choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: When the precision in a `float` type is not enough, we have `double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: We will be using plenty of Booleans throughout the book. The `boolean`
    variable type can be either `true` or `false`; nothing else. Booleans answer questions
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Is the contact a friend?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Are there any new messages?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Are two examples for a Boolean enough?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`: Store a single alphanumeric character in a `char` type. It''s not going
    to change the world on its own, but could be useful if we put lots of them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: This type is like a space-saving version of `int`. It can be used
    to store whole numbers with both positive and negative values, and can have mathematical
    operations performed on it. Where it differs from `int` is that it uses only 16
    bits of memory, which is just half the amount of memory compared to `int`. The
    downside to `short` is that it can only store half the range of values compared
    to `int`, from -32768 to 32767.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: This type is like an even more space-saving version of `short`. It
    can be used to store whole numbers with both positive and negative values, and
    can have mathematical operations performed on it. Where it differs from `int`
    and `short` is that it uses only 8 bits of memory, which is just half the amount
    of memory compared to `byte`, and quarter the memory of `int`. The downside to
    `byte` is that it can only store half the range of values compared to `int`, from
    -32768 to 32767\. Saving 8 or even 16 bits in total is unlikely to ever matter;
    however, if you needed to store millions of whole numbers in a program, then `short`
    and `byte` are worth considering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I have kept this discussion on data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, then have a look at the *Oracle
    Java Tutorials* site at http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html.
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  prefs: []
  type: TYPE_NORMAL
- en: As we just learned, each type of data that we might want to store will need
    a specific amount of memory. For this reason, we must let the Java compiler know
    the type of the variable before we begin to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The variables described previously are known as **primitive** types. Most primitive
    types are used throughout different programming languages (as well as keywords),
    so if you have a good understanding of the types and keywords, then jumping into
    another language will be far easier than the first time! These types use predefined
    amounts of memory, and so, using our warehouse storage analogy, fit into predefined
    sizes of storage box.
  prefs: []
  type: TYPE_NORMAL
- en: As the "primitive" label suggests, they are not as sophisticated as **reference**
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we didn't cover the `String` variable type we previously
    used to introduce the concept of variables that hold alphanumeric data, such as
    a contact's name.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings are one example of a special type of variable, known as a **reference**
    type. They quite simply refer to a place in memory where storage of the variable
    begins, but the reference type itself does not define a specific amount of memory.
    The reason for this is straightforward: it''s because we don''t always know how
    much data will need to be stored in it until the program is run.'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of Strings and other reference types as continually expanding and
    contracting storage boxes. So, won't one of these `String` reference types bump
    into another variable eventually?
  prefs: []
  type: TYPE_NORMAL
- en: As we are thinking about a device's memory as a huge warehouse full of racks
    of labeled storage boxes, then you can think of a DVM as a super-efficient forklift
    truck driver that puts the different types of storage boxes in the most appropriate
    place; and, if it becomes necessary, the DVM will quickly move stuff around in
    a fraction of a second to avoid collisions. Also, when required, Dalvik, the forklift
    truck driver, will even vaporize any unneeded storage boxes.
  prefs: []
  type: TYPE_NORMAL
- en: This all happens at the same time as constantly unloading new storage boxes
    of all types and placing them in the best place for that type of variable. Dalvik
    keeps reference variables in a different part of the warehouse from primitive
    variables, and we will learn more details about this in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector.*
  prefs: []
  type: TYPE_NORMAL
- en: Strings can be used to store any keyboard character, like a `char` type but
    of almost any length. Anything from a contact's name to an entire book can be
    stored in a single `String` type. We will be using Strings regularly, including
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple more reference types we will explore as well.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arrays are a way to store lots of variables of the same type, ready for quick
    and efficient access. We will look at arrays in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays, Maps, and Random Numbers.*
  prefs: []
  type: TYPE_NORMAL
- en: Think of an array as an aisle in our warehouse, with all variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as Strings. We might, for example, use
    an array to store dozens of contacts in.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another reference type is the `class` type, which we have already discussed
    but not explained properly. We will be getting familiar with classes in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187), *Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that each type of data that we might want to store will require
    an amount of memory. Hence, we must let the Java compiler know the type of the
    variable before we begin to use it. We do this with a variable **declaration**.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's enough theory. Let's see how we would use our variables and types. Remember
    that each primitive type needs a specific amount of real device memory. This is
    one of the reasons why the compiler needs to know what type a variable will be.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must first `int` with the name `unreadMessages`, we would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it—simply state the type (in this case, `int`), then leave a space and
    type the name you want to use for this variable. Note also that the `;` semicolon
    at the end of the line will tell the compiler that we are done with this line
    and that what follows, if anything, is not part of the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for almost all the other variable types, the declaration would occur
    in the same way. Here are some examples. The variable names in the examples are
    arbitrary. This is like reserving a labeled storage box in a warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice I said *almost all the other variable types*. One of the exceptions is
    variables of the `class` type. We have already seen some code declaring variables
    of the `class` type. Do you remember this code snippet from [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure* in the `MainActivity.java`
    file?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This edited snippet of code is declaring a variable called `fab` of type `FloatingActionButton`.
    But we are off track a little, and will come back to classes in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Variable initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Initialization** is the next step. Here, for each type, we initialize a value
    to the variable. This is like placing a value inside a storage box in a warehouse.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `char` variable uses `'` single quotes around the initialized
    value, while the `String` type uses `"` double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine the declaration and initialization steps. Here, we declare
    and initialize the same variables as we have previously, but in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whether we declare and initialize separately or together is dependent upon the
    specific situation. The important thing is that we must do both at some point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This would cause the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compiler Error: Variable a might not have been initialized**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a significant exception to this rule. In certain circumstances, variables
    can have **default values**. We will see this in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*; however, it is good practice to both declare and
    initialize variables.
  prefs: []
  type: TYPE_NORMAL
- en: Changing values in variables with operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, in almost any program, we are going to need to "do things" with these
    variables' values. We manipulate (change) variables with **operators**. Here is
    a list of perhaps the most common Java operators that allow us to manipulate variables.
    You do not need to memorize them as we will look at every line of code as and
    when we use them for the first time. We have already seen the first operator when
    we initialized our variables, but we will see it again, this time being a bit
    more adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the assignment operator: `=`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes the variable to the left of the operator the same as the value to
    the right—for example, like in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After the previous line of code has executed, the value stored in `unreadMessages`
    will be the same as the value stored in `newMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: The addition operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the addition operator: `+`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will add together values on either side of the operator and is usually used
    in conjunction with the assignment operator. For example, it can add together
    two variables that have numeric values, like in this next line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the previous code has executed the combined value of the values held by
    `newMessages` and `unreadMessages`, this is now stored in `unreadMessages`. As
    another example of the same thing, look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it is perfectly acceptable to use the same variable simultaneously
    on both sides of an operator.
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the subtraction operator: `-`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will subtract the value on the right side of the operator from the value
    on the left. This is usually used in conjunction with the assignment operator,
    as in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as a similar example, it is used in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After the previous line of code has executed, `accountBalance` will hold its
    original value minus whatever the value held in `withdrawals` is.
  prefs: []
  type: TYPE_NORMAL
- en: The division operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the division operator: `/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will divide the number on the left by the number on the right. Again, it
    is usually used in conjunction with the assignment operator. Here is an example
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If in the previous line of code `numSweets` held nine sweets and `numChildren`
    held three sweets, then `fairShare` will now hold the value of three sweets.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the multiplication operator: `*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will multiply variables and numbers together and, as with many of the other
    operators, is usually used in conjunction with the assignment operator. For example,
    look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After the previous two lines of code have executed, `answer` holds the value
    100 and `biggerAnswer` holds the value 1000.
  prefs: []
  type: TYPE_NORMAL
- en: The increment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the increment operator: `++`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The increment operator is a quick way to add one to something. For example,
    look at this next line of code, which uses the addition operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line of code has the same result as this much more compact code
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The decrement operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the decrement operator: `--`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The decrement operator (as you probably guessed) is a quick way to subtract
    one from something. For example, look at this next line of code, which uses the
    subtraction operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code is the same as `myVariable --;`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The formal names for these operators are slightly different from those explained
    previously—for example, the division operator is one of the multiplicative operators.
    But the names given previously are far more useful for the purpose of learning
    Java, and if you used the term *division operator* while conversing with someone
    from the Java community, they would know exactly what you mean.
  prefs: []
  type: TYPE_NORMAL
- en: There are even more operators than this in Java. We will meet some of them in
    the next chapter, when we learn about making decisions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about operators, there is a complete list of them on the
    *Oracle Java Tutorials* website, at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators needed to complete the projects in this book will be fully explained
    in this book. The link is provided for the more curious among us.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try using some declarations, assignments, and operators. When we bundle
    these elements together into some meaningful syntax, we call this an `Toast` and
    `Log` to check our results.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing Yourself demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project called `Expressing Yourself`, use the `/Expressing Yourself`
    folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the `onCreate` method, just before the `}` closing curly brace, add
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Directly below the previous line of code, we will initialize a value to `numMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the previous line of code and before the `}`closing curly
    brace of `onCreate`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You will need to import the `Toast` and `Log` classes, as we have done previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app, and we can examine the output and then the code. In the logcat
    window, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On the screen, you will see two pop-up `Toast` messages. The first says **Message
    from James Gosling.** The second says **Message is:Dear reader, I invented Java.**
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The second pop-up Toast message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The second pop-up Toast message
  prefs: []
  type: TYPE_NORMAL
- en: Let's step through the code and make sure that each line is clear before moving
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declared and initialized an `int` type variable called `numMessages`.
    We could have done it on one line, but we did it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we used `Log` to output a message. Instead of simply typing the message
    between the `""` double quote marks, this time we used the `+` operator to add
    `numMessages` onto the output, and as we saw in the console, the actual value
    of `numMessages` was output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to further prove that our `numMessages` variable is as versatile as it
    should be, we used the `++` operator, which should have increased its value by
    `1` and then added `numMessages` to itself, using `+ 1`. We then output the new
    value of `numMessages`, and indeed found its value has increased to 12 from 10,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we created a `boolean`-type variable called `isFriend`, and output that
    to the console. We saw from the output that `true` was displayed. This variable
    type will fully prove its usefulness when we look at decision making in the next
    section. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we declared and initialized two `String`-type variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we output the `String` variables using `Toast`. We used a hardcoded
    part of the `"Message from "` message, and added the variable part of the message
    with `+ contact`. We used the same technique to form the second `Toast` message
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When we add two Strings together to make a longer `String` type, this is called
    **concatenation**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can declare variables, initialize them to a value, change them around
    a bit, and output them using `Toast` or `Log`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At last, we have used some serious Java. We learned about variables, declaration,
    and initialization. We saw how to use operators to change the value of variables.
    It's all right if you don't remember everything straight away as we will constantly
    be using these techniques and keywords throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, let's look at how we can make decisions based on the values
    of these variables and find out how this is useful to us.
  prefs: []
  type: TYPE_NORMAL
