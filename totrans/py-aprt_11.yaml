- en: Chapter 6 – Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is a mechanism for halting “normal” program flow and continuing
    at some surrounding context or code block.
  prefs: []
  type: TYPE_NORMAL
- en: The act of interrupting normal flow is called “raising” an exception. In some
    enclosing context the raised exception must be *handled*, which means control
    flow is transferred to an exception handler. If an exception propagates up the
    call stack to the start of the program, then an unhandled exception will cause
    the program to terminate. An exception object, containing information about where
    and why an exceptional event occurred, is transported from the point at which
    the exception was raised to the exception handler so that the handler can interrogate
    the exception object and take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve used exceptions in other popular imperative languages like C++ or
    Java, then you’ve already got a good idea of how exceptions work in Python.
  prefs: []
  type: TYPE_NORMAL
- en: There have been long and tiresome debates over exactly what constitutes an “exceptional
    event”, the core issue being that exceptionality is in reality a matter of degree
    (some things are more exceptional than others). This is problematic because programming
    languages impose a false dichotomy by insisting that an event is either entirely
    exceptional or not at all exceptional.
  prefs: []
  type: TYPE_NORMAL
- en: The Python philosophy is at the liberal end of the spectrum when it comes to
    the use of exceptions. Exceptions are ubiquitous in Python, and it’s crucial to
    understand how to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and control flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since exceptions are a means of control flow, they can be clumsy to demonstrate
    at the REPL, so in this chapter we’ll be using a Python module to contain our
    code. Let’s start with a very simple module we can use for exploring these important
    concepts and behaviors. Place this code in a module called `exceptional.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `convert()` function from this module into the Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'and call our function with a string to see that it has the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call our function with an object that can’t be converted to an integer,
    we get a traceback from the `int()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What’s happened here is that `int()` *raised* an exception because it couldn’t
    sensibly perform the conversion. We didn’t have a handler in place, so it was
    caught by the REPL and the stack trace was displayed. In other words, the exception
    went unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ValueError` referred to in the stack trace is the *type* of the exception
    object, and the error message `"invalid literal for int() with base 10: ''hedgehog''"`
    is part of the payload of the exception object that has been retrieved and printed
    by the REPL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the exception propagates across several levels in the call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Call stack | Effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int()` | exception raised here |'
  prefs: []
  type: TYPE_TB
- en: '| `convert()` | exception conceptually passes through here |'
  prefs: []
  type: TYPE_TB
- en: '| REPL | exception caught here |'
  prefs: []
  type: TYPE_TB
- en: Handling exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s make our `convert()` function more robust by handling the `ValueError`
    using a `try` .. `except` construct. Both the `try` and `except` keywords introduce
    new blocks. The `try` block contains code that could raise an exception and the
    `except` block contains the code which performs error handling in the event that
    an exception is raised. Modify the `convert()` function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have decided that if a non-integer string is supplied, we’ll return minus
    one. To reinforce your understanding of the control-flow here we’ll also add a
    couple of print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test this interactively after restarting the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `print()` in the `try` block after the point at which the exception
    was raised was *not* executed when we passed in `'giraffe'` as the function argument.
    Instead, execution was transferred directly to the first statement of the `except`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `int()` constructor only accepts numbers or strings, so let’s see what
    happens if we feed an object of another type into it, say a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time our handler didn’t intercept the exception. If we look closely at
    the trace, we can see that this time we received a `TypeError` – a different type
    of exception.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each `try` block can have multiple corresponding `except` blocks which intercept
    exceptions of different types. Let’s add a handler for `TypeError` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we re-run the same test in a fresh REPL we find that `TypeError` is
    handled too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve got some code duplication between our two exception handlers with that
    duplicated `print` statement and assignment. We’ll move the assignment in front
    of the `try` block, which doesn’t change the behavior of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll exploit the fact that both handlers do the same thing by collapsing
    them into one, using the ability of the `except` statement to accept a tuple of
    exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see that everything still works as designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Programmer errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’re confident with the control flow for exception behavior, we can
    remove the print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But now when we try to import our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: we get yet another type of exception, an `IndentationError`, because our `except`
    block is now empty and empty blocks are not permitted in Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an exception type that is *ever* useful to catch with an `except`
    block! Almost anything that goes wrong with a Python program results in an exception,
    but some exception types, such as `IndentationError`, `SyntaxError` and `NameError`,
    are the result of programmer errors which should be identified and corrected during
    development rather than handled at runtime. The fact that these things are exceptions
    is mostly useful if you’re creating a Python development tool such as a Python
    IDE, embedding Python itself in a larger system to support application scripting,
    or designing a plugin system which dynamically loads code.
  prefs: []
  type: TYPE_NORMAL
- en: Empty blocks – the `pass` statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With that said, we still have the problem of what to do with our empty `except`
    block. The solution arrives in the form of the `pass` keyword, which is a special
    statement that does precisely nothing! It’s a no-op, and it’s only purpose is
    to allow us to construct syntactically permissible blocks that are semantically
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case though, it would be better to simplify further by using multiple
    `return` statements, doing away with the `x` variable completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Exception objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we’d like to get hold of the exception object – in this case an
    object of type `ValueError` or `TypeError` - and interrogate it for more details
    of what went wrong. We can get a named reference to the exception object by tacking
    an `as` clause onto the end of the `except` statement with a variable name that
    will be bound to the exception object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll modify our function to print a message with exception details to the
    `stderr` stream before returning. To print to `stderr` we need to get a reference
    to the stream from the `sys` module, so at the top of our module we’ll need to
    `import sys`. We can then pass `sys.stderr` as a keyword argument called `file`
    to `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We take advantage of the fact that exception objects can be converted to strings
    using the `str()` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see that at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Imprudent return codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a second function, `string_log()` to our module, which calls our
    `convert()` function and computes the natural log of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we must confess that we’ve gone out of our way here to be deeply
    unPythonic by wrapping the perfectly good `int()` conversion, which raises exceptions
    on failure, in our `convert()` function which returns a good old-fashioned negative
    error code. Rest assured that this unforgivable Python heresy has been committed
    solely to demonstrate the greatest folly of error return codes: That they can
    be ignored by the caller, wreaking havoc amongst unsuspecting code later in the
    program. A slightly better program might test the value of `v` before proceeding
    to the log call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without such a check `log()` will of course fail when passed the negative error
    code value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, the consequence of the `log()` failure is the raising of another
    exception, also a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Much better, and altogether more Pythonic, to forget about error return codes
    completely and revert to raising an exception from `convert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Re-raising exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of returning an unPythonic error code, we can emit our error message
    and re-raise the exception object we’re currently handling. This can be done by
    replacing the `return -1` with a `raise` statement at the end of our exception
    handling block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Without a parameter `raise` re-raises the exception that is currently being
    handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing in the REPL, we can see that the original exception type is re-raised
    whether it’s a `ValueError` or a `TypeError`, and our “Conversion error” message
    is printed to `stderr` along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions are part of your function’s API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions are an important aspect of the API of a function. Callers of a function
    need to know which exceptions to expect under various conditions so that they
    can ensure appropriate exception handlers are in place. We’ll use square-root
    finding as an example, using a home-grown square-root function, courtesy of Heron
    of Alexandria (although he probably didn’t use Python).
  prefs: []
  type: TYPE_NORMAL
- en: '![Callers of a function need to know which exceptions to expect.](images/m06----callers-need-to-know.png)'
  prefs: []
  type: TYPE_IMG
- en: Callers of a function need to know which exceptions to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following code in a file `roots.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s only one language feature in this program we haven’t met before: The
    logical `and` operator which we use in this case to test that two conditions are
    `True` on each iteration of the loop. Python also includes a logical `or` operator
    which can be used to test whether either or both of its operands are `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our program, we can see that Heron was really on to something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions raised by Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s add a new line to the `main()` function which takes the square-root of
    -1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run that, we get a new exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What has happened is that Python has intercepted a division by zero, which occurs
    on the second iteration of the loop, and raised an exception – a `ZeroDivisionError`.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s modify our code to catch the exception before it propagates up to the
    top of the call stack (thereby causing our program to stop) using the `try` ..
    `except` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run the script we see that we’re handling the exception cleanly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be careful to avoid a beginners mistake of having too-tight scopes
    for exception handling blocks; we can easily use one `try` .. `except` block for
    all of our calls to `sqrt()`. We also add a third print statement to show how
    execution of the enclosed block is terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Raising exceptions explicitly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is an improvement on what we started with, but most likely users of a `sqrt()`
    function don’t expect it to throw a `ZeroDivisionError`.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides us with several standard exception types to signal common errors.
    If a function parameter is supplied with an illegal value, it is customary to
    raise a `ValueError`. We can do this by using the `raise` keyword with a newly
    created exception object which we can create by calling the `ValueError` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways in which we could deal with the division by zero. The first
    approach would be to wrap the root-finding while-loop in a `try` .. `except ZeroDivisionError`
    construct and then raise a new `ValueError` exception from inside the exception
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While it works, this would be wasteful; we would knowingly proceed with a non-trivial
    computation which will ultimately be pointless.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/m06----wasteful.png)'
  prefs: []
  type: TYPE_IMG
- en: Guard clauses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We know this routine will always fail with negative numbers so we can detect
    this precondition early on and raise an exception at that point, a technique called
    a *guard clause*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The test is a simple if-statement and a call to `raise` passing a newly minted
    exception object. The `ValueError()` constructor accepts an error message. See
    how we also modify the docstring to make it plain which exception type will be
    raised by `sqrt()` and under what circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'But look what happens if we run the program – we’re still getting a traceback
    and an ungraceful program exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because we forgot to modify our exception handler to catch `ValueError`
    rather than `ZeroDivisionError`. Let’s modify our calling code to catch the right
    exception class and also assign the caught exception object to a named variable
    so we can interrogate it after it has been caught. In this case our interrogation
    is to `print` the exception object, which knows how to display itself as the message
    to stderr:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program again, we can see that our exception is being gracefully
    handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions, APIs, and protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions are part of a function’s API, and more broadly are part of certain
    *protocols*. For example, objects which implement the sequence protocol should
    raise an `IndexError` exception for indices which are out of range.
  prefs: []
  type: TYPE_NORMAL
- en: The exceptions which are raised are as much a part of a function’s specification
    as the arguments it accepts and must be documented appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: There are a handful of common exception types in Python, and usually when you
    need to raise an exception in your own code, one of the built-in types is a good
    choice. Much more rarely, you’ll need to define new exception types, but we don’t
    cover that in this book. (See the next book in this series *The Python Journeyman*
    for how to do that.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re deciding which exceptions your code should raise, you should look
    for similar cases in existing code. The more your code follows existing patterns,
    the easier it will be for people to integrate and understand. For example, suppose
    you were writing a key-value database: it would be natural to use `KeyError` to
    indicate a request for a non-existent key because this is how `dict` works. Which
    is to say that “mapping” collections in Python follows certain protocols, and
    exceptions are part of those protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few common exception types.
  prefs: []
  type: TYPE_NORMAL
- en: IndexError
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `IndexError` is raised when an integer index is out of range.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this when you index past the end of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: ValueError
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `ValueError` is raised when an object is of the right type, but contains an
    inappropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen this already when trying to construct an `int` from a non-numeric
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: KeyError
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `KeyError` is raised when a look-up in a mapping fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that here when we look up a non-existent key in a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Choosing not to guard against `TypeError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We tend not to protect against `TypeErrors` in Python. To do so runs against
    the grain of dynamic typing in Python and limits the re-use potential of code
    we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could test whether the argument was an `str` using the built-in
    `isinstance()` function and raise a `TypeError` exception if it was not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: But then we’d also want to allow arguments that are instances of `float` as
    well. It soon gets complicated if we want to check whether our function will work
    with types such as rational, complex, or any other kind of number, and in any
    case, who is to say that it does?!
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively we could intercept `TypeError` inside our function and re-raise
    it, but to what end?
  prefs: []
  type: TYPE_NORMAL
- en: '![Don''t usually bother to handle TypeErrors.](images/m06----just-let-it-fail.png)'
  prefs: []
  type: TYPE_IMG
- en: Don’t usually bother to handle TypeErrors.
  prefs: []
  type: TYPE_NORMAL
- en: Usually in Python it’s not worth adding type checking to your functions. If
    a function works with a particular type – even one you couldn’t have known about
    when you designed the function – then that’s all to the good. If not, execution
    will probably result in a `TypeError` anyway. Likewise, we tend not to *catch*
    `TypeErrors` with except blocks very frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic style – EAFP versus LBYL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at another tenet of Python philosophy and culture, the idea that
    “It’s Easier to Ask for Forgiveness than for Permission”.
  prefs: []
  type: TYPE_NORMAL
- en: There are only two approaches to dealing with a program operation that might
    fail. The first approach is to check that all the preconditions for a failure
    prone operation are met in advance of attempting the operation. The second approach
    is to blindly hope for the best, but be prepared to deal with the consequences
    if it doesn’t work out.
  prefs: []
  type: TYPE_NORMAL
- en: In Python culture these two philosophies are known as “Look Before you Leap”
    (LBYL) and its “Easier to Ask for Forgiveness than for Permission” (EAFP) – which,
    incidentally, was coined by Rear Admiral Grace Hopper, inventor of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Python is strongly in favor of EAFP because it puts primary logic for the “happy
    path” in its most readable form, with deviations from the normal flow handled
    separately, rather than interspersed with the main flow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example – processing a file. The details of the processing
    aren’t relevant. All we need to know is that the `process_file()` function will
    open a file and read some data from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the LBYL version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Before attempting to call `process_file()` we check that the file exists, and
    if it doesn’t we avoid making the call and print a helpful message instead. There
    are several problems with this approach, some obvious and some insidious. One
    obvious problem is that we only perform an existence check. What if the file exists
    but contains garbage? What if the path refers to a directory instead of a file?
    According to LBYL we should add preemptive tests for those too.
  prefs: []
  type: TYPE_NORMAL
- en: A more subtle problem is that there is a race condition here. It’s possible
    for the file to be deleted, for example by another process, *between* the existence
    check and the `process_file()` call … a classic race condition. There’s really
    no good way to deal with this – handling of errors from `process_file()` will
    be needed in any case!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the alternative, using the more Pythonic EAFP approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this version we attempt the operation without checks in advance, but we have
    an exception handler in place to deal with any problems. We don’t even need to
    know in a lot of detail exactly what might go wrong. Here we catch `OSError` which
    covers all manner of conditions such as file-not-found and using directories where
    files are expected.
  prefs: []
  type: TYPE_NORMAL
- en: EAFP is standard in Python, and following that philosophy is primarily facilitated
    by exceptions. Without exceptions, and being forced to use error codes instead,
    you are required to include error handling directly in the main flow of the logic.
    Since exceptions interrupt the main flow, they allow you to handle exceptional
    cases non-locally.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions coupled with EAFP are also superior because, unlike error codes,
    *exceptions cannot be easily ignored*. By default exceptions have a big effect,
    whereas error codes are silent by default. So the exception-/EAFP-based style
    makes it very difficult for problems to be silently ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Clean-up actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you need to perform a clean-up action irrespective of whether an operation
    succeeds. In a later module we’ll introduce context managers which are the modern
    solution to this common situation, but here we’ll introduce the `try` .. `finally`
    construct, since creating a context manager can be overkill in simple cases. In
    any case, an understanding of `try` .. `finally` is useful for making your own
    context managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function, which uses various facilities of the standard library
    `os` module to change the current working directory, create a new directory at
    that location, and then restore the original working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At first sight this seems reasonable, but should the call to `os.mkdir()` fail
    for some reason the current working directory of the Python process won’t be restored
    to it’s original value, and the `make_at()` function will have had an unintended
    side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we’d like the function to restore the original current working
    directory under all circumstances. We can achieve this with a `try` .. `finally`
    block. Code in the `finally` block is executed whether execution leaves the `try`
    block normally by reaching the end of the block, or exceptionally by an exception
    being raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This construct can be combined with `except` blocks, used below to add a simple
    failure logging facility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, if `os.mkdir()` raises an `OSError`, the `OSError` handler will be run
    and the exception will be re-raised. But since the `finally` block is always run
    no matter how the try-block ends, we can be sure that the final directory change
    will take place in all circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m06----zen-errors-should-never-pass-silently.png)'
  prefs: []
  type: TYPE_IMG
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detecting a single keypress from Python – such as the “Press any key to continue.”
    functionality at the console – requires use of operating system specific modules.
    We can’t use the built-in `input()` function, because that waits for the user
    to press *Enter* before giving us a string. To implement this on Windows we need
    to use functionality from the Windows-only `msvcrt` module, and on Linux and macOS
    we need to use functionality from the Unix-only `tty` and `termios` modules, in
    addition to the `sys` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is quite instructive as it demonstrates many Python language features
    including `import` and `def` as *statements*, as opposed to merely declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Recall that top-level module code is executed on first import. Within the first
    try-block we attempt to `import msvcrt`, the Microsoft Visual C Runtime. If this
    succeeds, we then proceed to define a function `getkey()` which delegates to the
    `msvcrt.getch()` function. Even though we’re inside a try-block at this point
    the function will be declared at the current scope, which is the module scope.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, the import of `msvcrt` fails, because we’re not running on Windows,
    an `ImportError` will be raised and execution will transfer to the except-block.
    This is a case of an error being silenced explicitly, because we’re going to attempt
    an alternative course of action in the exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: Within the except-block we import three modules needed for a `getkey()` implementation
    on Unix-like systems and then proceed to the alternative definition of `getkey()`
    which again binds the function implementation to a name in the module scope.
  prefs: []
  type: TYPE_NORMAL
- en: This Unix implementation of `getkey()` uses a `try` .. `finally` construct to
    restore various terminal attributes after the terminal has been put into raw mode
    for the purposes of reading a single character.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that our program is running on a system that is neither Windows
    nor Unix-like, the `import tty` statement will raise a second `ImportError`. This
    time we make no attempt to intercept this exception; we allow it to propagate
    to our caller – which is whatever attempted to import this `keypress` module.
    We know how to signal this error, but not how to handle it, so we defer that decision
    to our caller. The error will not pass silently.
  prefs: []
  type: TYPE_NORMAL
- en: If the caller has more knowledge or alternative tactics available, it can in
    turn intercept this exception and take appropriate action, perhaps degrading to
    using Python’s `input()` built-in function and giving a different message to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The raising of an exception interrupts normal program flow and transfers control
    to an exception handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handlers are defined using the `try` .. `except` construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try` blocks define a context in which exceptions can be detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corresponding `except` blocks define handlers for specific types of exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses exceptions pervasively and many built-in language features depend
    on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`except` blocks can capture an exception object, which is often of a standard
    type such as `ValueError`, `KeyError` or `IndexError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmer errors such as `IndentationError` and `SyntaxError` should not normally
    be handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptional conditions can be signaled using the `raise` keyword which accepts
    a single parameter of an exception object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`raise` without an argument within an `except` block re-raises the exception
    which is currently being processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We tend not to routinely check for `TypeErrors`. To do so would negate the flexibility
    afforded to us by Python’s dynamic type system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception objects can be converted to strings using the `str()` constructor
    for the purposes of printing message payloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exceptions thrown by a function form part of it’s API and should be appropriately
    documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When raising exceptions prefer to use the most appropriate built-in exception
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean-up and restorative actions can be performed using the `try` .. `finally`
    construct which may optionally be used in conjunction with `except` blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the way we saw that:'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `print()` function can be redirected to `stderr` using the
    optional `file` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python supports the logical operators `and` and `or` for combining boolean expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return codes are too easily ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform specific actions can be implemented using an Easier to Ask Forgiveness
    than Permission approach facilitated by intercepting `ImportErrors` and providing
    alternative implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
