- en: Chapter 6. Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about dependency injection that teaches you how to decouple
    the requirements of an application and how to create a consistent source of data
    as a service. You will learn about Injector and Provider classes. We will also
    discuss Injectable decorator that is required for the creation of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The injector and provider classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injectable and inject decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating data services for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is dependency injection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, I will talk about the concept of **dependency injection** with some concrete
    examples that will hopefully demonstrate the problems it tries to solve and the
    benefits it gives to the developer. Angular is mostly based on dependency injection,
    which you may or may not be familiar with. If you already know the concept of
    dependency injection, you can safely skip this chapter and just read the next
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is probably one of the most famous design patterns I know,
    and you have probably already used it. I think it is one of the most difficult
    ones to explain well, partly due to the nonsense examples used in most introductions
    to dependency injection. I have tried to come up with examples that fit the Angular
    world better.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine, you start your own business, and tend to travel a lot by air, so you
    need to arrange flights. You are always booking the flight yourself using the
    phone number of the airline agency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus your typical travel planning routine might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide the destination, and desired arrival date and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call up the airline agency and convey the necessary information to obtain a
    flight booking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick up the tickets and be on your way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you suddenly change the preferred agency, and its contact mechanisms,
    you would be subject to the following relearning scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The new agency, and its new contact mechanisms (say the new agency offers Internet
    based services and the way to make the bookings is over the Internet instead of
    over the phone)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The typical conversational sequence through which the necessary bookings get
    done (data instead of voice)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to adjust yourself to the new scenario. It could lead to a substantial
    amount of time spent on the readjustment process.
  prefs: []
  type: TYPE_NORMAL
- en: Assume your business is growing and you get a secretary in the company, so whenever
    you needed to travel, you send an email to him or her to just state the destination,
    desired arrival date and time. The flight reservations are made for you and the
    tickets get delivered to you.
  prefs: []
  type: TYPE_NORMAL
- en: Now if the preferred agency gets changed, the secretary would become aware of
    the change, and would perhaps readjust his or her workflow to be able to communicate
    with the agency. However, you would have no relearning required. You still continue
    to follow the same protocol as before, since the secretary makes all the necessary
    adaptation in a manner that means you do not need to do anything differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the scenarios, you are the client and are dependent upon the services
    provided by the agency. However, the second scenario has a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to know the contact point of the agency—the secretary does it
    for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to know the exact conversational sequence by which the agency
    conducts its activities via voice, email, website, and so on, as you are aware
    of a particular standardized conversational series with the secretary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services you are dependent upon are provided to you in a manner that you
    do not need to readjust should the service provider change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is dependency injection in *real life* .
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both, the Angular and custom components we used in our project are a part of
    a set of collaborating components. They depend upon each other to complete their
    intended purpose, and they need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: Which components to communicate with?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to locate them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to communicate with them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the way to access is changed, such changes can potentially require the
    source of a lot of components to be modified. Here are the plausible solutions
    we can use to prevent dramatic changes of components:'
  prefs: []
  type: TYPE_NORMAL
- en: We can embed the logic of location and instantiation as part of our usual logic
    of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create the *external* piece of code to assume the responsibility of location
    and instantiation and supply the references when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can look at the last solution as the  *secretary* from our *real life* example.
    We don't need to change the code of components when the way to locate any external
    dependency changes. This solution is the implementation of dependency injection,
    where an *external* piece of code is part of Angular Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The use of dependency injection requires the declaration of the components and
    lets the framework work out of the complexities of instantiation, initialization,
    sequencing, and supplying the references as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing of a dependency into a dependent object that would use it is a dependency
    injection. A component can accept a dependency in at least three common ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor injection** : In this, the dependencies are provided through
    a class constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setter injection** : In this, the injector utilizes the component exposed
    setter methods to inject the dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface injection** : In this, the dependency provides a method that will
    inject the dependency into any component passed to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method requires the component to provide a parameter in a constructor
    for the dependency. We injected the `Router` instance in the code of the `ProductGridService`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Constructor injection is the most preferable method and can be used to ensure
    the component is always in a valid state, but its lacks the flexibility of being
    able to change its dependencies later.
  prefs: []
  type: TYPE_NORMAL
- en: Other injection methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setter and interface methods are not implemented in the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Components versus services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular 2 distinguishes the code of a web application on:'
  prefs: []
  type: TYPE_NORMAL
- en: The components that represent the visual part
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reusable data services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data service is a simple class that provides methods for returning or updating
    some data.
  prefs: []
  type: TYPE_NORMAL
- en: ReflectiveInjector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `ReflectiveInjector` is an injection container that we use as a replacement
    for a `new` operator we are using to resolve the constructor dependencies automatically.
    When code in an application asks about dependencies in the constructor, the `ReflectiveInjector`
    resolves them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With a `resolveAndCreate` method, the `ReflectiveInjector` creates an instance
    of `Injector` . We are passing the array of service providers into the injector
    to configure it, or it won't know how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: With an `Injector` , creating a `ProductGridService` is very easy, because it
    takes full responsibility of providing and injecting the `ActivatedRoute` into
    the `ProductGridService` .
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about why we imported and applied the `Injectable` decorator to the
    class?
  prefs: []
  type: TYPE_NORMAL
- en: Injectable decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create multiple types in the application for particular needs. Some of them
    may have dependencies to others. We must mark any type available for an injector
    with an `Injectable` decorator. Injector uses class constructor metadata to get
    the parameter types and determine dependent types for instantiation and injection.
    Any dependent type must be marked with `Injectable` decorator or injector will
    report an error when trying to instantiate it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Add `@Injectable()` to every service class to prevent dependency injection errors.
  prefs: []
  type: TYPE_NORMAL
- en: We must import and apply the `Injectable` decorator to all class of our services
    explicitly to make them available to an injector for instantiation. Without this
    decorator, the Angular doesn't know about the existence of those types.
  prefs: []
  type: TYPE_NORMAL
- en: Inject decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned, the Injector uses a class constructor metadata to determine
    dependent types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Injector uses the TypeScript generated metadata to inject the instance of `ActivatedRoute`
    type into the constructor. For injecting the TypeScript primitives such as `string`
    , `boolean` , or array we should define and use the Opaque Token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the `APP_TITLE` token defined we can use it in the registration of
    dependency provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `@Inject` decorator when we inject the application title into any
    constructor of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about tokens shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Optional decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In cases when class has optional dependencies, we can use the `@Optional` decorator
    to mark the constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I added the conditional statement into the code above because I expected that
    `config` property will equal `null` .
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the injector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, I used the `resolveAndCreate` method of the `ReflectiveInjector`
    to create `Injector` , but in real life, it''s not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Angular framework creates an application-wide injector for us during the
    Bootstrap of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We must configure the injector via registering the providers that create the
    services our application requires. We can do that in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a provider within an `NgModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register a provider in an `AppComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one is best? The services injected into the `AppModule` are widely available
    in the entire application and can be injected into lazy-loading modules and their
    components. The services injected into the `AppComponent` are available only to
    this component and its children and are not available to lazy-loading modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Register application-wide providers in the root `AppModule` , not in the `AppComponent`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure injector with alternative providers under the right circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: Provided an object behaves or looks like the original one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a substitute class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a factory function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example for `AppModule` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a short-hand expression when registering the provider in the injector.
    Angular transforms it into the following verbose format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `provide` property in the first place is the *token* that serves as the
    key for:'
  prefs: []
  type: TYPE_NORMAL
- en: Locating a dependency value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering the provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second property, `useClass` , is a definition object similar to many other
    *use* things such `useValue` , `useExisting` , and others. and tells the framework
    how to create the dependency. With the help of the *use* definitions, we can quickly
    switch implementations, define constants and factory functions. Let's look at
    all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Class providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time we will utilize the `useClass` definition to ask the different
    class to provide the service. We can create our own `BetterRouter` class as an
    extension of the original one and register it such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The injector knows how to build `BetterRouter` and will sort it out.
  prefs: []
  type: TYPE_NORMAL
- en: Aliased class providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In scenarios when we need to use many providers of the same singleton, we can
    use the `useExisting` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following example where `useExisting` helps organize mock requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code below demonstrates how to use the `MockBackend` instead of the real
    one, making AJAX requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful place for `useExisting` is in providing multiple values of custom
    pipes, custom directives, or custom validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the `multi` option, it is possible to add the `CustomValidatorDirective`
    to the default collections to have it available globally in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Value providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we need to use a configuration object, string or function in our
    application is not always an instance of a class. Here the interface defines the
    structure of configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can register the ready-made objects with the `useValue` definition. There
    is no `Config` class, so we cannot use it for the token. Instead, we can use a
    string literal to register and resolve dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can inject it into any constructor with the help of `@Inject` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, using string tokens opens up a potential for naming collisions.
    Angular comes to the rescue and provides an elegant solution with `Opaque Token`
    for non-class dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are registering the `CUSTOM_CONFIG` in the injector with the value provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inject it into any constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Multiple values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the help of the `multi` option it is possible to add other values to the
    same binding later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere in the code we can get multiple values of the `languages` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Factory providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In cases when we need to create the dependent value dynamically based on information
    changed at any moment after the Bootstrap has happened, we can apply the `useFactory`
     definition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we use `SecurityService` to authorize the user.`CategoryService`
    must know facts about the user. The authorization can change during the user session
    because he or she can log in and log out at any moment many times. The direct
    injection `SecurityService` into `CategoryService` creates a precedent to inject
    it into all services of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is quite neat, use the primitive Boolean `authorization` property
    instead of `SecurityService` to control `CategoryService` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The authorized property will update dynamically, so we cannot use a value provider,
    but we have to take over the creation of a new instance of the `CategoryService`
    with a factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the factory provider we inject the `SecurityService` along with the factory
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The hierarchy of injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 1 has only one injector across the application, and it manages the creation
    and resolving of all dependencies quite nicely. Every registered dependency becomes
    a singleton, so only one instance of it is available across the application. That
    solution has a side effect where you need to have more than one instance of the
    same dependency injecting into different parts of the application. Because the
    Angular 2 application is a tree of components, the framework has a **hierarchical
    dependency injection** system—the tree of injectors exists in parallel to the
    component tree of the application. Every component has an injector of its own
    or shared with other components at the same level in the tree. When the component
    at the bottom of the tree requests a dependency, Angular tries to find it with
    a provider registered in that component's injector. If the provider doesn't exist
    on this level, the injector passes the request to its parent injector and so on
    until finding the injector that can handle the request. Angular throws an exception
    if it runs out of ancestors. This solution helps us to create different instances
    of the same dependency on various levels and components. The particular service
    instance is still a singleton, but only in the scope of the host component instance
    and its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal, create folder `ecommerce` and move in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the contents of the project from the folder `chapter_6/1.ecommerce-seed`
    into the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following script to install `npm` modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the TypeScript watcher and lite server with next command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This script opens the web browser and navigates to the welcome page of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Category service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned in [Chapter 5](text00047.html#page "Chapter 5. Routing") , *Routing*
    , about the necessity to decouple the data from the presentation logic when implementing
    SPA. I partially realized it in the category and product views. The `CategoryListComponent`
    and `WelcomeComponent` use category returns from the `getCategories` function.
    Right now it is not suffering, but when we start getting and updating data from
    the server, we will need more functions. Better hide the implementation detail
    inside the single reusable data service class to use it in multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refactor the category data acquisition business to a single service that
    provides categories, and share that service with all components that need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `category.ts`  to `category.service.ts` to follow a name convention
    in which we spell the name of a service in lowercase followed by `.service` .
    If the service name is multi-word, we will spell the base filename in lower `dash-case`
    . Add an import statement to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the `CategoryService` class and move the `categories` variable,
    `getCategories` and `getCategory` functions inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add `this` to all references to `categories` property.
  prefs: []
  type: TYPE_NORMAL
- en: Injector provider for category service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must register a service provider with the injector to tell Angular how to
    create the service. The best place to do that is in the `providers` property of
    a `NgModule` . We need only one instance of categories per application, so when
    we import the `CategoryModule` into the `AppModule` , Angular will register and
    create the singleton from the `CategoryService` class available across the whole
    application. Open the `category.module.ts` file, import the `CategoryService`
    and change `@NgModule` decorator with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Move to your web browser and open the browser console. We get a full bunch
    of issues, mostly about the wrong name of file `category.ts` was renamed to `category.service.ts`
    . We can easily fix that issue. Another problem is the use of the functions `getCategory`
    and `getCategories` . To fix that issue we need to import the `CategoryService`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And inject it into constructors in all the necessary places such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Move initialization of all variables inside the constructor for now, similar
    to `categories` in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Product service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rename the `product.ts`  to `product.service.ts` . Create the class `ProductService`
    and move the `products` variable, `getProducts` and `getProduct` functions into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Fix the `import` in all classes to have references on old methods.
  prefs: []
  type: TYPE_NORMAL
- en: Injector provider for product service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We follow the same procedure for `ProductService` to register a service provider.
    Because we need only one instance of service per application, we can register
    it in the `ProductModule` . Open the `product.module.ts` file, import the `ProductService`
    and change the `@NgModule` decorator with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the application to see all of your products and categories again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injector provider for product service](Image00105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_6/2.ecommerce-di` .
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A shopping cart is a piece of software that acts as an online store's catalog
    and allows users to select items for eventual purchase. It's known as a shopping
    basket. A shopping cart (or basket) allows a user to collect items while browsing
    an online catalog of products. The user should click on the **Buy Now** button
    to add the selected item to the cart. The total amount and number of items in
    the cart presents in the navigation bar component. The user is able to move to
    a checkout or view the cart to manage the number of purchased items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cart must store the items the user puts in the cart. The items should be:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetchable to be able to display the cart content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updatable to be able to change the quantity of an item in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in mind, let''s first create the basic cart functionality: adding,
    updating, and deleting items and defining a barebones item class and walk through
    the code usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the `cart` folder and `cart.service.ts` file inside. We will keep
    the model definition implemented as the `Cart` and the `CartItem` inside that
    file as well as the `CartService` .
  prefs: []
  type: TYPE_NORMAL
- en: The Cart model and CartItem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning, the `Cart` class needs an internal array for storing all
    the `items` in the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it must `count` the number and keep the `amount` of all items. The `CartItem`
    is an interface defining the structure of data the cart can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The CartService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CartService` keeps the `cart` instance to make it available across the
    whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addProduct` method should add items to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The method takes one argument of type `Product` and tries to find the item containing
    the same one. The method needs to increment the number of products and increase
    the amount of the found cart item. Otherwise, it creates the new `CartItem` instance
    and assigns the product to it. After all, it is growing the total number of items
    and amount in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `removeProduct` method of the class can be used to remove the product
    quickly from the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The method takes one argument of product type and tries to find the item containing
    the same one. The method needs to decrement the number of goods associated with
    this item cart. It removes the cart item which includes no one product. In the
    end, it reduces the total number of items and amount in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method `removeItem` removes the particular item and reduces the total number
    of items and amount in the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following private method `findItem` helps to find `CartItem` by `Product`
    id:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The last private method, `remove` , decreases the number of items in the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Cart menu component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key aspect that I find must present on the shopping cart design is that,
    at first glance, the user should be able to find out how many items there are
    in the shopping cart. You need to keep your user informed about how many items
    are in the shopping cart so that users are aware of what they have added to the
    cart without having to use the dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure shoppers can easily see the items in their cart and that they appear
    above the fold rather than on another page.
  prefs: []
  type: TYPE_NORMAL
- en: That is quite a significant UX design pattern. If you keep the shopping cart
    content somewhere in the sidebar or near the top right of your pages, you are
    removing extra steps in the checkout process and making it easier for shoppers
    to move throughout the site and keep track of items and order totals the whole
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Cart menu component](Image00106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this in mind, let''s create the `cart-menu.component.ts` and  `cart-menu.component.html`
    . Copy and paste the following code into the `cart-menu.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the local `cart` variable is to represent on view the content
    and update it with changes that happen after the user adds or removes the product
    to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We display the total number of items and amount in the label of the drop-down
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the currency pipe with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the ISO 4217 currency code, such as `USD` for the US
    dollar and `EUR` for the euro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* At the second place is a Boolean indicating whether to use the currency symbol
    (example `$` ) or the currency code (example `USD` ) in the output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the last place we add the digit info in the next format: `minIntegerDigits.minFractionDigits-maxFractionDigits`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend using this pipe here and in all other places where you need to display
    the amount of currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We display the contents of the cart inside a Bootstrap 4 table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the menu, we display the total amount and two buttons to navigate
    to `Cart` and `Checkout` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Cart module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add the `CartManuComponent` and `Cart Service` into the `CartModule`
    to make them easily accessible in the entire application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the `CartModule` into the `AppModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Update the Navbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `navbar.component.html` and find the cart placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to look more elegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Update the Cart via Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And the last thing we must to do is inject the `CartService` into the `ProductGrid`
    component and start to listen to `addToCart` events. In the method with the same
    name we call the `addProduct` of `CartService` to add the selected goodie into
    the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to click on **Buy Now** on different products and see changes happen
    in the navigation bar. Click the dropdown to display the shopping cart content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Update the Cart via Service](Image00107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_6/3.ecommerce-cart` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now be familiar with the dependency injection that Angular relies heavily
    on. As we've seen, we split our Angular code into visual components and services.
    Each of them depend upon one another, and dependency injection provides referential
    transparency. Dependency injection allows us to tell Angular what services our
    visual components depend on, and the framework will resolve these for us.
  prefs: []
  type: TYPE_NORMAL
- en: We created the classes for products and categories to hide the functionality
    into reusable services. Plus, we created the shopping cart component and service
    and wired the last to products, so the user can add the products to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](text00066.html#page "Chapter 7. Working with Forms") , *Working
    with Forms* , we will talk about how to use Angular 2 directives related to form
    creation and how to link a code based form component to the HTML form. Plus we
    will continue to build the project we started to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
