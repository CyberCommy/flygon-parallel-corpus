- en: '*Chapter 1*: Getting the Necessary Tools and Writing Our First Linux Programs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll install the necessary tools on our Linux system, such
    as **GCC**, **GNU Make**, **GDB**, and **Valgrind**. We'll also try them out and
    see how they work. Knowing how to use these tools is the key to being a fast and
    efficient developer. We'll then write our first programs—Linux style. By understanding
    the different parts of a **C program**, you can easily interact with the rest
    of the system in a best practice manner. After that, we'll learn how to use the
    built-in manual pages (**man pages** for short) to look up **commands**, **libraries**,
    and **system calls**—a skill that we'll need a lot throughout this book. Knowing
    how to look up things in the relevant built-in manual page is often much faster—and
    more precise—than searching the internet for answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing GCC and GNU Make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing GDB and Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple C program for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a program that parses command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up information in the built-in manual pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the manual for information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need a computer with Linux already set up. It doesn't
    matter if it's a local machine or a remote machine. The particular distribution
    you use doesn't matter much either. We'll look at how to install the necessary
    programs in **Debian**-based distributions, as well as **Fedora**-based distributions.
    Most of the major Linux distributions are either Debian-based or Fedora-based.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also be using a `vi` and `nano`, and they are available pretty much everywhere.
    We won't cover how to use a text editor in this book, though.
  prefs: []
  type: TYPE_NORMAL
- en: The C files for this chapter can be downloaded from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques](https://github.com/PacktPublishing/Linux-System-Programming-Techniques),
    under the `ch1` directory. The filenames on GitHub correspond to the filenames
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also clone the entire repository to your computer. The files for this
    chapter are in the `ch1` Directory. You clone the repository with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you don't have Git installed on your computer, you will need to follow some
    installation instructions, depending on your distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3wdEoV6](https://bit.ly/3wdEoV6)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git to download the code repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Git is only necessary if you want to clone (download) the entire
    code repository for this book to your computer. The steps listed here assume that
    your user has `sudo` privileges. If this isn't the case, you can run `su` first
    to switch to the root user and skip `sudo` (assuming you know the root password).
  prefs: []
  type: TYPE_NORMAL
- en: Debian-based distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These instructions work for most Debian-based distributions, such as Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the repository cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install Git using `apt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fedora-based distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This instruction work for all newer Fedora-based distributions, such as CentOS
    and Red Hat (if you are using an old version, you might need to replace `dnf`
    with `yum`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Git package using `dnf`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing GCC and GNU Make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will install the essential tools that we'll need throughout
    this book; namely, GCC, the compiler. It's the **compiler** that turns the **C
    source code** into a **binary program** that we can run on the system. All the
    C code that we write will need to be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also install GNU Make, a tool that we'll be using later on to automate
    how projects containing more than one source file are compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are installing software on the system, we'll need to be using either
    the `sudo` privileges. I will be using `sudo` in this recipe, but if you are on
    a system without `sudo`, you can switch to the root user with `su` before entering
    the commands (and then leave out `sudo`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be installing what is called a meta-package or a group, a package that
    contains a collection of other packages. This meta-package includes both GCC,
    GNU Make, several manual pages, and other programs and libraries, which are nice
    to have when we're developing.
  prefs: []
  type: TYPE_NORMAL
- en: Debian-based systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These steps work for all Debian-based systems, such as Debian, **Ubuntu**,
    and **Linux Mint**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the repository cache to get the latest version in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `build-essential` package, and answer `y` when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Fedora-based systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This works for all Fedora-based systems, such as Fedora, **CentOS**, and **Red
    Hat**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a software group called *Development Tools*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Verify the installation (both Debian and Fedora)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These steps are the same for both Debian and Fedora:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the installation by listing the versions installed. Note that the exact
    versions will differ from system to system; this is normal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to try out the GCC compiler by compiling a minimal C program.
    Please type the source code into an editor and save it as `first-example.c`. The
    program will print the text "Hello, world!" on the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile it using GCC. This command produces a file called `a.out`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to run the program. To run a program in Linux that isn''t in
    the usual directories for binaries (`/bin`, `/sbin`, `/usr/bin,` and so on), you
    need to type the special`./` sequence before the filename. This executes the program
    from the current path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, recompile the program. This time, we will specify a name for the program
    with the `-o` option (`-o` for *output*). This time, the program file will have
    the name `first-example`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun the program, this time with the new name, `first-example`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to compile it using Make instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, rerun the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing software on the system always requires root privileges, either via
    a regular root user or via `sudo`. Ubuntu, for example, uses `sudo` and has the
    regular root user disabled. Debian, on the other hand, doesn't use `sudo` at all
    in the default installation. To use it, you have to set it up yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Debian and Ubuntu use the `apt-get update` command before installing the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora-based systems use the `dnf` on newer versions. If you are using an older
    version, you might need to replace `dnf` with `yum`.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we installed a group of packages that contain the utilities,
    manual pages, and compilers that we'll need throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation was complete, before trying to compile anything, we listed
    the GCC version and Make version.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we compiled a straightforward C program, first using GCC directly and
    then using Make. The first example with GCC produced a program with the name `a.out`,
    which stands for *assembler output*. That name has a long history and goes back
    to the first edition of Unix in 1971\. Even though the file format, `a.out`, isn't
    used anymore, the name still lives on today.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we specified a program name with the `-o` option, where `-o` stands for
    *output*. This produces a program with a name of our choosing. We gave the program
    the name `first-example`.
  prefs: []
  type: TYPE_NORMAL
- en: When we used Make, we didn't need to type in the filename of the source code.
    We only wrote the name we wanted for the binary program produced by the compiler.
    The Make program is smart enough to figure out that the source code has the same
    filename but that it ends with `.c`.
  prefs: []
  type: TYPE_NORMAL
- en: When we executed the program, we ran it as `./first-example`. The `./` sequence
    tells the shell that we want to run the program from the current directory. If
    we leave out `./`, it won't `$PATH` variable—usually `/bin`, `/usr/bin`, `/sbin`,
    and `/usr/sbin`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GDB and Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB and Valgrind are two useful **debugging** tools that we'll use later on
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: GDB is the GNU debugger, a tool that we can use to step through a program and
    see what's happening inside it. We can watch over variables, see how they change
    during runtime, set breakpoints where we want the program to pause, and even change
    variables. **Bugs** are inevitable, but with GDB, we can find these bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind is also a tool we can use to find bugs, though it was made explicitly
    for finding **memory leaks**. Memory leaks can be challenging to find without
    a program such as Valgrind. Your program might work as expected for weeks, but
    then suddenly, things may start to go wrong. That's probably a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use these tools will make you a better developer and your programs
    more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will be installing software here as well, we'll need to execute these
    commands with root privileges. If our system has a traditional root user, we can
    use that by switching to root with `su`. If we are on a system with `sudo`, and
    our regular user has administrative rights, you can use `sudo` to execute the
    commands instead. Here, I'll be using `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using Debian or Ubuntu, you'll need to use the `apt-get` tool. If
    you, on the other hand, are using a Fedora-based distribution, you'll need to
    use the `dnf` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Debian-based systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These steps are for Debian, Ubuntu, and Linux Mint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the repository cache before installing the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install both GDB and Valgrind using `apt-get`. Answer `y` when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Fedora-based systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This step is for all Fedora-based systems, such as CentOS and Red Hat. If you
    are using an older system, you might need to replace `dnf` with `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install both GDB and Valgrind using `dnf`. Answer `y` when prompted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This step is the same for both Debian-based and Fedora-based systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the installation of GDB and Valgrind:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDB and Valgrind are two debugging tools that are not included in the group
    packages we installed in the previous recipe. That's why we need to install them
    as separate steps. The tool for installing software on Debian-based distributions
    is `apt-get`, while for Fedora, it's `dnf`. Since we are installing software on
    the system, we need to execute these commands with root privileges. That's why
    we needed to use `sudo`. Remember that if your user—or system—doesn't use `sudo`,
    you can use `su` to become root.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we verified the installations by listing the versions that were installed.
    The exact version can differ from system to system, though.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the versions differ is that every Linux distribution has its
    own software repository, and every Linux distribution maintains its own software
    versions as "latest". This means that the latest version of a program in a particular
    Linux distribution isn't necessarily the newest version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple C program for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be building a small **C program** that sums up the values
    that are passed to the program as **arguments**. The C program will contain some
    essential elements we need to know about when programming for Linux. These elements
    are **return values**, arguments, and **help texts**. As we progress through this
    book, these elements will show up, time and time again, along with some new ones
    that we'll learn about along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering these elements is the first step to writing great software for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing you'll need for this recipe is the C source code, `sum.c`, and
    the GCC compiler. You can choose to type the code in yourself or download it from
    GitHub. Typing it in yourself gives you the benefit of learning how to write it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to write your first program in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor and type in the following code, naming the file `sum.c`.
    The program will sum up all the numbers that are entered as arguments into the
    program. The arguments to the program are contained in the `argv` array. To convert
    the arguments into integers, we can use the `atoi()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to compile the source code using GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. Don''t forget`./` before the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the **exit code** from the program before we do anything
    else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun the program, this time with some **integers** that the program
    can sum up for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we check the exit code from the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by exploring the basics of the code so that we understand what the
    different parts do and why they matter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, we've included a `stdio.h`. This file is needed for `printf()`.
    The name *stdio* stands for `printf()` prints characters on the screen, it's classed
    as a *stdio* function.
  prefs: []
  type: TYPE_NORMAL
- en: The other header file we included is `stdlib.h`, which stands for `atoi()` function,
    which we can use to convert **strings** or **characters** into integers.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we have a `printhelp()`. There is nothing particular to say about
    this; it's good C practice to keep the `main()`, and the function prototypes at
    the very beginning. The function prototype tells the rest of the program which
    argument the function takes, as well as what type of value it returns.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we declared the `main()` `int main(int argc, char *argv[])`.
  prefs: []
  type: TYPE_NORMAL
- en: The two variables, `argc` and `argv`, have special meanings. The first, `argc`,
    is an integer and contains the number of arguments that were passed to the program.
    It will always be at least 1, even if no arguments are passed to the program;
    the very first argument is the name of the program itself.
  prefs: []
  type: TYPE_NORMAL
- en: The next variable—or `argv`, which contains all the arguments that were passed
    to the program at the `argv[0]`, holds the name of the program—that is, the command
    line by which the program was executed. If the program was executed as `./sum`,
    then `argv[0]` contains the string `./sum`. If the program was executed as `/home/jack/sum`,
    then `argv[0]` contains the string `/home/jack/sum`.
  prefs: []
  type: TYPE_NORMAL
- en: It is this argument—or rather the program name—that we pass to the `printhelp()`
    function so that it prints the name of the program, along with the help text.
    It's good practice to do this is Linux and Unix environments.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we performed a simple `printhelp()` function that we built. Directly
    after that, we `return` from `main()` with the code 1, indicating to the `main()`
    using `return`, that code is sent to the shell and the program exits. These codes
    have special meanings, which we'll explore in more depth later in this book. Simply
    put, 0 indicates that everything is alright, while anything other than 0 is an
    error code. Using return values in Linux is a must; that's how other programs—and
    the shell—get notified of how the execution went.
  prefs: []
  type: TYPE_NORMAL
- en: A bit further down, we have the `for()` `argc` to walk through the list of arguments.
    We started at 1 with `i=1`. We can't begin with 0 here, since index 0 in the `argv[]`
    array is the program name. Index 1 is the first argument; that is, the integer
    that we can pass to the program.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for()` loop, we have `sum = sum + atoi(argv[i]);`. The important
    part we'll focus on here is `atoi(argv[i])`. All the arguments that we give to
    the program via the command line are passed on as strings. To be able to do calculations
    on them, we need to convert them into integers, which the `atoi()` function does
    for us. The name `atoi()` stands for *to integer*.
  prefs: []
  type: TYPE_NORMAL
- en: Once the result has been printed on the screen with `printf()`, we `return`
    from main with 0, indicating everything is okay. When we return from `main()`,
    we return from the entire process to the shell; in other words, the **parent process**.
  prefs: []
  type: TYPE_NORMAL
- en: Execution and return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are executing programs outside the directories mentioned in the `$PATH`
    environment variable, we need to prepend the name of the file with `./`.
  prefs: []
  type: TYPE_NORMAL
- en: When the program finishes, it gives the return value to the shell, which, in
    turn, saves it to a variable called `?`. When another program ends, the variable
    is overwritten by the latest return value from that program. We print the value
    of the `echo`, a small utility that prints text and variables on the screen directly
    from the shell. To print environment variables, we need to put a `$` sign in front
    of the variable name, such as `$?`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three other similar functions to `atoi()`, called `atol()`, `atoll()`,
    and `atof()`. The following are short descriptions for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`atoi()` converts a string into an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atol()` converts a string into a long integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atoll()` converts a string into a long long integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atof()` converts a string into a floating-point number (of type double).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore the return values of other programs, you can execute
    programs such as `ls` with a directory that exists and print the variable with
    `echo $?`. Then, you can try to list a directory with `ls` that doesn't exist
    and print the value of `$?` again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We've touched on the subject of the `$PATH` environment variable a couple of
    times in this chapter. If you want to know what that variable contains, you can
    print it with `echo $PATH`. If you want to add a new directory to the `$PATH`
    variable temporarily, let's say `/home/jack/bin`, you can execute the `PATH=${PATH}:/home/jack/bin`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a program that parses command-line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a more advanced program—one that parses command-line
    `argc` and `argv`. We will use those variables here as well, but for options.
    Options are the hyphenated letters, such as `-a` or `-v`.
  prefs: []
  type: TYPE_NORMAL
- en: This program is similar to the previous one, with the difference that this program
    can both this; `-s` for "sum" and `-m` for "multiply."
  prefs: []
  type: TYPE_NORMAL
- en: Almost all programs in Linux take different options. Knowing how to parse options
    to the programs you create is a must; that is how the user changes the behavior
    of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need is a text editor, the GCC compiler, and Make.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since this source code will be a bit longer, it will be broken up into three
    pieces. The entire code goes into the same file, though. The complete program
    can be downloaded from GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor, type in the following code, and name it `new-sum.c`. This
    first bit is pretty similar to the previous recipe, except for some extra variables
    and a **macro** at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, continue typing in the same file. This part is for actually parsing the
    command-line options, the calculations, and printing the result. We parse the
    options using `getopt()` and a `switch` statement. Notice that this time, we can
    also multiply the numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, continuing in the same file, add the `printhelp()` function at the
    bottom. This function prints a help message, sometimes called a *usage* message.
    This message is displayed either when the user uses the `-h` option or some form
    of error occurs, for example, when no arguments are given:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Save and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, it''s time to compile the program. This time, we''ll try using Make instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first bit is pretty similar to the previous recipe, except we have some
    more variables we `unistd.h`, which is required for the `getopt()` function, which
    we use to parse options to the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another new weird-looking part; that is, the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will cover this in great detail later on in this book. But for now, just
    know that it's a feature macro we use to adhere to the `getopt()`, something we
    will cover in detail in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The getopt() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step in this recipe—step two—is the exciting part. It is here that
    we parse the options using the `getopt()` function—which stands for *get options*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to use `getopt()` is to loop through the arguments in a `while` loop
    and using a `switch` statement to catch the options. Let''s take a closer look
    at the `while` loop and break it down into smaller pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `getopt()` function returns the actual letter of the option it parses. This
    means that the first bit, `opt = getopt`, saves the option to the `opt` variable,
    but only the actual letter. So, for example, `-h` is saved as `h`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the arguments that we must pass to the `getopt()` function, which
    is `argc` (the argument count), `argv` (the actual arguments), and, finally, the
    options that should be accepted (here `smh`, which is translated into `-s`, `-m`,
    and `-h`).
  prefs: []
  type: TYPE_NORMAL
- en: The last bit, `!= -1`, is for the `while` loop. When `getopt()` has no more
    options to return, it returns -1, indicating that it's done parsing options. That's
    when the `while` loop should end.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside the loop, we use a `switch` statement to perform specific actions for
    each option. Under each `case`, we perform the calculation and `break` out of
    that `case` when we're done. Just as in the previous recipe, we use `atoi()` to
    convert the argument strings into integers.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `h` case (the `-h` option, for help), we print the help message and
    return with code 0\. We asked for help, and hence it isn't an error. But below
    that, we have the default case, a case that is caught if no other option matches;
    that is, the user typed in an option that isn't accepted. This is indeed an error,
    so here, we return with code 1 instead, indicating an error.
  prefs: []
  type: TYPE_NORMAL
- en: The help message function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A help message should show the various options a program takes, its arguments,
    and a simple usage example.
  prefs: []
  type: TYPE_NORMAL
- en: With `printf()`, we can split long lines into multiple smaller lines in our
    code, just like we did here. The unique character sequence, `\n`, is a newline
    character. The line will break wherever this character is placed.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running the program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we compiled the program using Make instead. The Make utility,
    in turn, uses `cc`, which is just a symbolic link to `gcc`. Later in this book,
    we'll learn how to change the behavior of Make by writing rules in Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: We then tried the program. First, we ran it without any options or arguments,
    causing the program to exit with the help text (and a return value of 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then tried two options: `-s` to summarize all the integers and `-m` to multiply
    all the integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking up information in the built-in manual page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to look up information in the built-in manual
    pages. We will learn how we can look up everything from commands, system calls,
    and **standard library functions**. The manual pages are mighty once you get used
    to using them. Instead of searching the internet for answers, it's often quicker—and
    more accurate—to take a look in the manual.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the manual pages (library calls and system calls) are installed as part
    of the *build-essential* package for Debian and Ubuntu. In Fedora-based distributions
    such as CentOS, these are often already installed in the base system as part of
    a package called *man pages*. If you are missing some manual pages, make sure
    you have installed these packages. Take a look at the very first recipe in this
    chapter, on how to install packages, to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on a minimal or slim installation, the `man` command might not be
    installed. If that is the case, you need to install two packages with the distribution
    package manager. The package names are *man-db* for the `man` command (same on
    nearly all distributions) and *manpages* (in Debian-based systems), or *man-pages*
    (in Fedora-based systems) for the actual manual pages. On Debian-based systems,
    you also need to install the *build-essential* package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore the manual pages, step by step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `man ls` into a console. You'll see the manual page for the `ls` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll up and down the manual page, one line at a time, using either the *arrow*
    keys or the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down a full page (window) at a time by pressing the *spacebar*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll up a full page by pressing the letter *b*. Keep pressing *b* until you
    reach the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, press */* to open a search prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `human-readable` into the search prompt and press *Enter*. The manual page
    is now automatically scrolled forward to the first occurrence of that word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now press *n* to jump to the next occurrence of the word – if there
    is one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit the manual by pressing *q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Investigating the different sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, there are multiple manual pages with the same name but in different
    sections. Here, we will investigate those sections and learn how to specify which
    section we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `man printf` into the command prompt. What you will see is the manual page
    for the `printf` command, not the C function of the same name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit the manual by pressing *q*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, type `man 3 printf` into the console. This is the manual page of the `printf()`
    C function. `3` indicates section 3 of the manual. Look at the header of the manual
    page, and you'll see which section you are in right now. It should say **PRINTF(3)**
    at this very moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's list all the sections. Quit the manual page you are looking at and type
    `man man` into the console. Scroll down a bit until you find the table that lists
    all the sections. There, you will also find a short description of each section.
    As you can see, section 3 is for library calls, which is what `printf()` is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the manual for the `unlink()` system call by typing `man 2 unlink` into
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit the manual page and type `man unlink` into the console. This time, you
    will see the manual for the `unlink` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The manual always starts at section 1 and opens the first manual it finds. That's
    why you are getting the `printf` and `unlink` commands, instead of the C function
    and system call when we leave out the section number. It's always a good idea
    to take a look at the header of the manual page that opens up to verify that you
    are reading the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember from the previous recipe that I "just knew" that `getopt()` returns
    `-1` when there are no more options to parse? I didn''t; it''s all in the manual.
    Open up the manual for `getopt()` by typing in `man 3 getopt`. Scroll down to
    the *Return value* header. There, you can read all about what `getopt()` returns.
    Almost all manual pages that cover library functions and system calls have the
    following headings: Name, Synopsis, Description, Return value, Environment, Attributes,
    Conforming to, Notes, Example, and See also.'
  prefs: []
  type: TYPE_NORMAL
- en: The Synopsis heading lists the header files we need to include for the particular
    function. This is really useful since we can't remember every function and its
    corresponding header file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of useful information in the manual about the manual itself –
    `man man` – so at least skim through it. We will be using the manual pages a lot
    to look up information about library functions and system calls in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the manual for information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we don't know the exact name of a particular command, function, or system
    call, we can search all the manuals in the system for the correct one. In this
    recipe, we will learn how to use the `apropos` command to search the manual pages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same requirements apply here that applied for the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s search the manual for different words, narrowing our result for each
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: Type in `apropos directory`. A long list of manual pages will present itself.
    After each manual, there is a number inside parentheses. This number is the section
    that the manual page is located in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To narrow the search down to only section 3 (library calls), type in `apropos
    -s 3 directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's narrow down the search ever further. Type in `apropos -s 3 -a remove directory`.
    The `-a` option stands for *and*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `apropos` command searches the manual pages descriptions and keywords. When
    we narrowed down the search with `apropos -s 3 -a remove directory`, the `-a`
    option stands for *and*, indicating that both *remove* and *directory* must be
    present. If we leave out the -`a` option, it searches for both keywords instead,
    regardless of whether one or both of them is present.
  prefs: []
  type: TYPE_NORMAL
- en: There is more information about how `apropos` works in the manual page for it
    (`man apropos`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we just want to know what a particular command or function does, we can
    look up a short description of it using the `whatis` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
