- en: Getting Started with Python and IoT
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Python和IoT
- en: In [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml), *Setting Up Your
    Development Environment*, we went through the essentials of the Python ecosystem,
    virtual environments, and package management and set up your Raspberry Pi for
    development and GPIO interfacing. In this chapter, we will begin our journey in
    Python and IoT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)中，*设置您的开发环境*，我们介绍了Python生态系统、虚拟环境和软件包管理的基本知识，并为您的树莓派进行了开发和GPIO接口设置。在本章中，我们将开始我们的Python和IoT之旅。
- en: What we cover in this chapter will lay the foundations and give us a working
    point of reference for the more advanced content that we'll cover in later chapters.
    We will learn to create a simple electrical circuit with a button, resistor, and
    LED (or light-emitting diode) and explore alternative ways to interact with the
    button and LED with Python. We will then proceed to create and discuss a complete
    end-to-end IoT program to control the LED over the internet and complete this
    chapter by looking at ways that you can extend the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的内容将奠定基础，并为我们在后续章节中将要涵盖的更高级内容提供一个工作参考点。我们将学习如何使用按钮、电阻和LED（或发光二极管）创建一个简单的电路，并探索使用Python与按钮和LED交互的替代方法。然后，我们将继续创建和讨论一个完整的端到端IoT程序，以控制LED通过互联网，并通过查看您可以扩展程序的方式来完成本章。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a breadboard prototype circuit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个面包板原型电路
- en: Reading an electronic schematic diagram
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读电子原理图
- en: Exploring two ways to flash a LED in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索两种在Python中闪烁LED的方法
- en: Exploring two ways to integrate a push button in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索两种在Python中集成按钮的方法
- en: Creating your first IoT program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个IoT程序
- en: Extending your IoT program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的IoT程序
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter and throughout this book, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章和整本书的练习，您将需要以下内容：
- en: Raspberry Pi 4 Model B. A 1 GB RAM version will be adequate to run our examples. If
    you are working directly on your Raspberry Pi versus a **Secure Shell** (**SSH**)
    session; for example, more RAM is recommended to improve the Raspbian Desktop
    experience and responsiveness.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B型。1 GB RAM版本足以运行我们的示例。如果您直接在树莓派上工作而不是通过SSH会话；例如，更多的RAM建议以改善Raspbian桌面体验和响应能力。
- en: You will need Raspbian OS Buster (with desktop and recommended software).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要Raspbian OS Buster（带桌面和推荐软件）。
- en: You will need a minimum of Python version 3.5.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要至少Python版本3.5。
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B, Raspberry Pi Zero W, or a different version of Raspbian
    OS as long as your Python version is 3.5 or higher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望代码示例应该在不修改的情况下在树莓派3型B、树莓派Zero W或不同版本的Raspbian OS上工作，只要您的Python版本是3.5或更高。
- en: You will find this chapter's source code in the `chapter02` folder in the GitHub
    repository available at the following URL: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在以下URL提供的GitHub存储库中的`chapter02`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令来设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**GPIOZero**: The GPIOZero GPIO library ([https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOZero**：GPIOZero GPIO库（[https://pypi.org/project/gpiozero](https://pypi.org/project/gpiozero)）'
- en: '**PiGPIO**:The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Requests**:A high-level Python library for making HTTP requests ([https://pypi.org/project/requests](https://pypi.org/project/requests))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Requests**：用于发出HTTP请求的高级Python库（[https://pypi.org/project/requests](https://pypi.org/project/requests)）'
- en: 'We are going to require a few physical electronic components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些物理电子元件：
- en: 1 x 5 mm red LED
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 5毫米红色LED
- en: '1 x 200 Ω resistor: Its color bands will be red, black, brown, and then gold
    or silver'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 200Ω电阻：其色带将是红色、黑色、棕色，然后是金色或银色
- en: Momentary push button (**Single Pole Single Throw**—**SPST**)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瞬时按钮（单极单刀开关-SPST）
- en: A breadboard
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Male-to-female and male-to-male jumper cables (sometimes called Dupont cables)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母对公和公对公跳线（有时称为杜邦线）
- en: You will find a complete parts list cataloging all of the electrical components
    required for every chapter in the *Preface*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*前言*中找到一个完整的零件清单，其中列出了每一章所需的所有电子元件。
- en: When you have your electronic components ready, we can proceed and arrange them
    on your breadboard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好您的电子元件后，我们可以继续并在您的面包板上安排它们。
- en: Creating a breadboard prototype circuit
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个面包板原型电路
- en: Throughout this book, we will be building many electrical circuits, and we will
    do this using an electronic breadboard. In the initial chapters, I will present
    many of the circuits with both a breadboard layout similar to that illustrated
    toward the end of this section in *Figure 2.7* and with a schematic diagram as
    shown in *Figure 2.8**.*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将建立许多电路，并将使用电子面包板进行。在最初的章节中，我将使用类似于本节末尾所示的面包板布局以及如图2.8所示的原理图来呈现许多电路。
- en: As we progress through this book and you gain more experience building breadboard
    circuits, I will cease with the breadboard layouts for the simpler circuits; however,
    I will still present them for the more complex circuits so you have something
    to compare your builds against.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，以及您在构建面包板电路方面的经验增加，我将停止对更简单电路的面包板布局；然而，对于更复杂的电路，我仍会呈现它们，这样您就有东西可以与您的构建进行比较。
- en: Please note that the proceeding circuit examples and discussions are only brief.
    At this stage of this book, we intend to build a simple electronic circuit that
    will be the basis for our Python examples in this chapter and [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask,* and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker.* We will discuss
    the Raspberry Pi and its pin numbering in detail in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*. Furthermore, we will cover
    in detail circuits and electronics fundamentals in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*, where among other topics we will
    learn the *why* behind how the button interacts electrically with your Raspberry
    Pi and why a 200 Ω resistor accompanies our LEDs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下电路示例和讨论仅为简要介绍。在本书的这个阶段，我们打算构建一个简单的电子电路，这将是本章和第三章《使用Flask进行RESTful API和Web套接字的网络》以及第四章《使用MQTT，Python和Mosquitto
    MQTT Broker进行网络》中Python示例的基础。我们将在第五章《将您的Raspberry Pi连接到物理世界》中详细讨论树莓派及其引脚编号。此外，我们将在第六章《软件工程师的电子学101》中详细介绍电路和电子基础知识，其中我们将学习按钮如何在电气上与您的树莓派进行交互的*原因*，以及为什么200Ω电阻器伴随我们的LED。
- en: Let's get started with building our first circuit. I'll walk you through the
    breadboard build step by step and talk briefly about each component as we work
    with them. We will start by discussing what a breadboard is and how it works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的第一个电路。我将逐步为您介绍面包板的构建过程，并在我们使用它们时简要讨论每个组件。我们将从讨论面包板是什么以及它是如何工作的开始。
- en: Understanding the breadboard
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解面包板
- en: 'An electronic *breadboard,* as illustrated in *Figure 2.1*, is a prototyping
    board that helps you to electrically connect components and wires quickly and
    easily. In this section, we will discuss the general properties of a breadboard
    in preparation for connecting components and wires together in the following sections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 电子*面包板*，如*图2.1*所示，是一个原型板，可以帮助您快速轻松地进行电气连接组件和电线。在本节中，我们将讨论面包板的一般属性，以便在接下来的部分中连接组件和电线时做好准备：
- en: '![](assets/a1acecae-ed38-4c66-9da8-9d6cd9d7c9dc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1acecae-ed38-4c66-9da8-9d6cd9d7c9dc.png)'
- en: Figure 2.1 – Breadboard
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 面包板
- en: Breadboards come in many different sizes, and our illustrated breadboard is
    a half-sized breadboard. Irrespective of their size, however, their basic layout
    and electrical connectivity are similar—with one small exception that I'll mention
    later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板有许多不同的尺寸，我们插图中的面包板是半尺寸面包板。然而，无论它们的尺寸如何，它们的基本布局和电气连接方式是相似的，只有一个小例外，我稍后会提到。
- en: Real breadboards may, or may not, have the row and column numbers markings on
    them. They have been included in the illustration to assist with the following
    discussion and explanations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的面包板可能有，也可能没有，行和列号码标记。它们已经包括在插图中，以帮助以下讨论和解释。
- en: 'The *holes* in the breadboard are where you place electrical components and
    wires to electrically connect them. The holes are electrically connected in the
    following ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板上的*孔*是您放置电子元件和电线以进行电气连接的地方。孔的电气连接方式如下：
- en: 'The two outer columns of holes are commonly referred to as *power rails*. There
    is a positive (+) column and a negative (-) column on either side of the breadboard.
    Each column of holes is electrically connected and run for the full length of
    the breadboard. Hence, there are four independent power rails on this breadboard:
    a *+* and *-* rail on the left-hand side of the breadboard and a *+* and *-* rail
    on the right-hand side.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板的两个外部列孔通常被称为*电源轨*。面包板的两侧分别有一个正（+）列和一个负（-）列。每一列孔都是电气连接的，并且贯穿整个面包板的长度。因此，这个面包板上有四个独立的电源轨：面包板左侧有一个*+*和*-轨，右侧也有一个*+*和*-轨。
- en: The power rails are frequently used to help to distribute power around the breadboard
    to components. Please note that they do not provide power themselves! They need
    a power source such as a power supply or battery connected to them to provide
    power.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 电源轨经常用于帮助在面包板上向组件分配电源。请注意，它们本身不提供电源！它们需要连接到电源供应或电池等电源源才能提供电源。
- en: The center of the breadboard has two banks of holes, which I have labeled *Bank
    A-E* and *Bank F-J*. Each *row* of holes in a bank is electrically connected.
    For example, holes A1 through to E1 are electrically connected, as are holes F1
    through to J1\. However, to be clear in our understanding, A1-E1 are *not* electrically
    connected to F1-J1 because they are on a separate bank.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板的中间有两排孔，我标记为*A-E*和*F-J*。每个银行的每一行孔都是电气连接的。例如，孔A1到E1是电气连接的，孔F1到J1也是如此。然而，为了清楚地理解，A1-E1与F1-J1并*不*是电气连接的，因为它们在不同的银行上。
- en: We straddle **Integrated Circuits** (**ICs**)—commonly called *chips—*acros*s* the gap
    between the two banks when we connect them into a breadboard. We will see an example
    of this in [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml), *Movement
    with Servos, Motors, and Steppers*, when we use an IC to control motors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它们连接到面包板时，我们跨越两个银行之间的间隙放置**集成电路**（**ICs**）—通常称为*芯片*。当我们使用IC来控制电机时，我们将在第十章《使用舵机，电机和步进电机进行运动》中看到一个例子。
- en: 'Here are a few more examples of how the holes are connected that you can work
    through to help with your understanding:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: B5 is electrically connected to C5 (they share the same row).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H25 is electrically connected to J25 (they share the same row).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A2 is *not* electrically connected to B2 (they don't share the same row).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E30 is *not* electrically connected to F30 (they are on different banks).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third + hole (from the top of the breadboard) on the left-hand side power
    rail is electrically connected to the last + hole on the left-hand side power
    rail (they are in the same vertical column).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third + hole (from the top of the breadboard) on the left-hand side power
    rail is *not* electrically connected to the third + hole on the right-hand side
    power rail (they are on different power rails).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I mentioned at the start of this section that all breadboards are basically
    the same, with one minor exception. This exception relates to the power rails.
    Some full-size breadboards may split their power rails into two separate vertical
    banks (so, electrically, the vertical holes in a rail do not run the full length
    of the breadboard). It is not always visually obvious that the power rails are
    split, so discovery needs to happen on a breadboard-by-breadboard basis. I mention
    this just in case you are using a full-size breadboard and experience connectivity
    issues when using the power rails.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced breadboards, and we understand how the holes are
    electrically related to one another, let's start plugging components and wires
    into our breadboards to create our first circuit. We'll start with the push button.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Positioning and connecting the push button
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are using a simple on/off button, also commonly known as an **Single Pole,
    Single Throw** (**SPST**) momentary switch. An example is shown in *Figure 2.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ddfb0e64-b89d-4881-a9f4-7452f4205b00.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – A push button and schematic symbol
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of *Figure 2.2 *is a photograph of a momentary push button,
    while the right-hand side shows the schematic symbol for a momentary push button.
    We'll see this symbol and discuss schematic diagrams where these types of symbols
    appear in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Push buttons come in many shapes and sizes; however, their general operation
    is the same. This specific push button pictured on the left-hand side is known
    as a *tactile* push button. They are small and well suited for use with a breadboard.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.3 *illustrates the push button connection we need to create on our
    breadboard. Please refer to this as you follow the forthcoming steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14c9d62c-822d-4016-adcf-963d7850656a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Connecting the push button
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to connect the push button into your breadboard and connect it
    to your Raspberry Pi. The following step numbers match the numbered black circles
    in *Figure 2.3*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Position the button on the breadboard as shown. It does not matter exactly which
    row of holes the button goes into, however, *Figure 2.3* shows the button positioned
    (top-left leg) at hole B10.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect a jumper wire into the same row as the push button's top-most
    leg (our illustration uses hole A10). Connect the other end of this wire to the
    eighth pin counted down from the outer edge of your Raspberry Pi's GPIO header.
    This pin is known as GPIO 23.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can get header pin labels and breadboard compatible modules to assist you
    with Raspberry Pi pin connections and identification. Here is a link to a printable
    version to get you started: [https://github.com/splitbrain/rpibplusleaf](https://github.com/splitbrain/rpibplusleaf).
    We will cover GPIO pins and their numbering in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using another wire (labeled* gnd'*), we connect the other side of the
    push button (the leg in hole B2) to the negative power rail on your breadboard.
    Our illustration shows the *gnd'* wire connection from hole A12 to a nearby hole
    on the left-hand side negative (-) power rail. The abbreviation *gnd* means ground.
    We will cover this term in more detail in the forthcoming section, *Understanding
    ground connections and symbols*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Electrically, an SPST switch can be installed any way around. If your button
    has four legs (two sets will be electrically connected) and your circuit below
    does not work when we test it later in the *Exploring two ways to integrate a
    push button in Python *section try rotating the button in your breadboard 90 degrees.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Now that our push button is in position and wired, we will next position and
    connect our LED.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Positioning and connecting the LED
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An LED is a small, yet bright, light made of a tiny crystal that emits a color
    when electricity is connected to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical LED is shown in  *Figure 2.4.* The left-hand side of the diagram
    shows a physical representation of a LED, while the right-hand side shows the
    schematic symbol for a LED:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/124bcbfb-9922-4e2a-8483-310489e81016.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – LED and schematic symbol
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: LEDs need to be connected the correct way around into a circuit, otherwise,
    they will not work. If you look closely at your LED, you will notice a flat side
    on the LED casing. The leg on this side is the *cathode,* which connects to the
    negative or ground side of a power source. The cathode leg will also be the shorter
    of the LED's legs. The other leg is known as the *anode* and connects to the positive
    side of a power source. If you examine the LED symbol, you will notice that the
    cathode side of the LED has a line drawn across the tip of the triangle—if you
    think of this line as being like a big negative sign, it'll help you to remember
    which side of the symbol is the cathode leg.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.5 *the LED connection we are about to create. Please refer to this
    diagram as you follow the forthcoming steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b60e866-a29c-4456-b964-b0de7e2561c5.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Connecting the LED
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to connect the LED into your breadboard and connect it to your
    Raspberry Pi. The following step numbers match the numbered black circles in *Figure
    2.5 *:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Connect the LED into your breadboard as illustrated, taking care to ensure that
    the LED is installed the correct way around. Our illustration shows the cathode
    leg in hole E15 and the anode leg in hole E16.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may need to bend the legs on your LED to get it into position. As you position
    your LED, make sure the two legs are not touching one another! If they are touching,
    this will cause what is known as an* electrical short*, and the LED part of the
    circuit will not work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Next, using a jumper wire (labeled *gnd"*), connect the cathodeleg of the LED
    into the same power rail shared by the push button. We have shown this connection
    with one end of the *gnd"* wire connected in hole A15, while the other end of
    the wire connected to a nearby hole on the left-hand side negative (-) power rail.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, using another jumper wire (labeled *gnd),* connect the negative (-)
    power rail to the 17^(th) outer edge pin on your Raspberry Pi's GPIO header. This
    pin is a ground (GND) pin on your Raspberry Pi.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done! That's our LED connected. Next, we add the resistor, which will complete
    our circuit.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Positioning and connecting the resistor
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A resistor is an electronic component used to limit (that is, resist) current
    flow and divide voltage and they are a very common electrical component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown in *Figure 2.6 *are a physical resistor (left-hand side) and two schematic
    symbols (right-hand side). There is no practical difference between the schematic
    symbols pictured. They represent different documentation standards, and you will
    find that the author of a schematic diagram will choose and stick with one type
    of symbol. We''ll be using the zig-zag symbol throughout this book:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c378274d-bc70-4c00-8441-fc5d7a45713d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Resistor and schematic symbols
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Resistors come in many shapes, sizes, and colors. As a general guide, their
    physical shape and size relate to their physical properties and capabilities,
    while the color of their casing is usually insignificant, at least as far as their
    properties are concerned. The colored bands on a resistor, however, are very significant
    as they identify the resistor's value. It's worth mentioning that small general-purpose
    resistors (which are what we will be using) use color bands for specifying their
    value, while physically larger resistors used in high power applications frequently
    have their resistance value printed on their casing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Resistors are an unbiased electrical component, meaning that they can be installed
    in an electrical circuit either way around. Their values, however, need to be
    chosen correctly, otherwise a circuit may not work as intended, or worse, the
    resistor and/or other components (including your Raspberry Pi) can be damaged.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: When starting out and learning about circuits, it is highly recommended and
    safest to always use the intended resistor values that are listed for a circuit.
    Avoid any temptation to substitute different values when you do not have the correct
    value on hand as this can result in damage to components and even your Raspberry
    Pi.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Our use of resistors through this book will be pragmatic. although I will be
    explaining how and why we arrive at the certain values we use from [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer,* onward. If you are new to resistors,
    you will find two links in the *Further reading* section where you can learn more
    about them, including how to read their values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.7 *demonstrates the resistor connection we need to create. Please
    refer to this as you follow the forthcoming steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0765bac-ced0-413e-a255-230365d8066c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Completed button and LED circuit on the breadboard
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to connect the resistor into your breadboard. The following step
    numbers match the numbered black circles in *Figure 2.7*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Place one leg (is does not matter which one) of the resistor into a hole that
    shares the same row as the LED's anode leg. This connection is shown at hole D16. Insert
    the other leg inserted into a vacant row, shown at D20 (it'll be a vacant row
    on your breadboard until we connect the wire next).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a jumper wire (illustrated starting at hole A20*)*, we connect the other
    leg of our resistor to the 20^(th) pin on the outer edge of your Raspberry Pi's
    GPIO header. This pin is known as GPIO 21.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done! With that last connection, we have created our first circuit. We'll
    be using this base circuit throughout the rest of this chapter and in the next
    two chapters, [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking
    with RESTful APIs and Web Sockets Using Flask*, and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker*. We will start to
    explore a range of other circuits from [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*, onward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed our breadboard circuit and learned how components
    and wires are connected on our breadboard, we are ready to explore a diagramming
    technique that is used to describe electrical circuits.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Reading an electronic schematic diagram
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we built our first circuit on a breadboard by following
    a series of illustrated steps. In this section, we will learn about *schematic** diagrams*,
    which is a formal way of documenting and describing an electrical circuit. These
    are the diagrams you find in electronic texts and datasheets.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to read a simple schematic diagram and how it relates back
    to the breadboard layout we just created. Understanding how the two relate, and
    especially being able to create a breadboard layout from a schematic diagram,
    is an important skill you will need to develop as you continue your electronics
    and IoT journey.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The electronic circuits and schematic diagrams we will be seeing and working
    with throughout this book will be relatively simple as far as schematic diagrams
    are concerned. We will address important concepts and component symbols as we
    encounter them on a case-by-case basis. For our journey, a full and detailed explanation
    of the ins and outs of schematic diagramming is unnecessary and beyond the practical
    scope of this book. However, I encourage you to read through the Spark Fun tutorial
    that's mentioned in the *Further reading* section. It provides a brief, yet comprehensive
    overview of reading schematic diagrams and will provide you with a good foundational
    understanding of this diagramming technique and its semantics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at a schematic diagram that represents the breadboard
    circuit we just created as shown in *Figure 2.7*. Our semantic diagram is illustrated
    here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1951077c-d77c-492a-954c-3cbc86eb172b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Schematic diagram of the breadboard circuit from Figure 2.7
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A schematic diagram can be correctly drawn in a multitude of ways; however,
    I've purposely drawn this diagram (and will do so where appropriate in this book)
    to closely resemble its equivalent breadboard layout to help with its interpretation
    and understanding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn to read this schematic diagram by first explaining the push button
    connection and wiring.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Reading the push button schematic connection
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I''ve combined the breadboard layout and schematic diagram (with a few additional
    labels) as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1c4ef234-81bf-4871-ba1c-d85820c635d0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Combined breadboard and schematic diagram, part 1 of 2
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to read the pushbutton connection. The following step numbers match
    the numbered black circles in *Figure 2.9*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Start at the breadboard with the wire labeled *wire 1.* If we look at the ends
    of this wire, we see that one end is connected to GPIO 23 on the Raspberry Pi,
    while the other end (at hole A10) connects to a row shared by the push button.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking at the schematic diagram, this breadboard connection is depicted diagrammatically
    by the line labeled *wire 1.* You will notice one end of the line is labeled GPIO23,
    while the other end leads into one side of the button symbol.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The color of a wire's casing has no inherent meaning. The color is simply a
    visual aid to help to distinguish different wires and connections. However, there
    are some common conventions such as using a red wire for a positive power connection
    and a black wire for the negative or ground wire
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Next, starting at the other side of the push button on the breadboard (hole
    A12), notice the wire labeled *gnd'*. This wire connects the push button to the
    outer power rail on the breadboard.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Five holes down from this first power rail connection, we see a second ground
    wire (labeled *gnd)* leading from the breadboard back to a GND pin on the Raspberry
    Pi.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breadboard *gnd* and *gnd'* wire connections are seen in the schematic diagram
    as the line labeled *gnd*, which leads out of the button and ends at a downward
    pointing *arrow* symbol annotated *GND* (remember *gnd* and *gnd'* are electrically
    connected on the breadboard and are therefore logically a single wire)*.* This
    is the symbol for a *ground connection*, and you will frequently see this symbol
    repeated a lot in schematic diagrams. I'll have more to say about this symbol
    when we reach the section titled *Reading and understanding the ground symbol*.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原理图中，面包板上的*gnd*和*gnd'*线连接被表示为标有*gnd*的线，这条线从按钮出来并以一个向下的*箭头*符号注释为*GND*（记住*面包板上的*gnd*和*gnd'*是电连接的，因此在逻辑上是一根线）。这是*地线连接*的符号，你会经常在原理图中看到这个符号。当我们到达标题为*阅读和理解地线符号*的部分时，我会对这个符号有更多的话要说。
- en: Examine the button symbol in the schematic diagram and you will notice that
    the *wire 1* and *gnd* lines are not joined but rather terminate in the button
    symbol (the small circles). This is known as a *normally open* *connection* or,
    in our specific case, *a **normally open* switch. You can think of *normally open*
    as meaning the line is broken (and remember a *line* represents a *wire).* Now,
    if you imagine the button *pressed,* then the button touches each circle and connects
    the *blue* and *gnd* lines, resulting in a *closed* connection that completes
    the circuit between GPIO 23 and GND. We'll discuss this idea more in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查原理图中的按钮符号，你会注意到*wire 1*和*gnd*线并没有连接，而是终止在按钮符号（小圆圈）。这被称为*常开*连接，或者在我们的特定情况下，是*常开*开关。你可以把*常开*理解为意味着线路断开（记住*线*代表*导线*）。现在，如果你想象按钮被按下，那么按钮会触碰每个圆圈，并连接*蓝色*和*gnd*线，形成一个*闭合*连接，完成了GPIO
    23和GND之间的电路。我们将在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中更详细地讨论这个概念，*软件工程师的电子学101*。
- en: When you are comfortable that you understand how the push button connections
    on the breadboard match the push button section of the schematic diagram, we will
    proceed and discuss LED and resistor connections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确信你理解了面包板上按键的连接如何与原理图上的按键部分匹配时，我们将继续讨论LED和电阻的连接。
- en: Reading the LED and resistor schematic connection
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读LED和电阻的原理图连接
- en: 'Continuing from the previous section, where we learned how to read and understand
    the push button part of the schematic diagram, next we complete our explanation
    by covering the LED and resistor connections, as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节，我们学习了如何阅读和理解原理图上按键部分，接下来我们将通过讨论LED和电阻的连接来完成我们的解释，如下所示：
- en: '![](assets/397ae268-fac0-4b72-93cd-447a7c8e845a.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/397ae268-fac0-4b72-93cd-447a7c8e845a.png)'
- en: Figure 2.10 – Combined breadboard and schematic diagram, part 2 of 2
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 组合面包板和原理图，第2部分
- en: 'Here is how to read the LED and resistor connection. The following step numbers
    match the numbered black circles in *Figure 2.10*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何阅读LED和电阻的连接。以下步骤编号与*图2.10*中编号的黑色圆圈相匹配：
- en: Start at the wire labeled *wire 2* on the breadboard. This wire connects GPIO
    21 on the Raspberry Pi into the row shared by one end of the resistor (hole A25).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从面包板上标有*wire 2*的线开始。这根线将树莓派上的GPIO 21连接到一个端子上，这个端子与一个电阻的一端（孔A25）共用。
- en: The *wire 2* connection is depicted by the line also labeled *wire 2* on the
    schematic diagram.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原理图上也标有*wire 2*的线连接。
- en: On the breadboard, the other end of the resistor is connected to the anode leg
    of the LED (hole E15). Remember, the resistor and anode leg of the LED are electrically
    connected because they share the same row of holes in the same bank on the breadboard.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面包板上，电阻的另一端连接到LED的阳极腿（孔E15）。记住，电阻和LED的阳极腿是电连接的，因为它们在面包板上的同一排孔中的同一组孔中。
- en: We see the resistor/LED connection in the schematic diagram where the resistor
    symbol meets the LED symbol. We know the resistor connects to the anode side of
    the LED in the diagram by the way the LED symbol is orientated.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在原理图中看到了电阻/LED连接，电阻符号与LED符号相遇。我们知道电阻通过LED符号的方向连接到了LED的阳极一侧。
- en: Next, on the breadboard, the other leg of the LED (hole E15)—the cathode leg—connects
    to the *gnd"* wire (hole A15), which then connects back to the outer power rail
    that is also shared by the push button's *gnd'* wire (which is then connected
    back to the Raspberry Pi's GND pin with the *gnd* wire.)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在面包板上，LED的另一端（孔E15）——阴极腿——连接到*gnd'*线（孔A15），然后连接回外部电源轨，这也是按键的*gnd'*线所共用的（然后通过*gnd*线连接回树莓派的GND引脚）。
- en: Finally, on the schematic diagram, this connection from the LED cathode leg
    to GND is depicted by the line labeled *gnd* (the same one used by the push button).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在原理图上，LED阴极腿到GND的连接由标有*gnd*的线表示（与按键使用的相同线）。
- en: We have now completed our schematic diagram explanation. How did you do? I hope
    you were able to trace around the diagram and see how it relates back to the circuit
    we built on the breadboard.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了我们的原理图解释。你做得怎么样？我希望你能够追踪原理图并看到它如何与我们在面包板上构建的电路相关联。
- en: Our last step illustrates an important concept in electronics—a *common ground*.
    We'll discuss this concept in more detail next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步展示了电子学中一个重要的概念——*公共地*。我们将在接下来更详细地讨论这个概念。
- en: Introducing ground connections and symbols
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入地线连接和符号
- en: Electrical circuits all require a common electrical point of reference, and
    we call this point *ground.* This is why we see the push button and LED sharing
    a common connection on both the breadboard and schematic diagram (as a reminder,
    refer to *Figure 2.10*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有电路都需要一个共同的电参考点，我们称之为*地*。这就是为什么我们看到按键和LED在面包板和原理图上共享一个公共连接的原因（作为提醒，请参考*图2.10*）。
- en: For the simple circuits presented throughout this book and when working with
    your Raspberry Pi's GPIO pins, it will be practical to consider the terms *negative* and *ground* as
    interchangeable. This is because the *negative* side of a power source will be
    our common point of electrical reference (and yes, GPIO pins are a source of power,
    which we will explore more in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously in the *Reading the push button schematic connection* section,
    in *step 4*, we diagrammed the ground point using an arrow symbol. Our ground
    symbol (made out of line segments) is one common variation of a ground symbol.
    You''ll see another variation in *Figure 2.11*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48acfd85-f903-40d0-98e2-fdbd5211bef1.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Common schematic diagram ground symbols
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: All ground points are electrically connected, and we may repeat the symbol many
    times in a schematic diagram to help to simplify the diagram. By using the ground
    symbol to indicate a common ground connection, we remove the need to draw many
    interconnecting lines to join all ground connections together (which would get
    rather messy for large or more complex circuits).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simple circuit certainly does not come under the banners of *large* or
    *complex*, however, to illustrate the concept of common ground, I have redrawn
    the schematic diagram shown originally in *Figure 2.8 *here, only this time using
    multiple ground symbols:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/95c85560-0269-4686-a3c1-dfbb79602628.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Alternative schematic diagrams of the breadboard circuit in Figure
    2.7
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Although our alternative schematic diagram looks like two separate circuits,
    they are electrically connected exactly the same as our original schematic diagram
    in *Figure 2.8.*
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Please take a moment now to examine both *Figure 2.8 *and *Figure 2.12 *and
    see whether you can work out how the two diagrams are electrically the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: All I have done here is broken the line (labeled *gnd* in *Figure 2.8*) and
    redrawn the push button subcircuit and LED/resistor subcircuit in a different
    orientation and used separate ground symbol for each subcircuit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, at this stage of this book, we do not go into how or
    why this circuit works electronically or how it interacts electrically with the
    GPIO pins on your Raspberry Pi. We'll cover these topics and many more with practical
    and illustrative exercises when we reach [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the schematic diagram that documents our breadboard circuit
    and see how they relate to one another, we're finally ready to dive into code
    and learn two ways to make our LED flash in Python!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Exploring two ways to flash an LED in Python
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will investigate two alternative GPIO libraries and ways
    to make an LED flash in Python, including the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPIOZero library: An entry-level GPIO library'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PiGPIO library: An advanced GPIO library'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learn to use these two libraries, we will see how they approach GPIO control
    differently and discover their relative strengths and weaknesses.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: After completing this section (and the following section, *Exploring two ways
    to integrate a push button in Python*), you will have explored and compared two
    very different approaches to GPIO control—the high-level (using GPIOZero) and
    a lower-level (using PiGPIO)—and have a good introductory grasp of when and how
    you would choose between the alternative when building an electronic interfacing
    program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our practical exercises by making the LED blink using GPIOZero.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Blinking with GPIOZero
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to investigate our first blinking method using the GPIOZero
    library. You will find the code we are about to cover in the `chapter02/led_gpiozero.py` file.
    Please review this file before proceeding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In the *Further reading* section, you will find relevant links to the GPIOZero
    API documentation for the specific features of this library that we use in this
    section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We will start by running our example code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program using the following command, remembering that you need to be
    in the *activated* virtual environment (if you need a refresher on how to activate
    a Python virtual environment, see [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml), *Setting
    Up Your Development Environment*):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the LED is connected correctly, it should blink.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: If you receive an error about PiGPIO when you run the program, make sure you
    have enabled the `pigpio` daemon as outlined in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml),* Setting
    Up Your Development Environment*. We'll talk more about PiGPIO and the PiGPIO
    daemon in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have run the code and seen the LED blink, it's time to look through
    the code that makes this happen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start our code exploration by looking at the external libraries we
    are importing in our Python program. They appear near the top of the source file,
    as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The imports of interest are the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: At line (1), we import the `Device` and `LED` classes from the GPIOZero package.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At line (2), we are importing a GPIOZero *Pin Factory*. This is used together
    with the `Device` class, which we'll see next.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we see how to set the GPIOZero Pin Factory implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Pin Factory configuration
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *Pin Factory* is used in GPIOZero specify which concrete GPIO library GPIOZero
    will use to perform the actual GPIO work. We will discuss Pin Factories in more
    detail when we compare the GPIOZero and PiGPIO examples later in this chapter in
    the *Comparing the GPIOZero and PiGPIO examples *section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On line (3), we are telling GPIOZero to use PiGPIO as its *Pin Factory* using
    the `Device` and `PiGPIOFactory` imports.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how a Pin Factory is set up, let's look at the code that makes
    our LED blink.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Blinking the LED
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we see the `LED` class at line (4) in the following is created and assigned
    to the `led` variable. The parameter to `LED` is the GPIO pin that the physical
    LED is connected to, as per the breadboard in *Figure 2.1*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On line (5), we start the LED blinking. The `background=False` parameter to `blink()` is
    needed to run the LED on the main thread so the program does not exit (an alternative
    of `background=True` would be to use `signal.pause()`. We'll see an example of
    this in the next section).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: GPIOZero makes it very easy to interface with common electronic components such
    as an LED. Next, we will perform the same exercise, only this time using the PiGPIO
    library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Blinking with PiGPIO
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen how to blink our LED using the GPIOZero library, let's
    look at an alternative method using the PiGPIO library.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The code we are about to walk through is contained in the `chapter02/led_pigpio.py` file. Terminate
    the previous example if it is still running, and run `led_pigpio.py`. The LED
    should blink again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In the *Further reading* section, you will find relevant links to the PiGPIO
    API documentation for the specific features of this library that we are using
    in this section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the PiGPIO version of our LED blinking code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting at the top of the file, we have the `import` section of the source
    file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time around, on line (1), we only need to import the PiGPIO module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to configure PiGPIO and set the I/O mode on the GPIO pin
    that is connected to our LED.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO and pin configuration**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the code that configures PiGPIO and the LED''s GPIO pin:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We create an instance of PiGPIO on line (2) and assign it to the `pi` variable.
    We use this variable to interact with the PiGPIO library from this point forward
    in the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: On line (3), we configure GPIO pin 21 to be an *output* pin. Configuring a pin
    as *output* means we want to use that pin to control something connected to it
    from our Python code. In this example, we want to control the LED. Later in this
    chapter, we'll see an example of an input pin used to respond to button presses.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have imported our required libraries and configured PiGPIO and the
    out GPIO pin, let's now see how we are making the LED blink.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Blinking the LED**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we make our LED blink:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We achieve the blinking with PiGPIO using a `while` loop. As the loop executes,
    we are toggling GPIO pin 21— our *output* pin—on and off (lines (4) and (5)),
    with a short `sleep()` function in between, hence making the LED appear to blink.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will compare our two libraries and their different approaches to blinking
    the LED.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the GPIOZero and PiGPIO examples
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at the code for the GPIOZero example, it's pretty obvious we're
    making an LED blink—it's pretty explicit in the code. But what about the PiGPIO
    example? There is no mention of LEDs or blinking. In truth, it could be doing
    anything—it's just we know an LED is connected to GPIO 21.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Our two blinking examples reveal important aspects of GPIOZero and PiGPIO:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIOZero** is a higher-level wrapper library. On the surface, it abstracts
    common electronic components such as LEDs into simple-to-use classes while, underneath,
    it is delegating the actual interfacing work to a concrete GPIO library.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PiGPIO** is a lower-level GPIO library where you work with, control, and
    access GPIO pins directly.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "zero" in GPIOZero refers to a naming convention for zero boilerplate code
    libraries where all of the complex internals are abstracted away to make it easier
    for beginners to get started.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: GPIOZero performs its delegation to an external GPIO library using a *Pin Factory*.
    In our example, we delegated to PiGPIO using the line, `Device.pin_factory = PiGPIOFactory()`.
    We'll pick up the topic of GPIOZero and delegation again in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    your Raspberry Pi to the Physical World*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: As we proceed through this book, we will be using both GPIOZero and PiGPIO.
    We'll use GPIOZero to simplify and condense code where appropriate, while we will
    be using PiGPIO for more advanced code examples and to teach core GPIO concepts
    that are otherwise abstracted away by GPIOZero.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will continue building on our LED blinking examples by integrating
    the push button.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Exploring two ways to integrate a push button in Python
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored two different approaches to making our
    LED blink—one using the GPIOZero library and the other with the PiGPIO library. In
    this section, we will integrate the push button from the circuit in *Figure 2.1 *with
    Python and see how we can integrate the button using both the GPIOZero and PiGPIO
    libraries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We will start by making our LED turn on and off with a button that is integrated
    using the GPIOZero library.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a button press with GPIOZero
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code we are about to cover is included in the `chapter02/button_gpiozero.py` file. Please
    review and run this file. The LED should turn on and off as you press the button.
    As per the circuit in *Figure 2.1*, the LED is still connected to GPIO 21, while
    our button is connected to GPIO 23.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously in the *Creating a breadboard circuit* section, if your
    button has four legs (two sets will be electrically joined) and your circuit does
    not work, try rotating the button in the breadboard 90 degrees.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the significant parts of the code, noting that we are skipping sections
    of code that we've already covered.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting at the top of the source file, you will find the section of code where
    we import external libraries, as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this example, we have also imported the GPIOZero `Button` class (1) and
    the Python `signal` module (2).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen that we are importing the `Button` class, let's look
    at the handler function that will be called when the button is pressed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Button pressed handler**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are using a callback handler to respond to button presses, defined in the
    `pressed()` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On line (3), our LED is turned on and off each time `pressed()` is invoked using
    the `toggle()` method of `led`. On line (4), we query the `value` property of
    `led` to determine whether the LED is on (`value == 1`) or off (`value == 0`)
    and store it in the `state` variable, which we print to the Terminal on line (5).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: You can also control the LED with the `led.on()`, `led.off()`, and `led.blink()` methods.
    You can also directly set the LED on/off state by setting `led.value`, for example, `led.value
    = 1` will turn the LED on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue and see how to create and configure a `Button` class instance
    and register the `pressed()` function so it is called when you press the physical
    button.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Button configuration**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following are the lines used to configure the push button. On line (6), the
    class we use is `Button`. In GPIOZero, we use a `Button` class for any *input*
    device that can be either on or off, such as buttons and switches:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On line (7), we register the `pressed()` callback handler with our `button` instance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the meanings of the parameters to the `Button` constructor on line
    (6):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the button's GPIO pin (`BUTTON_GPIO_PIN == 23`).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter, `pull_up=True`, enables an internal pull-up resistor for
    GPIO 23\. Pull-up and pull-down resistors are an important concept in digital
    electronics. We're are going to skip over this concept for now because we will
    be covering the importance and use of pull-up and pull-down resistors in greater
    detail in [Chapter 6,](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml) *Electronics
    101 for the Software Engineers*.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter `bounce_time=0.1` (0.1 seconds), is used to compensate for
    an occurrence known as switch or contact *bounce*.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounce is a type of electrical noise that occurs as the metal contacts within
    a physical button or switch come together. The result of this noise is seen as
    a rapid succession of on-off (or high-low) states changes on a digital input pin.
    This is undesirable because we want *one* physical press of a button (or toggle
    of a switch) to be seen as *one* state change on the input pin*.* This is commonly
    achieved in code using a **debounce threshold** or **timeout***,* which in our
    case is the amount of time that our Raspberry Pi ignores successive pin stage
    changes following an initial state change.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Try setting `bounce_time=0` (no debouncing). You should find that the button
    behaves very erratically. Then, use a higher number such as `bounce_time=5` (5 
    seconds), and you will find that after the first press the button is non-responsive
    until the duration expires.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to push buttons, selecting an appropriate debounce threshold is
    a matter of balancing how rapidly a user needs to press the button (this demands
    lower thresholds) versus how much bounce is inherent in your button (this demands
    higher thresholds). About 0.1 seconds is a good suggested starting value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's cover a common technique that is used to prevent an electronic-interfacing
    Python program from exiting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**Preventing the main thread from terminating**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s common to see the use of `signal.pause()` or an equivalent construct
    in GPIO examples and programs:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Line (8) prevents the main program thread from reaching its natural end, which
    under normal circumstances is where the program terminates.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to add `signal.pause()` to the end of a GPIO-interfacing Python program
    is a common and often confusing mistake when starting out. If your program exits
    immediately after it's started, try adding `signal.pause()` at the end of your
    program as a first step.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn''t need `signal.pause()` with our previous LED flashing examples. Here
    is why:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Our GPIOZero example (`chapter02/led_gpiozero.py`) used `background=False` in
    the LED constructor. This prevented our program from exiting by keeping the LED's
    thread in the foreground.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the PiGPIO example (`chapter02/led_pigpio.py`), it's the `while` loop that
    prevents the program from exiting.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this seems confusing, don't worry! Knowing how to prevent a program from
    existing abnormally all comes down to experience, practice, and understanding
    how Python and GPIO libraries work.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how to integrate the button using PiGPIO.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a button press with PiGPIO
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now replicate the same functionality as our previous GPIOZero example
    to turn our LED on and off with a button press, only this time using the PiGPIO
    library. The code for our PiGPIO example can be found in the `chapter02/button_pigpio.py` file.
    Please review and run this file now, and confirm that the LED responds to your
    button presses.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Let's unravel the interesting parts of the code, starting with the GPIO pin
    configuration for the push button (again, noting that we're skipping sections
    of code that we've already covered).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Button pin configuration**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting on line (1), we configure GPIO pin 23 (`BUTTON_GPIO_PIN == 23`) as
    an *input* pin:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, on line (2), we enable an internal pull-up resistor for pin 23\. In PiGPIO,
    we debounce the push button on line (3) using the `pi.set_glitch_filter()` method.
    This method takes the parameter in milliseconds.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Notice, in PiGPIO, we needed to configure each property for our button (pin
    input mode, a pull-up resistor, and debouncing) as a discrete method call, whereas
    in the previous GPIOZero example this all occurred on a single line when we created
    an instance of the GPIOZero LED class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Button pressed handler**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our button callback handler is defined at starting on line (4) and is more
    involved than the previous GPIOZero handler:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice the signature of `pressed(gpio_pin, level, tick)`. Our previous GPIOZero
    version has no parameters while PiGPIO has three mandatory parameters. Our simple
    one-button example does not use these parameters; however, for completeness they
    are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`gpio_pin`: This is the pin responsible for invoking the callback. This will
    be 23 in our example.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`: This the state of the pin. For us, this will be `pigpio.FALLING_EDGE` (we''ll
    see why shortly).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tick`: This is the number of microseconds since boot.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On line (5), we read the current state of GPIO 21 (our LED) into a variable
    with `led_state = pi.read()`. Then, starting on line (6), depending on whether
    the LED is currently on (`led_state == 1`) or off (`led_state == 0`), we set the
    GPIO 21 high or low using `pi.write()` to toggle the LED to its inverse on or
    off state.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the callback handler is registered on line (7). The parameter value, `pigpio.FALLING_EDGE`,
    means the call handler is `pressed()` whenever the GPIO pin, `BUTTON_GPIO_PIN`,
    (that is, 23) starts to transition from a digital high to a digital low. This
    is a lot more explicit than simply testing whether a pin is *high* or *low;* however,
    for simplicity, consider the following level parameter options to `pi.callback()`.
    Try changing the parameter and see what happens when you press the button:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`pigpio.FALLING_EDGE`: This is low (think *falling* toward low). `pressed()`
    is called when you *press* the button.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pigpio.RAISING_EDGE`: This is high (think *raising* toward high). `pressed()` is
    called when you *release* the button.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pigpio.EITHER_EDGE`: This can be high or low. `pressed()` is called when you
    both *press* and *release* the button, effectively meaning the LED will only illuminate when
    you hold down the button.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice or think at any stage in the PiGPIO example that when the button
    is pressed—that is, you *activated* the button—GPIO pin 23 becomes low (that is,
    the `pigpio.FALLING_EDGE` parameter on line (7)), and this results in `pressed()`
    begin called? Did this seem a bit back-to-front or false from a programming perspective?
    We'll revisit this idea and discuss the reasons behind it in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on GPIO libraries and electronics for now. We've seen how to respond
    to button presses with both the GPIOZero and PiGPIO libraries. In particular,
    we saw that the GPIOZero approach was rather simple and straightforward compared
    to the PiGPIO approach, which involved more code and more configuration. This
    is the same outcome we discovered in the previous section, *Exploring two ways
    to flash an LED in Python*—that is, the GPIOZero approach was simpler.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Is one approach better than the other? The answer to that all depends on what
    goal you are trying to achieve and how much lower-level control you require over
    your electronic interfacing to achieve that goal. At this stage of this book,
    I just wanted to give you contrasting options regarding GPIO libraries and how
    we interface them with electronics. We'll be picking this topic up again in greater
    detail when we revisit popular GPIO libraries for Python in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and create an IoT program to control our LED over the internet.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first IoT program
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are about to create a Python program to integrate with a service called [dweet.io](http://dweet.io/).
    This is how their website describes the service: "*it''s like Twitter for social
    machines*."'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We will create simple *dweets,* which are the dweet.io equivalent of a *tweet,* by
    pasting a URL into a web browser.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Our program will monitor and receive our dweets by polling a dweet.io RESTful
    API endpoint for data. As data is received, it will be parsed to find an instruction
    specifying whether our LED should be turned on or off or made to blink. Based
    on this instruction, our LED state will be changed using the GPIOZero library.
    We'll have a look at data format received from dweet.io when we discuss the program's
    code in a subsequent section titled *Understanding the server code*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We're using the free public [dweet.io](http://dweet.io/) service where all information
    is publicly accessible, so do not publish any sensitive data. There is a professional
    service available at [dweetpro.io](http://dweetpro.io/) that provides data privacy,
    security, dweet retention, and other advanced features.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The code for this program is contained in the `chapter02/dweet_led.py` file.
    Read through the source code in this file to get a broad perspective about what's
    happening before continuing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing the Python server
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will run and interact with a Python server program that
    will let us control our LED from a web browser by copying and pasting links. Once
    we have used the program to control our LED, we'll then delve into the mechanics
    of the code and how it works in the next section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `chapter02/dweet_led.py` program. You should see output similar to
    the following:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On line (1), the program has created a unique name for our *thing* to use with
    dweet.io. You'll notice this name in the URLs starting on line (2). The name created
    for your *thing* will be different from the preceding example.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: A *thing* name in dweet.io is analogous to an @handle on Twitter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the URLs at starting on line (2) into a web browser (it could
    be a computer other than your Raspberry Pi). After a short delay, the LED should
    change its state (on, off, or blinking) depending on the URL used.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have confirmed that the LED is controllable using the URLs, we will
    proceed and look at the program.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the server code
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will step through the major parts of the `dweet_led.py`
    program and discover how it works, starting with the imports.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, at the start of the source code file, we see the Python imports:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is one specific import I want to draw your attention to. On line (1),
    we are importing the `request` module (this was installed earlier in this chapter
    when you ran `pip install -r requirements.txt`). `requests` is a high-level library
    for making HTTP requests in Python. Our program uses this module to communicate
    with the dweet.io APIs, which we'll see shortly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand that we are importing and will later use the `requests`
    library, let's cover the global variables used in our program.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable definitions**'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we define several global variables. For now, review the following comments
    for their purposes. You''ll see them being used as we progress through the code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you read through the master source file, following these variable definitions,
    you''ll also notice that we are using the Python logging system instead of `print()`
    statements:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you need to turn on debugging for the program to diagnose a problem or to
    see the raw JSON data exchanged between our program and the dweet.io service,
    change line (2) to `logger.setLevel(logging.DEBUG)`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will step through the significant methods in the program and see what
    they do.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**The resolve_thing_name() method**'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `resolve_thing_name()` method is responsible for loading or creating a unique
    name for our *thing* for use with dweet.io.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Our intention when using this method is to always reuse a name so that our
    dweet URLs for controlling our LED remain the same between the program restarts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On line (3), we load a name stored previously in `thing_file` if the file exists;
    otherwise, we use the Python `UUID` module method `uuid1()` on line (4) to create
    an 8-character unique identifier and use that as the thing name. We store this
    newly created identifier-cum-name in `thing_file` on line (5).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the function that retrieves the last dweet made to our
    *thing.*
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**The get_lastest_dweet() method**'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`get_lastest_dweet()` queries the dweet.io service to retrieve the latest dweet
    (if any) made for our *thing.* Following is an example of the JSON response we
    expect to receive. It is the `content.state` property on line (1) that we are
    ultimately interested in:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Looking at the following code, we see, on line (6), the creation of the resource
    URL used to query the dweet.io service. A call to this URL will return us a JSON
    similar to that shown in the preceding. You will find a link in the *Further reading*
    section to the complete dweet.io API reference.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on line (7), the `requests` module use used to make an HTTP GET request
    to retrieve the latest dweet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting on line (8) in the following, we check whether the request succeeded
    at the HTTP protocol level. If successful on line (9), we then proceed to parse
    the JSON response and extract and return the `content` property starting on line
    (10):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our next method to cover is `poll_dweets_forever()`, which will use `get_lastest_dweet()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**The poll_dweets_forever() method**'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`poll_dweets_forever()` is a long-running function that periodically calls
    on line (11) the `get_lastest_dweet()` method we just covered. When a dweet is
    available, it is handled on line (12) by `process_dweet()`, which we will discuss
    shortly:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We sleep for a default delay of 2 seconds on line (13) before continuing the
    loop. Practically, this means there will be up to an approximate 2-second delay
    between using one of the dweeting URLs to request a LED state change and the LED
    altering its state.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the master source file, you will come across a function named
    `stream_dweets_forever()`.  This is an alternative and more efficient stream-based
    method of accessing dweets in real time using HTTP streaming.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The polling-based approach of `poll_dweets_forever()` was chosen here for discussion
    for simplicity. It will become clear as you read on where you can switch approaches.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Our next stop is the method we use to control the LED.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**The process_dweet() method**'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw previously when `poll_dweets_forever()` (similar to `stream_dweets_forever()`)
    gets a dweet, it parses out the `content` property from the dweet''s JSON. This
    is then passed to `process_dweet()` for handling, where we extract the `state`
    child property from the `content` property:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On line (15) (and (17) in the subsequent code block), we test for and maintain
    the LED's last known state and avoid interacting with the LED if it's already
    in the requested state. This will avoid potential visual glitching of the LED
    that can occur if it's repeatedly put into a blinking state when already blinking.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The core of `process_dweet()` is to access the `state` property of the dweet
    and change the LED''s state, which starts on line (16):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Following line (16), we set the LED state based on the dweet (remember the `led` variable is
    a GPIOZero LED instance) before keeping track of the new state on line (17), as
    mentioned, for subsequent testing when `process_dweet()` is called on line (15).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the simplicity of GPIOZero, our LED controlling code only makes a
    fleeting appearance in the code!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude by covering the program's main entry point.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**The main program entry point**'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the end of the source file, we have the following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On line (8), `print_instructions()`  is responsible for printing the sweet URLs
    to the Terminal, while on line (19), we see a call to `get_latest_dweet()`. This
    call initializes our LED to the last dweeted state when the program starts. Finally,
    on line (20), we start polling the dweet.io service to access the latest dweets.
    It's here you swap the dweet polling method to the streaming method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: This now completes our walk-through of `dweet_led.py`. Through this discussion,
    we have now seen how to leverage the dweet.io service to create a simple and functional
    IoT program. Before we complete this chapter, I want to leave you with two bonus
    source code files that you can use to extend your IoT program.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Extending your IoT program
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two files in the `chapter02` folder complement what we have covered
    in this chapter by combining the concepts we have learned. As the overall code
    and approach are similar to what we have already covered, we will not go through
    the code in detail:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '`dweet_button.py` provides an implementation showing how to use a push button
    to create a dweet with the dweet.io service. This will let you change your LED
    state with the press of a button.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pigpio_led_class.py` provides a code-level example of how a low-level library
    like PiGPIO relates to a high-level library like GPIOZero.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start by discussing `dweet_button.py`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a dweeting button
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program in `dweet_button.py` integrates the GPIOZero push button example
    with dweet.io. Earlier in this chapter, in the section titled *Running and testing
    the Python server*, we copied and pasted URLs into a web browser to control our
    LED.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `dweet_button.py`, each time you press the button, this program
    cycles through the dweet.io URLs to change the LED''s state. To configure this
    program, find and update the following line with the thing name you are using
    with `dweet_led.py`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember, that you'll also need the `dweet_led.py` program to be running in
    a Terminal, otherwise, the LED will not respond to your button presses.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see how to mimic GPIOZero using PiGPIO and a Python class.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: PiGPIO LED as a class
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `pigpio_led_class.py` file, we have a Python class that is a re-engineering
    of the PiGPIO LED example to wrap it as a class that mimics the GPIOZero `LED`
    class. It demonstrates the basic principle of how GPIOZero abstracts away lower-level
    GPIO complexity. This re-engineered class can be used as a drop-in replacement
    for the GPIOZero `LED` examples in this chapter, as shown here. See the header
    comments in `pigpio_led_class.py` for more information:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I hope you find these two bonus files interesting, and that by exploring the
    PiGPIO LED as a class example, you can better appreciate how the higher-level
    GPIOZero library and lower-level PiGPIO library relate to one another.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: At this stage of your journey, if you are a little unclear about what's happening
    with `pigpio_led_class.py`, do not get worried. I wanted to simply set out a brief example
    of GPIO library interactions for you to ponder in the context of an end-to-end
    application, as this will serve as a point of reference as you continue reading. We'll
    be covering the GPIOPZero and PiGPIO libraries (plus others) in greater detail
    in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World*, plus we'll be covering more advanced concepts such
    as threading in electronic interfacing programs (similar to the use of threads
    in `pigpio_led_class.py`) in [Chapter 12](b2a583d8-ea6d-4e0e-9018-26997fbdda4e.xhtml),
    *Advanced IoT Programming Concepts – Threads, AsyncIO, and Event Loops*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, you've just created a real functional IoT application
    using a Raspberry Pi and Python. We saw two alternative ways to flash a LED and
    read a button press in Python using both the GPIOZero and PiGPIO GPIO libraries.
    We also compared the use of these libraries and saw that GPIOZero takes a higher-level
    and more abstract approach to coding and GPIO control than does the lower-level
    PiGPIO library. We also connected the LED to the internet using the online dweet.io
    service. Using simple URLs, we were able to turn on and off and blink the LED
    by simply visiting the URLs in a web browser.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: As you proceed through the subsequent chapters in this book, we'll be building
    on and going deeper into the core knowledge you have learned in this chapter about
    GPIO interfacing, electronic circuits, and controlling a circuit over the internet.
    We will learn alternative approaches to building an application to those we have
    covered in this chapter and discover the core principles related to GPIO control
    and electronic interfacing. Equipped with this deepening knowledge, you'll be
    able to create even more powerful and grand IoT solutions by the time you complete
    this book!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml), *Networking with
    RESTful APIs and Web Sockets Using Flask*, we will be looking at the popular Flask
    microservices framework, and we will create two Python-based web servers and accompanying
    web pages to control the LED over a local network or the internet.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of questions for you to test your knowledge regarding this chapter''s
    material. You will find the answers in the *Assessments* section of the book:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: You don't have the correct resistor value. Can you just substitute another value
    resistor that you have lying around?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GPIOZero package is a compete GPIO library. Is it all you'll ever need?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you always use the built-in Python packages for networking wherever possible?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: an LED is unbiased, meaning it can be plugged into a circuit
    any way around and still work.'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are building an IoT application that interacts with other existing networked
    devices and it times out. What could be the problem?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Python module and function can be used to stop a program exiting?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We connected our LED to the internet using the dweet.io service and called
    its RESTful APIs, which are documented at the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Dweet.io API documentation:  [https://dweet.io](https://dweet.io)
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may wish to familiarize yourself with the GPIOZero library briefly to get
    an idea about what it can do. It''s well documented with heaps of examples. Here
    are a couple of useful links to relevant parts of the API documentation that we''ve
    covered so far:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: GPIOZero home page: [https://gpiozero.readthedocs.io](https://gpiozero.readthedocs.io/en/stable/api_output.html)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output Devices (LED): [https://gpiozero.readthedocs.io/en/stable/api_output.html](https://gpiozero.readthedocs.io/en/stable/api_output.html)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input Devices (Button): [https://gpiozero.readthedocs.io/en/stable/api_input.html](https://gpiozero.readthedocs.io/en/stable/api_input.html)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding PiGPIO, here are the relevant parts of its API documentation. You'll
    notice that PiGPIO is a more advanced GPIO library with less verbose documentation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The PiGPIO Python home page: [http://abyz.me.uk/rpi/pigpio/python.html](http://abyz.me.uk/rpi/pigpio/python.html)
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `read()` method: [http://abyz.me.uk/rpi/pigpio/python.html#read](http://abyz.me.uk/rpi/pigpio/python.html#read)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `write()` method: [http://abyz.me.uk/rpi/pigpio/python.html#write](http://abyz.me.uk/rpi/pigpio/python.html#write)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `callback()` method: [http://abyz.me.uk/rpi/pigpio/python.html#callback](http://abyz.me.uk/rpi/pigpio/python.html#callback)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_glitch_filter()`: [https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter](https://abyz.me.uk/rpi/pigpio/python.html#set_glitch_filter)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resistors are a very common electronic component. The following resources provide
    an overview of resistors and how to read their color bands to determine their
    resistance value in Ohms:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Resistor overview: [https://www.electronics-tutorials.ws/resistor/res_1.html ](https://www.electronics-tutorials.ws/resistor/res_1.html)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reading color bands: [https://www.electronics-tutorials.ws/resistor/res_2.html](https://www.electronics-tutorials.ws/resistor/res_2.html)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Spark Fun tutorial provides an excellent introduction to reading
    schematic diagrams:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '*How to Read a Schematic Diagram*: [https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all](https://learn.sparkfun.com/tutorials/how-to-read-a-schematic/all)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
