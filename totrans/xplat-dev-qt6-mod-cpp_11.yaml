- en: '*Chapter 8*: Graphics and Animations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn the fundamentals of Qt's graphics framework
    and how to render graphics on a screen. You will understand how general drawing
    is done in Qt. We will begin by discussing 2D graphics using **QPainter**. We
    will explore how to draw different shapes using a painter. Then you will learn
    about the Graphics View architecture used by **QGraphicsView** and **QGraphicsScene**.
    Later, we will discuss the **Scene Graph** mechanism used by Qt Quick. In this
    chapter, you will also learn how to make the user interface more interesting by
    adding animations and states.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qt's graphics framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPainter` and 2D graphics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Graphics View framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick scene graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State machines in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the graphics framework used
    by Qt. You will be able to draw onscreen and add animations to your UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest version of a desktop platform such
    as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platforms on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qt's graphics framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is one of the most popular frameworks for GUI applications. Developers can
    build awesome cross-platform GUI applications using Qt without worrying about
    the underlying graphics implementation. The Qt **Rendering Hardware Interface**
    (**RHI**) interprets graphics instructions from Qt applications to the available
    graphics APIs on the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'RHI is the abstract interface for hardware-accelerated graphics APIs. The most
    important class in the `rhi` module is `QRhi`. The `QRhi` instance is supported
    by a backend for the specific graphics API. The selection of the backend occurs
    at runtime and is decided by the application or library that creates the `QRhi`
    instance. You can add the module by adding the following line into your project
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Different types of graphics APIs supported by RHI are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenGL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenGL ES**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vulkan**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct3D**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metal**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 8.1* shows the major layers of the graphics stack in the Qt graphics
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Major layers of the Qt 6 graphics stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Major layers of the Qt 6 graphics stack
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get familiar with the graphics APIs shown in the preceding diagram.
    **OpenGL** is the most popular graphics API with cross-language and cross-platform
    application support. It is used to interact with the GPU, to achieve hardware-accelerated
    rendering. **OpenGL ES** is a flavor of the OpenGL API intended for embedded devices.
    It allows the rendering of advanced 2D and 3D graphics on embedded and mobile
    devices. **OpenGL ES on iOS devices** is also known as **EAGL**. OpenGL ES is
    also available on web platforms as WebGL. OpenGL and OpenGL ES are developed and
    maintained by the Khronos Group, a consortium of technology hardware and software
    companies. You can learn more about OpenGL at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.opengl.org/about/
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulkan** is a new-generation graphics API that helps in creating cross-platform
    and high-performance applications for modern GPUs. It was created by the Khronos
    Group. Vulkan''s explicit API design allows efficient implementations on a wide
    range of desktop, embedded, and mobile platforms. Qt 6 provides support for the
    Vulkan API. To use Vulkan, Qt applications require the LunarG Vulkan SDK. Explore
    more about Vulkan at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.lunarg.com/vulkan-sdk/
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct3D** is a Microsoft proprietary graphics API that provides functions
    to render 2D and 3D graphics by utilizing underlying GPU capabilities. Microsoft
    Corporation created it for use on the Windows platform. It is a low-level API
    that can be used to draw primitives with the rendering pipeline or to perform
    parallel operations with the compute shader.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Direct3D exposes the advanced graphics capabilities of 3D graphics hardware,
    including stencil buffering, W-buffering, Z-buffering, perspective-correct texture
    mapping, spatial anti-aliasing, programmable HLSL shaders, and effects. Direct3D''s
    integration with other DirectX technologies allows it to provide several features
    comprising video mapping, hardware 3D rendering in 2D overlay planes, and even
    sprites and allowing the use of 2D and 3D graphics in interactive media ties.
    Direct3D is intended to virtualize 3D hardware interfaces in general. In contrast,
    OpenGL is intended to be a 3D hardware-accelerated rendering system that can be
    emulated in software. These two APIs are fundamentally designed in two distinct
    ways. The following link provides further insight into Direct3D:'
  prefs: []
  type: TYPE_NORMAL
- en: https://docs.microsoft.com/en-in/windows/win32/getting-started-with-direct3d
  prefs: []
  type: TYPE_NORMAL
- en: '**Metal** is Apple''s low-level computer graphics API, which offers near-direct
    access to the **graphics processing unit** (**GPU**), allowing you to optimize
    the graphics and compute capacity of your iOS, macOS, and tvOS apps. It also has
    a low-overhead architecture that includes pre-compiled GPU shaders, fine-grained
    resource management, and multithreading support. Before the announcement of Metal,
    Apple provided OpenGL for macOS and OpenGL ES for iOS, but there was a performance
    issue due to the highly abstracted hardware. Metal, on the other hand, has better
    performance than OpenGL thanks to its Apple-specific API. Metal enables a whole
    new generation of professional graphics output by supporting up to 100 times more
    draw calls than OpenGL. You can read more about Metal at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://developer.apple.com/documentation/metal
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we got familiar with Qt's graphics framework and RHI. You now
    have a basic understanding of this framework. In the next section, we will go
    further and discuss 2D graphics using QPainter.
  prefs: []
  type: TYPE_NORMAL
- en: QPainter and 2D graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt comes with an advanced windowing, painting, and typography system. The most
    important classes in the Qt GUI module are `QWindow` and `QGuiApplication`. This
    module includes classes for 2D graphics, imaging, fonts, and advanced typography.
    Additionally, the GUI module comes with classes for integrating windowing systems,
    OpenGL integration, event handling, 2D graphics, basic imaging, fonts, and text.
    Qt's user interface technologies use these classes internally, but they can directly
    be used to write applications that use low-level OpenGL graphics APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the platform, the `QWindow` class supports rendering with OpenGL
    and OpenGL ES. Qt includes the `QOpenGLPaintDevice` class, which allows the use
    of OpenGL accelerated `QPainter` rendering and several convenience classes. These
    convenience classes simplify writing code in OpenGL by hiding the complexities
    of extension handling and the differences between OpenGL ES 2.0 and desktop OpenGL.
    `QOpenGLFunctions` is a convenience class that provides cross-platform access
    to the OpenGL ES 2.0 functions on desktop OpenGL without the need to manually
    resolve the OpenGL function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of these APIs and classes on a qmake-based application, you have
    to include the `gui` module in your project file (`.pro`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a *Cmake*-based build system, then add the following to the
    `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `QPainter` class, primarily used for drawing operations, provides an API
    for various tasks such as drawing vector graphics, text, and images onto different
    surfaces, or `QPaintDevice` instances, including `QImage`, `QOpenGLPaintDevice`,
    `QWidget`, and `QPrinter`. For Qt Widgets user interfaces, Qt uses a software
    renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are Qt GUI''s high-level drawing APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Paint system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and filling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore these APIs in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the paint system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt's paint system provides several convenience classes for drawing on the screen.
    The most important classes used are `QPainter`, `QPaintDevice`, and `QPaintEngine`.
    You can use `QPainter` to paint on widgets and other paint devices. This class
    can be used to draw things from simple lines to complex shapes such as `QPainter`
    inside the `paintEvent()` function or inside a function invoked by a function
    called by `paintEvent()`. `QPaintDevice` is the base class of the objects that
    allow 2D drawing by using a `QPainter` instance. `QPaintEngine` provides the interface
    that defines how `QPainter` paints to a specified device on a specified platform.
    The `QPaintEngine` class is an abstract class that is used internally by `QPainter`
    and `QPaintDevice`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the hierarchy of painting-related classes to get a better
    idea of how to choose the right classes while using the paint system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The hierarchy of paint classes in Qt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The hierarchy of paint classes in Qt
  prefs: []
  type: TYPE_NORMAL
- en: The preceding hierarchical approach illustrates that all drawing approaches
    follow the same mechanism. So, it is easy to add provisions for new features and
    provide default implementations for unsupported ones.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the coordinate system in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the coordinate system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QPainter` class controls the coordinate system. It forms the basis of Qt's
    painting system along with the `QPaintDevice` and `QPaintEngine` classes. The
    default coordinate system of a paint device has its origin in the top-left corner.
    The primary function of `QPainter` is to perform drawing operations. While the
    `QPaintDevice` class is an abstraction of a two-dimensional space, which can be
    painted on using `QPainter`, the `QPaintEngine` class offers a painter with the
    interface to draw on different types of devices. The `QPaintDevice` class is the
    base class of objects that can be painted, which inherits its drawing capabilities
    from the `QWidget`, `QImage`, `QPixmap`, `QPicture`, and `QOpenGLPaintDevice`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the coordinate system in the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-6/coordsys.html
  prefs: []
  type: TYPE_NORMAL
- en: Drawing and filling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QPainter` provides a painter with highly optimized functions for most of the
    drawing requirements on the GUI. It can draw various types of shapes ranging from
    simple graphical primitives (such as `QPoint`, `QLine`, `QRect`, `QRegion`, and
    `QPolygon` classes) to complex shapes such as vector paths. The vector paths are
    represented by the `QPainterPath` class. `QPainterPath` works as a container for
    painting operations, allowing graphical shapes to be constructed and reused. It
    can be used for filling, outlining, and clipping. `QPainter` can also draw aligned
    text and pixmaps. To fill the shapes drawn by `QPainter`, you can use the `QBrush`
    class. It has color, style, texture, and gradient attributes and is defined with
    color and style.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the APIs discussed so far to draw using `QPainter`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with QPainter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QPainter` has several convenience functions to draw most primitive shapes,
    such as `drawLine()`, `drawRect()`, `drawEllipse()`, `drawArc()`, `drawPie()`,
    and `drawPolygon()`. You can fill the shapes using the `fillRect()` function.
    The `QBrush` class describes the fill pattern of shapes drawn by `QPainter`. A
    brush can be used to define the style, color, gradient, and texture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following `paintEvent()` function where we have used `QPainter`
    to draw text and different shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created a `QPainter` instance and painted
    a line, text, ellipse, arc, and pie using the available default drawing functions.
    When you add the preceding code into your custom class and run the project, you
    will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Output of drawing with QPainter example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Output of drawing with QPainter example
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides several offscreen drawing classes, each with its own set of advantages
    and disadvantages. `QImage`, `QBitmap`, `QPixmap`, and `QPicture` are the classes
    involved. In most cases, you must choose between `QImage` and `QPixmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QImage` class in Qt allows for easy image reading, writing, and manipulation.
    `QImage` is the class to use if you''re working with resources, combining multiple
    images, and doing some drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates an image that''s 128 pixels square, encoding each pixel
    a 32-bit integer – 8 bits for each channel of opacity, red, green, and blue. The
    second line creates a `QPainter` instance that can draw on the `QImage` instance.
    Next, we perform the drawing you just saw in the previous section, and when we''re
    done, we write the image to a PNG file, with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`QImage` supports several image formats, including PNG and JPEG. `QImage` also
    has a `load` method, where you can load an image from a file or resource.'
  prefs: []
  type: TYPE_NORMAL
- en: The `QBitmap` class is a monochromatic offscreen paint device that provides
    a pixmap with a depth of 1 bit. The `QPixmap` class provides an offscreen paint
    device. The `QPicture` class is a paint device that serializes `QPainter` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `QImageReader` and `QImageWriter` classes to have more
    fine-grained control over how images are loaded and saved. To add support for
    image formats other than those provided by Qt, image format plugins can be created
    using `QImageIOHandler` and `QImageIOPlugin`. The `QPainterPath` class helps in
    drawing different graphical shapes that can be created and reused. The following
    code snippet demonstrates how to use `QPainterPath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created a custom-drawn polygonal object with
    the desired painter path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that while doing a paint operation, ensure that there is no delay
    between painting the background and painting the content. Otherwise, you will
    notice flickering on the screen if the delay is more than 16 milliseconds. You
    can avoid this by rendering the background into a pixmap, then painting the content
    onto that pixmap. Finally, you can draw that pixmap onto the widget. This approach
    is known as **double buffering**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned not only how to draw an image on the screen,
    but also how to draw it off the screen and save it as an image file. In the next
    section, we will learn about the basics of the Graphics View framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Graphics View framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Graphics View framework is a powerful graphics engine that allows you to
    visualize and interact with a large number of custom-made 2D graphical items.
    If you are an experienced programmer, you can use the graphics view framework
    to draw your GUI and have it animated completely manually. To draw hundreds or
    thousands of relatively lightweight customized items at once, Qt provides a separate
    view framework, the Graphics View framework. You can make use of the Graphics
    View framework if you are creating your own widget set from scratch, or if you
    have a large number of items to display on the screen at once, each with its own
    position and data. This is especially important for applications that process
    and display a large amount of data, such as geographic information systems or
    computer-aided design software.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics View offers a surface for managing as well as interacting with a multitude
    of custom-created 2D graphical items, and a view widget for visualizing the items,
    with zooming and rotation support. The framework consists of an event propagation
    architecture that enables interaction capabilities for the scene's items. These
    items respond to key events; mouse press, move, release, and double-click events;
    as well as tracking mouse movement. Graphics View employs a **Binary Space Partitioning**
    (**BSP**) tree to provide very fast item discovery, allowing it to visualize large
    scenes in real time, even when there are millions of items.
  prefs: []
  type: TYPE_NORMAL
- en: The framework follows an item-based `approach` to model/view programming. It
    comprises three components, `QGraphicsScene`, `QGraphicsView`, and `QGraphicsItem`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QGraphicsItem` exposes an interface that your subclass can override to manage
    mouse and keyboard events, drag and drop, interface hierarchies, and collision
    detection. Each item has its own local coordinate system, and helper functions
    allow you to quickly transform an item''s coordinates to the scene''s coordinates.
    The Graphics View framework displays the contents of a `QGraphicsScene` class
    using one or more `QGraphicsView` instances. To see different parts of the scene,
    you can attach multiple views to the same scene, each with its own translation
    and rotation. Because the `QGraphicsView` widget is a scroll area, you can also
    attach scroll bars to the view and allow the user to scroll around it. The view
    receives keyboard and mouse input, generates scene events for the scene, and dispatches
    those scene events to the scene, which then dispatches those same events to the
    scene''s items. Previously, the framework was preferred for games development.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'We will skip the details about the usages of the framework and examples as
    it lost its popularity after Qt Quick 2 came into existence. Qt Quick 2 comes
    with the Scene Graph API, which provides most of the functionalities that were
    earlier offered by the Graphics View framework. If you''d still like to learn
    more about the Graphics View framework, you can read the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-6/graphicsview.html
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed Qt's Graphics View framework. In the next section,
    we will learn about OpenGL integration with Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Qt OpenGL module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick and Qt Widgets are the two main approaches to **user interface** (**UI**)
    development in Qt. They exist to support various types of UIs and are built on
    separate graphics engines that have been optimized for each of these. It is possible
    to combine OpenGL graphics API code with both of these UI types in Qt. This is
    useful when the application contains its own OpenGL-dependent code or when integrating
    with a third-party OpenGL-based renderer. The OpenGL/OpenGL ES XML API Registry
    is used to generate the OpenGL header.
  prefs: []
  type: TYPE_NORMAL
- en: The Qt OpenGL module is intended for use with applications that require OpenGL
    access. The convenience classes in the Qt OpenGL module help developers build
    applications more easily and faster. This module is responsible for maintaining
    compatibility with Qt 5 applications and Qt GUI. `QOpenGLWidget` is a widget that
    can add OpenGL scenes to UIs that use `QWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of Qt RHI as the rendering foundation in Qt, most classes
    denoted by `QOpenGL` have been moved to the Qt OpenGL module in Qt 6\. The classes
    are still usable and fully supported for applications that rely solely on OpenGL.
    They are no longer considered essential because Qt has been extended to support
    other graphics APIs, such as Direct3D, Metal, and Vulkan, in its foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Existing application code will mostly continue to work, but it should now include
    Qt OpenGL in project files, as well as the headers if they were previously included
    indirectly via Qt GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 6 no longer directly employs OpenGL-compatible GLSL source snippets. Shaders
    are instead written in Vulkan-style GLSL, reflected and translated to other shading
    languages, and packaged into a serializable `QShader` object that `QRhi` can consume.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shader preparation pipeline in Qt 6 is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Illustration of the shader preparation pipeline as described
    in the Qt blog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Illustration of the shader preparation pipeline as described in
    the Qt blog
  prefs: []
  type: TYPE_NORMAL
- en: 'With Qt 6.1, Qt Data Visualization supports only the OpenGL RHI backend. It
    requires the setting of the environment variable `QSG_RHI_BACKEND` to `opengl`.
    You can do this at the system level, or define it in `main()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss how the framework is used with Qt Widgets in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Qt OpenGL and Qt Widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Widgets is typically rendered by a highly optimized and accurate software
    rasterizer, with the final content being displayed on the screen using a method
    appropriate for the platform on which the application is running. However, Qt
    Widgets and OpenGL can be combined. The `QOpenGLWidget` class is the primary entry
    point for this. This class can be used to enable OpenGL rendering for a specific
    part of the widget tree, and the Qt OpenGL module's classes can be used to help
    with any application-side OpenGL code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`QWindow` or `QWidget` based applications with OpenGL implementations, there
    are no other options but to directly call the OpenGL APIs at runtime. For Qt Quick
    and Qt Quick 3D applications, Qt 6 introduced support for Direct3D 11, Vulkan,
    and Metal, in addition to OpenGL. On Windows, the default choice remains Direct3D,
    therefore the removal of ANGLE is eased by having support for graphics APIs other
    than OpenGL as well.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use Qt's Open GL module. Let's move on to
    the next section, where we'll discuss graphics in Qt Quick in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics in Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick is designed to take advantage of hardware-accelerated rendering. It
    will be built by default on the low-level graphics API that is most appropriate
    for the target platform. On Windows, for example, it will default to Direct3D,
    whereas on macOS, it will default to Metal. For rendering, Qt Quick applications
    make use of a scene graph. The scene graph renderer can make more efficient graphics
    calls, which improves performance. The scene graph has an accessible API that
    allows you to create complex but fast graphics. The Qt Quick 2D Renderer can also
    be used to render Qt Quick. This raster paint engine allows Qt Quick applications
    to be rendered on platforms that do not support OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Qt uses the most appropriate graphics API on the target platform by default.
    However, it is possible to configure Qt's rendering path to use a specific API.
    In many cases, selecting a specific API improves performance and allows developers
    to deploy on platforms that support a specific graphics API. To change the render
    path in `QQuickWindow`, you can use the `QRhi` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will have a look at some functionalities that
    will further enhance your graphics-related skills in Qt Quick. Let's begin by
    discussing how we can use OpenGL in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Qt OpenGL and Qt Quick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On platforms that support OpenGL, it is possible to manually select it as the
    active graphics API. In order to use this functionality when working with Qt Quick,
    the application should manually set the rendering backend to OpenGL in addition
    to adjusting project files and including headers.
  prefs: []
  type: TYPE_NORMAL
- en: With Qt 6, there is no direct way of OpenGL rendering using Qt Quick. The QRhi-based
    rendering path of the Qt Quick scene graph is now the new default. Aside from
    the defaults, the methods for configuring which QRhi backend and thus which graphics
    API to use remain largely unchanged from Qt 5.15\. One key difference in Qt 6
    is improved API naming. Now, you can set the RHI backend by calling the `QQuickWindow::setGraphicsApi()`
    function, whereas earlier this was achieved by calling the `QQuickWindow::setSceneGraphBackend()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the changes in the following article:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.qt.io/blog/graphics-in-qt-6.0-qrhi-qt-quick-qt-quick-3d
  prefs: []
  type: TYPE_NORMAL
- en: Custom Qt Quick items using QPainter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also make use of `QPainter` in your Qt Quick application. This can be
    done by subclassing `QQuickPaintedItem`. With the help of this subclass, you can
    render content using a `QPainter` instance. To render its content, the `QQuickPaintedItem`
    subclass uses an indirect 2D surface by either using software rasterization or
    using an **OpenGL Framebuffer Object** (**FBO**). Rendering is a two-step operation.
    The paint surface is rasterized before drawing. However, drawing using a scene
    graph is significantly faster than this rasterization approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the scene graph mechanism used by Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Qt Quick scene graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick 2 employs a dedicated scene graph that is traversed and rendered using
    a graphics API, including OpenGL, OpenGL ES, Metal, Vulkan, or Direct 3D. Using
    a scene graph for graphics instead of traditional imperative painting systems
    (`QPainter` and similar), allows the scene to be rendered to be retained between
    frames and the entire set of primitives to render to be known before rendering
    begins. This allows for a variety of optimizations, including batch rendering
    to reduce state changes and discarding obscured primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume a GUI comprises a list of 10 elements and each one has a different
    background color, text, and icon. This would give us 30 draw calls and an identical
    number of state changes using traditional drawing techniques. Contrarily, a scene
    graph reorganizes the primitives to render so that one call can draw all backgrounds,
    icons, and text, dropping the total number of draw calls to three. This type of
    batching and state change reduction can significantly improve performance on some
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph is inextricably linked to Qt Quick 2 and cannot be used independently.
    The `QQuickWindow` class manages and renders the scene graph, and custom `Item`
    types can add their graphical primitives to the scene graph by calling `QQuickItem::updatePaintNode()`.
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph represents an `Item` scene graphically and is a self-contained
    structure that has enough information to render all of the items. Once configured,
    it can be manipulated and rendered regardless of the state of the items. On several
    platforms, the scene graph is even rendered on a separate render thread while
    the GUI thread prepares the state for the next frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will dive deeper to improve our understanding
    of the scene graph structure and then learn the rendering mechanism. Further,
    we will be mixing the scene graph and the Native Graphics API while using Qt Quick
    3D.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick scene graph structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene graph is made up of a variety of predefined node types, each of which
    serves a specific purpose. Although we call it a scene graph, a node tree is a
    more precise definition. The tree is constructed from `QQuickItem` types in the
    QML scene, and the scene is then internally processed by a renderer, which draws
    the scene. There is no active drawing code in the nodes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Although the node tree is mostly built internally by the existing Qt Quick QML
    types, users can add complete subtrees with their own content, including subtrees
    that represent 3D models.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSGGeometryNode` is the most important node for users. It creates customized
    graphics by specifying their geometry and material. The `QSGGeometry` class describes
    the shape or mesh of the graphical primitive and is used to define the geometry.
    It can define everything, be it a line, a rectangle, a polygon, a collection of
    disconnected rectangles, or a complex 3D mesh. The material defines how the pixels
    for a specific shape are filled. There can be multiple children for a node. The
    geometry nodes are rendered as per the child order and the parent nodes can be
    found behind their children.'
  prefs: []
  type: TYPE_NORMAL
- en: The material describes how a geometry's interior in `QSGGeometryNode` is filled.
    It encapsulates graphics shaders for the vertex and fragment stages of the graphics
    pipeline and provides a great deal of flexibility in what can be done, even though
    the majority of Qt Quick items only use very basic materials such as solid color
    and texture fills.
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph API is low-level and prioritizes performance over convenience.
    Creating the most basic custom geometries and materials from scratch requires
    a significant amount of code input. As a result, the API includes a few convenience
    classes that make the most commonly used custom nodes easily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how the rendering is done in a scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering using a scene graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A scene graph is internally rendered in the `QQuickWindow` class, and there
    is no public API to access it. However, there are a few points in the rendering
    pipeline where the user can insert application code. These points can be used
    for adding custom scene graph content or for inserting arbitrary rendering commands
    by calling the scene graph's graphics API (OpenGL, Vulkan, Metal, and so on) directly.
    The render loop determines the integration points.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of render loops in a scene graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basic` is a single-threaded renderer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threaded` is a multithread renderer that renders on a different thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt tries to select an appropriate render loop based on the platform and underlying
    graphics capabilities. When this is not sufficient, or during testing, the environment
    variable `QSG_RENDER_LOOP` can be used to force the use of a specific type of
    renderer loop. You can find the type of render loop in use by enabling the `qt.scenegraph.general`
    logging category.
  prefs: []
  type: TYPE_NORMAL
- en: In most applications that use a scene graph, the rendering takes place on a
    separate render thread. This is done to improve multi-core processor parallelism
    and make better use of stall times such as waiting for a blocking swap buffer
    call. This provides significant performance improvements, but it limits where
    and when interactions with the scene graph can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how a frame is rendered using the threaded render
    loop and OpenGL. Apart from the OpenGL context specifics, the steps are the same
    for other graphics APIs as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Rendering sequence followed in a threaded render loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Rendering sequence followed in a threaded render loop
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the threaded renderer is used by default on Windows with Direct3D
    11 or higher. You can force the use of the threaded renderer by setting `QSG_RENDER_LOOP`
    to `threaded` in the environment. However, the threaded render loop depends on
    the graphics API implementation for throttling. When building with Xcode 10 or
    later on macOS and OpenGL, the threaded render loop is not supported. For Metal,
    there are no such limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your system is not capable of providing Vsync-based throttling, then use
    the basic render loop by setting the environment variable `QSG_RENDER_LOOP` to
    `basic`. The following steps describe how a frame is rendered in a basic or non-threaded
    render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Rendering sequence followed in a non-threaded render loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Rendering sequence followed in a non-threaded render loop
  prefs: []
  type: TYPE_NORMAL
- en: When the platform's standard OpenGL library is not used, then by default the
    non-threaded render loop is used on OpenGL-enabled platforms. This is primarily
    a preventive strategy for the latter because not all the combinations of OpenGL
    drivers and windowing systems have been verified. You may consider writing your
    code as if you are using the threaded renderer even if you are using the non-threaded
    render loop because otherwise, your code won't be portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find further information on the workings of the scene graph renderer, you
    may visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc-snapshots.qt.io/qt6-dev/qtquick-visualcanvas-scenegraph.html
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you got to know about the rendering mechanism behind the scene
    graph. In the next section, we will discuss how to mix a scene graph with the
    Native Graphics API.
  prefs: []
  type: TYPE_NORMAL
- en: Using a scene graph with the Native Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene graph provides two methods for mixing the scene graph with the Native
    Graphics APIs. The first approach is by directly issuing commands to the underlying
    graphics engine, and the second approach is by generating a textured node in the
    scene graph. Applications can make OpenGL calls directly into the same context
    as the scene graph by connecting to the `QQuickWindow::beforeRendering()` and
    `QQuickWindow::afterRendering()` signals. Applications using APIs such as Metal
    or Vulkan can request native objects, such as the scene graph's command buffer,
    through `QSGRendererInterface`. Then the user can render content either within
    or outside of the Qt Quick scene. The advantage of mixing the two is that no additional
    framebuffer or memory is required to execute the rendering, and a potentially
    costly texturing step is avoided. The disadvantage is that Qt Quick chooses when
    to invoke the signals. The OpenGL engine is only allowed to draw during that time.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Qt 6.0, direct use of the Native Graphics API must be invoked
    before the calls to the `QQuickWindow::beginExternalCommands()` and `QQuickWindow::endExternalCommands()`
    functions. This approach is identical to `QPainter::beginNativePainting()`, and
    it serves the same purpose. It allows the scene graph to identify any cached state
    or assumptions about the state inside the presently recorded render pass. If anything
    exists, then it becomes invalid as the code may have changed it by interacting
    directly with the Native Graphics API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When combining OpenGL content with scene graph rendering, it is crucial that
    the application doesn't leave the OpenGL context with buffers bound, attributes
    enabled, or specific values in the stencil buffer, or something similar. If you
    forget this, then you will see unexpected behavior. The custom rendering code
    must be thread-aware.
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph also provides support with several logging categories. These
    are useful in finding the root cause of performance issues and bugs. The scene
    graph features an adaptation layer in addition to the public API. The layer allows
    you to implement certain hardware-specific adaptations. It has an internal and
    proprietary plugin API that allows hardware adaption teams to get the most out
    of their hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are observing graphics-related issues or to find which type of rendering
    loop or graphics API is currently used, start the application by setting the environment
    variable `QSG_INFO` to `1` or by enabling at least `qt.scenegraph.general` and
    `qt.rhi.*`. During initialization, this will print some crucial information required
    to debug the graphics issues.
  prefs: []
  type: TYPE_NORMAL
- en: 3D graphics with Qt Quick 3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Qt Quick 3D** is a Qt Quick add-on that provides a high-level API for creating
    3D content and 3D user interfaces. It extends the Qt Quick scene graph, allowing
    you to integrate 3D content into 2D Qt Quick applications. Qt Quick 3D is a high-level
    API for creating 3D content and 3D user interfaces on the Qt Quick platform. Rather
    than relying on an external engine, which introduces syncing issues and additional
    layers of abstraction, we provide spatial content extensions to the existing Qt
    Quick scene graph, as well as a renderer for that extended scene graph. It is
    also possible to mix Qt Quick 2D and 3D content when using the spatial scene graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `import` statement in your `.qml` file can be used to import
    the QML types into your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the base Qt Quick 3D model, additional functionality is provided
    by the following module imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Qt Quick 3D is available for purchase under a commercial license. When building
    from source, make sure the modules and tools from the `qtdeclarative` and `qtshadertools`
    repositories are built first, as Qt Quick 3D cannot be used without them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss shader tools and shader effects in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Shader effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For importing shaders into 3D scenes, Qt Quick 3D has its own framework. **Shader
    effects** enable the full, raw power of a graphics processing unit to be directly
    utilized via vertex and fragment shaders. Too many shader effects can result in
    increased power consumption and sometimes slow performance, but when used sparingly
    and carefully, a shader can allow complex and visually appealing effects to be
    applied to a visual object.
  prefs: []
  type: TYPE_NORMAL
- en: Both shaders are bound to the `vertexShader` and `fragmentShader` properties.
    Every shader's code requires a `main(){…}` function, which is executed by the
    GPU. A variable with the prefix `qt_` is provided by Qt. To understand the variables
    in shader code, have a look at the OpenGL API reference document.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with `ShaderEffect` or subclassing `QSGMaterialShader` in QML
    applications using Qt Quick, the application must provide a baked shader pack
    in the form of a `.qsb` file. The Qt Shader Tools module includes a command-line
    tool called `.qsb` files. The `ShaderEffect` QML type and `QSGMaterial` subclasses,
    in particular, can make use of qsb output. It can also be used to inspect the
    contents of a `.qsb` package. The input file extension is used to determine the
    type of shader. As a result, the extension has to be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.vert` – Vertex shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.frag` – Fragment shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.comp` – Compute shaders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example assumes `myeffect.vert` and `myeffect.frag` contain Vulkan-style
    GLSL code, processed by the `qsb` tool in order to generate the `.qsb` files.
    Now we convert that Vulkan-Style shader with `qsb` via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see an example of using the preceding syntax in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is not necessary to specify both `vertexShader` and `fragmentShader`. Many
    `ShaderEffect` implementations will only provide a fragment shader in practice,
    instead of relying on the built-in vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the shader tools at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-6/qtshadertools-qsb.html
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use shader effects in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we arranged two images in a row. The first one is
    the original image and the second one is the image with the shader effect.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about different types of shader effects in Qt Quick
    and how to use the `qsb` tool to create compatible fragment files. In the next
    section, you will learn how to draw using `Canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Canvas QML type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Canvas` output as an image. It provides a 2D canvas that uses a `Context2D`
    object for drawing and implements a paint signal handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, first, we got the context from `getContext("2d")`.
    Then we drew a rectangle with a red border. The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Output of sample application using Canvas to draw a rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Output of sample application using Canvas to draw a rectangle
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you got familiar with drawing using `Canvas`. In the next section,
    we will discuss particle systems in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding particle simulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using particle systems, you can simulate effects such as explosions, fireworks,
    smoke, fog, and wind. Qt Quick includes a particle system that enables these types
    of complex, 2D simulations, including support for environmental effects such as
    gravity and turbulence. Particles are most commonly used in games to add subtle
    and visually appealing effects to currently selected items in lists or activity
    notifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '`ParticleSystem`, `Painters`, `Emitters`, and `Affectors` are the four main
    QML types in this particle system. The `ParticleSystem` system includes painter,
    emitter, and affector types. The `ParticleSystem` type connects all of these types
    and manages the shared timeline. They must all share the same `ParticleSystem`
    in order to interact. Subject to this constraint, you may have as many particle
    systems as you want, so the logical separation is to have one `ParticleSystem`
    type for all the types with which you want to interact, or just one if the number
    of types is small and easily controlled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `ParticleSystem`, import the module with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The emitter produces particles. The emitter can no longer change a particle
    after it has been emitted. You can use `affectors` type to influence particles
    after they have been emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each type of `affector` affects particles differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Age`: Modifies the particle''s lifespan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Attractor`: Draws particles towards a certain location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Friction`: Slows movement proportionate to the particle''s present velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gravity`: Sets acceleration at an angle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Turbulence`: Liquid-like behavior based on a noise image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Wander`: Changes the route randomly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupGoal`: Changes the state of a particle group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpriteGoal`: Changes the state of a sprite particle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand the use of `ParticleSystem` with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have used the Qt logo, which is emitting particles
    around it. We have created an instance of `ImageParticle` that creates particles
    that are emitted by `Emitter`. The `AngleDirection` type is used to decide the
    angle and direction of particle emission. Since we want the particles to be emitted
    around the logo, we have used `360` for both attributes. The output of the preceding
    example is shown in *Figure 8.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Output of the above particle system example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Output of the above particle system example
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore more about these QML types on the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: https://qmlbook.github.io/
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed different types of drawing mechanisms and components
    in Qt Quick. In the next section, we will learn how to do animation in Qt Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Animation in Qt Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animation framework simplifies the process of animating a GUI element by
    allowing its properties to be animated. `QPropertyAnimation` class, is one of
    the more common ways to animate a GUI element. This class is part of the animation
    framework, and it uses Qt's timer system to change the properties of a GUI element
    over a specified time period.
  prefs: []
  type: TYPE_NORMAL
- en: To create animations for our GUI application, Qt provides us with several subsystems,
    including a timer, timeline, animation framework, state machine framework, and
    the Graphics View framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss how to use property animation with `QPushButton` in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we animated a push button from one position to
    another position and changed the button size. You can add easing curve to control
    the animation simply by adding it to the property animation before calling the
    `start()` function. You can also experiment with different types of easing curves
    to see which one works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Property animations and animation groups are both inherited from the `QAbstractAnimator`
    class. Hence, you can add one animation group to another to create a more complex,
    nested animation group. Qt currently provides two types of animation group classes,
    `QParallelAnimationGroup` and `QSequentialAnimationGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `QSequentialAnimationGroup` group to manage the states of the
    animations within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can explore more about Qt''s animation framework at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-6/animation-overview.html
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed animation in Qt Widgets. In the next section,
    you will learn how to do animation in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Animation and transitions in Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to create animation and add transitions
    in Qt Quick. To create an animation, you need to choose a proper animation type
    for the type of the property that is to be animated and then apply the animation
    for the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Quick has different types of animations, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animator`: It is a special type of animation that operates directly on Qt
    Quick''s scene graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnchorAnimation`: It is used for animating an anchor change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParallelAnimation`: It runs animations in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParentAnimation`: It is used for animating a parent change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathAnimation`: It animates an item along a path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PauseAnimation`: It enables pauses during animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertyAnimation`: It animates changes in property values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequentialAnimation`: It runs animations sequentially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScriptAction`: During an animation, it allows JavaScript to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertyAction`: It can change a property immediately during an animation,
    without the need to animate a property change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 8.9* shows the hierarchy of animation classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The hierarchy of animation classes in Qt Quick'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – The hierarchy of animation classes in Qt Quick
  prefs: []
  type: TYPE_NORMAL
- en: '`PropertyAnimation` provides a way to animate changes to a property''s value.
    Different subclasses of `PropertyAnimation` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ColorAnimation`: Animates changes in color values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberAnimation`: Animates changes in `qreal`-type values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotationAnimation`: Animates changes in rotation values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector3dAnimation`: Animates changes in `QVector3d` values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be used to define animations in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In a `Transition`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a `Behavior`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a `property`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a `signal` handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Property values are animated by applying animation types to them. To create
    smooth transitions, animation types will interpolate property values. State transitions
    can also assign animations to state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SmoothedAnimation`: It is a specialized `NumberAnimation` subclass. In animation,
    when the target value is changed, `SmoothAnimation` ensures smooth changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpringAnimation`: With its specialized attributes including mass, damping,
    and epsilon, it provides a spring-like animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Animation can be set for an object in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct property animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predefined targets and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation as behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitions during state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations are created by applying animation objects to property values in order
    to change the properties gradually over time. Smooth movements are used in these
    property animations by interpolating values between property value changes. Property
    animations allow for different interpolations and timing controls via easing curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates two `PropertyAnimation` objects using
    predefined properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the animation will begin as soon as the `Rectangle`
    is loaded and is applied to its `x` and `y` values automatically. Here, we have
    used the `<AnimationType> on <Property>` syntax. Hence, it is not required to
    set the target and the property values to `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Animations may be shown sequentially or parallelly. While sequential animations
    play a group of animations serially, parallel animations play a group of animations
    at the same time. Therefore, when animations are grouped inside a `SequentialAnimation`
    or a `ParallelAnimation`, they will be played sequentially or parallelly. `SequentialAnimation`
    can also be used for playing `Transition` animations since transition animations
    are automatically played in parallel. You can group the animations to ensure that
    all animations within a group are applied to the same property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `SequentialAnimation` to animate the rectangle''s `color` in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used `SequentialAnimation` on the `color`
    property using the `<AnimationType> on <Property>` syntax. As a result, the child
    `ColorAnimation` objects are automatically added to this property, and no `target`
    or `property` animation values are needed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `Behavior` animations to set the default property animations. Animations
    specified in `Behavior` types are applied to the property and animate any property
    value changes. To intentionally enable or disable the behavior animations, you
    can use the `enabled` property. You can use several methods to assign behavior
    animations to properties. One of the methods is the `Behavior on <property>` declaration.
    It conveniently assigns a behavior animation onto a property.
  prefs: []
  type: TYPE_NORMAL
- en: '`Animator` types are distinct from normal `Animation` types. Let''s create
    a simple example where we rotate an image using an `Animator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used the `RotationAnimator` type, which is
    used to animate the rotation of an `Image` QML type.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed different types of animations in Qt Quick and
    created several examples. In the next section, we will discuss how to control
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Animation` type is the ancestor of all animation types. This type does not
    allow the creation of `Animation` objects. It equips a user with the necessary
    properties and methods to use animation types. All animation types consist of
    `start()`, `stop()`, `resume()`, `pause()`, `restart()`, and `complete()`, and
    they control how animations are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: The animation's interpolation between the start and end values is defined by
    the easing curves. Different easing curves may extend beyond the defined interpolation
    range. The easing curves make it easier to create animation effects such as bounce,
    acceleration, deceleration, and cyclical animations.
  prefs: []
  type: TYPE_NORMAL
- en: In a QML object, each property animation may have a distinct easing curve. The
    curve can be controlled with various parameters and some of these parameters are
    unique to a particular curve. Visit the easing documentation for more information
    on easing curves.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the way to control animations in Qt Quick.
    In the next section, you will learn how to use states and transitions.
  prefs: []
  type: TYPE_NORMAL
- en: States, state machine, and transitions in Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick states are property configurations in which a property's value can
    change to reflect different states. State changes cause abrupt changes in property;
    animations smooth transitions to create visually appealing state changes. Types
    for creating and executing state graphs in QML are provided by the Declarative
    State Machine Framework. Consider using the QML states and transitions for user
    interfaces with multiple visual states that are independent of the application's
    logical state.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import the state machine module and the QML types into your application
    by adding the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Please note that there are two ways to define the states in QML. One is provided
    by `QtQuick` and the other by the `QtQml.StateMachine` module.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: While using `QtQuick` and `QtQml.StateMachine` in a single QML file, make sure
    to import `QtQml.StateMachine` after `QtQuick`. In this approach, the `State`
    type is provided by the Declarative State Machine Framework, not by `QtQuick`.
    To avoid any ambiguity with QtQuick's `State` item, you can import `QtQml.StateMachine`
    into a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate property changes caused by state changes, the `Transition` type
    can include animation types. Bind the transition to the `transitions` property
    to assign it to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A button can have two states: `pressed` and `released`. For each state, we
    can assign a different property configuration. A transition would animate the
    transition from `pressed` to `released`. Similarly, there would be animation when
    switching from the `released` to the `pressed` state.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a circular LED using the `Rectangle` QML type and add a `MouseArea`
    to it. Assign the default state as `OFF` and the color as `green`. On mouse press,
    we want to change the LED color to `red` and once the mouse is released, the LED
    becomes `green` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the states. In this example, we have two states, `ON` and `OFF`.
    Here, we are manipulating the `color` property based on the state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add an animation to the transitions. Let''s add `ColorAnimation` to
    the transition to make it smooth and attractive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used two states, `ON` and `OFF`. We have used
    `MouseArea` to change the states based on mouse press and release events. When
    the state is `ON`, the rectangle color changes to `red`, and when it is `OFF`,
    the color changes to `green`. Here, we have also used `Transition` to switch between
    the states.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `to` and `from` properties are bound to the state''s name, the transition
    will be associated with the state change. For simple or symmetric transitions,
    setting the `to` property to the wild card symbol `"*"` implies that the transition
    applies to any state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can explore more about the State Machine QML API at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://doc.qt.io/qt-6/qmlstatemachine-qml-guide.html
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the state machine in Qt Quick. In the next
    section, you will learn how to use the state machine in Qt Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The state machine in Qt Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes in the State Machine framework are available for creating and executing
    state graphs. The State Machine framework provides an API and execution model
    for effectively embedding state chart elements and semantics in Qt applications.
    The framework is tightly integrated with Qt's meta-object system.
  prefs: []
  type: TYPE_NORMAL
- en: There was a major change to the State Machine framework in Qt 6\. The APIs were
    missing from the Qt 6.0.x core module. With Qt 6.1, the module was restored as
    the `statemachine` to the `.pro` file to use the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a `qmake` based build system, then add the following line
    to your `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a *CMake* based build system, then add the following to `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need the following headers inside your C++ source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a simple Qt Widgets application that implements the state-machine.
    Modify the UI form by adding `QLabel` and `QPushButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the constructor of your custom C++ class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a state to show the green-colored LED. Next,
    we will create another state for the red-colored LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add transitions for the state change events when the button is toggled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a state machine instance and add the states to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to start the state machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the previous example, you will see an output window like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Output of the application using the state machine in Qt Widgets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Output of the application using the state machine in Qt Widgets
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram reinforces that in a parent state machine, only the states
    of the child state machine can be specified as transition targets. States of the
    parent state machine, on the other hand, cannot be specified as targets of transitions
    in the child state machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following article nicely captures the performance considerations while
    using a state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.embedded.com/how-to-ensure-the-best-qt-state-machine-performance/
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about state machines and their usage in Qt Widgets.
    We discussed how to implement state machines in both Qt Widgets and Qt Quick.
    Let's summarize what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different graphics APIs and we learned how to
    use the `QPainter` class to draw graphics both on and off the screen. We also
    looked into the Graphics View framework and scene graph rendering mechanism. We
    saw how Qt provides the `QPaintDevice` interface and the `QPainter` class to perform
    graphics operations throughout this chapter. We also discussed the Graphics View
    classes, OpenGL framework, and shader tools. At the end of the chapter, we explored
    the animation and state machine framework in both Qt Widgets and Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B16231_09_Final_ASB_ePub.xhtml#_idTextAnchor221), *Testing
    and Debugging*, we will learn about debugging and testing in Qt. It will help
    you to find the root cause of issues and fix defects.
  prefs: []
  type: TYPE_NORMAL
