- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in *Chapter 4*, *Deciding the Best Cloud-Based Solution*, the
    serverless architecture is one of the newest ways to provide flexible software
    solutions. To do so, Microsoft Azure provides Azure Functions, an event-driven,
    serverless, and scalable technology that accelerates your project development.
    The main goal of this chapter is to get you familiar with Azure Functions and
    the best practices you can implement while using it. It is worth mentioning that
    the use of Azure Functions is a great alternative for having a serverless implementation
    that can accelerate your development. With them, you can deploy APIs faster, enable
    services triggered by timers, and even trigger processes by receiving events from
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Azure Functions app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Azure Functions using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – implementing Azure Functions to send emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to use Azure Functions in
    C# to speed up your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community Edition or better with all the Azure tools
    installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section of *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5/tree/master/ch10](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5/tree/master/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Azure Functions app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure Functions app is an Azure PaaS where you can build pieces of code
    (functions) and connect them to your application and use triggers to start them.
    The concept is quite simple – you build a function in the language you prefer
    and decide on the trigger that will start it. You can write as many functions
    as you want in your system. There are cases where the system is written entirely
    with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for creating the necessary environment are as simple as the ones
    we need to follow to create the function itself. The following screenshot shows
    the parameters that you must decide on when you create the environment. After
    you select **Create a resource** in Azure and filter by **Function App**, clicking
    the **Create** button, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Creating an Azure function'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of key points that you should consider while creating your
    Azure Functions environment. The possibilities given for running functions increase
    from time to time, as do the programming language options and publishing styles.
    One of the most important configurations we have is the hosting plan, which is
    where you will run your functions. There are three options for the hosting plan:
    a Consumption (Serverless), Premium, and App Service plan. Let''s talk about these
    now.'
  prefs: []
  type: TYPE_NORMAL
- en: Consumption plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you choose a Consumption plan, your functions will only consume resources
    when they are executed. This means that you will only be charged while your functions
    are running. Scalability and memory resources will be automatically managed by
    Azure. This is truly what we call serverless.
  prefs: []
  type: TYPE_NORMAL
- en: Something we need to take note of while writing functions in this plan is the
    timeout. By default, after 5 minutes, the function will timeout. You can change
    the timeout value using the `functionTimeout` parameter in the `host.json` file.
    The maximum value is 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: When you choose the Consumption plan, the way in which you will be charged will
    depend on what you are executing, execution time, and memory usage. More information
    on this can be found at [https://azure.microsoft.com/en-us/pricing/details/functions/](https://azure.microsoft.com/en-us/pricing/details/functions/).
  prefs: []
  type: TYPE_NORMAL
- en: Note that this can be a good option when you do not have App Services in your
    environment, and you are running functions with low periodicity. On the other
    hand, if you need continuous processing, you may want to consider the App Service
    plan.
  prefs: []
  type: TYPE_NORMAL
- en: Premium plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on what you use your functions for, especially if they need to run
    continuously or almost continuously, or if some function executions take longer
    than 10 minutes, you may want to consider a Premium plan. Besides, you may need
    to connect your function to a VNET/VPN environment, and in this case, you will
    be forced to run in this plan.
  prefs: []
  type: TYPE_NORMAL
- en: You may also need more CPU or memory options than what is provided with the
    Consumption plan. The Premium plan gives you one core, two core, and four core
    instance options.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that even with unlimited time to run your function, if
    you decide to use an HTTP trigger function, 230 seconds is the maximum allowed
    for responding to a request. The reason why this is a limit is related to Azure
    Load Balancer. You may have to redesign your solution in such situations to adhere
    to the best practices set by Microsoft ([https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices](https://docs.microsoft.com/en-us/azure/azure-functions/functions-best-practices)).
  prefs: []
  type: TYPE_NORMAL
- en: App Service plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The App Service plan is one of the options you can choose when you want to
    create an Azure Functions app. The following is a list of reasons (suggested by
    Microsoft) as to why you should use the App Service plan instead of the Consumption
    plan to maintain your functions:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use underutilized existing App Service instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to run your function app on a custom image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the App Service plan scenario, the `functionTimeout` value varies according
    to the Azure Function runtime version. However, the value is at least 30 minutes.
    You may find a tabled comparison between the timeouts in each consumption plan
    at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale#timeout](https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale#timeout).
  prefs: []
  type: TYPE_NORMAL
- en: Programming Azure functions using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to create Azure functions. It is worth mentioning
    that there are several ways to create them using C#. The first one is by creating
    the functions and developing them in the Azure portal itself. To do this, let
    us consider that you have created an Azure Functions app with similar configurations
    to the ones from the screenshot at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting the resource created and navigating to the **Functions** menu,
    you will be able to **Add** new functions to this environment, as you can see
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Adding a function'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will need to decide the kind of trigger that you want to use to start
    the execution. The most frequently used ones are **HTTP trigger** and **Timer
    trigger**. The first enables the creation of an HTTP API that will trigger the
    function. The second means functions will be triggered by a timer set according
    to your decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you decide on the trigger you want to use, you must name the function.
    Depending on the trigger you decide on, you will have to set up some parameters.
    For instance, HTTP trigger requires that you set up an authorization level. Three
    options are available, that is, **Function**, **Anonymous**, and **Admin**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Configuring an HTTP function'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that this book does not cover all the options that are
    available when it comes to building functions. As a software architect, you should
    understand that Azure provides a good service for serverless architectures in
    terms of functions. This can be useful in several situations. This was discussed
    in more detail in *Chapter 4*, *Deciding the Best Cloud-Based Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this is as follows. Notice that Azure provides an editor that
    allows us to run the code, check logs, and test the function that we have created.
    This is a good interface for testing and coding basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: HTTP function environment'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to create more sophisticated functions, you may need a
    more sophisticated environment so that you can code and debug them more efficaciously.
    This is where the Visual Studio Azure Functions project can help you. Besides,
    using Visual Studio to execute the development of the function moves you in the
    direction of using source control and CI/CD for your functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio, you can create a project dedicated to Azure Functions by
    going to **Create a new project**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Creating an Azure Functions project in Visual Studio 2019'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have submitted your project, Visual Studio will ask you for the type
    of trigger you are using and for the Azure version that your function will run
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Creating a new Azure Functions application'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that Azure Functions supports different platforms and
    programming languages. At the time of writing, there are three runtime versions
    of Azure Functions, and C# can run in all of them. The first version is compatible
    with .NET Framework 4.7\. In the second one, you can create functions that run
    on .NET Core 2.2\. In the third one, you will be able to run .NET Core 3.1 and
    .NET 5.
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must keep code reusability in mind. In this case,
    you should pay attention to which version of Azure Functions Project you will
    decide to build your functions in. However, it is always recommended that you
    use the latest version of the runtime, as soon as it acquires general availability
    status.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the code that is generated is like that generated when you create
    Azure functions in the Azure portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The publish method follows the same steps as the publish procedure for web apps
    that we described in *Chapter 1*, *Understanding the Importance of Software Architecture*.
    However, it is always recommended to use a CI/CD pipeline, as we are going to
    describe in *Chapter 20*, *Understanding DevOps Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Azure Functions templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several templates in the Azure portal that you can use in order to
    create Azure functions. The number of templates that you can choose from is updated
    continuously. The following are just a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blob Trigger**: You may want to process something for a file as soon as this
    file is uploaded to your blob storage. This can be a good use case for Azure Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cosmos DB Trigger**: You may want to synchronize data that arrives in a Cosmos
    DB database with a processing method. Cosmos DB was discussed in detail in *Chapter
    9*, *How to Choose Your Data Storage in the Cloud*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Grid Trigger**: This is a good way to manage Azure events. Functions
    can be triggered so that they manage each event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Hub Trigger**: With this trigger, you can build functions that are
    linked to any system that sends data to Azure Event Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Trigger**: This trigger is useful for building serverless APIs and web
    app events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT Hub Trigger**: When your application is connected to devices through
    the use of IoT Hub, you can use this trigger whenever a new event is received
    by one of the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue Trigger**: You can handle queue processing using a function as a service
    solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Bus Queue Trigger**: This is another messaging service that can be
    a trigger for functions. Azure Service Bus will be covered in more detail in *Chapter
    11*, *Design Patterns and .NET 5 Implementation*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer Trigger**: This is commonly used with functions and is where you specify
    time triggers so that you can continuously process data from your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining Azure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created and programmed your function, you need to monitor and
    maintain it. To do this, you can use a variety of tools, all of which you can
    find in the Azure portal. These tools will help you solve problems due to the
    amount of information you will be able to collect with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option when it comes to monitoring your function is using the **Monitor**
    menu inside the Azure Functions interface in the Azure portal. There, you will
    be able to check all your function executions, including successful results and
    failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Monitoring a function'
  prefs: []
  type: TYPE_NORMAL
- en: It will take about 5 minutes for any results to be available. The date shown
    in the grid is in UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on **Run query in Application Insights**, the same interface allows
    you to connect to this tool. This will take you to a world of almost infinite
    options that you can use to analyze your function data. Application Insights is
    one of the best **Application Performance Management** (**APM**) systems available
    nowadays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Monitoring using Application Insights'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the query interface, you can also check all the performance issues of
    your function using the Insights interface in the Azure portal. There, you can
    analyze and filter all the requests that have been received by your solution and
    check their performance and dependencies. You can also trigger alerts when something
    abnormal happens to one of your endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Monitoring using Application Insights Live Metrics'
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will find a good daily helper for your projects
    in this tool. It is worth mentioning that Application Insights works on several
    other Azure services, such as web apps and virtual machines. This means that you
    can monitor the health of your system and maintain it using the wonderful features
    provided by Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – Implementing Azure Functions to send emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will use a subset of the Azure components we described previously.
    The use case from WWTravelClub proposes a worldwide implementation of the service,
    and there is a chance that this service will need different architecture designs
    to face all the performance key points that we described in *Chapter 1*, *Understanding
    the Importance of Software Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: If you go back to the user stories that were described in *Chapter 1*, *Understanding
    the Importance of Software Architecture*, you will find that many needs are related
    to communication. Because of this, it is common to have some alerts be provided
    by emails in the solution. The use case of this chapter will focus on how to send
    emails. The architecture will be totally serverless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the basic structure of the architecture. To give
    users a great experience, all the emails that are sent by the application will
    be queued asynchronously, thereby preventing significant delays in the system''s
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Architectural design for sending emails'
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are no servers that manage Azure functions for enqueuing or
    dequeuing messages from Azure Queue Storage. This is exactly what we call serverless.
    It is worth mentioning that this architecture is not restricted to only sending
    emails – it can also be used to process any HTTP `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will learn how to set up security in the API so that only authorized
    applications can use the given solution.
  prefs: []
  type: TYPE_NORMAL
- en: First step – Creating Azure Queue storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite simple to create storage in the Azure portal. Let us learn how.
    First, you will need to create a storage account by clicking on **Create a resource**
    in the main page of the Azure portal and searching for **Storage account**. Then,
    you will be able to set up its basic information, such as **Storage account name**
    and **Location**. Information about **Networking**, and **Data protection**, as
    shown in the following screenshot, can be checked in this wizard too. There are
    default values for these settings that will cover the demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Creating an Azure storage account'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the storage account in place, you will be able to set up a queue.
    You will find this option by clicking on the **Overview** link in the storage
    account and selecting the **Queues** option, or by selecting **Queues** via the
    storage account menu. Then, you will find an option to add the queue (**+ Queue**),
    where you just need to provide its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Defining a queue to monitor emails'
  prefs: []
  type: TYPE_NORMAL
- en: 'The created queue will give you an overview of the Azure portal. There, you
    will find your queue''s URL and use Storage Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Queue created'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you will also be able to connect to this storage using Microsoft
    Azure Storage Explorer ([https://azure.microsoft.com/en-us/features/storage-explorer/](https://azure.microsoft.com/en-us/features/storage-explorer/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Monitoring the queue using Microsoft Azure Storage Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: This tool is especially useful if you are not connected to the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: Second step – Creating the function to send emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you can start programming in earnest, informing the queue that an email
    is waiting to be sent. Here, we need to use an HTTP trigger. Note that the function
    is a static class that runs asynchronously. The following code is gathering the
    request data coming from the HTTP trigger and inserting the data into a queue
    that will be treated later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In some scenarios, you may try to avoid the queue setup indicated in the preceding
    code by using a queue output binding. Check the details at [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue-output?tabs=).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a tool such as Postman to test your function by running the Azure
    Functions Emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Postman function test'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will appear in Microsoft Azure Storage Explorer and the Azure portal.
    In the Azure portal, you can manage each message and dequeue each of them or even
    clear the queue storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: HTTP trigger and queue storage test'
  prefs: []
  type: TYPE_NORMAL
- en: Third step – Creating the queue trigger function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After this, you can create a second function. This one will be triggered by
    data entering your queue. It is worth mentioning that, for Azure Functions v3,
    you will have the `Microsoft.Azure.WebJobs.Extensions.Storage` library added as
    a NuGet reference automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Creating a queue trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set the connection string inside `local.settings.json`, you will
    be able to run both functions and test them with Postman. The difference is that,
    with the second function running, if you set a breakpoint at the start of it,
    you will check whether the message has been sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_10_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: Queue triggered in Visual Studio 2019'
  prefs: []
  type: TYPE_NORMAL
- en: From this point, the way to send emails will depend on the mail options you
    have. You may decide to use a proxy or connect directly to your email server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several advantages to creating an email service this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Once your service has been coded and tested, you can use it to send emails from
    any of your applications. This means that your code can always be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps that use this service will not be stopped from sending emails due to the
    asynchronous advantages of posting in an HTTP service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not need to pool the queue to check whether data is ready for processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the queue process runs concurrently, which delivers a better experience
    in most cases. It is possible to turn it off by setting some properties in `host.json`.
    All the options for this can be found in the *Further reading* section at the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the advantages of developing functionality
    with serverless Azure functions. You can use it as a guideline for checking the
    different types of triggers that are available in Azure Functions and for planning
    how to monitor them. We also saw how to program and maintain Azure functions.
    Finally, we looked at an example of an architecture where you connect multiple
    functions to avoid pooling data and to enable concurrent processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will analyze the concept of design patterns, learn why
    they are so useful, and learn about some of the common patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are Azure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the programming options for Azure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the plans that can be used with Azure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you deploy Azure functions with Visual Studio?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What triggers can you use to develop Azure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Azure Functions v1, v2, and v3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Application Insights help us to maintain and monitor Azure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to learn more when it comes to creating Azure functions, check
    out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure Functions scale and hosting: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale](https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure Functions – Essentials [Video]*, by Praveen Kumar Sreeram: [https://www.packtpub.com/virtualization-and-cloud/azure-functions-essentials-video](https://www.packtpub.com/virtualization-and-cloud/azure-functions-essentials-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions runtime overview: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An overview of Azure Event Grid: [https://azure.microsoft.com/en-us/resources/videos/an-overview-of-azure-event-grid/](https://azure.microsoft.com/en-us/resources/videos/an-overview-of-azure-event-grid/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer trigger for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Application Insights section from the book, *Azure for Architects*, by
    Ritesh Modi: [https://subscription.packtpub.com/book/virtualization_and_cloud/9781788397391/12/ch12lvl1sec95/application-insights](https://subscription.packtpub.com/book/virtualization_and_cloud/9781788397391/12/ch12lvl1sec95/appli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring Azure Functions using the Application Insights section from the
    book, *Azure Serverless Computing Cookbook*, by Praveen Kumar Sreeram: [https://subscription.packtpub.com/book/virtualization_and_cloud/9781788390828/6/06lvl1sec34/monitoring-azure-functions-using-application-insights](https://subscription.packtpub.com/book/virtualization_and_cloud/9781788390828/6/06lvl1sec34/monitori)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get started with Azure Queue storage using .NET: [https://docs.microsoft.com/en-us/azure/storage/queues/storage-dotnet-how-to-use-queues](https://docs.microsoft.com/en-us/azure/storage/queues/storage-dotnet-how-to-use-queues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions triggers and bindings concepts: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Queue storage bindings for Azure Functions: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
