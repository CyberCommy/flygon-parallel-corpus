- en: Chapter 3. Handling Inputs and Outputs with GPIOs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you prepared your development PC and BBBAndroid system
    for the development of hardware-interfacing Android apps. Now that your development
    environment is set up and ready to go, you will begin exploring your very first
    app that is capable of direct communication with hardware connected to the BBB.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '**General**-**Purpose Input/Output** (**GPIO**) is one of the most basic interfaces
    in digital electronics. In the examples within this chapter, you will be working
    with GPIOs to receive digital input signals from the outside world and send digital
    output signals back in response. While this is a small start, it is the first
    step in developing and understanding hardware-interfacing apps that are much more
    complex. GPIOs can be used to implement complex and powerful interfacing logic.
    We will discuss both the hardware and software sides of GPIO interfacing and explain
    how calling Java methods in Android apps can interface with low-level hardware-interfacing
    code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GPIOs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a GPIO interface circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including PacktHAL within your apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the GPIO example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPIOs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its most basic level, communication between two pieces of hardware requires
    the transmission of data back and forth between them. In computer systems, this
    data is represented as voltage levels sent over a wire that connects the devices
    together. The patterns and levels of voltage back and forth form a communication
    protocol that the devices use to transmit data between each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: GPIO is the most basic interfacing option offered by microcontrollers and microprocessors.
    Some pins of the BBB's processor are allocated as GPIOs that act as an *input*
    (monitoring voltage on the wire to receive data) or an *output* (placing a particular
    voltage on the wire to send data). The BBB has dozens of available GPIO pins,
    which makes GPIO a flexible and simple way for Android apps to interact with the
    outside world without requiring fancy device drivers or extra interfacing hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Nuts and bolts of GPIO
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital logic operates on the concept that there are two discrete voltage levels
    that represent an *on/high* state and an *off/low* state. By toggling between
    these two states, binary bits of data are transmitted between devices. The BBB
    uses the voltage of 3.3 V for its high level and a voltage of 0 V (connected to
    a ground) for the low level. This voltage scheme is known as a *3.3 V logic level*,
    and it is commonly used for single-board computers such as the BeagleBoard and
    Raspberry Pi. Many microcontrollers (many Arduinos, for example) use a 5 V logic
    level instead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Never apply more than 3.3 V to any BBB pin!**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Applying greater than 3.3 V to a BBB GPIO can fry the BBB's processor, so always
    make sure that you only work with a maximum of 3.3 V when designing the GPIO interface
    circuitry for the BBB. Pins P9.3/4 supply 3.3 V, and pins P9.5/6 supply 5 V. It
    is very simple to accidentally connect a breadboard wire to the pins supplying
    5 V when you intended to use the 3.3 V pins. To help avoid this mistake, try covering
    the P9.5/6 pins with a piece of tape. This prevents you from accidentally inserting
    a breadboard wire into these pins.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The BBB's processor has four banks of GPIOs, with 32 individual GPIOs in each
    bank. With only 92 pins available on the P8/9 connectors, it is not possible to
    give every GPIO access to the outside world. In fact, the BBB's System Reference
    Manual shows that it is only possible to mux about 65 unique GPIOs to P8/P9 at
    the same time, even if every other feature being muxed to P8/9 was disabled. There
    are a few other GPIOs that are used internally for tasks such as lighting and
    blinking the BBB's LEDs, but you should consider yourself restricted to only using
    the GPIOs that are accessible via P8/P9 and that do not conflict with any of the
    standard BBB features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: GPIO access methods under Android
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two basic approaches to interacting with GPIOs on the BBB: **file
    I/O** and **memory-mapping**. With the file I/O, you pass GPIO requests through
    a kernel driver by reading and writing to GPIO files in the filesystem. With memory-mapping,
    you map the GPIO control resistors into memory and then read and write these mapped
    memory locations to directly manipulate the control resistors. As both of these
    methods are made possible by the Linux kernel, they will both work just as well
    under Android as they do under Linux.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of the file I/O method
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file I/O method can be performed by any process that has the proper permissions
    to read/write the GPIO device files. However, like any file I/O operation, this
    can be quite slow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of the memory-mapping method
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory-mapping method allows you to directly access the resistors that control
    the GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!),
    but only processes with root permissions can use it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: As your apps are unable to execute with root permissions without some serious
    permission changes, you will be unable to use memory-mapping to access GPIOs.
    This effectively restricts you to only using file I/O for your apps.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PacktHAL implements both memory-mapping and file I/O for GPIO access. If you
    are interested in the low-level details of how both of these approaches work,
    examine the `jni/gpio.c` file in `PacktHAL.tgz`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android for GPIO use
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files from PacktHAL
    to your Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable specific GPIOs and allow your apps to
    access them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that when we talk about the `init.{ro.hardware}.rc` file, we are referring
    to the `init.genericam33xx(flatteneddevice.tr` file in the root directory of the
    Android filesystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BB-PACKTPUB-00A0.dtbo` file is a Device Tree overlay that muxes the BBB
    to support all of the examples in this book. As far as GPIOs are concerned, this
    overlay muxes the P9.11 and P9.13 pins into GPIOs. In the `PacktHAL.tgz` file,
    the source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts`
    file. The code responsible for muxing the two GPIOs is located in the `bb_gpio_pins`
    node within `fragment@0`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The details of the hex values used in the `bb_gpio_pins` node are beyond the
    scope of this book. However, the general idea is that they specify which pin is
    of interest, which mode the pin should be muxed to, a few details about pull-up/pull-down
    resistors, whether it is an input or an output pin, and whether any skewing adjustments
    should be made to the signal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The details of what skew is and how to adjust for it are beyond the scope of
    this book. If you would like to learn more about skewing, we suggest the Wikipedia
    page on the subject as a good starting point ([http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: At boot, this overlay is loaded by the `init.{ro.hardware}.rc` file. The kernel
    then knows which pins are treated as GPIOs. After loading the overlay, the `init.{ro.hardware}.rc`
    file then executes a few commands that explicitly "unlock" these GPIO files for
    use by apps by *exporting* them. Exporting a GPIO pin creates a series of files
    in the `/sys` filesystem that can be read and written to interact with that GPIO
    pin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'By exporting a GPIO pin and then changing the permissions of the proper files
    in the `/sys` filesystem via `chmod`, any process can read from or write to GPIOs.
    This is exactly what the commands in the `init.{ro.hardware}.rc` file do to allow
    Android apps to interface with GPIOs. The following portion of the `init.{ro.hardware}.rc`
    file performs the export and `chmod` operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each GPIO has a specific integer identifier that is determined by the bank the
    GPIO belongs to and its position within that bank. In our case, the GPIO muxed
    to P9.11 is the 30th GPIO in bank 0, and P9.13 is the 31st GPIO in bank 0\. This
    makes their integer identifiers 30 and 31, respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPIO pins 30 and 31 are only available via the `/sys` filesystem because
    they were explicitly exported via the `write` commands in the `init.{ro.hardware}.rc`
    file. Other GPIO pins will not be available via the filesystem unless they are
    also explicitly exported in the same fashion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This is a very insecure way of allowing GPIO access because it opens up the
    GPIOs for use by processes that we might not want to have direct access to them.
    For experimentation and prototyping, this is not a problem. However, you certainly
    should not do this in a commercial system. Unless you develop a proper, privileged
    Android manager to handle the GPIO resources, you must allow *all* processes to
    access the GPIO files unless you tailor the permissions to only be usable by apps
    belonging to a specific user or group. As each app is assigned its own user, you
    would have to chown the GPIOs to the proper user and group after you install the
    app's `.apk` file onto the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Building a GPIO-interfacing circuit
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you begin developing software that communicates using GPIOs, you must
    first construct a hardware circuit for the GPIOs to interface with. For this chapter,
    you will build a simple circuit that consists of a 1k ohm resistor, an LED, and
    a pushbutton switch. Part numbers and suppliers for these components were listed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction to Android
    and the BeagleBone Black"), *Introduction to Android and the BeagleBone Black*.
    Before getting started, be sure that you have all of the proper parts and remove
    all power sources from your BBB (unplug the power supply and USB cables) prior
    to connecting anything to the BBB's P8/P9 connector.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t disassemble your circuit!**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as it is
    positioned in the following diagram (towards the top of the breadboard), you can
    simply leave the GPIO components and wires in place as you build the remaining
    circuits in this book. This way, it will already be constructed and working when
    you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete
    Interfacing Solution").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the circuit
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The circuit that you will build interfaces with the following four BBB''s pins:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: P9.1 (ground)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.3 (3.3 V)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.11 (GPIO)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.13 (GPIO)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The P9.11 pin is configured as an output GPIO, and it drives the LED. The P9.13
    pin is configured as an input GPIO, and it sets its state depending upon the input
    voltage that is applied to it. Both GPIO pins are configured by the `BB-PACKTPUB-00A0.dtbo`
    overlay to use an internal pull-up resistor. If you are not familiar with what
    a pull-up resistor is, don't worry. For the purposes of these examples, it simply
    means that the logic level of the GPIOs will not "float" between on and off if
    nothing is attached to the GPIO pins. Instead, the logic level will be "pulled-up"
    to the on state.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested in learning more about what a pull-up resistor is and how it works?
    We suggest that you check out this online tutorial on pull-up and pull-down resistors,
    available at [http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Breadboards typically have two vertical buses on either side that run almost
    the entire length of the breadboard. These buses are used to provide convenient
    access to power and ground signals for any components inserted into the breadboard.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing the circuit](img/00010.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: The complete GPIO-interfacing circuit
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start constructing our circuit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Connect the BBB's ground (P9.1) and 3.3 V (P9.3) signals to the two vertical
    buses on the breadboard. The ground bus is the vertical bus towards the center
    of the breadboard. The 3.3 V bus is the vertical bus towards the edge of the breadboard.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the anode, or the positive lead, of the LED to P9.11\. LEDs have
    a polarity, so current will only flow through them in one direction. Current flows
    from the longer lead (the anode) of the LED to the shorter lead (the cathode).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the LED's leads have been cut to the same length and you are unable to tell
    which lead is which, feel around the edge of the LED's plastic casing. The edge
    of the casing is flat on the cathode side and rounded on the anode side. As long
    as the cathode is connected to the ground and the anode is connected to the GPIO
    pin, the LED will work properly.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must limit the current drawn by the LED to ensure that you do not damage
    the GPIO pin, so place a 1K ohm resistor between the LED's cathode lead and the
    ground signal. Resistors do not have a polarity like LEDs do, so the direction
    that you connect it to the breadboard will not matter.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to learn more about using a current-limiting resistor with an LED,
    such as selecting the right resistor for the task, we suggest that you read the
    tutorial from SparkFun, available at [https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now that the LED and resistor have been connected to the BBB, you must connect
    the pushbutton switch. Different switches have different numbers of leads, but
    the switch that we suggested for your use has a total of four leads. These leads
    form two pairs of two leads each. The two leads in each pair are always electrically
    connected to each other, but one pair will only be electrically connected to the
    other pair when the button is being pressed. Two sides of the switch are smooth,
    and the other two sides have two protruding leads on each side. The two protruding
    leads on a single side of the switch belong to different pairs of leads. Pick
    one side of the switch with two leads on it and connect one lead to P9.13 and
    the other lead to the breadboard's ground bus.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your circuit is now complete. Double-check your wiring against the diagram of
    the complete GPIO-interfacing circuit to ensure that everything is connected properly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Checking your wiring
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have completed the wiring of the GPIO circuit, you should test it to
    ensure that it works properly. Luckily, you can do this easily by shelling into
    the BBB and working with the exported GPIO pin files. We will assume that you
    are using `adb` to shell into the Android system, but using the FTDI to access
    the console shell will work in exactly the same way.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How do I use the FTDI cable?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: If you have never used an FTDI cable to communicate with your BBB, there is
    a page on the [www.elinux.org](http://www.elinux.org) wiki (maintained by the
    BeagleBoard.org staff) that can help you get started, which is [http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will only be using the USB cable and ADB shell to access the
    BBB. However, learning how to use the FTDI to monitor and troubleshoot your BBB
    can really come in handy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect power to your BBB and then use the USB cable to connect the BBB to
    your development system. After shelling into the BBB, begin testing your GPIO
    circuit using the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the directory for the GPIO pin muxed to P9.11 (GPIO pin 30):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `echo` command to turn the LED on by forcing the state of this GPIO
    to 1:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The LED will now be turned on. Use the `echo` command to turn the LED off by
    forcing the state of this GPIO to 0:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The LED will now be turned off. Change into the directory for the GPIO pin
    muxed to P9.13 (the GPIO pin 31):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the `cat` command to check the current state of the pushbutton switch.
    When executing this command, make sure that you are not pushing the button:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令检查当前的按钮开关状态。执行此命令时，请确保您没有按下按钮：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, execute the following `cat` command while holding down the button. You
    should type the entire command, press the button, and then hit the *Enter* key
    to enter the command while still holding the button down:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在按住按钮时执行以下`cat`命令。您应该输入整个命令，按下按钮，然后按*Enter*键输入命令，同时保持按下按钮：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pushbutton values look reversed because of how the circuit is wired. The
    pull-up resistor on P9.13 will pull the value of the GPIO to `1` when the button
    is not pressed. When the button is pressed, the P9.13 pin becomes connected to
    the ground signal and changes the GPIO to `0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电路的布线方式，按钮的值看起来是相反的。P9.13上的上拉电阻在按钮未按下时将GPIO的值拉到`1`。当按下按钮时，P9.13引脚连接到地信号并将GPIO更改为`0`。
- en: If you saw the LED turn on and off and the correct values were returned when
    the switch was pressed and released, you have correctly wired the circuit. If
    the LED did not light up, make sure that you have not accidentally swapped the
    anode and cathode leads of the LED. If the switch always returns a value of 0,
    make sure that you have connected the correct pair of leads on the switch to the
    ground signal bus and P9.13.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到LED在按下和释放开关时打开和关闭，并且返回了正确的值，那么您已经正确地连接了电路。如果LED没有亮起，请确保您没有意外交换LED的阳极和阴极引线。如果开关始终返回值为0，请确保您已将开关上的正确引线连接到地信号总线和P9.13。
- en: Including PacktHAL within your apps
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中包含PacktHAL
- en: Before diving into using PacktHAL to interface with GPIOs, you must understand
    how to include PacktHAL support in your apps. We will walk you through the process
    of adding the PacktHAL code into your app and then building it. PacktHAL will
    be packaged with your app in the`.apk` app as a shared library. The source code
    for the library exists within the app's project directory, but it is built separately
    from the Java code of the app. You must manually build the PacktHAL shared library
    before your app can include it within the `.apk` app and use it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用PacktHAL与GPIO进行接口之前，您必须了解如何在应用程序中包含PacktHAL支持。我们将带您完成将PacktHAL代码添加到您的应用程序中，然后构建它的过程。PacktHAL将作为共享库打包到您的应用程序中的`.apk`应用程序中。库的源代码存在于应用程序项目目录中，但与应用程序的Java代码分开构建。在您的应用程序可以将其包含在`.apk`应用程序中并使用它之前，您必须手动构建PacktHAL共享库。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We include a prebuilt version of the PacktHAL library in each of the example
    app projects included with this book, so you can jump into building and running
    the example apps right away without worrying about the details of building PacktHAL.
    Once you begin creating your own custom apps and modifying PacktHAL for your own
    hardware projects, you will need to understand how to build PacktHAL from source.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中包含的每个示例应用程序项目中都包含了PacktHAL库的预构建版本，因此您可以立即开始构建和运行示例应用程序，而不必担心构建PacktHAL的细节。一旦您开始创建自己的自定义应用程序并修改PacktHAL以用于自己的硬件项目，您将需要了解如何从源代码构建PacktHAL。
- en: Understanding the Java Native Interface
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Java本机接口
- en: Android apps are written in Java, but the functions in PacktHAL are written
    in C native code. Native code is the code that is compiled into a native binary,
    such as a shared library or executable, and then executed directly by the Android
    OS. Native code is built using the compiler toolchain supplied within the Android
    NDK. Native binaries are not as portable as the "build once, run anywhere" bytecode
    of Android apps, but they can be used for low-level interfacing in ways that Java
    code cannot. Unlike Java bytecode, which is executable on any platform that has
    a proper virtual machine, native code is compiled for one specific hardware architecture
    (such as ARM, x86, or PowerPC) and can be executed only on that architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序是用Java编写的，但PacktHAL中的函数是用C本地代码编写的。本地代码是编译成本地二进制代码的代码，例如共享库或可执行文件，然后由Android
    OS直接执行。本地代码是使用Android NDK中提供的编译器工具链构建的。本地二进制代码不像Android应用程序的“构建一次，随处运行”的字节码那样具有可移植性，但它们可以用于低级接口，这是Java代码无法做到的。与Java字节码不同，Java字节码可以在具有适当虚拟机的任何平台上执行，本地代码是为一种特定的硬件架构（例如ARM、x86或PowerPC）编译的，并且只能在该架构上执行。
- en: Functions implemented in native code are called from an app's Java code via
    the **Java Native Interface** (**JNI**). JNI is a popular interfacing mechanism
    that Java applications use to interact with native C/C++ code. Among other features,
    JNI is used to *translate* Java datatypes into C datatypes and vice versa.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地代码中实现的函数通过**Java本机接口**（**JNI**）从应用程序的Java代码中调用。JNI是Java应用程序用于与本地C/C++代码交互的一种流行的接口机制。除其他功能外，JNI用于*转换*Java数据类型为C数据类型，反之亦然。
- en: For example, consider the Java `String` type. While Java has a `String` implementation,
    there is no equivalent type in C. The string must be suitably converted to a compatible
    type before it can be used by the C code. Each Java type is represented in C by
    a series of equivalent types, such as `jint`, `jstring`, and `jboolean`, which
    are defined in the standard `jni.h` header file that is supplied by the Android
    NDK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Java的`String`类型。虽然Java有`String`实现，但在C中没有等效的类型。在C代码中使用之前，字符串必须适当转换为兼容的类型。每种Java类型在C中都由一系列等效类型表示，例如`jint`、`jstring`和`jboolean`，这些类型在Android
    NDK提供的标准`jni.h`头文件中定义。
- en: Creating a new app project that uses PacktHAL
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个使用PacktHAL的新应用程序项目
- en: 'The following steps demonstrate how you can create a new custom app that includes
    PacktHAL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何创建一个包含PacktHAL的新自定义应用程序：
- en: Launch the Eclipse ADT and select the menu option **File**, then **New**, then
    **Android Application Project**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse ADT，选择菜单选项**文件**，然后**新建**，然后**Android应用程序项目**。
- en: 'In the **New Android Application** dialog, enter `myapp` into the **Application
    Name** field. This will automatically populate the **Project Name** and **Application
    Name** fields. Change the **Minimum Required SDK**, **Target SDK**, and **Compile
    With** fields to **API 19: Android 4.4**. The theme field can be left alone or
    changed to whichever theme you would like for your app. When finished, click on
    the **Next** button.![Creating a new app project that uses PacktHAL](img/00011.jpeg)'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The New Android Application screen
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Proceed through the successive dialog screens, retaining the default settings
    for each screen, until you click on the **Finish** button on the final screen.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The name of the default activity created for your new app is `MainActivity`.
    After creating the new project, the folder structure of your new `myapp` project
    will reside in the `myapp` (`$PROJECT`) directory and have a directory structure
    similar to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After creating the app for the first time, several new folders will be created
    to hold the various intermediary files created during the build process. Once
    you have created your app, you must add the PacktHAL code to it and compile it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Building PacktHAL under Windows
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in `c:\`, you can copy the PacktHAL code into your app''s
    project directory (`$PROJECT`) using the following process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and browse to the `$PROJECT` directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a second file explorer window and browse to `c:\PacktHAL`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `jni` directory in the `c:\PacktHAL` directory and select
    **Copy** from the context menu.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere convenient on white space within the `$PROJECT` directory
    window and then select **Paste** from the context menu.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the `jni\` directory exists in your `$PROJECT` directory, you can
    build PacktHAL using the Android NDK. Assuming that you installed the Android
    NDK in `c:\android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$PROJECT` directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The PacktHAL library is now built and present in your project as the file `$PROJECT\libs\armeabi\libpacktHAL.so`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Building PacktHAL under Linux
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in your `$HOME` directory, you can copy the PacktHAL code
    into your app''s project directory (`$PROJECT`) using the following commands:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the `jni` directory exists in your `$PROJECT` directory, you can build
    PacktHAL using the Android NDK. Assuming that you installed the Android NDK in
    `$HOME/android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `$PROJECT/jni` directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The PacktHAL library is now built and present in your project as the `$PROJECT/libs/armeabi/libpacktHAL.so`
    file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the GPIO example app
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will examine the example Android app that performs GPIO
    interfacing on BBB. The purpose of this application is to demonstrate how to use
    PacktHAL to perform GPIO read and write processes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with GPIOs from
    within your Android apps. These functions allow you to read the values of input
    GPIOs and set the values of output GPIOs. The low-level details of the hardware
    interfacing are implemented in PacktHAL, so you can quickly and easily get your
    apps interacting with GPIOs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Before digging through the GPIO app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app, as well as a precompiled `.apk` package, are located in the `chapter3.tgz`
    file, which is available for download from the book's website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Installing the app and source under Windows
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to the root directory of
    `c:\` after downloading it and will decompress it from there. We will refer to
    your workspace directory as `$WORKSPACE`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume that your `adb.exe` binary is in your current path. If it is
    not, call `adb` by using the full path to the `adb.exe` binary:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and navigate to the directory.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `chapter3.tgz` file in file explorer and select **Extract
    Here**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A directory named `c:\gpio` now exists, and it contains all of the files for
    the GPIO example app. You must import this project into your Eclipse ADT workspace:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse ADT.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **File** menu and select **Import**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import** dialog, expand the **Android** folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import Projects** dialog, type `c:\gpio` in the **Root Directory**
    text field. Then, click on the **Refresh** button. The **gpio** project will appear
    on the list of projects to import.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to import the `gpio` app project into your workspace
    and copy the `c:\gpio` directory into your `$WORKSPACE` directory.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of the project files for the GPIO app are now located in that `gpio` directory.
    A prebuilt `.apk` package for the app is provided in the `$WORKSPACE\gpio\bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$WORKSPACE\gpio\bin` directory:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Installing the app and source under Linux
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to your `$HOME` directory
    after downloading it and will decompress it from there. We will refer to your
    workspace directory as `$WORKSPACE`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Linux `tar` command to decompress and untar the `chapter3.tgz` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A directory named `gpio` now exists in your `$HOME` directory, and it contains
    all of the files for the gpio example app. You must import this project into your
    Eclipse ADT workspace as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse ADT.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **File** menu and select **Import**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import** dialog, expand the `Android` folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import Projects** dialog, type `$HOME/gpio` (substituting in the full
    path for `$HOME`) in the **Root Directory** text field. Then, click on the **Refresh**
    button. The **gpio** project will appear on the list of projects to import.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to import the gpio app project into your workspace
    and copy the `$HOME/gpio` directory into your `$WORKSPACE` directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of the project files for the app are now located in the `$WORKSPACE/gpio`
    directory. A prebuilt `.apk` package for the gpio project is provided in the `gpio/bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `bin` directory of the `gpio` project:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The app's user interface
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the `gpio` app on the Android system to see the app's (UI). If you are
    using a touchscreen cape, you can simply touch the gpio app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the gpio
    app icon to launch the app.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The app uses a very simple UI to interact with the GPIOs. As it is so simple,
    the only activity that the app has is default `MainActivity`. The UI consists
    of only three buttons and text view.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![The app''s user interface](img/00012.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: The GPIO sample app screen
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The **Poll Button State** button checks the current state of the pushbutton
    switch and updates the value of the **Button State** text view to report that
    state. The switch state will be reported as **UNKNOWN** until the **Poll Button
    State** button is pressed for the first time. The **Turn light on** button will
    turn on the LED if it is not already on, and the **Turn light off** button will
    turn the LED off.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The text view has an ID associated with it in `res/layout/activity_main.xml`
    so that the app can update the text view''s value programmatically:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of the three buttons have an `onClick()` handler defined:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each `onClick()` handler will trigger one of the PacktHAL GPIO functions to
    read the state of a GPIO or write a new state to a GPIO.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a refresher on the fine details of the various Android UI elements,
    there are several resources available online that can help you. We recommend that
    you start with the official Android Developer website at [http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Calling the PacktHAL functions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GPIO interface functionality in PacktHAL is implemented in four C functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`openGPIO()`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readGPIO()`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeGPIO()`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeGPIO()`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ideally, you would load the PacktHAL shared library into your app and then simply
    call the library functions directly to control the GPIOs. The example app actually
    *does* load the PacktHAL library via a `System.loadLibrary()` call, but then things
    become less straightforward because these C functions cannot be called directly.
    You must specify Java methods that, when called, actually call the C functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainActivity` class specifies four methods with the `native` keyword to
    call the PacktHAL C functions in `MainActivity.java`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These four Java methods specified in `MainActivity` are not actually a direct
    mapping to the C functions of the same name in PacktHAL. Notice that the GPIO
    methods in `MainActivity` are all `private native` within the scope of the class.
    Any method defined with the `native` keyword will attempt to call a native *JNI
    wrapper function* when it is invoked. However, the naming of the invoked JNI wrapper
    function follows some very specific rules that represent the scope of its Java-side
    method. The following figure shows how these JNI wrapper functions finally call
    the GPIO-interfacing functions inside of PacktHAL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling the PacktHAL functions](img/00013.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: The MainActivity methods and the PacktHAL GPIO-interfacing functions that they
    call
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Each `native` method in the `MainActivity` class with the name `name()` will
    use JNI to call a JNI wrapper function with the name `Java_com_packt_gpio_MainActivity_name()`.
    The name of this wrapper function is determined by replacing each `.` in the fully
    qualified name of the app with an underscore. The `Java_` prefix of the function
    name tells Android that the function is being called via a method in a Java class.
    There are a few exceptions to this JNI naming convention, but this general rule
    will get you through most cases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Do I need to know all about JNI to make my own Android interfacing projects?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Not really. Using JNI can be quite confusing, and many, many books and tutorials
    have been dedicated to describing it in great detail. For now, don't worry about
    not knowing everything that there is to know about JNI. When you have spent some
    time experimenting with hardware interfacing under Android, you can revisit this
    topic and learn more of the fine details of how JNI works. In this book, we will
    focus on showing you just enough information about JNI to get you started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, our Java `openGPIO()` method in the `MainActivity` class for
    the `com.packtpub.gpio` example app uses JNI to call the wrapper C function `Java_com_packtpub_gpio_MainActivity_openGPIO()`.
    This is a little confusing, but still very manageable. PacktHAL implements these
    JNI wrapper C functions in the `jni/packt_native_gpio.c` file. Looking at this
    source file, you can see where the `Java_com_packtpub_gpio_MainActivity_openGPIO()`
    function in PacktHAL calls the `openGPIO()` C function in PacktHAL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Why not just do away with the separate `openGPIO()` C function and place all
    of the hardware interface code inside `Java_com_packt_gpio_MainActivity_openGPIO()`?
    Functions such as `openGPIO()` in PacktHAL will usually not change once you have
    them working properly, and you can use these same functions under both Linux and
    Android. Wrapper functions such as `Java_com_packt_gpio_MainActivity_openGPIO()`
    will change their name and implementation details based upon how and where they
    are invoked from an app's Java code. It is better to isolate functionality that
    will not change in its own function. This avoids your accidentally breaking something
    when customizing or renaming the functions invoked via JNI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just remember that a Java method in your app, such as `openGPIO()` in the `MainActivity`
    class, makes a JNI call to invoke a PacktHAL C function with a long, mangled name
    like `Java_com_packt_gpio_MainActivity_openGPIO()`. The JNI wrapper function will
    then call one of the PacktHAL C functions, for example, `openGPIO()`, that actually
    controls the hardware. From the app developer's point of view, once you sort out
    the JNI wrapper function details, it is almost like calling the C function that
    controls the hardware directly from the Java app code!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Using the PacktHAL GPIO functions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have seen how the PacktHAL GPIO functions are called from Java,
    you will see what each of these functions does and how you can use them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The `openGPIO()` function initializes your app's access to GPIOs. This function
    offers you two different methods for GPIO interfacing, of which you select one
    method using `openGPIO()` function's `useMmap` parameter. The two methods are
    file I/O (by setting `useMmap` to 0) and memory-mapping (by setting `useMmap`
    to any non-zero number). To change from one interfacing method to the other, you
    must call `closeGPIO()` to shut down the GPIO portion of PacktHAL and then call
    `openGPIO()` again with a different value for `useMmap`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Processes must run as `root` to use memory- mapping to directly access the GPIO
    control resistors. As apps cannot run as root, the JNI wrapper function always
    passes `0` as the `useMmap` argument to `openGPIO()` to force the use of file
    I/O to interact with GPIOs. The `openGPIO()` method in the `MainActivity` class
    does not accept any arguments because of this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The example app calls the `openGPIO()` method from the `onCreate()` method
    of the `MainActivity` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The complementary call to the `closeGPIO()` method is made by the `onDestroy()`
    method of the `MainActivity` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `readGPIO()` method reads the state of a particular input GPIO. Both the
    PacktHAL `readGPIO()` function and the `readGPIO()` method in `MainActivity` take
    the same two parameters. The first parameter is a connector number on the BBB
    (8 or 9), and the second parameter is a pin location on that connector (1 through
    42). The `readGPIO()` method is called from within the `onClick()` handler of
    the `PollStatus` button:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In `onClickPollStatus()`, the `readGPIO()` method call is reading the state
    of the GPIO pin P9.13\. This is the GPIO pin that you connected to the pushbutton
    switch. If the switch is pressed when the `readGPIO()` method is called, `true`
    is returned. Otherwise, `false` is returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writeGPIO()` method is used to set the state of an output GPIO. Both the
    PacktHAL `writeGPIO()` function and the `writeGPIO()` method in `MainActivity`
    take three parameters. The first parameter is the connector number on the BBB
    (8 or 9), the second parameter is a pin location on that connector (1 through
    42), and the third parameter is the value to set (0 or 1). The `writeGPIO()` method
    is called from within the `onClick` handlers of the `LightOn` and `LightOff` buttons:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In both of these `onClick()` handlers, the GPIO being set is P9.11\. This is
    the GPIO pin that you connected to the LED. The `onClickButtonLightOn()` method
    sets the GPIO to 1, turning the LED on. Likewise, the `onClickButtonLightOff()`
    method sets the GPIO to 0, turning the LED off.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you ready for a challenge?**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen all of the pieces of the gpio app, why not change it
    to add new functionality? For a challenge, try changing the app to use only a
    single button that toggles the state of the LED. If the LED is currently off,
    pressing the button will turn it on and vice versa. We have provided one possible
    implementation of this in the `chapter3_challenge.tgz` file, which is available
    for download from the book's website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to GPIOs and how they work. You constructed
    a circuit that uses GPIOs for both input and output, and then you did some basic
    testing on the circuit to ensure that the circuit was constructed properly and
    that the kernel is able to interact with the circuit via the filesystem. You also
    learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file and `BB-PACKTPUB-00A0.dtbo`
    Device Tree overlay that are responsible for configuring GPIOs and making them
    available for your app's use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We showed you how to add PacktHAL into a newly created app project and how to
    build PacktHAL using the Android NDK. Then, you learned how JNI integrates PacktHAL
    into your Java app via JNI wrapper functions and explored how each GPIO function
    of PacktHAL is called and used from within an app.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to integrate I2C bus devices into your
    apps and begin interacting with hardware that is much more sophisticated than
    the basic on/off logic of GPIOs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
