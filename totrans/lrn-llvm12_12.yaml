- en: '*Chapter 9*: Instruction Selection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The LLVM IR used so far still needs to be turned into machine instructions.
    This is called **instruction selection**, often abbreviated to **ISel**. Instruction
    selection is an important part of the target backend, and LLVM has three different
    approaches for selecting instructions: the selection DAG, fast instruction selection,
    and global instruction selection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LLVM target backend structure, which introduces you to the
    task performed by the target backend, and you examine the machine passes to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **machine IR** (**MIR**) to test and debug the backend, which helps
    you to output MIR after a specified pass and run a pass on the MIR file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How instruction selection works, in which you learn about the different ways
    LLVM performs instruction selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting new machine instructions, in which you add a new machine instruction
    and make it available to the instruction selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how the target backends are structured
    and how instruction selection works. You will also acquire the knowledge to add
    currently unsupported machine instructions to the assembler and the instruction
    selection, and how to test your addition.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see the graph visualization, you must install the **Graphviz** software,
    which can be downloaded from [https://graphviz.org/](https://graphviz.org/). The
    source code is available at [http://gitlab.com/graphviz/graphviz/](http://gitlab.com/graphviz/graphviz/).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LLVM target backend structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the LLVM IR is optimized, the selected LLVM target is used to generate
    the machine code from it. Among others, the following tasks are performed in the
    target backend:'
  prefs: []
  type: TYPE_NORMAL
- en: The **directed acyclic graph** (**DAG**) used for instruction selection, usually
    referred to as the **SelectionDAG**, is constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Machine instructions corresponding to the IR code are selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The selected machine instructions are ordered in an optimal sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual registers are replaced with machine registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prologue and epilogue code is added to functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic blocks are ordered in an optimal sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Target-specific passes are run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object code or assembly is emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these steps are implemented as machine function passes, derived from the
    `MachineFunctionPass` class. This is a subclass of the `FunctionPass` class, one
    of the base classes used by the old pass manager. As of LLVM 12, the conversion
    of machine function passes to the new pass manager is still a work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: During all these steps, an LLVM instruction undergoes a transformation. At the
    code level, an LLVM IR instruction is represented by an instance of the `Instruction`
    class. During the instruction selection phase, it is transformed into a `MachineInstr`
    instance. This is a representation much nearer to the actual machine level. It
    already contains the instructions that are valid for the target, but still operates
    on virtual registers (up to register allocation) and also can contain certain
    pseudo instructions. The passes after the instruction selection refine this, and
    in the end, an instance of `MCInstr` is created, which is a representation of
    the real machine instruction. The `MCInstr` instance can be written into an object
    file or printed as assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the backend passes, you can create a small IR file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this code as `sum.ll`. Compile it for the MIPS architecture using `llc`,
    the LLVM static compiler. This tool compiles LLVM IR into assembly text or an
    object file. The target platform compile for can be overridden on the command
    line with the `–mtriple` option. Invoke the `llc` tool with the `–debug-pass=Structure`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Besides the generated assembly code, you will see a long list of machine passes
    to run. Among them, the `MIPS DAG->DAG Pattern Instruction Selection` pass performs
    the instruction selection, the `Mips Delay Slot Filler` is a target-specific pass,
    and the last pass before cleanup, `Mips Assembly Printer`, is responsible for
    printing the assembly code. Of all of these passes, the instruction selection
    pass is the most interesting one, and we look at it in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using MIR to test and debug the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw in the previous section that many passes are run in the target backend.
    However, most of these passes do not operate on LLVM IR, but on MIR. This is a
    target-dependent representation of the instructions, and therefore more low-level
    than LLVM IR. It can still contain references to virtual registers, so it is not
    yet the pure instruction of the target CPU.
  prefs: []
  type: TYPE_NORMAL
- en: To see the optimizations on the IR level, you can, for example, tell `llc` to
    dump the IR after each pass. This does not work with the machine passes in the
    backend, because they do not work on IR. Instead, MIR serves a similar purpose.
  prefs: []
  type: TYPE_NORMAL
- en: MIR is a textual representation of the current state of the machine instructions
    in the current module. It utilizes the YAML format, which allows for serialization
    and deserialization. The basic idea is that you can stop the pass pipeline at
    a point and inspect the state in YAML format. You can also modify the YAML file,
    or create your own, and pass on it, and inspect the result. This allows for easy
    debugging and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at MIR. Run the `llc` tool with the `--stop-after=finalize-isel`
    option and the test input file we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs `llc` to dump MIR after instruction selection is complete. The
    shortened output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are several properties you immediately note. First, there is a mix of
    virtual registers such as `%0` and real machine registers such as `$a0`. The reason
    for this comes from ABI lowering. To be portable across different compilers and
    languages, functions adhere to a calling convention, which is part of the `$a0`.
    Because the MIR output was generated after the instruction selection but before
    register allocation, you still see the use of virtual registers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the `add` instruction from LLVM IR, the machine instruction `ADDu`
    is used in the MIR file. You can also see that the virtual registers have a register
    call attached, in this case, `gpr32`. There are no 16-bit registers on the MIPS
    architecture, and therefore 32-bit registers must be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `bb.0` label refers to the first basic block, and the indented content after
    the label is part of the basic blocks. The first statement specifies the registers
    that are live on entry to the basic block. After that, the instructions follow.
    In this case, only `$a0`, and `$a1`, both parameters, are live on entry.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of other details in the MIR file. You can read about them in
    the LLVM MIR documentation at [https://llvm.org/docs/MIRLangRef.html](https://llvm.org/docs/MIRLangRef.html).
  prefs: []
  type: TYPE_NORMAL
- en: One problem you encounter is how to find out the name of a pass, especially
    if you just need to examine the output after that pass without actively working
    on it. When using the `-debug-pass=Structure` option with `llc`, the options that
    activate the passes are printed on the top. For example, if you want to stop before
    the `Mips Delay Slot Filler` pass, then you need to look at the printed list,
    and hopefully find the `-mips-delay-slot-filler` option, which also gives you
    the name of the pass.
  prefs: []
  type: TYPE_NORMAL
- en: The main application of the MIR file format is to aid in testing machine passes
    in the target backend. Using `llc` with the `--stop-after option`, you get the
    MIR after the specified pass. Usually, you will use this as the base for your
    intended test case. The first thing you note is that the MIR output is very verbose.
    For example, many fields are empty. To reduce this clutter, you can add the `-simplify-mir`
    option to the `llc` command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You save and change the MIR as needed for your test case. The `llc` tool can
    run a single pass, and this is a perfect match for testing with the MIR file.
    Let''s assume you like to test the `MIPS Delay Slot Filler` pass. The delay slot
    is a special property of RISC architectures such as MIPS or SPARC: the next instruction
    after a jump is always executed. Therefore, the compiler must make sure that there
    is a suitable instruction after each jump, and this pass performs this duty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate the MIR before running the pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is much smaller because we used the `-simplify-mir` option. The
    body of the function is now the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most notably, you will see the `ADDu` instruction, followed by apseudo instruction
    for the return.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `delay.ll` file as input, we now run the delay slot filler pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare the function in the output with the earlier one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that `ADDu` and the pseudo instruction for the return have changed
    order, and the `ADDu` instruction is now nested inside the return: the pass identified
    the `ADDu` instruction as suitable for the delay slot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case the delay slot concept is new to you, you will also want to have a
    look at the generated assembly, which you easily generate with `llc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output contains a lot of details, but with the help of the `bb.0` name
    of the basic block, you can easily locate the generated assembly code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the order of the instructions changed!
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, we take a look at the heart of the target backend
    and examine how machine instruction selection is performed in LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: How instruction selection works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The task of an LLVM backend is to create machine instructions from the LLVM
    IR. This process is called **instruction selection** or **lowering**. Motivated
    by the idea to automate this task as much as possible, the LLVM developers invented
    the TableGen language to capture all the details of a target description. We first
    look at this language before diving into the instruction selection algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the target description in the TableGen language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A machine instruction has a lot of properties: a mnemonic used by the assembler
    and disassembler, a bit pattern to represent the instruction in memory, input
    and output operands, and so on. The LLVM developers decided to capture all this
    information in a single place, the `.td` suffix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, the TableGen language is very simple. All you can do is define
    records. A `Register` class defines the common properties of a register, and you
    can define a concrete record for register `R0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You use the `let` keyword to override a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TableGen language has a lot of syntactic sugar to make dealing with records
    easier. A class can have a template argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The TableGen language is statically typed, and you have to specify the type
    of each value. Some of the supported types are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bit`: A single bit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: A 64-bit integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bits<n>`: An integral type consisting of *n* bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: A character string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list<t>`: A list of elements of type `t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dag`: A **directed acyclic graph** (**DAG**; used by the instruction selection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a class can also be used as a type. For example, `list<Register>`
    specifies a list of elements of the `Register` class.
  prefs: []
  type: TYPE_NORMAL
- en: The language allows the inclusion of other files with the `include` keyword.
    For conditional compiling, the preprocessor directives `#define`, `#ifdef`, and
    `#ifndef` are supported.
  prefs: []
  type: TYPE_NORMAL
- en: The TableGen library in LLVM can parse files written in the TableGen language
    and create an in-memory representation of the records. You can use this library
    to create your own generator.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM comes with its own generator tool called `llvm-tblgen` and some `.td` files.
    The target description of a backend includes the `llvm/Target/Target.td` file
    first. This file defines classes such as `Register`, `Target`, or `Processor`.
    The `llvm-tblgen` tool knows about these classes and generates C++ code from the
    defined records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the MIPS backend as an example. The target description
    is in the `Mips.td` file in the `llvm/lib/Target/Mips` folder. This file includes
    the `Target.td` file mentioned first. It also defines target features, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Such features are later used to define CPU models, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other files that define registers, instructions, scheduling models, and so on
    are also included.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `llvm-tblgen` tool can show you the records defined by this target description.
    If you are in the `build` directory, then the following command will print the
    records to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with Clang, the `–I` option adds a directory to search when including
    files. To see the records can be helpful for debugging. The real purpose of the
    tool is to generate C++ code from the records. For example, with the `-gen-subtarget`
    option, the data necessary to parse the `–mcpu=` and `–mtarget=` option of `llc`
    is emitted to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save the generated code from that command in a file and explore how the feature
    and the CPU are used in generated code!
  prefs: []
  type: TYPE_NORMAL
- en: 'The encoding of instructions usually follows a handful of patterns. Therefore,
    the definition of instructions is split into classes defining the bit encoding
    and the concrete definition of instruction. The encoding for the MIPS instructions
    is in the file `llvm/Target/Mips/MipsInstrFormats.td`. Let''s have a look at the
    definition of the `ADD_FM` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the record body, several new bit fields are defined: `rd`, `rs`, and so
    on. They are used to override portions of the `Inst` field, which holds the bit
    pattern for the instruction. The `rd`, `rs`, and `rt` bit fields encode the registers
    the instruction operates on, and the `op` and `funct` parameters denote the opcode
    and a function number. The `StdArch` superclass only adds a field stating that
    this format follows a standard encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most instruction encoding in the MIPS target does not refer to the DAG nodes
    and do not specify the assembly mnemonic. A separate class is defined for that.
    One of the instructions in the MIPS architecture is the `nor` instruction, which
    computes the bitwise or of the first and second input register, inverts the bits
    of the result, and assigns the result to the output register. There are several
    variants of this instruction, and the following `LogicNOR` class helps with avoiding
    the same definitions multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, the simple concept of records now looks complicated. Let''s dissect that
    definition. The class derives from the `InstSE` class, which is always used for
    instructions with standard encoding. If you follow the superclass hierarchy further,
    then you see that this class derives from `Instruction` class, which is the predefined
    class denoting an instruction of a target. The `(outs RO:$rd)` parameter defines
    the result of the final instruction as a DAG node. The `RO` part refers to the
    parameter of the same name of the `LogicNOR` class and denotes a register operand.
    The `$rd` is the register to use. This is the value that will be put later into
    the instruction encoding, in the `rd` field. The second parameter defines the
    values the instruction will operate on. In summary, this class is for an instruction
    that operates on three registers. The `!strconcat(opstr, "\t$rd, $rs, $rt")` parameter
    assembles the textual representation of the instruction. The `!strconcat` operator
    is a predefined functionality from TableGen, which concatenates two strings. You
    can look up all predefined operators in the TableGen programmer''s guide at: [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html).'
  prefs: []
  type: TYPE_NORMAL
- en: It follows a pattern definition, which resembles the textual description of
    the `nor` instruction and describes the computation of this instruction. The first
    element of the pattern is the operation, which is followed by a comma-separated
    list of operands. The operands refer to the register names in the DAG parameters
    and also specify an LLVM IR value type. LLVM has a set of predefined operators,
    such as `add` and `and`, which can be used in patterns. The operators are of the
    `SDNode` class, and can also be used as parameters. You can look up the predefined
    operators in the file `llvm/Target/TargetSelectionDAG.td`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `II_NOR` parameter specifies the itinerary class used in the scheduling
    model, and the `FrmR` parameter is a value defined to identify this instruction
    format. Finally, the `opstr` mnemonic is passed to the superclass. The body of
    this class is quite simple: it just specifies that the `nor` operation is commutative,
    which means that the order of the operands can be swapped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this class is used to define a record for an instruction, as an example,
    for the `nor` instruction in 64-bit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the final definition, recognizable from the `def` keyword. It uses the
    `LogicNOR` class to define the DAG operands and pattern, and the `ADD_FM` class
    to specify the binary instruction encoding. The additional `GPR_64` predicate
    makes sure that this instruction is only used if 64-bit registers are available.
  prefs: []
  type: TYPE_NORMAL
- en: The developers try hard to not repeat definitions multiple times, and one often-used
    approach is the use of `multiclass` classes. A `multiclass` class can define multiple
    records at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the floating point unit of a MIPS CPU can perform addition with
    single- or double-precision floating point values. The definition of both instructions
    is very similar, therefore a `multiclass` class is defined to create two instructions
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ADDS_FT` class defines the instruction format, similar to the `LogicNOR`
    class. The `FGR_32` and `FGR_64` predicates are used to decide at compile time
    which instruction can be used. The important part is the definition of `_D32`
    and `_D64` records. These are the templates for the records. The instruction records
    are then defined with the `defm` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This defines the two records from the multiclass at once and assigns the names
    `FADD_D32` and `FADD_D64` to them. This is a very powerful way to avoid code repetition,
    and it is often used in the target descriptions, but combined with the other TableGen
    features it can lead to very cryptic definitions.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of how the target description is organized, we can now explore
    the instruction selection in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction selection with the selection DAG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard way LLVM converts the IR to machine instructions is via a DAG.
    Using pattern matching with the patterns provided in the target description and
    using custom code, the IR instructions are transformed into machine instructions.
    This approach is not as straightforward as it sounds: the IR is mostly target-independent
    and can contain data types that are not supported on the target. For example,
    the `i1` type representing a single bit is not a valid type on most targets.'
  prefs: []
  type: TYPE_NORMAL
- en: The selectionDAG consists of nodes of `SDNode` type, defined in the file `llvm/CodeGen/SelectionDAGNodes.h`.
    The operation the node represents is called `OpCode`, and the target-independent
    codes are defined in the file `llvm/CodeGen/ISDOpcodes.h`. Besides the operation,
    the node stores the operands and the value it produces.
  prefs: []
  type: TYPE_NORMAL
- en: The values and operands of a node form a data flow dependency. A control flow
    dependency is represented by chain edges, which have the special type `MVT::Other`.
    This makes it possible to keep the order of instructions with side effects, for
    example, a load instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instruction selection using the selection DAG is performed with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The DAG is constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DAG is optimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The types in the DAG are legalized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DAG is optimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operations in the DAG are legalized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DAG is optimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instructions are selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instructions are ordered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's examine how we can follow the changes each of the steps makes to the selection
    DAG.
  prefs: []
  type: TYPE_NORMAL
- en: How to follow the instruction selection process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can see the work of the instruction selection in two different ways. If
    you pass the `–debug-only=isel` option to the `llc` tool, then the result of each
    step is printed in textual format. This is a great help if you need to investigate
    why a machine instruction was selected. For example, run the following command
    to see the output for the `sum.ll` file from the *Understanding the LLVM target
    backend structure* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints a lot of information. At the top of the output, you see the description
    of the initial created DAG for the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Like in the MIR output from the last section, you see here `CopyFromReg` instructions,
    which transfer the content of registers used by the ABI to virtual nodes. The
    `truncate` nodes are required because the example uses 16-bit values, but the
    MIPS architectures have only native support for 32-bit values. The `add` operation
    is performed on 16-bit virtual registers, and the result is extended and returned
    to the caller. Such a section is printed for each of the steps mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: 'LLVM can also generate a visualization of the selection DAG with the help of
    the *Graphviz* software. If you pass the `–view-dag-combine1-dags` option to the
    `llc` tool, then a window opens showing the constructed DAG. For example, run
    `llc` with the small file from the preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running on a Windows PC, you then see the DAG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Constructed selection DAG for the sum.ll file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Constructed selection DAG for the sum.ll file
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to compare that the textual representation and this graph contain the
    same information. The `EntryToken` is the start of the DAG, and the `GraphRoot`
    is the final node. The chain for the control flow is marked with the blue dashed
    arrows. The black arrows denote the data flow. The red arrows glue nodes together,
    preventing reordering them. The graph can get really big even for moderately sized
    functions. It does not contain more or other information than the textual output
    with the `–debug-only=isel` option, only the presentation is more comfortable.
    You can also generate the graph at other points in time, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `--view-legalize-types-dags` option to see the DAG before type legalization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `–view-isel-dags` option to see the selection instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see all available options to view the DAG using the `--help-hidden`
    option. Because the DAG can get large and confusing, you can limit the rendering
    to one basic block using the `-filter-view-dags` option.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the instruction selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing how to visualize the DAG, we can now dive into the details. The selection
    DAG is constructed from the IR. For each function in the IR, an instance of the
    `SelectionDAG` class is populated by the `SelectionDAGBuilder` class. There are
    no special optimizations done at this step. Nevertheless, a target needs to provide
    some functions to lower calls, argument handling, return jumps, and so on. To
    do so, the target has to implement the `TargetLowering` interface. Inside the
    folder of a target, the source is usually in the `XXXISelLowering.h` and `XXXISelLowering.cpp`
    files. The implementation of the `TargetLowering` interface provides all the information
    needed for the instruction process, for example, which data types and which operations
    are supported on the target.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization step is run several times. The optimizer performs simple optimization,
    for example identifying rotates on targets that support these operations. The
    rationale here is that a cleaned-up DAG is produced, which simplifies the other
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the type legalization step, types that are not supported on the target
    are replaced with supported ones. For example, if a target natively supports only
    32-bit-wide integers, then smaller values must be converted to 32-bit through
    sign or zero extension. This is called `TargetLowering` interface. After type
    legalization, the selection DAG has this textual representation for the `sum.ll`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this with the initial constructed DAG, then here only 32-bit
    registers are used. The 16-bit values were promoted, because only 32-bit values
    are supported natively.
  prefs: []
  type: TYPE_NORMAL
- en: Operation legalization is similar to type legalization. This step is necessary
    because not all operations may be supported by a target, or even if a type is
    natively supported on a target, it may not valid for all operations. For example,
    not all targets have a native instruction for population count. In such cases,
    the operation is replaced by a sequence of operations to implement the functionality.
    If the type does not fit for the operation, then promoting the type to a larger
    one could be done. It is also possible for a backend author to provide custom
    code. If the legalization action is set to `Custom`, then the `LowerOperation()`
    method in the `TargetLowering` class is called for these operations. The method
    must create a legal version of the operation then. In the `sum.ll` example, the
    `add` operation is already legal, because addition of two 23-bit registers is
    supported on the platform, and nothing changed.
  prefs: []
  type: TYPE_NORMAL
- en: After types and operations are legalized, the instruction selection happens.
    A large part of the selection is automated. Remember from the previous section
    that you provided a pattern in the description of an instruction. From these descriptions,
    a pattern matcher is generated by the `llvm-tblgen` tool. Basically, the pattern
    matcher tries to find a pattern that matches the current DAG node. The instruction
    associated with the pattern will then be selected. The pattern matcher is implemented
    as a bytecode interpreter. The available codes for the interpreter are defined
    in the `llvm/CodeGen/SelectionDAGISel.h` header file. The `XXXISelDAGToDAG` class
    implements the instruction selection for a target. The `Select()` method is called
    for each DAG node. The default is to call the generated matcher, but you can also
    add code for cases not handled by it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is noteworthy that there is no one-to-one relationship between a selection
    DAG node and the selected instructions. A DAG node can expand into several instructions,
    and several DAG nodes can collapse into a single instruction. An example of the
    former is synthesizing immediate values. Especially on RISC architectures, the
    bit length of immediate values is restricted. A 32-bit target may only support
    an embedded immediate value of 16-bit length. To perform an operation that requires
    a 32-bit constant value, you usually split it into two 16-bit values and then
    generate two or more instructions that use the 16-bit values instead. Among others,
    you find patterns for this in the MIPS target. Bit-field instructions are a common
    example for the latter case: combinations of `and`, `or`, and `shift` DAG nodes
    can often be matched to special bit-field instructions, resulting in just one
    instruction for two or more DAG nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you specify a pattern in the target description to combine two or more
    DAG nodes. For more complex cases, which are not easily handled with a pattern,
    you can mark the operation of the top node to require special DAG combine treatment.
    For these nodes, the `PerformDAGCombine()` method in the `XXXISelLowering` class
    is called. You can then check arbitrary complex patterns, and if you find your
    match, then you can return the operation representing the combined DAG nodes.
    This method is called before the generated matcher is run for the DAG node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the instruction selection process in the printed output for
    the `sum.ll` file. For the `add` operation, you find there the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The index numbers point into the array of the generated matcher. The start is
    at index `27835` (an arbitrary value that can change from release to release),
    and after some steps, the `ADDu` instruction is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Following the pattern matching
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter a problem with a pattern, then you can also retrace the matching
    by reading the generated bytecode. You find the source in the `lib/Target/XXX/XXXGenDAGIsel.inc`
    file in the `build` directory. You open the file in a text editor and search for
    the index in the preceding output. Each line is prefixed with the index number,
    so you can easily find the right place in the array. The used predicates are also
    printed as comments, so they can help you to understand why a certain pattern
    was not selected.
  prefs: []
  type: TYPE_NORMAL
- en: Turning the DAG into instruction sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After instruction selection, the code is still a graph. This data structure
    needs to be flattened, which means that the instructions must be sequentially
    ordered. The graph contains data and control flow dependencies, but there are
    always several possibilities to order the instructions in such a way that these
    dependencies are fulfilled. What we want is an order that best utilizes the hardware.
    Modern hardware can issue several instructions in parallel, but restrictions always
    apply. A simple example of such a restriction is one instruction requiring the
    result of another instruction. In such a case, the hardware may not be able to
    issue both instructions and instead executes the instructions in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: You can add a scheduling model to the target description, which describes the
    available units and their properties. For example, if a CPU has two integer arithmetic
    units, then this information is captured in the model. For each instruction, it
    is necessary to know which part of the model is used. There are different ways
    to do this. The newer, recommended approach is to define a scheduling model using
    the so-called machine-instruction scheduler. To do so, you need to define a `SchedMachineModel`
    record for each subtarget in the target description. Basically, the model consists
    of definitions for the input and output operands of instructions and processor
    resources. Both definitions are then associated together with latency values.
    You can look up the predefined types for this model in the `llvm/Target/TargetSched.td`
    file. Look at the Lanai target for a very simple model and in the SystemZ target
    for a complex scheduling model.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an older model based on so-called itineraries. With this model,
    you define processor units as `FuncUnit` records. A step using such a unit is
    defined as an `InstrStage` record. Each instruction is associated with an itinerary
    class. For each itinerary class, the used processor pipeline composed of `InstrStage`
    records is defined, together with the number of processor cycles required for
    execution. You can find the predefined types for the itinerary model in the `llvm/Target/TargetItinerary.td`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Some targets use both models. One reason is due to development history. The
    itinerary-based model was the first one added to LLVM, and targets began using
    this model. When the new machine-instruction scheduler was added more than 5 years
    later, nobody cared enough to migrate the already existing models. Another reason
    is that with the itinerary model, you can not only model an instruction that uses
    multiple processor units, but you can also specify during which cycles the units
    are used. However, this detail level is rarely needed, and if it is needed, then
    you can refer to the machine-instruction scheduler model to the defined itineraries,
    basically pulling this information into the new model too.
  prefs: []
  type: TYPE_NORMAL
- en: If present, the scheduling model is used to order the instructions in an optimal
    way. After this step, the DAG is not needed anymore and is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Performing instruction selection with the selection DAG produces almost optimal
    results, but it comes at a cost in terms of runtime and memory usage. Therefore,
    alternative approaches were developed, which we examine next. In the next section,
    we look at the fast instruction selection approach.
  prefs: []
  type: TYPE_NORMAL
- en: Fast instruction selection – FastISel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the selection DAG for instruction selection costs compile time. If you
    are developing an application, then the runtime of the compiler matters. You also
    do not care about the generated code so much, because it is more important that
    complete debug information is emitted. Because of these reasons, the LLVM developers
    decided to implement a special instruction selector that has a fast runtime but
    produces less optimal code, and which is used only for `–O0` optimization level.
    This component is called fast instruction selection, or **FastIsel** for short.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is in the `XXXFastISel` classes. Not every target supports
    this instruction selection method, in which case the selection DAG approach is
    used for `–O0`, too. The implementation is straightforward: a target-specific
    class is derived from a `FastISel` class and has to implement a couple of methods.
    The TableGen tool generates most of the required code from the target description.
    Nevertheless, there is some effort needed to implement this instruction selector.
    One of the root causes is that you need to get the calling convention right, which
    is usually complex.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MIPS target features an implementation of fast instruction selection. You
    can enable use of fast instruction selection by passing the `–fast-isel` option
    to `llc` tool. Using the `sum.ll` example file from first section, an invocation
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Fast instruction selection runs very quickly, but it is a completely different
    code path. Some LLVM developers decided to look for a solution that runs quickly
    but can also produce good code, with the goal to replace both the selection `dag`
    and the fast instruction selector in the future. We look at this approach in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The new global instruction selection – GlobalISel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the selection DAG, we can generate pretty good machine code. The drawback
    is that it is a very complex piece of software. This means that it is hard to
    develop, test, and maintain. The FastISel instruction selection works quickly
    and is less complex, but does not produce good code. Both approaches do not share
    much code, except for the code generated by TableGen.
  prefs: []
  type: TYPE_NORMAL
- en: Can we have the best of both worlds? One instruction selection algorithm, which
    is fast, easy to implement, and which produces good code? That is the motivation
    for adding another instruction selection algorithm, the global instruction selection,
    to the LLVM framework. The short-term goal is to replace FastISel first, and in
    the long term the selection DAG, too.
  prefs: []
  type: TYPE_NORMAL
- en: The approach taken by global instruction selection is to build on the existing
    infrastructure. The whole task is broken down into a sequence of machine function
    passes. Another major design decision is to not introduce another intermediate
    representation but instead use the existing `MachineInstr` class. However, new
    generic opcodes are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current sequence of steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IRTranslator` pass builds the initial machine instructions using the generic
    opcodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Legalizer` pass legalizes types and operations in one step. This is different
    from the selection DAG, which uses two different steps for it. Real CPU architectures
    are sometimes weird, and it is possible that a certain data type is only supported
    with one instruction. This case is not handled well by the selection DAG, but
    it's easy to handle this in the combined step in the global instruction selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated machine instructions still operate on virtual registers. In the
    `RegBankSelect` pass, a register bank is selected. A register bank represents
    a type of registers on the CPU, for example, general-purpose registers. This is
    more coarse-grained than the register definitions in the target description. The
    important point is that it associates type information with the instruction. The
    type information is based on the types available in the target, so this is already
    lower than the generic type in LLVM IR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the types and operations are known to be legal for the target,
    and type information is associated with each instruction. The following `InstructionSelect`
    pass can then easily replace the generic instructions with the machine ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the global instruction selection, the usual backend passes such as instruction
    scheduling, register allocation, and basic block placement are run.
  prefs: []
  type: TYPE_NORMAL
- en: Global instruction selection is compiled into LLVM, but it is not enabled by
    default. If you want to use it, you need to give the `–global-isel` option to
    `llc` or `–mllvm global-isel` to `clang`. You can control what happens if an IR
    construct cannot be handled by global instruction selection. When you give the
    `-global-isel-abort=0` option to `llc`, then the selection DAG is used as fallback.
    With `=1`, the application is terminated. To prevent this, you can give the `-global-isel-abort=0`
    option to `llc`. And with `=2`, the selection DAG is used as fallback, and a diagnostic
    message is printed to inform you about the problem.
  prefs: []
  type: TYPE_NORMAL
- en: To add global instruction selection to a target, you only need to override the
    corresponding functions in the `TargetPassConfig` class of your target. This class
    is instantiated by the `XXXTargetMachine` class, and the implementation is usually
    found in the same file. For example, you override the `addIRTranslator()` method
    to add the `IRTranslator` pass to the machine passes of your target.
  prefs: []
  type: TYPE_NORMAL
- en: The development happens mainly on the AArch64 target, which currently has the
    best support for global instruction selection. Many other targets, including x86
    and Power, have also added support for global instruction selection. One challenge
    here is that not that much code is generated from the table description, so there
    is still an amount of manual coding you have to do. Another challenge is that
    big-endian targets are currently not supported, so pure big-endian targets such
    as SystemZ cannot use global instruction selection as of today. Both will certainly
    improve over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mips target features an implementation of global instruction selection,
    with the mentioned limitation that it can only be used for little-endian targets.
    You can enable use of global instruction selection by passing the `–global-isel`
    option to the `llc` tool. Using the `sum.ll` example file from first section,
    an invocation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the target `mipsel-linux-gnu` is the little-endian target.
    Using the big-endian `mips-linux-gnu` target results in an error message.
  prefs: []
  type: TYPE_NORMAL
- en: The global instruction selector works much quicker than the selection DAG, and
    already produces higher code quality than fast instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting new machine instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CPU you are targeting may have machine instructions not yet supported by
    LLVM. For example, manufacturers using the MIPS architecture often add special
    instructions to the core MIPS instruction set. The specification of the RISC-V
    instruction set explicitly allows manufacturers to add new instructions. Or you
    are adding a completely new backend, and then you must add the instructions of
    the CPU. In the next section, we will add assembler support for a single, new
    machine instruction to an LLVM backend.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new instruction to the assembler and code generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New machine instructions are usually tied to a certain CPU feature. Then the
    new instruction is only recognized if the user has selected the feature using
    the `--mattr=` option to `llc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will add a new machine instruction to the MIPS backend. The
    imaginary, new machine instruction first squares the value of the two input registers
    `$2` and `$3` and assigns the sum of both squares to the output register `$1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The name of the instruction is `sqsumu`, derived from the square and summation
    operation. The last `u` in the name indicates that the instruction works on unsigned
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU feature we are adding first is called `sqsum`. This will allow us to
    call `llc` with the `--mattr=+sqsum` option to enable recognition of the new instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the code we will add is in the `llvm/lib/Target/Mips` folder. The top-level
    file is `Mips.td`. Look at the file and locate the section in which the various
    features are defined. Here you add the definition of our new feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SubtargetFeature` class takes four template parameters. The first, `sqsum`,
    is the name of the feature, for use on the command line. The second parameter,
    `HasSQSum`, is the name of the attribute in the `Subtarget` class representing
    this feature. The next parameters are the default value and the description of
    the feature, used for providing help on the command line. TableGen generates the
    base class for the `MipsSubtarget` class, defined in `MipsSubtarget.h` file. In
    this file, we add the new attribute in the private part of the class, where all
    the other attributes are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the public part, we also a method to retrieve the value of the attribute.
    We need this method for the next addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With these additions, we are already able to set the `sqsum` feature on the
    command line, albeit without effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tie the new instruction to the `sqsum` feature, we need to define a predicate
    that indicates whether the feature is selected or not. We add this to the `MipsInstrInfo.td`
    file, either in the section where all the other predicates are defined or simply
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The predicate uses the `hasSQSum()` method defined earlier. Additionally, the
    `AssemblerPredicate` template specifies the condition used when generating the
    source code for the assembler. We simply refer to the previously defined feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the scheduling model. The MIPS target uses both the
    itinerary and the machine-instruction scheduler. For the itinerary model, an `InstrItinClass`
    record is defined for each instruction in the `MipsSchedule.td` file. Simply add
    the following line in this file in the section where all the itineraries are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to give details about the instruction costs. Usually, you find
    this information in the documentation for the CPU. For our instruction, we optimistically
    assume that it just takes one cycle in the ALU. This information is added to the
    `MipsGenericItineraries` definition in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, the update to the itinerary-based scheduling model is complete.
    The MIPS target also defines a generic scheduling model based on the machine-instruction
    scheduler model in the `MipsScheduleGeneric.td` file. Because this is a complete
    model covering all instructions, we also need to add our instruction add. As it
    is based on multiplication, we simply extend the existing definition for the `MULT`
    and `MULTu` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The MIPS target also defines a scheduling model for the P5600 CPU in the `MipsScheduleP5600.td`
    file. Our new instruction is obviously not supported on this target, so we add
    it to the list of unsupported features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to add the new instruction at the end of the `Mips64InstrInfo.td`
    file. TableGen definitions are always terse, therefore we dissect them. The definition
    uses some predefined classes from the MIPS target descriptions. Our new instruction
    is an arithmetic instruction, and by design, it fits the `ArithLogicR` class.
    The first parameter, `"sqsumu"`, specifies the assembler mnemonic of the instruction.
    The next parameter, `GPR64Opnd`, states that the instructions use 64-bit registers
    as operands and the following `1` parameter indicates that the operands are commutative.
    Last, an itinerary is given for the instruction. The `ADD_FM` class is given to
    specify the binary encoding of the instruction. For a real instruction, the parameters
    must be chosen according to the documentation. Then follows the `ISA_MIPS64` predicate,
    which indicates for which instruction set the instruction is valid. And last,
    our `SQSUM` predicate states that the instruction is only valid when our feature
    is enabled. The complete definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only aim to support the new instruction, then this definition is enough.
    Be sure to finish the definition with `;` in this case. With the addition of a
    selection DAG pattern, you make the instruction available to the code generator.
    The instruction uses the two operand registers `$rs` and `$rt` and the destination
    register `$rd`, all three defined by the `ADD_FM` binary format class. In theory,
    the pattern to match is then simple: the value of each register is squared using
    the `mul` multiplication operator, and then the two products are added using the
    `add` operator and assigned to the destination register `$rd`. The pattern gets
    a bit more complicated because, with the MIPS instruction set, the result of a
    multiplication is stored in a special register pair. To be usable, the result
    must be moved to a general-purpose register. During legalization of operations,
    the generic `mul` operator is replaced with the MIPS-specific `MipsMult` operation
    for the multiplication and the `MipsMFLO` operation to move the lower part of
    the result into a general-purpose register. We must take this into account when
    writing the pattern, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As described in the *Instruction selection with the selection DAG* section,
    if this pattern matches the current DAG node, then our new instruction is selected.
    Because of the `SQSUM` predicate, this only happens when the `sqsum` feature is
    activated. Let's check it with a test!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the new instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you extend LLVM, then it is good practice to verify it with automated tests.
    Especially if you want to contribute your extension to the LLVM project, then
    good tests are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding a new machine instruction as we did in the last section, we must
    check two different aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to verify that the instruction encoding is correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we must make sure that the code generation works as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The LLVM projects use `llvm-mc` tool. Besides other tasks, this tool can show
    the encoding of an instruction. For an ad hoc check, you can run the following
    command to show the instruction encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This already shows part of the input and the command to run in an automated
    test case. To verify the result, you use the `FileCheck` tool. The output of `llvm-mc`
    is piped into this tool. Additionally, `FileCheck` reads the test case file. The
    test case file contains lines marked with the `CHECK:` keyword, after which the
    expected output follows. `FileCheck` tries to match these lines against the data
    piped into it. If no match is found, then an error is displayed. Place the `sqsumu.s`
    test case file with the following content into the `llvm/test/MC/Mips` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are inside the `llvm/test/Mips/MC` folder, then you can run the test
    with the following command, which reports success at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The LIT tool interprets the `RUN:` line, replacing `%s` with the current filename.
    The `FileCheck` tool reads the file, parses the `CHECK:` lines, and tries to match
    the input from the pipe. This is a very effective way of testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are in the `build` directory, you can invoke the LLVM tests with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the tests contained in one folder, by adding the folder name
    separated by a dash. To run the tests in the `llvm/test/Mips/MC` folder, you type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct a test case for the code generation, you follow the same strategy.
    The following `sqsum.ll` file contains LLVM IR code to calculate the hypotenuse
    square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the generated assembly code, you use the `llc` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Convince yourself that you see our new `sqsum` instruction in the output. Please
    also check that the instruction is not generated if you remove the `–mattr=+sqsum`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this knowledge, you can construct the test case. This time, we
    use two `RUN:` lines: one to check that our new instruction is generated, and
    one to check that it is not. We can do both with one test case file because we
    can tell the `FileCheck` tool to look for a different label than `CHECK:`. Put
    the test case file `sqsum.ll` with the following content into the `llvm/test/CodeGen/Mips`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other test, you can run the test alone in the folder with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run it from the build directory with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With these steps, you enhanced the LLVM assembler with a new instruction, enabled
    the instruction selection to use this new instruction, and verified that the encoding
    is correct and the code generation works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how the backend of an LLVM target is structured.
    You used the MIR to examine the state after a pass and you used machine IR to
    run a single pass. With this knowledge, you can investigate problems in backend
    passes.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how instruction selection with the help of the selection DAG is
    implemented in LLVM, and you also were introduced to alternative methods for instruction
    selection with FastISel and GlobalISel, which helps in deciding which algorithm
    to choose if your platform offers all of them.
  prefs: []
  type: TYPE_NORMAL
- en: You extended LLVM to support a new machine instruction in the assembler and
    in the instruction selection, helping you to add support for currently unsupported
    CPU features. To validate the extension, you developed automated test cases for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we examine another unique feature of LLVM: generating
    and executing code in one step, also known as **Just-In-Time** (**JIT**) compilation.'
  prefs: []
  type: TYPE_NORMAL
