- en: Communication and Advocacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not write code in isolation. We are embedded in a highly chaotic social
    world in which we must communicate with other people constantly. Our software
    itself will, via its interfaces, be part of this communication. Furthermore, if
    we operate within a team, a workplace, or a community, we are liable to the challenges
    of effective communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most significant way in which communication has an effect on our code bases
    is in the setting of requirements and the raising of issues and feedback. Software
    development is essentially one very elongated feedback process, where every change
    is precipitated by a communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f40a4db5-ca16-4aa5-a21d-b09940e7f46a.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we'll learn how to effectively collaborate and communicate
    with others, how to plan and set requirements, some common collaboration pitfalls,
    and their solutions. We'll also learn how to identify and raise larger issues
    that are preventing us from writing clean JavaScript. Throughout this chapter,
    we will hopefully begin to appreciate our individually vital roles in the feedback
    cycle of software development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll see the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning and setting requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying issues and driving change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning and setting requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common communication struggles resides in the process of deciding
    what to actually build. Programmers will typically spend a lot of time meeting
    with managers, designers, and other stakeholders to transform a genuine user need
    into a workable solution. Ideally, this process would be simple: *User has [problem];
    We create [solution]. End of story!* Unfortunately, however, it can be far more
    complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous technical constraints and biases of communication that can
    make even seemingly simple projects turn into punishingly long struggles. This
    is as relevant to the JavaScript programmer as any other programmer, for we now
    operate at a level of systemic complexity that was previously only the domain
    of enterprise programmers wielding Java, C#, or C++. The landscape has changed,
    and so the humble JavaScript programmer must now be prepared to pick up new skills
    and ask new questions about the systems they build.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding user needs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Establishing user needs is vital but it is often taken for granted. It''s typical
    for programmers and other project members to assume they understand a certain
    user need without really digging into the details, so it''s useful to have a process
    to fall back on. For each ostensible *need* or *problem*, we should ensure that
    we understand the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Who are our users?**: What characteristics do they have? What devices do
    they use?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What are they trying to do?**: What actions are they trying to carry out?
    What''s their ultimate goal?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do they currently do it?**: What set of steps are they currently taking
    to reach their goal? Are there any notable issues with their current method?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What problems do they experience doing it this way?**: Does it take a long
    time? Is it cognitively expensive? Is it difficult to use?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning of the book, we asked ourselves to consider why we wrote code,
    and we explored what it means to truly understand the nature of our problem domain.
    Ideally, we should be able to step inside the shoes of our users, experience the
    problem domain ourselves, and then craft working solutions from firsthand experience.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we are not always able to talk directly to our users or walk
    in their shoes. Instead, we may rely on intermediates such as project managers
    and designers. And so, we are dependent upon their communication efficacy to relay
    the user needs to us in a way that allows us to build a correct solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see how the needs of our users, combined with the technical and business
    constraints, flow into an idea that is built into a solution and iterated upon.
    The translation of **User Needs** to **Idea** is vital, as is the process of feedback
    that allows us to iterate and improve upon our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6113395e-408d-4552-bcb2-47547245a696.png)'
  prefs: []
  type: TYPE_IMG
- en: Since user needs are crucial to the process of development, we have to think
    carefully about how we balance these with other constraints. It is usually impossible
    to build the ideal solution, catering well to every single user. Almost every
    piece of software, whether presented as a GUI or API, is a compromise in which
    the average user is well catered to, inevitably meaning that the edge case users
    are left being only partially served by the solution. It's important to consider
    how we can adequately accommodate as many users' needs as possible, delicately balancing
    constraints such as time, money, and technical capability.
  prefs: []
  type: TYPE_NORMAL
- en: Following our understanding of user needs, we can begin to design and implement
    prototypes and models of how a system may work. We'll briefly discuss the process
    of doing this next.
  prefs: []
  type: TYPE_NORMAL
- en: Quick prototypes and PoCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software, and especially the web platform, provides us with the benefit of
    a quick build cycle. We can go from concept to UI in a very short amount of time.
    This means that ideas can be brought to life during the process of brainstorming,
    almost in real time. We can then place these prototypes in front of real users,
    get real feedback, and then iterate quickly towards an optimal solution. Truly,
    the forte of the web platform—the triad of HTML, CSS, and JavaScript—is that it
    allows a quick and hacky solution that can be iterated on easily, and can work
    on multiple platforms and devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0411eaa-25df-43a5-a514-6869b2044791.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s easy to get weighed down by the variety and complexity of JavaScript
    frameworks and libraries; the sheer burden of them can force us to move at a much
    slower pace. That''s why, when prototyping, it''s often better to stick to a simpler
    stack that you already understand well. If you''re accustomed to a framework,
    or if you are prepared to sink some time into learning, then it is worth utilizing
    one of many available skeletal boilerplate starter repositories as your starting
    point. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: React boilerplate ([github.com/react-boilerplate/react-boilerplate](http://github.com/react-boilerplate/react-boilerplate))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular bootstrap boilerplate ([github.com/mdbootstrap/Angular-Bootstrap-Boilerplate](http://github.com/mdbootstrap/Angular-Bootstrap-Boilerplate))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember boilerplate ([github.com/mirego/ember-boilerplate](http://github.com/mirego/ember-boilerplate))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Svelte template ([github.com/sveltejs/template](http://github.com/sveltejs/template))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These each offer a relatively simple project template that you can use to very
    quickly set up a new prototype. Even though the tooling used within each one involves
    multiple build tools and framework options, the setup cost is minimal and so the
    time it takes to start tackling the real problem domain of your project is kept
    very short. There are, naturally, similar boilerplates and example applications
    you can find for server-side Node.js projects, isomorphic web applications, and
    even robotic or hardware projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the technical process of planning and setting requirements,
    we can move on to discover some vital communication strategies that'll help us
    collaborate with others on our code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Communication strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We intuitively know that communication is vital to an effective project and
    a clean code base, yet it is annoyingly common to find ourselves in situations
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't feel listened to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't feel we've got our point across
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We feel confused as to a topic or plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We feel out of the loop or ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These difficulties come about because of cultures and practices of poor communication.
    This is not only an issue for morale and general fulfillment in our work but can
    also become a huge issue for the cleanliness of our code bases and the reliability
    of the technology we build. To foster a clean code base, we must focus on the
    underlying communication practices that we employ. A good set of communication
    strategies and practices are incredibly useful in ensuring a clean code base,
    specifically helping us with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring good feedback with colleagues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving correct bug reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actioning improvements and fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving user requirements and wishes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Announcing changes or issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agreeing on conventions and standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making decisions about libraries and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But how do we actually accomplish good communication? We are inherently biased
    toward our own socialized communication practices, so it can be difficult to change
    or even see that we have issues with our communication. For this reason, it is
    useful to identify a set of communication strategies and pitfalls that can re-bias
    us towards better and higher signal communication.
  prefs: []
  type: TYPE_NORMAL
- en: '**High signal** communication is any piece of communication that compresses
    a lot of highly valuable or insightful information in a minimally noisy fashion.
    Expressing a bug report in a brief and highly objective paragraph may be an example
    of high signal, while expressing it as a three-part essay with rhetoric and opinion
    thrown in is an example of low signal.'
  prefs: []
  type: TYPE_NORMAL
- en: Listen and respond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether in online or offline conversations, it is quite easy to fall into a
    trap where we end up talking *over* each other instead of *to* each other. A good
    and useful conversation is one where the participants are truly listening to each
    other, instead of merely awaiting their turn to talk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following conversation between **Person #1** and **Person #2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Person #1**: *We should use the React framework for this, it has a proven
    track record.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person #2**: *I agree about its track record. Shall we explore any other
    options, weighing up their pros and cons*?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person #1**: *React is really fast, well-documented, and the API is really
    usable. I love it*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here **Person #1** is not paying attention to what **Person** **#2** is saying.
    Instead, they are just continuing with their existing train of thought, reiterating
    their preference for the React framework. It would be more conducive to good teamwork
    and a healthier project if **Person #1** made an effort to listen to **Person
    #2**''s points and then respond specifically to them. Compare the preceding conversation
    with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Person #1**: *We should use the React framework for this, it has a proven
    track record.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person #2**: *I agree about its track record. Shall we explore any other
    options, weighing up their pros and cons?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person #1**: *That''d be a good idea, what other frameworks do you think
    we should consider?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, **Person #1** is being receptive, and not purely talking *over* **Person
    #2**. This shows a much-needed sensitivity and conversational attention. This
    may seem obvious, or even inane, but you may be surprised how often we end up
    speaking over each other and the costs it inflicts us with. Consider taking an
    observational role in your next meeting, observe instances where people fail to
    properly pay attention, listen, or respond. You may be surprised by its prevalence.'
  prefs: []
  type: TYPE_NORMAL
- en: Explain from the user's perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In almost every piece of online or offline communication you have in regards
    to a code base, the user should be the most important thing. The purpose of our
    work is to fulfill the expectations of the user and deliver to them a user experience
    that is intuitive and functional. This is relevant, regardless of whether our
    end-product is a piece of consumer software or a developer API. The user remains
    our priority. It is, however, incredibly common to find ourselves in situations
    where there is a decision to be made and we don''t know how to make it; we end
    up relying on gut instinct or our own biased beliefs. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Of course users should have to fulfill our password strength requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course our API should be strictly type-checked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course we should use a dropdown component for country selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These may seem like fairly unobjectionable statements, but we should always
    seek to qualify them from the perspective of the user. If we cannot do this, then
    there's a strong possibility that the decision holds no water and should be challenged.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the preceding statements, we can defend our reasoning as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Of course users should have to fulfill our password strength requirements**:
    Users with stronger passwords will end up being more secure against brute-force
    password attacks. While we as a service need to ensure secure storage of passwords,
    it is the user''s responsibility, and very much in their interest, to ensure a
    strong password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Of course our API should be strictly type-checked**: A strictly type-checked
    API will ensure that users get more informative warnings about incorrect usage
    and can thus reach their desired goal sooner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Of course we should use a dropdown component for country selection**: A dropdown
    is an established convention that users have come to expect. We could always augment
    this with an autocompletion feature as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice how we are expanding upon our of course statements with reasoning that
    relates specifically to the user. It's easy for us to walk around making assertions
    about how things should be without actually backing up our claims with strong
    reasoning. Doing this can lead to pointless and badly argued opposition. It is
    better to always reason about our decisions from the user's perspective so that,
    if there is an argument, we are arguing based on what's best for the user and
    not merely what opinions are most popular, or held most strongly. Always explaining
    from the perspective of the user also helps to instill a culture where we and
    our colleagues are constantly thinking about the user, regardless of whether we're
    programming a deeply specialized API or developing a generic GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Have small and focused communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar in spirit to the *single responsibility principle* that we use when
    coding, our communications should ideally only be about one thing at a time. This
    greatly improves understanding among participants and will ensure that any decisions
    that are made relate specifically to the matter at hand. Additionally, keeping
    meetings or communications short ensures that people will be able to pay attention
    for the entire duration. Long meetings, just like long emails, eventually cause
    boredom and irritation. And with each topic or tangent added, the chances of each
    item being individually resolved dwindles massively. It's important to remember
    this when raising issues and bugs as well. Keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Ask stupid questions and have wild ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a tendency, especially in professional environments, to feign a great
    level of confidence and understanding. This can be to the detriment of knowledge
    transfer. If everyone is pretending to be masterful, then nobody will take the
    humble position that''s required to learn. It''s so valuable to be honest (and
    even stupid) in our lines of questioning. If we''re new additions to a team or
    are confused about an area of a code base, it''s important to ask the questions
    we truly have so that we can build the understanding necessary to be productive
    and reliable in our tasks. Without this understanding, we''ll flail about, probably
    causing bugs and other problems. If everyone in a team takes a position of feigned
    confidence, the team will very quickly become ineffective, with nobody able to
    resolve their questions or confusions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dfcc0d61-a646-4777-a8f2-ba13caad3aa0.png)'
  prefs: []
  type: TYPE_IMG
- en: This type of questioning we want to aim towards can be called **open questioning***; *a
    process in which we maximally divulge our ignorances so that we may gain as much
    understanding as possible in a given area. And similarly to such open questioning,
    we can say there is also **open ideating**, wherein we maximally explore and divulge
    any ideas that we have with the hope of some subset being useful.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it's the ideas left unsaid that are the most effective. Generally,
    if you feel an idea or question is too stupid or wild to say, it's usually a good
    idea to say it. The worst-case scenario (the downside) is that it is an inapplicable
    or obvious question or idea. But the best-case scenario (the upside) is that you've
    either gained understanding, asked a question that many people had on their minds
    (and thus aided their understanding), or have come up with an idea that drastically
    transforms the efficacy of the team or the quality of the code base. The upsides
    of being open are assuredly worth the downsides.
  prefs: []
  type: TYPE_NORMAL
- en: Pair programming and 1:1s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of a programmer's time is taken up by the isolated pursuit of writing code.
    This is, to many programmers, their ideal situation; they are able to block out
    the rest of the world and find fluid productivity, writing logic with speed and
    fluency. One risk of this isolation, however, is that vital knowledge of a code
    base or system can accrue in the minds of the few. Without being distributed,
    there is a risk that the code base will become increasingly specialized and complex,
    limiting the ability of newcomers and colleagues to navigate it with ease. For
    this reason, it is essential to consider how to transfer knowledge effectively
    between programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously in the book, we already have a number of formal ways
    to transfer knowledge regarding a piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Via documentation, in all its forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via the code itself, including comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via tests, including unit and E2E variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though these mediums, if built correctly, can be effective in relaying
    knowledge, there appears to always be a need for something else. The basic human
    convention of ad hoc communication is a method that has stood the test of time
    and still remains one of the most effective methods.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to learn about a new code base is through **pair programming**,
    an activity in which you sit alongside a more experienced programmer and collaborate
    together on bug fixes or feature implementations. This is especially useful for
    the unfamiliar programmer, as they are able to benefit from the existing knowledge
    and experience of their programming partner. Pair programming is also useful when
    there is an especially complex issue to solve. Having two or more brains tackling
    the problem can drastically increase problem-solving ability and limit the possibility
    of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Even outside of pair programming, generally having a Q&A or teacher-student dynamic
    can be very useful. Setting aside time to talk to individuals who have the knowledge
    you desire and asking them pointed but exploratory questions will usually yield
    a lot of understanding. Do not underestimate the power of a focused conversation
    with someone that has the knowledge you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying issues and driving change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A large part of being a programmer is identifying issues and fixing them. As
    part of our work, we employ many different moving parts, many of which will be
    maintained by other teams or individuals, and as such, we'll need to be effective
    in identifying and raising issues with code and systems that we don't have a full
    understanding of. Much like anything we do as programmers, the way in which we
    articulate these issues must take into consideration the target audience (user)of the
    issue or bug report that we're expressing. When we begin to see these pieces of
    communication as user experiences in their own right, we'll start to be genuinely
    effective communicators.
  prefs: []
  type: TYPE_NORMAL
- en: Raising bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Raising bugs is a skill. It can be done poorly or effectively. To illustrate
    this, let''s consider two issues on GitHub. Each of them raise the same issue
    but do so in drastically different ways. This is the first variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e412bfef-b4c9-4bfe-8e0e-ebf9e5935d16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the second variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1edb0db7-ebaa-4444-b58e-1dc50e8e4eeb.png)'
  prefs: []
  type: TYPE_IMG
- en: As a maintainer of this code base, which bug report would you prefer to receive?
    Obviously the second. Yet we see, time and time again, thousands of bug reports
    and raised issues on open source projects that not only fail to accurately relay
    the issue at hand but are impatiently worded and disrespectful of the time and
    efforts of the project owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, when raising a bug it is best to include, at minimum, the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem summary**: You should briefly summarize the problem being experienced
    in regular prose so that the issue can be quickly understood and triaged (possibly
    by someone who is not adept at diagnosing or fixing the exact issue).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps taken**: You should show the exact code that could be used to reproduce
    the actual behavior that you receive. The reader of your bug should be able to
    take your shared code or input parameters and reproduce the behavior themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expected behavior**: You should demonstrate what you would expect the behavior
    or output to be, given the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actual behavior**: You should demonstrate the incorrect output or behavior
    that you observed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of such a bug report for a fictional `sum()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem summary**: `sum()` does not behave intuitively when given null inputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps taken**: Called `sum(null, null)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expected behavior**: `sum(null,  null)` should return `NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actual behavior**:`sum(null, null)` returns `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may also be useful to include information about the environment in which
    the code is running, including hardware and software (for example, *MacBook 2013
    Retina, Chrome version 43.01*). The entire purpose of raising a bug is to communicate
    an unexpected or incorrect behavior with a level of accuracy and detail that'll
    allow a swift resolution. If we limit the amount of information we provide, or
    are outright rude, we drastically decrease the probability of our issue being
    resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the specific steps we should take when raising issues, there is also
    a wider question around how we should drive and inspire systemic change in a piece
    of software or a culture. We'll be exploring this next.
  prefs: []
  type: TYPE_NORMAL
- en: Driving systemic change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A bug is usually considered a self-contained technical issue with a piece of
    hardware or software. There are, however, larger or more systemic issues that
    we face every day, and these can be expressed in terms of a culture or in terms
    of the everyday conventions and patterns that we employ throughout a system. Here
    are some fictional examples of issues from within a typical IT consultancy:'
  prefs: []
  type: TYPE_NORMAL
- en: We tend to use typefaces throughout our designs that are inaccessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a hundred different standards for how to write good JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We seem to always forget to update third-party dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't feed back into the open source community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These issues are slightly too broad or subjective to be expressed as definitive
    *bugs*, so we'll need to explore other means to surface them and get them resolved.
    It may be useful to think of such systemic issues as opportunities for growth
    instead of *bugs*, as this can vastly affect how on-board people are with your
    proposed changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, the steps involved in creating systemic change are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QUALIFY: Articulate the problem with specific examples**: Find examples that
    demonstrate the problem you''re trying to describe. Ensure that these examples
    plainly show the issue and aren''t too complex. Describe the problem in a way
    that makes sense even to people that aren''t fully immersed in the *problem domain*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FEEDBACK: Gather feedback from other people**: Gather thoughts and suggestions
    from other people. Ask them open questions such as *What do you think about [...]?*.
    Accept the possibility that there is no problem, or the problem you''re encountering
    is best viewed in some other way.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IDEATE: Collaborate on possible solutions**: Source ideas on possible solutions
    from multiple people. Don''t try to reinvent the wheel. Sometimes the simplest
    solutions are the best. It''s also highly likely that systemic issues cannot be
    solved in a purely technical way. You may need to consider social and communicative
    solutions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**RAISE: Raise the problem alongside possible solutions**: Depending on what
    the problem is, raise it to the appropriate people. This may be via a team meeting,
    a 1:1 chat, or online communication. Ensure that you are raising the issue in
    a non-confrontational way and with a focus on improvement and growth.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IMPLEMENT:** **Collaboratively pick a solution and begin work**: Presuming
    that you are still considering this problem is worth pursuing, you can begin to
    implement the most preferred solution, possibly in an isolated and *Proof of Concept*
    kind of way. For example, if the problem being tackled was *We have a hundred
    different standards for how to write good JavaScript,* then you could begin to
    collaboratively implement a singular set of standards using a linter or formatter,
    reaching out for feedback along the way, and then slowly updating older code to
    align with these standards.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MEASURE: Check in frequently on the success of the solution**: Get feedback
    from people and seek quantifiable data to discern whether the selected solution
    is working as expected. If it isn''t, then consider going back to the drawing
    board and exploring other solutions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the traps in creating systemic change is to wait too long or to be too
    cautious in approaching the problem. Gaining feedback from others is really valuable,
    but it is not necessary to depend entirely upon their validation. It's sometimes
    hard for people to step outside their perspective and see certain issues, especially
    if they're very accustomed to how things are currently done. Instead of waiting
    for them to see things your way, it may be best to go ahead with an isolated version
    of your proposed solution and later prove its efficacy to them.
  prefs: []
  type: TYPE_NORMAL
- en: When people reactively defend how things are currently done, they are typically
    expressing the **status quo bias**, which is an emotional bias that prefers the
    current state of affairs. In the face of such a reaction, it is very normal for
    people to be unwelcoming of a change. So be cautious of placing too much value
    in others' negative feedback about your proposed change.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the things we wish to change within the technologies and systems we
    work with every day are not easily solved. They may be complex, unwieldy, and
    often multi-disciplinary problems. Examples of these types of problems are easily
    found on discussion forums and community feedback surrounding standards iteration,
    such as with the ECMAScript language specification. Rarely is an addition or change
    to the language accomplished simply. Patience, consideration, and communication
    are all needed to solve these problems and move ourselves and our technologies
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have tried to explore the challenge of effective communication
    in a technical context, and have broadly discussed the communicative process involved
    in taking a problem from the ideation stage to the prototype stage. We have also
    covered the task of communicating and advocating for technological change, whether
    in the form of bug reports or raising broader issues concerning systemic problems.
    Programmers are not just the authors of code; they operate as part of the systems
    they are building, as crucial agents in the iterative feedback cycles that result
    in clean software. Understanding the considerable roles we play in these systems
    and feedback cycles is hugely empowering and begins to get to the crux of what
    it means to be a clean JavaScript programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will be bringing together everything we have
    learned in the book so far, exploring a new problem domain via a case study. That'll
    conclude our exploration into clean code in JavaScript.
  prefs: []
  type: TYPE_NORMAL
