- en: Chapter 6. Working with the Angular 2 Router and Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we're already familiar with the core of the framework. We know how to
    define components and directives in order to develop the view of our applications.
    We also know how to encapsulate business-related logic into services and wire
    everything together with the dependency injection mechanism of Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explain a few more concepts that will help us build
    real-life Angular 2 applications. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The component-based router of the framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular 2 forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing template-driven forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing custom form validators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Developing the "Coders repository" application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the process of explaining the concepts mentioned earlier, we'll develop a
    sample application that contains a repository of developers. Before we start coding,
    let's explain the structure of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The "Coders repository" will allow its users to add developers either by filling
    a form with details about them or by providing the GitHub handle for the developer
    and importing his or her profile from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purpose of this chapter, we will store information on the developers
    in memory, which means that after the page is refreshed, we'll lose all the stored
    during the session data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following views:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view that adds or imports new developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A view that shows the given developer''s details. This view has two subviews:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic details**: Shows the name of the developer and her or his GitHub avatar
    if available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced profile**: Shows all the details known for the developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end result of the home page of the application will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the "Coders repository" application](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 1
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we will build only a few of the listed views. The rest of the
    application will be explained in [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Explaining
    Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each developer will be an instance of the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All the developers will reside within the `DeveloperCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The classes mentioned here encapsulate quite a simple logic and don't have anything
    Angular 2-specific, so we won't get into any details.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's continue with the implementation by exploring the new router.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Angular 2 router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, in order to bootstrap any Angular 2 application, we need
    to develop a root component. The "Coders repository" application is not any different;
    the only addition in this specific case is that we will have multiple pages that
    need to be connected together with the Angular 2 router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the imports required for the router''s configuration and
    define the root component right after this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we imported a couple of things directly from the Angular
    2 router module, which is externalized outside the framework's core.
  prefs: []
  type: TYPE_NORMAL
- en: With `ROUTER_DIRECTIVES`, the router provides a set of commonly used directives
    that we can add to the list of used ones by the root component. This way, we will
    be able to use them in the templates later.
  prefs: []
  type: TYPE_NORMAL
- en: The import `ROUTE_PROVIDERS` contains a set of router-related providers, such
    as one for injecting the `RouteParams` token into the components' constructors.
  prefs: []
  type: TYPE_NORMAL
- en: The `RouteParams` token provides an access to parameters from the route's URL
    in order to parametrize the logic associated with a given page. We'll demonstrate
    a typical use case of this provider later.
  prefs: []
  type: TYPE_NORMAL
- en: The import `LocationStrategy` class is an abstract class that defines the common
    logic between `HashLocationStrategy` (used for hash-based routing) and `PathLocationStrategy`
    (used for HTML5-based routing by taking advantage of the history API).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`HashLocationStrategy` does not support server-side rendering. This is due
    to the fact that the hash of the page does not get sent to the server, so it cannot
    find out the component associated with the given page. All modern browsers except
    IE9 support the HTML5 history API. You can find more about server-side rendering
    in the last chapter of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: The last imports we didn't take a look at are `RouteConfig`, which is a decorator
    that allows us to define the routes associated with a given component; and `Route`
    and `Redirect`, which respectively allow us to define the individual routes and
    redirects. With `RouteConfig`, we can define a hierarchy of routes, which means
    that the router of Angular 2 supports nested routing out of the box unlike its
    predecessor in AngularJS 1.x.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the root component and bootstrapping the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s define a root component and configure the application''s initial
    bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, you can notice a syntax we're already familiar with
    from [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* and [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*. We defined a component with an `app` selector, `template` that we're going
    to take a look at later, and sets of providers and directives.
  prefs: []
  type: TYPE_NORMAL
- en: The `App` component uses a single provider called `DeveloperCollection`. This
    is the class that contains all the developers stored by the application. You can
    notice that we added `ROUTER_DIRECTIVES`; it contains an array of all the directives
    defined within the Angular's router. Some of the directives within this array
    allow us to link to the other routes defined within the `@RouteConfig` decorator
    (the `routerLink` directive) and declare the place where the components associated
    with the different routes should be rendered (`router-outlet`). We'll explain
    how we can use them later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the call of the `bootstrap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As the first argument of `bootstrap`, we pass the root component of the application
    as usual. The second argument is a list of providers that will be accessible by
    the entire application. To the set of providers, we add `ROUTER_PROVIDERS` and
    we also configure the provider for the `LocationStrategy` token. The default `LocationStrategy`
    token, which Angular 2 uses, is `PathLocationStrategy` (that is, the HTML5-based
    one). However, in this case, we are going to use the hash-based one.
  prefs: []
  type: TYPE_NORMAL
- en: The two biggest advantages of the default location strategy are that it is supported
    by the server-rendering module of Angular 2, and the application's URL looks more
    natural to the end user (there's no `#` used). On the other hand, in case we use
    `PathLocationStrategy`, we may need to configure our application server, in order
    to handle the routes properly.
  prefs: []
  type: TYPE_NORMAL
- en: Using PathLocationStrategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to use `PathLocationStrategy`, we may need to provide `APP_BASE_HREF`.
    For instance, in our case, the `bootstrap` configuration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By default, the value associated with the `APP_BASE_HREF` token is `/`; it represents
    the base path name inside of the application. For instance, in our case, the "Coders
    repository" will be located under the `/ch6/ts/multi-page-template-driven/` directory
    (that is, `http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/`).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes with @RouteConfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the next step, let''s take a look at the route''s declaration placed in
    the `@RouteConfig` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As the preceding snippet shows, the `@RouteConfig` decorator accepts an array
    of routes as an argument. In the example, we defined two types of routes: using
    the classes `Route` and `Redirect`. They are used respectively to define the routes
    and redirects in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each route must define the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`component`: The component associated with the given route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the route used for referencing it in the templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path to be used for the route. It will be visible in the browser''s
    location bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Route` class also supports a data property whose value can be injected
    in the constructor of its associated component by using the `RouteData` token.
    A sample use case of the data property could be if we want to inject different
    configuration objects based on the type of the parent component that contains
    the `@RouteConfig` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the redirect contains only two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: The path to be used for the redirection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirectTo`: The path the user is redirected to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, we declared that we want the page opened by the user
    with the path `/add-dev` to be redirected to `['/dev-add']`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to make everything work, we need to define the `AddDeveloper`
    and `Home` components, which are referenced in `@RouteConfig`. Initially, we''re
    going to provide a basic implementation that we''ll incrementally extend over
    time along the chapter. In `ch6/ts/step-0`, create a file called `home.ts` and
    enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to import the `Home` component in `app.ts`. Now, open the file
    called `add_developer.ts` and enter the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using routerLink and router-outlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the route's declaration and all the components associated with the individual
    routes. The only thing left is to define the template of the root `App` component
    in order to link everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `template` property inside the `@Component`
    decorator in `ch6/ts/step-0/app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template above there are two Angular 2-specific directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`routerLink`: This allows us to add a link to a specific route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router-outlet`: This defines the container where the components associated
    with the currently selected route need to be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the `routerLink` directive. As value it accepts an array
    of route names and parameters. In our case we provide only a single route name
    prefixed with slash (since this route is on root level). Notice that the route
    name used by `routerLink` is declared by the `name` property of the route declaration
    inside `@RouteConfig`. Later in this chapter we'll see how we can link to nested
    routes and pass route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This directive allows us to declare links independently from `LocationStrategy`
    that we have configured. For instance, imagine we are using `HashLocationStrategy`;
    this means that we need to prefix all the routes in our templates with `#`. In
    case we switch to `PathLocationStrategy`, we'll need to remove all the hash prefixes.
    Another huge benefit of `routerLink` is that it uses the HTML5 history push API
    transparently to us, which saves us from a lot of boilerplates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next directive from the previous template that is new to us is `router-outlet`.
    It has similar responsibility to the `ng-view` directive in AngularJS 1.x. Basically,
    they both have the same role: to point out where the `target` component should
    be rendered. This means that according to the definition, when the user navigates
    to `/`, the `Home` component will be rendered at the position pointed out by `router-outlet`,
    same for the `AddDeveloper` component once the user navigates to `/dev-add`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have these two routes up and running! Open `http://localhost:5555/dist/dev/ch6/ts/step-0/`
    and you should see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using routerLink and router-outlet](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 2
  prefs: []
  type: TYPE_NORMAL
- en: If you don't, just take a look at `ch6/ts/step-1` that contains the end result.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy-loading with AsyncRoute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AngularJS 1.x modules allow us to group together logically related units in
    the application. However, by default, they need to be available during the initial
    application's `bootstrap` and do not allow deferred loading. This requires downloading
    the entire codebase of the application during the initial page load that, in case
    of large single-page apps, can be an unacceptable performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a perfect scenario, we would want to load only the code associated with
    the page the user is currently viewing, or to prefetch bundled modules based on
    heuristics related to the user''s behavior, which is out of the scope of this
    book. For instance, open the application from the first step of our example: `http://localhost:5555/dist/dev/ch6/ts/step-1/`.
    Once the user is at `/`, we only need the `Home` component to be available, and
    once he or she navigates to `/dev-add`, we want to load the `AddDeveloper` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect what is actually going on in Chrome DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy-loading with AsyncRoute](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 3
  prefs: []
  type: TYPE_NORMAL
- en: We can notice that during the initial page load, we downloaded the components
    associated with all the routes, even `AddDeveloper` that is not required. This
    happens because in `app.ts`, we explicitly require both the `Home` and the `AddDeveloper`
    components and use them in the `@RouteConfig` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific case, loading both the components may not seem like a big problem,
    because at this step, they are pretty simple and do not have any dependencies.
    However, in real-life applications, they will have imports of other directives,
    components, pipes, services, or even third-party libraries. Once any of the components
    is required, its entire dependency graph will be downloaded, even if the component
    is not needed at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router of Angular 2 comes with a solution to this problem. All we need
    to do is import the `AsyncRoute` class from the `angular2/router` module and use
    it inside `@RouteConfig` instead of using `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `AsyncRoute` class accepts as an argument an object
    with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loader`: A function that returns a promise that needs to be resolved with
    the component associated with the given route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the route that can be used to refer to it in the templates
    (usually, inside of the `routerLink` directive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path of the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the user navigates to a route that matches any of the async routes' definitions
    in the `@RouteConfig` decorator, its associated loader will be invoked. When the
    promise returned by the loader is resolved with a value of the target component,
    the component will be cached and rendered. Next time the user navigates to the
    same route, the cached component will be used, so the routing module won't download
    the same component twice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the preceding example uses System, however, Angular's `AsyncRoute`
    implementation is not coupled to any particular module loader. The same result
    could be achieved, for instance, with require.js.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular 2 forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's continue with the implementation of the application. For the next
    step, we'll work on the `AddDeveloper` and `Home` components. You can continue
    your implementation by extending what you currently have in `ch6/ts/step-0`, or
    if you haven't reached step 1 yet, you can keep working on the files in `ch6/ts/step-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular 2 offers two ways to develop forms with validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A template-driven approach**: Provides a declarative API where we declare
    the validations into the template of the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A model-driven approach**: Provides an imperative API with `FormBuilder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore both. Let's start with the template-driven
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Developing template-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forms are essential for each **CRUD** (**Create Retrieve Update and Delete**)
    application. In our case, we want to build a form for entering the details of
    the developers we want to store.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, we''ll have a form that allows us to enter the
    real name of a given developer, to add his or her preferred technology, enter
    an e-mail, and declare whether she or he is popular in the community or not yet.
    The end result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing template-driven forms](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 4
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following imports to `add_developer.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to do is add `FORM_DIRECTIVES` to the list of directives
    used by the `AddDeveloper` component. The `FORM_DIRECTIVES` directives contains
    a set of predefined directives for managing Angular 2 forms, such as the `form`
    and `ngModel` directives.
  prefs: []
  type: TYPE_NORMAL
- en: The `FORM_PROVIDERS` is an array with a predefined set of providers that we
    can use for injecting the values associated with their tokens in the classes of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update the `AddDeveloper` implementation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `developer` property contains the information associated with the current
    developer that we're adding with the form. The last two properties, `errorMessage`
    and `successMessage`, are going to be used respectively for displaying the current
    form's error or success messages once the developer has been successfully added
    to the developers collection, or an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into the template-driven form's markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the next step, let''s create the template of the `AddDeveloper` component
    (`step-1/add_developer.html`). Add the following content to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These two elements are intended to display the error and success messages when
    adding a new developer. They are going to be visible when `errorMessage` and `successMessage`
    respectively have non-falsy values (that is, something different from the empty
    string, `false`, `undefined`, `0`, `NaN`, or `null`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s develop the actual form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We declare a new form using the HTML `form` tag. Once Angular 2 finds such tags
    in a template with an included form directive in the parent component, it will
    automatically enhance its functionality in order to be used as an Angular form.
    Once the form is processed by Angular, we can apply form validation and data-bindings.
    After this, using `#f="ngForm"`, we will define a local variable for the template
    called `f`, which allows us to reference to the current form. The last thing left
    from the form element is the submit event handler. We use a syntax that we're
    already familiar with `(ngSubmit)="expr"`, where in this case, the value of the
    expression is the call of the `addDeveloper` method attached to the component's
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the `div` element with class name `control-group`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is not an Angular-specific class; it is a `CSS` class defined
    by Bootstrap that we use in order to provide a better look and feel to the form.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of it, we can find a `label` element that doesn't have any Angular-specific
    markup and an input element that allows us to set the real name of the current
    developer. We set the control to be of a type text and declare its identifier
    to equal `realNameInput`. The required attribute is defined by the HTML5 specification
    and is used for validation. By using it on the element, we declare that it is
    required for this element to have a value. Although this attribute is not Angular-specific
    using the `ngControl` attribute, Angular will extend the semantics of the required
    attribute by including validation behavior. This behavior includes setting specific
    `CSS` classes on the control when its status changes and managing its state that
    the framework keeps internally.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngControl` directive is a selector of the `NgControlName` directive. It
    enhances the behavior of the form controls by running validation over them for
    the change of their values, and applying specific classes during the controls'
    life cycle. You might be familiar with this from AngularJS 1.x where the form
    controls are decorated with the `ng-pristine`, `ng-invalid`, and `ng-valid` classes,
    and so on, in specific phases of their lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the `CSS` classes that the framework adds to
    the form controls during their lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Classes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-untouched` | The control hasn''t been visited |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-touched` | The control has been visited |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-pristine` | The control''s value hasn''t been changed |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-dirty` | The control''s value has been changed |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-valid` | All the validators attached to the control have returned `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ng-invalid` | Any of the validators attached to the control has a `false`
    value |'
  prefs: []
  type: TYPE_TB
- en: 'According to this table, we can define that we want all the input controls
    with invalid value to have a red border in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The exact semantics behind the preceding `CSS` in the context of Angular 2 is
    to use a red border for all the input elements whose values have been changed
    and are invalid according to the validators attached to them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how we can attach different validation behavior to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in form validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already saw that we can alter validation behavior to any control by using
    the `required` attribute. Angular 2 provides two more built-in validators, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minlength`: Allows us to specify the minimum length of the value that a given
    control should have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength`: Allows us to specify the maximum length of the value that a given
    control should have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These validators are defined with Angular 2 directives and can be used in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This way, we specify that we want the value of the input to be between `2` and
    `30` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom control validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another data property defined in the `Developer` class is the `email` field.
    Let''s add an input field for this property. Above the button in the preceding
    form, add the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can think of the `[(ngModel)]` attribute as an alternative to the `ng-model`
    directive from AngularJS 1.x. We will explain it in detail in the *Two-way data
    binding with Angular 2* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Angular 2 provides a set of predefined validators, they are not enough
    for all the various formats our data can live in. Sometimes, we''ll need custom
    validation logic for our application-specific data. For instance, in this case,
    we want to define an e-mail validator. A typical regular expression, which works
    in general cases (but does not cover the entire specification that defines the
    format of the e-mail addresses), looks as follows: `/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ch6/ts/step-1/add_developer.ts`, define a function that accepts an instance
    of Angular 2 control as an argument and returns `null` if the control''s value
    is empty or matches the regular expression mentioned earlier, and `{ ''invalidEmail'':
    true }` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the modules `angular2/common` and `angular2/core` import `NG_VALIDATORS`
    and `Directive`, and wrap this validation function within the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined a single multiprovider for the token `NG_VALIDATORS`.
    Once we inject the value associated with this token, we'll get an array with all
    the validators attached to the given control (for reference, take a look at the
    section for multiproviders in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The only two steps left in order to make our custom validation work are to
    first add the `email-input` attribute to the e-mail control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to add the directive to the list used by the component `AddDeveloper`
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're using an external template for the `AddDeveloper` control. There's no
    ultimate answer to whether a given template should be externalized or inlined
    within the component with `templateUrl` or `template`, respectively. The best
    practice states that we should inline the short templates and externalize the
    longer ones, but there's no specific definition as to which templates are considered
    short and which are long. The decision on whether the template should be used
    inline or put into an external file depends on the developer's personal preferences
    or common conventions within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Using select inputs with Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the next step, we should allow the user of the application to enter the technology
    into which the input developer has the most proficiency. We can define a list
    of technologies and show them in the form as a select input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AddDeveloper` class, add the `technologies` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the template, just above the `submit` button, add the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like for the input elements we declared earlier, Angular 2 will add the
    same classes depending on the state of the select input. In order to show red
    border around the select element when its value is invalid, we need to alter the
    `CSS` rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that inlining all the styles in our components' declaration could be
    a bad practice, because this way, they won't be reusable. What we can do is extract
    all the common styles across our components into separate files. The `@Component`
    decorator has a property called `styleUrls` of type `array` where we can add a
    reference to the extracted styles used by the given component. This way, we can
    inline only the component-specific styles if required.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we will declare the name of the control to be equal to "technology"
    using `ngControl="technology"`. By using the `required` attribute, we will declare
    that the user of the application must specify the technology into which the current
    developer is proficient. Let's skip the `[(ngModel)]` attribute for the last time
    and see how we can define the select element's options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `select` element, we will define the different options using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a syntax we're already familiar with. We will simply iterate over all
    the technologies defined within the `AddDeveloper` class, and for each technology,
    we will show an option element with a value of the technology name.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NgForm directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already mentioned that the form directive enhances the HTML5 form''s behavior
    by adding some additional Angular 2-specific logic. Now, let''s take a step back
    and take a look at the form that surrounds the input elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined a new identifier called `f`, which references
    to the form. We can think of the form as a composition of controls; we can access
    the individual controls through the form's controls property. On top of this,
    the form has the **touched**, **untouched**, **pristine**, **dirty**, **invalid**,
    and **valid** properties, which depend on the individual controls defined within
    the form. For example, if none of the controls within the form has been touched,
    then the form itself is going to be with the status untouched. However, if any
    of the controls in the form has been touched at least once, the form will be with
    the status touched as well. Similarly the form will be valid only if all its controls
    are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate the usage of the `form` element, let''s define a component
    with the selector `control-errors`, which shows the current errors for a given
    control. We can use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've also added the `maxlength` validator to the `realName` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `control-errors` element has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`control`: Declares the name of the control we want to show errors for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errors`: Creates a mapping between control error and an error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now add the following imports in `add_developer.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In these imports, the `NgControl` class is the abstract class that represents
    the individual form components, `NgForm` represents the Angular forms, and `Host`
    is a parameter decorator related to the dependency injection mechanism, which
    we already covered in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a part of the component''s definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ControlErrors` component defines two inputs: `control`—the name of the
    control declared with the `ngControl` directive (the value of the `ngControl`
    attribute)—and `errors`—the mapping between an error and an error message. They
    can be specified respectively by the `control` and the `errors` attributes of
    the `control-errors` element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we have control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare its associated `control-errors` component by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `currentError` getter, in the preceding snippet, we need to do
    the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a reference to the component declared with the `control` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the error message associated with any of the errors that make the current
    control invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a snippet that implements this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line of the implementation of `currentError`, we get the target
    control by using the `controls` property of the injected form. It is of the type
    `{[key: string]: AbstractControl}`, where the key is the name of the control we''ve
    declared with the `ngControl` directive. Once we have a reference to the instance
    of the target control, we can check whether its status is touched (that is, whether
    it has been focused), and if it is, we can loop over all the errors within the
    `errors` property of the instance of `ControlError`. The `map` function will return
    an array with either an error message or a `null` value. The only thing left is
    to filter all the `null` values and get only the error messages. Once we get the
    error messages for each error, we will return the last one by popping it from
    the `errorMessages` array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the NgForm directive](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 5
  prefs: []
  type: TYPE_NORMAL
- en: If you experience any problems during the implementation of the `ControlErrors`
    component, you can take a look at its implementation at `ch6/ts/multi-page-template-driven/add_developer.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hasError` method of every control accepts as an argument an error message
    identifier, which is defined by the validator. For instance, in the preceding
    example where we defined the custom e-mail validator, we will return the following
    object literal when the input control has an invalid value: `{ ''invalidEmail'':
    true }`. If we apply the `ControlErrors` component to the e-mail control, its
    declaration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Two-way data-binding with Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most famous rumors about Angular 2 was that the two-way data-binding
    functionality was removed because of the enforced unidirectional dataflow. This
    is not exactly true; the Angular 2's form module implements a directive with the
    selector `[(ngModel)]`, which allows us to easily achieve data-binding in two
    directions—from the view to the model and from the model to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we imported the directive `NgModel` from the `angular2/common`
    package. Later, in the template, we set the attribute `[(ngModel)]` to the value
    `name`.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the syntax `[(ngModel)]` might seem a little bit unusual. From [Chapter
    4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting
    Started with Angular 2 Components and Directives"), *Getting Started with Angular
    2 Components and Directives*, we know that the syntax `(eventName)` is used for
    binding to events (or outputs) triggered by a given component. On the other hand,
    we use the syntax `[propertyName]="foobar"` to achieve one-way data-binding by
    setting the value of the property (or in the terminology of the Angular 2 components,
    the input) with the name `propertyName` to the result of the evaluation of the
    expression `foobar`. The syntax `NgModel` just combines both in order to achieve
    data-binding in two directions. That's why we can think of it more like a syntax
    sugar, rather than a new concept. One of the main advantages of this syntax compared
    to AngularJS 1.x is that we can tell which bindings are one-way and which are
    two-way only by looking at the template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `(click)` has its canonical syntax `on-click` and `[propertyName]`
    has `bind-propertyName`, the alternative syntax of `[(ngModel)]` is `bindon-ngModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open `http://localhost:5555/dist/dev/ch6/ts/simple-two-way-data-binding/`,
    you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data-binding with Angular 2](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 6
  prefs: []
  type: TYPE_NORMAL
- en: Once you change the value of the input box, it will automatically update the
    following label.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already used the `NgModel` directive in the preceding templates. For example,
    we bound to the developer''s e-mail using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This way, the value of the e-mail property of the developer object attached
    to the `AddDeveloper` component's instance is going to be updated once we change
    the value of the text input.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s peek at the interface of the `AddDeveloper` component''s controller
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It has a field of the type `Developer`, and we bind the form controls to its
    properties using the `NgModel` directive. The class also has a method called `addDeveloper`,
    which is being invoked on the submission of the form. We declare this by binding
    to the `submit` event using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can notice two more things. We got a reference
    to the form using `#f="ngForm"` and we bound the disabled property of the button
    to the expression: `!f.form.valid`. We already described the `NgForm` control
    in the previous section; its valid property will have a value true once all the
    controls within the form have valid values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we''ve entered valid values for all the input controls
    in the form. This means that its **submit** button will be enabled. Once we press
    *Enter* or we click on the **Add** button, the `addDeveloper` method will be invoked.
    The following is a sample implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we set the `id` property of the current developer to equal the total
    number of developers in `DeveloperCollection`, plus one. Later, we added the developer
    to the collection and set the value of the `successMessage` property. Right after
    this, we set the property submitted to equal to `true`, which will result in hiding
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the stored developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can add a new entry to the developers' collection, let's show a
    list of all the developers on the front page of the "Coders repository".
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `ch6/ts/step-1/home.ts` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing new to us here. We extend the functionality of the `Home` component
    by providing an external template and implementing the `getDevelopers` method,
    which delegates its call to the instance of `DeveloperCollection` that is injected
    in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template itself is something that we''re already familiar with as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We list all the developers as rows within an HTML table. For each developer,
    we check the status of its popular flag. If its value is `true`, then for the
    **Popular** column, we show a span with the text `Yes`, otherwise we set the text
    to `No`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter a few developers in the **Add Developer** page and you navigate
    to the home page after that, you should see a result similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing all the stored developers](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig. 7
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the complete functionality of the application at `ch6/ts/multi-page-template-driven`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explained the basics of routing in Angular 2\. We took a look
    at how we can define different routes and implement the components associated
    with them that are displayed on route change. In order to link to the different
    routes, we explained `routerLink`, and we also used the `router-outlet` directives
    for pointing out where the components associated with the individual routes should
    be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we took a look at was the Angular 2 forms functionality with built-in
    and custom validation. After this, we explained the `NgModel` directive, which
    provides to us two-way data-binding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how we can develop model-driven forms and
    child and parametrized routes, use the `Http` module for making RESTful calls,
    and transform data with custom pipes.
  prefs: []
  type: TYPE_NORMAL
