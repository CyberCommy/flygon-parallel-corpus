- en: Creating a Markdown Editor with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is hard to deal with content on the internet without encountering markdown.
    Markdown is a simplified way to create content using plain text that is easily
    converted into simple HTML. In this chapter, we are going to investigate what
    it takes to create a parser that will convert a subset of the markup format into
    HTML content. We will automatically convert relevant tags into the first three
    header levels, the horizontal rule, and paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have covered how to create a simple Bootstrap
    web page and reference the JavaScript generated from our TypeScript, as well as
    hooking up to a simple event handler. We will also cover how to create classes
    using simple design patterns and how to design classes with single responsibilities,
    which are techniques that serve us well as professional developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Bootstrap page that overrides the Bootstrap styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing which tags we are going to use in our markdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping our markdown tag types to HTML tag types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing our converted markdown in a custom class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the visitor pattern to update our document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the chain-of-responsibility pattern to apply tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking this back to our HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a grasp of some of the concepts that we are going to cover
    throughout the rest of this book, we are going to start putting them into practice
    by creating a project that parses a very simple markdown format while the user
    types into a text area and displays the resulting web page alongside it. Unlike
    full markdown parsers, we are going to concentrate on formatting the first three
    header types, the horizontal rule, and paragraphs. The markup is restricted to
    breaking lines down by newline characters and looking at the start of a line.
    It then determines whether or not a particular tag is present and, if not, it
    assumes the current line is a paragraph. The reason we have chosen this implementation
    is because it is a simple task to pick up immediately. While it is simple, it
    offers sufficient depth to show that we are going to tackle topics that require
    us to give real thought to how we will structure the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **user interface** (**UI**), uses Bootstrap, and we will look at how to
    hook up to a change event handler and how to get and update HTML content from
    the current web page. This is what our project will look like when we have finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e9cd123-84da-441a-b275-ff822a2de7c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our overview, we can move on to getting started with creating
    the HTML project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with a simple HTML project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project is a simple HTML and TypeScript file combination. Create a directory
    to hold the HTML and TypeScript files. Our JavaScript will reside in a script
    folder under this directory. The following `tsconfig.json` file is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Writing a simple markdown parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was thinking about the project that we are going to tackle in this chapter,
    I had a clear objective in mind. While we are writing this code, we are going
    to try out things such as patterns and good **object-oriented** (**OO**) practices,
    such as classes having a single responsibility. If we can apply these techniques
    right from the start, we will soon get into the habit of using them and this will
    translate into useful development skills.
  prefs: []
  type: TYPE_NORMAL
- en: As professional developers, before we write any code, we should gather the requirements
    that we are going to use and ensure that we are making no assumptions about what
    our application will do. We may think that we know what we want our application
    to do, but if we make a list of our requirements, we'll make sure that we understand
    everything that we are meant to deliver and we'll come up with a handy checklist
    to tick features off as we complete them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is my list:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create an application to parse markdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will type into a text area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the text area changes, we will parse the entire document again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will break the document down based on where the user presses the *Enter*
    key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opening characters will determine whether or not the line is markdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entering # followed by a space is replaced by an H1 heading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entering ## followed by a space is replaced by an H2 heading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entering ### followed by a space is replaced by an H3 heading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering --- is replaced by a horizontal rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the line does not start with markdown, the line is treated as a paragraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting HTML will be displayed in a label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the content in the markdown text area is empty, the label will contain an
    empty paragraph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layout will be done in Bootstrap and the content will stretch to 100% height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given those requirements, we have a good idea of what we are going to deliver,
    so we are starting off by creating our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Bootstrap UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features*, we looked at the basics of creating a UI using Bootstrap. We will take
    the same basic page and adjust it to fit our needs with a couple of little tweaks.
    Our starting point is this page, which stretches across the full width of the
    screen by setting the container to use `container-fluid`, and divides the interface
    into two equal parts by setting `col-lg-6` on both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add our text area and label components to our form, we find that rendering
    them in this row does not automatically expand them to fill the height of the
    screen. We need to make a couple of adjustments. First, we need to manually set
    the style of the `html` and `body` tags to fill the available space. To do this,
    we add the following in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we can take advantage of a new feature in Bootstrap 4,
    which is applying `h-100` to these classes to fill 100% of the space. We are also
    going to take this opportunity to add the text area and label, as well as giving
    them IDs that we can look up from our TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we finish off our page, we are going to start writing TypeScript code
    that we can use in our application. Add a file called `MarkdownParser.ts` to hold
    our TypeScript code and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We created this class so that we could get the text area and the label based
    on their IDs. Once we have these, we are going to hook into the text area, key
    up the event, and write the keypress value back to the label. Notice how, even
    though we are not in a web page at this point, TypeScript implicitly gives us
    access to standard web page behaviors. This allows us to retrieve the text area
    and label based on the IDs we previously entered, and to cast them to the appropriate
    type. With this, we gain the ability to do things such as subscribe to events
    or access an element's `innerHTML`.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we are going to use the `MarkdownParser.ts` file
    for all of our TypeScript in this chapter. Normally, we would separate the classes
    into their own files, but this single-file structure should be simpler to review
    as we progress through the code. In future chapters, we will be moving away from
    a single file because those projects are much more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these interface elements, we hook up to the keyup event. When the
    event is fired, we look to see if we have any text in the text area and set the
    HTML of the label with the content (if it is present), or the empty paragraph
    (if it is not present). The reason we have written this code is because we want
    to use it to ensure that we properly link up our generated JavaScript and the
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: We use the keyup event—rather than the keydown or keypress events—because the
    key is not added into the text area until the keypress event is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now revisit our web page and add the missing bits so that we can update
    our label when our text area changes. Just before the `</body>` tag, add the following
    to reference the JavaScript file that TypeScript produces, in order to create
    an instance of our `HtmlHandler` class and hook the `markdown` and `markdown-output`
    elements together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a quick review, this is what the HTML file looks like at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application at this point, typing in the text area automatically
    updates the label. The following screenshot shows what our application looks like
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9ef6ff7-6136-43b3-9684-ad5644531509.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we know that we can automatically update our web page, we have no more changes
    that need to be made to it. All the code that we are about to write will be done
    entirely in the TypeScript file. Going back to our list of requirements, we have
    done enough to satisfy the last three requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping our markdown tag types to HTML tag types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our requirements, we set out a master list of tags that our parser is going
    to handle. In order to identify these tags, we are going to add an enumeration
    consisting of the tags we are making available to our users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From our requirements, we also know that we need to translate between these
    tags and their equivalent opening and closing HTML tags. The way that we are going
    to do this is to map `tagType` to an equivalent HTML tag. To do this, we are going
    to create a class that has the sole responsibility of handling this mapping for
    us. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At first, the use of `readonly` on a type can appear confusing. What this keyword
    means is that, after the class has been instantiated, `tagType` cannot be recreated
    elsewhere in the class. This means that we can set up our mappings in the constructor
    safe, knowing that we are not going to call `this.tagType = new Map<TagType, string>();`
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a way to retrieve opening and closing tags from this class. We''re
    going to start by creating a method to get the opening tag from `tagType`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is pretty straightforward. It starts by trying to get `tagType`
    from the map. With the code we currently have, we will always have an entry in
    the map, but we could extend the enumeration in the future and forget to add the
    tag to the list of tags. That is why we check to see if the tag is present; if
    it is, we return the tag enclosed in `<>`. If the tag is not present, we return
    a paragraph tag as a default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at `ClosingTag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at these two methods, we can see that they are almost identical. When
    we think about the problem of creating our HTML tag, we realize that the only
    difference between an opening and a closing tag is that the closing tag has a
    `/` in it. With that in mind, we can change the code to use a helper method that
    accepts whether the tag starts with `<` or `</`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains is for us to add methods to retrieve the opening and closing
    tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Pulling this all together, the code for our `TagTypeToHtml` class now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The single responsibility of our `TagTypeToHtml` class is mapping `tagType`
    to an HTML tag. Something that we are going to keep coming back to throughout
    this chapter is that we want classes to have a single responsibility. In OO theory,
    this is known as one of the principles of **SOLID** (short for **Single Responsibility
    Principle**, **Open/Closed Principle**, **Liskov Substitution Principle**, **Interface
    Segregation Principle**, **Dependency Inversion Principle**) design. The acronym
    refers to a set of complementary development techniques to create more robust
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This handy acronym serves to guide us on how to structure classes and the most
    important part, in my opinion, is the Single Responsibility Principle, which states
    that a class should do one thing and one thing only. While I would certainly recommend
    reading about this topic (and we will touch on other aspects of it as we progress),
    in my opinion, the most important part of SOLID design is that classes are responsible
    for one thing and one thing only; everything else flows out of that principle.
    Classes that only do one thing are generally much easier to test and they are
    a lot easier to understand. That does not mean that they should only have one
    method. They can have many methods, as long as they are all related to the purpose
    of the class. We will cover this topic again and again throughout the book because
    it is so important.
  prefs: []
  type: TYPE_NORMAL
- en: Representing our converted markdown using a markdown document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we are parsing our content, we need a mechanism to actually store the
    text that we are creating during the parsing process. We could just use a global
    string and update it directly, but that would become problematic if we decided
    to asynchronously add to it later on. The main reason for not using a string is
    down to Single Responsibility Principle again. If we were using a simple string,
    then each piece of code that we add to the text would end up having to write to
    the string in the correct way, which means that they would be mixing reading the
    markdown with writing to the HTML output. When we discuss it like that, it becomes
    apparent that we need to have a separate means of writing the HTML content out.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means for us is that we are going to want code that can accept a
    number of strings to form the content (these could include our HTML tags, so we
    don''t want to just accept a single string). We also want a means of getting our
    document when we have finished building it up. We are going to start by defining
    an interface, which will act as the contract that consuming code will implement.
    Of particular interest here is that we are going to allow our code to accept any
    number of items in our `Add` method, so we will be using a REST parameter here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this interface, we can create our `MarkdownDocument` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class is incredibly straightforward. For each piece of content passed in
    to our `Add` method, we add it to a member variable called `content`. As this
    is declared as private, our `Get` method returns the same variable. This is why
    I like having classes with a single responsibility—in this case, they are just
    updating the content; they tend to be a lot cleaner and easier to understand than
    convoluted classes that do many different things. The main thing is that we can
    do whatever we like to keep our content updated internally, as we have hidden
    *how* we maintain the document from the consuming code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are going to be parsing our document one line at a time, we are going
    to use a class to represent the current line that we are processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our class is very simple. Again, we have decided not to go with a simple string
    to pass around our code base because this class makes our intent clear—we want
    to parse the current line. If we had just used a string to represent the line,
    it would be too easy to pass the wrong thing when we wanted to use the line.
  prefs: []
  type: TYPE_NORMAL
- en: Updating markdown document using visitors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features*, we briefly touched on patterns. Simply put, patterns in the software
    development process are general solutions to particular problems. This simply
    means that we use the name of a pattern to convey to others that we are solving
    a problem using particular and well-established code examples. For instance, if
    we say to another developer that we are solving a problem using a mediator pattern,
    as long as the other developer is aware of patterns, they will have a pretty good
    idea as to how we will be structuring our code.
  prefs: []
  type: TYPE_NORMAL
- en: When I was planning this code out, I made a conscious decision early on that
    we would be using something called the visitor pattern with our code. Before we
    look at the code we are going to create, we will have a look at what this pattern
    is and why we are going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visitor pattern is what is known as a **behavioral pattern**. The term behavioral
    pattern is simply a classification of a group of patterns that are concerned with
    the way that classes and objects communicate. What the visitor pattern gives us
    is the ability to separate an algorithm from the object that the algorithm works
    on. This sounds a lot more complicated than it really is.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the motivations behind us using the visitor pattern is that we want
    to take the common `ParseElement` class and apply different operations on it,
    depending on what the underlying markdown is, which ultimately leads to us building
    up the `MarkdownDocument` class. The idea here is that if the content the user
    types in is something we would represent in HTML as a paragraph, we want to add
    different tags to those used, for example, when the content represents a horizontal
    rule. The convention for the visitor pattern is that we have two interfaces, `IVisitor`
    and `IVisitable`. At their most basic, these interfaces look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind these interfaces is that the object will be visitable, so when
    it needs to perform the relevant operations, it accepts the visitor so that it
    can visit the object.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the visitor pattern to our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know what the visitor pattern is, let''s take a look at how we
    are going to apply it to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create the `IVisitor` and `IVisitable` interfaces as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When our code reaches the point where `Visit` is called, we are going to use
    the `TagTypeToHtml` class to add the relevant opening HTML tag, the line of text,
    and then the matching closing HTML tag to our `MarkdownDocument`. As this is common
    to each of our tag types, we can implement a base class that encapsulates this
    behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the concrete visitor implementations. This is as simple
    as creating the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, this code may seem like overkill, but it serves a purpose. If we
    take `Header1Visitor`, for instance, we have a class that has the single responsibility
    of taking the current line and adding it to our markdown document wrapped in H1
    tags. We could litter our code with classes that were responsible for checking
    whether the line started with #, and then remove the # from the start, prior to
    adding the H1 tags and the current line. However, that makes the code harder to
    test and more likely to break, especially if we want to change the behavior. Also,
    the more tags we add, the more fragile this code will become.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other side of the visitor pattern code is the `IVisitable` implementation. For
    our current code, we know that we want to visit the relevant visitor whenever
    we call `Accept`. What this means to our code is that we can have a single visitable
    class that implements our `IVisitable` interface. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we have put the simplest visitor pattern implementation in
    place that we could. There are many variants of the visitor pattern, so we have
    gone with an implementation that respects the design philosophy of the pattern
    without slavishly sticking to it. That's the beauty of patterns—while they give
    us a guide as to how to do something, we should not feel that we have to blindly
    follow a particular implementation if modifying it slightly differently suits
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which tags to apply by using the chain-of-responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the means to transform a simple line into an HTML encoded line,
    we need a way to decide which tags we should apply. Right from the start, I knew
    that we would be applying yet another pattern, one that is eminently suitable
    for asking the question, "*Should I handle this tag?*" If no, then I will forward
    this on so that something else can decide whether or not it should handle the
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use another behavioral pattern to handle this—the chain-of-responsibility
    pattern. This pattern lets us chain together a series of classes by creating a
    class that accepts the next class in the chain, along with a method to handle
    a request. Depending on the internal logic of the request handler, it may pass
    processing onto the next class in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start off with our base class, we can see what this pattern gives us
    and how we are going to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The next class in our chain is set using `SetNext`. `HandleRequest` works by
    calling our abstract `CanHandle` method to see whether the current class can handle
    the request. If it cannot handle the request and if `this.next` is not `null`
    (note the use of union types here), we forward the request onto the next class.
    This is repeated until we can either handle the request or `this.next` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a concrete implementation of our `Handler` class. First, we
    will add our constructor and member variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor accepts the instance of the markdown document; the `string`
    that represents our `tagType`, for example, *#;* and the relevant visitor will
    visit the class if we get a matching tag. Before we see what the code for `CanHandle`
    looks like, we need to take a slight detour and introduce a class that will help
    us parse the current line and see if the tag is present at the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a class that exists purely to parse the string, and
    looks to see if it starts with the relevant markdown tag. What is special about
    our `Parse` method is that we are returning something called a **tuple**. We can
    think of a tuple as a fixed-size array that can have different types at different
    positions in the array. In our case, we are going to return a `boolean` type and
    a `string` type. The `boolean` type indicates whether or not the tag was found,
    and the `string` type will return the text without the tag at the start; for example,
    if the `string` was `# Hello` and the tag was `#` , we would want to return `Hello`.
    The code that checks for the tag is very straightforward; it simply looks to see
    if the text starts with the tag. If it does, we set the `boolean` part of our
    tuple to `true` and use `substr` to get the remainder of our text. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `LineParser` class, we can apply that in our `CanHandle`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using our parser to build a tuple where the first parameter states
    whether or not the tag was present, and the second parameter contains the text
    without the tag if the tag was present. If the markdown tag was present in our
    string, we call the `Accept` method on our `Visitable` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, we could have directly called `this.visitor.Visit(request,
    this.document);`, however, that provides us with more knowledge about how to perform
    the visit into this class than I would like. By using the `Accept` approach, if
    we make our visitors more complex, we avoid having to revisit this method as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our `ParseChainHandler` looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a special case that we need to handle. We know that the paragraph has
    no tag associated with it—if there are no matches through the rest of the chain,
    by default, it''s a paragraph. This means that we need a slightly different handler
    to cope with paragraphs, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this infrastructure in place, we are now ready to create the concrete
    handlers for the appropriate tags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a route through from the tag, for example, `---`,to the appropriate
    visitor. We have now linked our chain-of-responsibility pattern to our visitor
    pattern. We have one final thing that we need to do: set up the chain. To do this,
    let''s use a separate class that builds our chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This simple-looking method accomplishes a lot for us. The first few statements
    initialize the chain-of-responsibility handlers for us; first for the headers,
    then for the horizontal rule, and finally for the paragraph handler. Remembering
    that this is only part of what we need to do here, we then go through the headers
    and the horizontal rule and set up the next item in the chain. Header 1 will forward
    calls on to header 2, header 2 forwards to header 3, and so on. The reason we
    don't set any further chained items after the paragraph handler is because that
    is the last case we want to handle. If the user isn't typing `header1`, `header2`,
    `header3`, or `horizontalRule`, then we're going to treat this as a paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last class that we are going to write is used to take the text that the
    user is typing in and split it into individual lines, and create our `ParseElement`,
    chain-of-responsibility handlers, and `MarkdownDocument` instance. Each line is
    then forwarded to `Header1ChainHandler` to start the processing of the line. Finally,
    we get the text from the document and return it so that we can display it in the
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can generate our HTML content, we have one change left to do. We
    are going to revisit the `HtmlHandler` method and change it so that it calls our `ToHtml`
    markdown method. At the same time, we are going to address an issue with our original
    implementation where refreshing the page loses our content until we press a key.
    To handle this, we are going to add a `window.onload` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run our application, it displays the rendered HTML content, even
    when we refresh our page. We have successfully created a simple markdown editor
    that satisfies the points that we laid out in our requirements, gathering stage.
  prefs: []
  type: TYPE_NORMAL
- en: I cannot stress enough how important the requirements, gathering stage is. All
    too often, poor requirements lead to us having to make assumptions about the behavior
    of an application. These assumptions can lead to delivering an application that
    users do not want. If you find yourself making an assumption, go back and ask
    your users exactly what they want. As we built our code here, we referred back
    to our requirements to make sure that we were building exactly what we were meant
    to build.
  prefs: []
  type: TYPE_NORMAL
- en: A final point about requirements—they change. It is common for requirements
    to evolve or get removed while we are writing an application. When they do change,
    we make sure that the requirements are updated, that we are making no assumptions,
    and that we check the work that has already been produced to make sure that it
    matches the updated requirements. This is what we do because we are professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built an application that responded to what the user
    was typing into a text area, and updated a label with converted text. The conversion
    of this text was handled by classes, each of which had a single responsibility.
    The reason we concentrated on producing classes that only did one thing was to
    learn, right from the start, how to use industry best practices to make our code
    cleaner and less prone to errors, since a well-designed class that only does one
    thing is less likely to have problems than classes that do lots of different things.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the visitor and chain-of-responsibility patterns in order to see
    how we could separate the text processing into deciding whether a line contained
    markdown and adding the appropriate HTML-encoded text. We started introducing
    patterns because patterns occur in so many different software development problems.
    Not only do they provide clear details about how to solve a problem; they also
    provide a clear language so that if someone says that a piece of code needs a
    particular pattern, there is no ambiguity for other developers about what that
    code needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at our first application using React.js,
    for when we build a personal contacts manager.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application currently only reacts to the user changing the content using
    the keyboard. It is possible that the user could use the context menu to paste
    the text in. Enhance the `HtmlHandler` method to cope with the user pasting text
    in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added H1 to H3 support. HTML also supports H4, H5, and H6\. Add support for
    these tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CanHandle` code, we are calling the `Visitable` code. Change the base
    `Handler` class so that it calls the `Accept` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about using design patterns, I would recommend the book
    *TypeScript Design Patterns (*[https://www.packtpub.com/application-development/typescript-design-patterns](https://www.packtpub.com/application-development/typescript-design-patterns))
    by Vilic Vane, published by Packt.
  prefs: []
  type: TYPE_NORMAL
