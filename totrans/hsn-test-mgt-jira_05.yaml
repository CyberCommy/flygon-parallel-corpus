- en: Understanding Components of Testing with Jira
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requirements, test suites, a test plan, traceability, and reports are the main
    components of testing provided as part of the Jira test management solution. Test
    suites, also known as test repositories, are used to organize test cases. Test
    planning is an important factor before we move on to the test execution phase.
    Traceability and reports help us to track the coverage and progress of the testing
    efforts in a project-release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the approach of Test Management using its plugins
    in Jira. First, we'll understand the requirements and some basics of a test plan,
    along with issue types, including the default workflow that every issue type goes
    through in Jira. We'll learn to create customized workflows and add them to the
    project using workflow schemes. Then we'll create our own issue type and apply
    this newly-created workflow to that issue type. We'll also take a look at issue
    types in detail and compare the test suite features provided by all three plugins.
    We'll start by understanding some basics of the test plan and where it resides
    in Jira plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: What are requirements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is test suite and what are its advantages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is test plan?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a traceability matrix and what are its benefits?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reports and their types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requirements are basically parts of the solution that will help you solve the
    end user's problems. They can also be desirable items that will attract the end
    user to use the product or service. Further, requirements may also contain functions
    that might be widely used in the existing products available in the market, which
    makes it critical to be available for a new product to enter the market.
  prefs: []
  type: TYPE_NORMAL
- en: What are requirements?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requirements can be a functional/non-functional and implicit/explicit list of
    features. Either way, they basically get classified as either core needs or good-to-haves
    for a product or service that will satisfy the customer. The specification varies
    on the target audience and the type of product being developed by the organization.
  prefs: []
  type: TYPE_NORMAL
- en: In the software industry, once the project is formally initiated and is allocated
    to a software development team, the first task for the project stakeholder is
    to gather the requirements. Gathering requirements helps the team to understand
    the scope of the project, timeline, budget, supported technology, its limitations,
    number of resources required, features requested, the customer's wish list, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: After the requirements are gathered and documented, the project coordinator
    (who acts as a liaison between the end user and the software development team)
    gets it approved from the end user. On receiving the go-ahead for the development
    phase, the requirements are analyzed and broken down into smaller work packets
    that become tasks for the team. Jira provides an effective way to help the team
    to organize and manage these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jira was built as a ticket-based system, where each task is represented as
    a ticket. Thus, requirements that are tasks for the team become a ticket in Jira.
    Jira also allows for the classification of tasks utilizing issue types (which
    basically helps in categorizing requirements to segregate work). Every Jira project
    has supported issue types by default. Now, if you''re wondering whether your project
    supports an issue type, this can be confirmed on the first screen when creating
    a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/599a661d-0526-4091-ab7c-ace2993639f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The default Issue Types that are seen in the preceding screenshot are Bug, Task,
    Sub-task, Story, and Epic. Jira also provides flexibility to customize the supported
    issue types for a project by adding, editing, and/or deleting issue types, as
    well as workflows. If the project or organization requires further segregation
    and classification of items in the project beyond what's available by default,
    then team members can create their own issue types as well, which we'll see in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](da0a480b-81d0-4369-8359-ddd0fd749ffe.xhtml), *Requirement Management*,
    we'll learn how to configure Jira issue types as requirements for testing. We'll
    also use these issue types to link with relevant test cases using Jira plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Issue types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating and using a new issue type involves the following six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as `Admin`, navigate to Administration | Issues | Add issue type, and
    follow the steps from the official documentation (*Defining issue type field values*: [https://confluence.atlassian.com/adminjiraserver/defining-issue-type-field-values-938847087.html](https://confluence.atlassian.com/adminjiraserver/defining-issue-type-field-values-938847087.html))
    to add a new issue type. We have created a new issue type named `ProdIssue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/b165170f-1664-4f94-8582-5dad5bcf1949.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a new workflow for `ProdIssue`. To create a new workflow, log
    in as `Admin`, navigate to Administration | Workflows | Add Workflow, and follow
    the steps from the official documentation (*Working with workflows*: [https://confluence.atlassian.com/adminjiraserver072/working-with-workflows-828787890.html
    ...](https://confluence.atlassian.com/adminjiraserver072/working-with-workflows-828787890.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a software development company gets a big project, it must split the project
    into smaller components so that it can apply the *divide-and-conquer* strategy.
    The final product is then created by integrating these smaller components. The
    general procedure for dividing the bigger project is by grouping requirements
    for a common feature together to form smaller projects. Each of these smaller
    projects then get assigned to a development team. Thus, each team works on delivering
    part of the larger final product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3be4a3a3-7161-4d0b-8923-c9acbd69eab6.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing efforts for each of these projects starts with the testers creating
    test scenarios and test cases. The number and complexity of the test cases vary
    with the size, duration, complexity, testing tools utilized, and the testing strategy.
    The biggest challenge, however, is to segregate these test cases so that they're
    easily accessible and can be referred to or reused across projects or organization-wide.
    This is where the concept of test suites comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: What is a test suite?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **test suite** is simply a bucket that holds a collection of test cases with
    similar behaviors or goals. Each test suite has common characteristics defined
    by underlying test cases and varies in numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various characteristics contribute towards recognizing and distinguishing the
    patterns of test suites, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Priority:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test input parameters or type. These include different sets or types of values,
    such as `.csv` files, images, variables, objects, or even returned values from
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expected behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type of testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser-specific
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific tools used by the team for testing, such ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test suite in synapseRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In synapseRT, the Test Suites tab is displayed on the left panel of the project
    page. From this section, we can create and manage test cases in the form of main
    and subtest suites. The following screenshot shows the main test suite, `Mobile
    banking App Tests`, which has a total of four test cases that have been organized
    into two subtest suites—`IOS device test` and `Android device test`. We also have
    the option to clone test cases from one test suite to another, delete, or even
    export test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/59995fbc-65b8-458e-808b-a15ad909c580.png)'
  prefs: []
  type: TYPE_IMG
- en: The test suite in Zephyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zephyr provides a way to manage your test execution with the help of test cycles.
    However, it doesn''t provide a feature to organize test cases by test suites.
    The Test Summary screen provides a detailed view of the number of test cases,
    organized by version, component, or label, and their execution status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/25cf7905-7737-4d78-ae14-687c241bd89c.png)'
  prefs: []
  type: TYPE_IMG
- en: The test suite in Test Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the Tests tab and create a new folder in the FOLDERS section. These
    folders will be your test suites. You can add new test cases by clicking the +New button
    on the screen. We have created a few test suites and test cases for our banking
    example, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/101a2848-9956-4b48-925c-ddf40abf4796.png)'
  prefs: []
  type: TYPE_IMG
- en: For the preceding banking example, testers can also create test suites at a
    high level based on mobile testing, web application testing, credit card testing,
    personal banking testing, account types testing, load types testing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of test suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s beneficial for test professionals to have organized test suites for the
    following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to separate the types of tasks that need to be performed for the verification
    of requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The effort estimation in terms of time and resource requirements is made easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acts as a knowledge-base repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it easy to identify test cases to mitigate risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identification and retesting of previously released components is made easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test suites often grow as a project progresses. Well-organized test suites are
    essential for effective test management.
  prefs: []
  type: TYPE_NORMAL
- en: Test plans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning is important if you want to be successful in delivering a project.
    We plan for each activity at each phase of the development process. Testing is
    no different. To ensure the quality of the product and perform verification, a
    test plan is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: What is a test plan?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A test plan is a document that outlines your approach to verify and test the
    software product. It's a detailed document prepared by test managers or test leads
    that highlights the features that need to be verified, the testing strategy, the
    availability of resources, and their roles. It also contains details about the
    scope of the test, components that are not part of the test phase, supported browser
    types and versions, limitations of the tools being used for testing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Every phase in the SDLC generates a set of deliverables. For example, the requirement
    gathering phase generates the BRD, the design phase generates high-level and low-level
    system and component design plans, and the test planning phase generates ...
  prefs: []
  type: TYPE_NORMAL
- en: The test plan in synapseRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Test Plan is another issue type in synapseRT. On clicking on the Create
    button, we get an option to choose the issue type as Test Plan. Once we enter
    all the details and create our test plan, we can add test cases and test cycles,
    as shown in the following screenshot. synapseRT provides an effective way of managing
    test cycles using the test plan. You can always add or remove test cases from
    the selected cycles before starting the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, once the cycle starts, a user can only add new test cases to the test
    cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/247d6496-a0af-4a7f-9865-e39bedb30f93.png)'
  prefs: []
  type: TYPE_IMG
- en: The test plan in Zephyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zephyr uses the Cycle Summary to plan the test cycle. Once cycles are planned,
    the test team can add and remove test cases from the cycles as needed. Test cases
    are validated for the content and, details, and assigned to the teams for peer
    review. After the peer review, it can be marked as Ready to Test and assigned
    to the team members who will be responsible for the execution of the test cases.
    Once the cycles with the updated test cases are ready, it can be moved under the
    targeted release test cycle and the team can start the execution phase. The following
    screenshot shows how test cycles are planned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/20522d0a-1384-435c-905c-675ae23a1465.png)'
  prefs: []
  type: TYPE_IMG
- en: The test plan in Test Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test Management provides a tab named Plans to create and manage test plans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0ba35af3-dd2c-4173-8e2f-d36cd1d7a979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you create a test plan, you can add test cycles, which contain test cases,
    as shown in the following screenshot. This can then be viewed from the Traceability
    section of the test plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5cadb8f0-8ae0-4ce4-a88b-b63bb131cd96.png)'
  prefs: []
  type: TYPE_IMG
- en: Traceability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requirements are usually documented in the BRD, **software requirement and specifications**
    (**SRS**) document, or in the Requirements section of the project management tools,
    such as Jira, being used by the team. Test scenarios and test cases are created
    in order to verify the stated requirements. It's important to ensure and track
    that all the requirements have corresponding test cases and are covered in the
    testing and verification phases. This is what the traceability matrix helps us manage.
  prefs: []
  type: TYPE_NORMAL
- en: What is a traceability matrix?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traceability matrix, also known as the **Requirement Traceability Matrix**
    (**RTM**), is a document that helps test professionals to establish a correlation
    between what they are being asked to test and what is being covered in the testing
    phase. It establishes a many-to-many relationship between the requirements and
    the test scenarios or test cases identified, which will be used to verify the
    linked requirements. The traceability matrix helps us to identify any leaks in
    quality and ensures complete test coverage so that no part of the requirements
    missed from the test.
  prefs: []
  type: TYPE_NORMAL
- en: Once the execution phase begins, the test professionals start the application-validation
    process by following the detailed steps mentioned in the test cases. The main
    goal is to identify whether a module satisfies conditions and meets the expected
    results. If it does, the test is passed, and if it doesn't, we call it a **defect**.
    The number of defects may vary from one execution cycle to another.
  prefs: []
  type: TYPE_NORMAL
- en: It's important for project stakeholders to be aware of the status of the test
    execution, so that they understand which requirements are yet to be verified and
    can address the obstacles in time. When raising a defect in the system, if it's
    linked to the relevant test case, it's easy to trace the defect back to the test
    cases, which can then be traced back to the given requirement. Often, in the case
    of the traceability matrix, it's important to add the test execution status, as
    well as linked defects' details. There are various formats of the RTM available
    that can help establish this relationship between the requirement being tested
    and the test cases and related defects.
  prefs: []
  type: TYPE_NORMAL
- en: Types of traceability matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most popular types of the RTM are shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward traceability matrix:** This is where requirements are linked to the
    test cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Business requirement ID#** | **Use case ID#** | **Priority** | **Test case
    ID#** |'
  prefs: []
  type: TYPE_TB
- en: '| BR_1 | UC_1 | High | TC#001 |'
  prefs: []
  type: TYPE_TB
- en: '|  | UC_2 | High | TC#002TC#005 |'
  prefs: []
  type: TYPE_TB
- en: '| BR_2 | UC_3 | Medium | TC#003TC#004 |'
  prefs: []
  type: TYPE_TB
- en: '**Backward traceability matrix**: This is where test cases are mapped to the
    requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Test case ID#** | **Use case ID#** | **Priority** | **Business requirement
    ID#** |'
  prefs: []
  type: TYPE_TB
- en: '| TC#001 | UC_1 | High | BR_1 |'
  prefs: []
  type: TYPE_TB
- en: '| TC#002 | UC_2 | High | BR_1 |'
  prefs: []
  type: TYPE_TB
- en: '| TC#003 | UC_3 | Medium | BR_2 |'
  prefs: []
  type: TYPE_TB
- en: '| TC#004 | UC_3 | Medium | BR_2 |'
  prefs: []
  type: TYPE_TB
- en: '| TC#005 | UC_1 | High | BR_1 |'
  prefs: []
  type: TYPE_TB
- en: '**Bi-directional traceability matrix:** This is where ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of the traceability matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the benefits of the traceability matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes it easy to track the status of test execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to ensure whether the test scenarios provide complete test coverage
    before the test execution begins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It identifies which requirements need more testing efforts in terms of resource
    allocation, time, debugging, or defect resolution time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It addresses and resolves issues ahead of time to reduce their impact on the
    project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It monitors the project's progress and estimates completion time well in advance
    by reducing the risk of failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 8](02a5b49e-4312-4149-941d-4948fc23db2d.xhtml), *Defect Management
    Phase,* we'll see how to link defects to the test cases, and in [Chapter 9](da0a480b-81d0-4369-8359-ddd0fd749ffe.xhtml), *Requirement
    Management,* we'll learn how to link requirements to the test cases. For now,
    let's see how each Jira plugin generates the traceability report.
  prefs: []
  type: TYPE_NORMAL
- en: Traceability in synapseRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traceability matrix in synapseRT can be generated from the Traceability
    tab on the left panel of the page. We have to enter the details, such as requirements
    (Epic, Task, Story, or Requirement) or project, and the relevant test plan (if
    any exists), for which we want to generate a traceability matrix. The following
    screenshot shows a forward traceability matrix generated in synapseRT. It shows
    the details, such as the requirements, their relevant test cases, their current
    execution status, and any linked defects. We also have an option to view traceability
    as a Matrix or Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d93a2e65-2186-42e2-91f6-78e251ae0026.png)'
  prefs: []
  type: TYPE_IMG
- en: Traceability in Zephyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zephyr provides both, forward and backward traceability reports. Let''s understand
    how to create them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a forward traceability matrix, specify the current version and select
    the requirement issue type from the list, such as Epic, Story, or Tasks, and click
    on the search icon. Based on the input parameters, Zephyr lists the relevant issue
    types on the page. Select the checkbox for the issue and the Requirements to Defects
    for which you want to generate the traceability matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/f7283f43-800a-4936-9a99-1e78a8e6c6dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The forward traceability matrix generated in Zephyr shows a relationship between
    requirements, their linked test cases, their execution status, and linked defects.
    We have a requirement, `ZP-1`, and there are three test cases added to this requirement.
    The Executions column shows further details about the execution status of each
    test case, for example, as a test case, `ZP-9` has two executions and both times
    it failed. It also has a linked defect, `ZP-11`, added in the Defects column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/58f04516-9c1e-4454-b4ec-d6288c8fbc18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the preceding steps to generate the backward traceability matrix. In this
    case, we will select the issue type as Bug, which we want to generate a traceability
    matrix for Zephyr shows all the relevant bug issues on the screen—select the one
    for which you want to generate the traceability, select the type as Defect to
    Requirements, and click on the Generate button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/07f0930d-e552-4e1c-bc64-1d2b46d5c15a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, we have a backward traceability matrix
    that establishes a relationship between the defect of a test case and its relevant
    requirements. This matrix has the Defects, Executions, Tests, and Requirements columns
    with the linked Jira issues. In both the cases, we have an option to export the
    traceability in HTML or Excel formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/cdcb8152-7143-4755-89dd-e4064110f582.png)'
  prefs: []
  type: TYPE_IMG
- en: Traceability in Test Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Test Management plugin, the traceability report details the Coverage,
    which shows the requirements; Test Cases and Test Executions results, showing
    the details about the test case; and Issues, which details the defects found during
    test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/71a09acb-4b8a-4bb0-9705-9f266c747a13.png)'
  prefs: []
  type: TYPE_IMG
- en: Reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reports are a formalized way of effectively and regularly communicating the
    status of the project's progress. They play a key role in the project management
    process. Details provided in the reports are helpful in identifying and mitigating
    the risks that might lead to the failure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Reports act as a project health-checker and help managers to track any deviation
    from the agreed scope, time, cost, budget, and stated resource requirements necessary to
    meet the quality. These reports also act as reference documents as a part of the
    knowledge base that can be maintained and shared within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Types of reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reporting needs vary based on the targeted audience. Jira reports are helpful
    to determine the statistics of the project and can be customized based on the
    people, projects, versions, or issue types that we will be exploring here. In
    [Chapter 10](c75f6a6f-2192-4307-9e7d-faeb17bffb17.xhtml), *Test Execution Status
    Reporting*, we''ll explore the different types of reports supported by Jira plugins.
    For now, let''s look at the types of reports supported by Jira:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agile**: Agile reports are useful to track the progress of the project by
    generating various types of reports. It gives more insights into the project and
    helps the project team to address the issues in time. It helps to compare and
    contract the projected timelines for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burndown Chart**: This graph helps to ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how each phase of test management can be performed
    using the Test Management plugins in Jira. We also compared the features provided
    by each plugin. Requirements are the documented needs of the end user, which are
    captured in Jira using issue types. We learned to add and modify issue types and
    workflows for use in our projects in Jira. Test cases can be organized based on
    components or requirements using test suites. We saw how test suites can be created
    in Jira using the plugins. Planning is essential to manage the testing phase.
    The test plan enables us to strategize how tests will be executed. We compared
    how each plugin provides the test plan feature. Traceability reports help us backtrack
    defects to test cases and requirements. We explored how each plugin provides its
    version of traceability reports. Finally, we familiarized ourselves with the reports
    section in Jira, which will be covered in detail in [Chapter 10](c75f6a6f-2192-4307-9e7d-faeb17bffb17.xhtml), *Test
    Execution Status Reporting*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the best approaches for selecting various
    project execution workflows, based on the project's needs.
  prefs: []
  type: TYPE_NORMAL
