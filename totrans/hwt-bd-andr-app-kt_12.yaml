- en: 12\. Dependency Injection with Dagger and Koin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the concept of dependency injection and the benefits it
    provides to an Android application. We will look at how we can perform dependency
    injection manually with the help of container classes. We will also cover some
    of the frameworks available for Android, Java, and Kotlin that can help developers
    when it comes to applying this concept. By the end of this chapter, you will be
    able to use Dagger and Koin to manage your app's dependencies, and you will know
    how to organize them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to structure code into different components,
    including ViewModels, repositories, API components, and persistence components.
    One of the difficulties that always emerged was the dependencies between all of
    these components, especially when it came to how we approached the unit tests
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: We have constantly used the `Application` class to create instances of these
    components and pass them in the constructors of the components one layer above
    (we created the API and Room instances, then the Repository instances, and so
    on). What we were doing was a simplistic version of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`). The reason for this is to increase the reusability and testability
    of the code and to shift the responsibility for creating instances from our components
    to the `Application` class. One of the benefits of DI comes with regard to how
    objects are created across the code base. DI separates the creation of an object
    from its usage. In other words, one object shouldn''t care how another object
    is created; it should only be concerned with the interaction with the other object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze three ways of how we can inject dependencies
    in Android: manual DI, Dagger, and Koin.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual DI** is a technique in which developers handle DI manually by creating
    container classes. In this chapter, we will look over how we can do this in Android.
    By studying how we manually manage dependencies, we will get some insight into
    how other DI frameworks operate and get a basis for how we can integrate these frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dagger** is a DI framework developed for Java. It allows you to group your
    dependencies in different **modules**. You can also define **components**, where
    the modules are added in order to create the dependency graph, and which Dagger
    automatically implements in order to perform the injection. It relies on annotation
    processors to generate the necessary code in order to perform the injection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Koin** is a lightweight DI library developed for Kotlin. It doesn''t rely
    on annotation processors; it relies on Kotlin''s mechanisms to perform the injection.
    Here we can also split dependencies into **modules**.'
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, we will explore how both these libraries work and the steps
    required to add them to a simple Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Manual DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how DI works, we can first analyze how we can manually
    inject dependencies into different objects across an Android application. This
    can be achieved by creating container objects that will contain the dependencies
    required across the app. You can also create multiple containers representing
    different scopes that are required across the application. Here, you can define
    dependencies that will only be required as long as a particular screen is displayed,
    and when the screen is destroyed, the instances can also be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample of a container that will hold instances as long as an application
    lives is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An `Application` class using that container looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, the responsibility for creating the
    dependencies shifted from the `Application` class to the `Container` class. Activities
    across the code base can still access the dependencies using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules with a limited scope could be used for something such as creating `ViewModel`
    factories, which, in turn, are used by the framework to create `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular container can be used by an activity or fragment to initialize `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, we see here that the responsibility of creating the `Factory` class was
    shifted from the `Activity` class to the `Container` class. `MyContainer` could
    be expanded to provide instances required by `MyActivity` in situations where
    the life cycle of those instances should be the same as the activity, or the constructor
    could be expanded to provide instances with a different life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's apply some of these examples to an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Manual Injection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will write an Android application that will apply the
    concept of manual DI. The application will have a Repository, which will generate
    a random number and a `ViewModel` object with a `LiveData` object responsible
    for retrieving the number generated by the Repository and publishing it in the
    `LiveData` object. In order to do so, we will need to create two containers that
    will manage the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` factory responsible for creating `ViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The app itself will display the randomly generated number each time a button
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `ViewModel` and `LiveData` library to the `app/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s write a `NumberRepository` interface, which will contain a method
    to retrieve an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will provide the implementation for this. We can use the `java.util.Random`
    class to generate a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now move on to the `MainViewModel` class, which will contain a `LiveData`
    object containing each generated number from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s move on to create our UI containing `TextView` for displaying
    the number and `Button` for generating the next random number. This will be part
    of the `res/layout/activity_main.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to add the string for the button to the `res/values/strings.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s create the `MainActivity` class responsible for rendering the
    preceding UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our `Application` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add the `Application` class to the `AndroidManifest.xml` file in
    the `application` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create our first container responsible for managing the `NumberRepository`
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add this container to the `RandomApplication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We now move on to creating `MainContainer`, which will need a reference to
    the `NumberRepository` dependency and will provide a dependency to the `ViewModel`
    factory required to create `MainViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can modify `MainActivity` to inject our dependencies from our containers
    and connect the UI elements in order to display the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted code, we can see that we are using the repository defined
    in `ApplicationContainer` and injecting it into `MainContainer`, which will then
    inject it into `ViewModel` through `ViewModelProvider.Factory`. The preceding
    example should render the output presented in *Figure 12.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1: Emulator output of Exercise 12.01 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Emulator output of Exercise 12.01 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: Manual DI is an easy way to set up your dependencies in situations where the
    app is small, but it can become extremely difficult as the app grows. Imagine
    if, in *Exercise 12.01*, *Manual Injection*, we had two classes that extended
    from `NumberRepository`. How would we handle such a scenario? How would developers
    know which one went in what activity? These types of questions become very common
    in most of the well-known apps on Google Play, which is why manual DI is rarely
    used. When used, it will probably take the form of a DI framework similar to the
    ones we will look over next.
  prefs: []
  type: TYPE_NORMAL
- en: Dagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dagger offers a comprehensive way to organize your application''s dependencies.
    It has the advantage of being adopted first on Android by the developer community
    before Kotlin was introduced. This is one of the reasons that many Android applications
    use Dagger as their DI framework. Another advantage the framework holds is for
    Android projects written in Java, because the library is developed in the same
    language. The framework was initially developed by Square (Dagger 1) and later
    transitioned to Google (Dagger 2). We will cover Dagger 2 in this chapter and
    describe its benefits. Some of the key functionalities Dagger 2 provides are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies grouped in modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components used to generate dependency graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcomponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Annotations are the key elements when dealing with Dagger, because it generates
    the code required to perform the DI through an annotation processor. The main
    annotations can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Module` are responsible for providing an object (dependent object) that can
    be injected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Inject` annotation is used to define a dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Component`-annotated interface defines the connection between the provider
    and the consumer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to add Dagger to your project, in the `app/build.gradle` file, you
    will need the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are dealing with annotation processors, in the same `build.gradle`
    file, you will need to add the plugin for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Consumers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dagger uses `javax.inject.Inject` to identify objects that require injection.
    There are multiple ways to inject dependencies, but the recommended ways are through
    constructor injection and field injection. Constructor injection looks similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When constructors are annotated with `@Inject`, Dagger will generate `Factory`
    classes that will be responsible for instantiating the objects. In the example
    of `ClassB`, Dagger will try to find the appropriate dependencies that fit the
    signature of the constructor, which, in this example, is `ClassA`, which Dagger
    already created an instance for.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want Dagger to manage the instantiation of `ClassB` but still
    have the dependency to `ClassA` injected, you can use field injection and it will
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Dagger will generate the necessary code just to inject the dependency
    between `ClassB` and `ClassA`.
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will find yourself in situations where your application uses external dependencies.
    That means that you will not be able to provide instances through constructor
    injections. Another situation where constructor injection is not possible is when
    interfaces or abstract classes are used. In this situation, Dagger offers the
    possibility to provide the instance using the `@Provides` annotation. You will
    then need to group the methods where instances are provided into modules annotated
    with `@Module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, `ClassA` and `ClassB` don't have any
    Dagger annotations. A module was created that will provide the instance for `ClassA`,
    which will then be used to provide the instance for `ClassB`. In this case, Dagger
    will generate a `Factory` class for each of the `@Provides` annotated methods.
  prefs: []
  type: TYPE_NORMAL
- en: Connectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming we will have multiple modules, we will need to combine them in a graph
    of dependencies that can be used across the application. Dagger offers the `@Component`
    annotation. This is usually used for an interface or an abstract class that will
    be implemented by Dagger. Along with assembling the dependency graph, components
    also offer the functionality to add methods to inject dependencies into a certain
    object''s members. In components, you can specify provision methods that return
    dependencies provided in the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding `Component`, Dagger will generate a `DaggerMyComponent` class
    and we can build it as described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Application` class will create the Dagger dependency graph and component.
    The `inject` method in `Component` allows us to perform DI on the variables in
    the `Application` class annotated with `@Inject`, giving us access to the `ClassB`
    object defined in the module.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to provide multiple instances of the same class (such as injecting
    different Strings or Integers across an application), you can use qualifiers.
    These are annotations that can help you identify instances. One of the most common
    ones is the `@Named` qualifier, as described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create two instances of `ClassA` and we give them different
    names. We then use the first instance whenever possible to create `ClassB`. We
    can also create custom qualifiers instead of the `@Named` annotation, as described
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The module can be updated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to keep track of the life cycle of your components and your dependencies,
    you can use scopes. Dagger offers a `@Singleton` scope. This usually indicates
    that your component will live as long as your application will. Scoping has no
    impact on the life cycle of the objects; they are built to help developers identify
    the life cycles of objects. It is recommended to give your components one scope
    and group your code to reflect that scope. Some common Dagger scopes on Android
    are related to the activity or fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The annotation can be used in the module where the dependency is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `Component` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example would indicate that `Component` can only use objects with
    the same scope. If any of the modules that are part of this `Component` contain
    dependencies with different scopes, Dagger will throw an error indicating that
    there is something wrong with the scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Subcomponents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that goes hand-in-hand with scopes is subcomponents. They allow you
    to organize your dependencies for smaller scopes. One common use case on Android
    is to create subcomponents for activities and fragments. Subcomponents inherit
    dependencies from the parent and they generate a new dependency graph for the
    scope of the subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a separate module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Subcomponent` that will generate a dependency graph for that module would
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent component would need to declare the new component, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can inject `ClassC` into your activity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this knowledge, let's move on to an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Dagger Injection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will write an Android application that will apply the
    concept of DI with Dagger. The application will have the same `Repository` and
    `ViewModel` defined in *Exercise 12.01*, *Manual Injection*. We will need to use
    Dagger to expose the same two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainSubComponent`. Also, `MainSubComponent` will be generated by `ApplicationComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The app itself will display a randomly generated number each time a button
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding Dagger and the `app/build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the `kapt` plugin in the `app/build.gradle` module. Attach the
    plugin as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We now need to add the `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`,
    and `RandomApplication` classes and build our UI with `MainActivity`. This can
    be done by following *Steps 2-9* from *Exercise 12.01*, *Manual Injection*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s move on to `ApplicationModule`, which will provide the `NumberRepository`
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create `MainModule`, which will provide the instance of `ViewModel.Factory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create `MainScope`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need `MainSubcomponent`, which will use the preceding scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will require `ApplicationComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will need to navigate to `Build` and click on `Rebuild project` in Android
    Studio so that we generate the Dagger code for performing the DI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we modify the `RandomApplication` class in order to add the code required
    to initialize the Dagger dependency graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We now modify the `MainActivity` class to inject `ViewModelProvider.Factory`
    and initialize `ViewModel` so that we can display the random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, it will build an application that will display
    a different random output when you click the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Emulator output of Exercise 12.02 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Emulator output of Exercise 12.02 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12.2* shows what the application looks like. You can view the generated
    Dagger code in the `app/build` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3: Generated Dagger code for Exercise 12.02'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Generated Dagger code for Exercise 12.02'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12.3*, we can see the code that Dagger generated in order to satisfy
    the relationship between dependencies. For every dependency that needs to be injected,
    Dagger will generate an appropriate `Factory` class (based on the `Factory` design
    pattern), which will be responsible for creating the dependency. Dagger also looks
    at the places where dependencies will need to be injected and generates an `Injector`
    class, which will have the responsibility of assigning the value to the dependency
    (in this case, it will assign the value to the members annotated with `@Inject`
    in the `MainActivity` class). Finally, Dagger creates implementations for the
    interfaces that have the `@Component` annotation. In the implementation, Dagger
    will handle how the modules are created and also provide a builder in which developers
    can specify how modules can be built.
  prefs: []
  type: TYPE_NORMAL
- en: Dagger Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, you have probably noticed that in the activity, you
    had to call the components and subcomponents to perform the injection. That tends
    to get repetitive in an application. It''s also not recommended for activities
    and fragments to know who is performing the injection. All of this comes from
    the fundamental conflict between Dagger and the Android framework. In Dagger,
    you are responsible for providing and injecting your dependencies. In Android,
    fragments and activities are instantiated by the system. In other words, you cannot
    move the creation of your activity or fragment into a Dagger module and inject
    the dependencies, so you have to resort to building subcomponents. By using subcomponents,
    you then create a dependency between the subcomponent and the activity. Luckily,
    Dagger provides a set of libraries to address these issues for Android, which
    can be added to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android Dagger libraries provide specialized injection methods that Dagger
    uses to inject dependencies into activities and fragments. This setup also simplifies
    the dependency setup for simpler projects by eliminating the need for subcomponents.
    A module that would set up the injection into an activity will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: (Please note that import statements are not shown for these examples.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing here is the introduction of the `@ContributesAndroidInjector`
    annotation, which, when applied to an abstract method, allows Dagger to create
    an implementation in which it will create `AndroidInjector`, which will then be
    used to perform the injection into the activity. The `Application` component will
    need a dedicated `AndroidInjectionModule` or `AndroidSupportInjection` module
    (if you are using the compatibility library to implement your fragments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`AndroidSupportInjectionModule` comes from the Dagger Android library and provides
    a set of bindings that prove useful when using the Android framework classes by
    keeping track of the different injectors you''ve added to your `Application`,
    `Activity`, and `Fragment` classes. This is how Dagger will know how each dependency
    should be injected into your activity or fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Application` class, you will need a `HasAndroidInjector` implementation.
    This will be responsible for providing the injection into each of your application''s
    activities. The same rule can be applied if you are using services or `ContentProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'What Dagger will do in your `Application` class, in `onCreate()`, is to create
    the graph and inject an `AndroidInjector` object into the `Application` class.
    The `AndroidInjector` object will then be used to inject dependencies into each
    of the specified activities. Finally, in your activity, you can use the `AndroidInjection.inject()`
    method to inject the dependencies. When `inject()` gets called, Dagger will look
    up the injector responsible for DI. If `inject()` gets called from an activity,
    then it will use the application injector. This is the point where the `androidInjector()`
    method from the application will be called by Dagger. If the injector is valid,
    then DI will be performed. If `inject()` is called from a fragment, then Dagger
    will look for an injector in the parent activity. If `inject()` is called from
    a nested fragment, then Dagger will look for an injector in the parent fragment,
    which is why it is only limited to one nested fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to perform DI in your fragments, a similar principle must be followed
    for each of your activities that was executed previously. Let''s assume that `MyActivity`
    has `MyFragment`. We will need to implement `HasAndroidInjector` for `MyActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need a provider module for our fragment that is similar to the
    provider module for the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `ActivityProviderModule`, you need to add `FragmentProviderModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is required for every activity that has fragments that have dependencies
    that require injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dagger Android provides a set of classes that have the `HasAndroidInjector`
    implementation. If you wish to avoid implementing the `HasAndroidInjector` method
    in your classes, use some of the following classes: `DaggerApplication`, `DaggerActivity`,
    `DaggerFragment`, and `DaggerSupportFragment`. Using them just requires them to
    be extended instead of `Application`, `Activity`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Changing Injectors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will change *Exercise 12.02*, *Dagger Injection*, to add
    the Android injector features. The output will be to display a randomly generated
    number and the same dependencies will need to be exposed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`
    (the same as for *Exercise 12.02*, *Dagger Injection*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainProviderModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependencies will be injected into `MainActivity` using the Android injector.
    The Android injector will be added to `RandomApplication` in order for the injection
    to work properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the Dagger Android dependencies to the `app/build.gradle` file,
    which will make your dependencies look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Next, delete the `MainSubcomponent` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `MainProviderModule` class, which will provide the `MainActivity` reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `ApplicationComponent` in order to add an `inject` method to the `Application`
    class and to add `ActivityProviderModule` and `AndroidSupportInjectionModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `Application` class to implement `HasAndroidInjector` and to have
    Dagger inject an injector object into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, replace the old injection with the `AndroidInjection.inject`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The final output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Emulator output of Exercise 12.03 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: Emulator output of Exercise 12.03 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the code generated when the app is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Generated Dagger code for Exercise 12.03'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: Generated Dagger code for Exercise 12.03'
  prefs: []
  type: TYPE_NORMAL
- en: Running the preceding code shouldn't change the outcome of the exercise or the
    scope of the dependencies presented in *Figure 12.3*. You can observe how the
    `MainActivity` object no longer has a dependency on the `Application` class or
    any of the components or subcomponents. *Figure 12.5* shows the generated code
    with the Dagger Android injectors. Most of it is similar to the existing one,
    but we can see the generated code for `MainProviderModule`, which actually generates
    a subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common setup you will find for Android applications when it comes to organizing
    their dependencies is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ApplicationModule**: This is where dependencies common for the entire project
    are defined. Objects such as context, resources, and other Android framework objects
    can be provided here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetworkModule**: This is where dependencies related to API calls are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatabaseModule`, `FilesModule`, `SharedPreferencesModule`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModels` or `ViewModel` factories are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewModel`. Here, either subcomponents or Android injectors are used for this
    purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've raised some questions about how manual DI can go wrong. Now we have seen
    how Dagger can address these issues. Although it does the job, and it does it
    quickly when it comes to performance, it is also a complex framework with a very
    steep learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: Koin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Koin is a lighter framework that is suitable for smaller apps. It requires no
    code generation and is built based on Kotlin's functional extensions. It is also
    a **Domain Specific language** (**DSL**). You may have noticed that when using
    Dagger, there's a lot of code that must be written in order to set up the DI.
    Koin's approach to DI solves most of those issues, allowing faster integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Koin can be added to your project by adding the following dependency to your
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to set up Koin in your application, you need the `startKoin` call
    with the DSL syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can configure what your application context is (in the `androidContext`
    method), specify property files to define Koin configurations (in the `androidFileProperties`),
    state the Logger Level for Koin, which will output in `LogCat` results of Koin
    operations depending on the Level (in the `androidLogger` method), and list the
    modules your application uses. A similar syntax is used to create the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the two objects will have two different life cycles.
    When a dependency is provided using the **single** notation, then only one instance
    will be used across the entire life cycle of the application. This is useful for
    repositories, databases, and API components, where multiple instances will be
    costly for the application. The **factory** notation will create a new object
    every time an injection is performed. This may be useful in the situation where
    an object needs to live as long as an activity or fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency can be injected using the `by inject()` method or the `get()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Koin also offers the possibility of using qualifiers with the help of the `named()`
    method when the module is created. This allows you to provide multiple implementations
    of the same type (for example, providing two or more list objects with different
    content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'One of Koin''s main features for Android applications is scopes for activities
    and fragments and can be defined as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example connects the life cycle of the `ClassB` dependency to
    the life cycle of `MainActivity`. In order for you to inject your instance into
    your activity you will need to extend the `ScopeActivity` class. This class is
    responsible for holding a reference as long as the activity lives. Similar classes
    exist for other Android components like Fragments (`ScopeFragment`) and Services
    (`ScopeService`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can inject the instance using the `inject()` method into your activity.
    This is useful in situations where you wish to limit who gets to access the dependency.
    In the preceding example, if another activity had wanted to access the reference
    to `ClassB`, then it wouldn't be able to find it in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that comes in handy for Android is the `ViewModel` injections.
    To set this up, you will need to add the library to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recall, `ViewModels` require `ViewModelProvider.Factories` in order
    to be instantiated. Koin automatically solves this, allowing `ViewModels` to be
    injected directly and to handle the factory work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to inject the dependency of `ViewModel` into your activity, you can
    use the `viewModel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the method directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding setup, Koin takes full advantage of Kotlin's
    language features and reduces the amount of boilerplate required to define your
    modules and their scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Koin Injection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will write an Android application that will perform DI using Koin.
    The application will be based on *Exercise 12.01*, *Manual Injection*, by keeping
    `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`, and `MainActivity`.
    The following dependencies will be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: As part of a module named `appModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainViewModel`: This will rely on Koin''s specialized implementation for `ViewModels`.
    This will be provided as part of a module named `mainModule` and will have the
    scope of `MainActivity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The app itself will display a randomly generated number each time a button
    is clicked. Let''s start by adding the Koin libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by defining the `appModule` variable inside the `MyApplication`
    class. This will have a similar structure to `AppModule` with the Dagger setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the activity module variable after `appModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s initialize `Koin` in the `onCreate()` method of `RandomApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s inject the dependencies into the activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, the app should work as per the previous examples.
    However, if you check `LogCat`, you will see a similar output to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 12.6*, we can see the same output as in previous exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Emulator output of Exercise 12.04 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Emulator output of Exercise 12.04 displaying a randomly generated
    number'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this exercise, Koin is much faster and easier to integrate,
    especially with its `ViewModel` library. This comes in handy for small projects,
    but its performance will be impacted once projects grow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Injected Repositories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you are going to create an app in Android Studio that connects
    to a sample API, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts),
    using the Retrofit library and retrieves a list of posts from the web page, which
    will then be displayed on the screen. You will then need to set up a UI test in
    which you will assert that the data is asserted correctly on the screen, but instead
    of connecting to the actual endpoint, you will provide dummy data for the test
    to display on the screen. You will take advantage of the DI concept in order to
    swap the dependencies when the app is executed as opposed to when the app is being
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, you will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A network component responsible for downloading and parsing the JSON file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A repository that accesses the data from the API layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` instance that accesses the Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An activity with `RecycleView` that displays the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Dagger module for providing the repository instance and one for providing
    the `ViewModel` factory instance, and a test module that will swap the repository
    dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One UI test that will assert the rows and uses a dummy object to generate the
    API data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Error handling can be avoided for this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, create an application with `Empty Activity` (`MainActivity`)
    and add an `api` package where your API calls are stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a class responsible for the API calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `repository` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a repository interface that will have one method, returning `LiveData`
    with the list of posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the implementation for the repository class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ViewModel` instance, which will call the repository to retrieve the
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an adapter for the rows of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the activity that will render the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a Dagger module that will initialize the network-related dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Dagger module that will be responsible for defining the dependencies
    required for the activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a subcomponent that will use the associated module and have the injection
    in the activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `AppComponent`, which will manage all of the modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the UI tests and a test application and provide a separate `RepositoryModule`,
    class, which will return a dependency holding dummy data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the UI test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.02: Koin-Injected Repositories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will migrate the app built in *Activity 12.01*, *Injected
    Repositories*, from Dagger to Koin, keeping the requirements intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the components in your code are the same as for the previous
    activity, the following steps need to be followed in order to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the Dagger 2 dependencies from `build.gradle` and the `kapt` plugin.
    The compilation errors this will generate will be able to guide you in removing
    unnecessary code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the standard `Koin` library and the one for `ViewModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Dagger modules and components from your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `networkModule`, `repositoryModule`, and `activityModule` modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Koin with the preceding modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject `ViewModel` into `MainActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `repositoryModule` in `TestApplication` to return `DummyRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the concept of DI and how it should be applied
    in order to separate concerns and prevent objects from having the responsibility
    of creating other objects and how this is of great benefit for testing. We started
    the chapter by analyzing the concept of manual DI. This served as a good example
    of how DI works and how it can be applied to an Android application; it served
    as the baseline when comparing the DI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: We also analyzed two of the most popular frameworks that help developers with
    injecting dependencies. We started with a powerful and fast framework in the form
    of Dagger 2, which relies on annotation processors to generate code to perform
    an injection. We also looked into Koin, which is a lightweight framework written
    in Kotlin with slower performance but a simpler integration and a lot of focus
    on Android components.
  prefs: []
  type: TYPE_NORMAL
- en: The exercises in this chapter were intended to explore how the same problem
    can be solved using multiple solutions and compare the degrees of difficulty between
    the solutions. In the activities for this chapter, we leveraged Dagger's and Koin's
    modules in order to inject certain dependencies when running the app and other
    dependencies when running the tests on an application that uses `ViewModels`,
    repositories, and APIs to load data. This is designed to show the seamless integration
    of multiple frameworks that achieve different goals. The activities also represented
    the combination of the different skills learned in previous chapters, from the
    basic ones that taught you how to display data on the UI to the more complex ones,
    such as those to do with networking, testing, `ViewModels`, repositories, and
    DI.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, you will have the opportunity to build upon the knowledge
    acquired thus far by adding concepts related to threading and how to handle background
    operations. You will get the opportunity to explore libraries such as RxJava and
    its reactive approach to threading, and you will also learn about coroutines,
    which takes a different approach to threading. You will also observe how coroutines
    and RxJava can combine very effectively with libraries such as Room and Retrofit.
    Finally, you will be able to combine all of these concepts in a robust application
    that will have a high degree of scalability for the future.
  prefs: []
  type: TYPE_NORMAL
