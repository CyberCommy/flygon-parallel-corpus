- en: Programming the Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After writing a couple of C++ programs and testing their output on the Raspberry
    Pi, it's now time to create our very own car robot and make it move forward, backward,
    left, and right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a good robot chassis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing and connecting the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with H-bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main hardware requirements for this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Robot chassis (the parts included in the robot chassis are explained in the *Constructing
    and connecting the robot* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two DC motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L298N motor driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Female-to-female connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a robot chassis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing a good robot chassis is one of the most important activities to do
    before we start constructing the robot. The chassis for the robot is like a skeleton
    for a human. Our skeletons are made up of bones that provide proper support to
    our organs. In the same way, a good chassis will provide proper support to the
    electronics components and hold them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either purchase a robot chassis from e-commerce websites such as Amazon
    and eBay, or you can purchase one directly from a vendor who deals with robotics
    equipment. A quick Amazon search for `robot chassis` will provide you with a list
    of different variants of robot chassis. Choosing from all of these options can
    be a daunting task if you haven''t constructed a robot previously. While choosing
    a robot chassis, keep the following pointers in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the robot chassis consists of two plates (an **Upper Plate**
    and a **Lower Plate**) so that you can place the electronics components in between
    the two plates as well as on the **Upper Plate**, as shown in the following photo:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cfe89fce-0ff6-4d8b-b737-49c80bfd99da.png)'
  prefs: []
  type: TYPE_IMG
- en: Choose a robot chassis that only supports two DC motors, like the one shown
    in the preceding photo. Robot chassis with support for four DC motors are also
    available, but you would need an extra motor driver to drive a four-wheel robot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, choose a robot chassis that has DC motors (two units), wheels (two
    units), and a castor wheel included as part of the complete kit, so that you do
    not have to purchase these components separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot chassis shown in the preceding photo is the one that I'll be using
    for creating my car robot, as it consists of two plates and includes the necessary
    components (DC motors, wheels, castor wheels, screws, and spacers) as a part of
    the complete kit.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and connecting the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing the robot properly is one of the most important steps. A properly
    constructed robot will move smoothly without any obstructions. Before constructing
    the robot, let's take a look at the complete list of components that you will
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parts required for building the robot include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A robot chassis, which must include the following components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An upper plate and a lower plate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two BO DC motors (BO is a type of DC motor that generally is yellow in color)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two** wheels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One** castor wheel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spacers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screws for connecting different parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One** screwdriver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One** L298N motor driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seven or eight** connecting wires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One **battery snapper'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One **9V battery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since these robot chassis are created by small-scale companies and there isn't
    a standard robot chassis that is available internationally, the robot chassis
    that I'm using for this project will differ from the robot chassis that is available
    in your country.
  prefs: []
  type: TYPE_NORMAL
- en: While purchasing a robot chassis online, please check the user reviews for the
    product.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing the robot becomes much easier when components such as upper and
    lower plates, DC motors, wheels, castor wheels, and spacers are included inside
    one single robot chassis kit. If you purchase these components separately, there
    is a chance that some components will not fit properly, which makes the entire assembly
    of the robot unstable. While the chassis that I'm using may differ from the one
    that you are using, the construction of most two-wheeled robots is quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the robot construction in the `Chapter03` folder of the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the motor driver to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After constructing the robot, it's time to connect the Raspberry Pi to the motor
    driver so that we can program the robot and move it in different directions. Before
    doing this, however, let's take a look at what a motor driver is.
  prefs: []
  type: TYPE_NORMAL
- en: What is a motor driver?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A motor driver is a breakout board that consists of a motor driver **integrated
    circuit** (**IC**). A motor driver is basically the same as a current amplifier,
    and its main purpose is to take a low-current signal and convert to a high-current
    signal in order to run the motors. The L298N motor driver is shown in the following
    photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f97d6a6a-f6b5-4eeb-ac6b-5b952d1d6d1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The main reason why we need a motor driver is that components such as motors
    cannot be connected directly to the Raspberry Pi as they do not get sufficient
    current from the Raspberry Pi, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dab7eee-2480-4551-af27-bb0485e58102.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is why we connect the motor to the motor driver first and supply power
    to the motors with a battery, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b57fbee5-e0aa-4e20-8f39-8ef886a4f088.png)'
  prefs: []
  type: TYPE_IMG
- en: Wiring connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The L298N motor driver consists of **four** input pins, **four** output sockets
    (two sockets for each motor), and **two** sockets for power. The Raspberry Pi
    pins are connected to the input pins of the motor driver. The DC motor wires are
    connected to the output socket of the motor driver and the battery snapper is
    connected to the power socket. The four input pins of the L298N motor driver are
    labeled **IN1**, **IN2**, **IN3**, and **IN4**. The output sockets are labeled
    **OUT1**, **OUT2**, **OUT3**, and **OUT4**. The following figure shows the wiring
    connection of Raspberry Pi, motor driver, and motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6b850a0-b20f-4033-8f12-d600d374ddcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, the wiringPi pin numbers **0**, **2**,
    **3**, and **4** are connected to the input socket of the motor driver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: wiringPi no **0** is connected to **IN1**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wiringPi no **2** is connected to **IN2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wiringPi no **3** is connected to **IN3**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wiringPi no **4** is connected to **IN4**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left motor wires are connected to the **OUT1** and **OUT2** sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right motor wires are connected to the **OUT3** and **OUT4** sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red wire of the battery snapper is connected to the **VCC** socket of the
    motor driver and the black wire is connected to the ground socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ground pin from the Raspberry Pi is connected to the ground socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with H-bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The L298N motor driver IC can control two motors at a time. It consists of
    a dual H-bridge circuit. This means it consists of two circuits that look like
    the one shown in the following diagram, one for each motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/253d6933-65c5-49e3-9370-24d2332850e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The H-bridge circuit consists of four switches **S1**, **S2**, ![](img/99b1cc6f-a64c-456d-9452-6789523e1500.png),
    and ![](img/9ba29df2-f0df-47a9-a012-29d0d2994cf4.png). These switches will open
    and close based on the input that we provide to the L298N IC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, since we have two motors, there are four possible input combinations that
    we can provide to the L298N IC, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HIGH HIGH (1, 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HIGH LOW (1, 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LOW HIGH (0, 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LOW LOW (0, 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will provide the HIGH (1) and LOW (0) signal to the **S1** and **S2** switches,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when *S1 = 1* and *S2 =0*, the **S1** switch will be closed and the
    **S2** switch will remain open. ![](img/aaf36f47-248a-426f-98f0-57f389c218f8.png) ,
    or ![](img/aa91d868-9da9-453b-bf33-8608d361d9d8.png) , will be 0, so the ![](img/0a247425-ed8b-4718-ad43-8de9b59c7ede.png)
    switch will be open. ![](img/4fd8f439-1baf-47f2-af3d-6da756d2f6a6.png) , or ![](img/20ad82af-0c82-4284-b06a-8881aff42648.png) ,
    will be 1, so the ![](img/293035e2-e863-41f9-ba7d-7b1236aeced3.png)switch will
    be closed. Now, since the **S1** and ![](img/2ef338bc-c25f-454d-bff3-f52500f29f0d.png)  switches
    are closed, the current will flow from the **Vcc** to the **S1**, then to the
    motor, then to the ![](img/4b1ac1d1-8a3c-4a87-baa4-1597a8b623df.png) , and end
    at the GND. The motor will rotate in a clockwise direction, as shown in the following
    diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9aa4e50-1048-49be-b7e7-d6d7c454e8dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When *S1 = 0* and *S2 = 1*, the **S1** switch will be open, the **S2** switch
    will be closed, the ![](img/819ca277-57f6-4e56-8859-4663691b668f.png) will be
    closed, and the ![](img/143742d9-a94a-4702-ab83-19828e9f9dfa.png) will be open.
    Now, since the **S2** and ![](img/2c222bb1-19a6-4fd0-90aa-797b95905efc.png)switches
    are closed, the current will flow from the **Vcc** to the **S2**, then to the
    motor, then to the ![](img/be4f60d6-19a9-45ff-a19c-b7fb5a1e10b8.png), and end
    at the **GND**. The motor will rotate in an anticlockwise direction, as shown
    in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9597e40e-f0ce-41c1-90ba-6b18ab7cb7fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When *S1 = 0* and *S2 = 0*, the **S1** switch will be open, the **S2** switch
    will be open, the ![](img/c6711146-011a-41e7-9a51-e6e690ce74bb.png) switch will
    be closed, and the ![](img/c53bf9a1-e1bb-4e79-8307-9939e761c813.png) switch will
    be closed. Now, since both the **S1** and **S2** switches are open, there is no
    path for the current to flow toward the motors. In this case, the motor will stop,
    as shown in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0aeecc23-606e-4f6d-964a-e920e8ce8f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When *S1 = 1* and *S2 = 1*, the **S1** and **S2** switches will be closed,
    while the ![](img/217b56eb-475a-4c2c-a8fd-f0e3a0a818bc.png) and ![](img/6db4eae3-7d64-4686-b7e0-dafd78eb640d.png) switches
    will be open. Since both the **S1** and **S2** switches are closed, this will
    create a short circuit condition and the current will not move through the motor.
    In this case, the motor will stop, as in the previous case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6797ffb-ed39-4b81-b4f1-5b98de6c968f.png)'
  prefs: []
  type: TYPE_IMG
- en: As explained earlier, since the L298N IC consists of two H-bridges, the same
    process will take place in the other H-bridge when we provide high and low signals.
    The second H-bridge will control the other motor.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have understood the H-bridge circuit, we will write a program called
    `Forward.cpp` to move our robot forward. After that, we will write a program to
    move the robot backward, left, and right, and then stop. You can download the
    `Forward.cpp` program from `Chapter03` of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program for moving the robot forward is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this program works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we set the wiringPi pins (numbers 0, 1, 2, and 3) as output pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, with the following two lines, the left motor moves forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the next two lines make the right motor move forwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After that, the `delay` command means the motors will move forwards for three
    seconds. As we are currently inside a `for` loop, the motor will keep rotating
    continuously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have finished the code, compile the program to check if there are any
    errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, connect the 9V battery to the battery snapper and upload the program.
    Before doing this, however, make sure that you lift up the wheels of the robot.
    This is because, when the robot starts moving, you might get one of the following
    three outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the motors move forwards. If you get this output, this means your robot
    will move forwards once you put it on the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One motor moves forwards and the other motor moves backward. If you get this
    output, interchange the wires of the motor that is moving backward on the motor
    driver. For example, if the right motor is moving backward, insert the **M3-OUT**
    wire in the **M4-OUT** socket and the **M4-OUT** wire in the **M3-OUT** socket,
    as shown in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8c8acc83-f31c-4b68-9b0c-fa414b0c2bfb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the motors move backward. In this case, your robot will move backward.
    If you get this output, interchange the wires of both the left and right motor
    on the motor driver. To do this for the left motor, connect the **M1-OUT** socket
    wire in the **M2-OUT** socket and the **M2-OUT** socket wire in the **M1-OUT**
    socket. For the right motor, connect the **M3-OUT** socket wire in the **M4-OUT** socket
    and the **M4-OUT** socket wire in the **M3-OUT** socket, as shown in the following
    diagram:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/10b7768c-4245-4205-8ff5-1934ac6113d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively you can also interchange the pins on the RPi to move the robot
    forward; connect pin 0 in place of pin 2 and pin 2 in place of pin 0 for the left
    motor. Similarly, connect pin 3 in place of pin 4 and pin 4 in place of pin 3
    for the right motor.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the upload button and check the final output. Since this program is
    in a `for` loop, the motor will keep running continuously. After testing the output,
    disconnect the battery from the battery snapper so that the power to the motors
    through the motor driver is turned off to stop the motors from moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the robot backward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To move the robot backward, we simply need to interchange the `HIGH` signal
    with the `LOW` signal and vice versa. The complete program to move the robot in
    this way is written inside the `RobotMovement.cpp` file, which can be downloaded
    from `Chapter03` of the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines will make the left motor move backward, while the following
    two lines will make the right motor move backward. The final line indicates that
    the robot will move for three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To stop the robot from moving, you can provide a `HIGH` signal or a `LOW` signal
    to the pins. In the code to make the robot move backward, add the following command
    to stop the motors for three seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Different types of turns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of turn that a robot can carry out:'
  prefs: []
  type: TYPE_NORMAL
- en: Axial turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radial turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for taking axial and radial turns is added in the `RobotMovement.cpp`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Axial turns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In axial turns, one wheel of the robot moves backward and the other wheel of
    the robot moves forwards. The robot can turn on the spot without moving from its
    original position. Axial turns are generally carried out if there are space constraints
    while turning, such as if a robot is moving through a maze. A robot can either
    carry out an axial left turn or an axial right turn.
  prefs: []
  type: TYPE_NORMAL
- en: Axial left turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an axial left turn, the left motor of the robot moves backward and the right
    motor moves forward, so the robot takes a left turn, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/381f38c3-0558-46e5-b096-df159f458fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have understood how the H-bridge works, you might be able to guess the
    code for taking an axial turn. If not, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will need to play around with the delay value a little bit to make sure
    that the robot is turning properly in the left direction. If the delay value is
    high, the robot will turn more than 90°, whereas if it is low, the robot will
    turn less than 90°.
  prefs: []
  type: TYPE_NORMAL
- en: Axial right turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an axial left turn, the left motor of the robot moves forwards and the right
    motor moves backward, thereby taking a right turn, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31e89ebe-ca7e-441b-8a4d-9589d7d49a64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for an axial right turn is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Radial turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a radial turn, one motor of the robot stops and the other motor moves forwards.
    The wheel that is stopped acts as the center of the circle and the moving wheel
    acts as the circumference. The distance between the motors represents a radius,
    which is why this turn is called a radial turn. A robot can either carry out a
    radial left turn or a radial right turn.
  prefs: []
  type: TYPE_NORMAL
- en: Radial left turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a radial left turn, the left motor stops and the right motor moves forwards,
    so the robot takes a left turn, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae9e5b3a-dd2f-4095-9167-cf7ab80f28a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for taking a radial left turn is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Radial right turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a radial right turn, the left motor moves forwards and the right motor stops,
    so the robot takes a right turn, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8510530d-bf08-42af-89b8-8aa87e847364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for taking a radial right turn is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at certain criteria for selecting a robot chassis.
    After that, we constructed our car, connected the motor driver to the Raspberry
    Pi, and understood the workings of an H-bridge circuit. Finally, we wrote programs
    to make the robot move forward, backward, left, and right.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, after understanding the basic fundamentals of moving a
    robot in this chapter, we will first write a program to measure distance using
    an ultrasonic sensor. Next, we will use these distance values for avoiding obstacles,
    that is, if the robot comes very close to a wall then the ultrasonic sensor will
    sense it and it will command the robot to take a turn, thereby avoiding the obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which motor driver are we using for controlling the robot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An L298N motor driver IC consists of which bridge?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the C program to move the robot in the forward direction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*S1 = 0* (LOW) and *S2 = 1* (HIGH), will move the robot in which direction?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the code for a radial left turn?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the code for an axial right turn?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
