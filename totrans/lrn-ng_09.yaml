- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we did a great job separating concerns in our applications
    and adding different layers of abstraction to increase the maintainability of
    the app. However, we have neglected the visual side of things, as well as the
    user experience part.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, our UI is bloated with components and stuff scattered across
    a single screen, and we need to provide a better navigational experience and a
    logical way to change the application's state intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: This is the moment where routing acquires special relevance and gives us the
    opportunity to build a navigational narrative for our applications, allowing us
    to split the different areas of interest into different pages that are interconnected
    by a grid of links and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: However, our application is only a set of components, so how do we deploy a
    navigation scheme between them? The Angular router was built with componentization
    in mind. We will see how can we create our custom links and make components react
    to them in the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discover how to define routes to switch components on and off, and redirect
    them to other routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger routes and load components in our views, depending on the requested
    route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle and pass different types of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dive into more advanced routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at different ways of securing our routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncover how to improve the response time by looking at different async strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding support for the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having routing in your application means you want to navigate between different
    topics in your navigation. You usually use a top menu or left menu and press on
    links to get where you want. This causes the URL in the browser to change. In
    a **Single-Page Application** (**SPA**), this doesn''t cause a page reload. To
    get set up with the Angular router is quite easy, but there are some things we
    need in place for it to be considered set up:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify a base element in `index.html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the `RouterModule` and tell the root module about it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a routing dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide on where to place the viewport of your application, that is, decide where
    in the page your content should be placed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact with a routing service if you want to investigate things such as routing
    or query parameters, or if you need to programmatically route the user to another
    page in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the base element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to inform Angular about the base path we want to use, so it can properly
    build and recognize the URLs as the user browses the website, as we will see in
    the next section. Our first task will be to insert a base `href` statement within
    our `<HEAD>` element. Append the following line of code at the end of your code
    statement inside the `<head>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The base tag informs the browser about the path it should follow while attempting
    to load external resources, such as media or CSS files, once it goes deeper into
    the URL hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and setting up the router module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can start playing around with all the goodies existing in the router
    library. First things first, we need to import the `RouterModule`, we do this
    in the root module of our application. So, we open a file called `app.module.ts`
    and insert the following line at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once we have done so, it's time to add the `RouterModule` as a dependency of
    the `AppModule` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterModule` is a little bit of a different module, though; it needs to be
    initialized at the same time as it is added as a dependant module. It looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that it points to variable routes that we have yet to define.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `routes` is a list of route entries that specifies what routes exist in
    the application and what components should respond to a specific route. It can
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every item in the route list is an object with a number of properties. The two
    most important properties are `path` and `component`. The path property is the
    routing path, note that you should specify the path value without a leading `/`.
    So, setting it to `products`, as with the preceding code, means that we define
    what would happen if the user navigates to `/products`. The `component` property
    points to the component that should respond to this route. The pointed-out components,
    template and data is what the user will see when navigating to the route.
  prefs: []
  type: TYPE_NORMAL
- en: The first specified route defines the path `/products`, and the last route item
    specifies `**`, which means it matches any path. Order matters. Had we defined
    the route item `**` first, then `products` would never have been hit. The reason
    `**` was defined last was that we wanted a route that would take care of the case
    when a user enters an unknown route. Rather than showing the user a blank page,
    we can now show them a nice page defined by the `PageNotFound` components template.
  prefs: []
  type: TYPE_NORMAL
- en: There are a ton more properties you can define on a route item, and also more
    complex routes you can set up. This will suffice for now, so we gain a basic understanding
    of routing setup.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a viewport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have come this far, it''s time to define a viewport where the routed
    content should be rendered. Normally, we would build an application where part
    of the content is static and part of it can be switched out, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we involve the `router-outlet` element. It is an element that
    tells the router that this is where you should render the content. Update your
    `app.component.html` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the `router` module imported and initialized. We also have a router
    list defined for two routes, and we have defined where the routed content should
    be rendered. This is all we need for a minimal setup of the router. In the next
    section, we will look at a more realistic example and further expand our knowledge
    of the routing module and what it can help us with.
  prefs: []
  type: TYPE_NORMAL
- en: Building a practical example – setting up the router service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s describe the problem domain. Through the course of this book, we have
    been dealing with `Tasks` within the context of Pomodoro sessions. So far we have
    been creating all the components and other constructs that we needed in one big
    visual pile. It''s a visual pile in the sense that everything has been visible
    in one page. A more natural approach to this is to imagine that we have dedicated
    views that we navigate between. Here are the options from a user standpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: The user reaches our app and checks the current listing of the pending tasks.
    The user can schedule the tasks to be done in order to get the required time estimation
    for the next Pomodoro session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If desired, the user can jump onto another page and see a create task form (we
    will create the form, but will not implement its editing features until the next
    chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can choose any task at any time and begin the Pomodoro session required
    to accomplish it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can move back and forth across the pages they have already visited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take the preceding user interactions and translate what this means in
    terms of different views that we should support:'
  prefs: []
  type: TYPE_NORMAL
- en: There needs to be a page listing all the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a page with a create task form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, there should be a way to navigate back and forth between the pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a new component for demonstration purposes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have built two well-differentiated components we can leverage to
    deliver a multi-page navigation. But in order to provide a better user experience,
    we might need a third one. We will now introduce the form component we will be
    exploring more thoroughly in [Chapter 10](19502d3a-f6dd-4811-9a2f-5dcc82f3c03c.xhtml),
    *Forms in Angular*, as a way to have more navigation options in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a component in our tasks feature folder, anticipating the form
    we will use in the next chapter to publish new tasks. Create the following files
    in the locations pointed out for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most basic definition of a component. We need to expose this new
    component from our feature module. Finally, we need to enter the route item for
    this component in a route list and configure the routes. Add the following code
    snippet in the `app/tasks/task.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the time has come to configure the routes. We do this in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `routes.ts`, a module that contains our routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the routes in the root module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first order of business is defining the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second order of business is initializing the routes. We do this in the
    root module. To initialize the routes, we need to call `RouteModule` and its static
    method,`forRoot`, and provide it with the routes list as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have set up the routes so they work the way they should. However,
    this approach doesn't scale so well. As your application grows, more and more
    routes will be added to the `routes.ts` file. Just like we moved the components
    and other constructs into their respective feature directory, so should we move
    the routes to where they belong. Our routing list so far consists of one route
    item belonging to the timer feature, two items to the task feature, and one route
    that points to the default route `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our cleanup work will consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating one dedicated `routes.ts` file per feature directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `RouteModule.forChild` in each feature module that has routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing routes from any root module that isn't strictly application-wide, for
    example `** = route not found`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that the application structure now looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After the creation of a few more files, we are ready to initialize our feature
    routes. Essentially, the initialization is the same for both `/timer/routes.ts`
    as `/task/routes.ts`. For that reason, let''s look at one of the `routes.ts` files
    and the intended change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The point here is that moving routes from `app/routes.ts` to `<feature>/routes.ts`
    means we set up the routes in their respective module file instead, namely `<feature>/<feature>.module.ts`.
    Also, we call `RouteModule.forChild`, and not `RouteModule.forRoot`, when setting
    up feature routes.
  prefs: []
  type: TYPE_NORMAL
- en: The router directives – RouterOutlet, RouterLink, and RouterLinkActive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already mentioned in the *Adding support for the Angular router *section, that
    to set up a router there were some essential basic steps to make routing work.
    Let''s remind ourselves of what they were:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a routes list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the `Route` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a viewport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the intents and purposes of this practical example, we have done the top two items,
    what remains is to add the viewport. A directive handles the viewport for Angular;
    it is called the `RouterOutlet` and just needs to be placed in the template for
    the component that sets up routing. So essentially, by opening up `app.component.html`
    and adding `<router-outlet></router-outlet>`, we sort out the last bullet item
    on our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot more to routing, of course. One interesting thing, which is
    expected of every router, is the ability to generate clickable links given a defined
    route. The `routerLink` directive handles that for us and is used in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routerLink` points to the route path, note the leading slash. This will
    look up which route item is defined in our routes list that corresponds to the
    route path `/`. After some investigation in our code, we find a route item that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Take extra notice here that when defining the route; we should not have a leading
    slash, but when creating a link with said route item and using the `routerLink`
    directive, we should have a trailing slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has produced the following element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That looks interesting, the key take away is that `href` is set to `/` and the
    class has been set to active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit was interesting, why would the class be set to active? That''s
    what the `routerLinkActive="active"` does for us. It investigates whether the
    current route we are on corresponds to the `routerLink` element we are currently
    on. If so, it gets awarded the active CSS class. Consider the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Only one of the elements will get the active class set. If the browser URL points
    to `/tasks`, it will be the second item, instead of the first. The fact that the
    active class is being added gives you, as developer, the opportunity to style
    the active menu element, because a menu is what we are creating by defining a
    list of links, such as the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering routes imperatively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more ways to navigate than to click on an element that has the `routerLink`
    directive on it. We can handle navigation in code or imperatively, as it is also
    called. To do so, we need to inject a navigation service that has the capacity
    to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inject the navigation service, also called the `Router`, into a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we set up a `goToTimer` method and associate that to the click
    event of the button. Inside of this method, we call `router.navigate()`, whichtakes
    an array. The first item in the array is our route; note the use of the trailing
    slash. That is how simple it can be to navigate imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: Handling parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have configured pretty basic paths in our routes so far, but what if we want
    to build dynamic paths with support for parameters or values created at runtime?
    Creating (and navigating to) URLs that load specific items from our data stores
    is a common action we need to address on a daily basis. For instance, we might
    need to provide a master-detail browsing functionality, so each generated URL
    living in the master page contains the identifiers required to load each item
    once the user reaches the detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are basically tackling a double trouble here: creating URLs with dynamic
    parameters at runtime, and parsing the value of such parameters. No problem; the
    Angular router has got our back and we will see how by using a real example.'
  prefs: []
  type: TYPE_NORMAL
- en: Building detail pages – using route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s get back to the tasks list component template. We have a router
    that takes us to that list of tasks, but what if we wanted to a look at specific
    task, and what if we wanted that task on a specific page? We can easily solve
    that by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the tasks component to add a navigation capability per item that lets
    us navigate to a task detail view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up routing for one task, the URL path to it will be `tasks/:id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TaskDetail` component that shows just one task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the first bullet point: updating `tasks.component.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be said that we can solve this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate imperatively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a route using `routerLink` that adds a parameter to the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to show how to navigate imperatively first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s highlight the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This produces a link that looks like `/tasks/13` or `/tasks/99`. In this case, `13`
    and `99` are just made-up numbers to show what the route path might look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way of navigating is to use the `routerLink` directive. To accomplish
    this, our preceding template will look slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both these ways work, just use the one that's best for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the second item in the list, which is to set up routing, this will
    match the route path described previously. We open `task/routes.ts` and add the
    following entry to our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this route in place, we have the last item in our list to fix, which is
    defining the `TaskDetailComponent`. Let''s start with a simple version of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With all this in place, we are able to click a task in the list and navigate
    to a `TaskDetailComponent`. However, we are not satisfied here. The real reason
    for doing this was so we can do a more detailed lookup of a task. So, we are missing
    a data call from the `TaskDetail` component to our `TaskService`, where we ask
    for just one task. Remember how our route to `TaskDetail` was `/tasks/:id`? For
    us to make a correct call to our `TaskService`, we need to dig out the ID parameter
    from the route and use that as a parameter when calling our `TaskService`. If
    we route to `/tasks/13`, we need to call `TaskService` with a `getTask(13)` and
    expect one `Task` back.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have two things to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Dig out the router parameter ID from the route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `getTask(taskId)` method to `TaskService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To succeed with the first mission, we can inject something called `ActivatedRoute`
    and talk to its `params` property, which is an Observable. The data coming from
    that Observable is an object where one of the properties is our route parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so this only solves half the problem. We are able to dig out the value
    of our ID parameter this way, but we don't do anything with it. We should be performing
    a data fetch as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add a `switchMap` statement, then we can get hold of the data, carry
    out a data call, and return the result of the data instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to add the `getTask` method to the `TaskService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Filtering your data – using query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have been dealing with routing parameters on the format of `tasks/:id`.
    Links formed like that tell us that the context is tasks and to get to one particular
    task, we need to specify which one, by specifying its number. It''s about narrowing
    down to the specific data we are interested in. Query parameters have a different
    job, they aim to either sort your data or narrow down the size of your data set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Query parameters are recognized as everything happening after the `?` character
    and are separated by an and (`&`) sign. To get to those values, we can work with
    the `ActivatedRoute`, just like we did with routing parameters but we look at
    a different collection on the `ActivatedRouter` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have covered basic routing, with route parameter as well as query
    parameters. The Angular router is quite capable though, and able to do much more,
    such as :'
  prefs: []
  type: TYPE_NORMAL
- en: Defining child routes, every component can have their own viewport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named outlets, the possibility to have different viewports in the same template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging, you can easily enable debugging to showcase how the routing works
    based on your routing list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Child routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a child route? A child route is a concept where we say that a route
    has children. We could write the routes for a feature like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens, though, if we want to have a products container component and
    in that component, we would like to have a product list or a product detail showing?
    For that case, we want to group our routes differently. We have clearly said that
    the `Product` container is the parent component that you should route to. So,
    it would be the first responder when going to the route `/products`. Let''s start
    by setting up the `products` route. It should listen to `/products` URL and have
    the `ProductsContainerComponent` responding, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our other routes can be added as its children, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this might make more sense from an organizational viewpoint but there
    is a bit of a technical difference; the `ProductsContainer` will need to have
    its own `router-outlet` for this to work. So, a quick overview of our app so far
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The main driver for doing it this way is so that we can create a container
    to give that some header or footer information and render replaceable content,
    much like we can do with the template for the app component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In summary the benefits to a container approach is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating child routes means we can treat a feature landing page like a page
    view or a viewport, thereby we can define things such as a header, a footer, and
    a part of the page as a piece of content that can be replaced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to write less when defining the route path, the parent's route is already
    assumed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute versus relative navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to navigate: either we use absolute routes or relative routes.
    An absolute route is specifying its route all the way from the route root, such
    as `/products/2/orders`, whereas a relative route is aware of its context. A relative
    route might therefore look like `/orders`, given that it is aware of it already
    being at `/products/2`, so the full route would read as `/products/2/orders`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be fine using only absolute paths; there is an upside to using relative
    paths, though: it gets easier to refactor. Imagine moving a bunch of components
    around, and suddenly all your hardcoded paths points are wrong. You might argue
    that you should have created a typed version of the route, such as `routes.ProductList`,
    so that you only have to change in one place anyway. That might be so, and then
    you are in a good place. If, however, youdon''t employ those ways of working,
    relative routes are for you. So, let''s have a look at an example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are going one level up. Imagine we are on `/products`. This would
    take us back to `/`. The important part here is to include the second parameter
    and specify the `relativeTo: this.route` bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Named outlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can have more that one outlet directive in a component template, if you
    just keep adding them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have the content rendered out four times. That''s not really why we
    add multiple outlets. We add more than one `router-outlet` so we can put different
    names on it. What is the business case for doing that, though? Imagine we wanted
    to show a header portion and a body portion; depending on what router portion
    we are on, these would differ. It can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are able to target a specific `router-outlet` when routing. So how
    do we:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a route that should target a specific named outlet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate to a named outlet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear a named outlet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how we set up the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows how we set up a shell page, it''s called a shell as
    it acts like a shell for named outlets. That means our shell component looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We also set up two child routes pointing to one named outlet each. The idea
    is that when we route to `/tasks`, the `TaskHeaderComponent` will be rendered
    to the header outlet and the  `TaskComponent` will be rendered to the body outlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an entirely different way of using routes, namely as pop-up outlets.
    This means we can render content to an outlet and also take it away. To accomplish
    this, we need to set up the route like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs to go along with a named outlet being defined, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting off by surfing to a page, this `PopupComponent` will not be visible,
    but we can make it visible by setting up a method wherein we navigate to it, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part here is the argument to `router.navigate` being`{ outlets
    : { <name-of-named-outlet> : <name-of-route> } }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this kind of syntax, it becomes apparent that we can render anything in
    there as long as the route is correctly set up. So, let''s say the routing looked
    like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two candidates that could possibly be rendered at the `popup`
    outlet. To render the error component, simply write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one final thing we need to cover, and that is how to remove the content
    of the named outlet. To do so, we amend the following to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the `closePopup()` method, and what we do inside of there is target
    our named `popup` outlet and provide it with a null argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why do we want to debug the router? Well, sometimes the route doesn''t do what
    we think it should do; when that is the case, it is good to know more about how
    the routing acts and why. To enable debugging, you need to provide a configuration
    object that enables debugging, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to route to, say, `/products` from our start page will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/96742ff5-3a12-4f7f-8ac7-a443481f356f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we can see here is that several events are triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigationStart`: When the navigation starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RoutesRecognized`: Parsing of the URL and recognizing the URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouteConfigLoadStart`: Triggered when reading a lazy load configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouteConfigLoadEnd`: After the route has been lazy loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GuardsCheckStart`: Evaluating the router guard, that is, can we go to this
    route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GuardsCheckEnd`: Router guard check done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResolveStart`: Attempting to fetch data that we need before routing to a path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResolveEnd`: Done resolving the data it was relying on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigationCancel`: Someone or something canceled the routing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavigationEnd`: Done routing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of events that can happen. As you can see from the preceding
    image, our bullet list covers more events than the image showed. This is due to
    us not having any modules that are lazy loaded, so those events aren't triggered,
    and also that we haven't set up any resolve guards, for example. Also, `NavigationCancel`doesn't
    occur unless the routing fails for some reason. It's important what events are
    triggered and when, so that you know what part of the code might be wrong. We
    will look closely at the events, `GuardsCheckStart` and `GuardsCheckEnd`, in our
    next section on determining whether you are authorized to visit a specific route.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning our generated URLs with location strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, whenever the browser navigates to a path by command of a `routerLink`
    or as a result of the execution of the navigate method of the `Router` object,
    the URL showing up in the browser's location bar conforms to the standardized
    URLs we are used to seeing, but it is in fact a local URL. No call to the server
    is ever made. The fact that the URL shows off a natural structure is because of
    the `pushState` method of the HTML5 history API that is executed under the folds,
    and allows the navigation to add and modify the browser history in a transparent
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main providers, both inherited from the `LocationStrategy` type,
    for representing and parsing state from the browser''s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PathLocationStrategy`: This is the strategy used by default by the location
    service, honoring the HTML5 `pushState` mode, yielding clean URLs with no hash-banged
    fragments (`example.com/foo/bar/baz`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashLocationStrategy`: This strategy makes use of hash fragments to represent
    state in the browser URL (`example.com/#foo/bar/baz`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the strategy chosen by default by the `Location` service, you
    can fall back to the old hashbang-based navigation by picking the `HashLocationStrategy`as
    the `LocationStrategy` type of choice.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, go to `app.module.ts` and tell the router, from now on, any
    time the injector requires binding to the`LocationStrategy` type for representing
    or parsing state (which internally picks `PathLocationStrategy`), it should use
    not the default type, but use `HashLocationStrategy` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just need to provide a second argument in the `RouterModule.forRoot()` method
    and make sure the `useHash`is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Securing the routes with AuthGuard and CanActivate hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use `CanActivate` in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to data you need to be logged in for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access to data you need to have the correct role for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So essentially, it is about potentially both authentication and authorization.
    What we need to do to make this happen is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a service that needs to evaluate whether you have permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add said service to the route definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is just any service you create, but it needs to implement the `CanActivate`interface.
    So, let''s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is implement the `CanActivate` interface by declaring the `canActivate()`method.
    We also injected an `AuthService`instance that we pretend exists. The point is
    that the `canActivate()`method should return `true` if navigation should continue
    and `false` if it should be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on to the next step of adding this service to the routing config; we do
    that by adding to the list that the `canActivate` property holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this out and see how our route debug changes if we return `true`
    from the`canActivate()` method, or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b77201f7-767c-4f22-8993-6d0f1152b53d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In `GuardsCheckEnd` we see that the `shouldActivate : true` property is emitted.
    This is because our `canActivate` method currently returns `true`, that is, we
    allow the routing to happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we change `canActivate` to return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/78c39be8-e946-4454-8fe8-dd95aaa514fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that in the `GuardsCheckEnd` event the `shouldActivate`now
    has the value `false`. We can also see that the `NavigationCancel`event has been
    emitted. The end result is that we weren't allowed to change route based on the `canActivate()` 
     method returning `false`. Now it is up to you to implement an authentication/authorization
    method and make it work for real.
  prefs: []
  type: TYPE_NORMAL
- en: Resolve<T> – fetching and resolving data before routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason for using this hook is so we can delay the routing to happen after
    we have fetched all the necessary data. You should not have anything long-running
    happening though. A more real case is that you have navigated to a product route,
    such as `/products/114`, and want to look up in the database what that product
    is and provide that to the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need the following to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `Resolve<T>` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a `Promise` from the`resolve()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the service as a provider to the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the service in the resolve property of the route it is providing data to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement said service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have implemented the `Resolve<T>` interface and we also ensure
    that a `Promise` is returned from the `resolve()` method. We also have some logic
    saying we will redirect the user if the data we get back is not what we expect
    or if an error happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we need to add the service to the `providers` keyword of our
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last step, we need to add the service to the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The CanDeactivate – handling cancel and save
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so we have the following situation: the user is on a page, they have
    filled in a lot of data when they decide to press a navigation link that takes
    them away from the page. At this point, you, as a developer, want to establish
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the user has filled in all data, they should then continue with navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user has not filled in all data, they should have the option of leaving
    the page anyway or remaining to complete the data entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To support these scenarios, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a service that implements the  `CanDeactivate` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the target component into the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set said service up as a provider to the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set service as `canDeactivate` responder in the route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the target component injectable and set it up as a provider to the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write logic to handle the case that all fields are filled in – keep routing,
    if fields are missing show a confirm that lets the user decide whether to continue
    to route away or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Starting with the service, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Worth highlighting here is how we define the logic in the `canDeactivate` method
    to have a return type that is either `Boolean` or a `Promise<boolean>`. This gives
    us the freedom to short circuit the method early if all valid fields are filled
    in. If they are not, we show the user a confirm message that freezes on the confirm
    until the user has decided what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is telling the module about this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to perform a change in the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For the next step, we are going to do something we don''t usually do, namely,
    set up the component as an injectable; this is needed so it can be injected into
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we need to add the component as a provider in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Async routing – improving response time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventually, your application will grow in size and the amount of data you put
    into it will also grow. The net result of this is that the application takes a
    long time to start initially, or certain parts of your application take a long
    time to start. There are ways around this, such as lazy loading and preloading.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading means we don't start with all of the application loaded initially.
    Parts of our application can be cordoned off into chunks that are only loaded
    when you ask for them. Today, this is centered around routes, this means that
    if you ask for a specific route you have not visited before, the module and all
    its constructs will be loaded. This is not something that is there by default
    but something you can quite easily set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at an existing module and its routes, and see how we can
    turn that into a lazy-loaded module. We will have to make changes in the following
    places :'
  prefs: []
  type: TYPE_NORMAL
- en: The routes list for our feature module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a route entry in our application routes, with a specific lazy-load syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove all references to the feature module in other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, a quick look at our feature modules routing list, prior to the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Our first order of business is to change the path for the first route entry
    from lazy to `''`, an empty string. It sounds a bit counterintuitive, but it has
    an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we do is to remedy the first thing; we need to add a lazy
    route entry to our app module routing, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we add the `loadChildren` property and this property expects
    a string as a value. This string value should point to where the module can be
    found, so essentially it looks like `<path to the module from the root>#<Module
    class name>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to remove all references to this module in other modules,
    for a very natural reason: if you haven''t navigated to `/lazy`, a service or
    component and so on doesn''t really exist yet, as its bundle hasn''t been loaded
    to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s have a look at what this looks like in the debug mode. The
    first image will show what it looked like before we navigated to our lazy module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50f37b7f-b0af-49d7-8077-14dc222d1c25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have our normal bundles that our project setup produces. Let''s now
    navigate to our lazy route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/927c9c75-d6ec-4527-867d-f7e20f182797.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that a bundle has been added called `5.chunk.js`, and it contains
    our newly loaded module and all its constructs.
  prefs: []
  type: TYPE_NORMAL
- en: A little word of caution though, is to not place constructs in lazy-loaded modules
    that you think you will use elsewhere. Conversely, you can let your `lazy` module
    depend on services and constructs found in other modules, as long as those are
    not lazy loaded. A good practice is therefore, to make as many modules as possible
    lazy loaded but shared functionality can't be lazy loaded, for the above mentioned
    reason.
  prefs: []
  type: TYPE_NORMAL
- en: CanLoad – don't lazy load unless the user has access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading is a great feature that can drastically reduce the loading time
    of your application by ensuring your application only starts with the bundles
    it absolutely needs. However, even if you ensure that most of your modules are
    lazy loaded, you need to take it a step further, especially if your application
    has any authentication or authorization mechanisms in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following, let us say that more than one of your modules needs
    the user to be authenticated or to have the role of admin. It would make no sense
    to load those modules when a user routes to their path if they are not allowed
    in that area anyway. To remedy this scenario, we can use a guard called `CanLoad`.
    `CanLoad` ensures we first validate whether it makes sense to lazy load a certain
    module based on a condition. You need to do the following to use this:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `CanLoad` interface and the `canLoad()` method, in a service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the preceding service to the `CanLoad` property of your route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following creates a service that implements the `CanLoad` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, the `canLoad()`method returns a Boolean. In this
    case, we have made it return `false`, which means the module will not be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we needed to do was to update the route to use this service
    as a `canLoad` guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to surf to `localhost:4200/lazy`, we go nowhere as our `canLoad`,
    by returning `false`, tells us that we can''t. Having a look at our console, we
    also see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43f0e34b-fe70-4ef0-a1a8-255074bce43c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, it says it cannot load children due to the guard, so the guard is working.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how everything works fine and loads like it should when you update the `CanLoadService` and `canLoad()`method
    to return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to add `CanLoadService` to the providers array of the root module.
  prefs: []
  type: TYPE_NORMAL
- en: Preloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been discussing eager loading and lazy loading. Eager loading,
    in this case, has meant that we load the entire application at once. Lazy loading
    has been about us identifying certain modules as modules that we only load on
    demand, that is, they are lazy loaded. There is, however, something in between:
    preloaded modules. Why do we need something in between, though? Well, imagine
    that we know with a good certainty that a normal user will want to access the
    products module within 30 seconds after logging in. It makes sense to mark the
    products module as a module that should be lazy loaded. It would be even better
    if it could be loaded in the background right after login so that it is ready
    to go when the user navigates to it. That is exactly what preloading does for
    us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We enable preloading by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This `PreloadAllModules` value preloads each and every lazy-loaded route, except
    for the ones guarded by the `canLoad`guard. This makes sense: the `canLoad` only
    loads if we are authenticated/authorized, or based on some other condition that
    we set up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we had a bunch of modules that were all set up as lazy, such as products,
    admin, categories, and so on, all of those would be loaded right after the initial
    boot based on `PreloadAllModules`. That might be good enough on a desktop. However,
    if you are on a mobile connection such as 3G, this might be way too heavy. At
    this point, we want better, more fine-grained control. What we can do is implement
    our own custom strategy for this. We need to do the following to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a service that implements `PreloadingStrategy` and the `preload` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `preload()` method must call the`load()` method, if it should be preloaded,
    or should return an empty Observable otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define whether a route should be preloaded, by using the data attributed on
    a route, or by using a service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the create strategy service as the value of `preloadingStrategy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first order of business, defining our service, we create it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can see how we invoke the load method if our `route.data` contains the preload
    Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for setting up the route correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The data property has been set to an object containing our `preload` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the last step. Let''s make the `RouterModule.forRoot()` aware that
    this service exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In short, this is a very efficient way of ensuring the user has the best possible
    experience without succumbing to either eager loading, or having to wait for a
    lazy load.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now uncovered the power of the Angular router and we hope you have enjoyed
    the journey into the intricacies of this library. One of the things that definitely
    shines in the Router module is the vast number of options and scenarios we can
    cover with such a simple but powerful implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the basics of setting up routing and handling different types
    of parameters. We have also learned more advanced feature such as child routing.
    Furthermore, we have learned how to protect our routes from unauthorized access.
    Finally, we have shown the full power of async routing and how you can really
    improve response time with lazy loading and preloading.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will beef up our task-editing component to showcase
    the mechanisms underlying web forms in Angular and the best strategies to grab
    users' input with form controls.
  prefs: []
  type: TYPE_NORMAL
