- en: Creating a Screen Capturer with NW.js, React, and Redux – Planning, Design,
    and Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are starting a new application screen capturer. With this
    tool, will be able to take screenshots and record screencasts. We will build the
    application using the React components of the Material UI toolkit, which implements
    Google's Material Design specification. We already gained some experience with
    React while working on the chat example. Now, we are taking a step further towards
    scalable and highly maintainable application development. We are going to have
    an introduction to one of the hottest libraries of the time that called Redux,
    which manages the application state.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will have a prototype, which already responds
    to user actions, but misses the service to capture display input and save it in
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Application blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we will develop a screen capturer, a little tool capable of taking
    screenshots and recording screencasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core idea can be expressed with the following user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As a user, I can take a screenshot and save it as a `.png` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can start recording a screencast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can start recording the screencast and save it as `.webm` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, I expect a notification to appear when a screenshot or screencast
    file is saved. I also would like to have the application presented in the system
    notification area (**Tray**) and to respond to specified global hot-keys. With
    a help of WireframeSketcher ([http://wireframesketcher.com/](http://wireframesketcher.com/)),
    I illustrated my vision with the following wireframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57de0862-ee30-4ff3-b481-8704cf5cb47f.png)![](img/d4f04746-888f-476a-8719-f4afadbe6ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe implies a **Tabbed Document Interface** (**TDI**) with two panels.
    The first one, labeled as Screenshot, allows us to take a screenshot (photo icon)
    and set the filename pattern for the output file. The second panel (Animation)
    looks pretty much the same, except the action button is intended to start screencast
    recording. As soon as a user hits the button, it gets replaced with the stop recording
    button and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create this application with NW.js. As you may remember from [Chapter
    1](ed6645a7-d7e6-4322-909d-0777d9763560.xhtml), *Creating a File Explorer with
    NW.js - Planning, Designing, and Development* and Chapter 2, *Creating a File
    Explorer with NW.js – Enhancement and Delivery*, NW.js looks up the manifest file
    for the start page link and application window meta information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This time, we do not need a big window. We go with `580x320px` and allow shrinking
    the window size down to `450x320px`. We set the window to open at the center of
    the screen without the frame and built-in windowing controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we were setting up NW.js in the first two chapters, we had just a few
    dependencies. Now, we are going to take advantage of React and, therefore, we
    need the corresponding packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As for dev dependencies, obviously, we need NW.js itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Same as for the chat application that is also based on React, we will use Babel
    compiler and Webpack bundler. So, it gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we remember Babel by itself is a platform, we need to specify what exact
    preset it applies to compile our sources. We already worked with these two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we extend the list with the `stage-3` preset ([https://babeljs.io/docs/plugins/preset-stage-3/](https://babeljs.io/docs/plugins/preset-stage-3/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This plugin set includes all the features of the so-called **Stage 3** proposal
    for the **EcmaScript** specification. In particular, it comprised of spread/rest
    operators on objects, which unlocks the most expressive syntax for the object
    composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we will apply two plugins not included in Stage 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are already familiar with the first one (ES Class Fields and Static Properties—[https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)).
    The second allows us to use decorators ([https://github.com/tc39/proposal-decorators](https://github.com/tc39/proposal-decorators)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since everything else is ready, we will extend the manifest file with automation
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These targets have already been used while developing the chat application.
    The first one fires up the application. The second compiles and bundles sources.
    And the third one runs continuously and builds the project every time any of the
    source files change.
  prefs: []
  type: TYPE_NORMAL
- en: 'For bundling, we have to configure Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So Webpack will start bundling ES6 modules recursively with `./js/app.jsx`.
    It will place the resulting JavaScript in `./build/app.js`. On the way, any `.js/.jsx`
    file requested for export will be compiled with Babel according to the configured
    presets and plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Static prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chat application we styled using CSS is provided by the Photon framework.
    This time, we are going to use ready-made React components of the Material-UI
    toolkit ([http://www.material-ui.com](http://www.material-ui.com)). What we get
    as developers is reusable units confronting Google Material Design guidelines
    ([https://material.io/guidelines/](https://material.io/guidelines/)). It ensures
    a good look and feel as well as providing a unified experience on different platforms
    and device sizes. We can install Material-UI with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'According to Google Material Design requirements, the application shall support
    different devices, including mobile, where we need to handle specialized events,
    such as `on-tap`. Currently, React does not support them from the box; one has
    to use a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We do not intend to run our application on a mobile, but without the plugin,
    we are going to have warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we are done with preparations, we can start scaffolding, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add our startup HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `head` element, we link to three external stylesheets. The first
    one (`https://fonts.googleapis.com/icon?family=Material+Icons`) unlocks Material
    Icons ([https://material.io/icons/](https://material.io/icons/)). The second (`https://fonts.googleapis.com/css?family=Roboto`)
    brings the Roboto font that is extensively used in Material Design. The last one
    (`./assets/main.css`) is our customization CSS. In the body, we set the `root`
    container for the application. I decided, instead of a custom element for readability,
    we could use an ordinary `div` instead. At the end, we load the JavaScript (`./build/app.js`)
    generated by Webpack according to our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the custom styles that we have already referred in `main.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./assets/main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the entry point script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`./js/app.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we import the `App` container component and render it into the `<root>`
    element of the DOM. The component itself will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Containers/App.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we wrap the application pane (`Main`) with the Material UI theme
    provider. With the `getMuiTheme` function imported from the Material UI package,
    we describe the theme and pass the derived configuration to the provider. As mentioned
    previously, we have to apply `injectTapEventPlugin` to enable the custom events
    in React that are used by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is the time to add presentational components. We start with the main layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/Main.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This component comprises the title bar, two tabs (`Screenshot` and `Animation`),
    and conditionally, either the `ScreenshotTab` panel or `AnimationTab`. For rendering
    the tab menu, we apply the Material UI `Tabs` container and the `Tab` component
    for child items. We also use the `FontIcon` Material UI component to render Material
    Design icons. We assign icons declared at the beginning of the render method to
    corresponding tabs by using props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/TitleBar.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the title bar with the `AppBar` Material UI component. Like in
    the previous example, we preliminarily define icons (this time, by using the `IconButton`
    component) and pass them to `AppBar` with props. We set inline handlers for the
    `IconButton` click event. The first one hides the window and the second closes
    the application. What is more, we set a custom CSS class `titlebar` to `AppBar`,
    because we are going to use this area as a window handle for drag and drop. So,
    we extend our custom style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a component representing tab panels. We start with `ScreenshotTab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/ScreenshotTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `IconButton` for the Take a screenshot action. We make it extra
    large by passing it with props custom styling (`TAB_BUTTON_STYLE`). In addition,
    we apply the `TextField` component to render text input in the style of Material
    Design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second tab panel will be quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/AnimationTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only difference it makes here is the conditional rendering of either the
    `Start recording` button or `Stop recording`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is pretty much everything for the static prototype. We just need to
    bundle the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And fire it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1828ac2a-f29d-4d46-9286-a0a2ff41185f.png)'
  prefs: []
  type: TYPE_IMG
- en: Comprehending redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned to manage the component state while working on the chat application.
    It was quite sufficient for that small example. However, as the application grows
    larger, you may notice that multiple components tend to share the state. We know
    how to lift the state up. But which exact component then shall manage the state?
    Where does the state belong? We can avoid this ambiguity by drawing on Redux,
    a JavaScript library known as a predictable state container. Redux implies an
    application-wide state tree. When we need to set the state for a component, we
    update the corresponding node in the global state tree. All the subscribed modules
    immediately receive the updated state tree. Thus, we can always easily find out
    what is going on with the application by checking the state tree. We can save
    and restore the entire application state at will. Just imagine, with a little
    effort, we can implement time traveling through application state history.
  prefs: []
  type: TYPE_NORMAL
- en: I presume you are probably a bit confused now. The approach, if you have no
    experience with it or its predecessor Flux, may look strange. In fact, it's surprisingly
    easy to grasp when you start working with it. So, let's jump in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux has three fundamental principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything that happens within the application is represented by a state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state is read-only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State mutations are made with pure functions that take the previous state, dispatch
    action, and return the next state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We receive new states by dispatching actions. An action is a plain object with
    the only mandatory field type that accepts a string. We are allowed to set as
    many arbitrary fields as we wish for the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec15eab6-e352-490e-bc34-e2604db7d69e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure depicts the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: We have the store in a particular state; let's say A.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We dispatch an action (created by a pure function, called **Action Creator**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That invokes the **Reducer** function with arguments: state object (representing
    state A) and the dispatched action object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Reducer** clones the supplied state object and modifies the clone object
    according to the scenario defined for the given action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Reducer** returns the object representing the new store, **State B**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any component connected to the store receives the new state and calls the `render`
    method to reflect the state change in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, in our application, we are going to have tabs. When a user clicks
    on all of them, the corresponding panel is supposed to show up. So, we need to
    represent the current `activeTab` in the state. We can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we dispatch actions not directly, but via a function, which is called
    `actionCreator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The function takes zero or more input arguments and produces the action object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Action** indicates that something happened, but doesn''t change the state.
    That is a task of another function called **Reducer**. **Reducer** receives as
    a parameter of an object representing the previous state and the last dispatched
    action object. According to the action type and payload, it produces a new state
    object and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we defined the initial application state in the constant
    `initialState`. We make it the default function parameter ([https://mzl.la/2qgdNr6in](https://mzl.la/2qgdNr6in))
    with the statement `state = initialState`. It means that when nothing is passed
    with the arguments, `state` takes the value of `initialState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to how we get a new state object. We declare a new object literal.
    We are destructuring the previous state object in it and extending it with the
    `activeTab` key-value pair set from action payload. Reducer must be a pure function,
    so we could not change a value passed in the state object. You know that, with
    parameters, we receive `state` as a reference, so if we simply changed the value
    of the `activeTab` field in `state`, the corresponding object outside the function
    scope would have been impacted through the link. We have to ensure the previous
    state is immutable. So, we create a new object for that. Destructuring is a considerably
    new approach. If you do not feel comfortable with it, you can go with `Object.assign`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For our application, we will use the only reducer, but in general, we may have
    many. We can use the `combineReducers` function exported by `redux` to combine
    multiple reducers so that each of them represents a separate leave of the global
    state tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass to `createStore` function of `redux` the reducer (can be also a product
    of `combineReducers`). The function produces the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we render the React application on server-side, we can expose the state
    object into the JavaScript global scope (for example, `window.STATE_FROM_SERVER`)
    and connect it from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const store = createStore( reducer, window.STATE_FROM_SERVER );`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now is the most exciting part. We subscribe to store events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then dispatch an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'While dispatching, we created an action of the type `SET_ACTIVE_TAB` with `activeTab`
    set to `SCREENSHOT` in the payload. Therefore, `console.log` in the store update
    handler prints the new state updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After this brief tour into Redux, we will apply the newly obtained knowledge
    in practice. First, we will install the `redux` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the additional helper library `redux-act` ([https://github.com/pauldijou/redux-act](https://github.com/pauldijou/redux-act))
    to simplify the declaration of action creators and reducers. By using this library,
    we can use the action creator functions as references within reducers, abandoning
    the `switch( action.type )` construction in favor of a shorter map syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For screen capture, we should perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SET_ACTIVE_TAB`: It receives the identifier of the selected tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOGGLE_RECORDING`: It receives `true` when screencast recording starts and
    `false` when it ends'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_SCREENSHOT_FILENAME`: It receives the output filename in the panel Screenshot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_SCREENSHOT_INPUT_ERROR`: It receives a message when an input error occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_ANIMATION_FILENAME`: It receives an output filename in the panel Animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_ANIMATION_INPUT_ERROR`: It receives a message when an input error occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Actions/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the canonical syntax, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We go here with a shorter one, achieved with the `createAction` function of
    `redux-act`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function, `createReducer`, exported by `redux-act`, makes the reducer
    declaration even shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Reducers/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need to describe reducer conditioning with a `switch` statement like
    we did during Redux''s introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `createReducer` does it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in a map-like object, where we use action creator functions
    as keys (for example, `[ Actions.setActiveTab ]`). Yeah, for dynamic object keys,
    we have to go with the syntax called **Computed property names** at [https://mzl.la/2erqyrj](https://mzl.la/2erqyrj).
    As object values, we use callbacks to generate the new state.
  prefs: []
  type: TYPE_NORMAL
- en: In this sample, we clone the old state (`{...state}`) and change in the derived
    object `activeTab` property value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noted, we used imports from `Constants/index.js`. In that module, we
    are going to encapsulate the application scope constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Constants/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we have actions and a reducer. That''s the time to create the store and
    connect it to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Containers/App.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We build the store using the `createStore` function of `redux`. Then, we wrap
    the `App` component with `Provider` provided by the `react-redux` package. Do
    not forget to install the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Provider** takes in a previously created store with props and makes it
    available for another `react-redux` function, `connect`. We will use this function
    in our `App` container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Containers/App.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define two mapper functions that `connect` accepts as arguments. The
    first `mapStateToProps` maps the stored state to the props. With the statement
    `( state ) => ({ states: state })`, we make the store state available in the component
    as `this.props.states`. The second `mapDispatchToProps` maps our actions to the
    props. The callback receives automatically from the `connect` function `dispatch`
    bound to the store. Together with the function `bindActionCreators` of `redux`,
    we can use it to map a set of actions to the props. So, we imported all the available
    actions as a plain object, `Actions`, and passed it to `bindActionCreators`. The
    return is mapped to the `actions` field, and therefore will be available within
    the component as `this.props.actions`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we pass the component to a function produced by `connect`. It extends
    the component, which we export upstream. This expression may look a bit confusing.
    Actually, what we do here is we modify the behavior of the component without explicitly
    modifying the component itself. Traditionally, in OOP languages, we used to achieve
    it with the Decorator pattern ([https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern)).
    Nowadays, many languages have built-in capacities, such as attributes in C#, annotations
    in Java, and decorators in Python. ECMAScript also has a proposal, [https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/),
    for decorators. Thus, by using the declarative syntax, we can modify the shape
    of a class or a method without touching its code. The plugin `babel-plugin-transform-decorators-legacy`,
    which we used in our Webpack configuration unlocks this feature to us. So, we
    can already use it for connecting the component to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From the container, we render the `Main` component and pass to it all the props
    of the container (by destructuring the parent props `{...this.props}`). So, `Main`
    receives the mapped state and actions in the props. We can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/Main.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you remember, this component serves the tab menu. We subscribe here for the
    *click on tab* events. We do not subscribe to the handler directly, but a function,
    `this.onTabNav`, bound to the instance scope that produces the intended handler
    according to the passed-in tab key. The constructed handler receives the key with
    the closure and passes it to the `setActiveTab` action creator extracted from
    `this.props.actions`. The action gets dispatched and the global state changes.
    From the component's perspective, it is like calling `setState`, which causes
    the component to update. The `activeTab` field extracted from `this.props.state`
    changes its value respectively and the component renders the panel matching the
    key passed with `this.onTabNav`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the panel, we can already connect the filename form to the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/ScreenshotTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we subscribe the `this.onFilenameChange` handler for the `change` event
    on `TextField`. So, if the user types in `this.onFilenameChange` it invokes and
    validates the input. If the current value is less than six characters in length
    or does not end with `.png`, it is considered as invalid. So, we use the `setScreenshotInputError`
    action creator extracted from `this.props.actions` to set a value for the error
    message. As soon as it is done, the `screenshotInputError` field of the state
    changes as well as the `errorText` property of the `TextField` component, and
    the error message shows up. If the filename is valid, we dispatch the `setScreenshotInputError`
    action to reset the error message. We change the screenshot filename in the state
    tree by calling the action creator `setScreenshotFilename`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have noticed, we encapsulated the `IconButton` custom style in the constants
    module, so it could be shared between both panels. But we have to add the new
    constant to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Constants/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second panel, in addition to form validation, also changes the state field
    `isRecording`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/AnimationTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We subscribe the handlers for click events on both the Start recording and Stop
    recording buttons. When a user hits the first one, the `this.onRecord` handler
    invokes the action creator, `toggleRecording`, which sets the state field `isRecording`
    to `true`. It causes the component to update. According to the new state, it replaces
    the Start recording button with the Stop recording one. And vice versa, if Stop
    recording is clicked in the `this.onStop` handler, we call `toggleRecording` to
    set the state property `isRecording` to `false`. The component updates respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build the application and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Observe that when we are switching tabs, editing file names, or toggling start/stop
    recording, the application responds as we intend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we familiarized ourselves with the basics of Google's Material
    Design. We built the static prototype from ready-made React components of the
    Material-UI set. We had an introduction into the Redux state container. We defined
    our application state tree and set state mutators. We created the global state
    store and connected it to the container component. We passed exposed action creators
    and state tree trunk into presentation components with the props. We examined
    shorter action/reducer declaration syntaxes provided by the `redux-act` library.
    We implemented it by using Redux state machine actions, such as tabbed navigation,
    recording toggle, and form validation.
  prefs: []
  type: TYPE_NORMAL
