- en: '*Chapter 3*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js APIs and Web Scraping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement Node.js applications using global objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create readable and writable Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write to files using asynchronous and synchronous APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create static and dynamic web servers using the http module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download content from websites using the http/https modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query and extract data from parsed HTML content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn about global objects and functions. Then, we
    will learn how to write efficient web servers, both static and dynamic, using
    the http module. Finally, we will use the http and https modules to scrape web
    pages and extract data from them.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the outset, Node.js was created to provide an alternative to the thread-per-request
    model of the first generation of HTTP servers. The event loop and the asynchronous
    nature of Node.js make it ideal for I/O-intensive servers that need to provide
    high throughput for a high number of concurrent clients. Because of that, it came
    armed with powerful and simple-to-use APIs to build HTTP servers out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about what Node.js and NPM are and how they
    work. In this chapter, you will learn about the basic global objects that are
    available to every script in Node.js. You will learn about readable and writable
    streams and how you can use them to read and write to files asynchronously. You
    will also learn how to read and write to files using the synchronous filesystem
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the last couple of sections, you will learn how to use the HTTP module to
    write web servers and make HTTP requests. You will build a static and a dynamic
    web server. Then, you will learn the basics of web scraping and how to use it
    to extract data from websites.
  prefs: []
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js execution context contains a few **global** variables and functions
    that can be used from anywhere in any script. The most widely used of all is the
    `require` function, since it is the function that helps you load other modules
    and access the non-global functions, classes, and variables that are available
    from the Node.js APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must have noticed this function being used in the previous chapter when
    we loaded the `commander` module from the package you installed in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It receives one parameter, which is a string representing the ID of the module
    you want to load, and returns the module's content. Internal modules, such as
    the ones we will discuss in this chapter, and the modules that are loaded from
    packages and installed by npm, are identified directly by their names, such as
    commander, fs, and http. In *Chapter 5, Modular JavaScript*, you will see how
    to create your own modules and how to use this function to load them.
  prefs: []
  type: TYPE_NORMAL
- en: Another important and widely used global is the console. Just like in the Chrome
    Developer tools, the console can be used to print text to the Terminal using standard
    output and standard error. It can also be used to print text to files for logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you have used console many times, like in the last exercise of the
    previous chapter, where you printed the following manipulated HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The console has a lot more to offer than just the `log` function. Let's take
    a deeper look at some of its applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to print some text to the console, you can use any of the following
    functions: `debug`, `error`, `info`, and `warn`. The difference between them is
    where the text ends up. When you use the `debug` and `info` methods, the text
    will be printed to standard output. For `warn` and `error`, the messages will
    be printed to standard error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you have the following code inside `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the script and redirect to different files, and then print their content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the preceding functions, as well as the log function, can format text if
    you want, which they do by providing extra arguments and a format string. You
    can read more about format strings in the `util.format` function documentation:
    [https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args](https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args).
    You can also use backticks if you prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to print some text conditionally, you can use `assert`. Assert
    can be used to check whether a condition is true. If it''s false, then it will
    print the text using `console.warn`, with some text explaining that the assertion
    failed. If it''s true, then it will not print anything. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This would only output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `trace` function is used to identify the source file and line of the output.
    It receives the same arguments as log and the others, but it will also print the
    stack trace for the log statement; that is, the filenames and lines where the
    call happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an array of data and want to show it as a table, you can use the
    table method. It receives two arguments: the tabular data and the properties you
    want to see in the table. For example, consider the following tabular data (array
    of objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You could print all the columns by passing the data to `console.table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Output of the console.table function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Output of the console.table function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Alternatively, you could pass a list of the property names that you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/C14587_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Output of console.table when passing a list of properties to print'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another interesting thing you can use `console` for is to time how long specific
    parts of your code will take to run. To do that, you use the `time` and `timeEnd`
    methods, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also give your timer a name and use multiple timers at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you want to know where a script was loaded from or what the full
    path of the file is. For that, every script has two globals defined: `__filename`
    and `__dirname` (that''s two underscores, and then filename/dirname). An example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the browser, when you want to execute a certain function in the future or
    at regular intervals, you can use `setTimeout` and `setInterval`, respectively.
    These functions are also available in the Node.js execution context and work the
    same way as in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can schedule code to execute some time from now by passing a callback function
    to be executed and the amount of time in milliseconds in the future you want it
    to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, `setTimeout` returns a timer ID, which is an integer and can''t
    do more than canceling the timer through the `clearTimeout` function. In Node.js,
    `setTimeout` returns a `Timeout` object that has some methods itself. An interesting
    one is the `refresh` method, which resets the start time of the timer to the current
    time and restarts counting the timer as if it had been scheduled at that moment.
    Take a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From the output, you can see that even though `secondTimer` was scheduled to
    run 3 seconds in the future, it ran 5 seconds in the future. That's because the
    second `setTimeout`, which was set to 2 seconds, refreshes it, restarting the
    count at that time, adding 2 seconds to the 3-second timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, you can use the `Timeout` instance to cancel the
    timer using the `clearTimeout` function. The following code is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`setTimeout` executes only once. You can use `setInterval` to do a specific
    task every specific amount of time. `setInterval` also returns a `Timeout` instance
    that can be used to cancel the timer using `clearInterval`. The following example
    sets a timer to run every second and keeps track of the number of times it ran.
    After a certain number of executions, it cancels the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this code looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the browser, we have a global object called window that represents the browser.
    In Node.js, we have process, which represents the currently running application.
    Through it, we can access the arguments that are passed into the application,
    including standard inputs and outputs and other information about the process,
    such as version or process ID.
  prefs: []
  type: TYPE_NORMAL
- en: To access the arguments that are passed into the process, you can use the `argv`
    attribute of the global variable process. `argv` is an array that contains each
    argument in a position. It includes the path to the Node.js binary and the full
    path of the script as the first two elements. After that, all the other extra
    arguments are passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code would print all the arguments passed in, each in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over some sample outputs for this single-line application.
  prefs: []
  type: TYPE_NORMAL
- en: 'No extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Many arguments separated one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One argument all in one string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we used the `commander` library to parse command-line
    arguments. When configuring `commander`, the last call to it was `parse(process.argv)`,
    which gave `commander` access to all the options that were passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important role that the process variable holds is access to standard
    inputs and outputs. If you want to print something to the console, you can use
    `stdout` and `stderr`. These two attributes are what `console.log` and all the
    other methods in the console use under the hood. The difference is that `stdout`
    and `stderr` do not add a new line at the end of each call, so you have to do
    that yourself if you want each output to go into its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These are two examples that print something with a new line at the end. For
    most cases, it is recommended to use the console since it gives you some extra
    stuff on top, such as logging levels and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to read input from the command line, you can use `process.stdin`.
    `stdin` is a Stream, which we''re going to talk more about in the next section.
    For now, you just need to know that Streams are based on events. That means that
    when input comes in, it will arrive in the form of a data event. To receive input
    from the user, you need to listen to that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When there''s no more code to be executed, the event loop will block, waiting
    for input from standard input. When the input is read, it will be passed into
    the callback function as a Buffer of bytes. You can convert it into a string by
    calling its `toString` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use it like any normal string. The following sample application
    demonstrates how you can use `stdout`, `stderr`, and `stdin` to request input
    from the user from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows what it would look like after running the application
    and typing some words, pressing *Enter*, and then typing "exit" to quit the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that when the user types "exit", it executes
    a special branch of the application code that calls `process.exit`, which is a
    function that exits the whole process and returns the specified exit code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Creating a Task Reminder Application'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will create a task reminder application. Now that we have
    learned how to interact with the user using the global variable process and also
    learned how to create timers, let's write an application that will use these new
    skills to manage reminders from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The application will receive inputs from the user and collect information to
    build a reminder. It will use a message, a time unit, and an amount of time. The
    input to the application will be provided in phases. Each phase will ask the user
    for some input, collect it, validate it, and then set the value of a variable
    to move to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an empty folder, create a new package using `npm init` and a file called
    `index.js`. In the `index.js` file, we will start by adding some constants and
    variables where we will store the state to create the timer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the function that is the heart of the application. This is
    what the function looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function processes all the input from the user in a set of conditions that
    will be based on the current state, based on what variables are already available.
    When the input is processed, it's then set back to null so that the next stage
    can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding function calls some functions that don''t exist yet: `askForMessage`,
    `askForTimeUnit`, and `askForAmount`. These functions are responsible for validating
    the input and setting the variables according to each phase so that the code can
    move to the next phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Add some details to the `askForMessage` function. The first thing the function
    does is check whether the input is null, which means that it's changing phase
    for the first time. This means it needs to print the prompt for input for the
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If the input is not `null`, this means that the user already inputted information
    for the current state and it needs to be validated. If validation fails, print
    more information and wait for the next input.
  prefs: []
  type: TYPE_NORMAL
- en: If the input is valid, then it sets the variable for the current state, which
    is `message` in this case, which will move the code to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `askForTimeUnit` function, which is the function that will
    handle the next phase of the code. This function uses the constants listed in
    the first step to print the supported time units and lets the user pick one. It
    works similar to the `askForMessage` function: `prompt`, `validate`, and `set
    value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we create the `askForAmount` function, which handles the last phase.
    This function prompts the user for some amount of time to create the timer. Like
    before, it has three parts: `prompt`, `validate`, and `set value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `askForAmount` function, it calls the `setTimerAndRestart`
    function. Let''s create that function, which creates the timer and resets all
    states so that the loop can start again, and the user can create new timers. This
    is what the `setTimerAndRestart` function looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: One important bit here is the special character, `\x07`. This will cause your
    Terminal to make a beep and then print the text set in the message. Also, the
    text is specially formatted with new lines at the beginning and end so that it
    doesn't disrupt the usage of the tool that much since the timers will print while
    the user continues to use the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of the application needs to register the listener to the data
    event in standard input and start the cycle by asking the user for the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the application from your Terminal, set up a couple of reminds,
    and hear it beep back at you as the timers expire:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/C14587_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Output after running the application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will notice that the only way to exit the application is to send the interrupt
    signal by pressing the *Ctrl+C* keys at the same time. As an extra challenge,
    try adding some code that will create an exit point so that the user can exit
    in a friendlier way.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with user inputs is fundamental for every command-line application.
    In this exercise, you learned how to master the asynchronous nature of Node.js
    so that you could handle a complex set of inputs to guide the user in the decision-making
    process of creating a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: FileSystem APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned about the global variables available to
    us in the Node.js execution context. In this section, we will learn about the
    FileSystem APIs, which are the APIs that are used to access files and directories,
    read and write data to files, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: But before we dig into the FileSystem APIs, we need to understand streams. In
    Node.js, a Stream is an abstract interface that represents streaming data. In
    the previous section, we used the standard I/O and briefly mentioned that they
    are streams, so let's understand them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams can be readable, writable, or both. They are event emitters, which
    means that to receive data, you need to register event listeners, just like we
    did with standard input in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will continue to build on our understanding of the previous
    sections and see that streams are used as an abstraction to represent all the
    things that data can flow through, including standard input and outputs, files,
    and network sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start understanding how this works, we will write an application that reads
    its own code by using `createReadStream` from the filesystem package. To use the
    FileSystem APIs, we need to import them, since they are not globally available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create a readable stream that points to the script file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we register for the events of the stream so that we can understand
    what''s going on. The read stream has four events that you should care about:
    ready, data, close, and error.'
  prefs: []
  type: TYPE_NORMAL
- en: Ready tells you when the file is ready to start reading, although when you create
    a readable stream that points to a file, it will start reading the file immediately
    when it is available.
  prefs: []
  type: TYPE_NORMAL
- en: Data, as we saw with standard input, will be called by passing in the data that
    was read from the stream as a byte buffer. The buffer needs to be transformed
    into a string by either calling its `toString` method or by concatenating it with
    another string.
  prefs: []
  type: TYPE_NORMAL
- en: Close is called when all the bytes have been read, and the stream is not readable
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '`Error` is called if an error occurs while reading from the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how we can register for the events by printing
    content to the console as the events occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this application appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you know how to read a file and how to use read streams, let''s take
    a look at writable streams in more detail. You saw some of their usage in the
    previous section, since standard output is a writable stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` method is the one most frequently used in writable streams. If
    you want to create a writable stream that writes to a file, you just need to pass
    the name of the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start writing to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add the newline character at the end, otherwise everything will
    be printed in the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''re done writing to the file, you call the `end` method to close
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Writable streams also have events you can listen to. The two most important
    ones are `error` and `close`. The error event will be triggered when an error
    occurs while writing to the stream. The `close` event will be called when the
    stream is closed. There''s also the `finish` event, which will be triggered when
    the `end` method is called. The following code is the final part of the sample
    code that can be found on GitHub: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_filesystem/write_stream.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the application, you will see that it will create the `todo.txt`
    file with the expected content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating a stream that points to a file will create a stream that overwrites
    the file content by default. To create a stream to append to the file, you need
    to pass an option object with the "a" flag, as in append, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting thing about streams is that you can pipe them. This means
    that you can send all the bytes from a read stream to a write stream. You could
    easily copy the content of one file to another with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Besides reading and writing to files, the FileSystem APIs also provide methods
    so that you can list files in directories, check a file's status, watch a directory
    or file for changes, copy, delete, change file permissions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with filesystem operations, you have to remember that the operations
    are asynchronous. This means that all the operations receive a callback that gets
    called when the operation has finished. When making a directory, for example,
    you could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback receives an error argument if something goes wrong while trying
    to create a directory, for example, if the directory already exists. Running the
    code for the first time would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'But when running it for the second time, it would fail as the directory has
    already been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a file in the directory you just created, you need to
    create the file inside the callback that is passed into `mkdir`. Doing it the
    following way can fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens when you try to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s because when the call to `writeFile` happens, there''s a chance that
    the directory still doesn''t exist. The correct way to do it is to call `writeFile`
    inside the callback that''s passed into `mkdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Since dealing with the preceding asynchronous calls is complicated and not
    all cases require high-performance asynchronous operations, in the filesystem
    module, almost all operations include a synchronous version of the same API. So,
    if you wanted to make a directory and create a file with some content in it, and
    there''s nothing else your application can be doing while the directory doesn''t
    exist, you could write the code in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `Sync` word at the end of each method name. The output of the preceding
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In Node.js 10, a promise-based API was also added to the filesystem module.
    Promises and other techniques that deal with asynchronous operations will be discussed
    in further chapters, so we will skip this for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to create directories and read and write data to files,
    let''s move on to the next most frequently used filesystem operation: listing
    directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To list files in a directory, you can use the `readdir` method. The callback
    that''s passed to the function will receive an error object if something goes
    wrong when you''re trying to read the directory and a list of filenames. The following
    code will print the names of all the files in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'But sometimes, you want more than just filenames. Here, the `readdir` function
    accepts an options object, which can be provided with the `withFileTypes` flag.
    If the flag is passed, then what the callback gets, instead of filenames, is an
    array of `Dirents`, which contains some extra information about the file, such
    as if it is a directory or a file. The following example will print the filenames
    in the current directory and prepend it with a (D) or (F), depending on whether
    it is a directory or file, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The last operation of the FileSystem APIs that is important to be aware of
    is concerned with how to check the status of a file. If you just need to know
    whether a file exists and is readable, you can use the `access` function, which
    receives the path to the file and a set of status flags to check for. If the file
    state matches the specified flags, then no error will be passed to the callback.
    Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're combining two flags, `F_OK` and `R_OK`. The first checks
    whether the file exists, while the second checks whether it's readable. You can
    combine multiple flags with the `|` (or) operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the preceding code, you would see the following output if the
    file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file doesn''t exist, then you would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the file exists but is not readable, you would receive the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All of this looks interesting, but if you need to know whether a path is a file
    or a directory, when it was last modified, and so on, then you need to use the
    `lstat` function, which will return a Stats instance. Stats contains everything
    you need to know about a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example checks whether the path is a file or directory, when
    it was created and last modified, and prints that information to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Globs are path-like strings that contain parts of the path replaced by wildcards,
    represented by `*`. When you have two `*`, for example, `**`, this means any directory
    or subdirectory. A simple example is to search for all the `.txt` files in any
    subdirectory of the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 12: Searching for a File through a Directory Using Glob Pattern'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will create an application that will scan through a directory
    tree and search for files based on glob. To achieve this, we will recursively
    call the synchronous version of the `readdir` function and use the `commander`
    and the `glob-to-regexp` modules to help us with processing the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In an empty directory, start a new application using `npm` `init` and add an
    `index.js` file, which will be our entry point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the two external modules that we will be using: `commander` and `glob-to-regexp`.
    For that, execute the `npm install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `index.js` file, using your favorite editor, import all the necessary
    modules for this project at the beginning of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We are already aware of the `fs` and commander modules. The `globToRegExp` module
    and `join` function will be explained in the upcoming steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the `counter` and `found` variables. These will be used to show
    some statistics relating to the search being executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the `commander` to receive the glob as the argument and an extra
    option for the user to set the initial directory to start the search from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'For this exercise, we will use a recursive function to walk through the directory
    tree. The `walkDirectory` function calls `readdirSync`, with the `withFileTypes`
    flag set to `true`. The `walkDirectory` function receives two arguments: the path
    to start reading from and the callback to be called for each file. When a directory
    is found, it is passed to the `walkDirectory` function so that the recursion continues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: When a file is found, the path is passed to the callback and the counter is
    incremented. Here, we use the `path.join` function to join the filename to the
    parent path to reconstruct the whole path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `walkDirectory` tree function, we will validate the arguments
    that have been passed to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `globToRegExp` module to transform the glob to a `RegExp`
    that can be used to test files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'With the matcher and the walk directory tree function ready, we can now walk
    the directory tree and test each file we find:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since all the code is executing synchronously, after the call to `walkDirectory`
    finishes, all the directories and subdirectories will have been processed. Now,
    we can print the statistics of what we found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4: Statistics of the files found'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Statistics of the files found'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can execute the search by starting in the parent directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Executing the search in the parent directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: Executing the search in the parent directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, you learned how to use the FileSystem APIs to traverse a directory
    tree. You also used regular expressions to filter files by name.
  prefs: []
  type: TYPE_NORMAL
- en: The FileSystem APIs provide the foundation for almost every application. Learning
    how to use them synchronously and asynchronously is fundamental for anything you
    will be doing in the backend world. In the next section, we will use these APIs
    to build a basic web server to serve files to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the beginning, Node.js was created with the objective of replacing old web
    servers that used the traditional model of one thread per connection. In the thread-per-request
    model, the server keeps a port open, and when a new connection comes in, it uses
    a thread from the pool or creates a new one to execute the work the user asked
    for. All of the operations on the server side happen synchronously, which means
    that while a file is being read from disk or a record from the database, the thread
    sleeps. The following illustration depicts this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: On the thread-per-request model, threads sleep while the I/O
    and other blocking operations happen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: On the thread-per-request model, threads sleep while the I/O and
    other blocking operations happen'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The problem with the thread-per-request model is that threads are expensive
    to create, and having them sleep while there''s more work to do means a waste
    of resources. Another issue is that when the number of threads is higher than
    the number of CPUs, they start losing their most precious value: concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of these issues, web servers that used the thread-per-request model
    would have a thread pool that''s not big enough so that the server can still respond
    to many requests in parallel. And because the number of threads is limited when
    the number of concurrent users making requests grows too much, the server runs
    out of threads and the users now have to wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/C14587_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Users have to wait for threads to become available when the number
    of concurrent requests grows'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Node.js, with its asynchronous model and the event loop, brought the idea that
    you can be more efficient if you have only one thread to execute work and move
    the blocking and I/O operations to the background, only coming back to it when
    data is available to be processed. When you have data-intensive work to be done,
    such as with web servers, which mostly read and write from files, disks, and records
    from databases, the asynchronous model becomes much more efficient. The following
    illustration depicts this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Asynchronous model with an event loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.8: Asynchronous model with an event loop'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Of course, this model is no silver bullet and, under heavy load and a high number
    of concurrent users, the amount of work on the queue will become so high that
    users will eventually start blocking each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the history of the asynchronous model and why Node.js implemented
    it, let's build a simple hello world web server. In the upcoming chapters, you
    will learn more about REST APIs and how to use some libraries to help you do some
    more advanced things. For now, we will use the http module to build a server that
    returns a "hello world" string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an HTTP server, you can use the `createServer` function from the
    http module. It''s as simple as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is driven by events, and the event that we''re most interested in
    is the request. This event is triggered when an HTTP client connects to the server
    and initiates a request. We can listen to this event with a callback that receives
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'request: The request the client is sending to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'response: The response object used to communicate with the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response is a writable stream, which means we already know how to send
    data to it: by calling the `write` method. But it also contains a special method
    called `writeHead`, which will send back the HTTP status code and any additional
    headers. The following is an example of how to send the hello world string back
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the server and the request handler. Now, we can start listening for
    requests on a specific port. To do that, we call the `listen` method on the server
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The code for this sample is available in GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_server.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start the hello world server by running this application, you will see
    something like this in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you open your browser and go to the specified path, you will see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Hello world web server example response'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: Hello world web server example response'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can try reaching other paths such as `http://localhost:3000/index.html`,
    for example. The result will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Hello world server always responds with Hello world'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.10: Hello world server always responds with Hello world'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you go back to the console where you''re running your server from, you will
    see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the server is receiving the path correctly from the browser.
    However, because the code doesn't handle any special case, it just returns Hello
    world. Clients always get the same result, no matter what path they request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13: Serving Static Files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have learned how to build a hello world web server that always responds with
    the same string, no matter what the client asks for. In this exercise, we're going
    to create an HTTP server that serves files from a directory. This type of server
    is called a static HTTP server since it only finds files in a directory and returns
    them to the client without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an empty directory, initialize a new npm application using the `init` command
    and add an `index.js` file to it. Also, install the `mime` package using `npm
    install`. We will use this package to determine what the content type is for the
    files we will be serving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by importing all the modules we will need for this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `fs` module to load files from disk. The http module will be
    used to create the HTTP server and handle the HTTP requests. The `mime` module
    is the one we installed in the previous step and will be used to determine the
    content type for each file. The path module is used to handle paths in a platform-independent
    way. Finally, the `url` module is used to parse URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know which files we will have to serve, we will scan the directory using
    the `walkDirectory` function from the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will pick the root directory, which can be passed as an argument.
    Otherwise, we will just assume it is the directory from where we''re running the
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can scan the directory tree and store the path to all files in a `Set`,
    which will make the process of checking the availability of the file quicker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'With the list of files ready to serve, we will create the HTTP server instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the request handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the handler function, parse what the user is requesting to a URL. For
    this, we will use the url module and, from the parsed URL, we will fetch the pathname
    that points to the file the client wants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'With the path to the file, we will check whether the file is in the list we
    collected before and, if not, respond with a 404 (not found) error message, log
    the result of the request, and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file is in the `Set`, we will use the path module to extract its extension
    and resolve the content type using the `mime` module. Then, we will respond with
    a 200 (ok) error message, create a read stream to the file, and pipe it to the
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the handler function. After that, we can start the server by
    picking a port, letting the user know what that is, and calling what to listen
    to the method in the http server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start the server by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'From another Terminal window, we can use the command-line HTTP client curl
    to call our server and see the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do the same from the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Static index.js served from our HTTP server as viewed from the
    browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: Static index.js served from our HTTP server as viewed from the
    browser'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also try this with a file that doesn''t exist to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'From the browser, the 404 response looks like an error page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: The server responds with a 404 error when asked for a file that
    doesn''t exist'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12: The server responds with a 404 error when asked for a file that
    doesn''t exist'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'On the Terminal where you''re running the server, you can see that it prints
    information about what''s being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: With just a few lines of code, you were able to build an HTTP server that serves
    static content.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP server is one of the fundamental components of the internet. Node.js
    makes it simple to build powerful servers. In this exercise, with just a few lines
    of code, we have built a static HTTP server. In the rest of this section, we will
    learn how to build a dynamic server that can generate HTML using templates and
    data that have passed in the request and also loaded from other data sources,
    such as a JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to building a dynamic HTTP server, let''s take a look at
    the HTTP client APIs that are available in Node.js. To test the HTTP client APIs,
    we will be using HTTP Bin, a free service that can be used to test HTTP requests.
    You can read more about it here: [https://httpbin.org](https://httpbin.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming chapters, you will learn about what each HTTP method means,
    but for now, we will just explore two of them: GET and POST. HTTP GET is what
    we have been using until now. It tells the server: "Go get this URL for me." HTTP
    POST means: "Store this content at this URL for me." In the static server we built
    in the previous exercise, it was a real path to a real file on disk. But it can
    be used in whatever way the server sees fit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Node.js to execute a GET request to the `httpbin` API. The HTTP
    client module lives in the same module as the server since it uses a lot of the
    same constructs. Therefore, we have to require the http module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Since GET is such a widely used HTTP method, the http module has an alias for
    it. We can execute GET by calling the `get` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` function receives the URL and a callback, which will be called and
    passed to the response as soon as the server starts sending it. The response that''s
    passed to the callback is a readable stream that we can get data from by listening
    to the data event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The data here is the body of the response. If we just print it to the console,
    we will see the response in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request instance that''s returned by the `get` method is a writable stream.
    To tell the server that we''re done with the request, we need to call the `end`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is some sample output from the preceding code, which can be found
    on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: You can see that it printed the response body to the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you need to send some extra headers or use HTTP basic authentication.
    For that, the `get` method accepts an `options` object, where you can set headers,
    basic authentication, and so on. The following is a sample options object where
    a custom header and basic authentication have been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you pass the options object before the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet is the output of preceding code, which is also available
    on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_get_with_headers.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '`httpbin` responds with all the information that we passed in our request.
    You can see that there are two extra headers now, Test and Authorization, with
    the values we specified. The authorization header is base64-encoded, as specified
    in the Basic Authentication spec.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, the get method is just an alias. The request method
    is the more flexible version of it and can be used to execute an HTTP POST request.
    Even though it is more flexible, the request method receives the same arguments:
    `url`, `options`, and `callback`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the HTTP method to be executed, we set it in the options object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the request function, instead of the get function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to post data to the server, you can use the request object we created.
    Remember that it is a writable stream, so we can write the content directly to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''re done writing the data to the request, call the `end` method and
    the request is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Some sample code that uses the write and `end` methods we explained previously
    is available on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_http/http_client_post.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the http module automatically sets the Content-Length header,
    based on the amount of data you sent. You can also see that the data attribute
    is set on the response, indicating the data that the server received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14: Serving Dynamic Content'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will be rewriting the storefront from the previous chapter.
    But now, the content will be served dynamically, and the HTML will be generated
    on the server side. For that, we will have an array of products stored in a JSON
    file, which will be loaded and used to generate an HTML file to return to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways of generating HTML to send to clients: concatenating strings,
    search and replace, template strings, and even a library such as cheerio could
    be used. Templating is, in general, the easiest since you can store the template
    in a separate file that can be written just like a normal HTML file but with some
    placeholders. For this exercise, we will use the handlebars templating library
    to do the hard work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new npm package with an `index.js` file in it. Install the two external
    packages that we will use in this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The handlebars package is a template engine. It can be used to render template
    text with placeholders and some basic logic, such as for loops and if/else statements.
    We will also be using the `mime` package we used previously to determine the content
    type of files that are going to be served statically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Require all the modules that will be used in the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the path for static files using a base directory. That directory will
    be the static directory where the script is loaded from. We store that path in
    a variable so that we can use it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the product array from the JSON file using `readFileSync`. We
    parse the JSON using the built-in `JSON.parse` function and then print the number
    of products found to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars have a concept of helper functions. These are functions that can
    be registered and used from within your templates. To register a helper function,
    you call the `registerHelp` function, passing the name of your helper as the first
    argument and the handler function as the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a helper function that can be used to format currency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the HTTP handler and start listening to connections, we will
    use the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We registered a function called `handleRequest` with our HTTP server. This
    is the root handler, and all requests will go through it. For this application,
    we''re expecting two types of requests: the first is static requests that will
    point to css, images, and other static files, while the second is a request to
    get the storefront HTML. This means that our root handler will only care about
    these two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To request the storefront, we will assume that when the user requests `/` or
    `/index.html` (`http://localhost:3000/` or `http://localhost:3000/index.html`),
    the user is trying to access the store, also known as the base or root page of
    an application. Everything else will be considered a static resource. To handle
    these requests, we will parse the URL, check the pathname, and use an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle static files, we will prepend the path to the directory where the
    static files should come from and use that as the full path. Then, we will check
    whether the file exists and is readable using the `access` function from the filesystem
    API. If there''s an error, then return a `404` error; otherwise, just create a
    readable stream and pipe the content of the file to the response. We also want
    to use the mime library to check the content type for each file and add a header
    to the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the function to serve static files, let's use handlebars to
    serve the dynamic content. For that, we need to load the HTML template using `readFileSync`
    and then compile it. The compiled script is transformed into a function that,
    when called, returns a string of the processed template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The template function receives the context that will be used to render the
    template. The context can be accessed in the template, which will be demonstrated
    in the next step. For this application, the context will be an object with one
    attribute called `products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'With the template handling in place, we need a template. Handlebars uses double
    curly braces as placeholders (for example, `{{variable}}`), and you can execute
    a for loop using the double curly braces with a hash: `{{#arrayVariable}}`. In
    a separate `html/index.html` file, relative to the `index.js` file, add the following
    HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the helper function, currency, which is called to render the price:
    `{{currency price}}.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to call the `initialize` function at the end to start listening
    for HTTP connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: To make the storefront load and render correctly, you will also need the css
    files and images. Just put them all in a folder called **static**. You can find
    the files on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Exercise14).
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the files in place, run the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a browser window and go to `http://localhost:3000`. You should see the
    storefront:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13: Storefront served from the dynamic web server'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: Storefront served from the dynamic web server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we transformed the storefront application into a dynamic web
    application that reads data from a JSON file and renders an HTML request when
    the user requests it.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic web servers are the basis of all online applications, from Uber to Facebook.
    You can summarize the work as loading data/processing data to generate HTML. In
    *Chapter 2, Node.js and npm*, we used some simple HTML and did the processing
    in the frontend. In this exercise, you learned how to do the same work on the
    backend using a template engine. Each methodology has its pros and cons and most
    applications end up with a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: You can add filtering options to the storefront web page as an improvement.
    Let's say the users want to filter the products by tag or a combination of them.
    In your `handleProductsPage` function, you could use query parameters to filter
    the list of products you're passing to the template for rendering. See if you
    can make this improvement yourself.
  prefs: []
  type: TYPE_NORMAL
- en: What is Scraping?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we will be talking about web **scraping**.
    But what exactly is web scraping? It's the process of downloading a page and processing
    its content to execute some repetitive automated tasks that would otherwise take
    too long to do manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to get car insurance, you need to go to each insurance
    company website and get a quote. That process normally takes hours since you have
    to fill in a form, submit it, wait for them to send you an email on each website,
    compare prices, and pick the one you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: The user downloads content, types data in, submits it, and then
    wait for the results'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.14: The user downloads content, types data in, submits it, and then
    wait for the results'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So why not make a program that can do that for you? That's what web scraping
    is all about. A program downloads a page as if it were a human, scrapes information
    from it, and makes decisions based on some algorithm, and submits the necessary
    data back to the website.
  prefs: []
  type: TYPE_NORMAL
- en: When you're getting insurance for your car, it doesn't seem like automating
    would bring much value. Writing an application that does that correctly for different
    websites would take many hours – more than doing it yourself manually. But what
    if you were an insurance broker? Then you would have to do this hundreds of times
    a day, maybe more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are an insurance broker company, and if you spend your time building
    one robot (that''s what these applications are called), you will start to become
    more efficient. That''s because, for that one website, you won''t be spending
    time filling out the forms. With the efficiency that you got from building your
    first robot, you can save time and be able to build a second one, then a third
    one, and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: Robot executing the task automatically by downloading content
    and making decisions based on an algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.15: Robot executing the task automatically by downloading content
    and making decisions based on an algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Web scraping started in the early days of the internet when Yahoo! was trying
    to manually index all the websites that existed. Then, a start-up, out of two
    college students' garages, started using robots to pull the data and index everything.
    In a very short amount of time, Google became the number one search website, a
    position that only gets harder and harder for competitors to challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Web scraping is a widely used technique to extract data from websites that do
    not provide APIs, such as most insurance companies and banks. Search and indexing
    is also another very common case. Some companies use scraping to analyze a website's
    performance and grade them, such as HubSpot ([https://website.grader.com](https://website.grader.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many techniques for web scraping, depending on what goal you''re
    trying to achieve. The most basic one is to download the base HTML from a website
    and read the content from there. If you only need to download data or fill in
    a form, this might be more than enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: The basic scraping technique involves downloading and processing
    the base HTML file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.16: The basic scraping technique involves downloading and processing
    the base HTML file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But sometimes, websites use Ajax to dynamically load the content after the
    HTML has been rendered. For those cases, just downloading the HTML wouldn''t be
    enough since it would just be an empty template. To solve that, you can use a
    headless browser, which works like a browser, parsing all HTML, downloading and
    parsing the related files (CSS, JavaScript, and so on), rendering everything together,
    and executing the dynamic code. That way, you can wait for the data to be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Depending on the use case, scraping requires a simulated or
    a fully headless browser to download and render the page more accurately'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.17: Depending on the use case, scraping requires a simulated or a
    fully headless browser to download and render the page more accurately'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The second technique is much slower since it requires the whole page to download,
    parse, and render. It is also much more brittle since executing the extra calls
    can fail, and waiting for JavaScript to finish processing the data can be hard
    to predict.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and Parsing Web Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's examine the simpler approach to web scraping. Suppose we wanted to follow
    the latest posts about JavaScript in Medium. We could write an application to
    download the JavaScript topic page, then search for anchors (links), and use that
    to navigate around.
  prefs: []
  type: TYPE_NORMAL
- en: To start, having a generic download function that will do some basic wrapping
    on the HTTP client is a good idea. We could use an external library, such as request,
    but let's see how we would go about wrapping that kind of logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the http module, but in this case, we will use the https version
    of it, since most websites these days will redirect you to their secure version
    if you try to reach the plain HTTP version. The https module provides the same
    APIs except it understands HTTPS protocol, which is the secure version of HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The `downloadPage` function receives a URL to download and a callback function
    that will be called after the content of the page has finished downloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside that function, we will start by making a request and ensuring that we
    are calling the end function to complete the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In the callback we pass to the get function, the first thing we will do is
    check for the response status and print an error message if it doesn''t match
    200, which is the HTTP code that means we have a successful request. We also stop
    everything by returning from the callback since the body will probably not be
    what we''re expecting if this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'After that `if` statement, we can accumulate the content of the page in a variable
    using the data event. When the connection is closed, in the `close` event, we
    call the callback function with the full content that was accumulated in the content
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The full code for this sample is available on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson03/sample_scraping/print_all_texts.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple usage of this function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This would download the page and print it to the console. But we want to do
    more, so we will use the `jsdom` library to parse the HTML and fetch some information
    from it. `jsdom` is a library that parses HTML and generates a DOM representation
    of it that can be queried and manipulated, just like the DOM in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing it using the `npm install` command, you can require it in
    your code. The module exposes a constructor that receives a string. After being
    instantiated, the `JSDOM` instance contains a window object that works exactly
    like the window object in the browser. The following is an example of using it
    to fetch all the anchors, filter out the ones that are empty, and print their
    texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the sample output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 15: Scraping Medium Articles'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will use scraping to print articles in the console. Let's
    use this knowledge to build an application that will download topic pages from
    Medium, parse the information, and print it in a consumable way. The application
    will have a hardcoded list of topics and will download the HTML for each of the
    pages. Then, it will use `jsdom` to parse the downloaded content, fetch information
    about each article, and print that in a pretty format in the console to make each
    article just a click away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder, with an `index.js` file in it. Then, run `npm init` and
    `install jsdom` using `npm install`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `index.js` file, use the require function for all the modules we will
    be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a constant array that will contain all the topics we will be downloading
    pages for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `downloadPage` function we created in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over each topic calling the `downloadPage` function for each topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we call two functions: `findArticles` and `printArticle`.
    The first will go through the DOM parsed from the page and return an object, of
    which the keys are the article titles and the values are objects containing information
    about each article.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write the `findArticles` function. We start by initializing the object,
    which will be the result of the function, and then querying the document that
    was passed in for all the anchor elements inside the H1 and H3 elements, which
    represent the title of the articles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Filter the anchors based on the fact that Medium article paths have two parts:
    `/author/articleId`. This means we can parse the `href` of the anchor as a URL,
    get the pathname, split using "/" as a separator, and ignore anyone that doesn''t
    have exactly two parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Chrome Developer Tools on the page, you can see that the title of
    the article lives inside a header element whose next sibling is a DIV that contains
    the following short description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18: The next sibling of the parent contains a short description
    of the article'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.18: The next sibling of the parent contains a short description of
    the article'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This means that for each anchor element, we can get that DIV, query for an anchor,
    and fetch its text as the description for the article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the article information in the result object using the title as the key.
    We use the title of the article as the key because that will automatically deduplicate
    articles from the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, from the `findArticles` function, we return the array containing all
    the articles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The other function we call inside the callback passed to `downloadPage` is `printArticle`.
    It is also the last piece of code to make this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `printArticle` function, which receives an article object
    and prints it to the console in a pretty way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application to print the articles to the console with the extra information
    in a nice format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19: Article printed to the console after running the application'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_03_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.19: Article printed to the console after running the application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we wrote an application that pulls data from Medium and prints
    a summary of the articles found to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Web scraping is a powerful way of fetching data when no API is available. Many
    companies use scraping to sync data between systems, to analyze the performance
    of websites, and to optimize processes that otherwise would not scale, thus blocking
    some important business needs. Understanding the concepts behind scraping allows
    you to build systems that would otherwise be impossible to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4: Scraping Products and Prices from Storefront'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 2, Node.js and npm*, we wrote some code that would fetch information
    about the products in the storefront example page. At the time, we said that the
    site wasn't going to be updated that frequently, so manually doing it from the
    Chrome Developer Console was fine. For some scenarios, this is fine, but when
    the content is dynamically generated, like in the newer version of the storefront
    that we wrote in this chapter, we might need to eliminate all manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will write an application that will scrape the storefront
    web page by downloading it using the http module and parsing it using `jsdom`.
    Then, you will extract the data from the DOM and generate a `CSV` file with the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the previous code you built or use a copy of it to serve the storefront
    website in `localhost:3000`. The code can be found on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson03/Activity04).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `npm` package, install the `jsdom` library, and create an entry
    file called `index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the entry file, call the `require()` method to load all the modules that
    are needed in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an HTTP request to `localhost:3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure a successful response and collect data from the body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the HTML using `jsdom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the product data from DOM; you will want the name, price, and unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CSV` file where the data will be written to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the product data to a `CSV` file, which is one product line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application and check the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 591.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about the global variables that are available to
    every Node.js script. We learned how to set timers and read from, and write to,
    the console. After that, we learned about streams and how to use them to read
    and write data from files. We also learned how to use the synchronous filesystem
    APIs. Then, we learned how to use the HTTP module to build web servers and scrape
    content from web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are well acquainted with the web scraping concept, you are ready
    to explore opportunities where you can build your own web applications and build
    automated robots to scrape content from other web applications. A good idea is
    to try and build a simple content management application to serve your blog, where
    you're going to write about all the new things you just learned about.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about REST APIs and use some frameworks
    to help you build them. In further chapters, you will learn about techniques you
    can use to manage asynchronous operations to make your Node.js applications powerful,
    but keep the code easy to write and maintain.
  prefs: []
  type: TYPE_NORMAL
