- en: Moving to a Global State with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a state management pattern and library. Wait, what? Let's put all of
    the technical lingo aside for this one—if you want to read the official technical
    explanation, you can do so on the official Vuex website, What is Vuex?, at [https://vuex.vuejs.org/](https://vuex.vuejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn how to set up your project using the
    global state management pattern and library, Vuex. Vuex will allow you to extract
    local state from your components into a, well, global all-knowing state. If you're
    not familiar with this type of pattern, such as React's Redux, don't worry! Keep
    reading—we're going to take baby steps.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to approach it on a what-does-that-mean-for-me level. As you probably
    know, the way that components in Vue communicate is through props from the parent
    to the children and events from the children to the parent. The children components,
    in some cases, will want to send data back to their parents. Maybe you want to
    alert the parent that something inside of it was clicked, or some piece of data
    was changed. In our previous example, our `BasicInput` and `BasicSelect` components
    `$emit` values to the parent when they change or when an input happens.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the parent component has a parent of its own and `$emits` something
    up to it as well. Sometimes, this third parent has a parent and so on. This can
    quickly become a very complex web of components that is flawlessly communicating
    with each other in perfect balance. Or so you thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'You get a call from your client: they want you to make an API call on your
    app that displays the name of the current user on the header, and they want you
    to pre-populate some fields on the form if there is a currently logged-in user.
    What do you do? Perhaps you''re thinking about making the API call on the `App.vue`
    parent component and start building a chain of props down the components that
    need it, but what would happen when that data changes on one of the children?
    Will you `$emit` the value back to the parents and create a massive chain?'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to use Vuex. Vuex will provide you with a global state that
    is not attached to any of your components directly but is accessible to all of
    them. In this chapter, we will grab our work from the previous chapter and migrate
    the whole form to Vuex. We will also make a mock API call to pull a logged-in
    user's data and pre-populate our global store with some values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Vuex to our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the mock API endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights, Vue, action!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vuelidate and Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter can be found in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Forms-with-Vue.js/tree/master/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/31l16Kg](http://bit.ly/31l16Kg)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Vuex to our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding Vuex to our project. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Terminal and run the following command to get Vuex added to the
    project as a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the library installed, we need to add it as a plugin to our
    app. Go to `main.js`, import it and add it with the following lines of code. You
    can place them after the `Vue` and `App` import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `store` variable will hold all of our global states, including our actions
    and mutations as well. We'll discuss those in more detail soon. For `store` to
    be available to the whole app, we are missing one last step. We need to inject
    the `store` variable into our `Vue` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `main.js` still, go to the configuration options for the new `Vue` instance
    and inject `store` to it as a property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Great job! Now that we have Vuex set up as a project dependency, we can almost
    dive into creating our store—there's just one more tiny thing to do before that.
    We're going to create a quick mock API endpoint for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the mock API endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To simulate that we are making an HTTP call to an API to get the details of
    our user, we need to set it up first using Mockoon. If you don't have it set up,
    check the instructions on how to install it in [Chapter 2](2f5516c2-6f66-4945-b340-645775373cea.xhtml), *A
    Form in its Simplest Form*, in the *Bringing in Axios* section of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to create a mock API endpoint. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the app and click on the Add route button in the second column. This
    will add a new route to the list in that same column. Click on it to select it
    and the pane on the right-hand side will update to show the information for this
    particular route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a532791e-c587-4e3a-9409-0d8c8eed836e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Route settings, where you can input the name of the route, leave the
    verb as GET and set the name of the endpoint as `user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f1fe164c-b3ac-4d65-b0a0-19be952aee8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go to the Body section of the panel and set up the dummy data that we
    will be returning from our call. Feel free, of course, to fill this with your
    own name and dummy information shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the dummy information will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d1fb153-5f88-447f-a538-353c8239f878.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One more thing before we start our mock server. Go to the Headers tab on the
    top of the panel, and add a new header. The left side should read Content-Type
    and the right side should read `application/json`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9bfc2033-8e96-4743-9864-482c3b02f783.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, make sure that you start the server with the green play icon on the
    toolbar. If the server was already running, click the stop button and restart
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Mockoon is a super simple but powerful tool, and, with these easy steps, we
    have a fully functional endpoint to run tests with. In the next section, we are
    going to finally dive into creating our store and, with it, the global state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the global state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with the setup, we can go back to `main.js` and start working
    on our global state.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the new `Vuex.Store` configuration, we will add a reserved property called
    `state`. `state` is a reactive object that works in a similar way to the local
    state, `data()`, so we will redefine the structure of our form here, except, since
    it's not directly tied to it now, we will rename it `user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `main.js`, go ahead and set up the following state inside the new `Vuex.Store`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why we are naming our global property that holds the user
    data as `user` instead of `form` as we had it before. First, let me clarify that
    you are free to name your state variables as best fits the needs of your application!
    However, in this case, `form` doesn't really clarify at a glance what kind of
    data we will be storing here; on the other hand, `user` is super descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice is to have the `user` property here start out as null. In
    that case, you can check whether they're already authenticated with simple `if`
    statements such as `if (!user)`. In this case, I have opted for this setup for
    clarity of the structure. Sure, in `App.vue`, the user's data will be used to
    populate a form, but in another part of our application, it may be used to display
    some of the user's data outside any type of form.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to set up your store is the first step to successfully having a
    functional global state. In the following section, we are going to add the ability
    to modify this store with mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some mutations to our store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important thing to know about Vuex is that, even though the global state
    is accessible from any of our components, we should not directly mutate or modify
    it. To modify the content of our user, we will need to create something called
    **mutations**. Mutations are methods that have one single job: to accept a value
    or payload and to commit a modification to the state. That way, Vuex can keep
    tabs on which components are making modifications to the state without it becoming
    highly chaotic!'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first mutation; we will call it `updateUser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mutation will take two parameters: the first one is `state`. Every mutation
    will always receive the state as the first parameter; it is injected to mutations
    by Vuex by default. The second parameter will be the value that that mutation
    will get when you call it—in this case, we will call it `user` since that is what
    we will pass down to it. It is important to know that mutations *cannot* execute
    asynchronous code. Every mutation needs to be synchronous because they are making
    changes to our state directly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new property inside the `Vuex.Store` configuration called `mutations`
    and then add our following new mutation to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When this mutation is committed, it will update the global state by calling
    `state.user = user` with the user that we pass through it. Now, where exactly
    do we want to commit this new mutation?
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we set up an API endpoint to fetch our mock *logged-in* user. We still
    have to set up a call to this endpoint so that our application can use it when
    it starts to check whether there is a user from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Lights, Vue, actions!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third key part of Vuex is called **actions**. Actions are methods, just
    as mutations are, but they can perform asynchronous code within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions receive two parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a `context`, which is an object that holds a reference to the
    state, the getters, and the ability to commit mutations and dispatch other actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second (optional) parameter is user-defined; means that we can send extra
    information to our actions if we need it, but this can also be safely ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common pattern in Vuex-powered applications is to keep HTTP calls inside Vuex
    actions—that way, they can be dispatched by any component inside the application
    if they are needed. These HTTP calls usually modify or make use of the state,
    which is very convenient since we have this all available through the `context`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the problem at hand. We need to make a call to our `/users`
    endpoint to get the user's information. We are going to create a Vuex action called
    `getLoggedInUser` that will know how to make this call for us and will automatically
    commit the information it fetches to the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be using Axios for this, make sure that we first import it to
    `main.js` at the top of the file with the other import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a property called `actions` inside the `Vuex.Store` configuration
    object; this property is also a reserved word. Inside of it, we will create our
    `getLoggedInUser` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember that Axios returns a JavaScript promise, so we will attach a `.then`
    block to our call in which we will commit our `updateUser` mutation with the data
    of the response. This data is exactly the one that we defined earlier in Mockoon
    as a JSON object. Keep in mind that a real-life application would involve a more
    intricate process for checking whether the user is, in fact, logged-in; a common
    practice would be to pass in an ID, of sorts, to the endpoint, or perhaps even
    the backend will handle the session by passing tokens back and forth. However,
    this is beyond the scope of this book, so we will keep on using this fake scenario
    for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our action ready, we need a place to dispatch it. In this
    case, we are going to assume that our app wants to check for the logged-in user
    as soon as possible, so we are going to leverage the `created()` hook inside our
    `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head to `App.vue` and add the `created` method onto the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser, refresh the page, and check your Network tab on the developer
    tools. You'll see that, as soon as the page is loaded, our Axios call to `http://localhost:3000/user`
    is being fired, and the user's data is being loaded. If you have an error, remember
    to start the server on Mockoon first!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we move onto modifying our form, let''s make a new `<TheHeader>` component
    to showcase the power of our new global state. Create a new file, `TheHeader.vue`,
    inside the `components` folder and copy the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this component, we're going to use interpolation to output `$store.state.user.firstName`,
    which, in turn, will access our global state, inside the state, and inside the
    user and look for the `firstName` property and display it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to `App.vue` and import the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to declare it inside the `components` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add our new component to the template right below the opening `<div>` element
    and check it out on the browser. You should see the name of our user being output
    directly from the global state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand both actions and mutations, we can take the difficulty
    up a notch. In the next section, we are going to incorporate our two major libraries—Vuex
    and Vuelidate.
  prefs: []
  type: TYPE_NORMAL
- en: Vuelidate and Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our form to continue to work with Vuelidate alongside Vuex, we are going
    to have to make some adjustments to how we have our data set up for two-way binding
    on our inputs. Don''t worry, we''ll take it step by step. Now that we have Vuex
    incorporated into our app, we want our form to use our global state instead of
    the local state we had in our `data() { form: {...} }` inside `App.vue`. So, we
    need to make some changes in our template to tell the two-way binding to use Vuex
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to remove all of the `v-model` statements from the inputs in our
    form. Instead, we are going to manually create our two-way bindings by setting
    up the `:value` bind and the `@input` listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new method called `updateUser`, which will receive
    two parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one will be `property` in our form that is getting updated, for example,
    `firstName` or `lastName`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter will be the `value` that this new property will receive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s start by adding this new method to our `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method will dispatch a new action that we will create in a moment called
    `updateUserData`; it will send a payload with the `property` and the `value` that
    the method got.
  prefs: []
  type: TYPE_NORMAL
- en: Let's stop for a minute and look at the second statement. Since Vuelidate will
    no longer be hooked into our local state, it is going to need us to tell it when
    to recalculate the dirty state of the input and to check for errors in validation.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `updateUser` method will be in charge of making the changes to our
    global state, we will access Vuelidate's object for this input through `$v.form[property]`
    and force `$touch()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our state will be global, we don''t need our `form: {...}` local state
    anymore, so you can go ahead and delete it. Your `data()` prop should now look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for Vuelidate to be able to access our global state, we are going
    to need to use a Vuex helper function to map it to computed properties. In this
    case, we want to use `mapState`. Imagine if you had to create a computed property
    for each one of our user properties, you would have to go down the list and create
    a lot of duplicated code that looked like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Imagine having to do this for all the properties of your form, could get tedious
    fast, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, Vuex has some handy map functions that we can leverage, so
    let''s go ahead and import `mapState` to the top of our `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a `computed` prop to our `App.vue` component and use the
    `mapState` function to map our whole state to the computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are going to pass an object to `mapState` to tell the function exactly what
    part of our whole global state we want to map to our computed properties. In this
    case, we are telling it to map everything inside the user global state to a local
    form. Since the user is an object with several child properties, it will create
    a binding for each one of them, so that when `App.vue` calls, for example, `this.form.firstName`,
    it will be found in the global state in `this.$store.state.user.firstName`. Awesome,
    right?!
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that `mapState` returns an object, so we can use the JavaScript
    ES6 spread operator here to merge the newly created into our `computed: {}` prop.
    This is incredibly handy if you want to add some more computed properties later,
    which are not mapped from Vuex.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about the spread operator, please refer to the following
    article: [https://dev.to/marinamosti/understanding-the-spread-operator-in-javascript-485j](https://dev.to/marinamosti/understanding-the-spread-operator-in-javascript-485j).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go and work on the `updateUserData` action, let''s make the `v-model`
    change that we discussed to our inputs. Remove all of the `v-model` statements,
    and replace them on each one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `:value` property will bind to our global state, that is, the one we created
    at the beginning of this chapter. The `$store` property is accessible globally
    through our application thanks to Vuex, and we can use it to access the state
    directly, even in our templates. The `@input` listeners will point directly to
    `updateUser`, set the property as a string, and pass the payload of the `$event` as
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `main.js`; we have to create the new action that our `updateUser`
    method is calling. We are going to leverage our already existing mutation, `updateUser`,
    to update one of the properties of the user. You could also refactor this into
    a mutation that specifically just updates one of the properties instead of overwriting
    the whole object. In this case, the object is very small, and the performance
    is not a concern. Add the following action to your store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On the first line of the action, we are going to make a shallow copy of our
    user state by using ES6's spread operator. It's important to keep in mind that
    the state should never be changed outside of a mutation, so if we assign the new
    property value directly to the user in our state, we would be doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the copy, we set the property to the new value and call `commit`
    on our `updateUser` mutation. Go back to your browser and reload the page; make
    sure you have the dummy Mockoon API running so that our Axios calls work and check
    out the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f665a06-5041-4f63-bb28-f51a7f653e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it! With these few changes to our application, we have successfully made
    it so that not only do we have global state ruling over our form, but we also
    leverage the flexibility and power of Vuelidate to hook into the global state
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have acquired the necessary skills to set up, create, and
    use Vuex as a global state pattern and library. You also learned how to hook up
    Vuelidate with Vuex so that your validation is directly connected to your global
    state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going for the final stretch—how to turn all of what
    we have done, and our form, into a fully schema-driven form.
  prefs: []
  type: TYPE_NORMAL
