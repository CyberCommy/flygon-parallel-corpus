- en: If, Else, and Switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the importance of memory and how it can
    be used to store data inside a computer. We spoke about how memory is reserved
    for your program using variables, and how we can include different types of information
    in our variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about how to control the flow of our program
    and how we can change what code gets executed by branching the code using control
    flow statements. Here, we''ll discuss the different types of control flow, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`If` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to check whether things are equal using the `==` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test for inequalities (that is, how to check whether one number is greater
    or smaller than another using the `>`, `>=`, `<`, `<=`, and `!=` operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using logical operators (such as not (`!`), and (`&&`), or (`||`))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Branching in more than two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `else if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first example project with Unreal Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The computer code we wrote in [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory,* went in one direction: straight down. Sometimes, we might
    want to be able to skip parts of the code. We might want the code to be able to
    branch in more than one direction. Schematically, we can represent this in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1178346-f65b-44e1-84a2-c7030d6be946.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, we want the option to not run certain lines of code under certain
    conditions. The preceding diagram is called a flowchart. According to this flowchart,
    if, and only if, we are hungry then we will go prepare a sandwich, eat it, and
    then go and rest on the couch. If we are not hungry, then there is no need to
    make a sandwich, so we will simply rest on the couch.
  prefs: []
  type: TYPE_NORMAL
- en: We'll only use flowcharts in this book sometimes, but in UE4, you can even use
    flowcharts to program your game (using something called blueprints).
  prefs: []
  type: TYPE_NORMAL
- en: This book is about C++ code, so we will always transform our flowcharts into
    actual C++ code in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the flow of your program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ultimately, what we want is the code to branch in one way under certain conditions.
    Code commands that change which line of code gets executed next are called control
    flow statements. The most basic control flow statement is the `if` statement.
    To be able to code `if` statements, we first need a way to check the value of
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: So, to start, let's introduce the `==` symbol, which is used to check the value
    of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: The == operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to check whether two things are equal in C++, we need to use not one
    but two equal signs (`==`) one after the other, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will notice that the output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, `1` means true and `0` means false. If you want the words `true` or
    `false` to appear instead of `1` and `0`, you can use the `boolalpha` stream manipulator
    in the `cout` line of code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `==` operator is a type of comparison operator. The reason why C++ uses
    `==` to check for equality and not just `=` is that we already used up the `=`
    symbol for the assignment operator! (see the *More on variables* section in [Chapter
    2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml), *Variables and Memory*). If we
    use a single `=` sign, C++ will assume that we want to overwrite `x` with `y`,
    not compare them.
  prefs: []
  type: TYPE_NORMAL
- en: Coding if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the double equals sign under our belt, let''s code the flowchart.
    The code for the preceding flowchart diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time we are using a `bool` variable! A `bool` variable either
    holds the value `true` or the value `false`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we start with a `bool` variable called `isHungry` and just set it to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we use an `if` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement acts like a guard on the block of code below it (remember
    that a block of code is a group of code encased within `{` and `}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31a956f9-de7e-4848-b059-20dade64db0d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can only read the code between `{` and `}` if `isHungry==true`.
  prefs: []
  type: TYPE_NORMAL
- en: You can only get at the code inside the curly braces when `isHungry == true`.
    Otherwise, you will be denied access and forced to skip over that entire block
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, anything that can be evaluated as a boolean can go inside `if (boolean)`.
    So, we can achieve the same effect by simply writing the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if( isHungry ) // only go here if isHungry is true` This can be used as an
    alternative for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if( isHungry == true )`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason people might use the `if( isHungry )` form is to avoid the possibility
    of making mistakes. Writing `if( isHungry = true )` by accident will set `isHungry`
    to true every time the `if` statement is hit! To avoid this possibility, we can
    just write `if( isHungry )` instead. Alternatively, some (wise) people use what
    are called Yoda conditions to check an `if` statement: `if( true == isHungry )`.
    The reason we write the `if` statement in this way is that, if we accidentally
    write `if( true = isHungry )`, this will generate a compiler error, catching the
    mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running this code segment to see what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output of the preceding lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The line of code that has `(x = y)` overwrites the previous value of `x` (which
    was 4) with the value of `y` (which is 5). Although we were trying to check whether
    `x` equals `y`, what happened in the previous statement was that `x` was assigned
    the value of `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding else statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `else` statement is used to have our code do something in the case that
    the `if` portion of the code does not run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have something else that we''d like to do in case we are
    not hungry, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few important things that you need to remember about the `else`
    keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An `else` statement must always immediately follow after an `if` statement.
    You can't have any extra lines of code between the end of the `if` block and the
    corresponding `else` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A program can never execute both the `if` and the corresponding `else` block.
    It''s always one or the other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3676e502-fcb4-404c-b163-9fc5bb354f97.png)'
  prefs: []
  type: TYPE_IMG
- en: The else statement is the way you will go if `isHungry` is not equal to true.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the `if`/`else` statements as a guard diverting people to either
    the left or the right. Each person will either go toward the food (when `isHungry==true`),
    or they will go away from the food (when `isHungry==false`).
  prefs: []
  type: TYPE_NORMAL
- en: Testing for inequalities using other comparison operators (>, >=, <, <=, and
    !=)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other logical comparisons can be easily done in C++. The `>` and `<` symbols
    mean just what they do in math. They are the greater than (`>`) and less than
    (`<`) symbols. `>=` has the same meaning as the `≥` symbol in math. `<=` is the
    C++ code for `≤`. Since there isn''t a `≤` symbol on the keyboard, we have to
    write it using two characters in C++. `!=` is how we say *"not equal to"* in C++.
    So, for example, say we have the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can ask the computer whether `x > y` or `x < y`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We need the brackets around the comparisons of `x` and `y` because of something
    known as operator precedence. If we don't have the brackets, C++ will get confused
    between the `<<` and `<` operators. It's weird and you will better understand
    this later, but you need C++ to evaluate the `(x < y)` comparison before you output
    the result (<<). There is an excellent table available for reference at [http://en.cppreference.com/w/cpp/language/operator_precedence](http://en.cppreference.com/w/cpp/language/operator_precedence).
  prefs: []
  type: TYPE_NORMAL
- en: Using logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logical operators allow you to do more complex checks, rather than checking
    for a simple equality or inequality. Say, for example, the condition to gain entry
    into a special room requires the player to have both the red and green keycards.
    We want to check whether two conditions hold true at the same time. To do this
    type of complex logic statement check there are three additional constructs that
    we need to learn: the not (`!`), and (`&&`), and or (`||`) operators.'
  prefs: []
  type: TYPE_NORMAL
- en: The not (!) operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `!` operator is handy to reverse the value of a `boolean` variable. Take
    the example of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement here checks whether or not you are wearing socks. Then, you
    are issued a command to get some socks on. The `!` operator reverses the value
    of whatever is in the `boolean` variable to be the opposite value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use something called a truth table to show all the possible results of using
    the `!` operator on a `boolean` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `wearingSocks` | `!wearingSocks` |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `false` | `true` |'
  prefs: []
  type: TYPE_TB
- en: So, when `wearingSocks` has the value `true`, `!wearingSocks` has the value
    `false` and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do you think will be the value of `!!wearingSocks` when the value of `wearingSocks`
    is `true`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value of `isVisible` after the following code is run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If `wearingSocks` is `true`, then `!wearingSocks` is `false`. Therefore, `!!wearingSocks`
    becomes `true` again. It's like saying "I am not not hungry." Not not is a double
    negative, so this sentence means that I am actually hungry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The answer to the second question is `false`. The value of `hidden` was `true`,
    so `!hidden` is `false`. The `false` value then gets saved into the `isVisible`
    variable. But the value of `hidden` itself remains `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `!` operator is sometimes colloquially known as a bang. The preceding bang-bang
    operation (`!!`) is a double negative and a double logical inversion. If you bang-bang
    a `bool` variable, there is no net change to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can use these on an `int` and in that case, if the `int` is set
    to zero, `! int` will be `true`, and if it is greater than zero, `! int` will
    be `false`. Therefore, if you bang-bang that `int` variable, and the `int` value
    is greater than zero, it is reduced to a simple `true`. If the `int` value is
    0 already, it is reduced to a simple `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The and (&&) operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say we only want to run a section of the code if two conditions are `true`.
    For example, we are only dressed if we are wearing both socks and clothes. You
    can use the following code to check this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The or (||) operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We sometimes want to run a section of the code if either one of the variables
    is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, say the player wins a certain bonus if they find either a
    special star in the level or the time that they take to complete the level is
    less than 60 seconds. In this case, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that I added parentheses around `levelCompleteTime < maxTimeForBonus`.
    While precedence rules may let you add longer statements without them, I've found
    it can be better to just add them if you have any doubt. It's better safe than
    sorry (and may be a little clearer to someone else looking at it later).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have noticed that the best way to get better at programming
    is by doing it. You have to practice programming a lot to get significantly better
    at it.
  prefs: []
  type: TYPE_NORMAL
- en: Create two integer variables, called `x` and `y`, and read them in from the
    user. Write an `if`/`else` statement pair that prints the name of the bigger-valued
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to the preceding exercise is shown in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Don't type a letter when `cin` expects a number. If that happens, `cin` can
    fail and give a bad value to your variable.
  prefs: []
  type: TYPE_NORMAL
- en: Branching code in more than two ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we were only able to make the code branch in one
    of the two ways. In pseudocode, we had the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pseudocode is *fake code*. Writing pseudocode is a great way to brainstorm and
    plan out your code, especially if you are not quite used to C++.
  prefs: []
  type: TYPE_NORMAL
- en: This code is a little bit like a metaphorical fork in the road, with only one
    of two directions to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to branch the code in more than just two directions.
    We might want the code to branch in three ways, or even more. For example, say
    the direction in which the code goes depends on what item the player is currently
    holding. The player can be holding one of three different items: a coin, key,
    or sand dollar. And C++ allows that! In fact, in C++, you can branch in any number
    of directions that you wish.'
  prefs: []
  type: TYPE_NORMAL
- en: The else if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `else if` statement is a way to code in more than just two possible branch
    directions. In the following code example, the code will go in one of the three
    different ways, depending on whether the player is holding the `Coin`, `Key`,
    or `Sanddollar` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code only goes in one of the three separate ways! In
    an `if`, `else`, and `else if` series of checks, we will only ever go into one
    of the blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee886ad0-ece1-421b-a109-35e91255f97f.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use a C++ program to answer the questions that follow the code. Be sure to
    try these exercises in order to gain fluency with these equality operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Write some new lines of code at the spot that says (`// *** Write new...`):'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether `x` and `y` are equal. If they are equal, print `x and y are equal`.
    Otherwise, print `x and y are not equal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An exercise on inequalities: check whether `x` is greater than `y`. If it is,
    print `x is greater than y`. Otherwise, print `y is greater than x`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To evaluate equality, insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To check which value is greater, insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The switch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switch` statement allows your code to branch in multiple ways. What the
    `switch` statement will do is look at the value of a variable, and depending on
    its value, the code will go in a different direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also see the `enum` construct here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Switches are like coin sorters. When you drop a 25-cent coin into a coin sorter,
    it finds its way into the 25-cent coin pile. Similarly, a `switch` statement will
    simply allow the code to jump down to the appropriate section. The example of
    sorting coins is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d32684e2-0719-4159-af5b-c8cf73d1773d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code inside the `switch` statement will continue to run (line by line)
    until the `break;` statement is hit. The `break` statement jumps you out of the
    `switch` statement. If you leave out the `break;` statements, it will continue
    to run the code inside the next case statement and won''t stop until it either
    hits a `break;` or the end of the `switch`. If you want to experiment, try taking
    out all the `break;` statements and see what happens! Take a look at the following
    diagram to understand how the `switch` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/313c6aed-604d-4a6d-a39f-ab1684cd5561.png)'
  prefs: []
  type: TYPE_IMG
- en: First, the `Food` variable is inspected. What value does it have? In this case,
    it has `Fish` inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `switch` command jumps down to the correct case label. (If there is no matching
    case label, `switch` will just be skipped).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `cout` statement is run, and `Here fishy fishy fishy` appears on the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After inspecting the variable and printing the user response, the `break` statement
    is hit. This makes us stop running lines of code in the `switch` and exit the
    `switch`. The next line of code that is run is just what would otherwise have
    been the next line of code in the program if the `switch` had not been there at
    all (after the closing curly brace of the `switch` statement). It is the `return
    0` that exits the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The switch statement versus the if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switches are like the `if` / `else if` / `else` chains from earlier. However,
    switches can generate code faster than `if` / `else if` / `else if` / `else` chains.
    Intuitively, switches only jump to the appropriate section of the code to execute.
    An `if` / `else if` / `else` chain might involve more complicated comparisons
    (including logical comparisons), which might take more CPU time. The main reason
    you will use `if` statements is if you are trying to check something that's more
    complicated than just comparing something in a specific set of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of an `enum` is really an `int`. To verify this, print the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cout << "Fish=" << Fish <<'
  prefs: []
  type: TYPE_NORMAL
- en: '" Bread=" << Bread <<'
  prefs: []
  type: TYPE_NORMAL
- en: '" Apple=" << Apple <<`'
  prefs: []
  type: TYPE_NORMAL
- en: '` "Orange=" << Orange << endl;`'
  prefs: []
  type: TYPE_NORMAL
- en: You will see the integer values of the `enum`—just so you know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, programmers want to group multiple values under the same switch
    `case` label. Say we have an `enum` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A programmer wants to group all the greens together, so they write a `switch`
    statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `Zucchini` falls through and executes the same code as `Broccoli`.
  prefs: []
  type: TYPE_NORMAL
- en: The non-green vegetables are in the `default` case label. To prevent a fall-through,
    you have to remember to insert an explicit `break` statement after each `case`
    label.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write another version of the same switch that does not let Zucchini
    fall through, by the explicit use of the `break` keyword in the switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is good programming practice to `break` the `default` case as well,
    even though it is the last case listed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complete the following program, which has an `enum` object with a series of
    mounts to choose from. Write a `switch` statement that prints the following messages
    for the mount selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Horse` | The steed is valiant and mighty. |'
  prefs: []
  type: TYPE_TB
- en: '| `Mare` | This mare is white and beautiful. |'
  prefs: []
  type: TYPE_TB
- en: '| `Mule` | You are given a mule to ride. You resent that. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sheep` | Baa! The sheep can barely support your weight. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chocobo` | Chocobo! |'
  prefs: []
  type: TYPE_TB
- en: Remember, an `enum` object is really an `int` statement. The first entry in
    an `enum` object is by default `0`, but you can give the `enum` object any starting
    value you wish using the `=` operator. Subsequent values in the `enum` object
    are `ints` arranged in order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to the preceding exercise is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Bit-shifted enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common thing to do in an `enum` object is to assign a bit-shifted value to
    each entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The bit-shifted values should be able to combine the window properties. This
    is how the assignment will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking which `WindowProperties` have been set involves a check using `bitwise
    AND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Bit-shifting is a technique that is slightly beyond the scope of this book,
    but I've included this tip just so you know about it.
  prefs: []
  type: TYPE_NORMAL
- en: Our first example with Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to get started with Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of warning: when you open your first Unreal project, you will find that
    the code looks very complicated. Don''t get discouraged. Simply focus on the highlighted
    parts. Throughout your career as a programmer, you will often have to deal with
    very large code bases containing sections that you do not understand. However,
    focusing on the parts that you do understand will make this section productive.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to download the launcher to install the engine. Go to [https://www.unrealengine.com/en-US/what-is-unreal-engine-4](https://www.unrealengine.com/en-US/what-is-unreal-engine-4)
    and when you click Get Started Now or Download, you will have to create a free
    account before you can download the launcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the launcher, open the Epic Games Launcher app. Select
    Launch Unreal Engine 4.20.X (there will probably be a new version by the time
    you read this), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04daefd6-113d-4bca-b666-9978e61e8f50.png)'
  prefs: []
  type: TYPE_IMG
- en: If you don't have the engine installed, you need to go to the Unreal Engine
    tab and download an engine (~7 GB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the engine is launched (which might take a few seconds), you will be in
    the Unreal Project Browser screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f95b850-6c0b-4430-8406-180d2d8c046c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, select the New Project tab in the UE4 project browser. Choose the C++ tab
    and select the Puzzle project. This is one of the simpler projects that doesn't
    have too much code, so it's good to start with. We'll move on to the 3D projects
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things to make a note of in this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure you're in the New Project tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you click on Puzzle, make sure that it is the one in the C++ tab, not the Blueprint
    tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter a name for your project, `Puzzle`, in the Name box (this is important
    for the example code I will give you to work on later).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change the storage folder (such as to a different drive), click
    the ... button next to the folder so that the browse window appears. Then, find
    the directory where you want to store your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you've done all this, select Create Project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: if it tells you it can''t create the project because you do not have
    the Windows 8.1 SDK installed, you can download it from [https://developer.microsoft.com/en-us/windows/downloads/sdk-archive](https://developer.microsoft.com/en-us/windows/downloads/sdk-archive).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2017 will open with the code of your project, as well as the
    Unreal Editor, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f96d5d-3788-4084-af56-7b2642074bb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks complicated? Oh boy, it sure is! We'll explore some of the functionality
    in the toolbars at the side later. For now, just select Play, as shown in the
    preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This launches the game. This is how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8243275-3064-4ce4-a989-5047adb97709.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, try clicking on the blocks. As soon as you click on a block, it turns orange,
    and this increases your score. You can end your play session by clicking Stop
    or hitting *Esc* on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to do is find the section that does this and change the behavior
    a little.
  prefs: []
  type: TYPE_NORMAL
- en: Find and open the `PuzzleBlock.cpp` file. Look for PuzzleBlock under C++ Classes
    | Puzzle and double-click it to open it in your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, the list of files in the project is located inside the Solution
    Explorer. If your Solution Explorer is hidden, simply click on View/Solution Explorer
    from the menu at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this file, scroll down to the bottom, where you''ll find a section that
    begins with the following words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`APuzzleBlock` is the class name (we''ll get into classes later), and `BlockClicked`
    is the function name. Whenever a puzzle block gets clicked on, the section of
    code from the starting `{` to the ending `}` is run. Hopefully, exactly how this
    happens will make more sense later.'
  prefs: []
  type: TYPE_NORMAL
- en: It's kind of like an `if` statement in a way. If a puzzle piece is clicked on,
    then this group of the code is run for that puzzle piece.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to walk through the steps to make the blocks flip colors when they
    are clicked on (so, a second click will change the color of the block from orange
    back to blue).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps with the utmost care:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PuzzleBlock.h` file. After the line which has this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `PuzzleBlock.cpp` file. Look for the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In `PuzzleBlock.cpp`, replace the contents of the void `APuzzleBlock::BlockClicked`
    section of code with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Only replace inside the `void APuzzleBlock::BlockClicked(UPrimitiveComponent*
    ClickedComp, FKey ButtonClicked)`statement.
  prefs: []
  type: TYPE_NORMAL
- en: Do not replace the line that starts with `void APuzzleBlock::BlockClicked`.
    You might get an error (if you haven't named your project `Puzzle`). If so, you
    can start over by creating a new project with the correct name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press Play to see your changes in action! So, let''s analyze this. This is
    the first line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This line of code simply flips the value of `bIsActive`. The `bIsActive` variable
    is a `bool` variable (it is created in `APuzzleBlock.h`), which keeps track of
    whether or not the block is active and should be displayed in orange. It's like
    flipping a switch. If `bIsActive` is `true`, `!bIsActive` will be `false`. So,
    whenever this line of code is hit (which happens with a click on any block), the
    `bIsActive` value is reversed (from `true` to `false` or from `false` to `true`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the next block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are simply changing the block color. If `bIsActive` is `true`, then the block
    becomes orange. Otherwise, the block turns blue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to branch the code. Branching makes it possible
    for the code to go in a different direction instead of going straight down.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to a different kind of control flow statement
    that will allow you to go back and repeat a line of code a certain number of times.
    The sections of code that repeat will be called loops.
  prefs: []
  type: TYPE_NORMAL
