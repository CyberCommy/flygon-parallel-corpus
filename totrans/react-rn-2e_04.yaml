- en: Event Handling, the React Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The focus of this chapter is event handling. React has a unique approach to
    handling events: declaring event handlers in JSX. I''ll get things going by looking
    at how event handlers for particular elements are declared in JSX. Then, you''ll
    learn about binding handler context and parameter values. Next, we''ll implement
    inline and higher-order event handler functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Then you'll learn how React actually maps event handlers to DOM elements under
    the hood. Finally, you'll learn about the synthetic events that React passes to
    event handler functions, and how they're pooled for performance purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The differentiating factor with event handling in React components is that it's
    **declarative**. Contrast this with something like jQuery, where you have to write
    imperative code that selects the relevant DOM elements and attaches event handler
    functions to them.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage with the declarative approach to event handlers in JSX markup
    is that they're part of the UI structure. Not having to track down code that assigns
    event handlers is mentally liberating.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll write a basic event handler, so you can get a feel for
    the declarative event handling syntax found in React applications. Then, you'll
    learn how to use generic event handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at a basic component that declares an event handler for
    the click event of an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The event handler function, `this.onClick()`, is passed to the `onClick` property
    of the `<button>` element. By looking at this markup, it's clear what code is
    going to run when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the official React documentation for the full list of supported event property
    names: [https://facebook.github.io/react/docs/](https://facebook.github.io/react/docs/).'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What I really like about the declarative event handler syntax is that it''s
    easy to read when there''s more than one handler assigned to an element. Sometimes,
    for example, there are two or three handlers for an element. Imperative code is
    difficult to work with for a single event handler, let alone several of them.
    When an element needs more handlers, it''s just another JSX attribute. This scales
    well from a code maintainability perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `<input>` element could have several more event handlers, and the code
    would be just as readable.
  prefs: []
  type: TYPE_NORMAL
- en: As you keep adding more event handlers to your components, you'll notice that
    a lot of them do the same thing. Next, you'll learn how to share generic handler
    functions across components.
  prefs: []
  type: TYPE_NORMAL
- en: Importing generic handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any React application is likely going to share the same event handling logic
    for different components. For example, in response to a button click, the component
    should sort a list of items. It''s these types of generic behaviors that belong
    in their own modules so that several components can share them. Let''s implement
    a component that uses a generic event handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through what's going on here, starting with the imports. You're importing
    a function called `reverse()`. This is the generic event handler function that
    you're using with your `<button>` element. When it's clicked, the list should
    reverse its order.
  prefs: []
  type: TYPE_NORMAL
- en: The `onReverseClick` method actually calls the generic `reverse()` function.
    It is created using `bind()` to bind the context of the generic function to this
    component instance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, looking at the JSX markup, you can see that the `onReverseClick()`
    function is used as the handler for the button click.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does this work, exactly? You have a generic function that somehow changes
    the state of this component because you bound context to it? Well, pretty much,
    yes, that''s it. Let''s look at the generic function implementation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function depends on a `this.state` property and an `items` array within
    the state. The key is that the state is generic; an application could have many
    components with an `items` array in its state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our rendered list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3f3ca9fb-eafe-488e-97a6-b4aac6401ce6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, clicking the button causes the list to sort, using your generic
    `reverse()` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/79b751c3-0cb7-40ee-8d7f-3d4cc5138f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, you'll learn how to bind the context and the argument values of event
    handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Event handler context and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn about React components that bind their event handler
    contexts and how you can pass data into event handlers. Having the right context
    is important for React event handler functions, because they usually need access
    to component properties or state. Being able to parameterize event handlers is
    also important, because they don't pull data out of DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting component data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you''ll learn about scenarios where the handler needs access
    to component properties, as well as argument values. You''ll render a custom list
    component that has a click event handler for each item in the list. The component
    is passed an array of values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each item in the list has an `id` property, used to identify the item. You''ll
    need to be able to access this ID when the item is clicked in the UI so that the
    event handler can work with the item. Here''s what the `MyList` component implementation
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the rendered list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fd1f7b83-a034-431c-a345-6ccda04e2066.png)'
  prefs: []
  type: TYPE_IMG
- en: You have to bind the event handler context, which is done in the constructor.
    If you look at the `onClick()` event handler, you can see that it needs access
    to the component so that it can look up the clicked item in `this.props.items`.
    Also, the `onClick()` handler is expecting an `id` parameter. If you take a look
    at the JSX content of this component, you can see that calling `bind()` supplies
    the argument value for each item in the list. This means that when the handler
    is called in response to a click event, the `id` of the item is already provided.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to parameterized event handling is quite different from prior
    approaches. For example, I used to rely on getting parameter data from the DOM
    element itself. This works well when you only need one event handler, and it can
    extract the data it needs from the event argument. This approach also doesn't
    require setting up several new functions by iterating over a collection and calling
    `bind()`.
  prefs: []
  type: TYPE_NORMAL
- en: And therein lies the trade-off. React applications avoid touching the DOM, because
    the DOM is really just a render target for React components. If you can write
    code that doesn't introduce explicit dependencies to DOM elements, your code will
    be portable. This is what you've accomplished with the event handler in this example.
  prefs: []
  type: TYPE_NORMAL
- en: If you're concerned about the performance implications of creating a new function
    for every item in a collection, don't be. You're not going to render thousands
    of items on the page at a time. Benchmark your code, and if it turns out that
    `bind()` calls on your React event handlers are the slowest part, then you probably
    have a really fast application.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **higher-order function** is a function that returns a new function. Sometimes,
    higher-order functions take functions as arguments too. In the preceding example,
    you used `bind()` to bind the context and argument values of your event handler
    functions. Higher-order functions that return event handler functions are another
    technique. The main advantage of this technique is that you don''t call `bind()`
    several times. Instead, you just call the function where you want to bind parameters
    to the function. Let''s look at an example component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders three buttons and has three pieces of state—a counter
    for each button. The `onClick()` function is automatically bound to the component
    context because it''s defined as an arrow function. It takes a `name` argument
    and returns a new function. The function that is returned uses this `name` value
    when called. It uses computed property syntax (variables inside `[]`) to increment
    the state value for the given name. Here''s what that component content looks
    like after each button has been clicked a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/41bea184-c17d-446a-b4e5-17fbdf0c91cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Inline event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The typical approach to assigning handler functions to JSX properties is to
    use a **named** function. However, sometimes you might want to use an **inline**
    function. This is done by assigning an **arrow** function directly to the event
    property in the JSX markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main use of inlining event handlers like this is when you have a static
    parameter value that you want to pass to another function. In this example, you're
    calling `console.log()` with the string `clicked`. You could have set up a special
    function for this purpose outside of the JSX markup by creating a new function
    using `bind()`, or by using a higher-order function. But then you would have to
    think of yet another name for yet another function. Inlining is just easier sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: Binding handlers to elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you assign an event handler function to an element in JSX, React doesn''t
    actually attach an event listener to the underlying DOM element. Instead, it adds
    the function to an internal mapping of functions. There''s a single event listener
    on the document for the page. As events bubble up through the DOM tree to the
    document, the React handler checks to see whether any components have matching
    handlers. The process is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dd1ebd5b-d2b9-49e7-ba39-38152fd442b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Why does React go to all of this trouble, you might ask? It's the same principle
    that I've been covering for the past few chapters; keep the declarative UI structures
    separated from the DOM as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a new component is rendered, its event handler functions are
    simply added to the internal mapping maintained by React. When an event is triggered
    and it hits the `document` object, React maps the event to the handlers. If a
    match is found, it calls the handler. Finally, when the React component is removed,
    the handler is simply removed from the list of handlers.
  prefs: []
  type: TYPE_NORMAL
- en: None of these DOM operations actually touch the DOM. It's all abstracted by
    a single event listener. This is good for performance and the overall architecture
    (keep the render target separate from the application code).
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic event objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you attach an event handler function to a DOM element using the native
    `addEventListener()` function, the callback will get an event argument passed
    to it. Event handler functions in React are also passed an event argument, but
    it's not the standard `Event` instance. It's called `SyntheticEvent`, and it's
    a simple wrapper for native event instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Synthetic events serve two purposes in React:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a consistent event interface, normalizing browser inconsistencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synthetic events contain information that's necessary for propagation to work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an illustration of the synthetic event in the context of a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/78ee36b3-8721-44a7-8be9-3bb2a2240db4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you'll see how these synthetic events are pooled for performance
    reasons and the implications of this for asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Event pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One challenge with wrapping native event instances is that this can cause performance
    issues. Every synthetic event wrapper that's created will also need to be garbage
    collected at some point, which can be expensive in terms of CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: When the garbage collector is running, none of your JavaScript code is able
    to run. This is why it's important to be memory efficient; frequent garbage collection
    means less CPU time for code that responds to user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your application only handles a few events, this wouldn't matter
    much. But even by modest standards, applications respond to many events, even
    if the handlers don't actually do anything with them. This is problematic if React
    constantly has to allocate new synthetic event instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'React deals with this problem by allocating a **synthetic instance pool**.
    Whenever an event is triggered, it takes an instance from the pool and populates
    its properties. When the event handler has finished running, the synthetic event
    instance is released back into the pool, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d3773e6e-17f6-44b0-a5f8-37103058ff30.png)'
  prefs: []
  type: TYPE_IMG
- en: This prevents the garbage collector from running frequently when a lot of events
    are triggered. The pool keeps a reference to the synthetic event instances, so
    they're never eligible for garbage collection. React never has to allocate new
    instances either.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one gotcha that you need to be aware of. It involves accessing
    the synthetic event instances from asynchronous code in your event handlers. This
    is an issue because, as soon as the handler has finished running, the instance
    goes back into the pool. When it goes back into the pool, all of its properties
    are cleared. Here''s an example that shows how this can go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second call to  `console.log()` is attempting to access a synthetic event
    property from an asynchronous callback that doesn't run until the event handler
    completes, which causes the event to empty its properties. This results in a warning
    and an `undefined` value.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this example is to illustrate how things can break when you write
    asynchronous code that interacts with events. Just don't do it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to event handling in React. The key differentiator
    between React and other approaches to event handling is that handlers are declared
    in JSX markup. This makes tracking down which elements handle which events much
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that having multiple event handlers on a single element is a matter
    of adding new JSX properties. Next, you learned that it's a good idea to share
    event handling functions that handle generic behavior. Context can be important
    for event handler functions, if they need access to component properties or state.
    You learned about the various ways to bind event handler function context, and
    parameter values. These include calling `bind()` and using higher-order event
    handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about inline event handler functions and their potential use,
    as well as how React actually binds a single DOM event handler to the document
    object. Synthetic events are an abstraction that wraps the native event, and you
    learned why they're necessary and how they're pooled for efficient memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to create components that are reusable
    for a variety purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes event handlers in React declarative?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any event handler function is declarative
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React event handlers are declared as part of the component JSX
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React event handlers aren't declarative
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a common use of higher-order event handler functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you have several components that handle the same event, you can use a higher-order
    function to bind the ID of the item being clicked to the handler function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Higher-order functions should be used wherever possible as React event handler
    functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you're not sure what data you'll need in the event handler, higher-order
    functions allow you to pass whatever you need
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you pass inline functions to event properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. This is preferable when event handlers are simple one-liners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. You should always declare event handler functions as methods or bound functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does React use pools of event instances instead of creating new instances
    with each event?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React doesn't use event pools
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if it didn't, you would run out of memory eventually because these objects
    are never deleted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid invoking the garbage collector to delete unused event instances when
    lots of events are fired in a small amount of time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/handling-events.html](https://reactjs.org/docs/handling-events.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
