- en: Sorting and Searching Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the algorithms that are used for sorting and
    searching. This is an important class of algorithms that can be used on their
    own or can become the foundation for more complex algorithms (presented in the
    later chapters of this book). This chapter starts by presenting different types
    of sorting algorithms. It compares the performance of various approaches to designing
    a sorting algorithm. Then, some searching algorithms are presented in detail.
    Finally, a practical example of the sorting and searching algorithms presented
    in this chapter is explored.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand the various algorithms
    that are used for sorting and searching, and you will be able to apprehend their
    strengths and weaknesses. As searching and sorting algorithms are the building
    blocks for most of the more complex algorithms, understanding them in detail will
    help you understand modern complex algorithms as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the main concepts discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing searching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A practical example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first look at some sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Sorting Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the era of big data, the ability to efficiently sort and search items in
    a complex data structure is quite important as it is needed by many modern algorithms.
    The right strategy to sort and search data will depend on the size and type of
    the data, as discussed in this chapter. While the end result is exactly the same,
    the right sorting and searching algorithm will be needed for an efficient solution
    to a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sorting algorithms are presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping Variables in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When implementing sorting and searching algorithms, we need to swap the values
    of two variables. In Python, there is a simple way to swap two variables, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/943d98a8-6cea-43f1-b3dc-1a96ed14a074.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple way of swapping values is used throughout the sorting and searching
    algorithms in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the bubble sort algorithm in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bubble sort is the simplest and slowest algorithm used for sorting. It is designed
    in a way that the highest value in its list bubbles its way to the top as the
    algorithm loops through iterations. As its worst-case performance is O(N²), as
    discussed previously, it should be used for smaller datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Logic Behind Bubble Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bubble sort is based on various iterations, called **passes**. For a list of
    size *N*, bubble sort will have *N*-1 passes. Let''s focus on the first iteration:
    pass one.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of pass one is pushing the highest value to the top of the list. We
    will see the highest value of the list bubbling its way to the top as pass one
    progresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bubble sort compares adjacent neighbor values. If the value at a higher position
    is higher in value than the value at a lower index, we exchange the values. This
    iteration continues until we reach the end of the list. This is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f24bd5d-ae99-4c23-b504-bdb9941e21d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now see how bubble sort can be implemented using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we implement pass one of bubble sort in Python, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4dd07ced-d8e2-4baa-a32d-73496686b03c.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the first pass is complete, the highest value is at the top of the list.
    The algorithm next moves on to the second pass. The goal of the second pass is
    to move the second highest value to the second highest position in the list. To
    do that, the algorithm will again compare adjacent neighbor values, exchanging
    them if they are not in order. The second pass will exclude the top element, which
    was put in the right place by pass one and need not be touched again.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing pass two, the algorithm keeps on performing pass three and
    so on until all the data points of the list are in ascending order. The algorithm
    will need *N*-1 passes for a list of size *N* to completely sort it. The complete
    implementation of bubble sort in Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8112422d-7d3a-4910-b2e9-f1240a431250.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's look into the performance of the `BubbleSort` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A Performance Analysis of Bubble Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easier to see that bubble sort involves two levels of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An outer loop**: This is also called **passes**. For example, pass one is
    the first iteration of the outer loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An inner loop**: This is when the remaining unsorted elements in the list
    are sorted, until the highest value is bubbled to the right. The first pass will
    have *N*-1 comparisons, the second pass will have *N*-2 comparisons, and each
    subsequent pass will reduce the number of comparisons by one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to two levels of looping, the worst-case runtime complexity would be O(n²).
  prefs: []
  type: TYPE_NORMAL
- en: Insertion Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic idea of insertion sort is that in each iteration, we remove a data
    point from the data structure we have and then insert it into its right position.
    That is why we call this **the insertion sort algorithm**. In the first iteration,
    we select the two data points and sort them. Then, we expand our selection and
    select the third data point and find its correct position, based on its value.
    The algorithm progresses until all the data points are moved to their correct
    positions. This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ba25bc4-942a-4704-abbe-558b0a521f69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The insertion sort algorithm can be coded in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the main loop, we iterate throughout all of the list. In each iteration,
    the two adjacent elements are `list[j]` (the current element) and `list[i]` (the
    next element).
  prefs: []
  type: TYPE_NORMAL
- en: In `list[j] > element_next` and `j >= 0`, we  compare the current element with
    the next element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this code to sort an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f82e873e-fb1a-4e6f-a195-799328961525.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at the performance of the insertion sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s obvious from the description of the algorithm that if the data structure
    is already sorted, insertion sort will perform very fast. In fact, if the data
    structure is sorted, then the insertion sort will have a linear running time;
    that is, O(n). The worst case is when each of the inner loops has to move all
    the elements in the list. If the inner loop is defined by *i*, the worst-case
    performance of the insertion sort algorithm is given by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23bd35a5-d92c-42c8-80d7-c85821d98ffb.png)'
  prefs: []
  type: TYPE_IMG
- en: '*![](assets/e136b412-be8f-4725-91d1-ab716386d1b8.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total number of passes is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03f8b384-ace0-401b-986f-d9fdfca57d1f.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, insertion can be used on small data structures. For larger data
    structures, insertion sort is not recommended due to quadratic average performance.
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have presented, so far, two sorting algorithms: bubble sort and insertion
    sort. The performance of both of them will be better if the data is partially
    sorted. The third algorithm presented in this chapter is **the merge sort algorithm**,
    which was developed in 1940 by John von Neumann. The defining feature of this
    algorithm is that its performance is not dependent on whether the input data is
    sorted. Like MapReduce and other big data algorithms, it is based on a divide
    and conquer strategy. In the first phase, called splitting, the algorithm keeps
    on dividing the data into two parts recursively, until the size of the data is
    less than the defined threshold. In the second phase, called **merging**, the
    algorithm keeps on merging and processing until we get the final result. The logic
    of this algorithm is  explained in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf2a1910-f8d4-4703-95e6-b68fe5a7ab3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s first look into the pseudocode of the merge sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see the algorithm has the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It divides the input list into two equal parts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses recursion to split until the length of each list is 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it merges the sorted parts into a sorted list and returns it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for implementing `MergeSort` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/90b41c82-5962-42c7-b781-57a59557f994.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the preceding Python code is run, it generates an output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff2f2912-318f-418a-800c-331c8ad48f00.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the code results are in a sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bubble sort algorithm compares immediate neighbors and exchanges them if
    they are out of order. If we have a partially sorted list, bubble sort should
    give reasonable performance as it will exit as soon as no more swapping of elements
    occurs in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: But for a totally unsorted list, sized *N*, you can argue that bubble sort will
    have to fully iterate through *N*-1 passes in order to get it fully sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Donald Shell proposed Shell sort (named after him), which questions the importance
    of selecting immediate neighbors for comparison and swapping.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pass one, instead of selecting immediate neighbors, we use elements that
    are at a fixed gap, eventually sorting a sublist consisting of a pair of data
    points. This is shown in the following diagram. In pass two, it sorts sublists
    containing four data points (see the following diagram). In subsequent passes,
    the number of data points per sublist keeps on increasing and the number of sublists
    keeps on decreasing until we reach a situation where there is just one sublist
    that consists of all the data points. At this point, we can assume that the list
    is sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/495145de-2a5c-4d41-aceb-2a95e51cc8e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, the code for implementing the Shell sort algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be used to sort the list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0749878d-e9b5-4f42-8610-19075022e645.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that calling the `ShellSort` function has resulted in sorting the input
    array.
  prefs: []
  type: TYPE_NORMAL
- en: A Performance Analysis of Shell Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell sort is not for big data. It is used for medium-sized datasets. Roughly
    speaking, it has a reasonably good performance on a list with up to 6,000 elements.
    If the data is partially in the correct order, the performance will be better.
    In a best-case scenario, if a list is already sorted, it will only need one pass
    through *N* elements to validate the order, producing a best-case performance
    of *O(N)*.
  prefs: []
  type: TYPE_NORMAL
- en: Selection Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier in this chapter, bubble sort is one of the simplest sorting
    algorithms. Selection sort is an improvement on bubble sort, where we try to minimize
    the total number of swaps required with the algorithm. It is designed to make
    one swap for each pass, compared to *N*-1 passes with the bubble sort algorithm.
    Instead of bubbling the largest value toward the top in baby steps (as done in
    bubble sort, resulting in *N*-1 swaps), we look for the largest value in each
    pass and move it toward the top. So, after the first pass, the largest value will
    be at the top. After the second pass, the second largest value will be next to
    the top value. As the algorithm progresses, the subsequent values will move to
    their correct place based on their values. The last value will be moved after
    the (*N*-1)^(th)  pass. So, selection sort takes *N*-1 passes to sort *N* items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e5e3334-1189-42eb-bb80-cac42d97f922.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of selection sort in Python is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the selection sort algorithm is executed, it will result in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d9494a36-e503-48a3-ad9f-b52b30611260.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the final output is the sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of the selection sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection sort's worst-case performance is *O(N**²**)*. Note that its worst
    performance is similar to bubble sort and it should not be used for sorting larger
    datasets. Still, selection sort is a better designed algorithm than bubble sort
    and its average performance is better than bubble sort due to the reduction in
    the number of exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a sorting algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The choice of the right sorting algorithm depends both on the size and the state
    of the current input data. For small input lists that are sorted, using an advanced
    algorithm will introduce unnecessary complexities to the code, with a negligible
    improvement in performance. For example, we do not need to use merge sort for
    smaller datasets. Bubble sort will be way easier to understand and implement.
    If the data is partially sorted, we can take advantage of that by using insertion
    sort. For larger datasets, the merge sort algorithm is the best one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Searching Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficiently searching data in complex data structures is one of the most important
    functionalities. The simplest approach, which will not be that efficient, is to
    search for the required data in each data point. But, as the data becomes bigger
    in size, we need more sophisticated algorithms designed for searching data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following searching algorithms are presented in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest strategies for searching data is to simply loop through
    each element looking for the target. Each data point is searched for a match and
    when a match is found, the results are returned and the algorithm exits the loop.
    Otherwise, the algorithm keeps on searching until it reaches the end of the data.
    The obvious disadvantage of linear search is that it is very slow due to the inherent
    exhaustive search. The advantage is that the data does not need to be sorted,
    as required by the other algorithms presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code for linear search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8406c7c9-2fee-4e53-be31-6c5efcd71876.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that running the `LinearSearch` function returns a `True` value if it can
    successfully find the data.
  prefs: []
  type: TYPE_NORMAL
- en: The Performance of Linear Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed, linear search is a simple algorithm that performs an exhaustive
    search. Its worst-case behavior is *O(N)*.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pre-requisite of the binary search algorithm is sorted data. The algorithm
    iteratively divides a list into two parts and keeps a track of the lowest and
    highest indices until it finds the value it is looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b23f9aa-ada6-4d28-841b-eea4256a3c7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that calling the `BinarySearch` function will return `True` if the value
    is found in the input list.
  prefs: []
  type: TYPE_NORMAL
- en: The Performance of Binary Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary search is so named because at each iteration, the algorithm bifurcates
    the data into two parts. If the data has *N* items, it will take a maximum of
    O(logN) steps to iterate. This means that the algorithm has an *O(logN)* runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary search is based on the logic that it focuses on the middle section of
    the data. Interpolation search is more sophisticated. It uses the target value
    to estimate the position of the element in the sorted array. Let''s try to understand
    it by using an example. Let''s assume we want to search for a word in an English
    dictionary, such as the word *river*. We will use this information to interpolate
    and start searching for words starting with *r*. A more generalized interpolation
    search can be programmed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc21fe23-43bb-4852-8e42-1458f022db6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that before using `IntPolsearch`, the array first needs to be sorted using
    a sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Performance of Interpolation Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data is unevenly distributed, the performance of the interpolation search
    algorithm will be poor. The worst-case performance of this  algorithm is *O(N)*
    and if the data is somewhat reasonably uniform, the best performance is O(log(log
    N)).
  prefs: []
  type: TYPE_NORMAL
- en: Practical Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to efficiently and accurately search data in a given data repository
    is critical to many real-life applications. Depending on your choice of searching
    algorithm, you may need to sort the data first  as well. The choice of the right
    sorting and searching algorithms will depend on the type and the size of the data,
    as well as the nature of the problem you are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to use the algorithms presented in this chapter to solve the problem
    of matching a new applicant at the immigration department of a certain country
    with historical records. When someone applies for a visa to enter the country,
    the system tries to match the applicant with the existing historical records.
    If at least one match is found, then the system further calculates the number
    of times that the individual has been approved or refused in the past. On the
    other hand, if no match is found, the system classes the applicant as a new applicant
    and issues them a new identifier. The ability to search, locate, and identify
    a person in the historical data is critical for the system. This information is
    important because if someone has applied in the past and the application is known
    to have been refused, then this may affect that individual's current application
    in a negative way. Similarly, if someone's application is known to have been approved
    in the past, this approval may increase the chances of that individual getting
    approval for their current application. Typically, the historical database will
    have millions of rows, and we will need a well-designed solution to match new
    applicants in the historical database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the historical table in the database looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Personal ID** | **Application ID** | **First name** | **Surname** | **DOB**
    | **Decision** | **Decision date** |'
  prefs: []
  type: TYPE_TB
- en: '| 45583 | 677862 | John | Doe | 2000-09-19 | Approved | 2018-08-07 |'
  prefs: []
  type: TYPE_TB
- en: '| 54543 | 877653 | Xman | Xsir | 1970-03-10 | Rejected | 2018-06-07 |'
  prefs: []
  type: TYPE_TB
- en: '| 34332 | 344565 | Agro | Waka | 1973-02-15 | Rejected | 2018-05-05 |'
  prefs: []
  type: TYPE_TB
- en: '| 45583 | 677864 | John | Doe | 2000-09-19 | Approved | 2018-03-02 |'
  prefs: []
  type: TYPE_TB
- en: '| 22331 | 344553 | Kal | Sorts | 1975-01-02 | Approved | 2018-04-15 |'
  prefs: []
  type: TYPE_TB
- en: In this table, the first column, `Personal ID`, is associated with each of the
    unique applicants in the historical database. If there are 30 million unique applicants
    in the historical database, then there will be 30 million unique personal IDs.
    Each personal ID identifies an applicant in the historical database system.
  prefs: []
  type: TYPE_NORMAL
- en: The second column we have is `Application ID`. Each application ID identifies
    a unique application in the system. A person may have applied more than once in
    the past. So, this means that in the historical database, we will have more unique
    application IDs than personal IDs. John Doe will only  have one personal ID but
    has two application IDs, as shown in the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding table only shows a sample of the historical dataset. Let''s assume
    that we have close to 1 million rows in our historical dataset, which contains
    the records of the last 10 years of applicants. New applicants are continuously
    arriving at the average rate of around 2 applicants per minute. For each applicant,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Issue a new application ID for the applicant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See if there is a match with an applicant in the historical database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a match is found, use the personal ID for that applicant, as found in the
    historical database. We also need to determine that how many times the application
    has been approved or refused in the historical database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no match is found, then we need to issue a new personal ID for that individual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose a new person arrives with the following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '`First Name`: `John`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Surname`: `Doe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOB`: `2000-09-19`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, how can we design an application that can perform an efficient and cost-effective
    search?
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy for searching the new application in the database can be devised
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the historical database by `DOB`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time a new person arrives, issue a new application ID to the applicant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch all the records that match that date of birth. This will be the primary
    search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the records that have come up as matches, perform a secondary search
    using the first and last name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a match is found, use `Personal ID` to refer to the applicants. Calculate
    the number of approvals and refusals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no match is found, issue a new personal ID to the applicant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try choosing the right algorithm to sort the historical database. We can
    safely rule out bubble sort as the size of the data is huge. Shell sort will perform
    better, but only if we have partially sorted lists. So, merge sort may be the
    best option for sorting the historical database.
  prefs: []
  type: TYPE_NORMAL
- en: When a new person arrives, we need to locate and search that person in the historical
    database. As the data is already sorted, either interpolation search or binary
    search can be used. Because applicants are likely to be equally spread out, as
    per `DOB`, we can safely use binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we search based on `DOB`, which returns a set of applicants sharing
    the same date of birth. Now, we need to find the required person within the small
    subset of people who share the same date of birth. As we have successfully reduced
    the data to a small subset, any of the search algorithms, including bubble sort,
    can be used to search for the applicant. Note that we have simplified the secondary
    search problem here a bit. We also need to calculate the total number of approvals
    and refusals by aggregating the search results, if more than one match is found.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world scenario, each individual needs to be identified in the secondary
    search using some fuzzy search algorithm, as the first and last names may be spelled
    slightly differently. The search may need to use some kind of distance algorithm
    to implement the fuzzy search, where the data points whose similarity is above
    a defined threshold are considered the same.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented a set of sorting and searching algorithms. We
    also discussed the strengths and weaknesses of different sorting and searching
    algorithms. We quantified the performance of these algorithms and learned when
    to use each algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study dynamic algorithms. We will also look at
    a practical example of designing an algorithm and the details of the page ranking
    algorithm. Finally, we will study the linear programming algorithm.
  prefs: []
  type: TYPE_NORMAL
