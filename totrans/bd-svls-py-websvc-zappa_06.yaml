- en: Building a Django REST API with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to create a RESTful API, using the Django Rest
    Framework. It will be based on a simple RESTful API with **CRUD** (**create**,
    **retrieve**, **update**, and **delete**) operations. We can consider the previously
    developed **ImageGallery** application with REST API extensions. Here, we will
    create an API for `PhotoAlbum`, where a user can create a new album, along with
    images through the REST API interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the Django REST Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and deploying the Django application using Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going further, there are some technical prerequisites to be met. These
    prerequisites are required to set up and configure the development environment.
    Following is the list of required software:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/Mac/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Rest Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Rest Framework JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Storages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django Imagekit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boto3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to install these packages in a virtual environment. In the next
    section, we will see the detailed information about the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the Django REST Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already covered the virtual environment setup process in detail in the
    *Setting up a virtual environment* section of [Chapter 5](part0128.html#3Q2800-8241a43bed654018b51365a570bcef1d),
    *Building a Django Application with Zappa*. You can follow these instructions
    to configure the pipenv tool and create a new virtual environment for this chapter.
    Let's move to the next section for installing the required packages using the
    pipenv tool.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to develop the REST API using the Django REST framework, so we
    need to install the following packages using the `pipenv install <package_name>`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`djangorestframework`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`djangorestframework-jwt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-storages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-imagekit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boto3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zappa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install multiple packages at once by mentioning the other packages separated
    by whitespace, such as `pipenv install <package_one> <package_two> ...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install these packages, then we are good to proceed with the implementation,
    and we will have the following mentioned `Pipfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`Pipfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pipenv maintains the versions along with its git hashes in the `Pipfile.lock`
    file. So we don't need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with configuring the development environment, and now it's time
    to implement the REST API. Stay tuned for the next section, where we are going
    to design the REST API using the Django Rest Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Designing REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to design the REST API for our ImageGallery application. We developed
    this application with Django's admin interface. Now we will extend the existing
    implementation of the ImageGallery application with a RESTful API interface. Before
    implementing the solution, let's have a look at a brief introduction to the Django
    REST Framework.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Django Rest Framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django Rest Framework is an open source library that is designed to implement
    the REST API in an optimistic way. It follows the Django design pattern with different
    terminologies. You can find the QuickStart tutorials at its documentation site
    ([http://www.django-rest-framework.org/#quickstart](http://www.django-rest-framework.org/#quickstart)).
  prefs: []
  type: TYPE_NORMAL
- en: Django Rest Frameworks is powerful and supports ORM and non-ORM data sources.
    It has built-in support for the Browsable API client ([https://restframework.herokuapp.com/](https://restframework.herokuapp.com/))
    and many other features as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to not use the Web Browsable API interface in the production
    environment. You can disable it by setting up the render class in `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Integrating the REST Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate the Django REST Framework, you can simply install it using the
    pipenv packing tool, as mentioned in the previous section on setting up the virtual
    environment. Once you are done with the installation part, you can proceed to
    add the `rest_framework` in your `INSTALLED_APPS` settings. Take a look at this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use the Web Browsable API along with the login and logout view,
    then you can add the following URL pattern in your root `urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now we have successfully integrated the Django REST Framework and
    we can move on to creating the REST API. Before creating the REST API, we need
    to implement the authentication and authorization layer so that each of our REST
    APIs will be secure from unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how can we make our REST API secure in the next section. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are essential parts to be considered while
    designing the REST APIs. With the help of these layers, we can prevent unauthorized
    access to our application. There are many types of implementation patterns are
    available, but we will use **JWT** (**JSON Web Token**). Read more about it at
    [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token).
    JWT is really useful for implementing distributed microservices architecture, and
    it doesn't rely on centralized server databases to verify the authenticity of
    the token.
  prefs: []
  type: TYPE_NORMAL
- en: There are many Python libraries available to implement the JWT token mechanism.
    In our case, we would like to use the `django-rest-framework-jwt` library ([https://getblimp.github.io/django-rest-framework-jwt/](https://getblimp.github.io/django-rest-framework-jwt/)),
    as it provides the support for Django Rest Framework.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you already have installed this library while setting up the environment
    in the *Virtual environment* section described earlier. Let's see how should we
    configure the `django-rest-framework-jwt` library in next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring django-rest-framework-jwt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are done with the installation, you need to add some predefined classes
    related to permission and authentication in `settings.py` as shown in the following
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to append the URL for obtaining a token, based on user credentials.
    In the root `urls.py`, we will be appending the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `api-token-auth` API will return a JWT token on successful authentication,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This token can be used to authorize all other protected APIs by adding an authorization
    header along with the token, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are other use cases where you would need to perform many operations on
    your issued token. For this, you would need to go through the documentation of
    `django-rest-framework-jwt` ([https://getblimp.github.io/django-rest-framework-jwt/](https://getblimp.github.io/django-rest-framework-jwt/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's start implementing the API for our ImageGallery application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing serializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django Rest Framework designed a serializers module similar to the Django forms
    module to implement the JSON presentation layer. Serializers are responsible for
    serializing and deserializing the data; you can see a detailed explanation about
    data serialization here ([http://www.django-rest-framework.org/tutorial/1-serialization/#creating-a-serializer-class](http://www.django-rest-framework.org/tutorial/1-serialization/#creating-a-serializer-class)).
  prefs: []
  type: TYPE_NORMAL
- en: The serializers module has many useful classes, such as `Serializer`, `ModelSerializer`,
    `HyperlinkedModelSerializer`, and more ([http://www.django-rest-framework.org/api-guide/serializers/](http://www.django-rest-framework.org/api-guide/serializers/)).
    Each class has similar operations but with extended features. A `Serializer` class
    is used to design custom data representation similar to Django's form representation,
    and `ModelSerializer` is used to represent the model class data similar to Django's
    `ModelFrom` class. `HyperlinkedModelSerializer` extends the representation of
    `ModelSerializer` with hyperlinked representation and with a primary key to relate
    the associated data.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a serializer class, using `ModelSerializer`. Take a look at
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`gallery`/`serializers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created `PhotoSerializer` and `PhotoAlbumSerializer` classes, using
    the `ModelSerializer` class. These serializers are associated with the model classes;
    hence, the data representation will be based on model structure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we are going to create views.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing viewsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`gallery`/`views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that we have created two different viewsets classes associated
    with `Photo` and `PhotoAlbum` models. The `PhotoAlbum` model has a one-to-many
    relationship with the `Photo` model. Hence, we will write a nested API such as
    `albums/(?P<album_id>[0-9]+)/photos` . In order to return related records of photos
    based on the `album_id`, we override the `get_queryset` method to filter the `queryset`
    based on the given `album_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we override the `perform_create` method to set the associated `album_id`
    while creating a new record. We will provide a complete demonstration in the upcoming
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at URLs configurations, where we configure the nested API
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the URL routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django REST Framework provides a `router` module to configure the standard
    URL configurations. It automatically adds support for all required URLs related
    to the mentioned viewsets. Read more about the `routers` here: [http://www.django-rest-framework.org/api-guide/routers/](http://www.django-rest-framework.org/api-guide/routers/).
    The following is the code snippet related to our route configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`gallery`/`urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a default router and registered the viewsets with a URL prefix.
    The router will automatically determine the viewsets and will generate the required
    API URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`imageGalleryProject`/`urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you include the `gallery.urls` patterns, then it will be available at the
    application level. We are done with implementation, so now it's time to see the
    demonstration. Let's move on to the next section, where will explore Zappa configuration,
    along with execution and deployment process on AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and deploying Django app using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides a lightweight deployment web server that runs on the local machine
    at port `8000`. You can debug and test your application before moving on to the
    production environment. Read more about it here ([https://docs.djangoproject.com/en/2.0/ref/django-admin/#runserver](https://docs.djangoproject.com/en/2.0/ref/django-admin/#runserver)).
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next sections, where we are going to explore application
    demonstration and deployment on AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Executing in the local environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to see the execution of your API. We are going to use Postman,
    an API client tool, to test the REST API. You can download the Postman app from
    [https://www.getpostman.com/](https://www.getpostman.com/). Let's see all the
    API executions in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: API authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before accessing the resource APIs, we need to authenticate the user and get
    a JWT access token. Let''s get an access token using the `api-token-auth` API.
    We are going to use the `curl` command-line tool to executes the API. The following
    is the `curl` command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we got the JWT token in response to user authentication. Now we are going
    to use this token as an authorization header to access other API resources.
  prefs: []
  type: TYPE_NORMAL
- en: GET request on API "/albums/"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This API will list all records from the `PhotoAlbum` model. Let''s try to access
    the `/album/` API with `GET` request method using the cRUL command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we got a 401 Unauthorized error from, the server with the message Authentication
    credentials were not provided. This is how we secured all our APIs using the JWT
    token authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we were to just add the authorization header with the access token
    we got from the authentication API, we would get the records from the server.
    The following cURL execution shows a successful API access with the authorization
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we got the data from the `"/albums/"` API by providing the Authorization
    header. Here, we can use `| python -m json.tool` to print the return response
    in a JSON readable format.
  prefs: []
  type: TYPE_NORMAL
- en: POST request on API "/albums/<album_id>/photos/"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can add more photos to the existing record. The <indexentry content="Django
    REST API execution, in local environment:POST request on API "/albums//photos/"">following
    is the log snippet of the cRUL command execution, where we are uploading a image
    file to existing photo album:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see that the image has been uploaded to AWS S3 storage, and we
    got the CDN link as we already configured AWS S3 and CloudFront. Let''s see the
    list of all records once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now our application has been implemented as per our requirements. We can move
    on to deploy the application over AWS Lambda using Zappa. Now let's move towards
    the next section to configure Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined the configuration as per the requirements. As the key defines
    each configuration, we can see the usages of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_region`: The AWS region where the Lambda will get uploaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_settings`: The import path of Django''s settings file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile_name`: The AWS CLI configuration profile which is defined in the `~/.aws/credentials`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project_name`: The project name for the uploading the Lambda function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime`: The Python runtime interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s3_bucket`: Creates an Amazon s3 bucket and uploads the deployment packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_env`: Sets the environment variable of all the key-value pairs mentioned
    in the uploaded JSON file at the Amazon S3 location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of this configuration information, we will proceed with the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are done with the configuration, then we can process the deployment.
    Zappa provides two different commands to perform the deployment such as `zappa
    deploy <stage_name>` and `zappa update <stage_name>`. Initially, we will use the
    `zappa deploy <stage_name>` command, as it is the first time that we are deploying
    this Lambda application.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already deployed the application and want to redeploy, then you
    would use the `zappa update <stage_name>` command. In the previous chapter, we
    had a detailed discussion about the deployment process of Zappa, so you can refer
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a log snippet of our deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's move to the next section, Where we are going to perform some execution
    on deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: Executing in the production environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have deployed the application successfully then you will get the hosted
    application link. This link is nothing but the link generated by configuring the
    AWS API gateway with AWS Lambda by Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the application in a production environment. A screenshot of
    the authentication API is present in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen the authentication execution in the local environment, it will
    be the same but in the production environment as well. The following is the log
    snippet of the authentication API execution deployed on AWS Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the functionality doesn't impact anything as the application
    is up and running on the serverless environment. Let's look at another API.
  prefs: []
  type: TYPE_NORMAL
- en: GET request on API /albums/
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have the access token gained by the authentication API, you are eligible
    to access all protected APIs. The following is a screenshot of the `GET` request
    for the `/albums/` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We are done with the deployment of the serverless environment. I
    hope you it was beneficial to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about developing the REST API in the Django REST
    Framework. We covered the process of securing the API using the JWT authentication
    mechanism. Finally, we deployed the application in a serverless environment using
    Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to develop a high-performance API based application
    using a very lightweight Python framework. We will also explore more Zappa configuration
    options to set up a caching mechanism. Stay tuned to discover more gems from the
    Zappa world.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Django Rest Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of Django-storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
