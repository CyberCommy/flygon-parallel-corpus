- en: Sharing Images with Docker Registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shipping applications is an integral part of the Docker platform. The Docker
    Engine can download images from a central location to run containers from them,
    and can also upload images which were built locally to a central location. These
    shared image stores are called **registries**, and in this chapter we'll look
    more closely at how image registries work and the types of registries that are
    available to you.
  prefs: []
  type: TYPE_NORMAL
- en: The primary image registry is Docker Hub, which is a free online service and
    is the default location for the Docker service to work with images. Docker Hub
    is a great place for the community to share images which are built to package
    open source software and are free to redistribute. Docker Hub has been hugely
    successful. At the time of writing this book, there are hundreds of thousands
    of images available on it, with billions of downloads every year.
  prefs: []
  type: TYPE_NORMAL
- en: A public registry may not be suitable for your own applications. Docker Hub
    also offers a commercial plan so that you can host private images (in a similar
    way to how GitHub lets you host public and private source code repositories),
    and there are other commercial registries that add features like security scanning.
    You can also run your own registry server in your environment by using an open
    source registry implementation which is freely available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter I''ll show you how to use those registries, and I''ll cover
    the finer details of tagging images – which is how you can version your Docker
    images – and working with images from different registries. We''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding registries and repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a local image registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing and pulling images with a local registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a commercial registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding registries and repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You download an image from a registry using the `docker image pull` command.
    When you run the command, the Docker Engine connects to the registry, authenticates
    – if it needs to – and pulls the image down. The pull process downloads all the
    image layers and stores them in the local image cache on the machine. Containers
    can only be run from images which are available in the local image cache, so unless
    they're built locally, they need to be pulled first.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the earliest commands you run when you get started with Docker on Windows
    will be something simple, like this example from [Chapter 2](5b6871d5-15a7-4dc2-9b7e-29a802491f24.xhtml),
    *Packaging and Running Applications as Docker Containers*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will work even if you don't have the image in your local cache, because
    Docker can pull it from the default registry – Docker Hub. If you try to run a
    container from an image that you don't have stored locally, Docker will automatically
    pull it before creating the container.
  prefs: []
  type: TYPE_NORMAL
- en: In this example I haven't given Docker much information to go on – just the
    image name, `dockeronwindows/ch02-powershell-env:2e`. That detail is enough for
    Docker to find the right image in the registry, because Docker fills in some of
    the missing details with default values. The name of the repository is `dockeronwindows/ch02-powershell-env`
    a repository is a storage unit that can contain many versions of a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Examining image repository names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Repositories have a fixed naming scheme: `{registry-domain}/{account-id}/{repository-name}:{tag}`.
    All parts are required, but Docker assumes defaults for some values. So `dockeronwindows/ch02-powershell-env:2e`
    is actually a short form of the full repository name, `docker.io/dockeronwindows/ch02-powershell-env:2e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry-domain` is the domain name or IP address of the registry that stores
    the image. Docker Hub is the default registry, so you can omit the registry domain
    when you''re using images from Hub. Docker will use `docker.io` as the registry
    if you don''t specify one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`account-id` is the name of the account or organization which owns the image
    on the registry. On Docker Hub the account name is mandatory. My own account ID
    is `sixeyed`, and the organization account ID for the images that accompany this
    book is `dockeronwindows`. On other registries, the account ID may not be needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repository-name` is the name you want to give your image to uniquely identify
    the application, within all the repositories for your account on the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag` is how you distinguish between different image variations in the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the tag for versioning your applications or to identify variants. If
    you don't specify a tag when you build or pull images, Docker uses the default
    tag  `latest`. When you start with Docker you will use Docker Hub and the `latest`
    tag, which are the defaults that Docker provides to hide some of the complexity
    until you're ready to dig deeper. As you continue with Docker, you'll use tags
    to make clear distinctions between different versions of your application package.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is Microsoft's .NET Core base image, which is on Docker
    Hub in the `microsoft/dotnet` repository. .NET Core is a cross-platform application
    stack which runs on Linux and Windows. You can only run Linux containers on Linux-based
    Docker hosts, and you can only run Windows containers on Windows-based Docker
    hosts, so Microsoft includes the operating system in the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Microsoft has dozens of versions of the .NET Core image
    available for use in the `microsoft/dotnet` repository, identified with different
    tags. These are just some of the tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2.2-runtime-bionic` a Linux image based on Ubuntu version 18.04 which has
    the .NET Core 2.2 runtime installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.2-runtime-nanoserver-1809` a Nano Server version 1809 image which has the
    .NET Core 2.2 runtime installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.2-sdk-bionic` a Linux image based on Debian which has the .NET Core 2.2
    runtime and SDK installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.2-sdk-nanoserver-1809` a Nano Server image which has the .NET Core 2.2 runtime
    and SDK installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tags make it clear what each image contains, but they are all fundamentally
    similar – they are all variations of `microsoft/dotnet`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker also supports multi-arch images, where a single image tag is used as
    an umbrella for many variations. There could be image variations based on Linux
    and Windows OS, or Intel and **Advanced RISC Machines** (**ARM**) processors.
    They all use the same image name, and when you run `docker image pull`, Docker
    pulls the matching image for your host's operating system and CPU architecture.
    .NET Core images do this – `docker image pull microsoft/dotnet:2.2-sdk` will download
    the Linux image on Linux machines, and the Windows image on Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: If you publish a cross-platform app to Docker Hub and you want to make it as
    easy as possible for consumers to use it, you should publish it as a multi-arch
    image. In your own development, it's better to be explicit and specify the exact
    `FROM` image in your Dockerfiles, otherwise your app will build differently on
    different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Building, tagging, and versioning images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You tag images when you first build them, but you can also explicitly add tags
    to an image with the `docker image tag` command. This is very useful in versioning
    mature applications, so users can choose which versioning level they want to work
    with. If you were to run the following commands, you would build an image with
    five tags, with ascending levels of precision for the application version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The initial `docker image build` command doesn't specify a tag, so the new image
    will default to `myapp:latest`. Each subsequent `docker image tag` command adds
    a new tag to the same image. Tagging doesn't copy the image, so there's no data
    duplication – you just have one image which can be referred to with several tags.
    By adding all of these tags, you give consumers the choice of which image to use,
    or to base their own image on.
  prefs: []
  type: TYPE_NORMAL
- en: This example application uses semantic versioning. The final tag could be the
    ID of the source code commit that triggered the build; this might be used internally
    but not made public. `5.1.6` is the patch version, `5.1` is the minor version
    number, and `5` is the major version number.
  prefs: []
  type: TYPE_NORMAL
- en: Users can explicitly use `myapp:5.1.6`, which is the most specific version number,
    knowing that the tag won't change at that level and the image will always be the
    same. The next release will have the tag `5.1.7`, but that will be a different
    image with a different application version.
  prefs: []
  type: TYPE_NORMAL
- en: '`myapp:5.1` will change with each patch release – the next build, `5.1` will
    be a tagged alias of `5.1.7` – but users can be confident there won''t be any
    breaking changes. `myapp:5` will change with each minor release – next month,
    it could be an alias of `myapp:5.2`. Users can choose the major version if they
    always want the latest release for version 5, or they could use the latest if
    they always want the latest version, and can accept the possibility of breaking
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the producer of images, you can decide how to support versioning in your
    image tags. As the consumer, you should favor being more specific – especially
    with images you use as the `FROM` image for your own builds. If you''re packaging
    a .NET Core application, you will have problems if you start your Dockerfile like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, this image has version 2.2.103 of the .NET Core SDK
    installed. If your application targets version 2.2, then that's fine; the image
    will build and your application will run correctly in a container. But when .NET
    Core 2.3 or 3.0 is released, the generic `:sdk` tag will be applied to the new
    image, which may not support targeting 2.2 applications. When you use the exact
    same Dockerfile after that release, it will use a different base image – your
    image build could fail, or it could complete only for the application to fail
    at runtime if there are breaking changes in the .NET Core update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you should consider using a tag for the minor version of the application
    framework you''re using, and explicitly stating the operating system and CPU architecture
    if it''s a multi-arch image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This way, you'll benefit from any patch releases to the image, but you'll always
    be using the 2.2 release of .NET Core, so your application will always have a
    matching host platform in the base image.
  prefs: []
  type: TYPE_NORMAL
- en: You can tag any image you have in your local cache – not just images you build
    yourself. This is useful if you want to re-tag a public image and add it to an
    approved set of base images in your local, private registry.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to a registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and tagging images are local operations. The end result of `docker
    image build` and `docker image tag` is a change to the image cache on the Docker
    Engine where you run the commands. Images need to be explicitly shared to a registry
    with the `docker image push` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub is available for use without authenticating to pull public images,
    but to upload images (or pull private images), you need to register for an account.
    Registration is free at [https://hub.docker.com/](https://hub.docker.com/), which
    is where you can create a Docker ID that you can use on Docker Hub and other Docker
    services. Your Docker ID is how you authenticate with the Docker service to access
    Docker Hub. This is done through the `docker login` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To push images to Docker Hub, the repository name must contain your Docker ID
    as the account ID. You can tag an image locally using any account ID – like `microsoft/my-app` – but
    you can't push it to Microsoft's organization on the registry. The Docker ID you
    are logged in with needs to have permission to push to the account on the registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I publish images to go along with this book, I build them with `dockeronwindows`
    as the account name in the repository. That''s an organization on Docker Hub and
    my own user account, `sixeyed`, has access to push images to that organization.
    When I am logged in as `sixeyed`, I can push images to repositories belonging
    to `sixeyed` or `dockeronwindows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the Docker CLI shows how the image is split into layers, and
    it tells you the upload status for each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This image uses Windows Server Core as the base image. That image is not publicly
    redistributable – it's listed on Docker Hub, and free to download from the Microsoft
    Container Registry, but it is not licensed to be stored on other public image
    registries. That's why we can see the lines stating *Skipped foreign layer* – Docker
    will not push layers containing the Windows OS to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t publish to another user''s account, but you can tag another user''s
    images with your own account name. This is a perfectly valid set of commands,
    which I could run if I wanted to download a specific version of the Windows Server
    Core image, give it a friendlier name, and make it available on the Hub under
    that new name in my account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft have used different tagging schemes for their images at different
    times. Windows Server 2016 images use the full Windows version number, like `10.0.14393.2608`.
    Windows Server 2019 images use the release name followed by the KB identifier
    for the most recent Windows update included in the image, like `1809_KB4480116`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to a registry doesn't get any more complex than that for the
    user, although, under the hood, Docker runs some smart logic. Image layering applies
    to registries as well as to the local image cache on the Docker host. When you
    push an image based on Windows Server Core to the Hub, Docker doesn't upload the
    4 GB base image – it knows that the base layer already exists on MCR, and it will
    only upload the layers that are missing on the target registry.
  prefs: []
  type: TYPE_NORMAL
- en: The last example of tagging a public image and pushing it to the public Hub
    is valid but unlikely – you're much more likely to tag and push images to your
    own private registry.
  prefs: []
  type: TYPE_NORMAL
- en: Running a local image registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker platform is portable because it's written in Go, which is a cross-platform
    language. Go applications can be compiled into native binaries, so Docker can
    run on Linux or Windows without users having to install Go. On Docker Hub there
    is an official  image which contains a registry server written in Go, so you can
    host your own image registry by running a Docker container from that image.
  prefs: []
  type: TYPE_NORMAL
- en: '`registry` is an official repository which is maintained by the Docker team,
    but at the time of writing it only has images available for Linux. It''s likely
    that a Windows version of the registry will be published soon, but in this chapter
    I will walk you through building your own registry image, as it demonstrates some
    common Docker usage patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Official repositories* are available on Docker Hub like other public images,
    but they have been curated by Docker, Inc. and are maintained either by Docker
    themselves or by the application owners. You can rely on them containing correctly
    packaged and up-to-date software. The majority of official images have Linux variants,
    but the number of Windows-based official images is growing.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the registry image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker''s registry server is a fully functional image registry, but it''s just
    the API server – it doesn''t have a Web UI like Docker Hub. It''s an open source
    application hosted on GitHub in the `docker/distribution` repository. To build
    the application locally, you would need to install the Go SDK first. If you''ve
    done that, you can run a simple command to compile the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But if you're not a regular Go developer, you don't want the overhead of installing
    and maintaining the Go tools on your local machine just so you can build the registry
    server when you want to update it. It would be better to package the Go tools
    into a Docker image and set up the image so that when you run a container, it
    builds the registry server for you. You can do this with the same multi-stage
    build approach I demonstrated in [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml),
    *Developing Dockerized .NET Framework and .NET Core Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-stage pattern has a lot of advantages. First, it means that your application
    image can be kept as lightweight as possible – you don't need to package the build
    tools along with the runtime. Secondly, it means that your build agent is encapsulated
    in a Docker image so that you don't need to install those tools on your build
    server. Third, it means that developers can use exactly the same build process
    that the build server uses, so you avoid a situation where developer machines
    and the build server have different toolsets installed, with the risk of them
    drifting and causing build issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile for `dockeronwindows/ch04-registry:2e` uses the official Go
    image, which has a Windows Server Core variant on Docker Hub. The builder stage
    uses that image to compile the registry application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I'm using an `ARG` instruction to specify the version of the source code to
    build – the GitHub repository has tags for each released version, and I'm defaulting
    to version 2.6.2\. Then I use `git` to clone the source code and switch to the
    labelled version of the code, and use `go build` to compile the application. The
    Git client and the Go tools are all in the base `golang` image. The output will
    be `registry.exe`, a native Windows executable which doesn't need Go installed
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage of the Dockerfile uses Nano Server as the base, which can run
    the Go application just fine. Here''s the whole application stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing complicated in this stage. It begins by setting up the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY` is an environment variable that
    the registry uses as the base path to store data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `VOLUME` is created for the registry data by using the path that was captured
    in the environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Port `5000` is exposed, which is the conventional port to use for Docker registries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remainder of the Dockerfile sets up the entrypoint for containers and copies
    the compiled binary and the default configuration file from the builder stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker containers in Windows Server 2016 had a different implementation of
    volumes – the target directory inside the container was actually a symbolic link
    rather than a normal directory. That caused issues with Go, Java, and other languages.
    There was a workaround that was made possible by using mapped drives, but that''s
    no longer needed. If you see any Dockerfiles that use a G: drive, they''re based
    on Windows Server 2016 and can be simplified for Windows Server 2019 just by using
    the C: drive.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the registry image is the same as any other image, but when you use
    it to run your own registry, there are some important factors to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Running a registry container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running your own registry lets you share images between team members and store
    the output of all your application builds using the fast local network instead
    of an internet connection. You would typically run the registry container on a
    server that can be widely accessed in a configuration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7c1703fa-380c-4361-949b-90883f08e110.png)'
  prefs: []
  type: TYPE_IMG
- en: The registry is running in a container (1) on a server (2). The client machines
    (3) are connected to the server so that they can use the registry on the local
    network to push and pull private images.
  prefs: []
  type: TYPE_NORMAL
- en: To make the registry container accessible, you need to publish port `5000` from
    the container to port `5000` on the host. Registry users can access the container
    using the host server's IP address or hostname, and that will be the registry
    domain you use in image names. You'll also want to mount a volume from the host
    to store the image data in a known location. When you replace the container with
    a new version, it will still be available using the host's domain name, and it
    will still have all the image layers stored by the previous container.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my host server I have a RAID array configured as disk `E:`, which I use
    for my registry data so that I can run my registry container mounting that volume
    for the data path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In my network I'll be running the container on a physical machine with the IP
    address `192.168.2.146`. I could use `192.168.2.146:5000` as the registry domain
    to tag images, but that isn't very flexible. It's better to use the domain name
    of the host so that I can point that to a different physical server if I need
    to without having to re-tag all my images.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the hostname you can use your network''s **Domain Name System** (**DNS**)
    service, or a **Canonical Name** (**CNAME**) if you''re running a public server.
    Alternatively you could add an entry to the hosts file on the client machines
    and use a custom domain name. This is the PowerShell command I use to add the
    hostname entry for `registry.local`, pointing to my Docker server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now my server is running a registry server in a container with reliable storage,
    and my client is set up to access the registry host using a friendly domain name.
    I can start pushing and pulling private images from my own registry, which is
    only available to users on my network.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing and pulling images with a local registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can only push images to a registry if the image tag matches the registry
    domain. The process for tagging and pushing is the same as with Docker Hub, but
    you need to explicitly include the local registry domain in the new tag. These
    commands pull my registry server image from Docker Hub and add a new tag, making
    it suitable to be pushed to the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker image tag` command specifies the source tag first, and then the
    target tag. You can change every part of the image name for the new target tag.
    I''ve used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry.local:5000` is the registry domain. The original image name had an
    implied domain of `docker.io`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`infrastructure` is the account name. The original account name was `dockeronwindows`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry` is the repository name. The original was `ch04-registry`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2.6.2` is the image tag. The original tag was `2e`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're wondering why all of the images for this book have the `2e` tag, it's
    because I've used that to identify them as working with the second edition of
    this book. I didn't use tags for images in the first edition, so they all have
    the implied tag of `latest`. They still exist on Docker Hub, but by tagging the
    new versions as `2e`, I can publish images to the same repositories without breaking
    the code samples for readers of the first edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can try to push the new tagged image to the local registry, but Docker won''t
    let me use the registry yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Docker platform is secure by default, and the same principle extends to
    image registries. The Docker Engine expects to use HTTPS to communicate with registries
    so that the traffic is encrypted. My simple registry installation uses plaintext
    HTTP, so I get an error saying Docker tried to use an encrypted transport for
    the registry but only an unencrypted transport was available.
  prefs: []
  type: TYPE_NORMAL
- en: There are two options for setting up Docker to use the local registry. The first
    is to extend the registry server to secure the communication – the registry server
    image can run over HTTPS if you supply it with an SSL certificate. That's what
    I would do in a production environment, but to start out I can use the other option
    and make an exception in the Docker configuration. The Docker Engine will allow
    a HTTP registry to be used if it's explicitly named in an allowed list of insecure
    registries.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the registry image with HTTPS using your company's SSL certificate
    or a self-signed certificate, which means that you don't need to configure the
    Docker Engine to allow insecure registries. There is a Windows registry walkthrough
    in Docker's lab repository on GitHub, `docker/labs`, which explains how to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Docker to allow insecure registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Engine can use a JSON configuration file to change settings, including
    the list of insecure registries that the engine will allow. Any registry domains
    in that list can use HTTP rather than HTTPS, so this is not something you should
    do for a registry that's hosted on a public network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker''s configuration file is located at `%programdata%\docker\config\daemon.json`
    (**daemon** is Linux terminology for a background service, so this is the name
    of the Docker Engine configuration file). You can manually edit it to add the
    local registry as a secure option and then restart the Docker Windows service.
    This configuration allows Docker to use the local registry with HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using Docker Desktop on Windows 10, the UI has a nice configuration
    window that takes care of this for you. Instead of editing the file manually,
    just right-click on the Docker logo in the status bar, select Settings*,* navigate
    to the Daemon page, and add an entry to the Insecure registries list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/500523ff-3838-4543-8104-c4342100969a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the local registry domain added to my insecure list, I can use it to push
    and pull images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Any users with network access to my Docker server can use images stored in
    the local registry with the `docker image pull` or `docker container run` commands.
    You can also use local images as the base images in other Dockerfiles by specifying
    the name with the registry domain, the repository name, and the tag in the `FROM`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is no way to override the default registry, so you can't set your local
    registry as the default when a domain isn't specified – the default is always
    Docker Hub. If you want to use a different registry for images, the registry domain
    always has to be specified in the image name. Any image names you use without
    a registry address will be assumed to refer to images from `docker.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Windows image layers in a local registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are not allowed to publicly redistribute the base layers for Microsoft images,
    but you are allowed to store them in a private registry. This is particularly
    useful for the Windows Server Core image. The compressed size of that image is
    2 GB, and Microsoft release a new version of the image every month, listed on
    Docker Hub, with the latest security patches.
  prefs: []
  type: TYPE_NORMAL
- en: The updates usually only add one new layer to the image, but that layer could
    be a 300 MB download. If you have many users working with Windows images, they
    will all need to download those layers, and that's a lot of bandwidth and a lot
    of time. If you run a local registry server, you can pull those layers once from
    Docker Hub, and push them to your local registry. Every other user then pulls
    from the local registry, downloading them from the fast local network rather than
    from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to enable this feature for specific registries in the Docker configuration
    file by using the `allow-nondistributable-artifacts` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This setting isn''t exposed directly in the Docker for Windows UI, but you
    can set it in the Advanced mode of the Settings screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7fe10262-09e8-4ea1-90b6-01d668a719bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, I can push the Windows *foreign layers* to my local registry. I can tag
    the latest Nano Server image with my own registry domain and push the image there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When you store the Windows base image layers in your own registry, the layer
    IDs will be different from the original layer IDs on MCR. That has an impact on
    Docker's image cache. You can pull your own Nano Server image on a clean machine
    using the full tag `registry.local:5000/microsoft/nanoserver:1809`. Then if you
    pull the official Microsoft image, the layers will be downloaded again. They have
    the same content but different IDs, so Docker doesn't recognize them as a cache
    hit.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to store your own versions of base images for Windows, make
    sure you're consistent and only use those images in your Dockerfiles. That also
    applies to images that build from the Windows image – so if you want to use .NET,
    you'll need to build your own SDK image using your Windows image as the base.
    There's an overhead to this, but lots of large organizations prefer the approach
    because it gives them fine control over their base images.
  prefs: []
  type: TYPE_NORMAL
- en: Using a commercial registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running your own registry is not the only way to have a secure, private store
    for image repositories – there are several third-party offerings you can use.
    In practice, they all work in the same way – you need to tag your images with
    the registry domain and authenticate with the registry server. There are several
    options available, and the most comprehensive ones come from Docker, Inc., which
    has different products available for different levels of service.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub is the most widely used public container registry, averaging over
    one billion image pulls per month at the time of writing. You can host unlimited
    public repositories on the Hub and pay a subscription to host multiple private
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub has an automated build system, so you can link image repositories
    to source code repositories in GitHub or Bitbucket, and Docker's servers will
    build an image from the Dockerfile in the repository whenever you push changes
    – it's a simple and effective hosted **Continuous Integration** (**CI**) solution,
    especially if you are using portable, multi-stage Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: A Hub subscription is suitable for smaller projects or teams with multiple users
    working on the same applications. It has an authorization framework where users
    can create an organization, which becomes the account name in the repository rather
    than an individual user's account name. Many users can be given access to the
    organization's repositories, which allows multiple users to push images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is also a registry for commercial software distribution. It's like
    an app store for server-side applications. If your company produces commercial
    software, Docker Hub could be a good choice for distributing it. You build and
    push images in exactly the same way, but your source can be kept private – only
    the packaged application is publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can register with Docker as a Verified Publisher to identify that there''s
    a commercial entity maintaining the images. Docker Hub lets you filter on Verified
    Publishers, so this is a good way to get visibility for your apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d6a7c495-7147-4b6d-86cd-3c79835f0983.png)'
  prefs: []
  type: TYPE_IMG
- en: There is also a certification process you can go through for images which are
    hosted on Docker Hub. Docker certification applies across software images and
    hardware stacks. If your image is certified, it's guaranteed to work on **Docker
    Enterprise** on any certified hardware. Docker tests all of these combinations
    in the certification process, and that end-to-end guarantee is very attractive
    to large enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Trusted Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker Trusted Registry** (**DTR**) is part of the Docker Enterprise suite,
    the enterprise-grade **Containers-as-a-Service** (**CaaS**) platform from Docker,
    Inc.. It''s aimed at enterprises running a cluster of Docker hosts in their own
    data centers or in any cloud. Docker Enterprise comes with a comprehensive management
    suite called **Universal Control Plane** (**UCP**), which provides an interface
    to administer all the resources in your Docker cluster – the host servers, images,
    containers, networks, volumes, and everything else. Docker Enterprise also provides
    DTR, which is a secure, scalable image registry.'
  prefs: []
  type: TYPE_NORMAL
- en: DTR runs over HTTPS and is a clustered service, so you can deploy multiple registry
    servers across your cluster for scalability and failover. You can use local storage
    or cloud storage for DTR, so if you run in Azure the images can be persisted in
    Azure storage with practically unlimited capacity. Like Docker Hub you can create
    organizations for shared repositories, but with DTR, you manage authentication
    by creating your own user accounts or by plugging into a **Lightweight Directory
    Access Protocol** (**LDAP**) service (like Active Directory). Then you can configure
    role-based access control for fine-grained permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security scanning is also available in DTR, a feature that scans the binaries
    inside your images to check for known vulnerabilities. You can configure scans
    to run whenever an image is pushed, or build a schedule. Scheduled scans can alert
    you when a new vulnerability is found in one of the dependencies for an old image.
    The DTR UI lets you drill down into the details of the vulnerability and see the
    exact file and the exact exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/57b74dfa-9361-4b46-ac45-baa91cefca64.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one other major security feature that is only available in Docker Enterprise,
    **content trust**. Docker content trust lets users digitally sign images to capture
    an approval workflow – so QA and security teams can run an image version through
    their test suites and sign it to confirm that they approve a release candidate
    for production. Those signatures are stored in DTR. UCP can be configured to only
    run images which have been signed by certain teams, so you get close control over
    what software your cluster will run, together with an audit trail proving who
    built and approved the software.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Enterprise has a rich suite of features which can be accessed through
    friendly web UIs, as well as through the usual Docker command line. Security,
    reliability, and scalability are major factors in the feature set, which makes
    it a good choice for enterprise users looking for a standard way to manage images,
    containers, and Docker hosts. I will cover UCP in [Chapter 8](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml),
    *Administering and Monitoring Dockerized Solutions*, and DTR in [Chapter 9](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml),
    *Understanding the Security Risks and Benefits of Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try out Docker Enterprise in a sandbox environment with no setup
    requirements, browse to [http://trial.docker.com](http://trial.docker.com) for
    a hosted trial that you can use for 12 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Other registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is now so popular that many third-party services have added an image
    registry to their existing offerings. On the cloud, you have the **EC2 Container
    Registry** (**ECR**) from **Amazon Web Services** (**AWS**), Azure Container Registry
    from Microsoft, and Container Registry on Google Cloud Platform. All of these
    offerings integrate with the standard Docker command line and with the other products
    in each respective platform, so they can be good options if you are heavily invested
    in one cloud service provider.
  prefs: []
  type: TYPE_NORMAL
- en: There are also standalone registry offerings, including Artifactory from JFrog,
    and Quay.io, which are hosted services. Having a hosted registry removes the management
    overhead of running your own registry server, and if you are already using services
    from a provider who also offers a registry, it makes sense to evaluate that option.
  prefs: []
  type: TYPE_NORMAL
- en: All of the registry providers have different feature sets and service levels
    – you should compare their offerings and, most importantly, check the level of
    Windows support. Most of the existing platforms were originally built to support
    Linux images and Linux clients, and there may not be feature parity for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you've learned what an image registry does and how to work with
    it using Docker. I covered repository names and image tagging to identify application
    versions or platform variations, and how to run and use a local registry server
    – by running one in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Using a private registry is something you're likely to do quite early in your
    Docker journey. As you start to Dockerize existing applications and experiment
    with new software stacks, it may be useful to push and pull images across the
    fast local network – or use the cloud if local storage space is an issue. As you
    use Docker more and progress to production implementation, you may have a roadmap
    to upgrade to DTR for a supported registry with rich security features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good understanding of how to share images and use images
    which have been shared by other people, you can look at bringing tried and trusted
    software components into our own applications with a container-first solution
    design.
  prefs: []
  type: TYPE_NORMAL
