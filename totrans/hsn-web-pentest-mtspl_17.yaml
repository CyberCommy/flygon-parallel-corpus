- en: Penetration Testing on Technological Platforms - Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at how to exploit JBoss and Apache Tomcat.
    In this chapter, we will look at Jenkins. Jenkins is a popular tool that's used
    to automate the non-human part of the software development process. In a **Business-to-Consumer**
    (**B2C**) relationship, a model where the company is providing services such as
    e-payment, e-commerce, online mobile and dish recharge plans, and so on to a consumer,
    the developers have a significant load on them. Due to the frequent updates that
    occur on the staging and production servers, the environment becomes complicated
    for the developers. To work more efficiently on the updates for the software and
    be able to launch them on time, a company will opt to use a platform engine to
    try and help pipeline the updates and manage them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is one such platform engine. It handles the deployment and management
    of source codes that need to be deployed on different servers at different times
    of the day. Since Jenkins handles sensitive information when it manages the source
    code for a company, it is a hot target for those who are focused on industrial
    cyber-espionage. Once the threat actor is able to gain access to the Jenkins platform,
    they can access the source code (blueprints) of the services that are being offered
    by the organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a penetration tester, we have to make sure the client''s organization has
    instances such as Jenkins fully patched. In this chapter, we will explore the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins reconnaissance and enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins instance: [https://jenkins.io/download/](https://jenkins.io/download/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Metasploit Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is an open source tool. It is built using Java, which helps with continuous
    integration when using plugins. For example, if we want to integrate Git, we need
    to install the git plugin. Jenkins supports hundreds of plugins, which makes it
    practically compatible with almost every tool. It does this to ensure **Continuous
    Integration** (**CI**) and **Continuous Delivery** (**CD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the key features of Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides CI and CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugin-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to configure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into how to enumerate and exploit Jenkins, we need to understand
    some of the basic terminologies that may come up in the later sections of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Stapler library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stapler is a library used by Jenkins that allows objects to be mapped to URLs
    automatically. It solves the problem of mapping relative URLs in complex applications
    such as **Expression Language** (**EL**) ([http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html](http://www-106.ibm.com/developerworks/java/library/j-jstl0211.html)).
    It takes an object and a URL and then evaluates the URL against the object. It
    repeats this process until it hits either a static resource, a view (such as JSP,
    Jelly, Groovy, and so on), or an action method. The following diagram shows this
    process in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/642f371b-7343-4276-b121-cd6780b082dd.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Credits: [http://stapler.kohsuke.org/what-is.html](http://stapler.kohsuke.org/what-is.html))'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, the root object is mapped to the URL, while
    every other object is mapped as a separate path until a resource is found.
  prefs: []
  type: TYPE_NORMAL
- en: URL routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'URL routing is used by Jenkins to process the URL paths; let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Models:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLog()` will traverse to `/log/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`getJob("foo")` will be traversed as `/job/foo`'
  prefs: []
  type: TYPE_NORMAL
- en: Action methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doArtifact(...) action in getJob("foo")` will become `/job/foo/1/artifact`,
    where 1 is the dynamic getter.'
  prefs: []
  type: TYPE_NORMAL
- en: Apache Groovy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Groovy is a multi-faceted programming language that supports static typing
    and static compilation. The key point for users to remember here is that Groovy
    supports runtime and compile-time meta-programming.
  prefs: []
  type: TYPE_NORMAL
- en: Meta-programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meta-programming is a technique that allows computer programs to consider other
    programs as their input data. So, a program can be designed to read/write/modify
    other programs, or even itself. If a program simply reports on itself, this is
    known as **introspection,** while if the program modifies itself, this is known
    as **reflection**. A lot of languages support meta-programming – PHP, Python,
    Apache Groovy, and compilers are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to further our understanding with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding program creates another program, `programs`, which
    prints numbers `1-500`.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract syntax tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Abstract Syntax Tree** (**AST**) is a representation of the structural
    and content-related details of a program. It does not include inessential punctuation
    and delimiters. AST is used by compilers for parsing, type resolution, flow analysis,
    and code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jenkins pipeline is a combination of plugins that work together and help
    with continuous delivery. The pipeline can be implemented as code using JenkinsFile,
    and this can be defined using a **domain-specific language** (**DSL**). Pipelines
    in Jenkins are built with Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins reconnaissance and enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration for Jenkins is a very important aspect of penetration testing. Activity information
    that's retrieved while performing reconnaissance and enumeration can help penetration
    testers exploit the Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to determine the installation and version detection processes
    of Jenkins. We will go through these now and then cover how to exploit Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Jenkins using favicon hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins has a very unique favicon, and when converted into hash form, it becomes
    `81586312`. This hash can be used to identify a Jenkins installation; it can even
    be used on Shodan to identify systems running Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the hash value is used to identify Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f86a715-c06d-4d3c-a260-533243fc15ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use different Jenkins HTTP response headers to find the Jenkins
    instance. For example, to find a specific version of Jenkins, we can use the `X-Jenkins`
    header, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93e9f548-629d-4fa0-9217-6bb57a1bf218.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's see what other HTTP response headers we can use to identify the Jenkins
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Jenkins using HTTP response headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways of detecting a Jenkins instance is by analyzing
    the HTTP response headers. Jenkins puts a lot of information into its response
    headers, such as the version''s disclosure information, **command-line interface**
    (**CLI**) port, user and group permissions, and more, all of which can be used
    for further exploitation. A response header from a Jenkins instance can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/984d8558-75f7-4827-b861-dec55222766c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are some of the HTTP server response headers for Jenkins instances
    that can be used for detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X-Hudson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-Session`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-You-Are-Authenticated-As`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-You-Are-In-Group-Disabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Required-Permission`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Permission-Implied-By`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Hudson-CLI-Port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-CLI-Port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-CLI2-Port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-SSH-Endpoint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Hudson-JNLP-Port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-JNLP-Port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-JNLP-Host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Instance-Identity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Jenkins-Agent-Protocols`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned some common ways to detect Jenkins manually, let's
    move on to the next phase of penetration testing – enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins enumeration using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the manual way of enumerating Jenkins, let's move on
    and look at the Metasploit Framework's auxiliary `jenkins_enum`, which takes enumeration
    one step further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Metasploit module also has an auxiliary that uses methods similar to the
    ones described in the previous section to perform the recon. This includes looking
    for the response header value, that is, `X-Jenkins`, as well as the HTML source
    for the keyword. The auxiliary can be loaded using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da68f422-f94b-41d7-a349-01a689bdeb27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After setting the options shown in the preceding screenshot, running the auxiliary
    will detect the version number, as well as perform basic checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b480c4b8-93a6-4c17-b729-db556e6a772f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can dive a little deeper and examine the source code of the auxiliary
    in order to understand what exactly the script is doing. By looking at the following
    screenshot, we can see that the script checks for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/view/All/newJobs`: Shows a list of jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/asynchPeople`: Shows a list of users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/systemInfo`: Prints the system''s information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7db89125-63ea-45f8-9825-c54e6781c96c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following command shows another auxiliary in Metasploit that allows us
    to brute-force the credentials of Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08016e9d-8559-4ad5-9139-80efd0a3b52d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we''ve set the required options and run the module, we''ll see that the
    auxiliary returns the valid credentials. This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc73dd5e-f11e-4839-8bba-faaa47f39b70.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now explore Jenkins in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once enumeration is complete, and if a vulnerable version of Jenkins has been
    found, we can move on to the exploitation phase. In this section, we will learn
    about the various exploits that can be discovered by `@orangetsai` and how they
    can be chained together to execute system commands on a Jenkins server.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will look at two of the most famous exploits of 2019, discovered by
    `@orangetsai` ([https://blog.orange.tw/](https://blog.orange.tw/)), which exploited
    Jenkins and returned a shell. These exploits were later added to Metasploit as
    unauthenticated RCEs.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins ACL bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the script console exploits of Jenkins became well known, a lot of people
    started configuring Jenkins with anonymous read access set to **disabled** in
    the global security configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd926542-db9b-401f-b9cc-e91dd476c493.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this setting, anonymous users could no longer see anything except the
    specific whitelisted items shown in the following screenshot (these were provided
    at the following URL: [https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258](https://github.com/jenkinsci/jenkins/blob/41a13dffc612ca3b5c48ab3710500562a3b40bf7/core/src/main/java/jenkins/model/Jenkins.java#L5258)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcbef755-cc87-49f7-9dd7-c3b166e1938d.png)'
  prefs: []
  type: TYPE_IMG
- en: We already know that Jenkins is based on Java and that, in Java, everything
    is a subclass of `java.lang.Object`. In this manner, all objects have `getClass()`,
    and the name of `getClass()` matches the naming convention rule. Therefore, one
    way to bypass this whitelist is to use the whitelisted objects as an entrance
    and jump to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Orange discovered that calling the objects (listed here) leads to ACL bypass
    and that the search method can be accessed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The routing mechanism shown in the preceding objects is mapped in the following
    URL format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'From the URL provided, we can see that no action is allowed unless we are logged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e63cbb-37c0-4d3e-a2eb-8149b638fab2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what happens when we use the ACL bypass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0be6ed36-35e4-4516-a0c3-63a0c3559755.png)'
  prefs: []
  type: TYPE_IMG
- en: We successfully bypassed the ACL and performed a search.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jenkins unauthenticated RCE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chaining the ACL bypass vulnerability with the sandbox bypass gives us **remote
    code execution** (**RCE**). Metasploit already has a module that exploits these
    vulnerabilities and executes our shellcode. Let''s take a look how it can be used
    before we learn about how the exploit works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load the exploit module by using the following command in msfconsole:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d26775f7-8b3d-4292-91ab-baf68066f517.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we set the required options and run the exploit, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d654f41-951a-4dac-a8bb-07f8d898dfc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a reverse shell, let''s read the source code of the exploit
    and try to understand how it works. By looking at the source code, we can see
    the various CVEs that were used in the exploit, as well as the author''s details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87ec3c85-0d1c-4ccc-a033-439673db3a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the source code for the module, we can see that the module is requesting `/search/index`
    using a `GET` HTTP method with the `q=a` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0ba3338-48b1-4a35-85e4-e794bc436d96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the exploit confirms whether the application is running Jenkins
    or not by checking the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ACL bypass to call for the search function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response headers for X-Jenkins value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the HTML page for the keyword administrator after calling the search
    URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we can see that something related to Groovy''s `doCheckScriptCompile`
    method is being mentioned. `doCheckScriptCompile` is a method that allows developers
    to check for syntax errors. To parse the syntax, an AST parser is used (see the
    *Jenkins terminology* section of this chapter for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26e0ac8f-3aca-4867-9030-52c24e04a831.png)'
  prefs: []
  type: TYPE_IMG
- en: To be able to achieve successful RCE, we need to send the code that's executed
    when it's sent through `doCheckScriptCompile()`. This is where meta-programming
    comes in. Groovy is meta-programming friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take a look at the Groovy reference manual, we''ll come across `@groovy.transform.ASTTest`,
    which has the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0639822c-f95e-4042-96d1-674ec5b3eca4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This implies that the following piece of code will be executed when it''s passed
    through `@ASTTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the exploit can be written like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The URL is calling the `workflow-cps` plugin of Jenkins, which has the `checkScriptCompile`
    method. URL for the hosted code is
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java](https://github.com/jenkinsci/workflow-cps-plugin/blob/2.46.x/src/main/java/org/jenkinsci/plugins/workflow/cps/CpsFlowDefinition.java)
    which can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92459083-6566-4699-8312-47a5238659b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, this version of the exploit will only work if the **Pipeline Shared
    Groovy Libraries Plugin** does not exist in Jenkins. This is why, if we look further
    down the exploit code, we will see something related to `@Grab` being used in
    the final payload mentioned in the comments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b54ba3b-c835-4bc3-99f4-9920a7930eeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to understand what `@Grab` is. As per Groovy''s official documentation,
    Grape is a JAR dependency manager that allows developers to manage and add Maven
    repository dependencies to their classpaths, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8565ff3b-f819-47b5-b6d8-d965c29162f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, `@Grab` will import the dependencies from the mentioned repository and
    add them to the code. Now, a question arises: "What if the repository is not on
    Maven?" In our case, because it''s in the shellcode, Grape will allow us to specify
    the URL, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f39306c-6f4b-4973-9df3-cd971a0d1da7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the following code will download the JAR from [http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar](http://evil.domain/evil/jar/org.restlet/1/org.restlet-1.jar):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have downloaded the malicious JAR from the server, the next task
    is to execute it. For this, we need to take a deep dive into the source code of
    the Groovy core, which is where Grape is implemented ([https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy](https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a method we can use to process the ZIP ( JAR) file and check for two
    methods in the specific directory. Note the last few lines shown in the following
    screenshot – there''s a function called `processRunners()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a8afec0-a923-46a6-aaf1-35ae68720053.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By taking a look at the following function, we can see that `newInstance()`
    is being called. This means a constructor can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d232cc35-0555-4e5a-9dbb-574883056dba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In short, if we create a malicious JAR and put a class file in the `META-INF/services/org.codehaus.groovy.plugins.Runners` folder,
    inside the JAR file, we will be able to invoke a constructor with our code, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will lead to code execution!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we return to the source code of the exploit, as shown in the following
    screenshot, we should be able to completely understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16c4f78f-0971-437e-a301-7a0c6fd89cdf.png)'
  prefs: []
  type: TYPE_IMG
- en: '`checkScriptCompile` is used to pass the syntax of the program.`@Grabconfig`
    is used to disable the checksum of the file being fetched.`@GrabResolver` is used
    to fetch external dependencies (a malicious JAR file).`Import` is used to execute
    the constructor where the shellcode is written.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Jenkins and its basic terminology. We covered
    how to detect the installation of Jenkins manually, as well as by using the Metasploit
    Framework. Then, we learned how to exploit Jenkins, as well as how the exploit
    works. Understanding how these exploits work is important if you wish to help
    the company you're working to apply better patches and have a pentester develop
    better exploits or bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal should always be to learn as much as we can about technology.
    From a pentester's perspective, the more they know, the greater their chances
    are of being able to exploit, and from a blue teams/SOC team's perspective, more
    information about the technology they have installed helps them prevent attacks
    being performed on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at exploiting bugs in the application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we identify the Jenkins instance in a black-box penetration test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any other ways to identify the Jenkins instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have identified the Jenkins instance from the HTTP headers, but the page isn't
    accessible. How can I make the page accessible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can I do once I have access to the Jenkins panel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links cover Jenkins exploits in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE: [https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins Security Advisory 2019-01-08: [https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266](https://jenkins.io/security/advisory/2019-01-08/#SECURITY-1266)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management with Grape: [http://docs.groovy-lang.org/latest/html/documentation/grape.html](http://docs.groovy-lang.org/latest/html/documentation/grape.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
