- en: Working with the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](text00137.html) , *Introduction to Kubernetes* , and [Chapter
    8](text00159.html) , *Using Kubernetes with Java* , we learned about the Kubernetes
    concepts and used them in practice by installing local Kubernetes clusters with
    `minikube` . We know all the pieces of Kubernetes architecture, such as pods,
    nodes, deployment, and services, for example. We have also mentioned one of the
    main components residing on the Master node, which is the API server. As you remember
    from [Chapter 7](text00137.html) , *Introduction to Kubernetes* , the API server
    is technically a process named `kube-apiserver` that accepts and responds to `HTTP
    REST` requests using JSON. The API server's main purpose is to validate and process
    data of cluster resources, such as Pods, services, or deployments. The API Server
    is the central management entity. It's also the only Kubernetes component that
    directly connects to `etcd` , a distributed key-value data store where Kubernetes
    stores all its cluster state.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we've been using a `kubectl` command-line tool to manage
    our cluster. `Kubectl` is a useful utility, whenever we want to execute commands
    against our cluster, either for creating, editing, or removing resources. In fact
    `kubectl` also communicates with the API server; you may have noticed that almost
    every action in Kubernetes that changes something is basically editing a resource.
    If you want to scale up or down your application, this will be done by modifying
    the deployment resource. Kubernetes will pick up the change on the fly and apply
    it to the resource. Also, read-only operations such as listing Pods or deployments,
    will execute the corresponding `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you can see what `REST` calls are being made by the `kubectl` command
    if you run it with a higher level of verbosity, with the `--v=6` or `--v=9` option,
    we will get back to it later in this chapter. We can access the API using `kubectl`
    , `client` libraries, or by making `REST` requests. When can the `REST` API be
    useful? Well, you can create a `REST` call in every programming or scripting language.
    This creates a whole new level of flexibility, you can manage Kubernetes from
    your own Java application, from your continuous delivery flow in Jenkins, or from
    the build tool you are using, let it be Maven for example. Possibilities are almost
    endless. In this chapter, we will get to know the API overview, its structure,
    and example requests. We will be doing this using the `REST` calls with the command-line
    `curl` utility. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation about the API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication (determining who is who)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization (determining who can do what)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the API by making some example calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAPI Swagger documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's gets started with an API overview.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes grows continuously. Its features change and this results in the
    API changing as well. To deal with those changes and to not break compatibility
    with existing clients over an extended period of time, Kubernetes supports multiple
    API versions, each with a different API path, such as `/api/v1` or `/apis/extensions/v1beta1`
    . There are three API levels in the Kubernetes API specification: alpha, beta,
    and stable. Let''s get to know the difference.'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The alpha version level is disabled by default, as with the other software,
    an alpha version should be considered as buggy and not production ready. Also,
    you should note that any featured introduced in the alpha version might not always
    be available later, in the stable version. Also, the changes in the API may be
    incompatible in the next release. You should not use the `alpha` version, unless
    you are very eager to test new features or do some experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Beta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beta level totally different from the `alpha` level of the API, code is
    tested (it still may have some bugs, as it is still not the `stable` release).
    Also, in contrast to the `alpha` level, features in `beta` will not be dropped
    in the future releases. If there is a breaking, not backward compatible change
    in the API, Kubernetes team will provide a guide on how to migrate. Using `beta`
    on a production environment is not the best idea, but you can safely use `beta`
    on a non-business critical cluster. You are also encouraged to provide feedback
    from using `beta` , this will make Kubernetes better for everyone of us using
    it. A version name in the `beta` level will contain the word `beta` , such as
    `v1beta1` for example.
  prefs: []
  type: TYPE_NORMAL
- en: Stable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stable level of the API is a tested, production-ready software. The version
    name in the stable API will be `vX` where `X` is an integer number, such as `v1`
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes API utilizes a concept of API groups. API groups have been introduced
    to make it easier to extend the Kubernetes API in the future. The API group is
    specified in a `REST` path and in the `apiVersion` field of a call''s JSON payload.
    Currently, there are several API groups in use: core, batch, and extensions. The
    group name is a part of the `REST` path of an API call: `/apis/$GROUP_NAME/$VERSION`
    . The core group is an exception, it does not show up in the `REST` path, for
    example: `/api/v1` **.** You can find the full list of supported API groups in
    the Kubernetes API reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the API, you can do almost anything with your cluster, as you would
    normally do using the `kubectl` command. This can be dangerous; that''s why Kubernetes
    supports authentication (determining who you are) and authorization (what you
    can do). The basic flow of calling the API service is presented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's begin with the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the Kubernetes API server serves `HTTP` requests on two ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Localhost** , **unsecured port** : By default, the IP address is `localhost`
    and a port number is `8080` . There is no TLS communication, all requests on this
    port bypasses authentication and authorization plugins. This is intended for testing
    and bootstrap, and for other components of the master node. This is also used
    to other Kubernetes components such as scheduler or controller-manager to execute
    API calls. You can change the port number with the `--insecure-port` switch, and
    the default IP by using the `--insecure-bind-address` command-line switch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure port** : The default port number is `6443` (it can be changed with
    the ``--secure-port` switch), usually it''s `443` on Cloud providers. It uses
    TLS communication. A certificate can be set with a `--tls-cert-file` switch. A
    private SSL key can be provided with a `--tls-private-key-file` switch. All requests
    coming through this port will be handled by authentication and authorization modules
    and admission control modules. You should use the secure port whenever possible.
    By having your API clients verify the TLS certificate presented by the `api-server`
    , they can verify that the connection is both encrypted and not susceptible to
    man-in-the-middle attacks. You should also be running the `api-server` where the
    insecure port is only accessible to localhost, so that connections that come across
    the network use `HTTP` ''s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With minikube, to access the API server directly, you'll need to use the custom
    SSL certs that have been generated by minikube. The client certificate and key
    are typically stored in `~/.minikube/apiserver.crt` and `~/.minikube/apiserver.key`
    . You'll have to load them into your `HTTP` 'S client when you make `HTTP` requests.
    If you're using `curl` use the`--cert` and the `--key` options to use the `cert`
    and `key` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access to the API server can be simplified through the proxy, which we will
    start later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to send requests to the Kubernetes API from a different domain,
    you will need to enable `cors` on `api-server` . You do that by adding a `--cors-allowed-origins=["http://*"]`
    argument to `kube-apiserver` configuration, typically in the `/etc/default/kube-apiserver`
    file and restart `kube-apiserver` .
  prefs: []
  type: TYPE_NORMAL
- en: Note that Kubernetes cluster does not manage users by itself. Instead, users
    are assumed to be managed by an outside, independent service. There is no resource
    in Kubernetes cluster that represents normal user accounts*.* That's why users
    cannot be added to a cluster through an API call.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes does not manage user accounts by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes API supports multiple forms of authentication: `HTTP` basic
    auth, bearer token, and client certificates. They are called authentication strategies.
    When launching the `api-server` , you can enable or disable each of these authentication
    strategies with command-line flags. Let''s look what''s possible, starting with
    the simplest, basic auth strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP basic auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use this authentication strategy, you will need to start the `api-server`
    with the `--basic-auth-file=<path_to_auth_file>` switch. It should be a `csv`
    file with the following entry for each user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify an optional fourth column containing group names, separated
    by a comma. If there is more than one group for the user, the whole column contents
    must be enclosed in double quotes, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `api-server` utilizes the basic auth strategy, it will expect all `REST`
    calls to be made with the `Authorization` header containing username and password
    encoded in `BASE64` (similar to ordinary basic auth protected web calls), for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate the authorization header value, you can use the following command
    in the shell, it will generate the value for user having password secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that any changes to the basic `auth` file will require a restart of the
    `api-server` to pick up the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTP` basic auth is typically used as default when running Kubernetes in the
    cloud. For example, once you launch your container cluster on Google Container
    Engine, you will have a master running the `api-server` on a VM in your GCP project.
    If you run a `gcloud preview container clusters` list, you will see the endpoint
    at which the `api-server` listens for requests as well as the credentials needed
    to access it. You will find more on running Kubernetes in the cloud in [Chapter
    10](text00205.html) , *Deploying Java on Kubernetes in the Cloud* .'
  prefs: []
  type: TYPE_NORMAL
- en: Static token file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make `api-server` use this scheme, it needs to be started with the `--token-auth-file=<PATH_TO_TOKEN_FILE>`
    switch. Similar to the `HTTP` basic auth strategy, the provided file is a `csv`
    file with a record for every user. The record needs to be in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the group name is optional and if there is more than one group for the
    user, you will need to separate them with a comma and enclose them in double quotes.
    The token is just a `base64` encoded string. An example command to generate a
    token on Linux can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be a token, which you then enter into the `token` file, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When using this strategy, `api-server` will be expecting an `Authorization`
    header with a value of `Bearer <` `TOKEN>` . In our example, this will looks the
    same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tokens last indefinitely, and the token list cannot be changed without restarting
    API server.
  prefs: []
  type: TYPE_NORMAL
- en: Client certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use this scheme, the `api-server` needs to be started with the
    following switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CA_CERTIFICATE_FILE` must contain one or more certificates authorities
    that can be used to validate client certificates presented to the `api-server`
    . The /CN (common name) of the client certificate is used as the username. Client
    certificates can also indicate a user''s group memberships using the organization
    fields. To include multiple group memberships for a user you will need to include
    multiple organization fields in the certificate. For example, using the `openssl`
    command-line tool to generate a certificate signing request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This would create a certificate signing request for the username `user` , belonging
    to two groups, `group1` and `group2` .
  prefs: []
  type: TYPE_NORMAL
- en: OpenID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenID connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol.
    You can read more about OpenID connect on the internet at `https://openid.net/connect`
    . It allows clients to verify the identity of the end-user based on the authentication
    performed by an authorization server, as well as to obtain basic profile information
    about the end-user in an interoperable and `REST` -like manner. All cloud providers,
    including Azure, Amazon, and Google support OpenID. The main difference with `OAuth2`
    is the additional field returned with the access token called an `id_token` .
    This token is a **JSON Web Token** (**JWT** ) with well-known fields (user's email
    for example), signed by the server. To identify the user, the authenticator uses
    the `id_token` from the `OAuth2token` response as a bearer token. To use the OpenID
    authentication, you will need to log in to your identity provider, which will
    provide you with an `id_token` (and also standard OAuth 2.0 `access_token` and
    a `refresh_token` **)** .
  prefs: []
  type: TYPE_NORMAL
- en: Since all of the data needed to do the authentication is contained within the
    `id_token` , Kubernetes does not need to make an additional call to the identity
    provider. This is very important from the scalability purposes, every request
    is stateless.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a token value to the `kubectl` command, you will need to use the
    `--token` flag. Alternatively, you can add it directly to your `kubeconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the simplified flow of things that will happen if you execute a `HTTP`
    call to your `api-server` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` will send your `id_token` in an `authorization` header to the API
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server will validate the JWT signature by checking against the certificate
    named in the configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server will check to make sure the `id_token` hasn't expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server will make sure the user is authorized, and returns a response
    to `kubectl` if so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, anyone who has access credentials to the `api-server` has full access
    to the cluster. You can also configure more fine grained authorization policies,
    let's look at authorization now.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step after the successful authentication is to check what operations
    are allowed for the authenticated user. Kubernetes supports four types of authorization
    policy schemes as of today. To utilize the specific authorization schema, use
    the `--authorization-mode` switch when starting `api-server` . The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `<mode>` parameter contains an ordered list of authorization plugins that
    Kubernetes is supposed to authenticate users with. When multiple authentication
    plugins are enabled, the first one that will successfully authenticate the request
    will make Kubernetes skip executing all remaining plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The default authorization mode is `AlwaysAllow` , which allows all requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following authorization schemes are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webhook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlwaysDeny`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AlwaysAllow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's describe them, one by one, briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Attribute-Based Access Control** (**ABAC** ) policy will be used if you start
    the `api-server` with the `--authorization-mode=ABAC` option. This policy uses
    local files in which you can, in a flexible way, define permission every user
    should have. There is an additional option to provide a policy file: `--authorization-policy-file`
    , so the complete syntax to use this policy will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that any changes to policy file will require a restart of the `api-server`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'As you remember from [Chapter 7](text00137.html) , *Introduction to Kubernetes*
    , Kubernetes clusters use the concept of namespaces to group related resources,
    such as Pods, deployments, or services. The authorization schemas in the `api-server`
    ''s make use of these namespaces. The `ABAC` policy file syntax is rather clear
    and readable. Each entry is a JSON object describing the authorization rule. Consider
    the following entry in the policy file, which gives user `john` complete access
    to the namespace `myApp` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example will give user `admin` complete access to all the namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, an example that gives all users read-only access to the entire
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Role-Based Access Control** (**RBAC** ), policy implementation is deeply
    integrated into Kubernetes. In fact, Kubernetes uses it internally for the system
    components, to grant the permissions necessary for them to function. `RBAC` is
    100% API driven, roles and bindings are API resources that an administrator can
    write and create on the cluster such as other resources such as Pods, deployments,
    or services. Enabling `RBAC` mode is as easy as passing a flag to `kube-apiserver`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This mode allows you to create and store policies using the Kubernetes API.
    In the `RBAC` API, a set of permission is represented by the concept of role.
    There is a distinction between namespace roles, represented by a `Role` resource,
    and a whole cluster role, represented by a `ClusterRole` resource. A `ClusterRole`
    can define the same all permissions a `Role` can define, but also some cluster-related
    permission, such as managing cluster nodes or modifying resources across all available
    namespaces. Note that once `RBAC` is enabled, every aspect of the API is disallowed
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions are additive; there are no deny rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of role that gives the whole set of available permissions
    to all operations on all resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Role is a resource, as you remember from [Chapter 8](text00159.html) ,
    *Using Kubernetes with Java* , to create resource using the file, you execute
    the `kubectl create` command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Role` and `ClusterRole` defines the set of permissions, but does not assign
    them to users or groups directly. There is another resource for that in Kubernetes
    API, which is `RoleBinding` or `ClusterRoleBinding` . They bind `Role` or `ClusterRole`
    to the specific subject, which can be user, group, or service user. To bind the
    `Role` or `ClusterRole` , you will need to execute the `kubectl create rolebinding`
    command. Take a look at the following examples. To grant the `adminClusterRole`
    to a user named `john` in the namespace `myApp` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next one will grant the `cluster-admin ClusterRole` to a user named `admin`
    across the entire cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent YAML file to use with `kubectl create -f` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: WebHook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `api-server` is started with the `--authorization-mode=Webhook` option,
    it will make calls to external `HTTP` server to authorize the user. This gives
    you the capability to create your own authorization servers. In other words, a
    WebHook is an `HTTP` callback mode that allows you to manage authorization using
    a remote `REST` server, either developed on your own, or a third-party authorization
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing the authorization check, the `api-server` will execute a `HTTP POST`
    request, with a JSON payload containing a serialized `api.authorization.v1beta1.SubjectAccessReview`
    object. This object describes the user making request to the `api-server` , the
    action which this user would like to execute, and the details about the resource
    being the subject of this action. An example request payload could look like the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The remote authorization server should provide a response, saying if this user
    is authorized to execute the specified action on a specified resource. The response
    should contain the `SubjectAccessReviewStatus` field, specifying if the `api-server`
    should either allow or disallow access. A permissive JSON response would looks
    the same as the this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The negative response will appear as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Having the possibility to delegate the authorization to another service makes
    the authorization process very flexible, imagine your own software that authorizes
    a user to do certain things in your cluster depending on the roles they have in
    the corporate `LDAP` directory for example.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysDeny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This policy denies all requests. If will be used if you start the `api-server`
    with a `--authorization-mode=AlwaysDeny` switch. This can be useful if you are
    doing some testing or would like to block incoming requests without actually stopping
    the `api-server` .
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysAllow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you start the `api-server` with `--authorization-mode=AlwaysAllow` , all
    requests will be accepted, without using any authorization schema. Use this flag
    only if you do not require authorization for your API requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the authentication and authorization possibilities in Kubernetes
    are very flexible. On the diagram at the beginning of this chapter we have seen
    the third phase of the API call flow: the admission control. What role does the
    admission control play? Let''s find out.'
  prefs: []
  type: TYPE_NORMAL
- en: Admission control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An admission control plug-in intercepts requests to the Kubernetes API server
    after the request is authenticated and authorized, but prior to making any changes
    to the API resource. These plug-ins run in sequence, before a request is accepted
    into the cluster. The Kubernetes API server supports a flag, `admission-control`
    that takes a comma-delimited, ordered list of admission control plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an overview of how the API call looks the same, let's actually
    make some use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API reference is a detailed document, available on the internet [https://kubernetes.io/docs/api-reference/v1.6/](https://kubernetes.io/docs/api-reference/v1.6/)
    ; [of course the API version will change in the future, `v1.6` was the current
    one at the time of writing.](https://kubernetes.io/docs/api-reference/v1.6/)
  prefs: []
  type: TYPE_NORMAL
- en: Before we make some actual calls to the `api-server` , it's worth knowing that
    `kubectl` also communicates with Kubernetes cluster using the API. As we mentioned
    earlier, you can see what `REST` calls are being made by the `kubectl` command.
    Looking at what's being sent to the server during the usage of `kubectl` is a
    great way to become familiar with Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: To see `REST` requests being executed by `kubectl` , run it with a higher level
    of verbosity, for example with a `--v=6` or `--v=9` option.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start making actual `REST` calls, let's briefly see what API operations
    are possible.
  prefs: []
  type: TYPE_NORMAL
- en: API operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes API defines the CRUD (create, update, read, and delete) set of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Create` : Create operations will create the resource in the cluster. The JSON
    payload that you will need to provide with your `REST` call is the resource manifest.
    It''s the equivalent of the YAML file we''ve been constructing in the [Chapter
    8](text00159.html) , *Using Kubernetes with Java* . This time, it will be in the
    JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update` : The update operation can be either `Replace` or `Patch` . A `Replace`
    will simply replace the whole resource object (a Pod, for example) with the provided
    spec. A `Patch` , on the other hand, will apply a change only to a specific field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Read` : A read operation can be either `Get` , `List,` or `Watch` . By executing
    `Get` , you will be given a specific resource object by its name. Executing `List`
    will retrieve all resource objects of a specific type within a namespace. You
    can use the selector query. A special form of the `List` operation is `List All
    Namespaces` , as the name says this will retrieve resources across all namespaces.
    A `Watch` operation will stream results for an object or a of list objects as
    they are updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete` : Will simply delete a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes `api-server` also exposes some additional, resource-specific operations.
    This includes `Rollback` , which rollbacks a Pod template to a previous version
    or read /write scale, which reads or updates the number of replicas for the given
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Example calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following examples, we will be using a command-line `HTTP` client, `curl`
    . You are not limited to `curl` , you can freely use the `HTTP` client you find
    convenient. Using the `HTTP` client with the user interface is often very handy,
    they usually present the `HTTP` response in a structured form and sometimes also
    do some request validation, if it's well formed. My recommended GUI clients will
    be Postman (for Windows, Linux, or Mac), or PAW for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before making any calls, let''s first start a proxy to the Kubernetes API server.
    The `kubectl` needs to be configured first, to be able to communicate with your
    cluster. In our local Kubernetes installation with `minikube` , the `kubectl`
    command will be automatically configured. To start a proxy to the `api-server`
    , execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While the proxy session is running, any request sent to `localhost:8000` will
    be forwarded to the Kubernetes API server. To check if our `api-server` is running,
    let''s ask for the API version it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `api-server` is running and waiting for incoming requests, it should
    give you an output similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It seems to be running fine; let's continue and make some use of the exposed
    API, starting, the same as previously, by creating a service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service using the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a service manifest file. Note that if you have your services,
    deployments, and Pods created in [Chapter 8](text00159.html) , *Using Kubernetes
    with Java* , by using the `kubectl` , you will need to delete them using `kubectl`
    or the Kubernetes dashboard. We are going to use the same names for the service
    and a deployment. When using `curl` with larger payloads, it''s more convenient
    to have the payload in the external file and not type it in the command-line.
    The JSON file that we will use as the payload is very similar to the one we have
    been using when creating a Pod with `kubectl` , but in JSON format this time.
    Let''s create a file named `service.json` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the contents of the JSON file are basically identical to the one we've
    been using when we were creating resources using YAML files. Yes, you can clearly
    see how the `kubectl` command is implemented, it just creates a JSON payload from
    the file input, there is no magic behind the scenes, at all.
  prefs: []
  type: TYPE_NORMAL
- en: You can convert between YAML to JSON and vice-versa using one of the YAML/JSON
    converters available online. The Kubernetes `api-server` will accept such JSON
    as `Kubectl` accepts the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having our JSON file ready, the next step is to create the service resource
    in our cluster by invoking the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Having our service defined, let's create a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a deployment using the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a deployment is very similar to creating a service, it''s creating
    another type of Kubernetes resource, after all. All we need is a proper JSON payload
    file that we will be sending to the `api-server` using the `POST HTTP` method.
    Our `rest-example` deployment manifest in JSON can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save the file using the `deployment.json` filename. Again, all we need
    to do now is to post this file to the `api-server` . This process is very similar
    to the creation of the service, it will be just a `POST` to the different endpoint
    with a different payload. To create a deployment from the shell using `curl` ,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you should note that deployment related API commands
    are in another API group: `extensions` . That''s why the endpoint will have a
    different `REST` path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing those two `REST HTTP` requests, we should have our service
    and deployment created in the cluster. Of course, because of the deployment manifest
    contains the number of replicas with the value `1` , one Pod will be created as
    well. Let''s check if it''s true, by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, all of the resources exist on our
    cluster. This time, however, they were created by two simple `HTTP POST` requests
    to the Kubernetes `api-servers` , without using `kubectl` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have said before that we can observe what `HTTP` requests are being executed
    by the `kubectl` tool. Let''s verify that. We will execute the last command to
    get the list of Pods, but with additional verbosity level, the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s a bunch of log lines about getting information from the cluster cache,
    but the last line is especially interesting, it contains the actual `HTTP` request
    being made by `kubectl` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run the `curl GET` command using this URL, all the authentication
    and authorization mechanisms would come into play. But having the `api-server`
    proxy running, we can skip authorization and authentication by executing the call
    on the proxied port (note that `curl` executes the `GET` method by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As the output, you will be given the JSON response containing detailed information
    about Pods in your cluster. The API is working, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deleting a service and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you decide it''s time to do some clean up, you may delete the service and
    the deployment by executing the `HTTP DELETE` request, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finding out the proper API operation `REST` paths (endpoints) can be very inconvenient
    just by looking at the web documentation or by spying what URLs are being called
    by `kubectl` . There's a better way of doing this; OpenAPI specification of the
    Kubernetes `api-server` . Let's look at how we can get this specification.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger docs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes `api-server` provides the list of available API commands by utilizing
    the OpenAPI specification. The OpenAPI Specification defines a standard, language-agnostic
    interface to `REST` APIs that allows both humans and computers to discover and
    understand the capabilities of the service without access to source code, documentation,
    or through network traffic inspection. It's very convenient to browse the API
    commands catalogue using the SwaggerUI tool that comes with Kubernetes `api-server`
    . You can also execute the `HTTP` commands using SwaggerUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the SwaggerUI is not enabled by default if you are running the local
    cluster using Minikube. You will need to enable it during the cluster startup,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the `api-server` proxy still running using port `8080` , visit the following
    host in your web browser to see the SwaggerUI screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be presented with a list of available API commands, grouped into API
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding each API section will give you all the available endpoints with the
    description of each operation. The SwaggerUI is a great tool to explore an API
    in a clear and readable form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the API exposed by Kubernetes is a very powerful tool in your
    arsenal. Any task that can be performed through the dashboard or `kubectl` client
    is exposed as an API. You can do almost anything with your cluster simply by utilizing
    `HTTP` calls. Kubernetes takes an API-first approach that makes it programmable
    and extensible. As we have seen it is easy to get started with the API. Our service
    and deployment creating examples, may be simple but should give you an idea how
    to experiment with the `api-server` . Using the API you can create and retrieve
    cluster resources not only from the command-line using `kubectl` , but also from
    your own application, build scripts, or continuous delivery pipelines. Only your
    imagination and the sky is the limit, and speaking of the sky, it's time to move
    there and see how Kubernetes can be used in the cloud.
  prefs: []
  type: TYPE_NORMAL
