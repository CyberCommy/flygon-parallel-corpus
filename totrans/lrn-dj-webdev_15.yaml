- en: Chapter 15. What's Next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web development has evolved over time and so have the devices where users consume
    information. The Web was designed for large-screen devices earlier, but recent
    trends show that consumption of the devices with small screen size and the devices
    that can be held in hand has increased. Thus, here arises the need to mold the
    Web to serve small-screen devices, but these devices are very power sensitive.
    So, there is the need to separate the backend functions from the frontend functions
    in Django.
  prefs: []
  type: TYPE_NORMAL
- en: One such most widely used solution is to use Django backend with an API enabled
    at the frontend to use it with Django. Using **AngularJS** for such a situation
    is most suited.
  prefs: []
  type: TYPE_NORMAL
- en: REST has been the future of web development and REST APIs are rather an integral
    part of the modern Web. As the fragmentation across a device increases, there
    arises a need of single minimal endpoint, which does not perform any presentation
    operation. For instance, the information retrieval or commutation could be as
    fast as possible and could also be scaled, and the presentation or business logic
    for this is left in the hands of modern browsers using a frontend framework.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS meets Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS is a modern JavaScript framework used to create complex web applications
    within a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Since the birth of AngularJS in 2009, it has been evolving very fast and is
    being widely accepted as a production-grade frontend framework. It is now maintained
    by Google.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS has a very interesting birth story. It got its big attention when
    one of the creators of angular recreated a web application in 3 weeks, which initially
    took 6 months to develop, by reducing the number of lines of code from 17,000
    to 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS has many features over conventional web development frameworks. Among
    them, a few unique and innovative features are two-way data bindings, dependency
    injection, easy-to-test code, and extending the HTML dialect using directives.
  prefs: []
  type: TYPE_NORMAL
- en: For the server side, we can use the **Django REST Framework** or **Tastypie**
    for REST endpoints. Then, we can use AngularJS, which focuses on the MVC model,
    to encourage the creation of easily maintainable modules.
  prefs: []
  type: TYPE_NORMAL
- en: Web technologies have evolved from synchronous to asynchronous, that is, the
    website requests now heavily use asynchronous calls to refresh its content without
    reloading the page, an example of which is your Facebook wall.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS is one of the solutions for the asynchronous need in a better way
    for Django web development.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will use AngularJS to create a single page, which
    uses the tweet's API that we already created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use AngulaJS to list all the tweets, but before that, we need to get
    familiarized with AngularJS''s key terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directives**: For this, the HTML file is extended with custom attributes
    and elements. AngularJS extends the HTML with **ng-directives**. The **ng-app**
    directive is used to define AngularJS''s application. The **ng-model** directive
    binds the value of HTML controls (input, checkbox, radio, select, and text area)
    to the application. The **data.ng-bind** directive binds the application data
    to the HTML view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: This is the data shown to the user in the view and with which the
    user interacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: This is the context where the model is stored, so that controllers,
    directives, and expressions can access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This is the main business logic behind views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we design an API-based web application, there is a high chance that both
    (the API's backend and the webapp frontend) of them reside on different servers.
    Thus, there arises a need to configure Django for **Cross-origin resource sharing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the definition explained on Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cross-origin resource sharing (CORS) is a mechanism that allows many resources
    (for example, fonts, JavaScript, and so on) on a web page to be requested from
    another domain outside the domain from which the resource originated.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We need to alter our Django API to allow requests from other servers as well.
    We will now update the `api.py` file of the `tweets` application to allow `the
    requests` to the server cross-site request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After adding this class, we can create a subclass of any resource that we want
    to expose for a cross-domain request. We will now change our `Tweet` class to
    make it available for cross-site access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `Tweet` class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the tweet resource is ready for access from different domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a basic AngularJS example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a single HTML file called `app.html` (as this file is independent of
    our existing Django project, we can create it outside the project folder) with
    the following content. Currently, this page uses AngularJS from a local disk,
    you can import the page from a CDN as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the following code, the `ng-controller` directive is triggered at its render
    time, which processes any business logic and injects the calculated models inside
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: The `<div ng-controller="tweetController">` tag is one example where the `tweetController`
    parameter is processed before its `div` is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our business logic completely in JavaScript in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `app.js` file makes a request to the API endpoint of tweets and injects
    the `tweets` object to the scope, which is rendered by the AngularJS in view (`app.html`)
    with the `ng-repeat` loop directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown in the following figure, which shows
    the country and tweets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AngularJS meets Django](img/image00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is just a basic AngularJS application, as advanced web development has
    moved from backend to frontend completely. An AngularJS-based application is best
    suited for a complete single-page application.
  prefs: []
  type: TYPE_NORMAL
- en: Django search with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Search has become an integral part of most of the applications we deal with
    nowadays. From Facebook, to search for a friend, to Google, where you search the
    whole Web, everything from blog to log needs a search capability to unlock the
    hidden information on a website.
  prefs: []
  type: TYPE_NORMAL
- en: The Web is evolving at an exponential rate. A GB of data is now obsolete and
    hundreds of terabytes of both structured and unstructured data is generated every
    day.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch** (**ES**) is better than other alternatives because, in addition
    to providing full-text search, it provides meaningful real-time data analytics
    and is highly scalable with a strong support for clustered data infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch also gives you a simple REST API that can easily integrate with
    any custom application and a Django (and more broadly, Python) development environment
    gives a lot of cool, out-of-the-box tools to implement Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: The Elasticsearch website ([http://www.elasticsearch.org/](http://www.elasticsearch.org/))
    contains a thorough documentation and there are lots of great examples online
    that will help you build any kind of search you need. By making full use of Elasticsearch,
    you can probably build your own "Google" with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an Elasticsearch server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, install Java. Then, download and extract Elasticsearch. You can either
    run ES as a service or you can start an ES server using the following Shell commands
    (change paths in accordance with your system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is done correctly, you can call the following URL in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:9200/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will give you a response in the following way, but with a different `build_hash`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Elasticsearch comes with basic configurations for basic deployment. However,
    if you want to tweak the configuration, then refer to its online documents and
    change the Elasticsearch configuration in the `elasticsearch.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between Elasticsearch and Django
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Django can be seamlessly integrated with Elasticsearch using basic Python programming.
    In this example, we will use the Python requests library to make the request from
    Django to Elasticsearch We can install requests by typing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the search functionality, there are mainly three operations that we need
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Elasticsearch index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed the index with data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the search results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an Elasticsearch index
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before loading an Elasticsearch index with text and retrieving the search results,
    Elasticsearch has to know some details about your content and how data should
    be treated. Therefore, we create an ES index that consists of settings and mappings.
    **Mappings** are the ES equivalents of Django's models—data field definitions
    for your content.
  prefs: []
  type: TYPE_NORMAL
- en: Although mappings are completely optional, as Elasticsearch dynamically creates
    a mapping from the information that it has got for indexing, but it is advised
    that you predefine the data map for indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python example for creating an ES index is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an Elasticsearch index](img/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For every operation done with Elasticearch, it gives a response message such
    as `{"acknowledged":true}`, which means that our index has been created successfully
    by Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether the mapping has actually been updated or not by making
    a query command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows that Elasticsearch has been updated with the new
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an Elasticsearch index](img/image00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After we created our first Elasticsearch index, we created the JSON dictionary
    with the information and dumped this information into Elasticsearch via Python
    requests. The **"contacts"** parameter is the index name we have choosen and we
    will use this name to feed and retrieve data from the Elasticsearch server. The
    **"mappings"** key describes what data your index will hold. We can have as many
    different mappings as we like. Every mapping contains a field in which data is
    stored, exactly, like a Django model. Some of the basic core fields are string,
    number, data, Boolean, and so on. The full list is given in the Elasticsearch
    documentation. The "shards" and "replicas" parameters are explained in the ES
    glossary. Without the "settings" key, ES would simply use the default values—which
    in most cases is perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding the index with data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have created an index, let''s store content inside it. An example
    Python code for our imaginary BlogPost model that contains a title, description,
    and content as text fields is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Feeding the index with data](img/image00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This acknowledgment shows that our contact data has been indexed. Of course,
    indexing a single data and searching it does not makes much sense, so we will
    index more contacts before we make a retrieval query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elasticsearch also provides bulk indexing, which can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Feeding the index with data](img/image00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, the **"status": 201** parameter,
    which in the HTTP status means that the record is successfully created. Elasticsearch
    reads data line by line, so we used **"\n"** at the end of every dataset. Bulk
    operations are much faster than running the multiple single request.'
  prefs: []
  type: TYPE_NORMAL
- en: This example is a simple JSON example. When we use Elasticsearch with our Django
    application, the same JSON object can be replaced by the Django model and to index
    the model, you can get all the Django model objects from the `ModelName.objects.all()`
    query and then parse and save it. Also, in the case of the manual ID, as we used
    in the preceding example, which is the index count, it will be much more convenient
    if you use a primary key to index it as an Elasticsearch ID. This will help us
    to directly query for a result object if we are not passing the object information
    as a payload.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving search results from the index
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Searching an index is rather simple. Again, we use Python requests to send
    a JSON-encoded data string to our ES endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a result, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving search results from the index](img/image00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the example, we are looking for the term **"raj"** in our contacts index.
    ES returns all the hits ordered by relevancy in the JSON-encoded format. Each
    of these hits contains an **"_id"** field that gives you the primary key of the
    concerned blog post. Using Django's ORM, it's now simple to retrieve the actual
    objects from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ES search endpoint offers an unlimited set of options and filters; fast
    retrieval from huge datasets, pagination, and everything you need to build a powerful
    search engine.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg. When you will build your Django application
    with Elasticsearch, you will explore many interesting features, such as aggregation,
    which can be used in the preceding example. It lists all the contact information
    of Ratan and autocomplete, which will be used to suggest a user the complete name
    from Elasticsearch, as they start typing in the search box for a contact.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the two important components that are used
    most often when the Django project is involved, namely, AngularJS and Elasticsearch.
    As frontend framework, AngularJS not only decreases the load from the server by
    pushing the render logic to a browser, it also gives a rich experience to the
    users when using an AngularJS-powered application.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch, on the other hand, is one of the most popular search engines
    used, which is open source as well. The ease of setting up and scaling Elasticsearch
    is what makes it the choice for any search engine requirement. You learnt a bit
    about Django as well. As the chapter started, we're sure that you'll had the aim
    of learning a skill and of becoming experts in it. Well, this is just the beginning;
    there are more things that you need to explore to reach at the expert level in
    each topic that was discussed in this chapter. We have reached at the end of this
    book. In this book, we went through the process of building a micro blogging application
    from scratch using Django as our framework. We covered a lot of topics related
    to Web 2.0 and social applications, as well as many Django components. You can
    always refer to the online documentation of Django. If you want to learn more
    about a particular feature or component, visit [https://docs.djangoproject.com](https://docs.djangoproject.com).
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for choosing this book to learn the Django web development basics. We
    wish you all the success in your professional life.
  prefs: []
  type: TYPE_NORMAL
