- en: '*Chapter 14*:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the most popular sorting and searching algorithms that are
    encountered in technical interviews. We will cover sorting algorithms such as
    Merge Sort, Quick Sort, Radix Sort, Heap Sort, and Bucket Sort, and searching
    algorithms such as Binary Search.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to tackle a wide range of problems
    that involve sorting and searching algorithms. We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the code files for this chapter on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering the sorting algorithms from the perspective of a person preparing
    for an interview reveals two main categories: a category containing a lot of relatively
    simple sorting algorithms that don’t occur in interviews, such as Bubble Sort,
    Insertion Sort, Counting Sort, and so on, and a category containing Heap Sort,
    Merge Sort, Quick Sort, Bucket Sort, and Radix Sort. These represent the top five
    sorting algorithms that occur in technical interviews.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the simple sorting algorithms, then I strongly
    recommend that you buy my book, *Java Coding Problems* ([www.packtpub.com/programming/java-coding-problems](http://www.packtpub.com/programming/java-coding-problems)),
    published by Packt. In [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*,
    Arrays, Collections, and Data Structures*, of *Java Coding Problems*, you can
    find detailed coverage of Bubble Sort, Insertion Sort, Counting Sort, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the application called *SortArraysIn14Ways* contains the implementations
    of 14 different sorting algorithms that you should know. The complete list is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble Sort with a `Comparator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble Sort optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble Sort optimized with a `Comparator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pancake Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion Sort with a `Comparator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap Sort with a `Comparator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bucket Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cocktail Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycle Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick Sort with a `Comparator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radix Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following sections, we will have a brief overview of the main algorithms
    that are encountered in interviews: Heap Sort, Merge Sort, Quick Sort, Bucket
    Sort, and Radix Sort. If you are already familiar with these algorithms, then
    consider jumping directly to the *Searching algorithms* section, or even to the
    *Coding challenges* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Heap Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not familiar with the heap concept, then consider reading the *Binary
    Heaps* section of [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heap Sort is an algorithm that relies on a binary heap (a complete binary tree).
    The time complexity cases are as follows: best case O(n log n), average case O(n
    log n), worst case O(n log n). The space complexity case is O(1).'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting elements in ascending order can be accomplished via a Max Heap (the
    parent node is always greater than or equal to the child nodes), and in descending
    order via a Min Heap (the parent node is always smaller than or equal to the child
    nodes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Heap Sort algorithm has several main steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform the given array into a Max Binary Heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the root is swapped with the last element from the heap and the heap’s
    size is reduced by 1 (this is like deleting the root element of the heap). So,
    the greater element (the heap root) goes to the last position. In other words,
    the elements that are at the root of the heap come out one by one in sorted order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step consists of *heapifying* the remaining heap (apply the recursive
    process that reconstructs the max heap in a top-down manner).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 2* while the heap size is greater than 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram represents a test case of applying the Heap Sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Heap sort'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – Heap Sort
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s assume the array from the preceding diagram; that is, 4,
    5, 2, 7, 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the first step, we build the Max Heap: 7, 5, 2, 4, 1 (we swapped 5 with
    7, 4 with 7, and 4 with 5).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, swap the root (7) with the last element (1) and delete 7\. Result: 1,
    5, 2, 4, **7**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, we construct the Max Heap again: 5, 4, 2, 1 (we swapped 1 with
    5 and 1 with 4).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We swap the root (5) with the last element (1) and delete 5\. Result: 1, 4,
    2, **5, 7**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we construct the Max Heap again: 4, 1, 2 (we swapped 1 with 4).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We swap the root (4) with the last element (2) and delete 4\. Result: 2, 1,
    **4, 5, 7**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a Max Heap already, so we simply swap the root (2) with the last element
    (1) and remove 2: 1, **2, 4, 5, 7**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Done! There is a single element left in the heap (1). So, the final result is
    **1, 2, 4, 5, 7**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, the preceding example can be generalized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Heap Sort is not a stable algorithm. A stable algorithm guarantees the order
    of duplicate elements. The complete application is called *HeapSort*. This application
    contains an implementation based on `Comparator` as well – this is useful for
    sorting objects.
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s discuss the Merge Sort algorithm. The time complexity cases are
    as follows: best case O(n log n), average case O(n log n), worst case O(n log
    n). The space complexity may vary, depending on the chosen data structures (it
    can be O(n)).'
  prefs: []
  type: TYPE_NORMAL
- en: The Merge Sort algorithm is a recursive algorithm based on the famous *divide
    and conquer* strategy. Considering that you’ve been given an unsorted array, applying
    the Merge Sort algorithm requires you to continually split the array in half until
    we obtain empty sub-arrays or sub-arrays that contains a single element (this
    is *divide and conquer*). If a sub-array is empty or contains one element, it
    is sorted by its definition – this is the recursion *base case*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we haven’t reached the *base case* yet, we divide both these sub-arrays
    again and attempt to sort them. So, if the array contains more than one element,
    we split it and we recursively invoke the sort operation on both sub-arrays. The
    following diagram shows the splitting process for the 52, 28, 91, 19, 76, 33,
    43, 57, 20 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Splitting the given array in the merge sort algorithm](img/Figure_14.2_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Splitting the given array in the Merge Sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the splitting is done, we call the fundamental operation of this algorithm:
    the *merge* operation (also known as the *combine* operation). Merging is the
    operation of taking two smaller sorted sub-arrays and combining them into a single,
    sorted, new sub-array. This is done until the entire given array is sorted. The
    following diagram shows the merging operation for our array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Merging operation for merge sort'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Merging operation for Merge Sort
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the Merge Sort algorithm. The flow begins from
    the `sort()` method. Here, we begin by asking the *base case* question. If the
    size of the array is greater than 1, then we call the `leftHalf()` and `rightHalf()`
    methods, which will split the given array into two sub-arrays. The rest of the
    code from `sort()` is responsible for calling the `merge()` method, which sorts
    two unsorted sub-arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the merge operation places the elements back into the original array
    one at a time by repeatedly taking the smallest element from the sorted sub-arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `left[t1] <= right[t2]` statement guarantees that the algorithm
    is stable. A stable algorithm guarantees the order of duplicate elements.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is called *MergeSort*.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quick Sort is another recursive sorting algorithm based on the famous *divide
    and conquer* strategy. The time complexity cases are as follows: best case O(n
    log n), average case O(n log n), worst case O(n2). The space complexity is O(log
    n) or O(n).'
  prefs: []
  type: TYPE_NORMAL
- en: The Quick Sort algorithm debuts with an important choice. We have to choose
    one of the elements of the given array as the *pivot*. Next, we partition the
    given array so that all the elements that are less than the *pivot* come before
    all the elements that are greater than it. The partitioning operation takes place
    via a bunch of swaps. This is the *divide* step in *divide and conquer*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the left and the right sub-arrays are again partitioned using the corresponding
    pivot. This is achieved by recursively passing the sub-arrays into the algorithm.
    This is the *conquer* step in *divide and conquer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst case scenario (O(n2)) takes place when all the elements of the given
    array are smaller than the chosen pivot or larger than the chosen pivot. Choosing
    the pivot element can be done in at least four ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the first element as the pivot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the end element as the pivot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the median element as the pivot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the random element as the pivot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the array 4, 2, 5, 1, 6, 7, 3\. Here, we’re going set the pivot as
    the end element. The following diagram depicts how Quick Sort works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Quick sort'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Quick Sort
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: We choose the last element as the pivot, so 3 is the pivot. Partitioning
    begins by locating two position markers – let’s call them *i* and *m*. Initially,
    both point to the first element of the given array. Next, we compare the element
    at position *i* with the pivot, so we compare 4 with 3\. Since 4 > 3, there is
    nothing to do, and *i* becomes 1 (*i*++), while *m* remains 0\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: We compare the element at position *i* with the pivot, so we compare
    2 with 3\. Since 2<3, we swap the element at position *m* with the element at
    position *i*, so we swap 4 with 2\. Both *m* and *i* are increased by 1, so *m*
    becomes 1 and *i* becomes 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: We compare the element at position *i* with the pivot, so we compare
    5 with 3\. Since 5 > 3, there is nothing to do, so *i* becomes 3 (*i*++), while
    *m* remains as 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**: We compare the element on position *i* with the pivot, so we compare
    1 with 3\. Since 1 < 3, we swap the element at position *m* with the element at
    position *i*, so we swap 1 with 4\. Both *m* and *i* are increased by 1, so *m*
    becomes 2 and *i* becomes 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5 and 6**: We continue to compare the element at position *i* with the
    pivot. Since 6>3 and 7 > 3, there is nothing to do at these two steps. After these
    steps, *i*=7.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 7**: The next element for *i* is the pivot itself, so there are no more
    comparisons to perform. We just swap the element at position *m* with the pivot,
    so we swap 5 with 3\. This brings the pivot to its final position. All the elements
    from its left are smaller than it, while all the elements from its right are greater
    than it. Finally, we return *m*.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the algorithm is repeated for the array bounded by 0 (*left*) and
    *m*-1 and for the array bounded by *m*+1 and the array’s end (*right*). The algorithm
    is repeated as long as *left*<*right* is true. When this condition is evaluated
    as false, the array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode for the quick sort algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the entire array, we call `sort(array, 0, array.length-1)`. Let’s see
    its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Quick Sort can swap non-adjacent elements; therefore, it is not stable. The
    complete application is called *QuickSort*. This application contains an implementation
    based on `Comparator` as well – this is useful for sorting objects.
  prefs: []
  type: TYPE_NORMAL
- en: Bucket Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bucket Sort (or Bin Sort) is another sorting technique that’s encountered in
    interviews. It is commonly used in computer science and useful when the elements
    are uniformly distributed over a range. The time complexity cases are as follows:
    the best and average cases O(n+k), where O(k) is the time for creating the bucket
    (this will be O(1) for a linked list or hash table), while O(n) is the time needed
    to put the elements of the given array into the bucket (this will also be O(1)
    for a linked list or hash table). The worst case is O(n2). The space complexity
    is O(n+k).'
  prefs: []
  type: TYPE_NORMAL
- en: Its climax relies on dividing the elements of the given array into groups that
    are called *buckets*. Next, each bucket is sorted individually using a different
    suitable sorting algorithm or using the bucket sorting algorithm via recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the buckets can be done in several ways. One approach relies on defining
    a number of buckets and filling each bucket with a specific range of elements
    from the given array (this is known as *scattering*). Next, each bucket is sorted
    (via bucket sorting or other sorting algorithms). Finally, the elements are collected
    from each bucket to obtain the sorted array (this is known as *gathering*). This
    is also known as the *scatter-sort-gather* technique and is exemplified in the
    following diagram. Here, we are using bucket sort on the 4, 2, 11, 7, 18, 3, 14,
    7, 4, 16 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Bucket sort via the scatter-sort-gather approach'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Bucket Sort via the scatter-sort-gather approach
  prefs: []
  type: TYPE_NORMAL
- en: So, as the preceding diagram reveals, we have defined four buckets for the elements
    in intervals; that is, 0-5, 5-10, 10-15, and 15-20\. Each element of the given
    array fits into a bucket. After distributing all the elements of the given array
    into buckets, we sort each bucket. The first bucket contains elements 2, 3, 4,
    and 4\. The second bucket contains elements 7, 7, and so on. Finally, we gather
    the elements from the buckets (from left to right) and we obtain the sorted array;
    that is, 2, 3, 4, 4, 7, 7, 11, 14, 16, 18.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this, we can write the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation of this pseudocode using lists can be done as follows (the
    `hash()` methods that are being called in this code are available in the code
    bundled with this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach to creating buckets consists of putting a single element into
    a bucket, as shown in the following diagram (this time, there is no sorting involved):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Bucket sort via the scatter-gather approach'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – Bucket Sort via the scatter-gather approach
  prefs: []
  type: TYPE_NORMAL
- en: In this *scatter-gather* approach, we store the number of occurrences of an
    element in each bucket, not the element itself, while the position (the index)
    of the bucket represents the element value. For example, in bucket number 2, we
    store the number of occurrences of element 2, which in array 4, 2, 8, 7, 8, 2,
    2, 7, 4, 9 occurs three times. Since elements 1, 3, 5, and 6 are not present in
    the given array, their buckets are empty (have 0s in them). The gathering operation
    collects the elements from left to right and obtains the sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this, we can write the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation of this pseudocode may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Bucket Sort is not a stable algorithm. A stable algorithm guarantees the order
    of duplicate elements. The complete application is called *BucketSort*.
  prefs: []
  type: TYPE_NORMAL
- en: Radix Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Radix Sort is a sorting algorithm that works very well for integers. In Radix
    Sort, we sort the elements by grouping the individual digits by their positions
    in the numbers. Next, we sort the elements by sorting the digits at each significant
    position. Commonly, this is done via Counting Sort (the Counting Sort algorithm
    is detailed in the book *Java Coding Problems* ([www.packtpub.com/programming/java-coding-problems](http://www.packtpub.com/programming/java-coding-problems)),
    published by Packt, but you can find an implementation of it in the application
    called *SortArraysIn14Ways*). Mainly, sorting the digits can be done via any stable
    sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple approach to understanding the Radix Sort algorithm relies on an example.
    Let’s consider the array 323, 2, 3, 123, 45, 6, 788\. The following image reveals
    the steps of sorting this array by sequentially sorting the units, the tens, and
    the hundreds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Radix sort](img/Figure_14.7_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Radix Sort
  prefs: []
  type: TYPE_NORMAL
- en: So, first, we sort the elements based on the digit corresponding to the unit
    place. Second, we sort the elements based on the digit corresponding to the tenth
    place. Third, we sort the elements based on the digit corresponding to the hundreds
    place. Of course, depending on the maximum number from the array, the process
    continues with thousands, ten thousands, and so on until no more digits are left.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an implementation of the Radix Sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of Radix Sort depends on the algorithm that’s used to sort
    the digits (remember that this can be any stable sorting algorithm). Since we
    are using the Counting Sort algorithm, the time complexity is O(d(n+b)), where
    *n* is the number of elements, *d* is the number of digits, and *b* is the radix
    or base (in our case, the base is 10). The space complexity is O(n+b).
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is called *RadixSort*. Well, so far, we’ve managed
    to cover the top five sorting algorithms that occur in technical interviews. Now,
    let’s quickly provide an overview of the searching algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Searching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main searching algorithm that occurs in interviews as a standalone problem
    or part of another problem is the Binary Search algorithm. The best case time
    complexity is O(1), while the average and worst case is O(log n). The worst case
    auxiliary space complexity of Binary Search is O(1) for the iterative implementation
    and O(log n) for the recursive implementation due to the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Binary Search algorithm relies on the *divide and conquer* strategy. Mainly,
    this algorithm debuts by dividing the given array into two sub-arrays. Furthermore,
    it discards one of these sub-arrays and operates on the other one iteratively
    or recursively. In other words, at each step, this algorithm halves the search
    space (which is initially the whole given array).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, these algorithms describe the steps for looking for element *x* in an array,
    *a*. Consider a sorted array, *a*, that contains 16 elements, as shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Ordered array containing 16 elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.8 – Ordered array containing 16 elements
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we compare *x* with the midpoint of the array, *p*. If they are equal,
    we return. If *x > p*, then we search the right-hand side of the array and discard
    the left-hand side (the search space is the right-hand side of the array). If
    *x < p*, then we search on the left-hand side of the array and discard the right-hand
    side (the search space is the left-hand side of the array). The following is a
    graphical representation of the Binary Search algorithm for finding the number
    17:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – The binary search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.9_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.9 – The Binary Search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we start with 16 elements and end with 1\. After the first step,
    we are down to 16/2 = 8 elements. At the second step, we are down to 8/2 = 4 elements.
    At the third step, we are down to 4/2 = 2 elements. And, at the final step, we
    find the searched number, 17\. If we put this algorithm into pseudocode, then
    we will obtain something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterative implementation is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinarySearch*. It also contains the recursive
    implementation of the Binary Search algorithm. In [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*, you can find different coding challenges that take advantage
    of the Binary Search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve covered the most popular sorting and searching algorithms that
    are encountered in technical interviews. It is advised that you practice these
    algorithms since they may occur as standalone problems that require the pseudocode
    or the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let’s tackle 18 problems that are related to sorting and searching
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Merging two sorted arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given two sorted arrays, *p* and *q*. The
    *p* array is large enough to fit *q* at the end of it. Write a snippet of code
    that merges *p* and *q* in a sorted order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: It is important to highlight the fact that *p* has enough space
    at the end to fit *q*. This suggests that the solution shouldn’t involve any auxiliary
    space. The solution should output the result of merging *p* and *q* in a sorted
    order by inserting the elements from *q* in *p* in order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mainly, we should compare the elements from *p* and *q* and insert them into
    *p* in order until we’ve processed all the elements in *p* and *q*. Let’s take
    a look at a meaningful diagram that reveals this action (*p* contains elements
    -1, 3, 8, 0, 0, while *q* contains elements 2, 4):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Merging two sorted arrays'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.10 – Merging two sorted arrays
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this test case step by step (let’s denote the index of the last element
    from *p* with *pIdx* and the index of the last element from *q* with *qIdx*).
    In the previous diagram, *pIdx*=2 (corresponding to element 8) and *qIdx*=1 (corresponding
    to element 4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 8
    with 4\. Since 8 > 4, we copy 8 to the end of *p*. Since both arrays are sorted,
    8 is the maximum of these arrays, so it must go to the last position (index) in
    *p*. It will occupy an empty slot in *p* (remember that *p* is large enough to
    fit *q* at its end). We decrease *pIdx* by 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 3
    with 4\. Since 3 < 4, we copy 4 to the end of *p*. We decrease *qIdx* by 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 3
    with 2\. Since 3 > 2, we copy 3 to the end of *p*. We decrease *pIdx* by 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare -1
    with 2\. Since -1 < 2, we copy 2 to the end of *p*. We decrease *qIdx* by 1\.
    There are no more elements to compare and *p* is sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: Check this out! After each comparison, we insert the elements at the end of
    *p*. This way, we don’t need to shift any elements. However, if we choose to insert
    the elements at the beginning of *p*, then we must shift the elements backward
    to make room for each inserted element. This is not efficient!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to see the implementation of this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MergeTwoSortedArrays*. If you’d like to
    check/remember how to merge *k* sorted arrays, then revisit [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*, the *Merging k sorted arrays in O(nk log k)* coding challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Grouping anagrams together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an array of words (containing characters
    from ''a'' to ''z'') representing several mixed anagrams (for example, "calipers",
    "caret", "slat", "cater", "thickset", "spiracle", "trace", "last", "salt", "bowel",
    "crate", "loop", "polo", "thickest", "below", "thickets", "pool", "elbow", "replicas").
    Write a snippet of code that prints this array so that all the anagrams are grouped
    together (for example, "calipers", "spiracle", "replicas", "caret", "cater", "trace",
    "crate", "slat", "last", "salt", "bowel", "below", "elbow", "thickset", "thickest",
    "thickets", "loop", "polo", "pool" ).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, here’s a quick reminder regarding anagrams. Two or more
    strings (words) are considered to be anagrams if they contain the same characters
    but in different orders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the example provided for this problem, let’s define the following
    array of mixed anagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since anagrams contain exactly the same characters, this means that if we sort
    them, then they will be identical (for example, sorting "slat", "salt" and "last"
    result in "alst"). So, we can say that two strings (words) are anagrams by comparing
    their sorted versions. In other words, all we need is a sorting algorithm. The
    most convenient way to do this is to rely on Java's built-in sorting algorithm,
    which is Dual-Pivot Quicksort for primitives and TimSort for objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in solution is called `sort()` and comes in many different flavors
    in the `java.util.Arrays` class (15+ flavors). Two of these flavors have the following
    signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void sort(Object[] a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> void sort(T[] a, Comparator<? super T> c)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we convert a string (word) into `char[]`, then we can sort its characters
    and return the new string via the following helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we just need a `Comparator` that indicates that two strings that are
    anagrams of each other are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we sort the given array of strings (words) via this `compareTo()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, the problem doesn’t actually ask us to sort the given array of anagrams;
    the problem asks us to print the anagrams grouped together. For this, we can rely
    on *hashing* (if you are not familiar with the concept of hashing, then please
    read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*, Object-Oriented
    Programming*, the *Hash table* problem). In Java, we can use hashing via the built-in
    `HashMap` implementation, so there is no need to write a hashing implementation
    from scratch. But how is this `HashMap` useful? What should we store in an entry
    (key-value pair) of this map?
  prefs: []
  type: TYPE_NORMAL
- en: 'Each group of anagrams converges to the same sorted version (for example, the
    group of anagrams containing the strings (words) "slat", "salt" and "last" have
    the unique and common sorted version as "alst"). Being unique, the sorted version
    is a good candidate to be the key in our map. Next, the value represents the list
    of anagrams. So, the algorithm is quite simple; it contains the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Loop over the given array of words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the characters of each word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the map (add or update the map).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If *n* is the number of strings (words) and each string (word) has a maximum
    of *m* characters, then the time complexity of the preceding two approaches is
    O(nm log m).
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do this better? Well, to do this better, we have to identify the issue
    of the preceding two approaches. The issue consists of the fact that we sort every
    string (word) and that this will cost us extra time. However, we can use an additional
    `char[]` to count up the number of occurrences (frequency) of each character in
    a string (word). After we build this `char[]`, we convert it into a `String` to
    obtain the key that we have to search for in `HashMap`. Since Java handles `char`
    types the same as it does (unsigned) `short`, we can make calculations with `char`.
    Let’s see the code (the `wordToChar` array tracks the frequency of characters
    from *a* to *z* for each string (word) in the given array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If *n* is the number of strings (words) and each string (word) contains a maximum
    of *m* characters, then the time complexity of the preceding two approaches is
    O(nm). If you need to support more characters, not just from *a* to *z*, then
    use an `int[]` array and `codePointAt()` – more details are available in [*Chapter
    10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*, Arrays and Strings*, in
    the *Extracting code points of surrogate pairs* coding challenge. The complete
    application is called *GroupSortAnagrams*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – List of unknown size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`size()`or similar method) containing only positive numbers. The code for this
    list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, as you can see, there is a method called `peekAt()` that returns the
    element at the given index in O(1). If the given index is beyond the bounds of
    this list, then `peekAt()` returns -1\. Write a snippet of code that returns the
    index at which an element, *p*, occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '`list.size()/2`) to find the middle point. The given data structure (list)
    doesn’t reveal its size.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the problem is reduced to finding the size of this list. We know that `peekAt()`
    returns -1 if the given index is beyond the bounds of this list, so we can loop
    the list and count the iterations until `peekAt()` returns -1\. When `peekAt()`
    returns -1, we should know the size of the list, so we can apply the Binary Search
    algorithm. Instead of looping the list element by element (linear algorithm),
    we can try to do so exponentially. So, instead of looping `peekAt(1)`, `peekAt(2)`,
    `peekAt(3)`, `peekAt(4)` ..., we loop `peekAt(1)`, `peekAt(2)`, `peekAt(4)`, `peekAt(8)`,
    .... In other words, instead of doing this in O(n) time, we can do so in O(log
    n) time, where *n* is the size of the list. We can do this because the given list
    is sorted!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should clarify this approach and the remaining details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *UnknownSizeList*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Merge sorting a linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given a singly linked list. Write a snippet
    of code that sorts this linked list via the Merge Sort algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Solving this problem requires knowledge of several topics that
    we’ve already covered in this book. First, you must be familiar with linked lists.
    This topic was covered in [*Chapter 11*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*,
    Linked Lists and Maps*. Second, you will need have read the *Merge Sort* section
    of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conforming to the Merge Sort algorithm, we have to continually split the linked
    list in half until we obtain empty sub-lists or sub-lists that contain a single
    element (this is the *divide and conquer* approach). If a sub-list is empty or
    contains one element, it is sorted by definition – this is known as *base case*
    recursion. The following diagram reveals this process for the initial linked list
    2 → 1 → 4 → 9 → 8 → 3 → 7 → null:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Using divide and conquer on a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.11 – Using divide and conquer on a linked list
  prefs: []
  type: TYPE_NORMAL
- en: 'Dividing the given linked list like this can be done via the Fast Runner/Slow
    Runner approach. This approach was detailed in [*Chapter 11*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*,
    Linked Lists and Maps*, in the *The Fast Runner/Slow Runner approach* section.
    Mainly, when the **Fast Runner** (**FR**) reaches the end of the given linked
    list, the **Slow Runner** (**SR**) points to the middle of this list, so we can
    split the list in two. The code for this is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is a classical Merge Sort implementation. The `sort()`
    method is responsible for recursively sorting the sub-lists. Next, the `merge()`
    method places the elements back into the original linked list one at a time by
    repeatedly taking the smallest element from the sorted sub-lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MergeSortSinglyLinkedList*. Sorting a doubly
    linked list is quite similar. You can find such an implementation in the application
    called *MergeSortDoublyLinkedList*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Strings interspersed with empty strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given a sorted array of strings that is interspersed
    with empty strings. Write a snippet of code that returns the index of the given
    non-empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: When we must search in a sorted data structure (for example,
    in a sorted array), we know that the Binary Search algorithm is the proper choice.
    So, can we use Binary Search in this case? We have the size of the given array,
    so we can halve the searching space and locate the middle point. If we denote
    the index 0 of the array as *left* and the *array.length-*1 as *right*, then we
    can write *mid =* (*left* + *right*)/2\. So, *mid* is the middle point of the
    given array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what we can do if the *mid* index falls on an empty string? In such a case,
    we don’t know if we should go to the *right* or the *left*. In other words, which
    half should be discarded, and what half should be used for continuing our search?
    The answer can be found in the following diagram (the given string is "cat", "",
    "", "", "", "", "", "rear", ""):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Computing the middle point in the case of an empty string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.12_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.12 – Computing the middle point in the case of an empty string
  prefs: []
  type: TYPE_NORMAL
- en: So, when the middle point (*mid*) falls on an empty string, we must correct
    its index by moving it to the nearest non-empty string. As shown in *step 2* of
    the preceding diagram, we choose *leftMid* as *mid*-1 and *rightMid* as *mid*+1\.
    We keep moving away from *mid* until the *leftMid* or *rightMid* index points
    out a non-empty string (in the preceding diagram, *rightMid* finds the string,
    "rear", after *steps 3* and *4*). When this happens, we update the *mid* position
    and continue the classical Binary Search (*step 4*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, this is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case time complexity for this approach is O(n). Notice that if the
    searched string is an empty string, then we return -1, so we treat this case as
    an error. This is correct since the problem says that the given string that needs
    to be found is non-empty. If the problem doesn’t provide any details about this
    aspect, then you have to discuss this with the interviewer. This way, you are
    showing the interviewer that you pay attention to details and corner cases. The
    complete application is called *InterspersedEmptyStrings*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Sorting a queue with the help of another queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given a queue of integers. Write a snippet
    of code that sorts this queue with the help of another queue (an extra queue).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The solution to this problem must include an extra queue, so
    we must think about how to use this extra queue when sorting the given queue.
    There are different approaches, but a convenient approach for an interview can
    be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the elements from the given queue are in ascending order (starting
    from the front of the queue), we dequeue them and enqueue in the extra queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an element breaks the preceding statement, then we dequeue and enqueue it
    back in the given queue, without touching the extra queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all the elements have been processed via *step 1* or *2*, we dequeue all
    the elements from the extra queue and enqueue them back in the given queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the size of the extra queue is not equal to the initial size of the
    given queue, we repeat from *step 1* since the queue is not sorted yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s consider that the given queue contains the following elements: rear →
    3 → 9 → 1 → 8 → 5 → 2 → front. The following diagram represents the given queue
    and the extra queue (initially empty):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – The given queue and the extra queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.13 – The given queue and the extra queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying *step 1* of our algorithm means dequeuing 2, 5, and 8 from the given
    queue and enqueuing them in the extra queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14 – Enqueuing 2, 5, and 8 in the extra queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.14_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.14 – Enqueuing 2, 5, and 8 in the extra queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the next element in the given queue is smaller than the last element
    that’s added to the extra queue, we apply *step 2* of our algorithm, so we dequeue
    1 and enqueue it in the given queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Dequeuing and enqueuing 1 in the given queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.15_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.15 – Dequeuing and enqueuing 1 in the given queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we apply *step 1* again since 9 (the front of the given queue)
    is bigger than the last element that’s added to the extra queue (8). So, 9 goes
    in the extra queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16 – Enqueuing 9 in the extra queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.16_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.16 – Enqueuing 9 in the extra queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, 3 is smaller than 9, so we must dequeue and enqueue it back in the given
    queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17 – Dequeuing and enqueuing 3 in the given queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.17 – Dequeuing and enqueuing 3 in the given queue
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’ve processed (visited) all the elements from the given queue,
    so we apply *step 3* of our algorithm. We dequeue all the elements from the extra
    queue and enqueue them in the given queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18 – Dequeuing from the extra queue and enqueuing in the given
    queue'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.18_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.18 – Dequeuing from the extra queue and enqueuing in the given queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we repeat the whole process until the given queue is sorted in ascending
    order. Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code’s runtime is O(n2). The complete application is called *SortQueueViaTempQueue*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Sorting a queue without extra space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given a queue of integers. Write a snippet
    of code that sorts this queue without using extra space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In the preceding problem, we had to solve the same problem but
    using an extra queue. This time, we cannot use an extra queue, so we must sort
    the queue in place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of sorting as a continuous process of finding the minimum element
    from the given queue, extracting it from its current position, and adding it to
    the rear of this queue. Expanding this idea may result in the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the current minimum as `Integer.MAX_VALUE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dequeue an element from the unsorted part of the queue (initially, the unsorted
    part is the entire queue).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare this element with the current minimum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this element is smaller than the current minimum, then do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the current minimum is `Integer.MAX_VALUE`, then this element becomes
    the current minimum and we do not enqueue it back in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: b. If the current minimum is not `Integer.MAX_VALUE`, then we enqueue the current
    minimum back in the queue and this element becomes the current minimum.
  prefs: []
  type: TYPE_NORMAL
- en: If this element is bigger than the current minimum value, then we enqueue it
    back in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 2* until the whole unsorted part is traversed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this step, the current minimum is the minimum of the entire unsorted part,
    so we enqueue it back in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the new boundary of the unsorted part and repeat from *step 1* until the
    unsorted part size is 0 (every time we execute this step, the unsorted part’s
    size is decreased by 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram is a snapshot of this algorithm for the queue; that is,
    rear → 3 → 9 → 1 → 8 → 5 → 2 → front:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19 – Sorting a queue without extra space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.19_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.19 – Sorting a queue without extra space
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how each minimum of the unsorted part (initially, the whole queue) is
    added back into the queue and becomes a member of the sorted part of the queue.
    Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code’s runtime is O(n2). The complete application is called *SortQueueWithoutExtraSpace*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Sorting a stack with the help of another stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an unsorted stack. Write a snippet
    of code that sorts the stack in descending or ascending order. You can only use
    an additional temporary stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If we could use two additional stacks, then we could implement
    an algorithm that repeatedly searches the minimum value in the given stack and
    pushes it into the final or resulting stack. A second additional stack will be
    used as a buffer while searching the given stack. However, the problem requires
    us to use only one additional temporary stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to this constraint, we are forced to pop from the given stack (let’s denote
    it as *s1*) and push in order into the additional stack (let’s denote it as *s2*).
    To accomplish this, we use a temporary or auxiliary variable (let’s denote it
    as *t*), as shown in the following diagram (the given stack is top → 1 → 4 → 5
    → 3 → 1 → 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20 – Sorting a stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.20_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.20 – Sorting a stack
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution consists of two main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'While *s1* is not empty, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pop a value from *s1* and store it in *t* (*action 1* in the previous diagram
    shows this for value 3).
  prefs: []
  type: TYPE_NORMAL
- en: b. Pop from *s2* and push it into *s1* as long as what we pop from *s2* is bigger
    than *t* or *s2* is not empty (*action 2* in the previous diagram).
  prefs: []
  type: TYPE_NORMAL
- en: c. Push *t* into *s2* (*action 3* in the previous diagram).
  prefs: []
  type: TYPE_NORMAL
- en: Once *step 1* is complete, *s1* is empty and *s2* is sorted. The biggest value
    is at the bottom, so the resulting stack is top → 5 → 4 → 3 → 2 → 1 → 1\. The
    second step consists of copying *s2* into *s1*. This way, *s1* is sorted in the
    reverse order of *s2*, so the smallest value is at the top of *s1* (top → 1 →
    1 → 2 → 3 → 4 → 5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is called *SortStack*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Sorting a stack in place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`for`, `while`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In the preceding problem, we had to solve the same problem but
    using an explicit extra stack. This time, we cannot use an explicit extra stack,
    so we must sort the stack in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider that the given stack is top → 4 → 5 → 3 → 8 → 2 →1\. The solution
    starts by popping the values from the stack until the stack is empty. Afterward,
    we insert the values from the recursion call stack back into the given stack in
    sorted position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to apply this approach to our stack. The following diagram reveals
    the process of popping the values from the stack until the stack is empty. On
    the left-hand side, we have the initial state. On the right-hand side, we have
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21 – Sorting the stack in place (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.21_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.21 – Sorting the stack in place (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we push back into the stack as long as the current element to push is
    smaller than the current top of the stack or the stack is empty. So, we will push
    1, 2, and 8\. We don’t push 3 (the next element to be pushed) since 3 is less
    than 8 (you can see this statement in the following diagram as *action 1*). At
    this point, we need to make room to 3, so we must pop the top of the stack, 8
    (you can see this statement in the following diagram as *action 2*). Finally,
    we push 3 and, afterward, we push 8 into the stack (you can see this statement
    in the following diagram as *action 3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22 – Sorting the stack in place (2)](img/Figure_14.22_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.22 – Sorting the stack in place (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good! Next, we must repeat the flow presented in the preceding diagram.
    So, the next element to be pushed from the recursion call stack into the given
    stack is 5\. But 5 is less than 8, so we cannot push it (you can see this statement
    in the following diagram as *action 1*). At this point, we need to make room for
    5, so we have to pop the top of the stack, which is 8 (you can see this statement
    in the following diagram as *action 2*). Finally, we push 5 and, afterward, we
    push 8 into the stack (you can see this statement in the following diagram as
    *action 3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Sorting the stack in place (3)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.23_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.23 – Sorting the stack in place (3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last element that should be pushed from the recursion call stack
    into the given stack is 4\. However, 4 is less than 8, so we cannot push it (you
    can see this statement in the following diagram as *action 1*). At this point,
    we need to make room to 4, so we must pop the top of the stack, which is 8 (you
    can see this statement in the following diagram as *action 2*). However, we still
    cannot push 4 into the stack because 4 is less than 5 (the new top element after
    popping 8). We must pop 5 as well (you can see this statement in the following
    diagram as *action 3*). Now, we can push 4\. Next, we push 5 and 8\. You can see
    this in the following diagram as *action 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.24 – Sorting the stack in place (4)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.24_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.24 – Sorting the stack in place (4)
  prefs: []
  type: TYPE_NORMAL
- en: 'Done! The given stack has been sorted. Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n2) with an auxiliary space of O(n) for the recursion
    call stack (*n* is the number of elements in the given stack). The complete application
    is called *SortStackInPlace*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Searching in a full sorted matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if a given integer is in this matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The brute-force method is quite inefficient. If we try to iterate
    the matrix and compare each (*row, col*) integer with the searched one, then this
    will impose a time complexity of O(mn), where *m* is the number of rows and *n*
    is the number of columns in the matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another solution will rely on the Binary Search algorithm. We have enough experience
    to implement this algorithm for a sorted array, but can we do it for a sorted
    matrix? Yes, we can, thanks to the fact that this sorted matrix is *fully sorted*.
    More precisely, since the first integer of each row is greater than the last integer
    of the previous row, we can look at this matrix as an array of length *rows* x
    *cols*. The following diagram clarifies this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25 – Fully sorted matrix as an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.25_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.25 – Fully sorted matrix as an array
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we see the given matrix as an array, then we can reduce the problem
    of applying the Binary Search to a sorted array. There is no need to physically
    transform the matrix into an array. All we need to do is express the Binary Search
    accordingly using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: The left-most integer of the array is at index 0 (let’s denote it as *left*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-most integer of the array is at index (*rows * cols*) - 1 (let’s denote
    it as *right*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle point of the array is at (*left + right*) / 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integer at the middle point of the index is at *matrix*[*mid / cols*][*mid
    % cols*], where *cols* is the number of columns in the matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these statements in place, we can write the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code performs in O(log mn) time, where *m* is the number of rows
    and *n* is the number of columns in the given matrix. The application is called
    *SearchInFullSortedMatrix*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Searching in a sorted matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if a given integer is in this matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Notice that this problem is not like the previous coding challenge
    since the first integer of each row doesn’t have to be greater than the last integer
    of the previous row. If we apply the Binary Search algorithm (as we did for the
    previous coding challenge), then we must apply it to every row. Since Binary Search
    has a complexity time of O(log n) and we have to apply it to every row, this means
    that this approach will perform in O(m log n) time, where *m* is the number of
    rows and *n* is the number of columns in the given matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to find a solution, let’s consider the following diagram (a matrix
    of 4 x 6):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26 – Searching in a sorted matrix](img/Figure_14.26_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.26 – Searching in a sorted matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we search for the element 80, which can be found at (2, 3).
    Let’s try to deduce this position. The climax of this deduction orbits the fact
    that the matrix has sorted rows and columns. Let’s analyze the start of the columns:
    if the start of a column is greater than 80 (for example, column 4), then we know
    that 80 cannot be in that column, since the start of the column is the minimum
    element in that column. Moreover, 80 cannot be found in any of the columns to
    the right of that column since the start element of each column must increase
    in size from left to right. Furthermore, we can apply the same logic to rows.
    If the start of a row is greater than 80, then we know that 80 cannot be in that
    row or subsequent (downward) rows.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we look at the end of the columns and rows, we can deduce some similar
    conclusions (mirrored conclusions). If the end of a column is less than 80 (for
    example, column 2), then we know that 80 cannot be in that column since the end
    of the column is the maximum element in that column. Moreover, 80 cannot be found
    in any of the columns to the left of that column since the start element of each
    column must decrease in size from right to left. Furthermore, we can apply the
    same logic to rows. If the end of a row is less than 80, then we know that 80
    cannot be in that row or subsequent (upward) rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we join, synthesize, and generalize these conclusions for an element, *p*,
    then we can deduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the start of a column is greater than *p*, then *p* must be to the left of
    that column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the start of a row is greater than *p*, then *p* must be above that row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the end of a column is less than *p*, then *p* must be to the right of that
    column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the end of a row is less than *p*, then *p* must be below that row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is already starting to look like an algorithm. There is one more thing
    that we must decide, though. Where do we start from? From which row and column?
    Fortunately, we have several options. For example, we can start with the greatest
    column (0, *last column*) and work to the left of the same row, or with the greatest
    row (*last row*, 0) and work up on the same column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we choose to start with the greatest column (0, *last column*)
    and work to the left to find the element, *p*. This means that our flow will be
    as follows (let’s denote *i*=0 and *j=cols*-1):'
  prefs: []
  type: TYPE_NORMAL
- en: If *matrix*[*i*][*j*] *> p*, then move left in the same row. The elements in
    this column are definitely greater than *matrix*[*i*][*j*] and hence, by extension,
    greater than *p*. So, we discard the current column, decrease *j* by 1, and repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *matrix*[*i*][*j*] *< p*, then move down in the same column. The elements
    in this row are definitely less than *matrix*[*i*][*j*] and hence, by extension,
    less than *p*. So, we discard the current row, increase *i* by 1, and repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *p* is equal to *matrix*[*i*][*j*], return `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we apply this algorithm to find element 80 in our 4 x 6 matrix, then the
    path from (0, 5) to (2, 3) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.27 – Path to the solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.27_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.27 – Path to the solution
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put this algorithm into code, then we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of this algorithm is O(m+n), where *m* is the number of
    rows and *n* is the number of columns. The complete application is called *SearchInSortedMatrix*.
    It also contains a recursive implementation of this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – First position of first one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an array that contains only values
    of 0 and 1\. There is at least a 0 and a 1\. All 0s comes first, followed by 1s.
    Write a snippet of code that returns the index of the first 1 in this array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider the array *arr*=[0, 0, 0, 1, 1, 1, 1]. The searched
    index is 3 since *arr*[3] is 1, and this is the first 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: Since 0s comes first, followed by 1s, the array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a very common topic in interviews, I’ll say it again: when we
    have to find something in a sorted array, we have to consider the Binary Search
    algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the Binary Search algorithm can be implemented quite easily.
    The middle point that’s computed in Binary Search can fall on 0 or 1\. Since the
    array is sorted, if the middle point falls on 0, then we know for sure that the
    first value of 1 must be on the right-hand side of the middle point, so we discard
    the left-hand side of the middle point. On the other hand, if the middle point
    falls on 1, then we know that the first value of 1 must on the left-hand side
    of the middle point, so we discard the right-hand side of the middle point. The
    following code clarifies this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *PositionOfFirstOne*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Maximum difference between two elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an array of integers, *arr*. Write
    a snippet of code that return the maximum difference between two elements when
    the larger integer appears after the smaller integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let’s consider several examples.'
  prefs: []
  type: TYPE_NORMAL
- en: If the given array is 1, 34, 21, 7, 4, 8, 10, then the maximum difference is
    33 (computed as 34 (index 1) - 1 (index 0)). If the given arrays is 17, 9, 2,
    26, 32, 27, 3, then the maximum difference is 30 (computed as 32 (index 4) - 2
    (index 2)).
  prefs: []
  type: TYPE_NORMAL
- en: How about an array sorted in ascending order, such as 3, 7, 9, 11? In this case,
    the maximum difference is 11 - 3 = 8, so this is the difference between the maximum
    and the minimum element. How about an array sorted in descending order such as
    11, 9, 7, 6? In this case, the maximum difference is 6 - 7 = -1, so the maximum
    difference is the difference closest to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these examples, we can think of several solutions. For example, we
    can start by computing the minimum and maximum of the array. Next, if the index
    of the maximum is greater than the index of the minimum, then the maximum difference
    is the difference between the maximum and the minimum of the array. Otherwise,
    we need to compute the next minimum and maximum of the array and repeat this process.
    This can lead to a complexity time of O(n2).
  prefs: []
  type: TYPE_NORMAL
- en: Another approach can start by sorting the array. Afterward, the maximum difference
    will be the difference between the maximum and the minimum elements (the difference
    between the last and the first elements). This can be implemented via a sorting
    algorithm in O(n log n) runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How about doing it in O(n) time? Instead of sorting the array or computing its
    maximum or minimum, we try another approach. Note that if we consider that *p*
    is the first element from the array, we can compute the difference between every
    successive element and *p*. While we are doing this, we are tracking the maximum
    difference and updating it accordingly. For example, if the array is 3, 5, 2,
    1, 7, 4 and *p*=3, then the maximum difference is 7-*p*=7-3=4\. However, if we
    look carefully, the real maximum difference is 7-1=6 and 1 is smaller than *p*.
    This leads us to the conclusion that, while traversing the elements successive
    to *p*, if the current traversed element is smaller than *p*, then *p* should
    become that element. Subsequent differences are computed between the successors
    of this *p* until the array is completely traversed or we find another element
    smaller than *p*. In such a case, we repeat this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n) time. The complete application is called *MaxDiffBetweenTwoElements*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Stream ranking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** Consider you’ve been given a stream of integers (such as a continuous
    flux of integer values). Periodically, we want to inspect the rank of a given
    integer, *p*. By rank, we understand the number of values less than or equal to
    *p*. Implement the data structure and algorithm that supports this operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let’s consider the following stream: 40, 30, 45, 15, 33, 42,
    56, 5, 17, 41, 67\. The rank of 45 is 8, the rank of 5 is 0, the rank of 17 is
    2, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The brute-force approach may work on a sorted array. Each time a new integer
    is generated, we add it to this array. While this will be very convenient for
    returning the rank of a given integer, this approach has an important drawback:
    each time we insert an element, we have to shift the elements greater than the
    new integer to make room for it. This is needed to maintain the array when it’s
    sorted in ascending order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A much better choice consists of a **Binary Search Tree** (**BST**). A BST
    maintains a relative order and inserting a new integer will update the tree accordingly.
    Let’s add the integers from our stream to a Binary Search Tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.28 – BST for stream ranking'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.28_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.28 – BST for stream ranking
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose that we want to find rank 43\. First, we compare 43 with the root
    and we conclude that 43 must be in the right sub-tree of the root, 40\. However,
    the root has 5 nodes in its left sub-tree (obviously, all of them are smaller
    than the root), so the rank of 43 is at least 6 (5 nodes of the left sub-tree
    of the root, plus the root). Next, we compare 43 with 45 and we conclude that
    43 must be to the left of 45, so the rank remains 5\. Finally, we compare 43 with
    42, and we conclude that 43 must be in the right sub-tree of 42\. The rank must
    be increased by 1, so the rank of 43 is 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we generalize this example with an algorithm? Here, we noticed
    that, for each node, we already know the rank of its left sub-tree. This doesn’t
    need to be computed each time the rank is required since this will be quite inefficient.
    We can track and update the rank of the left sub-tree each time a new element
    is generated and inserted into the tree. In the preceding diagram, each node has
    its sub-tree rank highlighted above the node. When the rank of a node is required,
    we already know the rank of its left sub-tree. Next, we have to consider the following
    recursive steps, which are applied via `int getRank(Node node, int element)`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `element` is equal to `node.element`, then return `node.leftTreeSize`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `element` is on the left of `node`, then return `getRank(node.left, element)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `element` is on the right of `node`, then return `node.leftTreeSize + 1 +
    getRank(node.right, element)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the given integer is not found, then we return -1\. The relevant code is
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will run in O(log n) time on a balanced tree and O(n) time
    on an unbalanced tree, where *n* is the number of nodes in the tree. The complete
    application is called *RankInStream*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Peaks and valleys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an array of positive integers representing
    terrain elevations. If an integer from this array is greater than or equal to
    its neighbors (adjacent integers), then this integer is called a *peak*. On the
    other hand, if an integer from this array is smaller than or equal to its neighbors
    (adjacent integers), then this integer is called a *valley*. For example, for
    array 4, 5, 8, 3, 2, 1, 7, 8, 5, 9, we can see that 8 (both) and 9 are peaks,
    while 4, 1, and 5 (except the last one) are valleys. Write a snippet of code that
    sorts the given array into an alternating sequence of peaks and valleys.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: At first sight, a handy solution would be to start by sorting
    the array in ascending order. Once the array is sorted as *l1 ≤ l2 ≤ l3 ≤ l4 ≤
    l5 ...*, we can see each triplet of numbers as *large*(*l1*)≤*larger*(*l2*)≤*largest*(*l3*).
    If we swap *l2* with *l3*, then *l1*≤*l3*≥*l2*, so *l3* becomes a peak. For the
    next triplet, *l2*≤ *l4* ≤ *l5*, we swap *l4* with *l5* to obtain *l2*≤*l5*≥*l4*,
    so *l5* is a peak. For the next triplet, *l4*≤*l6*≤*l7*, we swap *l6* with *l7*
    to obtain *l4*≤*l7*≥*l6*, so *l7* is a peak. If we continue these swaps, then
    we obtain something like this: *l1*≤*l3*≥*l2*≤*l5*≥*l4*≤*l7*≥*l6* .... But is
    this efficient? Since we have to sort the array, we can say that the time complexity
    of this solution is O(n log n). Can we do better than this? Yes, we can! Let’s
    assume that we represent our array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.29 – Given array of terrain elevations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.29_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.29 – Given array of terrain elevations
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can clearly see the peaks and valleys of the given array. If we focus
    on the first triplet (4, 5, 8) and try to obtain a peak, then we have to swap
    the value from the middle (5) with the maximum between its neighbors (adjacent
    integers). So, by swapping 5 with max(4, 8), we obtain (4, 8, 5). Therefore, 8
    is a peak and can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.30 – Swapping 5 with 8'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.30_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.30 – Swapping 5 with 8
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s focus on the next triplet (5, 3, 2). We can obtain a peak by swapping
    3 with max(5, 2), so by swapping 3 with 5\. The result is (3, 5, 2), as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.31 – Swapping 3 with 5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.31_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.31 – Swapping 3 with 5
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, 5 is a peak and 3 is a valley. We should continue with the triplet (2,
    1, 7) and swap 1 with 7 to obtain the peak (2, 7, 1). The next triplet will be
    (1, 8, 5) and have 8 as a peak (there is nothing to swap). In the end, we obtain
    the final result, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.32 – Final result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.32_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.32 – Final result
  prefs: []
  type: TYPE_NORMAL
- en: The interviewer will want you to pay attention to details and mention them.
    For example, when we swap the middle value with the left value, can we break the
    already processed terrain? Can we break a valley or a peak? The answer is no,
    we cannot break anything. This is because when we swap the middle with the left,
    we already know that the middle value is smaller than the left value and that
    the left value is a valley. Therefore, we just create a deeper valley by adding
    an even smaller value to that place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these statements, the implementation is quite simple. The following
    code will clarify any remaining details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code performs in O(n) complexity time. The complete application is called
    *PeaksAndValleys*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Nearest left smaller number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given an array of integers, *arr*. Write
    a snippet of code that finds and prints the nearest smaller number for every element
    so that the smaller element is on left-hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let’s consider the given array; that is, 4, 1, 8, 3, 8, 2, 6,
    7, 4, 9\. The expected result is _, _, 1, 1, 3, 1, 2, 6, 2, 4\. From left to right,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*arr*[0]=4 and in its left there is no element, so we print _.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[1]=1 and in its left there is no element smaller than it, so we print
    _.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[2]=8 and the nearest smallest element in its left is 1, so we print 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[3]=3 and the nearest smallest element in its left is 1, so we print 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[4]=8 and the nearest smallest element in its left is 3, so we print 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[5]=2 and the nearest smallest element in its left is 1, so we print 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[6]=6 and the nearest smallest element in its left is 2, so we print 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[7]=7 and the nearest smallest element in its left is 6, so we print 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[8]=4 and the nearest smallest element in its left is 2, so we print 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arr*[9]=9 and the nearest smallest element in its left is 4, so we print 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple but inefficient solution relies on two loops. The outer loop can start
    from the second element (index 1) and go to the length of the array (*arr.length*-1),
    while the inner loop traverses all the elements on the left-hand side of the element
    picked by the outer loop. As soon as it finds an element smaller, it stops the
    process. Such an algorithm is very easy to implement, but it runs in O(n2) complexity
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can reduce the time complexity to O(n) via a `Stack`. Mainly, we
    can traverse the given array from 0 to *arr.length*-1 and rely on a `Stack` to
    track the subsequence of elements that have been traversed so far that are smaller
    than any later element that has already been traversed. While this statement may
    sound complicated, let’s clarify it by looking at this algorithm’s steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every element of *arr*, (*i* = 0 to *arr.length*-1), we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. While the stack is not empty and the top element is greater than or equal
    to *arr*[*i*], we pop from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: b. If the stack is empty, then there is no element in the left of *arr*[*i*].
    We can print a symbol representing no element found (for example, -1 or _).
  prefs: []
  type: TYPE_NORMAL
- en: c. If the stack is not empty, then the nearest smaller value to *arr*[*i*] is
    the top element of the stack. We can peek and print this element.
  prefs: []
  type: TYPE_NORMAL
- en: d. Push *arr*[*i*] into the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code has a runtime of O(n), where *n* is the number of elements in the
    given array. The complete application is called *FindNearestMinimum*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – Word search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the given word is present on the board. The same letter cell may
    not be used more than once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let’s consider that we have the following board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.33 – Board sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.33_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.33 – Board sample
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this is not the first time where we need to solve a problem that
    requires us to find a certain path in a grid. In [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*, we had the *Robot grid* problems, including
    *Color spots*, *Five Towers*, *The falling ball,* and *Knight tour*. In [*Chapter
    12*](B15403_12_Final_JM_ePub.xhtml#_idTextAnchor276)*, Stacks and Queues*, we
    had *Islands*. Finally, in [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*, we had *Chess knight*.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the experience you’ve accumulated from these problems, challenge yourself
    to write an implementation for this problem without having any further instructions.
    The complete application is called *WordSearch*. If *k* is the length of the given
    word and the board has a size of *m* x *n*, then this application runs in O(m
    * n * 4k) time.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 18 – Sorting an array based on another array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you’ve been given two arrays. Write a snippet of code
    that reorders the elements of the first array according to the order defined by
    the second array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let’s consider we’ve been given the following two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The expected result is {7, 4, 4, 8, 8, 8, 2, 1, 1, 3, 3, 5, 6, 9}.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem relies on *hashing*. More precisely, we can employ
    the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Count and store the frequency of each element from the first array in a map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each element of the second array, check if the current element from the
    second array is present in the map or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a. If so, then set it *n* times in the first array (*n* is the frequency of
    the current element from the second array in the first array).
  prefs: []
  type: TYPE_NORMAL
- en: b. Remove the current element from the map so that, in the end, the map will
    contain only the elements that are present in the first array but are not present
    in the second array.
  prefs: []
  type: TYPE_NORMAL
- en: Append the elements from the map to the end of the first array (these are already
    sorted since we used a `TreeSet`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(m log m + n), where *m* is the number of elements
    in the first array and *n* is the number of elements in the second array. The
    complete application is called *SortArrayBasedOnAnotherArray*.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this was the last problem in this chapter. Now, it’s time to summarize
    our work!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a comprehensive chapter that covered sorting and searching algorithms.
    You saw the implementations of Merge Sort, Quick Sort, Radix Sort, Heap Sort,
    Bucket Sort, and Binary Search. Moreover, in the code bundled with this book,
    there’s an application called *SortArraysIn14Ways* that contains the implementations
    of 14 sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover a suite of problems categorized as mathematical
    and puzzle problems.
  prefs: []
  type: TYPE_NORMAL
