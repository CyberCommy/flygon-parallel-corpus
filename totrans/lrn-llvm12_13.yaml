- en: '*Chapter 10*: JIT Compilation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LLVM core libraries come with the **ExecutionEngine** component, which allows
    the compilation and execution of IR code in memory. Using this component, we can
    build **just in time** (**JIT**) compilers, which allow the direct execution of
    IR code. A JIT compiler works more like an interpreter, in the sense that no object
    code needs to be stored on secondary storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about applications for JIT compilers, and how
    the LLVM JIT compiler works in principle. You will explore the LLVM dynamic compiler
    and interpreter, and you will also learn how to implement a JIT compiler tool
    on your own. You will also see how to make use of a JIT compiler as part of a
    static compiler, and the challenges associated with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of LLVM's JIT implementation and use cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JIT compilation for direct execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing a JIT compiler for code evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to develop a JIT compiler, either
    using a preconfigured class, or a customized version fitting your needs. You will
    also acquire the knowledge to make use of a JIT compiler inside a traditional
    static compiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of LLVM's JIT implementation and use cases
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only looked at **ahead of time** (**AOT**) compilers. These
    compilers compile the whole application. Only once the compilation is finished
    can the application run. If the compilation is performed at the runtime of the
    application, then the compiler is a JIT compiler. A JIT compiler has interesting
    use cases:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of a virtual machine**: A programming language can be translated
    to byte code with an AOT compiler. At runtime, a JIT compiler is used to compile
    the byte code to machine code. The advantage of this approach is that the byte
    code is hardware-independent, and thanks to the JIT compiler, there is no performance
    penalty compared to an AOT compiler. Java and C# use this model today, but the
    idea is really old: the USCD Pascal compiler from 1977 already used a similar
    approach.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expression evaluation**: A spreadsheet application can compile often-executed
    expressions with a JIT compiler. This can speed up the financial simulations,
    for example. The LLVM debugger LLDB uses the approach to evaluate a source expression
    at debug time.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database queries**: A database creates an execution plan from a database
    query. The execution plan describes the operations on tables and columns, which
    leads to the query answer when executed. A JIT compiler can be used to translate
    the execution plan into machine code, thereby speeding up the execution of the
    query.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static compilation model of LLVM is not as far away from the JIT model as
    you may think. The LLVM static compiler, `llc`, compiles LLVM IR into machine
    code and saves the result as an object file on disk. If the object file is not
    stored on disk but in memory, would the code be executable? Not directly, because
    references to global functions and global data use relocations instead of absolute
    addresses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, a relocation describes how to calculate the address, for example,
    as an offset to a known address. If we resolve the relocations into addresses,
    like the linker and dynamic loader do, then we can execute the object code. Running
    the static compiler to compile IR code into an object file in memory, performing
    a link step on the in-memory object file, and then running the code gives us a
    JIT compiler. The JIT implementation in the LLVM core libraries is based on this
    idea.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'During the development history of LLVM, there were several JIT implementations,
    with different feature sets. The latest JIT API is the **on request compilation**
    (**ORC**) engine. In case you were wondering about the acronym: it was the lead
    developer''s intention to invent yet another acronym based on Tolkien''s universe,
    after the **ELF** (**Executable and Linking Format**) and the **DWARF** (**Debugging
    Standard**) were already there.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORC engine builds on, and extends, the idea of using the static compiler
    and a dynamic linker on the in-memory object file. The implementation uses a *layered*
    approach. The two basic levels are the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Compile layer
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link layer
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On top of the compile layer can sit a layer providing support for *lazy compilation*.
    A **transformation layer** can be stacked on top or below the lazy compilation
    layer, allowing the developer to add arbitrary transformation, or simply be notified
    of certain events. This layered approach has the advantage that the JIT engine
    is *customizable for diverse requirements*. For example, a high-performance virtual
    machine may choose to compile everything upfront and make no use of the lazy compilation
    layer. Other virtual machines will emphasize start up time and responsiveness
    to the user, and achieve this with the help of the lazy compilation layer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The older MCJIT engine is still available. The API is derived from an even older,
    already removed, JIT engine. Over time, the API became a bit bloated, and it lacks
    the flexibility of the ORC API. The goal is to remove this implementation, as
    the ORC engine now provides all the functionality of the MCJIT engine. New developments
    should use the ORC API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at `lli`, the LLVM interpreter and dynamic compiler,
    before we dive into implementing a JIT compiler.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Using JIT compilation for direct execution
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running LLVM IR directly is the first idea that comes to mind when thinking
    about a JIT compiler. This is what the `lli` tool, the LLVM interpreter, and the
    dynamic compiler do. We will explore the `lli` tool in the next section, and subsequently
    implement a similar tool on our own.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the lli tool
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try the `lli` tool with a very simple example. Store the following source
    as a `hello.ll` file. It is the equivalent of a C hello world application. It
    declares the prototype for the `printf()` function from the C library. The `hellostr`
    constant contains the message to be printed. Inside the `main()` function, a pointer
    to the first character of the message is calculated via the `getelementptr` instruction,
    and this value is passed to the `printf()` function. The application always returns
    `0`. The complete source code is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This LLVM IR file is generic enough that it is valid for all platforms. We
    can directly execute the IR with the `lli` tool with the help of the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interesting point here is how the `printf()` function is found. The IR code
    is compiled to machine code, and a lookup for the `printf` symbol is triggered.
    This symbol is not found in the IR, so the current process is searched for it.
    The `lli` tool dynamically links against the C library, and the symbol is found
    there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the `lli` tool does not link against libraries you created. To enable
    the use of such functions, the `lli` tool supports the loading of shared libraries
    and objects. The following C source just prints a friendly message:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Stored in the `greetings.c` file, we use this to explore the loading of objects
    with the `lli` tool. Compile this source into a shared library. The `–fPIC` option
    instructs clang to generate position-independent code, which is required for shared
    libraries. With the `–shared` option given, the compiler creates the `greetings.so`
    shared library:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also compile the file into a `greetings.o` object file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have two files, the `greetings.so` shared library and the `greetings.o`
    object file, which we will load into the `lli` tool.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need an LLVM IR file, which calls the `greetings()` function. For this,
    create the `main.ll` file, which contains a single call to the function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个LLVM IR文件，其中调用`greetings()`函数。为此，请创建包含对该函数的单个调用的`main.ll`文件：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to execute the IR as before, then the `lli` tool is not able to
    locate the greetings symbol and will simply crash:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试像以前一样执行IR，则`lli`工具无法找到`greetings`符号，将简单崩溃：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `greetings()` function is defined in an external file, and to fix the crash,
    we have to tell the `lli` tool which additional file needs to be loaded. In order
    to use the shared library, you have to use the `–load` option, which takes the
    path to the shared library as an argument:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetings()`函数在外部文件中定义，为了修复崩溃，我们必须告诉`lli`工具需要加载哪个附加文件。为了使用共享库，您必须使用`–load`选项，该选项以共享库的路径作为参数：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is important to specify the path to the shared library, if the directory
    containing the shared library is not in the search path for the dynamic loader.
    If omitted, then the library will not be found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含共享库的目录不在动态加载器的搜索路径中，则重要的是指定共享库的路径。如果省略，则将无法找到库。
- en: 'Alternatively, we can instruct the `lli` tool to load the object file with
    the `–extra-object` option:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指示`lli`工具使用`–extra-object`选项加载对象文件：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other supported options are `–extra-archive`, which loads an archive, and `–extra-module`,
    which loads another bitcode file. Both options require the path to the file as
    an argument.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持的选项是`–extra-archive`，它加载存档，以及`–extra-module`，它加载另一个位代码文件。这两个选项都需要文件的路径作为参数。
- en: You now know how you can use the `lli` tool to directly execute LLVM IR. In
    the next section, we will implement our own JIT tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用`lli`工具直接执行LLVM IR。在下一节中，我们将实现自己的JIT工具。
- en: Implementing our own JIT compiler with LLJIT
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LLJIT实现我们自己的JIT编译器
- en: The `lli` tool is nothing more than a thin wrapper around LLVM APIs. In the
    first section, we learned that the ORC engine uses a layered approach. The `ExecutionSession`
    class represents a running JIT program. Besides other items, this class holds
    the used `JITDylib` instances. A `JITDylib` instance is a symbol table, which
    maps symbol names to addresses. For example, this can be the symbols defined in
    an LLVM IR file, or the symbols of a loaded shared library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`lli`工具只是LLVM API周围的薄包装器。在第一节中，我们了解到ORC引擎使用分层方法。`ExecutionSession`类表示正在运行的JIT程序。除其他项目外，此类还保存了使用的`JITDylib`实例。`JITDylib`实例是一个符号表，将符号名称映射到地址。例如，这可以是LLVM
    IR文件中定义的符号，或者是加载的共享库的符号。'
- en: To execute LLVM IR, we do not need to create a JIT stack on our own. The utility
    `LLJIT` class provides this functionality. You can also make use of this class
    when migrating from the older MCJIT implementation. This class essentially provides
    the same functionality. We begin the implementation with the initialization of
    the JIT engine in the next subsection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行LLVM IR，我们不需要自己创建JIT堆栈。实用程序`LLJIT`类提供此功能。当从较旧的MCJIT实现迁移时，您也可以使用此类。该类基本上提供了相同的功能。我们将在下一小节中开始实现JIT引擎的初始化。
- en: Initializing the JIT engine for compiling LLVM IR
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化用于编译LLVM IR的JIT引擎
- en: 'We first implement the function that sets up the JIT engine, compiles an LLVM
    IR module, and executes the `main()` function in this module. Later, we use this
    core functionality to build a small JIT tool. This is the `jitmain()` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现设置JIT引擎，编译LLVM IR模块并在此模块中执行`main()`函数的函数。稍后，我们将使用此核心功能构建一个小型JIT工具。这是`jitmain()`函数：
- en: 'The function needs the LLVM module with the IR to execute. Also needed is the
    LLVM context class used for this module, because the context class holds important
    type information. The goal is to call the `main()` function, so we also pass the
    usual `argc` and `argv` parameters:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数需要执行LLVM模块的LLVM IR。还需要用于此模块的LLVM上下文类，因为上下文类保存重要的类型信息。目标是调用`main()`函数，因此我们还传递通常的`argc`和`argv`参数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the `LLJITBuilder` class to create an `LLJIT` instance. If an error
    occurs, then we return the error. A possible source for an error is that the platform
    does not yet support JIT compilation:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`LLJITBuilder`类创建`LLJIT`实例。如果发生错误，则返回错误。错误的可能来源是平台尚不支持JIT编译：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add the module to the main `JITDylib` instance. If configured, then
    JIT compilation utilizes multiple threads. Therefore, we need to wrap the module
    and the context in a `ThreadSafeModule` instance. If an error occurs, then we
    return the error:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将模块添加到主`JITDylib`实例中。如果配置，则JIT编译将利用多个线程。因此，我们需要将模块和上下文包装在`ThreadSafeModule`实例中。如果发生错误，则返回错误：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like the `lli` tool, we also support the symbols from the C library. The `DefinitionGenerator`
    class exposes symbols, and the `DynamicLibrarySearchGenerator` subclass exposes
    the names found in the shared library. The class provides two factory methods.
    The `Load()` method can be used to load a shared library, while the `GetForCurrentProcess()`
    method exposes the symbols of the current process. We use the latter function.
    The symbol names can have a prefix, depending on the platform. We retrieve the
    data layout and pass the prefix to the `GetForCurrentprocess()` function. The
    symbol names are then treated in the right way, and we do not need to care about
    it. As usual, we return from the function in case an error occurs:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`lli`工具一样，我们还支持C库中的符号。`DefinitionGenerator`类公开符号，`DynamicLibrarySearchGenerator`子类公开共享库中找到的名称。该类提供了两个工厂方法。`Load()`方法可用于加载共享库，而`GetForCurrentProcess()`方法公开当前进程的符号。我们使用后者功能。符号名称可以具有前缀，取决于平台。我们检索数据布局并将前缀传递给`GetForCurrentprocess()`函数。然后符号名称将以正确的方式处理，我们不需要关心它。通常情况下，如果发生错误，我们会从函数中返回：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then add the generator to the main `JITDylib` instance. In case a symbol
    needs to be looked up, the symbols from the loaded shared library are also searched:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将生成器添加到主`JITDylib`实例中。如果需要查找符号，则还会搜索加载的共享库中的符号：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we look up the `main` symbol. This symbol must be in the IR module given
    on the command line. The lookup triggers compilation of that IR module. If other
    symbols are referenced inside the IR module, then they are resolved using the
    generator added in the previous step. The result is of the `JITEvaluatedSymbol`
    class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We ask the returned JIT symbol for the address of the function. We cast this
    address to the prototype of the C `main()` function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can call the `main()` function in the IR module, and pass the `argc`
    and `argv` parameters, which the function expects. We ignore the return value:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We report success following execution of the function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This demonstrates how easy it is to use JIT compilation. There is a bunch of
    other possibilities to expose names, besides exposing the symbols for the current
    process or from a shared library. The `StaticLibraryDefinitionGenerator` class
    exposes the symbols found in a static archive, and can be used in the same way
    as the `DynamicLibrarySearchGenerator` class. The `LLJIT` class also has an `addObjectFile()`
    method to expose the symbols of an object file. You can also provide your own
    `DefinitionGenerator` implementation if the existing implementations do not fit
    your needs. In the next subsection, you extend the implementation into a JIT compiler.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Creating the JIT compiler utility
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `jitmain()` function is easily extended into a small tool, which we do
    next. The source is saved in a `JIT.cpp` file and is a simple JIT compiler:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We must include several header files. The `LLJIT.h` header defines the `LLJIT`
    class, and the core classes of the ORC API. We include the `IRReader.h` header
    because it defines a function to read LLVM IR files. The `CommandLine.h` header
    allows us to parse the command-line options in the LLVM style. Finally, the `InitLLVM.h`
    header is required for basic initialization of the tool, and the `TargetSelect.h`
    header for the initialization of the native target:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We add the `llvm` namespace to the current scope:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our JIT tool expects exactly one input file on the command line, which we declare
    with the `cl::opt<>` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To read the IR file, we call the `parseIRFile()` function. The file can be
    the textual IR representation, or a bitcode file. The function returns a pointer
    to the created module. Error handling is a bit different because a textual IR
    file can be parsed, which is not necessarily syntactical correct. The `SMDiagnostic`
    instance holds the error information in case of a syntax error. The error message
    is printed, and the application is exited:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `jitmain()` function is placed here:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we add the `main()` function, which initializes the tool and the native
    target, and parses the command line:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, the LLVM context class is initialized:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we load the IR module named on the command line:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we can call the `jitmain()` function. To handle errors, we use the `ExitOnError`
    utility class. This class prints an error message and exits the application when
    an error occurred. We also set a banner with the name of the application, which
    is printed before the error message:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the control flow reaches this point, then the IR was successfully executed.
    We return `0` to indicate success:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is already the complete implementation! We only need to add the build description,
    which is the topic of the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CMake build description
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to compile this source file, we also need to create a `CMakeLists.txt`
    file with the build description, saved besides the `JIT.cpp` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the minimal required CMake version to the number required by LLVM and
    give the project the name `jit`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The LLVM package needs to be loaded, and we add the directory of the CMake
    modules provided by LLVM to the search path. Then we include the `ChooseMSVCCRT`
    module, which makes sure that the same C runtime is used as by LLVM:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to add the definitions and the include path from LLVM. The LLVM
    components used are mapped to the library names with a function call:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we define the name of the executable, the source files to compile,
    and the library to link against:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That is everything that is required for the JIT tool. Create and change into
    a build directory, and then run the following command to create and compile the
    application:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This compiles the `JIT` tool. You can check the functionality with the `hello.ll`
    file from the beginning of the chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a JIT compiler is surprisingly easy!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The example used LLVM IR as input, but this is not a requirement. The `LLJIT`
    class uses the `IRCompileLayer` class, which is responsible for compiling IR to
    machine code. You can define your own layer, which accepts the input you need,
    for example, Java byte code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Using the predefined LLJIT class is handy, but limits our flexibility. In the
    next section, we will look at how to implement a JIT compiler using the layers
    provided by the ORC API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Building a JIT compiler class from scratch
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the layered approach of ORC, it is very easy to build a JIT compiler customized
    for the requirements. There is no one-size-fits-all JIT compiler, and the first
    section of this chapter gave some examples. Let's have a look at how to set up
    a JIT compiler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The ORC API uses layers, which are stacked together. The lowest level is the
    object linking layer, represented by the `llvm::orc::RTDyldObjectLinkingLayer`
    class. It is responsible for linking in-memory objects and turning them into executable
    code. The memory required for this task is managed by an instance of the `MemoryManager`
    interface. There is a default implementation, but we can also use a custom version
    if we need to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Above the object linking layer is the compile layer, which is responsible for
    creating an in-memory object file. The `llvm::orc::IRCompileLayer` class takes
    an IR module as input, and compiles it to an object file. The `IRCompileLayer`
    class is a subclass of the `IRLayer` class, which is a generic class for layer
    implementations accepting LLVM IR.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: These two layers already form the core of a JIT compiler. They add an LLVM IR
    module as input, which is compiled and linked in-memory. To add more functionality,
    we can add more layers on top of these both. For example, the `CompileOnDemandLayer`
    class splits a module, so that only the requested functions are compiled. This
    can be used to implement lazy compilation. The `CompileOnDemandLayer` class is
    also a subclass of the `IRLayer` class. In a very generic way, the `IRTransformLayer`
    class, also a subclass of the `IRLayer` class, allows us to apply a transformation
    to the module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Another important class is the `ExecutionSession` class. This class represents
    a running JIT program. Basically, this means that the class manages the `JITDylib`
    symbol tables, provides lookup functionality for symbols, and keeps track of the
    resource managers used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic recipe for a JIT compiler is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an instance of the `ExecutionSession` class.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the layer, at least consisting of the `RTDyldObjectLinkingLayer`
    class and the `IRCompileLayer` class.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the first `JITDylib` symbol table, usually with `main` or a similar name.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The usage is very similar to the `LLJIT` class from the previous section:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Add an IR module to the symbol table.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up a symbol, the triggered compilation of the associated function, and
    possibly the whole module.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the function.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next subsection, we will implement a JIT compiler class based on the
    generic recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JIT compiler class
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To keep the implementation of the JIT compiler class simple, we put everything
    into the `JIT.h` header file. The initialization of the class is a bit more complex.
    Due to the handling of possible errors, we need a factory method to create some
    objects upfront before we can call the constructor. The steps to create the class
    are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by guarding the header file against multiple inclusion with the `JIT_H`
    preprocessor definition:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`JIT_H`预处理器定义保护头文件免受多次包含的影响：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A bunch of include files is required. Most of them provide a class with the
    same name as the header file. The `Core.h` header provides a couple of basic classes,
    including the `ExecutionSession` class. The `ExecutionUtils.h` header provides
    the `DynamicLibrarySearchGenerator` class to search libraries for symbols, which
    we already used in the *Implementing our own JIT compiler with LLJIT* section.
    The `CompileUtils.h` header provides the `ConcurrentIRCompiler` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一堆包含文件。其中大多数提供与头文件同名的类。`Core.h`头文件提供了一些基本类，包括`ExecutionSession`类。`ExecutionUtils.h`头文件提供了`DynamicLibrarySearchGenerator`类来搜索库中的符号，我们已经在*使用LLJIT实现我们自己的JIT编译器*部分中使用过。`CompileUtils.h`头文件提供了`ConcurrentIRCompiler`类：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our new class is the `JIT` class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新类是`JIT`类：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The private data members reflect the ORC layers and a helper class. The `ExecutionSession`,
    `ObjectLinkingLayer`, `CompileLayer`, `OptIRLayer`, and `MainJITDylib` instances
    represent the running JIT program, the layers, and the symbol table, as already
    described. The `TargetProcessControl` instance is used for interaction with the
    JIT target process. This can be the same process, another process on the same
    machine, or a remote process on a different machine, possible with a different
    architecture. The `DataLayout` and `MangleAndInterner` classes are required to
    mangle the symbols names in the correct way. The symbol names are internalized,
    which means that all equal names have the same address. To check whether two symbol
    names are equal, it is then sufficient to compare the addresses, which is a very
    fast operation:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有数据成员反映了ORC层和一个辅助类。 `ExecutionSession`，`ObjectLinkingLayer`，`CompileLayer`，`OptIRLayer`和`MainJITDylib`实例代表了运行中的JIT程序，层和符号表，如前所述。
    `TargetProcessControl`实例用于与JIT目标进程进行交互。这可以是相同的进程，同一台机器上的另一个进程，或者是不同机器上的远程进程，可能具有不同的架构。
    `DataLayout`和`MangleAndInterner`类需要以正确的方式操纵符号名称。符号名称是内部化的，这意味着所有相等的名称具有相同的地址。要检查两个符号名称是否相等，只需比较地址，这是一个非常快速的操作：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The initialization is split into three parts. In C++, a constructor cannot return
    an error. The simple and recommended solution is to create a static factory method,
    which can do the error handling prior to constructing the object. The initialization
    of the layers is more complex, so we introduce factory methods for them, too.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化分为三个部分。在C++中，构造函数不能返回错误。简单且推荐的解决方案是创建一个静态工厂方法，在构造对象之前进行错误处理。层的初始化更复杂，因此我们也为它们引入了工厂方法。
- en: In the `create()` factory method, we first create a `SymbolStringPool` instance,
    which is used to implement string internalization and is shared by several classes.
    To take control of the current process, we create a `SelfTargetProcessControl`
    instance. If we want to target a different process, then we need to change this
    instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create()`工厂方法中，我们首先创建一个`SymbolStringPool`实例，用于实现字符串内部化，并由几个类共享。为了控制当前进程，我们创建一个`SelfTargetProcessControl`实例。如果我们想要针对不同的进程，则需要更改此实例。
- en: 'Then we construct a `JITTargetMachineBuilder` instance, for which we need to
    know the target triple of the JIT process. Next, we query the target machine builder
    for the data layout. This step can fail if the builder is not able to instantiate
    the target machine based on the triple provided, for example, because support
    for this target is not compiled into the LLVM libraries:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构造了一个`JITTargetMachineBuilder`实例，我们需要知道JIT进程的目标三元组。接下来，我们查询目标机器生成器以获取数据布局。如果生成器无法根据提供的三元组实例化目标机器，例如，因为对此目标的支持未编译到LLVM库中，这一步可能会失败：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, we have handled all the calls that could potentially fail. We
    are now able to initialize the `ExecutionSession` instance. Finally, the constructor
    of the `JIT` class is called with all instantiated objects, and the result is
    returned to the caller:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经处理了所有可能失败的调用。我们现在能够初始化`ExecutionSession`实例。最后，调用`JIT`类的构造函数，并将结果返回给调用者：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The constructor of the `JIT` class moves the passed parameters to the private
    data members. The layer objects are constructed with a call to a static factory
    name with the `create` prefix. Each `layer` factory method requires a reference
    to the `ExecutionSession` instance, connecting the layer to the running JIT session.
    Except for the object linking layer, which is at the bottom of the layer stack,
    each layer also requires a reference to the previous layer, illustrating the stacking
    order:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT`类的构造函数将传递的参数移动到私有数据成员。通过调用带有`create`前缀的静态工厂名称构造层对象。每个`layer`工厂方法都需要引用`ExecutionSession`实例，将层连接到运行中的JIT会话。除了对象链接层位于层堆栈的底部之外，每个层还需要引用上一个层，说明了堆叠顺序：'
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the body of the constructor, we add the generator to search the current
    process for symbols. The `GetForCurrentProcess()` method is special, because the
    return value is wrapped in an `Expected<>` template, indicating that an `Error`
    object can also be returned. But we know that no error can occur – the current
    process will eventually run! Therefore, we unwrap the result with the `cantFail()`
    function, which terminates the application if an error occurred anyway:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的主体中，我们添加了生成器来搜索当前进程的符号。`GetForCurrentProcess()`方法是特殊的，因为返回值包装在`Expected<>`模板中，表示也可以返回`Error`对象。但我们知道不会发生错误-当前进程最终会运行！因此，我们使用`cantFail()`函数解包结果，如果发生错误，它将终止应用程序：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To create the object linking layer, we need to provide a memory manager. We
    stick here to the default `SectionMemoryManager` class, but we could also provide
    a different implementation if needed:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建对象链接层，我们需要提供一个内存管理器。我们在这里坚持使用默认的`SectionMemoryManager`类，但如果需要，我们也可以提供不同的实现：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A slight complication exists for the COFF object file format, which is used
    on Windows. This file format does not allow functions to be marked as exported.
    This subsequently leads to failures in checks inside the object linking layer:
    the flags stored in the symbol are compared with the flags from IR, which leads
    to a mismatch because of the missing export marker. The solution is to override
    the flags only for this file format. This finishes construction of the object
    layer, and the object is returned to the caller:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在Windows上使用的COFF目标文件格式存在一个小复杂性。这种文件格式不允许将函数标记为导出。这随后导致在对象链接层内部的检查失败：存储在符号中的标志与IR中的标志进行比较，由于缺少导出标记而导致不匹配。解决方案是仅针对这种文件格式覆盖标志。这完成了对象层的构建，并将对象返回给调用者：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To initialize the compiler layer, an `IRCompiler` instance is needed. The `IRCompiler`
    instance is responsible for compiling an IR module into an object file. If our
    JIT compiler does not use threads, then we can use the `SimpleCompiler` class,
    which compiles the IR module using a given target machine. The `TargetMachine`
    class is not thread-safe, likewise the `SimpleCompiler` class, too. To support
    compilation with multiple threads, we use the `ConcurrentIRCompiler` class, which
    creates a new `TargetMachine` instance for each module to compile. This approach
    solves the problem with multiple threads:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化编译器层，需要一个`IRCompiler`实例。`IRCompiler`实例负责将IR模块编译成目标文件。如果我们的JIT编译器不使用线程，那么我们可以使用`SimpleCompiler`类，它使用给定的目标机器编译IR模块。`TargetMachine`类不是线程安全的，同样`SimpleCompiler`类也不是。为了支持多线程编译，我们使用`ConcurrentIRCompiler`类，它为每个要编译的模块创建一个新的`TargetMachine`实例。这种方法解决了多线程的问题：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Instead of compiling the IR module directly to machine code, we install a layer
    that optimizes the IR first. This is a deliberate design decision: We turn our
    JIT compiler into an optimizing JIT compiler, which produces faster code that
    takes longer to produce, meaning a delay for the user. We do not add lazy compilation,
    so entire modules are compiled when just a symbol is looked up. This can add up
    to a significant time before the user sees the code executing.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不直接将IR模块编译成机器代码，而是安装一个优化IR的层。这是一个有意的设计决定：我们将我们的JIT编译器转变为一个优化的JIT编译器，它产生更快的代码，但需要更长的时间来生成，这对用户来说会有延迟。我们不添加延迟编译，所以当查找一个符号时，整个模块都会被编译。这可能会导致用户在看到代码执行之前花费相当长的时间。
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `optimizeModule()` function is an example of a transformation on an IR
    module. The function gets the module to transform as parameter, and returns the
    transformed one. Because the JIT can potentially run with multiple threads, the
    IR module is wrapped in a `ThreadSafeModule` instance:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimizeModule()`函数是对IR模块进行转换的一个示例。该函数以要转换的模块作为参数，并返回转换后的模块。由于JIT可能会使用多个线程，IR模块被包装在一个`ThreadSafeModule`实例中：'
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To optimize the IR, we recall some information from [*Chapter 8*](B15647_08_ePub_RK.xhtml#_idTextAnchor126),
    *Optimizing IR*, in the *Adding an optimization pipeline to your compiler* section.
    We require a `PassBuilder` instance to create an optimization pipeline. First,
    we define a couple of analysis managers, and register them afterward at the pass
    builder. Then we populate a `ModulePassManager` instance with the default optimization
    pipeline for the `O2` level. This is again a design decision: the `O2` level produces
    fast machine code already, but does this faster still than the `O3` level. Afterward,
    we run the pipeline on the module. Finally, the optimized module is returned to
    the caller:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了优化IR，我们回顾一些来自[*第8章*](B15647_08_ePub_RK.xhtml#_idTextAnchor126)的信息，*优化IR*，在*向编译器添加优化流水线*部分。我们需要一个`PassBuilder`实例来创建一个优化流水线。首先，我们定义了一些分析管理器，并在通行构建器中注册它们。然后，我们使用默认的优化流水线填充了一个`ModulePassManager`实例，用于`O2`级别。这再次是一个设计决定：`O2`级别已经产生了快速的机器代码，但比`O3`级别更快。之后，我们在模块上运行流水线。最后，优化后的模块返回给调用者：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The client of the `JIT` class needs a way to add an IR module, which we provide
    with the `addIRModule()` function. Remember the layer stack we created: we must
    add the IR module to the top layer, otherwise we would accidently bypass some
    layers. This would be a programming error that is not easily spotted: if the `OptIRLayer`
    member is replaced by a `CompileLayer` member, then our `JIT` class still works,
    but not as an optimizing JIT because we have bypassed this layer. This is no cause
    for concern as regards this small implementation, but in a large JIT optimization,
    we would introduce a function to return the top-level layer:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT`类的客户端需要一种添加IR模块的方法，我们使用`addIRModule()`函数提供这种方法。记住我们创建的层栈：我们必须将IR模块添加到顶层，否则我们可能会意外地绕过一些层。这将是一个不容易发现的编程错误：如果`OptIRLayer`成员被`CompileLayer`成员替换，那么我们的`JIT`类仍然可以工作，但不作为一个优化的JIT，因为我们已经绕过了这一层。这在这个小实现中并不值得担心，但在一个大的JIT优化中，我们会引入一个函数来返回顶层层次：'
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Likewise, a client of our JIT class needs a way to look up a symbol. We delegate
    this to the `ExecutionSession` instance, passing in a reference to the main symbol
    table and the mangled and internalized name of the requested symbol:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们的JIT类的客户端需要一种查找符号的方法。我们将这个任务委托给`ExecutionSession`实例，传入主符号表的引用以及所请求符号的mangled和internalized名称：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Putting the JIT compiler together was quite easy. Initializing the class is
    a bit tricky, as it involves a factory method and a constructor call for the `JIT`
    class, and factory methods for each layer. This distribution is caused by limitations
    in C++, although the code itself is simple.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将JIT编译器组合在一起相当容易。初始化这个类有点棘手，因为它涉及到`JIT`类的一个工厂方法和构造函数调用，以及每个层的工厂方法。这种分布是由于C++的限制，尽管代码本身很简单。
- en: In the next subsection, we are using our new JIT compiler class to implement
    a command-line utility.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将使用我们的新JIT编译器类来实现一个命令行实用程序。
- en: Using our new JIT compiler class
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的新JIT编译器类
- en: 'The interface of our new JIT compiler class resembles the `LLJIT` class used
    in the *Implementing our own JIT compiler with LLJIT* section. To test our new
    implementation, we copy the `LIT.cpp` class from the previous section and make
    the following changes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新JIT编译器类的接口类似于*使用LLJIT实现我们自己的JIT编译器*部分中使用的`LLJIT`类。为了测试我们的新实现，我们从上一节中复制`LIT.cpp`类，并进行以下更改：
- en: To be able to use our new class, we include the `JIT.h` header file. This replaces
    the `llvm/ExecutionEngine/Orc/LLJIT.h` header file, which is no longer required
    because we are no longer using the LLJIT class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用我们的新类，我们包含`JIT.h`头文件。这取代了`llvm/ExecutionEngine/Orc/LLJIT.h`头文件，因为我们不再使用LLJIT类，所以它不再需要。
- en: Inside the `jitmain()` function, we replace the call to `orc::LLJITBuilder().create()`
    with a call to our new `JIT::create()` method.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jitmain()`函数中，我们用对我们的新`JIT::create()`方法的调用替换了对`orc::LLJITBuilder().create()`的调用。
- en: Again, in the `jitmain()` function, we remove the code to add the `DynamicLibrarySearchGenerator`
    class. Precisely this generator is integrated in the JIT class.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`jitmain()`函数中，我们删除了添加`DynamicLibrarySearchGenerator`类的代码。这个生成器已经集成在JIT类中。
- en: This is already everything that needs to be changed! We can compile and run
    the changed application as in the previous section, with the same result. Under
    the hood, the new class uses a fixed optimization level, so with sufficiently
    large modules, we can note the differences in startup and runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是需要改变的一切了！我们可以像在上一节中一样编译和运行更改后的应用程序，得到相同的结果。在底层，新类使用了固定的优化级别，因此对于足够大的模块，我们可以注意到启动和运行时的差异。
- en: Having a JIT compiler at hand can stimulate new ideas. In the next section,
    we will look at how we can use the JIT compiler as part of a static compiler to
    evaluate code at compile time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有JIT编译器可以激发新的想法。在下一节中，我们将看看如何将JIT编译器作为静态编译器的一部分来评估编译时的代码。
- en: Utilizing a JIT compiler for code evaluation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用JIT编译器进行代码评估
- en: Compiler writers make a great effort to produce optimal code. A simple, yet
    effective, optimization is to replace an arithmetic operation on two constants
    by the result value of this operation. To be able to perform the computation,
    an interpreter for constant expressions is embedded. And to arrive at the same
    result, the interpreter has to implement the same rules as the generated machine
    code! Of course, this can be the source of subtle errors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器编写者付出了巨大的努力来生成最佳代码。一个简单而有效的优化是用两个常量替换算术运算的结果值。为了能够执行计算，嵌入了一个常量表达式的解释器。为了得到相同的结果，解释器必须实现与生成的机器代码相同的规则！当然，这可能是微妙错误的源泉。
- en: A different approach would be to compile the constant expression to IR using
    the same code generations methods, and then have JIT compile and execute the IR.
    This idea can even be taken a step further. In mathematics, a function always
    produces the same result for the same input. For functions in computer languages,
    this is not true. A good example is the `rand()` function, which returns a random
    value for each call. A function in computer languages, which has the same characteristic
    as a function in mathematics, is called a **pure function**. During the optimization
    of expressions, we could JIT-compile and execute pure functions, which only have
    constant parameters, and replace the call to the function with the result returned
    from JIT execution. Effectively, we move the execution of the function from runtime
    to compile time!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用相同的代码生成方法将常量表达式编译为IR，然后让JIT编译和执行IR。这个想法甚至可以进一步发展。在数学中，函数对于相同的输入总是产生相同的结果。对于计算机语言中的函数，这并不成立。一个很好的例子是`rand()`函数，它每次调用都返回一个随机值。在计算机语言中，具有与数学函数相同特性的函数称为**纯函数**。在表达式优化期间，我们可以JIT编译和执行只有常量参数的纯函数，并用JIT执行返回的结果替换对函数的调用。实际上，我们将函数的执行从运行时移到了编译时！
- en: Think about cross-compilation
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑交叉编译
- en: Using a JIT compiler as part of a static compiler is an interesting option.
    However, if the compiler were to support cross-compilation, then this approach
    should be well thought-out. The usual candidates causing trouble are floating-point
    types. The precision of the `long double` type in C often depends on the hardware
    and the operation system. Some systems use 128-bit floating points, while others
    only use 64-bit floating points. The 80-bit floating point type is only available
    on the x86 platform, and usually only used on Windows. Performing the same floating-point
    operation with different precision can result in huge differences. Evaluation
    through JIT compilation cannot be used in such cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态编译器中使用JIT编译器是一个有趣的选择。然而，如果编译器支持交叉编译，那么这种方法应该经过深思熟虑。通常会引起麻烦的候选者是浮点类型。C语言中`long
    double`类型的精度通常取决于硬件和操作系统。一些系统使用128位浮点数，而其他系统只使用64位浮点数。80位浮点类型仅在x86平台上可用，并且通常仅在Windows上使用。使用不同精度进行相同的浮点运算可能会导致巨大差异。在这种情况下，无法使用JIT编译进行评估。
- en: It cannot easily be decided whether a function is pure. The common solution
    is to apply a heuristic. If a function does not read or write into heap memory,
    either through pointers or indirectly with the use of aggregate types, and only
    calls other pure functions, then it is a pure function. The developer can aid
    the compiler, and mark pure functions, for example, with a special keyword or
    symbol. In the semantic analysis phase, the compiler can then check for violations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确定一个函数是否是纯函数。常见的解决方案是应用一种启发式方法。如果一个函数既不通过指针也不通过聚合类型间接地读取或写入堆内存，并且只调用其他纯函数，那么它就是一个纯函数。开发人员可以帮助编译器，例如，用特殊的关键字或符号标记纯函数。在语义分析阶段，编译器可以检查违规情况。
- en: In the next subsection, we will take a closer look at the implications for language
    semantics when trying to JIT-execute a function at compile time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将更仔细地看一下在编译时尝试对函数进行JIT执行时对语言语义的影响。
- en: Identifying the language semantics
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别语言语义
- en: The difficult part is indeed to decide at the language semantics level which
    parts of the language are suitable for evaluation at compile time. Excluding access
    to heap memory is very restrictive. In general terms, it rules out string handling,
    for example. Using heap memory becomes problematic when the allocated memory survives
    the lifetime of the JIT-executed function. This is a program state, which can
    influence other results, and is therefore dangerous. On the other hand, if there
    are matched calls to `malloc()` and `free()` functions, then the memory is only
    used for internal calculation. In this case, the use of heap memory would be safe.
    But precisely this condition is not easy to proof.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: At a similar level, an infinite loop inside the JIT-executed function can freeze
    the compiler. Alan Turing showed in 1936 that no machine can decide whether a
    function will produce a result or whether it is stuck in an endless loop. Some
    precautions must be taken to avoid this situation, for example, a runtime limit
    after which the JIT-executed function is terminated.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'And last, the more that functionality is allowed, the more thoughts must be
    put into security, because the compiler now executes code written by someone else.
    Just imagine that this code downloads and runs files from the internet or tries
    to erase the hard disk: with too much state allowed for JIT-executed functions,
    we also need to think about such scenarios.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The idea is not new. The D programming language has a feature called **compile-time
    function execution**. The reference compiler **dmd** implements this feature by
    interpretation of the functions at the AST level. The LLVM-based LDC compiler
    has an experimental feature to use the LLVM JIT engine for it. You can find out
    more about the language and the compilers at https://dlang.org/.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignoring the semantic challenges, the implementation is not that difficult.
    In the *Building a JIT compiler class from scratch* section, we developed a JIT
    compiler with the `JIT` class. We feed an IR module in the class, and we can look
    up and execute a function from this module. Looking at the `tinylang` compiler
    implementation, we can clearly identify access to constants, because there is
    a `ConstantAccess` node in the AST. For example, there is code like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Instead of interpreting the operations in the expression to derive the value
    of the constant, we can do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Create a new IR module.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an IR function in the module, returning a value of the expected type.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the existing `emitExpr()` function to create the IR for the expression and
    return the calculated value with the last instruction.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JIT-execute the function to calculate the value.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is this worth implementing? LLVM performs constant propagation and function
    inlining as part of the optimization pipeline. A simple expression such as 4 +
    5 is already replaced during IR construction with the result. Small functions
    such as calculation of the greatest common divisor are inlined. If all parameters
    are constant values, then the inlined code gets replaced by the result of the
    calculation through constant propagation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Based on this observation, an implementation of this approach is only useful
    if enough language features are available for execution at compile time. If this
    is the case, then it is fairly easily implemented using the given sketch.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to utilize the JIT compiler component of LLVM enables you to use
    LLVM in whole new ways. Besides implementing a JIT compiler like the Java VM,
    the JIT compiler can also be embedded in other applications. This allows creative
    approaches, such as its use inside a static compiler, which you looked at in this
    section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to develop a JIT compiler. You began with possible
    applications of JIT compilers, and you explored `lli`, the LLVM dynamic compiler
    and interpreter. Using the predefined `LLJIT` class, you built a tool similar
    to `lli` on your own. To be able to take advantage of the layered structure of
    the ORC API, you implemented an optimizing `JIT` class. Having acquired all this
    knowledge, you explored the possibility of using a JIT compiler inside a static
    compiler, a feature from which some languages can benefit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何开发JIT编译器。您从JIT编译器的可能应用开始，并探索了LLVM动态编译器和解释器`lli`。使用预定义的`LLJIT`类，您自己构建了类似于`lli`的工具。为了能够利用ORC
    API的分层结构，您实现了一个优化的`JIT`类。在获得了所有这些知识之后，您探讨了在静态编译器内部使用JIT编译器的可能性，这是一些语言可以受益的特性。
- en: In the next chapter, you will examine how to add a backend for a new CPU architecture
    to LLVM.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何为新的CPU架构向LLVM添加后端。
