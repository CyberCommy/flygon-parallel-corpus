- en: Implementing Move Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some advanced C++ move semantics. We will first
    discuss the Big Five, which is an idiom that simply encourages programmers to
    explicitly define the destruction and move/copy semantics of a class. Next, we
    will learn how to define a move constructor and move assignment operator; the
    different combinations of move semantics (including move-only and non-copyable);
    non-movable classes; and how to implement these classes and why they are important.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also discuss some common pitfalls such as why a `const &&`
    move makes no sense, and how to overcome l-value versus r-value reference types.
    The recipes in this chapter are important because once you enable C++11 or higher,
    move semantics is enabled, which changes how C++ fundamentally handles classes
    in numerous situations. The recipes in this chapter provide the foundation for
    writing efficient code in C++ that behaves as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using compiler-generated special class member functions and the Big Five
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your class movable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving only types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `noexcept` move constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to be wary of `const &&`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing qualified member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring objects that cannot be moved or copied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Using compiler-generated special class member functions and the Big Five
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using C++11 or higher, the compiler will auto-generate certain functions
    for your C++ classes if you do not explicitly provide them in the class definition.
    In this recipe, we will explore how this works, which functions the compiler will
    create for you, and how this affects your program's performance and validity.
    In general, the goal of this recipe is to make the case that every class should,
    at a minimum, have the Big Five defined to ensure your class is explicit about
    how you wish to manage resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher, and run the following in a Terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore the difference between a move and copy and
    how this relates to the Big Five, which is a reference to five functions that
    all classes should explicitly define. To start, let''s first look at a simple
    example of a class that outputs an integer value in its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the class will output to `stdout` when the class is
    destructed. The class also has an integer member variable that is initialized
    on construction. The problem with the preceding example is that the implicit copy
    and move semantics are suppressed because we defined the class's destructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Big Five are the following functions, which every class should define if
    at least one of these functions are defined (that is, if you define one, you must
    define them all):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the Big Five includes the destructor, move constructor, move assignment
    operator, copy constructor, and copy assignment operator. The author of these
    classes need not implement these functions but instead should—at a minimum—*define*
    the functions, explicitly stating how deletions, copying, and moving should take
    place (if at all). This ensures that if one of these functions is defined, the
    rest of the class''s move, copy, and destruction semantics are correct, as in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the class is marked as `virtual` by defining a virtual
    destructor (meaning the class is capable of participating in runtime polymorphism).
    No implementation is needed (by setting the destructor to `default`), but the
    definition itself is explicit, which tells the compiler that we want the class
    to support virtual functions. This tells the user of the class that a pointer
    to this class can be used to delete an instance of any class that derives from
    it. It also tells the user that inheritance will leverage runtime polymorphism
    and not composition. This class also states that copies and moves are both allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, copies are explicitly deleted (which is the same as
    defining a move constructor without defining copy semantics). This defines a move-only
    class, which means that the class can only be moved; it cannot be copied. An example
    of such a class in the standard library is `std::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class implements the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have explicitly defined a copy-only class.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different combinations of the Big Five. The point of this recipe
    is to show that explicitly defining these five functions ensures that the author
    of the class is explicit about the intent of the class itself. This is with respect
    to how it should operate and how a user should use the class. Being explicit ensures
    the author of the class doesn't intend for one type of behavior, but instead gets
    another because of how the compiler will implicitly construct the class based
    on the compiler's implementation and how the C++ specification was defined.
  prefs: []
  type: TYPE_NORMAL
- en: Making your class movable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++11 or higher, objects can either be copied or moved, which can be used
    to dictate how your object''s resources are managed. The big difference between
    a copy and a move is simple: a copy creates a copy of the resources an object
    manages, while a move transfers the resources from one object to another.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explain how to make a class movable, including how to
    properly add move constructors and move assignment operators. We will also explain
    some of the subtle details of a movable class and how to use them in your code.
    This recipe is important because, in a lot of cases, moving an object instead
    of copying an object increases the performance and reduces the memory consumption
    of your programs. However, the use of movable objects could introduce some instabilities
    if they are not used properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to make a class movable. To start, let''s
    examine a basic class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a simple class with a private integer member
    that is initialized. We then define a default constructor and a destructor that
    outputs to `stdout` when an instance of the class is destroyed. By default, this
    class is movable, but the move operation mimics a copy (in other words, there
    is no difference between a move or a copy with this simple example).
  prefs: []
  type: TYPE_NORMAL
- en: 'To really make this class movable, we need to add both a move constructor and
    a move assignment operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we add these two functions, we will be able to use the following to move
    our class from one instance to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To support this, in the preceding class, we will not only add the move constructor
    and assignment operator, but we will also implement a default constructor to provide
    a valid moved-from state to our example class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the class now has a default constructor and an explicit constructor
    that takes an integer argument. The default constructor initializes the integer
    memory variable, which represents our moved-from or invalid state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we output the value of our integer member
    variable when the class is destroyed, but in this case, we first check to make
    sure the integer variable is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement the move constructor and assignment operators. The move
    constructor simply calls the move assignment operator to prevent the need for
    duplication (as they perform the same action). The move assignment operator first
    checks to make sure that we are not moving to ourselves. This is because doing
    so would lead to corruption as the user would expect the class to still contain
    a valid integer but in fact, the internal integer would inadvertently be set to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We then exchange the integer value and set the original to `0`. This is because,
    once again, a move is not a copy. A move transfers the value from one instance
    to another. In this case, the instance being moved to starts as `0` and is given
    a valid integer, while the instance being moved from starts with a valid integer
    and is set to `0` after the move, resulting in only `1` instance containing a
    valid integer.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that we have to define the copy constructor and assignment
    operator. This is because, by default, if you provide a move constructor and assignment
    operator, C++ will automatically delete the copy constructor and assignment operator
    if they are not explicitly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will compare a move versus a copy, so we define the copy
    constructor and assignment operator to ensure they are not implicitly deleted.
    In general, it is best practice to define your destructor, the move constructor,
    and assignment operator as well as the copy constructor and assignment operator
    for every class you define. This ensures that the copy/move semantics for every
    class you write are explicit and intentional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc7cc97b-8542-42e5-9ada-0634f0017fbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our main function, we run two different tests:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test creates two instances of our class and copies the contents of
    one instance to the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test creates two instances of our class and then moves the contents
    of one instance to the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this example is executed, we see the first test's output was written to
    twice. This is because the first instance of our class is given a copy of the
    second instance of our class, which has a valid integer value. The second test's
    output is only written to once because we are transferring the valid state of
    one instance to the other, resulting in only one instance having a valid state
    at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some notable instances worth mentioning here:'
  prefs: []
  type: TYPE_NORMAL
- en: Move constructors and assignment operators should never throw exceptions. Specifically,
    a move operation transfers the valid state of an instance of a type to another
    instance of that type. At no point should this operation fail as no state is being
    created or destroyed. It is simply being transferred. Also, it is oftentimes difficult
    to *undo* a move operation part of the way through the move. For these reasons,
    these functions should always be labeled as `noexcept` (refer to [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-move-noexcept)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move constructors and assignment operators do not include `const` types in their
    function signature because the instance being moved from cannot be `const` since
    its internal state is being transferred, which implicitly assumes a write is occurring.
    More importantly, if you label a move constructor or assignment operator as `const`,
    it is possible that a copy would occur instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you intend to create a copy, a move should be used instead, especially
    for large objects. Just like passing `const T&` as a function argument to prevent
    a copy from occurring, when a function is called, a move should be used in place
    of a copy when a resource is being moved into another variable instead of being
    copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler will automatically generate move operations instead of copy operations
    when possible. For example, if you create an object in a function, configure the
    object, and then return the object, a move will be automatically performed by
    the compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to make your classes movable, in the next recipe, we will
    learn what a move-only type is, and why you might want to use them in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Move-only types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make a class move-only. A great example
    of the difference between a copy and a move is the difference between `std::unique_ptr`
    and `std::shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: The point of `std::unique_ptr` is to enforce a single owner for dynamically
    allocated types while `std::shared_ptr` allows for multiple owners of dynamically
    allocated types. Both allow the user to move the contents of a pointer type from
    one instantiation to another, but only `std::shared_ptr` allows the user to make
    a copy of the pointer (as copying the pointer would create more than one owner).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use these two classes to show how to make a move-only
    class and to show why this type of class is used so heavily in C++ (as most of
    the time we wish to move and not copy).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A move-only class is a class that can be moved but cannot be copied. To explore
    this type of class, let''s wrap `std::unique_ptr`, which itself is a move-only
    class, in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class stores `std::unique_ptr` as a member variable and, on construction,
    instantiates the memory variable with an integer value. On destruction, the class
    checks to make sure `std::unique_ptr` is valid and if so, outputs the value to
    `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, we might wonder why we must check for validity as `std::unique_ptr`
    is always constructed. The reason `std::unique_ptr` could become invalid is during
    a move. Since we are creating a move-only class (and not a non-copyable, non-movable
    class), we implement the move constructor and move assignment operator, which
    moves `std::unique_ptr`. `std::unique_ptr`, on moving, will transfer the contents
    of its internal pointer from one class to another, resulting in the class being
    moved from storing an invalid pointer (that is, `nullptr`). In other words, even
    though this class cannot be null-constructed, it can still store `nullptr` if
    it is moved, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, only one class outputs to `stdout` as only
    one instance is valid. Like `std::unique_ptr`, a move-only class ensures that
    you always have a 1:1 relationship between the total number of resources being
    created and the total number of actual instantiations occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that since we are using `std::unique_ptr`, our class becomes
    a move-only class whether we like it or not. For example, attempting to add a
    copy constructor or copy assignment operator to enable the ability to copy will
    result in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, every class that includes a move-only class as a member also
    becomes a move-only class itself. Although this might seem undesirable, you must
    first ask yourself: do you really need a class to be copyable? The likely answer
    is no. In fact, in most cases, even before C++11, most—if not all—of the classes
    that we work with should be move-only. The ability of a class to be copied when
    it should be moved can lead to wasted resources, corruption, and so on, which
    is one of the reasons move semantics were added to the specification. Move semantics
    allow us to define how we want the resources we allocate to be handled, and it
    provides us with a way to enforce the desired semantics at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder how the preceding example would be converted to allow for
    copying. The following example leverages a shared pointer to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class uses `std::shared_ptr` instead of `std::unique_ptr`. Under
    the hood, `std::shared_ptr` keeps track of the number of copies that are made
    and only deletes the pointer it stored when the total number of copies is `0`.
    In fact, you can query the total number of copies using the `use_count()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the move constructor, move assignment operator, copy constructor,
    and copy assignment operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These definitions could have also been written using the `=` default syntax
    as these implementations are the same thing. Finally, we test this class using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the preceding code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80128ca4-0b35-4b29-b649-c871a64b025f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding tests, we first create a copy of our class and output the total
    number of copies to see that two copies were in fact created. The second test
    performs `std::move()` instead of a copy, which results in only one copy being
    created as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the noexcept move constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to ensure a move constructor and a move assignment
    operator never throw an exception. The C++ specification doesn't prevent a move
    constructor from throwing (as it was determined that such a requirement would
    simply be too difficult to enforce, as too many legitimate examples exist even
    in the standard library). However, ensuring that exceptions are not thrown should
    be possible in most cases. Specifically, a move usually doesn't create resources
    but instead transfers resources and as a result, strong exception guarantees should
    be possible. A good example of a move that does create a resource is `std::list`,
    which must provide a valid `end()` iterator even on a move.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated before, a move should not throw an exception to ensure strong exception
    guarantees (that is, the act of moving an object doesn''t possibly corrupt the
    object), and in most cases, this is possible because a move (unlike a copy) doesn''t
    create resources, it transfers them. The best way to ensure that your move constructors
    and move assignment operators do not throw is to only transfer member variables
    using `std::move()`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the member variable you are moving doesn''t throw, your class
    will not either. Using this simple technique will ensure that your move constructors
    and operators never throw. But what if this operation cannot be used? Let''s explore
    this issue with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create a class with a vector as the member variable.
    The vector can either be initialized as empty by default, or it can be initialized
    with a single element. On destruction, if the vector has a value, we output the
    value to `stdout`. We implement the `move` constructor and operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the move operator is transferring the single element from one instance
    to the other (not the best way to implement a move, but this implementation can
    demonstrate the point without being overly complicated). If the vector is empty,
    this operation will throw, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we attempt to move an instance of this class in two different tests.
    In the first test, both instances are default constructed, which results in empty
    classes, while the second test constructs the vector with a single element, which
    results in a valid move. In this case, we were able to prevent the move from throwing,
    but it should be noted that the resulting classes did not actually perform the
    move, resulting in both objects not containing the state that was desired. This
    is why move constructors should never throw. Even if we didn't catch the exception,
    it would be extremely difficult to assert the state of the program after the throw
    occurred. Did the move occur? What state is each instance in? In most cases, this
    type of error should lead to `std::terminate()` being called as the program enters
    a corrupt state.
  prefs: []
  type: TYPE_NORMAL
- en: A copy is different because the original class is left intact. The copy is invalid
    and the programmer can handle this case gracefully, as the original state of the
    instance being copied is unaffected (hence we mark it `const`).
  prefs: []
  type: TYPE_NORMAL
- en: Since, however, the instance being moved from is writable, both instances are
    in a corrupt state and there isn't a good way to know how to handle the program
    moving forward, as we don't know whether the original instance was left in a state
    that can be properly handled.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to be wary of const&&
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn why a move constructor or operator should never
    be marked `const` (and why a copy constructor/operator is always marked as `const`).
    This is important because it gets to the heart of the difference between a move
    and a copy. Move semantics in C++ is one of its most powerful features and understanding
    why it is so important and what it is actually doing is critical to writing good
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn why a `const&&` constructor or operator doesn''t
    make sense and will result in unexpected behavior. A move transfers resources,
    which is why it is marked as non-`const`. This is because a transfer assumes that
    both instances are written to (one instance receives the resource while the other
    has the resource taken away). A copy creates resources, which is why they are
    not always marked as `noexcept` (creating resources absolutely could throw) and
    they are marked `const` (because the original instance is being copied, not modified).
    A `const&&` constructor is claiming to be a move that doesn''t transfer, which
    must be a copy (if you are not writing to the original instance, you are not moving—you
    are copying), as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a class that implements default move and
    copy constructors/operators. The only difference is that we add output to `stdout`
    to tell us whether a copy is being performed or a move is being performed.
  prefs: []
  type: TYPE_NORMAL
- en: We then create two instances of our class with the instance being moved from
    being marked as `const`. We then perform the move and what is output is a copy.
    This is because even though we asked for a move, the compiler used a copy. We
    could implement a `const &&` move constructor/operator but there would be no way
    to write the move as a move, since we marked the object being moved from as `const`,
    so we cannot take its resources. Such a move would, in fact, be implemented as
    a copy, no different than what the compiler did for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to add qualifiers to our member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing qualified member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about what a reference qualified member function
    is. Although this aspect of the C++ language is less used and understood, it is
    important because it provides the programmer with the ability to handle how resources
    are operated on, based on whether or not the class is in an l-value or r-value
    state when a function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will look at what a reference qualified member function
    is. To explain what a reference-qualified member function is, let''s look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have implemented a `foo()` function, but we have two different
    versions. The first version has `&` at the end while the second has `&&` at the
    end. Which `foo()` function gets executed is dictated by whether or not the instance
    is an l-value or an r-value, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19571c4b-ebb1-4680-a183-82571ec2416c.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, the first execution of `foo()` is an l-value,
    as the l-value version of `foo()` is executed (that is, the function with `&`
    at the end). The last two executions of `foo()` are r-values as the r-value versions
    of `foo()` are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Reference-qualified member functions can be used to ensure that the function
    is only called in the right context. Another reason to use these types of functions
    is to ensure that the function is only called when an l-value or r-value reference
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might not want to allow `foo()` to be called as an r-value
    as this type of invocation doesn't ensure that an instance of the class actually
    has a lifetime outside of the call itself, as demonstrated in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to make a class that can neither be moved
    nor copied, and explain why you might do such a thing.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring objects that cannot be moved or copied
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about how to create an object that we cannot move
    or copy and why you might want to create such a class. Copying a class requires
    the ability to copy the contents of a class, which in some cases, could be impossible
    (for example, making a copy of a memory pool is not simple). Moving a class assumes
    that the class is allowed to exist in a potentially invalid state (for example, `std::unique_ptr`,
    when moved, takes on a `nullptr` value, which is invalid). Such cases may also
    be undesirable (you now have to check for validity). A non-movable class that
    we cannot copy can overcome these types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Move-only classes prevent a class from being copied, which in some cases, can
    be a performance improvement. Move-only classes also ensure a 1:1 relationship
    between resources that are created versus the resources that are allocated, as
    copies cannot exist. Moving a class, however, can result in a class becoming invalid,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6a0a4c9-5084-4fae-8a30-69fb5fff3ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create a class that can be moved, which stores `std::unique_ptr`.
    In the destructor of the class, we dereference the class and output its value.
    We don't check the validity of `std::unique_ptr` because we wrote a constructor
    that forces a valid `std::unique_ptr`, forgetting that a move can undo this explicit
    validity. The result is that, when a move is performed, we get a segmentation
    fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, we need a reminder that we made this assumption, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class explicitly deletes both the copy and move operations, and
    this is our desired intent. Now, if we accidentally move this class, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This error tells us that it is assumed that the class is valid and therefore
    does not support moving. We either need to properly support moving (which means
    we must maintain support for invalid `std::unique_ptr`) or we need to remove the
    `move` operation. As shown, a class that cannot be moved or copied can ensure
    that our code works as intended, providing the compiler with a mechanism to warn
    us when we are doing something with our class that we didn't intend.
  prefs: []
  type: TYPE_NORMAL
