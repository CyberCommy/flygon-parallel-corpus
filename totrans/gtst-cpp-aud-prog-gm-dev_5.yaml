- en: Chapter 5. Intelligent Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have played sounds in a very linear fashion; we load an
    audio file from a disk and play it when needed, optionally controlling some of
    its parameters during playback. Even when we used advanced features such as 3D
    audio, there was still a one-to-one relationship between the sound and the audio
    file.
  prefs: []
  type: TYPE_NORMAL
- en: However, a sound does not necessarily correspond to a single audio file. In
    many scenarios we can benefit from using multiple audio files for a single sound.
    For example, we can often reduce repetition by providing several variations of
    the same sound as separate audio files, or we can build complex soundscapes by
    combining several smaller sound fragments.
  prefs: []
  type: TYPE_NORMAL
- en: For other sounds, the modifications we apply at runtime to their parameters
    are just as important as the audio files that compose them. For example, we cannot
    realistically simulate the sound of a car engine without constantly updating its
    pitch and volume based on the engine's rpm and load values. Another common example
    is to have a soundtrack dynamically react to the events in the game in order to
    convey more or less tension to the player.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we could certainly implement any of these features by writing
    specialized code for each situation, orchestrating each audio file and sound parameter
    as necessary. However, this approach takes a significant amount of effort, and
    is hard to manage and tweak, since most of the behavior gets hardcoded into the
    game. An even bigger problem is that it is usually a sound designer, not a programmer,
    which creates the sounds for a game, and using this approach would require a significant
    amount of communication and synchronization between both parties.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we can solve this problem by using a high-level audio engine. These
    engines usually provide an external tool that the sound designer can use to create
    complex sounds, independently from a programmer, and store them as sound events.
    Then, regardless of the complexity of the sound, the programmer can easily trigger
    it from the game, usually by writing the name of the event.
  prefs: []
  type: TYPE_NORMAL
- en: The main difficulty in covering this topic is that there are several high-level
    audio engines available, and each of them has its own set of features and philosophy.
    Using these tools, we can perform things such as generative audio (generating
    audio at runtime from a set of sound samples and rules) or adaptive music (music
    that changes depending on game events). To simplify the terminology, we will be
    using the term intelligent audio to encompass all situations where a sound can
    have complex behavior attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work with the FMOD Designer tool and see some of the
    interesting stuff that we can do with it. A detailed coverage of the tool would
    be impossible given the limited scope of the book, but it should be enough to
    give you some ideas and to get you started. For more information, the FMOD Designer
    tool ships with a user manual that is over 400 pages long, and a sample project
    with many examples.
  prefs: []
  type: TYPE_NORMAL
- en: Audio files versus sound events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before installing the FMOD Designer tool, let us start by really understanding
    the difference between treating each audio file as a sound, and working at a higher
    level of abstraction with sound events (or sound cues in some engines). The following
    figure demonstrates how we have been approaching audio in our games so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio files versus sound events](img/9099OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this model, we can see that the game interacts directly with the audio files,
    and that the code is responsible for using these audio files in a way that is
    appropriate for the game, which usually requires the creation of specialized codes.
    When we move over to using a high-level audio engine such as the FMOD Designer,
    the process is significantly different, as we can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio files versus sound events](img/9099OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first difference in this model is that the game does not interact directly
    with audio files. Instead, it interacts with entities known as sound events, which
    may contain multiple audio files, and encapsulate all of the custom behavior and
    parameters of the sound that were previously inside the game. This separation
    makes the game code a lot simpler, and provides a better environment for a sound
    designer to work.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also, that there is an audio project file that groups all sound events
    together. This means that the game only needs to load this single file to get
    access to all sound events, which is significantly easier than having to load
    every individual audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the FMOD Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The FMOD Designer is the high-level, data-driven API that complements the FMOD
    Ex low-level engine that we have been using so far. It contains two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FMOD Designer**: This is a sound designer tool that allows us to create complex
    sound events and interactive music for our games (from [http://www.fmod.org](http://www.fmod.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMOD Event System**: This is an application layer that lets us use the content
    created with the designer within our games (comes bundled with FMOD Ex, inside
    the `fmoddesignerapi` folder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The FMOD Designer projects have the `.fdp` extension, but to use them inside
    of a game you must first build them from the **Project** menu. The build process
    generates a `.fev` file, containing all the information for every sound event
    in the project, and one `.fsb` file for each wave bank in the project, which is
    where the audio files are stored. The following is a screenshot of the FMOD Designer
    user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the FMOD Designer](img/9099OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most important task of the FMOD Designer is to create sound events. There
    are two types of sound events in FMOD, and an interactive music system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple events**: With simple events, we can create sounds composed by multiple
    audio files, and play them randomly or sequentially, one or several at a time,
    at different rates, and with random volume or pitch variation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-track events**: With multi-track events, we can combine as many simple
    events as we need (in this case called **sound defs**), organize them into layers,
    apply effects to them, control which sound defs should be playing at any given
    time, create custom parameters, and link those parameters to any of the properties
    of the sound or effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactive music**: With the interactive music system, we can create songs
    (called **cues**) composed by multiple segments, and have the game transition
    between them in response to certain events. Besides transitions, we can also add
    flourishes to the music, which play concurrently and synchronized with the main
    song'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the next few sections, we will briefly cover the main features and user
    interface of the first two of these systems, as well as some ideas and examples
    of how to use them in the context of a game. Coverage of the topic of interactive
    music will have to be more superficial, because its breadth exceeds the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Simple events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simple events are the easiest to use, as well as the least resource intensive.
    We should therefore try to use simple events whenever they are enough for our
    requirements. With a simple event, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a sound composed by multiple audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play audio files sequentially or in a random order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomize sound properties, such as volume or pitch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the looping behavior of the sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play multiple audio files at once, or at certain intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a simple event, go to the **Events** section, right-click on top
    of any **Event Group**, and then select the **Add Simple Event** option. If there
    is no **Event Group** created, we can create one from the same context menu. Event
    groups behave like folders and serve to organize all of our events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple events](img/9099OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the event selected, the next step is to add the audio files that compose
    it to the **Playlist** pane, either through the right-click context menu, or by
    dragging some audio files into it. If we intend to play the audio files in a random
    order, we can specify the probability of each file playing through the right-click
    context menu, or using the dial control at the bottom-left corner of the pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple events](img/9099OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the **Playlist Options** pane, we can control how the audio engine should
    pick files from the playlist. There are three different **Playlist Behaviors**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random**: This option picks an audio file at random every time, following
    the weights attributed in the playlist to each of them. We can also select whether
    to allow the same audio file to play twice in a row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shuffle**: This option randomizes the playlist once, and then plays the audio
    files in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential**: This option follows the same order in which the audio files
    appear in the playlist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the **Playlist Options** pane, we can also find a **Sound Randomization**
    section, which lets us apply some variation to the starting volume and pitch of
    each file (similar to what we implemented ourselves back in [Chapter 3](ch03.html
    "Chapter 3. Audio Control"), *Audio Control*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple events](img/9099OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Playback Options** pane, which controls how many audio files, should
    be played and how often, there are four different **Playback Modes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oneshot**: This mode picks a single audio file, and plays it only once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeating Loop**: This mode picks a single audio file, and plays it multiple
    times (with the number of times being controlled by the **Play Count** parameter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Successive Loop**: This mode plays multiple audio files in succession, picking
    a new one each time (with the number of files to play being controlled by the
    **Loop Count** parameter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Granular**: This mode is similar to the previous mode, but allows us to control
    the time to wait between each file that is played (**Grain Interval** parameter),
    how many files can be playing simultaneously (**Polyphony** parameter), and the
    total amount of files to play before the sound ends (**Total Grains** parameter)![Simple
    events](img/9099OT_05_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is the **Properties** pane on the right side of the interface,
    which allows us to control several other properties of the sound event, such as
    most of the 3D audio properties discussed on the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of simple events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas of how we can use simple events to enrich the audio in our
    games. Most of these ideas can be found on the examples project that comes with
    the FMOD Designer, so be sure to look there too.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding repetitive sound effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most games have a few sound effects that are played all the time, such as the
    sound of a character's footsteps, or the sound of a gun. If we use the exact same
    audio file every time, the player will usually notice the repetition after some
    time, which is undesirable in most cases. Using simple events, we can easily make
    these sound effects more interesting and dynamic, just by providing a few variations
    of the sound and letting the audio engine pick one randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a very small volume and pitch variation to the sound can also do wonders,
    as long as the variation is not large enough to change the overall nature of the
    sound. Values along the lines of `-3` dB for the volume and `+/- 2` semitones
    for the pitch are usually good starting points.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a footsteps sound loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways we can use a footsteps sound effect in a game. For example,
    we could have an audio file containing the sound of a single footstep, and trigger
    it once for every step the character takes inside the game world, or we could
    have a looping audio file with a walking sound, and play it constantly whenever
    the character is walking.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach requires more work inside the game, while the second approach
    takes more memory, as the audio file needs to be longer. Using a simple event,
    we can combine both approaches, by taking an audio file of a single footstep,
    and setting up the event so that it performs the looping, using time intervals
    that are appropriate for a certain walking speed. Later, when working with multi-track
    events, we will also see a way to vary the walking speed dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a simple event with the footstep audio files (following
    the advices given earlier in order to avoid repetition) and set the playback mode
    to granular. Then we adjust the grain interval so that the time between each footstep
    corresponds to the speed of the character walking, and increase the polyphony
    so that each footstep can sound without having to wait for the previous to end.
    We can also set slightly different maximum and minimum grain interval values,
    to reinforce the variations of the sound even further.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a breaking glass sound effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach we can use to reduce repetition in our sound effects is to
    generate them at runtime as a combination of a few smaller sound fragments. For
    example, to simulate the sound of a glass object falling to the ground and shattering,
    we could have a pool of different glass breaking sounds, and always play two or
    three of them in quick succession. Combined with the usual volume and pitch variations,
    the result is a sound effect that will sound different most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this type of sound effect, we need to use the granular playback
    mode, and set both the polyphony and the grain count parameters to the number
    of sound fragments that we want to use at once. For the breaking glass sound effect,
    we could set the polyphony and grain count to 2 or 3, and set a very small grain
    interval (for example, 200 ms), so that the sounds play almost at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ambient track of singing birds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same technique used to generate the sound of a glass breaking can also generate
    long, looping, and ever changing, ambient tracks. A common example is to take
    a few small audio files of birds singing, and by triggering them randomly at different
    times, and with different volume and pitch, we can easily give the impression
    of being in a forest, where there are several different birds singing. The process
    is very similar to the previous effect, except that this time we should set a
    large polyphony (such as 15), a grain interval value of around 1s, and an infinite
    grain count so that the sound does not stop playing. Modifying the 3D position
    randomization properties can also be useful to create a volumetric sound, and
    give the impression that every bird is located in a different point in space,
    instead of every sound coming from the same spot.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-track events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multi-track events are significantly more powerful than simple events. In fact,
    before adding any sound to a multi-track event, we must turn it into a sound def,
    which has almost the same functionality as a simple event. With a multi-track
    event, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform everything that we could with a simple event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create multiple layers of sounds that play at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply one or more DSP effects to each layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create custom parameters to modify the sound in real-time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play different sounds depending on the value of a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify any of the sound or effect properties from a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before creating a multi-track event, we must prepare a sound def for each of
    the sounds that we intend to use. The process is similar to creating a simple
    event, although the interface is a bit different. Head over to the **Sound Defs**
    section, right-click on top of any folder, and select one of the **Add sound def**
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The interface used to create a sound def is a bit like a condensed version
    of the simple event interface, with the playlist on the left, and every other
    property on the right. Since most of the properties control something that we
    have already seen in simple events, there is no need to repeat that information
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a multi-track event, follow the same steps used to create a simple
    event, but select the **Add Multi-Track Event** option instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A multi-track event is divided into layers, or tracks, with each layer being
    able to contain multiple sound defs. Adding a new layer, or adding sound to a
    layer, are both handled by right-clicking on the following interface and selecting
    the **Add layer** or **Add sound** option from the context menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the preceding example will play all three sound defs at the same
    time. This behavior changes as soon as we add a parameter to the sound, which
    can be done by right-clicking on the dark area on top of the sounds region, and
    selecting the **Add parameter** option from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A parameter is essentially a variable with a certain range of permitted values
    that the game code can modify. The way the FMOD Designer represents parameters
    might look like a timeline, but it is important to understand that a parameter
    is a generic value, and does not necessarily represent time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter we create is marked as the **primary** parameter, and it
    determines which sounds to play. In the following example, only the two sounds
    that are in contact with the red line (representing the current value of the **primary**
    parameter) will be playing. Changing the value of the parameter to any value above
    0.5 would replace the **Frogs** sound with the **Crickets** sound. We can create
    multiple parameters in the same event, although only one of them will be marked
    as primary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another use of parameters is to control the sound properties of each layer.
    In order to do that, we must first add an effect to the layer we want to control,
    by right-clicking on the layer, and selecting the **Add effect** option. Effects
    can vary from a simple volume or pitch control, to more complex DSP effects, such
    as a distortion or a delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Having an effect added to a layer, and a parameter selected, we can draw curves
    on the layer, which represent how the properties of the effect should vary with
    the values of the parameter. In the following example, we have added a second
    parameter to the event, which modifies the pitch of the first layer, and the volume
    of the second layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, by right-clicking on any sound inside a multi-track event, we can
    access some sound instance properties that are not available elsewhere. Among
    those properties, there is an auto pitch feature, which behaves like adding a
    pitch effect to that sound, and controlling it based on a parameter, but is simpler
    to use. This feature is useful when trying to simulate the sound of a car engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-track events](img/9099OT_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Examples of multi-track events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas of how we can use multi-track events to provide a more interactive
    and dynamic game audio experience in our games. Many of these ideas build upon
    the ones discussed earlier for simple events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interactive footsteps sound loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the simple event examples from the previous section described how to
    generate a looping footsteps sound. However, that sound was only useful for a
    specific walking speed, and for a specific surface. Using multi-track events,
    we can create a single sound event that contains footstep sounds for all different
    types of surfaces, such as grass, concrete, or sand, and allow the game to control
    the walking speed through a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we must first create a sound def for each type of surface
    the character can walk on. Each sound def should play a footsteps sound loop at
    the average walking speed, which we can control with the spawn rate parameter
    (this speed should be consistent between each sound def).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we must create a multi-track event with a single layer, and two parameters
    to control the surface type (primary) and the walking speed. By adding all the
    sounds to this layer, distributing them evenly (by right-clicking and selecting
    the **Layout sounds evenly** option), and setting the maximum range of the `surface
    type` parameter to be the total number of sounds in the layer, we can use that
    parameter as a simple index to select which surface the character is walking on.
  prefs: []
  type: TYPE_NORMAL
- en: For the `walking speed` parameter, we need to add an effect of type `Spawn Intensity`
    to the layer, and draw a curve to control how the spawn intensity relates to the
    `walking speed` parameter. For example, a value of 0.5 means that the footsteps
    will occur at half the average speed, while a value of 2.0 means that footsteps
    will occur at twice the average speed.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating the sound of a car engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use multi-track events to generate complex interactive sounds, such
    as the sound of a car engine. The FMOD Designer examples project has a great car
    engine simulation that we can study. That sound event has two layers, and two
    parameters, one for the engine's rpm, and one for the engine's load.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the layers contains four different sounds, recorded from a car engine
    at different rpm ranges. The sounds on the top layer correspond to the car accelerating
    (on-load), while the sounds on the bottom layer correspond to the car decelerating
    (off-load).
  prefs: []
  type: TYPE_NORMAL
- en: The `load` parameter serves to blend between both layers at runtime with a volume
    effect. When the `load` parameter is in the middle, we hear a mix of both layers,
    but as the `load` parameter changes, the volumes quickly change so that we only
    hear one of the layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rpm` parameter serves two purposes. As the primary parameter, it determines
    which of the four sounds should be playing for the current value. The sounds actually
    overlap at the edges, so at certain rpm values, we can hear a mix of two sounds
    at once. The other purpose of the `rpm` parameter is to modify the pitch of the
    sound, so that higher the rpm value, the higher is the pitch of the sound. This
    is handled automatically by enabling the **auto-pitch** feature on each of the
    sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simulating the sound of a car engine](img/9099OT_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a complex ambient track of a forest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a simple event, we were able to create a looping ambient track with a
    large number of singing birds. Using a multi-track event, we can easily extend
    the ambient track to contain other layer of sounds. For example, we could add
    a layer with the sound of the wind looping in the background, and layers for other
    types of animal cries, probably occurring at different rates than the bird sounds.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to simulate a cave within the forest, we could create a parameter
    to control the location of the character, and add an occlusion effect to every
    layer that is only active for a certain range of values.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we could create a parameter to specify the time of the day, and
    play different sounds depending on its value, such as removing the sounds of the
    birds at night, and bringing some cricket sounds in.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that we can create complex sound effects that change depending
    on the events of the game, it is also possible to do the same for the game's background
    music. This allows the music to adapt to the circumstances, for example, to convey
    the correct emotion for the moment, or provide a sense of tension when danger
    draws near.
  prefs: []
  type: TYPE_NORMAL
- en: Music that is played in a non-linear fashion like this is known as interactive
    music (if the player directly controls the changes) or adaptive music (if the
    music reacts to the game environment, but not necessarily to the player). There
    are two main approaches to creating interactive music.
  prefs: []
  type: TYPE_NORMAL
- en: The vertical approach (re-orchestration)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this approach, the audio system modifies the mix of the song in real-time
    depending on events occurring in the game. This can consist, for example, of adding
    new instruments to the song, or making the music play faster or slower to match
    the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to implement this type of interactive music in the FMOD Designer
    is by using multi-track events in combination with specially prepared multi-channel
    audio files (which we can create using audio editing software, such as Audacity).
    This usually requires splitting up the music into layers, and adding each of the
    layers to a different audio channel in the file. Then, using the Channel Mix effect
    on a multi-track event, we can easily control the individual volumes of each audio
    channel based on the value of a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common application of this technique is to create a `tension` or `excitement`
    parameter, so that the song gets more intense (by adding more layers) as the value
    increases. The famous Japanese composer, Koji Kondo, is very fond of creating
    interactive music using this approach. Some recent examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: On the Super Mario Galaxy levels where Mario rides on top of a star ball, the
    speed at which Mario moves completely determines the pitch, playback rate, and
    even the amount of instruments playing in the song.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the market area of The Legend of Zelda: Skyward Sword, each merchant has
    its own variation of the market theme. As the link approaches one of the merchants,
    the music changes very smoothly into the corresponding variation (while retaining
    the correct relative positioning within the theme).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The horizontal approach (re-sequencing)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this approach, the music moves or jumps between different sections depending
    on the events of the game. This usually requires splitting the music into segments,
    so that the game can transition between them. When the system is not transitioning
    between segments, it keeps looping the current segment, and the music continues
    playing indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Information about the tempo and time signature of the music is frequently required,
    so that the audio system can synchronize transitions to beats or measures of the
    song to provide a more musical experience. The interactive music system in the
    FMOD Designer is capable of creating interactive music sequences in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of interactive music using the horizontal approach is the
    song, *A pirate I was meant to be*, in *Monkey Island 3*, where the player can
    actually select, in real-time, what verse of the song the characters will sing
    next. The song waits in a loop while the player makes his choice, and transitions
    gracefully afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Calling sound events from the game code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test our FMOD Designer project in a game, we must first build the
    project, by selecting the **Build from the Project** menu, or pressing *Ctrl*
    + *B*. This process will generate the `fev` and `fsb` files that we have to copy
    to our game assets folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to add some extra dependencies to our C++ project, so that we
    can interact with the FMOD Designer API. These dependencies ship together with
    the FMOD Ex Programmer''s API, but we must add the references ourselves, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **C/C++** | **General**, and add `C:\FMOD\ fmoddesignerapi\api\inc`
    to the list of **Additional Include Directories** (entries are separated by semicolons).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Linker** | **General**, and add `C:\FMOD\ fmoddesignerapi\api\lib`
    to the list of **Additional Library Directories**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Linker** | **Input**, and add `fmod_event.lib` to the list of
    **Additional Dependencies**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build Events** | **Post-Build Event**, and add `xcopy /y "C:\FMOD\fmoddesignerapi\api\fmod_event.dll”
    "$(OutDir)”` to the **Command Line** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `<fmod_event.hpp>` header file from your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the process of loading an FMOD Designer project, playing a sound event,
    and modifying some of its parameters, is in many ways similar to what we saw in
    [Chapter 2](ch02.html "Chapter 2. Audio Playback"), *Audio Playback*. Let us take
    a look at the most basic way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create and initialize an `FMOD::EventSystem` object, and load
    the project file. We should also call the `update()` method in every frame, and
    the `release()` method at the end of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to play an event, we must get a reference to it, by using the fully
    qualified name of the event, which contains the project name, the name of the
    event group that contains the event, and the name of the event itself. Then, we
    can simply use the `start()` method to play the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if there is a parameter that we want to modify, we can get a reference
    to it using the `getParameter()` method of the event object, and change the value
    using the `setValue()` method of the parameter object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how a sound can be a lot more than just an audio
    file, how FMOD has a high-level tool called the FMOD Designer, how we can create
    simple and multi-track sound events in the FMOD Designer, how we can also apply
    some of these concepts to music and play sound events created in the FMOD Designer
    from our applications.
  prefs: []
  type: TYPE_NORMAL
