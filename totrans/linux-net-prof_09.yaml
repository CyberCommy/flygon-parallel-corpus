- en: '*Chapter 6*: DNS Services on Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Domain Name System** (**DNS**) is a major underpinning of today''s information-based
    society. A proverb used within the technical community (phrased in haiku format)
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s not DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*There is no way it''s DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: '*It was DNS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This describes more technical problems than you might think, up to widespread
    internet or cloud service outages. It also nicely describes the progression of
    how a problem is solved, with the answer: *"The root problem is always DNS."*
    This nicely illustrates just how important this service is to almost every facet
    of today''s corporate networks and public internet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover several topics that involve DNS basics, then
    build—and finally, troubleshoot—DNS services. We''ll look at the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: What is DNS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two main DNS server implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common DNS implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS troubleshooting and reconnaissance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, with the DNS basics covered, we''ll discuss the following two entirely
    new DNS implementations that are seeing rapid adoption:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS over **HyperText Transfer Protocol Secure** (**HTTPS**), known as **DoH**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS over **Transport Layer Security** (**TLS**), known as **DoT**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also discuss the **DNS Security Extensions** (**DNSSEC**) implementation,
    which cryptographically signs DNS responses to prove that they are verified and
    haven't been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be able to continue working with your existing Linux host or **virtual
    machine** (**VM**) as we go through the examples in this chapter. There are no
    additional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What is DNS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS is essentially a translator between what people want and what a network
    needs to make that happen. People, for the most part, understand text names of
    hosts and services—for instance, `google.com` or `paypal.com`. However, these
    names don't mean anything to the underlying network. What DNS does is take those
    "fully qualified hostnames" that someone might type into an application, such
    as their browser at **Open Systems Interconnection** (**OSI**) Layer 7 (remember
    the OSI layers in [*Chapter 3*](B16336_03_Final_NM_ePub.xhtml#_idTextAnchor053),
    *Using Linux and Linux Tools for Network Diagnostics*), and translates them into
    **Internet Protocol** (**IP**) addresses that can then be used to route the application
    request at OSI Layers 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: In the reverse direction, DNS can also translate an IP address into a **fully
    qualified domain name** (**FQDN**), using what's called a **pointer** (**PTR**)
    request (for a DNS PTR record) or "reverse lookup". This can be important to technical
    folks, but these requests are not as commonly seen by regular people running their
    browsers and other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Two main DNS server implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS has a large and complex infrastructure on the internet (which we'll touch
    on in this section). This is made up of 13 root name servers (which are each a
    reliable cluster of servers), a group of commonly used name servers (for instance,
    the servers we use at Google or Cloudflare), and a series of registrars who will,
    for a fee, register a DNS domain name for you—for instance, your organization's
    domain name.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the most part, most administrators are working with the needs of
    their organization—working with their internal DNS name servers that face their
    internal folks, or with their external DNS name servers that face the internet.
    It is these two use cases that we'll be focusing on in this chapter. You will
    see as we build these examples out how the Google or Cloudflare DNS infrastructure,
    or even the root DNS servers, are not all that different.
  prefs: []
  type: TYPE_NORMAL
- en: An organization's "internal" DNS server (and a DNS overview)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common DNS service that organizations deploy is an **internal DNS server**
    for their own people's use. This server likely has a zone file populated with
    DNS records for internal DNS resolution. This file can either be populated manually
    by editing the zone file or can be populated automatically, using auto-registration
    by the clients or from **Dynamic Host Configuration Protocol** (**DHCP**) leases.
    Often, all three methods are combined.
  prefs: []
  type: TYPE_NORMAL
- en: The basic request flow is simple. A client makes a DNS request. If that request
    is for a host that's internal to the organization and the request is to an internal
    DNS server, the DNS response is supplied immediately since it's on that local
    DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s for an external host, then things are bit more complex—for instance,
    let''s query for `www.example.com`. Before we start, note that the following diagram
    shows the *worst case*, but there is a caching process at almost every step that
    usually allows for one or more steps to be skipped along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A dizzying overview of how complicated a single DNS request
    can get'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_06_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – A dizzying overview of how complicated a single DNS request can
    get
  prefs: []
  type: TYPE_NORMAL
- en: 'This process looks pretty complicated, but you''ll see that it goes by pretty
    fast, and in fact has a number of *escape hatches* that let the protocol skip
    many of these steps in lots of cases. Let''s look at the entire *worst-case* process
    in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the entry is in the DNS cache of the internal DNS server, and the **time
    to live** (**TTL**) of that entry has not expired, then the response is supplied
    immediately to the client. Similarly, if the client is requesting an entry that's
    hosted on the server in a zone file, the answer is supplied immediately to the
    client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the entry is not in the cache of the internal DNS server, or if it is in
    the cache but the TTL of that entry has expired, then the internal server forwards
    the request to its upstream providers (often called **forwarders**) to refresh
    the entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the query is in the cache of the forwarder, it will simply return the answer.
    If this server has the authoritative name server for the domain, it will simply
    query that host (skipping ahead in the process to *Step 5*).
  prefs: []
  type: TYPE_NORMAL
- en: If the forwarder does not have the request in the cache, it will in turn request
    upstream. In this case, though, it will likely query the root name servers. The
    goal in this is to find the "authoritative name server" that has the actual entries
    (in a zone file) for that domain. In this case, the query is made to the root
    name servers for `.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root name server will not return the actual answer, but will instead return
    the authoritative name server for the `.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the forwarder gets this response, it updates its cache with that name
    server entry, then makes the actual query against that server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authoritative server for `.com` returns the authoritative DNS server for
    `example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The forwarder server then makes a request against this final authoritative name
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authoritative name server for `example.com` returns the actual query *"answer"*
    to the forwarder server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The forwarder name server caches that answer, then sends a reply back to your
    internal name server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your internal DNS server also caches that answer, then forwards it back to the
    client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client caches the request in its local cache, then passes the requested
    information (the DNS response) to the application that requested it (perhaps your
    web browser).
  prefs: []
  type: TYPE_NORMAL
- en: Again, this process shows the worst-case process to make a simple DNS request
    and receive an answer. In practice, once the servers have been up for even a short
    period of time, caching shortens this considerably. Once in a steady state, the
    internal DNS server for most organizations will have most requests cached, so
    the process skips right from *Step 1* to *Step 10*. In addition, your forwarding
    DNS server will cache—in particular, it will almost never query the root name
    servers; usually, it will have the TLD servers (in this case, the server for `.com`)
    cached as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this description, we also brought up the concept of "root name servers".
    These are the authoritative servers for the root or the `.` zone. There are 13
    root servers for redundancy, each of which in turn is actually a reliable cluster
    of servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which key features do we need to enable on your internal DNS server to make
    all this work? We need to enable the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS recursion**: This model relies on DNS recursion—the ability for each
    server in turn to make the client''s DNS request "up the line". If the DNS entry
    requested is not defined on the internal server, it needs permission to forward
    those requests on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forwarder entries**: If the requested DNS entry is not hosted on the internal
    server, **internal DNS service** (**iDNS**) requests are forwarded to these configured
    IP addresses—these should be two or more reliable upstream DNS servers. These
    upstream servers will in turn cache DNS entries and expire them as their TTL timers
    expire. In days past, people would use their **internet service provider''s**
    (**ISP''s**) DNS servers for forwarders. In more modern times, the larger DNS
    providers are both more reliable and provide more features than your ISP. Some
    of the common DNS services used as forwarders are listed next (the most commonly
    used addresses appear in bold):![](img/Table_011.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: In a large organization, a DNS server''s performance can be greatly
    improved by adding memory—this allows more caching, which means that more requests
    can be serviced locally, direct from the memory of the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic registration**: While servers usually have static IP addresses and
    static DNS entries, it''s common for workstations to have addresses assigned by
    DHCP, and having those workstations in DNS is of course desirable as well. DNS
    is often configured to allow dynamic registration of these hosts, either by populating
    DNS from DHCP addresses as they are assigned or by permitting the hosts to register
    themselves in DNS (as described in **Request for Comments** (**RFC**) *2136*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft implements an authentication mechanism into their dynamic update process,
    and this is where it is most commonly seen. It is, however, an option in Linux
    DNS (**Berkeley Internet Name Domain**, or **BIND**) as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Host redundancy**: Almost all core services benefit from redundancy. For
    DNS, that is usually with a second DNS server. The database is usually replicated
    in one direction (from the primary to the secondary server) and uses the serial
    number in the zone file to know when to replicate, using a copy process called
    a **zone transfer**. Redundancy is key to account for various systems failures,
    but it''s just as important in allowing system maintenance without a service interruption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an internal DNS server in place, what needs to be changed in our configuration
    to make a DNS server that serves a zone to the public internet?
  prefs: []
  type: TYPE_NORMAL
- en: An internet-facing DNS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of an internet-facing DNS server, you are most likely implementing
    an authoritative DNS server for one or more DNS zones. For instance, in our reference
    diagram (*Figure 6.1*), the authoritative DNS server for `example.com` would be
    a good example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation, the focus shifts from the internal server''s emphasis
    on performance and forwarding to restricting access for maximum security. These
    are the restrictions that we want to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restrict recursion**: In the DNS model we''ve outlined, this server is "the
    end of the line"—it''s directly answering DNS requests for the zone(s) it is hosting.
    This server should never have to look upstream to service a DNS request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache is less important**: If you are an organization and you are hosting
    your own public DNS zones, then you only need enough memory to cache your own
    zones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host redundancy**: Again, if you are hosting your own zone files, adding
    a second host is likely more important to you than adding a cache. This gives
    your DNS service some hardware redundancy so that you can do maintenance on one
    server without interrupting the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restricting zone transfers**: This is a key restriction that you want to
    implement—you want to answer individual DNS queries as they arrive. There isn''t
    a good reason for a DNS client on the internet to request all entries for an organization.
    Zone transfers are meant to maintain your zone between redundant servers so that
    as a zone is edited, the changes are replicated to the other servers in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: DNS servers have a feature called **Response Rate Limiting**
    (**RRL**) that limits how frequently any one source can query that server. Why
    would you implement such a feature?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS is often used in "spoofing" attacks. Since it is based on the **User Datagram
    Protocol** (**UDP**), there is no "handshake" to establish a session; it's a simple
    request/response protocol—so, if you want to attack a known address, you can simply
    make DNS queries with your target as the requester, and the unsolicited answer
    will go to that IP.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't seem like an attack, but if you then add a "multiplier" (in other
    words, if you are making small DNS requests and get larger responses—for instance,
    **text** (**TXT**) records—and you are using multiple DNS servers as "reflectors"),
    then the bandwidth you are sending to the target can add up pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: This makes rate limiting important—you want to restrict any one IP address to
    make a small number of identical queries per second. This is a reasonable thing
    to do; given the reliance of DNS caching, any one IP address shouldn't make more
    than one or two identical requests in any 5-minute period, since 5 minutes is
    the minimum TTL for any DNS zone.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to enable rate limiting is to restrict the ability of an attacker
    to do reconnaissance in DNS—making dozens or hundreds of requests for common DNS
    names and compiling a list of your valid hosts for subsequent attacks against
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Restricting dynamic registration**: Dynamic registration is, of course, never
    recommended on most internet-facing DNS servers. The one exception would be any
    organization that offers **Dynamic DNS** (**DDNS**) registration as a service.
    Companies of this type include Dynu, DynDNS, FreeDNS, and No-IP, among several
    others. Given the specialist nature of these companies, they each have their own
    methods of securing their DDNS updates (often involving a custom-written agent
    and some form of authentication). The direct use of *RFC 2136* is simply not securable
    for an internet-facing DNS server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the basics of implementing both an internal DNS server and starting to
    secure these for their various use cases, which DNS applications do we have available
    to work with to build a DNS infrastructure? Let's learn about this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Common DNS implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**BIND**, also called **named** (for **name daemon**), is the DNS tool most
    often implemented in Linux, and is arguably both the most flexible and complete,
    as well as the most difficult to configure and troubleshoot. For better or worse,
    though, it''s the service you are most likely to see and to implement in most
    organizations. The two main implementation use cases are outlined in the next
    two sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS Masquerade** (**dnsmasq**) is a competing DNS server implementation.
    It''s commonly seen on network appliances because of its small footprint, but
    also makes a fine DNS server for a smaller organization. The key advantages to
    Dnsmasq would include its built-in **graphical user interface** (**GUI**) that
    can be used for reporting, as well as its integration with DHCP (which we''ll
    discuss in the next chapter), allowing DNS registration directly from the DHCP
    database. In addition, Dnsmasq implements a friendly way to implement DNS blocklists,
    which are very nicely packaged up in the Pi-hole application. If your home network
    has a DNS server on its perimeter firewall or **Wireless Access Point** (**WAP**),
    that DNS server is most likely Dnsmasq.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on the commonly used BIND (or named) DNS server.
    Let's get on with building our internal DNS server using that application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic installation: BIND for internal use'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you would expect, installing `bind`, the most popular DNS server in Linux,
    is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the `/etc/bind/named.conf` file. In older versions, the application
    configuration was all in this one monolithic configuration file, but in newer
    versions it''s simply composed of three `include` lines, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `/etc/bind/named.conf.options`, and add the following options—be sure
    to use `sudo` as you need admin rights to change any of the configuration files
    for `bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow queries from the list of local subnets. In this example, we're allowing
    all subnets in *RFC 1918*, but you should restrict this to the subnets you have
    in your environment. Note that we're using classless subnet masking to minimize
    the number of entries in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the listening port (this is correct by default).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable recursive queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a list of DNS forwarders for recursion to work. In this example, we'll
    add Google and Cloudflare for DNS forwarding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once done, our configuration file should look something like this. Note that
    it really is an almost "plain language" configuration—there''s no mystery about
    what any of these sections mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit `/etc/bind/named.conf.local`, and add the server type, zone, and
    zone filename. Also, permit workstations on the specified subnets to register
    their DNS records with the DNS server using the `allow-update` parameter, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zone` file itself, where the DNS records are all stored, is not located
    in the same place as these first two `config` files. To edit the `zone` file,
    edit `/var/cache/bind/<zone file name>`—so, in this example, it''s `/var/cache/bind/coherentsecurity.com.zone`.
    You''ll again need `sudo` access to edit this file. Make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Add records as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `SOA` line with your zone and name server's FQDN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If needed, update the `TTL` value in the last line in the `SOA` record—the default
    is `86400` seconds (24 hours). This is usually a good compromise as it favors
    caching of records across multiple servers. If you are doing any DNS maintenance,
    though, you might want to edit the file the day before (that is, 24 hours or more
    prior to maintenance) and shorten this to 5 or 10 minutes so that your changes
    aren't delayed due to caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `ns` record, which identifies the DNS server(s) for your domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `A` record as needed—these identify the IP addresses for each host. Note
    that for `A` records, we're only using the **common name** (**CN**) for each host,
    not the FQDN name, which would include the domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once done, our DNS zone file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – An example DNS zone file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_06_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – An example DNS zone file
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, in an internal DNS zone it's often desirable to have
    clients register themselves in DNS. This allows administrators to reach clients
    by name rather than having to determine their IP addresses. This is a simple edit
    to the `named.conf` file (or, more likely, the applicable included child file).
    Note that this requires us to add `192.168.122.0/24` (defining that whole subnet)
    would likely be more common. A corporate "supernet" that defines the entire company
    is also commonly seen—for instance, `10.0.0.0/8` or `192.168.0.0/16`—but for security
    reasons this is not usually recommended; you likely don't actually need devices
    auto-registering in *every* subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the applicable zone, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few scripts that will check your work—one for the basic configuration
    and included files, and another for the zone. `named-checkconf` will not return
    any text if there is no error, and `named-checkzone` will give you some `OK` status
    messages, as shown next. If you run these and don''t see errors, you should be
    at least OK enough to start the service. Note that the `named-checkzone` command
    wraps to the next line in the following code example. Errors in the `bind` configuration
    files are common—such as missing semicolons, for instance. These scripts will
    be very specific about issues found, but if they error out and you need more information,
    the log file for these commands (`bind` for `bind` itself) is the standard `/var/log/syslog`
    file, so look there next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enable the `bind9` service and start it (or restart it if you are
    "pushing" an update) by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now able to resolve hostnames in our zone, using the DNS server on our
    local host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Because recursion and forwarders are in place, we can also resolve hosts on
    the public internet, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With our internal DNS server completed and working, let's look at our internet-facing
    DNS, which will allow people to resolve our company's resources from the public
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'BIND: Internet-facing implementation specifics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, this configuration is not nearly as common as it once was.
    Going back to the 1990s or earlier, if you wanted people to get to your web server,
    the most common approach was to stand up your own DNS server or to use one provided
    by your ISP. In either case, any DNS changes were manual file edits.
  prefs: []
  type: TYPE_NORMAL
- en: In more recent times, it's much more common to host your DNS services with your
    DNS registrar. This "cloud" approach leaves the security implementation to that
    DNS provider and also simplifies maintenance, as the various providers usually
    give you a web interface to maintain your zone file. The key security consideration
    in this model is that you will want a provider that gives you the option to enable
    **multi-factor authentication** (**MFA**) (for instance, using Google Authenticator
    or similar) to guard against **credential stuffing** attacks against your administrative
    access. It's also worth researching your registrar's account recovery procedures—what
    you don't want is to go through all the work of implementing MFA to then have
    an attacker steal that too with a simple helpdesk call to your DNS registrar!
  prefs: []
  type: TYPE_NORMAL
- en: 'All that being said, many organizations still do have a good use case for implementing
    their own DNS servers, so let''s get on with modifying the configuration we have
    from our previous section for use as an internet DNS server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`etc/bind/named.conf.options`, we''ll want to add some form of rate limiting—in
    the case of DNS, this is the RRL algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, keep in mind that this has the possibility to deny service to legitimate
    queries. Let''s add a `responses-per-second` value of `10` as a preliminary rate
    limit but set it to a status of `log-only`. Let it run in `log-only` mode for
    some period of time, and adjust the per-second rate up or down until you are comfortable
    that you have a value that is low enough to prevent aggressive attacks but high
    enough that you won''t deny access during legitimate operations. The log file
    to monitor during this process is, as mentioned previously, `/var/log/syslog`.
    When you are happy with your values, remove the `log-only` line. Once in operation,
    be sure to monitor for any situations that trigger this setting—this can be easily
    done in your logging or **Security Information and Event Management** (**SIEM**)
    solution with simple keyword matching. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`/etc/bind/named.conf.options`. In addition, remove the forwarders line completely.
    The code is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`allow-query` line to reflect that, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have DNS servers for both our internal users and our internet clients,
    which tools might we use to troubleshoot this service?
  prefs: []
  type: TYPE_NORMAL
- en: DNS troubleshooting and reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main tool in Linux to troubleshoot DNS services is `dig`, which comes pre-installed
    in almost all Linux distributions. If you don''t have `dig` in your distribution,
    you can install it with `apt-get install dnsutils`. The use of this tool is pretty
    simple, as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to find name server records for a company (we''ll check `sans.org`), we''ll
    make an `ns` query against `sans.org`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This has a lot of commented information—knowing which DNS flags are set, as
    well as the exact operation of the DNS question and answer, can be very valuable,
    and that information is all in this default output. However, it''s also common
    to want a "just the facts" output—to get this, we''ll add a second parameter,
    `+short`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dig` command allows us to make any DNS queries we like. You can only query
    one target with one DNS query at a time, though, so to get **NS** information
    (relating to the **name server**) and **mail exchanger** (**MX**) information,
    you would need two queries. The MX query is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Which other tools can we use to troubleshoot, and which other DNS implementations
    might be involved?
  prefs: []
  type: TYPE_NORMAL
- en: DoH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DoH** is a newer DNS protocol; as the name implies, it is carried over HTTPS,
    and in fact, the DNS queries and responses are similar in form to an **application
    programming interface** (**API**). This new protocol was supported first in many
    browsers rather than natively in mainstream operating systems. It is, however,
    now available on most mainstream operating systems, just not enabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify a DoH server remotely, the `curl` (a pun on "*see url*")
    tool can do the job nicely. In the following example, we''re querying against
    Cloudflare''s name server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the query is simply an `https` request formed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP header in the request is `accept: application/dns-json`. Notice that
    this query is using standard HTTPS, so it''s listening on port `tcp/443`, not
    on the regular `udp/53` and `tcp/53` DNS ports.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the command output much more readable by piping it through `jq`.
    This simple query shows the flags—the DNS question, answer, and authority stanzas—in
    the output. Note in the following code snippet that the `RD` flag (which stands
    for `RA` flag (which stands for **Recursion Available**) is set by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Network Mapper** (**Nmap**) can also be used to verify the certificate on
    a remote DoH server, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Nmap does not currently come with a script that will verify DoH itself
    by making an actual DoH query. To fill that gap, you can download such a script
    here: https://github.com/robvandenbrink/dns-doh.nse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script verifies that the port is servicing HTTP requests using the Lua
    `http.shortport` operator, then constructs the query string, and then makes the
    HTTPS request using the correct header. A full write-up of this tool is available
    here: https://isc.sans.edu/forums/diary/Fun+with+NMAP+NSE+Scripts+and+DOH+DNS+over+HTTPS/27026/.'
  prefs: []
  type: TYPE_NORMAL
- en: With DoH thoroughly explored, which other protocols do we have available to
    validate and encrypt our DNS requests and responses?
  prefs: []
  type: TYPE_NORMAL
- en: DoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tcp/853`, which means it won''t conflict with DNS (`udp/53` and `tcp/53`)
    or DoH (`tcp/443`)—all three services can be run on the same host if the DNS server
    application supports all three.'
  prefs: []
  type: TYPE_NORMAL
- en: DoT name resolution is supported on most modern operating systems (as a client).
    It's not always running by default, but it's available to enable if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verifying a DoT server remotely is as simple as using Nmap to verify that `tcp/853`
    is listening, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The open port `tcp/853` is flagged as `domain-s` (DNS over `-sV`) shown in
    the preceding code snippet does show the `DNSStatusRequestTCP` string in the response,
    which is a nice clue that this port is in fact running DoT. Since it''s DoT, we
    can also use Nmap to again verify the certificate that''s validating the DoT service,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's about as far as we can go with the tools we've discussed up to now. The
    `dig` tool (at this time) does not support making DoT queries. However, the `knot-dnsutils`
    package gives us an "almost `dig`" command-line tool—`kdig`. Let's use this tool
    to explore DoT a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: knot-dnsutils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`knot-dnsutils` is a Linux package that includes the `kdig` tool. `kdig` duplicates
    what the `dig` tool does but then also adds additional features, which include
    support for DoT queries. To start using this tool, we''ll first have to install
    the `knot-dnsutils` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the install is completed, the `kdig` utility is, as mentioned, very
    much like the `dig` command, with a few extra command-line parameters—let''s make
    a DoT query to illustrate this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Which new parameters did we use?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debug` parameter (`-d`) gives us all the preceding lines that include
    the `DEBUG` string. Given that most people would be using `kdig` because of its
    TLS support, those `DEBUG` lines give us some excellent information that we might
    often want while testing a new service. Without the `debug` parameter, our output
    would be much more "`dig`-like", as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+short` parameter shortens the output to a "just the facts" display, just
    as in `dig`. Without this, the output would include all sections (not just the
    "answer" section), as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The new parameters that we used are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `+tls-ca` parameter enforces TLS validation—in other words, it verifies
    the certificate. By default, the system **certificate authority** (**CA**) list
    is used for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `+tls-hostname` allows you to specify the hostname for TLS negotiation.
    By default, the DNS server name is used, but in our case the server name is `8.8.8.8`—and
    you need a valid hostname that appears in the **CN** or **subject alternative
    name** (**SAN**) list for TLS to negotiate correctly. So, this parameter allows
    you to specify that name independent of what is used in the server name field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `+tls-sni` adds the **Server Name Indication** (**SNI**) field in the
    request, which is required by many DoT servers. This may seem odd, as the SNI
    field is there to allow an HTTPS server to present multiple certificates (each
    for a different HTTPS site).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens if you don''t use any of these parameters, and you just use `kdig`
    the way you''d use `dig`? By default, `kdig` doesn''t force the verification of
    a certificate against the FQDN you specify, so it''ll typically just work, as
    illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, it's a good idea to use TLS the way it was intended, with verification—after
    all, the point is to add another layer of trust into your DNS results. If you
    don't verify the server, all you've done is encrypt the query and response. You
    can't verify without specifying the correct hostname either in the server name
    field or in the TLS hostname field (this value needs to match the certificate
    parameters). Forcing certificate validation is important since this ensures that
    the DNS server is the one you really want to query (that is, your traffic hasn't
    been intercepted) and that the response has not been tampered with in its journey
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how DoT works, how can we troubleshoot it or find out
    whether a DNS host has DoT implemented?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DoT in Nmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the DoH Nmap example, implementing DoT in Nmap allows you to do DoT
    discovery and queries at a much larger scale, rather than one at a time. Given
    the complexities of making HTTPS calls in Nmap, an easy way to accomplish this
    is to simply call `kdig` from within the Nmap script, using the `os.execute` function
    in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Another key difference is that instead of testing the target port for the `http`
    function (using the `shortport.http` test), we're using the `shortport.ssl` test
    to verify any open port found for SSL/TLS capabilities; since if it isn't servicing
    valid TLS requests, it can't very well be DoT, can it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dns.dot` tool is available for download here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/robvandenbrink/dns-dot
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view a full write-up here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://isc.sans.edu/diary/Fun+with+DNS+over+TLS+%28DoT%29/27150
  prefs: []
  type: TYPE_NORMAL
- en: Which other security mechanisms can we implement on the DNS protocol itself?
    Let's take a look at DNSSEC, the original mechanism to verify DNS responses.
  prefs: []
  type: TYPE_NORMAL
- en: DNSSEC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`udp/53` and `tcp/53`, as it does not encrypt anything—it just adds fields
    to validate standard DNS operations using signing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the public key for any DNS zone by using the `DNSKEY` parameter
    in `dig`. In the following code example, we''re adding the `short` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the `DS` parameter, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add the `-d` (debug) parameter and filter to see just the `DEBUG` data,
    we''ll see the following line in the output, which indicates that we''re using
    the same port and protocol as a regular DNS query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a DNSSEC query, just add `+dnssec` to the `dig` command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: DNSSEC is all about authenticating DNS requests between clients and servers,
    and between servers as requests are relayed. As we've seen, it's implemented by
    the owners of any particular zone, to allow requesters to verify that the DNS
    "answers" they are getting are correct. However, because of its complexity and
    reliance on certificates, it just hasn't seen the uptake that DoT and DoH have.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, DoT and DoH focus on personal privacy, encrypting the individual
    DNS requests that a person makes as they go about their business. While this encryption
    makes those DNS requests more difficult to capture as they are made, those requests
    are still recorded on the DNS servers themselves. Also, if an attacker is in a
    position to collect a person's DNS requests, they are also in a position to simply
    record which sites they visit (by IP address).
  prefs: []
  type: TYPE_NORMAL
- en: All that being said, we won't delve into the depths of DNSSEC, mostly because
    as an industry we've made that same decision and (for the most part) have chosen
    not to implement it. However, you definitely do see it from time to time, especially
    when working through a problem involving DNS, so it's important to know what it
    looks like and why it might be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our discussion on DNS drawing to a close, you should now have the tools
    available to build a basic internal DNS server and a standard DNS server facing
    the internet. You should also have the basic tools to start securing these services
    by editing the various configuration files for the Linux `bind` or named service.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you should have some familiarity with troubleshooting various DNS
    services, using tools such as `dig`, `kdig`, `curl`, and `nmap`.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll continue on with a discussion on DHCP, which—as we've
    seen in this chapter—is definitely separate, but still can be related to DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: How does DNSSEC differ from DoT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does DoH differ from "regular" DNS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which features would you implement on an internal DNS server over an external
    DNS server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more on the subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definitive DNS references**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basic DNS has literally dozens of RFCs that define the service as well as best
    practices for implementation. A good list of these RFCs can be found here: https://en.wikipedia.org/wiki/Domain_Name_System#RFC_documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you need more detail on DNS and are looking for a more readable
    guide through the protocol and implementation details than the RFCs (emphasis
    on "readable"), many consider Cricket Liu''s books to be an excellent next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '*DNS and BIND* by Cricket Liu and Paul Albitz:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.amazon.ca/DNS-BIND-Help-System-Administrators-ebook/dp/B0026OR2QS/ref=sr_1_1?dchild=1&keywords=dns+and+bind+cricket+liu&qid=1614217706&s=books&sr=1-1
  prefs: []
  type: TYPE_NORMAL
- en: '*DNS and BIND on IPv6* by Cricket Liu:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.amazon.ca/DNS-BIND-IPv6-Next-Generation-Internet-ebook/dp/B0054RCT4O/ref=sr_1_3?dchild=1&keywords=dns+and+bind+cricket+liu&qid=1614217706&s=books&sr=1-3
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS UPDATE (Auto-registration)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 2136*: *Dynamic Updates in the Domain Name System (DNS UPDATE)*:'
  prefs: []
  type: TYPE_NORMAL
- en: https://tools.ietf.org/html/rfc2136
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticated DNS registration in Active Directory (AD)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 3645*: *Generic Security Service Algorithm for Secret Key Transaction
    Authentication for DNS (GSS-TSIG)*:'
  prefs: []
  type: TYPE_NORMAL
- en: https://tools.ietf.org/html/rfc3645
  prefs: []
  type: TYPE_NORMAL
- en: '**DoH**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fun with NMAP NSE Scripts and DOH (DNS over HTTPS):* https://isc.sans.edu/forums/diary/Fun+with+NMAP+NSE+Scripts+and+DOH+DNS+over+HTTPS/27026/'
  prefs: []
  type: TYPE_NORMAL
- en: 'DoH Nmap script: https://github.com/robvandenbrink/dns-doh.nse'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 8484*: *DNS Queries over HTTPS (DoH):* https://tools.ietf.org/html/rfc8484'
  prefs: []
  type: TYPE_NORMAL
- en: '`dns-dot` Nmap script: https://isc.sans.edu/diary/Fun+with+DNS+over+TLS+%28DoT%29/27150'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 7858*: *Specification for DNS over Transport Layer Security (TLS):* https://tools.ietf.org/html/rfc7858'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNSSEC**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain Name System Security Extensions (DNSSEC):* https://www.internetsociety.org/issues/dnssec/'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4033*: *DNS Security Introduction and Requirements:* https://tools.ietf.org/html/rfc4033'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4034*: *Resource Records for the DNS Security Extensions:* https://tools.ietf.org/html/rfc4034'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4035*: *Protocol Modifications for the DNS Security Extensions:* https://tools.ietf.org/html/rfc4035'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4470*: *Minimally Covering NSEC Records and DNSSEC On-line Signing:* https://tools.ietf.org/html/rfc4470'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4641*: *DNSSEC Operational Practices:* https://tools.ietf.org/html/rfc4641'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 5155*: *DNS Security (DNSSEC) Hashed Authenticated Denial of Existence:*
    https://tools.ietf.org/html/rfc5155'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 6014*: *Cryptographic Algorithm Identifier Allocation for DNSSEC:* https://tools.ietf.org/html/rfc6014'
  prefs: []
  type: TYPE_NORMAL
- en: '*RFC 4398*: *Storing Certificates in the Domain Name System (DNS):* https://tools.ietf.org/html/rfc4398'
  prefs: []
  type: TYPE_NORMAL
