- en: Encrypting and SSH Hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may work for a super-secret government agency, or you may be just a regular
    Joe or Jane citizen. Either way, you will still have sensitive data that you need
    to protect from prying eyes. Business secrets, government secrets, personal secrets—it
    doesn't matter; it all needs protection. Locking down user's home directories
    with restrictive permissions settings, as we saw in [Chapter 2](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml), *Securing
    User Accounts*, is only part of the puzzle; we also need encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The two general types of data encryption that we'll look at in this chapter
    are meant to protect *data at rest* and *data in transit*. We'll begin with using
    file, partition, and directory encryption to protect data at rest. We'll then
    cover **Secure Shell** (**SSH**) to protect data in transit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU Privacy Guard** (**GPG**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting partitions with **Linux Unified Key Setup** (**LUKS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting directories with eCryptfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using VeraCrypt for the cross-platform sharing of encrypted containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that SSH protocol 1 is disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and managing keys for password-less logins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling root user login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling username/password logins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a chroot environment for SFTP users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Privacy Guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin with **GNU Privacy Guard** (**GPG**). This is a free open source
    implementation of Phil Zimmermann's *Pretty Good Privacy*, which he created back
    in 1991\. You can use either one of them to either encrypt or cryptographically
    sign files or messages. In this section, we'll focus strictly on GPG.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some advantages of using GPG:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses strong, hard-to-crack encryption algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the private/public key scheme, which eliminates the need to transfer
    a password to a message or file recipient in a secure manner. Instead, just send
    along your public key, which is useless to anyone other than the intended recipient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use GPG to just encrypt your own files for your own use, the same as
    you'd use any other encryption utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to encrypt email messages, allowing you to have true end-to-end
    encryption for sensitive emails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few GUI-type frontends available to make it somewhat easier to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, as you might know, there are also some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Using public keys instead of passwords is great when you work directly only
    with people who you implicitly trust. But, for anything beyond that, such as distributing
    a public key to the general population so that everyone can verify your signed
    messages, you're dependent upon a web-of-trust model that can be very hard to
    set up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the end-to-end encryption of email, the recipients of your email must also
    have GPG set up on their systems, and know how to use it. That might work in a
    corporate environment, but lots of luck getting your friends to set that up. (I've
    never once succeeded in getting someone else to set up email encryption.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use a standalone email client, such as Mozilla Thunderbird, you can install
    a plugin that will encrypt and decrypt messages automatically. But, every time
    a new Thunderbird update is released, the plugin breaks, and it always takes a
    while before a new working version gets released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with its numerous weaknesses, GPG is still one of the best ways to share
    encrypted files and emails. GPG comes preinstalled on both Ubuntu Server and CentOS.
    So, you can use either of your virtual machines for these demos.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your GPG keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting started with GPG requires you to first generate your GPG keys. You''ll
    do that with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that, since you're setting this up for yourself, you don't need sudo privileges.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this command is too long to show all at once, so I'll show relevant
    sections of it, and break down what it means.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that this command does is to create a populated `.gnupg` directory
    in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll then be asked to select which kinds of keys you want. We''ll just go
    with the default RSA and RSA. (RSA keys are stronger and harder to crack than
    the older DSA keys. Elgamal keys are good, but they may not be supported by older
    versions of GPG.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For decent encryption, you''ll want to go with a key of at least 2048 bits,
    because anything smaller is now considered vulnerable. Since 2048 just happens
    to be the default, we''ll go with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, select how long you want for the keys to remain valid before they automatically
    expire. For our purposes, we'll go with the default `key does not expire`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide your personal information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a passphrase for your private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This could take a while, even when you''re doing all of the recommended things
    to create entropy. Be patient; it will eventually finish. By running a `sudo yum
    upgrade` in another window, I created enough entropy so that the process didn''t
    take too long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the keys did get created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And, while you''re at it, take a look at the files that you created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These files are your public and private keyrings, your own `gpg.conf` file,
    a random seed file, and a trusted users database.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetrically encrypting your own files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find GPG useful for encrypting your own files, even when you never plan
    to share them with anyone else. For this, you'll use symmetric encryption, which
    involves using your own private key for encryption. Before you try this, you'll
    need to generate your keys, as I outlined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key encryption is, well, just that, symmetric. It's symmetric in the
    sense that the same key that you would use to encrypt a file is the same key that
    you would use to decrypt the file. That's great for if you're just encrypting
    files for your own use. But, if you need to share an encrypted file with someone
    else, you'll need to figure out a secure way to give that person the password.
    I mean, it's not like you'd want to just send the password in a plain-text email.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s encrypt a super-secret file that we just can''t allow to fall into the
    wrong hands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `-c` option indicates that I chose to use symmetric encryption
    with a passphrase for the file. The passphrase that you enter will be for the
    file, not for your private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'One slight flaw with this is that GPG makes an encrypted copy of the file,
    but it also leaves the original, unencrypted file intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get rid of that unencrypted file with `shred`. We''ll use the `-u` option
    to delete the file, and the `-z` option to overwrite the deleted file with zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn''t look like anything happened, because `shred` doesn''t give you
    any output. But, an `ls -l` will prove that the file is gone. Now, if I were to
    look at the encrypted file with `less secret_squirrel_stuff.txt.gpg`, I would
    be able to see its contents, after being asked to enter my private key passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as my private key remains loaded into my keyring, I''ll be able to
    view my encrypted file again without having to reenter the passphrase. Now, just
    to prove to you that the file really is encrypted, I''ll create a shared directory,
    and move the file there for others to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When I go into that directory to view the file with `less`, I can still see
    its contents, without having to reenter my passphrase. But now, let''s see what
    happens when Maggie tries to view the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And when she hits the *Y* key to see it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Poor Maggie really wants to see my file, but all she can see is encrypted gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: What I've just demonstrated is another advantage of GPG. After entering your
    private key passphrase once, you can view any of your encrypted files without
    having to manually decrypt them, and without having to reenter your passphrase.
    With other symmetric file encryption tools, such as Bcrypt, you wouldn't be able
    to view your files without manually decrypting them first.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, let''s now say that you no longer need to have this file encrypted, and
    you want to decrypt it in order to let other people see it. Just use `gpg` with
    the `-d` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `WARNING` message about the message not being integrity protected means
    that I had encrypted the file, but I never signed the file. Without a digital
    signature, someone could alter the file without me knowing about it, and I wouldn't
    be able to prove that I am the originator of the file. (Have no fear, we'll talk
    about signing files in just a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – combining gpg and tar for encrypted backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this lab, you''ll combine `tar` and `gpg` to create an encrypted backup
    on a simulated backup device. You can perform this lab on either one of your virtual
    machines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off by creating your GPG keys. You will do that with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create some dummy files in your home directory, so that you''ll have something
    to back up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a backup directory at the root level of the filesystem. (In real life,
    you would have the backup directory on a separate device, but for now, this works.)
    Change ownership of the directory to your own account, and set the permissions
    so that only you can access it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an encrypted backup file of your own home directory. Compression is
    optional, but we''ll go ahead and use `xz` for the best compression. (Note that
    you''ll need to use `sudo` for this, because the `.viminfo` directory in your
    home directory is owned by the root user.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that either your home directory got deleted, or that you accidentally
    deleted some important files from your own home directory. Extract and decrypt
    the original home directory within the `/backup` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that, by combining `tar` with `gpg`, the `-C` option of `tar` to automatically
    place your home directory back within the `/home` directory won't work. So, you'll
    either need to manually copy the extracted directory back to `/home`, or move
    the encrypted backup file to `/home` before you extract it. Also, be aware that
    when you extract an encrypted archive with `gpg`, the ownership of the files will
    change to that of whoever extracted the archive. So, this probably wouldn't be
    a good choice for backing up an entire `/home` directory with home directories
    for multiple users. Finally, since this creates one huge archive file, any type
    of corruption in the archive file could cause you to lose the entire backup.
  prefs: []
  type: TYPE_NORMAL
- en: End of Lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using private and public keys for asymmetric encryption and signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetric encryption is great if you're just using GPG locally for your own
    stuff, but what if you want to share an encrypted file with someone, while ensuring
    that they can decrypt it? With symmetric encryption, you'd need to find a secure
    way to transmit the passphrase for the file to the file's recipient. In doing
    so, there will always be the risk that some third party could intercept the passphrase,
    and could then get into your stuff. Here's where asymmetric encryption comes to
    the rescue. To demonstrate, I'm going to create a file, encrypt it, and send it
    to my buddy Frank to decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption, is, well, asymmetric. Being asymmetric means that you
    would use one key to encrypt a file, and another key to decrypt it. You would
    keep your private key to yourself and guard it with your life, but you would share
    the public key with the whole world. The beauty of this is that you can share
    encrypted files with another person, and only that person would be able to decrypt
    them. This is all done without having to share a password with the recipient.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, both Frank and I have to create a key set, as we''ve already shown
    you. Next, each of us needs to extract our public keys, and send them to each
    other. We''ll extract the key into an ASCII text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the participants in this would either send their keys to each other
    through an email attachment, or by placing the keys in a shared directory. In
    this case, Frank and I will receive each other''s public key files, and place
    them into our respective `.gnupg` directories. Once that''s done, we''re ready
    to import each other''s keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the good stuff. I''ve created a super-secret message for Frank, and
    will asymmetrically encrypt it (`-e`) and sign it (`-s`). (Signing the message
    is the verification that the message really is from me, rather than from an impostor.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the first thing I had to do was to enter the passphrase for my private
    key. Where it says to enter the user ID, I entered `frank`, since he''s the intended
    recipient of my message. But, look at the line after that, where it says, `There
    is no assurance this key belongs to the named user`. That''s because I still haven''t
    *trusted* Frank''s public key. We''ll get to that in a bit. The last line of the
    output again says to enter a user ID, so that we can designate multiple recipients.
    But, Frank is the only one I care about right now, so I just hit the *Enter* key
    to break out of the routine. This results in a `.gpg` version of my message to
    Frank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: My final step is to send Frank his encrypted message file, by whatever means
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Frank receives his message, he''ll use the `-d` option to view it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Frank enters the passphrase for his private key, and he sees the message. At
    the bottom, he sees the warning about how my public key isn''t trusted, and that
    there''s `no indication that the signature belongs to the owner`. Well, since
    Frank knows me personally, and he knows for a fact that the public key really
    is mine, he can add my public key to the *trusted* list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of this output is the command prompt for the `gpg` shell. Frank
    is concerned with trust, so he''ll enter the command, `trust`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Frank has known me for quite a while, and he knows for a fact that I''m the
    one who sent the key. So, he chooses option `5` for ultimate trust. Once Frank
    logs out and logs back in, that trust will take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With no more warning messages, this looks much better. At my end, I'll do the
    same thing with Frank's public key.
  prefs: []
  type: TYPE_NORMAL
- en: What's so very cool about this is that even though the whole world may have
    my public key, it's useless to anyone who isn't a designated recipient of my message.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an Ubuntu machine, to get rid of the `gpg-agent is not available in this
    session` messages, and to be able to cache your passphrase in the keyring, install
    the `gnupg-agent` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt install gnupg-agent`'
  prefs: []
  type: TYPE_NORMAL
- en: Signing a file without encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a file isn''t secret, but you still need to ensure authenticity and integrity,
    you can just sign it without encrypting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as before, I create a `.gpg` version of the file. When Frank receives
    the file, he may try to open it with `less`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of gibberish there because of the signature, but if you look
    carefully, you''ll see the plain, unencrypted message. Frank will use `gpg` with
    the `--verify` option to verify that the signature really does belong to me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting partitions with Linux Unified Key Setup – LUKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to encrypt individual files can be handy, but it can be quite unwieldy
    for a large number of files. For that, we need something better, and we have three
    different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block encryption**: We can use this for either whole-disk encryption, or
    to encrypt individual partitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File-level encryption**: We''d use this to encrypt individual directories,
    without having to encrypt the underlying partitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerized Encryption**: Using third-party software that doesn''t come
    with any Linux distribution, we can create encrypted, cross-platform containers
    that can be opened on either Linux, Mac, or Windows machines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Linux Unified Key Setup** (**LUKS**), falls into the first category. It's
    built into pretty much every Linux distribution, and directions for use are the
    same for each. For our demos, I'll use the CentOS virtual machine, since LUKS
    is now the default encryption mechanism for Red Hat Enterprise Linux 7 and CentOS
    7.
  prefs: []
  type: TYPE_NORMAL
- en: Disk encryption during operating system installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you install Red Hat Enterprise Linux 7 or one of its offspring, you have
    the option of encrypting the drive. All you have to do is to click on a checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/659a6c43-4b71-4b86-8e67-8ed28938964f.png)'
  prefs: []
  type: TYPE_IMG
- en: Other than that, I just let the installer create the default partitioning scheme,
    which means that the `/` filesystem and the `swap` partition will both be logical
    volumes. (I'll cover that in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the installation can continue, I have to create a passphrase to mount
    the encrypted disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a5ec4f6-0c1c-4b20-8444-cb4bf81a89ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, whenever I reboot the system, I need to enter this passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e665ba5e-5389-46f8-a2b0-a86b05a5247a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the machine is up and running, I can look at the list of logical volumes.
    I see both the `/` logical volume and the `swap` logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And I can look at the list of physical volumes. (Actually, there''s only one
    physical volume in the list, and it''s listed as a `luks` physical volume.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the underlying physical volume is encrypted, which means that
    both the `/` and the `swap` logical volumes are also encrypted. That's a good
    thing, because leaving the swap space unencrypted—a common mistake when setting
    up disk encryption up manually—can lead to data leakage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an encrypted partition with LUKS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you'll need to either add another encrypted drive to
    an existing machine, or encrypt a portable device, such as a USB memory stick.
    This procedure works for both scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, I''ll shut down my CentOS VM and add another virtual drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1edaaaf-409c-4b9d-a10e-f4c9fd0deb8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll bump the drive capacity up to 20 GB, which will give me plenty of room
    to play with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f25a5458-d9cf-4b39-a4de-3161eca6fdca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After rebooting the machine, I now have a `/dev/sdb` drive to play with. My
    next step is to create a partition. It doesn''t matter whether I create a new-fangled
    GPT partition, or an old-fashioned MBR partition. I''ll create a GPT partition,
    and my preferred utility for doing that is `gdisk`, simply because it''s so similar
    to the old `fdisk` that I know and love so well. The only catch is that `gdisk`
    isn''t installed on CentOS by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll use the entire drive for my partition, and leave the partition type set
    at the default `8300`. I now have the `/dev/sdb1` partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll next use `cryptsetup` to convert the partition to LUKS format. In this
    command, the `-v` signifies verbose mode, and the `-y` signifies that I''ll have
    to enter my passphrase twice in order to properly verify it. Note that when it
    says to type `yes` all in uppercase, it really does mean to type it in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Although I don''t have to, I''d like to look at the information about my new
    encrypted partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot more to the output than what I can show here, but you get the
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I''ll map the partition to a device name. You can name the device pretty
    much whatever you want, and I''ll just name mine `secrets`. (I know, it''s a corny
    name. You probably won''t want to make it so obvious where you''re storing your
    secrets.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When I look in the `/dev/mapper` directory, I see my new `secrets` device,
    listed as a symbolic link to the `dm-3` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll use `dmsetup` to look at the information about my new device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to format the partition in the usual manner. I could use any
    filesystem that''s supported by Red Hat and CentOS. But, since everything else
    on my system is already formatted with XFS, that''s what I''ll go with here, as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'My final step is to create a mount point and to mount the encrypted partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mount` command will verify that the partition is mounted properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the LUKS partition to mount automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only missing piece of the puzzle is to configure the system to automatically
    mount the LUKS partition upon boot-up. To do that, I''ll configure two different
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/crypttab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/fstab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Had I not chosen to encrypt the disk when I installed the operating system,
    I wouldn''t have a `crypttab` file, and I would have to create it myself. But,
    since I did choose to encrypt the drive, I already have one with information about
    that drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields describe the name and location of the encrypted partition.
    The third field is for the encryption passphrase. If it's set to `none`, as it
    is here, then the passphrase will have to be manually entered upon boot-up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `fstab` file, we have the entry that actually mounts the partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Well, there are actually two entries in this case, because I have two logical
    volumes, `/` and `swap`, on top of my encrypted physical volume. The `UUID` line
    is the `/boot` partition, which is the only part of the drive that isn't encrypted.
    Now, let's add our new encrypted partition so that it will mount automatically,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is where it would be extremely helpful to remotely log into your virtual
    machine from your desktop host machine. By using a GUI-type Terminal, whether
    it be the Terminal from a Linux or MacOS machine, or Cygwin from a Windows machine,
    you'll have the ability to perform copy-and-paste operations, which you won't
    have if you work directly from the virtual machine terminal. (Trust me, you don't
    want to be typing in those long UUIDs.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to obtain the UUID of the encrypted partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll copy that UUID, and paste it into the `/etc/crypttab` file. (Note that
    you''ll paste it in twice. The first time, you''ll prepend it with `luks-`, and
    the second time you''ll append it with `UUID=`.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I''ll edit the `/etc/fstab` file, adding the last line in the file
    for my new encrypted partition. (Note that I again used `luks-`, followed by the
    UUID number.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When editing the `fstab` file for adding normal, unencrypted partitions, I always
    like to do a `sudo mount -a` to check the `fstab` file for typos. That won't work
    with LUKS partitions though, because `mount` won't recognize the partition until
    the system reads in the `crypttab` file, and that won't happen until I reboot
    the machine. So, just be extra careful with editing `fstab` when adding LUKS partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the moment of truth. I'll reboot the machine to see if everything works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, the machine has rebooted, and `mount` shows that my endeavors have been
    successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting directories with eCryptfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting entire partitions is cool, but you might, at times, just need to
    encrypt an individual directory. For that, we can use eCryptfs. We'll need to
    use our Ubuntu machines for this, because Red Hat and CentOS no longer include
    eCryptfs in version 7 of their products. (It was in Red Hat 6 and CentOS 6, but
    it's no longer even available for installation in version 7.)
  prefs: []
  type: TYPE_NORMAL
- en: Home directory and disk encryption during Ubuntu installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you install Ubuntu Server, you have two chances to implement encryption.
    You''ll first be given the chance to encrypt your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f24ca5a-c6e0-40a6-a644-e8864326a800.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Later, on the Partition disks screen, you''ll be given the chance to set up
    encrypted logical volumes for whole disk encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7994a943-59c1-4a50-9365-0656f8b0419f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After choosing this option, you will then be asked to enter a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba033a01-d844-426b-9e9b-d317d48b0fab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The disk encryption uses LUKS, just the same as we saw on the CentOS machine.
    To prove this, all we have to do is look for a populated `crypttab` file in the
    `/etc` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Red Hat and CentOS, an Ubuntu machine will always have the `/etc/crypttab`
    file, even if there are no LUKS partitions. Without LUKS partitions, the file
    will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The home directory encryption uses eCryptfs, as evidenced by the `.ecryptfs`
    directory in the `/home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, what we have here is encryption on top of encryption, for double protection.
    Is that really necessary? Probably not, but choosing to encrypt my home directory
    ensured that the access permissions for it got set to the more restrictive `700`
    setting, rather than the default `755` setting. Be aware though, that any user
    accounts you create now will have wide open permissions settings on their home
    directories. Unless, that is, we create user accounts with the encryption option.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a home directory for a new user account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml), *Securing User
    Accounts*, I showed you how Ubuntu allows you to encrypt a user''s home directory
    as you create his or her user account. To review, let''s see the command for creating
    Goldie''s account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When Goldie logs in, the first thing she''ll want to do is to `unwrap` her
    mount passphrase, write it down, and store it in a secure place. (She''ll need
    this if she ever needs to recover a corrupted directory.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When you use `adduser --encrypt-home`, home directories for new users will automatically
    be set to a restrictive permissions value that will keep everyone out except for
    the owner of the directory. This happens even when you leave the `adduser.conf`
    file set with its default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private directory within an existing home directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you have users who, for whatever strange reason, don't want to
    encrypt their entire home directories, and want to keep the `755` permissions
    settings on their home directories so that other people can access their files.
    But, they also want a private directory that nobody but them can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of encrypting an entire home directory, any user can create an encrypted
    private directory within his or her own home directory. The first step, if it
    hasn''t already been done, is for someone with admin privileges to install the
    `ecryptfs-utils` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To create this private directory, we''ll use the interactive `ecryptfs-setup-private`
    utility. If you have admin privileges, you can do this for other users. Users
    without admin privileges can do it for themselves. For our demo, let''s say that
    Charlie, my big Siamese/Gray tabby guy, needs his own encrypted private space.
    (Who knew that cats had secrets, right?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `login` passphrase, Charlie enters his normal password or passphrase
    for logging into his user account. He could have let the system generate its own
    `mount` passphrase, but he decided to enter his own. Since he did enter his own
    mount passphrase, he didn''t need to do the `ecryptfs-unwrap-passphrase` command
    to find out what the passphrase is. But, just to show how that command works,
    let''s say that Charlie entered `TurkeyLips` as his mount passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it's a horribly weak passphrase, but for our demo purposes, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Charlie logs out and logs back in, he can start using his new private
    directory. Also, you can see that he has three new hidden directories within his
    home directory. All three of these new directories are only accessible by Charlie,
    even though his top-level home directory is still wide open to everybody:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do a `grep ''ecryptfs'' *` command in the `/etc/pam.d` directory, you''ll
    see that PAM is configured to automatically mount users'' encrypted directories
    whenever they log into the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting other directories with eCryptfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting other directories is a simple matter of mounting them with the `ecryptfs`
    filesystem. For our example, let's create a `secrets` directory in the top level
    of our filesystem, and encrypt it. Note how you list the directory name twice,
    because you also need to specify a mount point. (Essentially, you're using the
    directory that you're mounting as its own mount point.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The output from this command is a bit lengthy, so let's break it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you''ll enter your desired passphrase, and choose the encryption algorithm
    and the key length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We'll go with the default of `aes`, and 16 bytes for the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to go with the default of no for `plaintext passthrough`, and with
    yes for filename encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll go with the default `Filename Encryption Key`, and verify the mounting
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning only comes up when you mount the directory for the first time.
    For the final two questions, I''ll type `yes` in order to prevent that warning
    from coming up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for fun, I''ll create a file within my new encrypted `secrets` directory,
    and then unmount the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: By choosing to encrypt filenames, nobody can even tell what files you have when
    the directory is unmounted. When I'm ready to access my encrypted files again,
    I'll just remount the directory the same as I did before.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting the swap partition with eCryptfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re just encrypting individual directories with eCryptfs instead of
    using LUKS whole-disk encryption, you''ll need to encrypt your swap partition
    in order to prevent accidental data leakage. Fixing that problem requires just
    one simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Don't mind the warning about the missing `/dev/mapper/cryptswap1` file. It will
    get created the next time you reboot the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using VeraCrypt for cross-platform sharing of encrypted containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once upon a time, there was TrueCrypt, a cross-platform program that allowed
    the sharing of encrypted containers across different operating systems. But the
    project was always shrouded in mystery, because its developers would never reveal
    their identities. And then, right out of the blue, the developers released a cryptic
    message about how TrueCrypt was no longer secure, and shut down the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'VeraCrypt is the successor to TrueCrypt, and it allows the sharing of encrypted
    containers across Linux, Windows, MacOS, and FreeBSD machines. Although LUKS and
    eCryptfs are good, VeraCrypt does offer more flexibility in certain ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, VeraCrypt offers cross-platform sharing, whereas LUKS and eCryptfs
    don't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VeraCrypt allows you to encrypt either whole partitions or whole storage devices,
    or to create virtual encrypted disks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only can you create encrypted volumes with VeraCrypt, you can also hide
    them, giving you plausible deniability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VeraCrypt comes in both command-line and GUI variants, so it's appropriate for
    either server use or for the casual desktop user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like LUKS and eCryptfs, VeraCrypt is free open source software, which means
    that it's free to use, and that the source code can be audited for either bugs
    or backdoors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and installing VeraCrypt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux version of VeraCrypt comes as a set of universal installer scripts
    that should work on any Linux distribution. Once you extract the `.tar.bz2` archive
    file, you''ll see two scripts for GUI installation, and two for console-mode installation.
    One of each of those is for 32-bit Linux, and one of each is for 64-bit Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For the server demo, I used `scp` to transfer the 64-bit console-mode installer
    to one of my Ubuntu virtual machines. The executable permission is already set,
    so all you have to do to install is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You'll need sudo privileges, but the installer will prompt you for your sudo
    password. After reading and agreeing to a rather lengthy license agreement, the
    installation only takes a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting a VeraCrypt volume in console mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I haven't been able to find any documentation for the console-mode variant of
    VeraCrypt, but you can see a list of the available commands just by typing `veracrypt`.
    For this demo, I'm creating a 2 GB encrypted volume in my own home directory.
    But you can just as easily do it elsewhere, such as on a USB memory stick.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new encrypted volume, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take you into an easy-to-use, interactive utility. For the most part,
    you''ll be fine just accepting the default options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For the filesystem, the default option of FAT will give you the best cross-platform
    compatibility between Linux, MacOS, and Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll then select your password and a PIM, which stands for Personal Iterations
    Multiplier. (For the PIM, I entered `8891`. High PIM values give better security,
    but they will also cause the volume to take longer to mount.) Then, type at least
    320 random characters in order to generate the encryption key. (This is where
    it would be handy to have my cats walking across my keyboard.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'After you hit *Enter*, be patient, because the final generation of your encrypted
    volume will take a few moments. Here, you see that my 2 GB `good_stuff` container
    has been successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this container, I have to mount it. I''ll begin by creating a mount
    point directory; the same as I would for mounting normal partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `veracrypt` utility to mount your container on this mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what VeraCrypt volumes you have mounted, use `veracrypt -l`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: And, that's all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using VeraCrypt in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Desktop users of any of the supported operating systems can install the GUI
    variant of VeraCrypt. Be aware though, that you can''t install both the console-mode
    variant and the GUI variant on the same machine, because one will overwrite the
    other. Here, you see the GUI version running on my CentOS 7 virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a487ef8-1b8d-42f2-a74f-15208816fabc.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the main focus of this book is sever security, I won't go into the details
    of the GUI version here. But, it's fairly self-explanatory, and you can view the
    full VeraCrypt documentation on their website.
  prefs: []
  type: TYPE_NORMAL
- en: You can get VeraCrypt from here: [https://www.veracrypt.fr/en/Home.html](https://www.veracrypt.fr/en/Home.html)
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we'll turn our attention to the subject of protecting
    data in transit, by locking down Secure Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that SSH protocol 1 is disabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this stage in your Linux career, you should already know how to use Secure
    Shell, or SSH, to do remote logins and remote file transfers. What you may not
    know is that a default configuration of SSH is actually quite insecure.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH protocol version 1, the original SSH protocol, is severely flawed, and
    should never be used. It''s still in most Linux distributions, but fortunately,
    it''s always disabled by default. But, if you ever open your `/etc/ssh/sshd_config`
    file and see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Then you have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Ubuntu main page for the `sshd_config` file says that protocol version 1
    is still available for use with `legacy devices`. But, if you're still running
    devices that are that old, you need to start seriously thinking about doing some
    upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: As Linux distributions get updated, you'll see SSH protocol 1 gradually being
    completely removed, as has happened with Red Hat and CentOS 7.4.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing keys for password-less logins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Secure Shell Suite, or SSH, is a great set of tools that provides secure,
    encrypted communications with remote servers. You can use the SSH component to
    remotely log into the command-line of a remote machine, and you can use either
    `scp` or `sftp` to securely transfer files. The default way to use any of these
    SSH components is to use the username and password of a person''s normal Linux
    user account. So, logging into a remote machine from the terminal of my OpenSUSE
    workstation would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: While it's true that the username and password go across the network in an encrypted
    format, making it hard for malicious actors to intercept, it's still not the most
    secure way of doing business. The problem is that attackers have access to automated
    tools that can perform brute-force password attacks against an SSH server. Botnets,
    such as the Hail Mary Cloud, perform continuous scans across the internet to find
    internet-facing servers with SSH enabled. If a botnet finds that the servers allow
    SSH access via username and password, it will then launch a brute-force password
    attack. Sadly, such attacks have been successful quite a few times, especially
    when the server operators allow the root user to log in via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: This older article gives more details about the Hail Mary Cloud botnet: [http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/](http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we''ll look at two ways to help prevent these types of
    attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable SSH logins through an exchange of public keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable the root user login through SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user's SSH key set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each user has the ability to create his or her own set of private and public
    keys. It doesn't matter whether the user's client machine is running Linux, MacOS,
    or Cygwin on Windows. In all three cases, the procedure is exactly the same. To
    demo, I'll create keys on my OpenSUSE workstation and transfer the public key
    to one of my virtual machines. It doesn't matter which virtual machine I use,
    but since I haven't shown much love to the CentOS machine lately, I'll use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll begin by creating the keys on my OpenSUSE workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: There are several different types of keys that you can create, but the default
    2048-bit RSA keys are considered as plenty strong enough for the foreseeable future.
    The private and public SSH keys work the same as we saw with GPG. You'll keep
    your private keys to yourself, but you can share the public key with the world,
    if you so desire. In this case though, I'm only going to share my public key with
    just one server.
  prefs: []
  type: TYPE_NORMAL
- en: When prompted for the location and name of the keys, I'll just hit *Enter* to
    accept the defaults. You could just leave the private key with a blank passphrase,
    but that's not a recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you choose an alternative name for your key files, you''ll need
    to type in the entire path to make things work properly. For example, in my case,
    I would specify the path for `donnie_rsa` keys as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/donnie/.ssh/donnie_rsa`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.ssh` directory in my home directory, I can see the keys that I created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `id_rsa` key is the private key, with read and write permissions only for
    me. The `id_rsa.pub` public key has to be world-readable.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring the public key to the remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transferring my public key to a remote server allows the server to readily
    identify both me and my client machine. Before I can transfer the public key to
    the remote server, I need to add the private key to my session keyring. This requires
    two commands. (One command is to invoke the `ssh-agent`, and the other command
    actually adds the private key to the keyring.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I can transfer my public key to my CentOS server, which is at address
    `192.168.0.101`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time that I log in, I''ll use the key exchange, and I won''t have
    to enter a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now you''re wondering, "*How is that secure if I can log in without entering
    my password?*" The answer is that once you close the client machine''s terminal
    window that you used for logging in, the private key will be removed from your
    session keyring. When you open a new terminal and try to log in to the remote
    server, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time I log into this server, I'll need to enter the passphrase for
    my private key. (That is, unless I add it back to the session keyring with the
    two commands that I showed you in the preceding section.)
  prefs: []
  type: TYPE_NORMAL
- en: Disabling root user login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few years ago, there was a somewhat celebrated case where malicious actors
    had managed to plant malware on quite a few Linux servers somewhere in southeast
    Asia. There were three reasons that the bad guys found this so easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: The internet-facing servers involved were set up to use username/password authentication
    for SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root user was allowed to log in through SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User passwords, including the root user's password, were incredibly weak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this meant that it was easy for Hail Mary to brute-force its way in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different distributions have different default settings for root user login.
    In the `/etc/ssh/sshd_config` file of your CentOS machine, you''ll see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike what you have in most configuration files, the commented-out lines in
    `sshd_config` define the default settings for the Secure Shell daemon. So, this
    line indicates that the root user is indeed allowed to log in through SSH. To
    change that, I''ll remove the comment symbol and change the setting to `no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the new setting take effect, I''ll restart the SSH daemon, which is
    named `sshd` on CentOS, and is named `ssh` on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Ubuntu machine, the default setting looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This means that the root user is allowed to log in, but only via a public key
    exchange. That's probably secure enough, if you really need to allow the root
    user to log in. But in most cases, you'll want to force admin users to log in
    with their normal user accounts, and to use `sudo` for their admin needs. So,
    in most cases, you can still change this setting to `no`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that if you deploy an instance of Ubuntu Server on a cloud service,
    such as Azure, Rackspace, or Vultr, the service owners will have you log into
    the virtual machine with the root user account. The first thing you'll want to
    do is to create your own normal user account, log back in with that account, disable
    the root user account, and disable the root user login in `sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling username/password logins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is something that you'll only want to do after you've set up the key exchange
    with your clients. Otherwise, clients will be locked out of doing remote logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both Ubuntu and CentOS machines, look for this line in the `sshd_config`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the comment symbol, change the parameter value to `no`, and restart
    the SSH daemon. The line should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the botnets scan your system, they'll see that doing a brute-force
    password attack would be useless. They'll then just go away and leave you alone.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a chroot environment for SFTP users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure File Transfer Protocol** (**SFTP**) is a great tool for performing
    secure file transfers. There is a command-line client, but users will most likely
    use a graphical client, such as Filezilla. A common use-case for SFTP is to allow
    website owners to upload web content files to the proper content directories on
    a web server. With a default SSH setup, anyone who has a user account on a Linux
    machine can log in through either SSH or SFTP, and can navigate through the server''s
    entire filesystem. What we really want for SFTP users is to prevent them from
    logging into a command-prompt via SSH, and to confine them to their own designated
    directories.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a group and configuring the sshd_config file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the exception of the slight difference in user-creation commands, this
    procedure works the same for either CentOS or Ubuntu. So, you can use either one
    of your virtual machines to follow along. We'll begin by creating an `sftpusers`
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the user accounts, and add them to the `sftpusers` group. We''ll do
    both operations in one step. On your CentOS machine, the command for creating
    Max''s account would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'On your Ubuntu machine, it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/ssh/sshd_config` file in your favorite text editor. Find the
    line that says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This setting allows you to disable normal SSH login for certain users.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the `sshd_config` file, add a `Match Group` stanza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: An important consideration here is that the `ChrootDirectory` has to be owned
    by the root user, and it can't be writable by anyone other than the root user.
    When Max logs in, he'll be in the `/home` directory, and will then have to `cd`
    into his own directory. This also means that you want for all users' home directories
    to have the restrictive `700` permissions settings, in order to keep everyone
    out of everyone else's stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and restart the SSH daemon. Then, try to log on as Max through
    normal SSH, just to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so he can''t do that. Let''s now have him try to log in through SFTP,
    and verify that he is in the `/home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see him try to `cd` out of the `/home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: So, our chroot jail does indeed work.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – setting up a chroot directory for sftpusers group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this lab, you can use either the CentOS virtual machine or the Ubuntu virtual
    machine. You''ll add a group, then configure the `sshd_config` file to allow group
    members to only be able to log in via SFTP, and to confine them to their own directories.
    For the simulated client machine, you can use the terminal of your MacOS or Linux
    desktop machine, or Cygwin from your Windows machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `sftpusers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a user account for Max, and add him to the `sftpusers` group. On CentOS,
    do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, ensure that the users'' home directories are all set with read,
    write, and execute permissions for only the directory''s user. If that''s not
    the case, do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/ssh/sshd_config` file in your preferred text editor. Find the
    line that says:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `sshd_config` file, add the following stanza:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the SSH daemon. On CentOS, do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Have Max try to log in through normal SSH, to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, have Max log in through SFTP. Once he''s in, have him try to `cd` out
    of the `/home` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: End of Lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've seen how to work with various encryption technologies
    that can help us safeguard our secrets. We started with GNU Privacy Guard for
    encrypting individual files. We then moved on to the disk, partition, and directory
    encryption utilities. LUKS and eCryptfs are specific to Linux, but we also looked
    at VeraCrypt, which can be used on any of the major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take an in-depth look at the subject of discretionary
    access control. I'll see you there.
  prefs: []
  type: TYPE_NORMAL
