- en: Going Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have explored so far, Microservices offer a great alternative architecture
    with which we can approach the application development scenario. With the advantages
    of having faster release cycles, easy-to-launch new features and high scalability,
    the Microservices are a compelling choice for developers. But all of these Microservices
    still run in a server-based environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Running in a server-based environment is useful in terms of the response times
    of the applications because there is always a service that is ready to accept
    an incoming request. But there is one disadvantage: If there are no users, the
    applications keep on consuming system resources.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Recently, application developers have started to make a move toward a new approach
    of application development. This approach of development focuses on the applications
    being event-driven and launches an action based on the occurrence of some event.
    These kinds of applications are known as serverless applications because they
    do not keep on running when there is no user and an instance of them launches
    only when there has been some event that has occurred.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: As we move through this chapter, we will take a look at this serverless approach
    of application development and how it is changing the development scenario.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reader of this chapter, you will get to learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The serverless approach to application development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process that powers the serverless architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a serverless application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of the serverless approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter13` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)[.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, for the code to execute successfully, some additional software
    will be required:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker**: Docker is required as a dependency to run the OpenWhisk software
    platform for the deployment of the serverless applications. To install `docker`
    on your platform, please take a look at [https://docs.docker.com/install/](https://docs.docker.com/install/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache OpenWhisk**: Apache OpenWhisk provides an open source platform for
    ...'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serverless approach to application development
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, as developers, we have grown accustomed to the traditional
    ways of building applications and handling their deployments on the production
    infrastructure. In this traditional architecture, we developed applications where
    the application takes in a request from the **Client**, checks whether the **Client**
    is authorized to perform that action, and then moves on to executing that action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application was developed, we deployed it over a platform that would
    be compatible with our application. This involves the choice of the operating
    system, the kind of the infrastructure where this platform will be running, for
    example a bare-metal server, a VM, or a container, and then we maintained the
    infrastructure by handling its scalability and fixing any issues that may arise.
    For example, a simple system that manages employee payroll inside an organization
    will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b9a3bf94-69b6-4b8e-ae0d-61a80b4794e3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: In this case, the application keeps running on a server, waiting for the requests
    to come, and acting on them as they arrive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach, though highly useful, usually pulls the developers from
    their main task of writing the logic to achieve a particular outcome from the
    system, and makes them focus on a lot of areas that involve tasks related to the
    infrastructure management and scalability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine an architecture that would allow developers to focus on just writing
    the logic behind a particular business process without worrying about where that
    logic will be executed and how it will scale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The serverless approach to building applications provides these features. The
    way this works in serverless is through the introduction of two new techniques
    to application development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Backend as a service** (**BaaS**): BaaS is a new cloud computing offering
    that provides the application developers with the functionality of linking their
    applications with the backend services through the use of APIs, so as to provide
    some common feature sets, such as user authentication and data storage. It differs
    from the general architecture of application development in that these services
    provided by the backend may not need to be developed by the application developers
    themselves, but access to these services is enabled through the use of APIs exposed
    by these services.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function as a service** (**FaaS**): FaaS is another category of cloud computing
    that allows developers to focus on writing the application logic without worrying
    about where this logic will execute. In FaaS, the applications run in a stateless
    and ephemeral manner where the infrastructure they might be executing in may be
    valid only for a few invocations, which may be as little as a single invocation.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the serverless architecture of application development, the applications
    are usually developed as functions that are executed as a response to a certain
    event. These functions execute in their own stateless containers, which may exist
    in the infrastructure for only a few invocations. We will take a look at how the
    serverless applications work in the later sections of this chapter. For a quick
    reference, if we had to implement the Payroll system as a serverless application;
    the following diagram shows how the architecture of the system would look:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2ae4e988-e8d6-4deb-8780-16aebbe431cb.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: As we can see, our serverless payroll application contains both the features
    of a BaaS offering where the **Client** directly interacts with the **Auth DB**
    through the APIs exposed by the **Auth DB** and the **Payslip** generation, and
    employee search runs in a FaaS offering where they are stored as functions and
    executed only when a particular event happens.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Both of these functions do not maintain any kind of state, such that they can
    run in ephemeral containers that may only last for a short amount of time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: So now, let's take a look at the components that power the serverless architecture
    and how the serverless architecture works to have a better understanding of how
    we can develop applications that best utilize the serverless architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Components of serverless architecture
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, the serverless architecture provides us a way to develop applications
    where we are only responsible for writing the logic behind the applications, and
    relieves us of the worry of how the infrastructure will be managed for running
    the application and how the application will scale up and down based on the number
    of requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: But what powers this architecture? Let's try to spend some time taking a look
    at how the different components inside the architecture work to provide a serverless
    development approach toward application development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, the serverless approach to application development is
    made possible through the use of two technologies that have came into existence
    ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Backend as a service
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the applications that we develop share a common set of functionalities.
    These functionalities may include the implementation of a user authentication
    database, providing a way for storage and retrieval of files, or sending notifications
    either through the use of emails or push notifications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these functionalities are built into the application by introducing
    new components inside the application with which the other components can interact.
    The same is true for the Microservices-based applications, where these features
    are implemented, as different Microservices and the other Microservices interact
    with these services to achieve a certain outcome.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些功能是通过在应用程序中引入新组件来构建的，其他组件可以与这些组件进行交互。对于基于微服务的应用程序也是如此，这些功能被实现为不同的微服务，其他微服务与这些服务进行交互以实现特定的结果。
- en: In the BaaS approach, we decouple these functionalities from the application
    by integrating these functionalities through the use of third-party cloud providers.
    When this happens, our applications usually integrate these functionalities through
    the use of the APIs that are provided by the third-party providers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在BaaS方法中，我们通过使用第三方云提供商来解耦这些功能，通过使用第三方提供商提供的API，我们的应用程序通常集成这些功能。
- en: To understand this better, let's take a look at the serverless payroll-management
    system we introduced earlier. In this system, we have made the user authentication
    a disjointed part of our application by leveraging the BaaS offering provided
    by a third-party.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们来看一下我们之前介绍的无服务器工资管理系统。在这个系统中，我们通过利用第三方提供的BaaS服务，将用户认证作为我们应用程序的一个不相关的部分。
- en: In this approach, our user authentication system and any of the data associated
    with it is managed by a third-party provider. This provider exposes some of the
    APIs for the service, which we can use to integrate the service with our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们的用户认证系统及其相关的任何数据都由第三方提供商管理。该提供商公开了一些服务的API，我们可以使用这些API将服务与我们的应用程序集成。
- en: In our example, we exposed part of the user authentication service to the client
    through the use of the APIs exposed by the service. This allows the client to
    perform the user authentication directly with the service without going through
    the whole backend of the application. The second place where we used the BaaS
    offering was when we linked the employee search function with the user authentication
    service to retrieve a particular employee based on some criteria.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们通过使用服务提供的API来向客户端公开部分用户认证服务。这允许客户端直接与服务进行用户认证，而无需通过整个应用程序的后端。我们使用BaaS服务的第二个地方是当我们将员工搜索功能与用户认证服务链接起来，根据某些标准检索特定的员工。
- en: 'This concept of BaaS provides us with several advantages, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS的这一概念为我们提供了几个优势，例如：
- en: '**Reduced development time:** With BaaS, the developers of an application need
    not worry about the development for the common set of functionalities that they
    can consume directly from the third-party service providers by using the APIs
    provided by the service provider.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开发时间：**通过BaaS，应用程序的开发人员无需担心开发可以直接从第三方服务提供商那里获取的常见功能集，而是使用服务提供商提供的API。'
- en: '**Ease of operations:** Since the service and the infrastructure related to
    the service is managed by the cloud computing provider only, this reduced the
    complexity of managing the service and the operations it provides, allowing for
    reduced operational headaches.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作的便利性：**由于服务和与服务相关的基础设施仅由云计算提供商管理，这减少了管理服务和其提供的操作的复杂性，从而减少了操作上的麻烦。'
- en: '**Ease of scalability:** The services provided by the cloud computing provider
    are managed directly by them, allowing for easy scalability, which is now done
    by the provider only.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展性：**云计算提供商提供的服务直接由他们管理，可以轻松扩展，现在只由提供商完成。'
- en: '**Flexibility of integration:** The services provided by the provider are usually
    integrated through the use of APIs. If the necessary API for the service integration
    is available for a provided platform, the platform can easily integrate with the
    service without worrying about the complexities behind the integration and hence
    allowing for support in different kinds of applications.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成的灵活性：**提供商提供的服务通常通过API进行集成。如果提供的平台有所需的服务集成API，平台可以轻松地与服务集成，而不必担心集成背后的复杂性，从而支持不同类型的应用程序。'
- en: Function as a service
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数即服务
- en: FaaS is an interesting concept and one of the main technologies that powers
    the serverless architecture. Inside this approach, we develop the backend code
    without worrying about how that code will be deployed and where it will be executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS是一个有趣的概念，也是支持无服务器架构的主要技术之一。在这种方法中，我们开发后端代码，而不用担心代码将如何部署以及在哪里执行。
- en: The applications aimed for FaaS are just like any other application that does
    not require any kind of special framework for their development and execution.
    The only difference that comes between an FaaS application and a regular application
    that is deployed on the servers is the fact that FaaS applications have a severe
    limitation in terms of maintaining their state and the amount of time they can
    execute for. So, let's take a deeper dive into these two main aspects of having
    your ...
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 针对FaaS的应用程序就像任何其他不需要任何特殊框架进行开发和执行的应用程序一样。FaaS应用程序与部署在服务器上的常规应用程序之间唯一的区别在于，FaaS应用程序在维护其状态和执行的时间方面有严格的限制。因此，让我们深入探讨这两个主要方面...
- en: The restrictions on state management
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国家管理的限制
- en: In the FaaS model, the different parts of the application are built as separate
    functions where each function is executed on the occurrence of a certain event.
    When the application is supposed to be deployed, the cloud provider automatically
    manages the infrastructure where the application will run and how the application
    will scale up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在FaaS模型中，应用程序的不同部分被构建为单独的函数，每个函数在发生某个事件时被执行。当应用程序应该被部署时，云提供商会自动管理应用程序将在哪里运行以及应用程序如何扩展。
- en: In comparison to the traditional applications that, once deployed, start a server
    process and are ready to accept the incoming connections, the FaaS-based applications
    are started dynamically as a response to a certain input. Once the event occurs,
    the function starts and executes, waits for some time, and then the instance in
    which the function is executing is terminated. Now, this makes the process a bit
    interesting because the time for which the function is present in the infrastructure
    is limited and there is no guarantee that the same instance of the function will
    also handle the next call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This makes the state management, that is, the management of local data for a
    currently-executing operation, a challenging task inside FaaS-based offerings,
    which severely limits what local data we can store inside a function instance
    while it is executing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: For dealing with such a scenario, we depend upon an external offering that can
    store the state data for us. This may include the use of an external database
    or a caching server where the data can be persisted for future reference.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions on execution times
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a function starts executing inside an FaaS offering, it has only a limited
    amount of time in which it needs to complete its execution. Most of the famous
    cloud service providers have a limit set on their infrastructure for how long
    a function inside an FaaS offering can execute. For example, if we choose the
    most renowned FaaS offering by AWS, the AWS Lambda, the maximum duration for which
    a function can execute is limited to five minutes. This limit may vary marginally
    on the other providers but won't be too high.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Now this makes an interesting case for us as application developers. If one
    of the application components that we are trying to implement as a function may
    take a significantly long time to ...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Executing functions inside FaaS
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have developed our applications in the form of functions, we need a
    place to host and run it. This hosting place for the functions is provided by
    the cloud service provider. Now, once we have successfully hosted these functions
    and implemented rules when a particular function should execute, it is the duty
    of the cloud provider to handle the correct execution of these functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Now, when these functions have to execute, the cloud provider determines the
    correct environment that will be required to execute a particular function. Once
    this environment has been determined, the cloud provider launches an ephemeral
    container inside which the function code resides. This container provides the
    function a complete isolation from the other functions that might be executing
    in the environment. Now, once the container has launched successfully, this function
    executes, and provides a response back.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part happens once the function has completed its execution.
    Once the function has completed execution, the cloud provider can either terminate
    the container instance in which the function was running or it can keep it alive
    to handle newer requests. Most of the time, the decision is taken based on the
    frequency of the requests that are arriving and the kind of policies that have
    been set by the user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If a function instance is still running and waiting, a new incoming request
    might be redirected to that instance only, whereas if there are no ideal instances
    of a function running, the cloud provider will launch a new instance and redirect
    the request to that instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have a good idea of how FaaS works inside the serverless architecture
    and how it enables us to develop serverless applications. But how are these functions
    actually triggered? This brings us to another important component that comprises
    the serverless offerings. Let's take a look at what it is.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: API gateways in the serverless architecture
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](34b7ccb4-5bbc-474e-a70c-13ef8c1ae237.xhtml), *Taking the Microservices
    Approac*h, when we went through the concept of Microservices, we got introduced
    to API Gateways and how they help in the development of Microservices. These API
    gateways also play an important role in the development of the applications based
    upon the serverless architectures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](34b7ccb4-5bbc-474e-a70c-13ef8c1ae237.xhtml) *采用微服务方法*中，当我们了解了微服务的概念时，我们介绍了API网关以及它们如何帮助开发微服务。这些API网关在基于无服务器架构的应用程序开发中也起着重要作用。
- en: The API gateways are nothing but HTTP servers that embed the information about
    certain API endpoints of an application and associate these endpoints with some
    handlers. Once a request is made to a certain API endpoint, the handler associated
    with the API endpoint is called to handle the request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: API网关只是嵌入有关应用程序的某些API端点的信息并将这些端点与某些处理程序相关联的HTTP服务器。一旦向某个API端点发出请求，就会调用与API端点相关联的处理程序来处理请求。
- en: In the serverless architecture, the handlers that are associated with a particular
    API endpoint ...
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器架构中，与特定API端点相关联的处理程序...
- en: Understanding the execution of a serverless application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解无服务器应用程序的执行
- en: So far, we've learned that a serverless application is built in the form of
    functions that execute based on the occurrence of some event. Also, these functions
    do not stay alive forever. Instead, these functions are brought into execution
    as requirements arise. So, how does the provider handle the execution of these
    functions when a request comes in? Let's take a look.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到无服务器应用程序是以函数的形式构建的，这些函数基于某些事件的发生而执行。此外，这些函数并不永远保持活动状态。相反，这些函数在需要时被执行。那么，当请求到来时，提供者如何处理这些函数的执行呢？让我们来看一下。
- en: Cold-starting a function
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷启动函数
- en: When the application has been freshly deployed, it is pretty easy to imagine
    that there will be no instances of the function that will be executing currently.
    When a new request comes in that asks for the functionality provided by the function
    we have just deployed on the infrastructure. Now, the cloud provider systems are
    notified that there are no running instances of the function that can handle the
    incoming request.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序刚刚部署时，很容易想象当前不会有任何正在执行的函数实例。当新请求到来并要求由我们刚刚部署在基础设施上的函数提供的功能时。现在，云提供者系统被通知说没有正在运行的函数实例可以处理传入的请求。
- en: Once the provider system is made aware of the situation, it spawns up a new
    instance with the function code inside it. This instance now starts to execute
    the function based on the parameters provided in the request and a response is
    generated by the function and sent back to the requesting client. ...
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供者系统意识到情况，它就会生成一个包含函数代码的新实例。这个实例现在开始根据请求中提供的参数执行函数，并且函数生成响应并发送回请求的客户端。
- en: Hot-starting a function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热启动函数
- en: Completely opposite to the cold start, where a new instance of the function
    needs to be created and brought up to the execution, the hot start of the function
    utilizes the existing instance of the function that is already running in the
    infrastructure of the provider. When this happens, an incoming request does not
    have to spend time waiting for a new instance to spawn up before the request can
    be handled. This allows for the request to be processed quickly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与冷启动完全相反，热启动函数利用已经在提供者基础设施中运行的函数的现有实例。当这种情况发生时，传入的请求不必等待新实例生成才能处理请求。这允许请求快速处理。
- en: 'There is one thing that needs to be noted here: even in the case of a hot start
    of a function, the state from the previous execution of the function is not stored.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意一点：即使在函数的热启动情况下，也不会存储函数先前执行的状态。
- en: Now we know about one of the major factors on which the performance of a function
    may depend. Let's now move forward and build our first serverless application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了函数性能可能取决于的一个主要因素。现在让我们继续构建我们的第一个无服务器应用程序。
- en: Building our first serverless application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个无服务器应用程序
- en: With our basic knowledge of the serverless architecture and how it works, it's
    now time for us to develop our first serverless application. For this tutorial,
    we are going to use the Apache OpenWhisk project, which will help us run our demo
    application on our local development system. So, let's take a look at what Apache
    OpenWhisk has to offer us and how we can utilize the platform for our benefit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们对无服务器架构及其工作原理的基本了解，现在是时候开发我们的第一个无服务器应用程序了。在本教程中，我们将使用Apache OpenWhisk项目，在本地开发系统上运行我们的演示应用程序。因此，让我们看看Apache
    OpenWhisk为我们提供了什么，以及我们如何利用该平台来获益。
- en: A quick introduction to Apache OpenWhisk
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache OpenWhisk的快速介绍
- en: The Apache OpenWhisk platform provides us with the features and functionality
    that allow us to set up our own platform for running serverless applications.
    The project provides the functionality for executing functions based on the triggering
    of certain events in the environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Apache OpenWhisk平台为我们提供了功能和功能，使我们能够设置自己的平台来运行无服务器应用程序。该项目提供了根据环境中某些事件的触发执行函数的功能。
- en: The execution of these functions happens inside the docker containers, and the
    OpenWhisk platform manages the deployment and scaling of these functions inside
    it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的执行发生在docker容器内，OpenWhisk平台管理其中的函数的部署和扩展。
- en: 'Here are some of the features provided by the platform:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是平台提供的一些功能：
- en: '**Easy-to-use tools:** The platform provides a number of tools that allow us
    to easily package and port the application to run on the OpenWhisk platform, with
    the exception of having the application follow a set of conventions as defined
    by the platform.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用的工具：** 该平台提供了许多工具，使我们能够轻松打包和移植应用程序以在OpenWhisk平台上运行，除了应用程序遵循平台定义的一组约定。'
- en: '**Isolation using containers:** The platform isolates the different functions
    through the use of docker containers, such that every function runs inside its
    own isolated environment so as to avoid any kind of environmental-dependency conflicts.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for a wide variety of languages:** The OpenWhisk platform provides
    us with a number of supported language platforms that we can use to build our
    serverless application. This also includes the use of binary executables built
    using Go, C++, and Rust.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in API Gateway:** The OpenWhisk package comes with its own built-in
    API gateway, allowing us to easily integrate the applications through the use
    of RESTful API endpoints.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these functionalities make OpenWhisk a great platform for running the
    serverless applications, be it on the cloud or in your local development environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: But, before we start building the application, we need to have OpenWhisk deployed
    on our system. To deploy the project, please follow the steps in the *Technical
    requirements* section at the beginning of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: For the demo, we are going to build an application that queries the GitHub API
    for us and retrieves the repositories that are associated with our user account.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing the code for our application, we need to have some dependencies
    in place. So, let's build the environment and then move on to writing the code
    that will power our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, let''s create a directory that will contain all the files
    related to our project. Let''s call this folder `github_demo`. The following command
    gets the folder in place for us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have the directory setup done, let''s move into the directory and set
    up a few things:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once this is done, we can now set up our project. Before we start writing the
    code, let's get the virtual environment setup done, which will help us to keep
    our project dependencies segregated. ...
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Building our configuration file
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this application, we are going to use a configuration file
    to store our user-account-related data, which will allow us to authenticate to
    the `Github` API. For this, inside our project directory, create a new file named
    `config.ini` with the following contents:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we have the configuration file setup complete, let's move on to writing
    our application code, which will interact with `Github` to get our `repos`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with the GitHub API
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re coming to the actual part of our application, let''s get started
    with writing the code. The following code snippet describes the code we use to
    query the `Github` API:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting the code ready to run with OpenWhisk
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the code ready, it's now time to get it into a format that OpenWhisk can
    execute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'For any function to execute inside OpenWhisk, the code should be called from
    the `__main__.py` file. So, let''s create the file and add the following contents
    to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the code in place, let''s try to understand what we did here. First, we
    imported the `get_repos` function that we created in the `github_demo.py` file,
    which helps to retrieve the contents from the `Github` API:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we define the `main()` function, which is called by the OpenWhisk, to
    execute the code. Any code that is present inside the main function is directly
    executed by the OpenWhisk. So, we use this method to call our `get_repos()` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once this is done, we are on the verge of getting our application ready for
    the deployment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Taking the final steps toward deployment
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just a few more steps before we can deploy our application. For the
    successful installation of the app, let''s create a file that stores the dependencies
    required for running our project. The following command helps us get the dependencies
    in place:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the requirements packaged, now let''s package our project so that it can
    be deployed to OpenWhisk. For this, running the following command helps in creating
    a package of different project components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this, we are now all set to deploy our application to OpenWhisk.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经准备好将我们的应用程序部署到OpenWhisk了。
- en: Deploying to OpenWhisk
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到OpenWhisk
- en: Once we have the package ready for deployment, we need to run a few commands
    provided by OpenWhisk to get the package up and running on the platform.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好部署包，我们需要运行OpenWhisk提供的一些命令，以便在平台上启动并运行包。
- en: 'As a first step, we have to execute the following command to get the package
    uploaded on the OpenWhisk:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们必须执行以下命令，将包上传到OpenWhisk：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this command is executed, the package will be uploaded to the OpenWhisk
    platform and will be ready to run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了这个命令，包将被上传到OpenWhisk平台，并准备好运行。
- en: 'Now, to invoke the application, we can run the following command, which will
    execute the application in an asynchronous manner:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要调用应用程序，我们可以运行以下命令，以异步方式执行应用程序：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once this is done, our application starts executing in an asynchronous manner.
    By running asynchronously, we mean that the execution of the command won't wait
    until the end of the execution of the function, but rather will provide an action
    activation ID that can be used to track the results of the invocation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的应用程序开始以异步方式执行。通过异步运行，我们的意思是命令的执行不会等到函数执行结束，而是会提供一个可以用来跟踪调用结果的操作激活ID。
- en: Now, let's take a look at how OpenWhisk handles the execution of this application
    after the application has been deployed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看应用程序部署后OpenWhisk如何处理这个应用程序的执行。
- en: Understanding the execution of application Inside Openwhisk
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Openwhisk内应用程序的执行
- en: With the demo application in place, it's time for us to understand how the execution
    of this application works behind the scenes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了演示应用程序，现在是时候了解这个应用程序在幕后是如何执行的了。
- en: 'Behind the successful execution of the application, there are several steps
    involved which start from the `wsk action invoke` command that we ran to execute
    our application. So, let''s take a look at the steps that happened behind the
    scenes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功执行的背后，有几个步骤涉及，从我们运行`wsk action invoke`命令开始执行我们的应用程序。因此，让我们看看幕后发生的步骤：
- en: '**Making the API call:** Every action that we build to deploy on OpenWhisk
    is mapped as an API endpoint that will invoke the action. When we run `wsk action
    invoke`*,* the command makes a call to the API endpoint that has been mapped for
    the provided function. This call is then intercepted by Nginx inside OpenWhisk,
    which acts ...'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发出API调用：** 我们构建的每个要部署到OpenWhisk的操作都被映射为将调用该操作的API端点。当我们运行`wsk action invoke`时，该命令会调用为所提供的函数映射的API端点。然后，这个调用被OpenWhisk内的Nginx拦截，起到...'
- en: Advantages of going serverless
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器的优势
- en: 'With an understanding of how serverless applications work, now it''s time for
    us to take a look at the advantages provided by this development approach:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了无服务器应用程序的工作原理后，现在是时候看看这种开发方法提供的优势了：
- en: '**Reduced development efforts:** By using the services provided by the third-party
    cloud providers, we can reduce the development efforts for some of the common
    functionalities that are found inside an application, such as user authentication,
    notification, and file storage. All of these functionalities can be implemented
    through the use of the APIs provided by the cloud providers.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开发工作量：** 通过使用第三方云提供商提供的服务，我们可以减少一些在应用程序中找到的常见功能的开发工作量，例如用户身份验证、通知和文件存储。所有这些功能都可以通过云提供商提供的API来实现。'
- en: '**Less operational complexity:** The execution and scaling of a serverless
    application is managed by the cloud service provider, which takes away the operational
    complexities of managing our own infrastructure to handle the execution of the
    application.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作复杂性较低：** 无服务器应用程序的执行和扩展由云服务提供商管理，这消除了管理我们自己的基础设施以处理应用程序执行的操作复杂性。'
- en: '**High availability:** The applications built in the serverless manner provide
    high availability due to the fact that the infrastructure is managed by the cloud
    provider, which can have the application run in different data centers across
    the world, hence reducing the chance that the application''s uptime will be affected
    in case one of the data centers is experiencing some issues.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高可用性：** 以无服务器方式构建的应用程序由于基础设施由云提供商管理，因此可以在世界各地的不同数据中心运行应用程序，从而降低了应用程序的可用性受影响的机会。'
- en: '**Optimized resource allocation:** Since a function is executed only when a
    certain event occurs, the allocation of resources happens only when a particular
    function is being executed, which optimizes the usage of resources across the
    infrastructure.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源分配：** 由于只有在发生某个事件时才执行函数，因此只有在执行特定函数时才分配资源，这优化了跨基础设施的资源使用。'
- en: '**Choice of programming languages:** Most of the serverless solutions provide
    a wide support for the different types of programming languages that are available,
    which allows us to implement our solutions with the best-possible technology stack
    that will work with the application.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程语言的选择：** 大多数无服务器解决方案都支持各种类型的编程语言，这使我们能够使用最佳的技术栈来实现我们的解决方案。'
- en: With this, we now have enough points that can convince us to choose the serverless
    development approach in case our needs align with the development methodology
    that needs to be followed for building a serverless application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有足够的理由选择无服务器开发方法，以便我们的需求与构建无服务器应用程序所需遵循的开发方法论相一致。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we moved through this chapter, we took a look at how the serverless architecture
    is becoming the new trend in the development of the applications, and how this
    architecture works. We covered the different components of the serverless architecture
    and went through the concepts of Backend as a Service and Function as a Service,
    which power the serverless architecture. We then looked at the role of API Gateways
    in the architecture and how the API Gateway in serverless applications differs
    from the one we used in Microservices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们阅读本章的过程中，我们看到了无服务器架构如何成为应用程序开发的新趋势，以及这种架构的工作原理。我们涵盖了无服务器架构的不同组件，并介绍了后端即服务和函数即服务的概念，它们支持无服务器架构。然后，我们看了一下API网关在架构中的作用，以及无服务器应用程序中的API网关与微服务中使用的API网关有何不同。
- en: After that, we took a tour of building our first serverless application and
    ran it through Apache OpenWhisk, which provides an open source platform for running
    serverless applications. Here, we also took a deep ...
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始构建我们的第一个无服务器应用程序，并通过Apache OpenWhisk运行它，该平台提供了一个运行无服务器应用程序的开源平台。在这里，我们也深入探讨了...
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the advantages provided by the serverless architecture?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无服务器架构提供了哪些优势？
- en: How does BaaS help is the development of applications?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BaaS如何帮助应用程序开发？
- en: How does an API Gateway help in the execution of serverless applications?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关如何帮助执行无服务器应用程序？
- en: What are some of the things that make it hard to port an application into a
    serverless format?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些因素使将应用程序转换为无服务器格式变得困难？
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Did you find the idea of serverless architecture interesting? Take a look at
    *Building Serverless Applications with Python* by *Jalem Raj Rohit*, *Packt Publishing*,
    and dive deeper into the serverless architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得无服务器架构的理念有趣吗？看看*Jalem Raj Rohit*的*Packt Publishing*出版的*使用Python构建无服务器应用程序*，深入了解无服务器架构。
