- en: Chapter 12. Audio in Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing FMOD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sound effect manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with multiple sound file names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important aspects in games development is audio programming.
    However, it is, strangely, one of the most neglected and underrated sections of
    games development as well. To understand the impact of audio in games, try playing
    a game such as *Counter-Strike* or *Quake* with sounds and then try playing the
    games without sound. It has a huge impact. Audio programming, if not done correctly,
    can lead to games crashing and lots of other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is very important to learn the correct way to do audio programming.
    Most engines will have a built-in sound component. For others, we need to add
    the audio component. In this chapter, we will have a look at one of the most popular
    sound engines. We will also have a look at how to integrate SDL into our C++ code,
    in order to play audio and sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: Installing FMOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to get started with is to install FMOD. This is one of the most
    popular audio engines and used in almost all modern game engines. It can also
    be added to any game engine of your choice. The other popular audio engine is
    called **Wwise**. This is used to integrate the audio for console programming,
    such as on the PS4.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see the different types of source control available
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://www.fmod.org/](http://www.fmod.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To download FMOD, go to [http://www.fmod.org/download/](http://www.fmod.org/download/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one authoring tool to edit the audio files.However, we should be downloading
    the FMOD Studio Programmer API and the Low Level Programmer API.
  prefs: []
  type: TYPE_NORMAL
- en: It also has plugins for all modern engine such as Cocos2d-x, Unreal Engine,
    and Unity3D.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FMOD is a low-level API, so it provides callbacks that help us to use the interface
    of FMOD to play sounds, pause sounds, and do a whole lot of other things. Because
    we have the source files, we can build the libraries and also use it in our own
    engine. FMOD also provides an API for Unity3D, which means that the code is also
    exposed to C#, making it easier to work with in Unity3D.
  prefs: []
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any game would be incomplete if it did not have any background music. So it
    is very important that we integrate a way to play music into our C++ engine. There
    are various ways to do this. We are going to use SDL to play music in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine and a working copy of Visual Studio. The SDL library
    is also required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to play background music:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are playing background music for our game. We need to create
    an interface as a wrapper to the existing SDL audio library. Interfaces are also
    good at providing a skeleton architecture that a base class can derive from in
    the future. We require `SDLAudioDevice`, which is the main handler object for
    playing the music. On top of that, we create a pointer to an audio data object,
    which creates audio from the file path provided. The device handler object has
    a built-in function called `CreateAudioFromFile` to help us with this process.
    Finally, we have an audio context class, which has functions to play, pause, and
    stop the audio. Each of the functions takes an audio object as a reference, which
    is used to perform the action on our audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sound effects are a neat way of adding some sense of tension or achievement
    to the game. Playing, pausing, and stopping sound effects all work in the same
    way that we used for background music, which we saw in the previous recipe. However,
    we can add some variety to the sound files by controlling their position, volume,
    and pitch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a source file called `Source.cpp` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are only looking at that part of the game that involves
    modifying the pitch, volume, and position of the sound file. These three things
    can be considered to be the attributes of the sound file, but there are other
    attributes as well. Therefore, the first thing to do would be to create a structure.
    The structure is used to store all the attributes of the sound. All we need to
    do is populate the structure with values as and when we want them. Finally, we
    create an audio object and pass in the `SampleInfo` struct as one of the parameters
    of the object. The constructor then initializes the sound to have these properties.
    Because we attached the properties to the object, it means we can also manipulate
    them at runtime and lower the volume dynamically if required. The pitch and other
    properties could also be manipulated in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sound effect manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although not one of the best practices out there, one of the most common methods
    for handling audio is to create a manager class. The manager class should ensure
    that there is only one audio component in the whole game, which controls which
    sound is to be played, paused, looped, and so on. Although there are other ways
    of writing the manager class, this is the most standard practice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to add sound effect manager
    using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have written a singleton class to implement the audio manager.
    The singleton class has all the necessary `sdl` headers and other device and context
    objects required to play the sounds. All these are private, so they cannot be
    accessed from other classes. We also made a static pointer to the class and made
    the constructor private as well. If we need an instance of this audio manager,
    we have to use the static `GlobalAudioClass *instance()` function. This function
    automatically checks whether there is an instance already created, then it returns
    that instance, or it creates a new one. Hence, only one instance of the manager
    class exists at all times. We can also use the manager to set and get data for
    the sound file, for example by setting the path of the sound file.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with multiple sound file names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In games, there will not be one sound file, but multiple sound files that we
    will have to deal with. Each will have a different name, type, and location. So
    it is not a wise move to define all of them separately. It will work, but it will
    be very messy coding if we have over 20 sound effects in our game, so there is
    a need for a slight improvement to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    an SVN client. A versioned project is also necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how easy it is to deal with multiple sound file
    names. All you have to do is add a source file called `Source.cpp`. Add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created an audio data handler class. The class has
    `enum`, which stores all the logical names of the sounds, for example `battle_music`,
    `background_music`, and so on. We also have a string array, which stores the actual
    names of the sound files. The order is important and it has to match the order
    in which we have written `enum`. Now that this `enum` is created, we can create
    an object of this class and set and get the audio filename. The `enum` is stored
    as integers and starts at `0` by default, and the names serve as an index for
    the string array. So `Files[AudioDataHandler::Background]` is actually `Files[1]`,
    which is `Hello.wav`, and so the correct file will be played. This is a very neat
    way of organizing audio data files. The other way to handle audio in games is
    to have the names of the audio files and the attributes of their location in an
    XML or JSON file, and have a reader which parses this information and then fills
    up the array in the same way as we are doing. That way, the code is extremely
    data driven because the designer or the audio engineer can just change the values
    of the XML or the JSON file, without having to make any changes to the code.
  prefs: []
  type: TYPE_NORMAL
