- en: Gearing up for the Journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After learning the theory about microservices, we will now move on to hands-on
    implementation. This chapter will lay the foundation for the journey ahead and
    will revisit Node.js and TypeScript concepts essential to the book. It will tell
    you about the trends and adoption rates of both languages. We will go through
    all the required installations, and we will prepare our development environment.
    We will test the development environment by implementing the customary `Hello
    World` microservice. In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting up the primary development environment**: We will set up a primary
    environment with all the prerequisites needed. We will understand all aspects
    required for microservice development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primer to TypeScript**: In this section, we are going to walk through some
    of the major TypeScript topics that we are going to use throughout the book. We
    will justify usage of TypeScript as our language in Node.js, and understand how
    applications can be written in TypeScript and Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primer to Node.js**: In this section, we will go through some advanced Node.js
    topics such as clustering in Node.js, the recently introduced async/await, and
    others. We will understand the Event Loop, and briefly look at Node streams and
    latest trends in Node.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice implementation**: We will write a `Hello World` microservice
    that will use our development environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up primary environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will set up our environment required for our journey ahead.
    You already installed Node.js and TypeScript globally. At the time of writing,
    the available version of Node.js was **9.2.0** and TypeScript was **2.6.2**.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code (VS Code)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**VS Code** is one of the best available editors right now for TypeScript.
    By default, VS Code TypeScript displays warnings on incorrect code, which helps
    us to write better code. Linters, debugging, build issues, errors, and so on are
    provided out of the box by VS Code. It has supports for JSDoc, sourcemaps, setting
    different out-files for files that are generated, hiding derived JavaScript files,
    and so on. It has support for auto-imports, generating method skeletons directly
    just like Eclipse for Java developers. It also provides options for version control
    systems. Hence, it will be our primary choice as IDE. You can download it from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing it for Windows is the easiest thing, as it''s an `.exe` file and
    all you have to do is select a path and follow the steps. Installing it on a Unix/Ubuntu
    machine involves downloading the `deb` file and then executing the following command
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once VS Code is available, open extensions and download [https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter](https://marketplace.visualstudio.com/items?itemName=pmneo.tsimporter) and
    [https://marketplace.visualstudio.com/items?itemName=steoates.autoimport](https://marketplace.visualstudio.com/items?itemName=steoates.autoimport).
    We will use the advantages of these extensions, which will be helpful for easy
    code management, prebuilt skeletons, and more.
  prefs: []
  type: TYPE_NORMAL
- en: PM2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is the advanced processor manager for Node.js. Node.js, being single threaded,
    requires some add-on tools for server management such as restarting server, memory
    management, multiple process management, and so on. It has a built-in load balancer,
    and it allows you to keep the application running forever. It has zero downtime
    and other system admin options that has eased up life. It is also exposed as a
    module, so we can runtime trigger various options at any phase of Node.js applications.
    To install PM2, open up a Terminal and shoot the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: More detailed options and APIs can be found at [http://pm2.keymetrics.io/docs/usage/pm2-api/](http://pm2.keymetrics.io/docs/usage/pm2-api/).
  prefs: []
  type: TYPE_NORMAL
- en: NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NGINX** is one of the most popular web servers. It can be used as a load
    balancer, HTTP cache, reverse proxy, and shock absorber. It has a capacity for
    handling more than 10,000 simultaneous connections with a very low footprint (approximately
    2.5 MB per 10,000 inactive [https://en.wikipedia.org/wiki/HTTP_persistent_connection](https://en.wikipedia.org/wiki/HTTP_persistent_connection)).
    It was specifically designed to overcome Apache. It can roughly handle four times
    more requests per second than Apache. NGINX can be used in various ways, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployed standalone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a frontend proxy for Apache acting as a network offload device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Act as a shock absorber, providing servers from a sudden spike in traffic or
    slow internet connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is our perfect fit for microservice applications, as containerized microservice
    applications need a frontend that is able to conceal and deal with the complex
    and ever-changing nature of applications running behind it. It performs some major
    things such as forward HTTP requests to different applications, shock absorber
    protection, routing, consolidated logging, Gzip compression, zero downtime, caching,
    scalability, and fault tolerance. Hence, it is our ideal application delivery
    platform. Let's begin NGINX 101.
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version from this site, [http://nginx.org/en/download.html](http://nginx.org/en/download.html),
    based on your operating system. At the time of writing, the mainline Version was
    **1.13.7**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once extracted, you can simply start NGINX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether NGINX is up or not you, can hit the following command in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of Linux, you can use the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are other useful NGINX commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `nginx -s stop` | Fast shutdown |'
  prefs: []
  type: TYPE_TB
- en: '| `nginx -s quit` | Graceful shutdown |'
  prefs: []
  type: TYPE_TB
- en: '| `nginx -s reload` | Changing configuration, starting new worker processes
    with a new configuration, and graceful shutdown of old worker processes |'
  prefs: []
  type: TYPE_TB
- en: '| `nginx -s reopen` | Re-opening log files |'
  prefs: []
  type: TYPE_TB
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** is an open source platform for developing, shipping, and running
    applications with the major advantage of separating your application from your
    infrastructure so you can adapt to major changes easily and quickly. Docker promotes
    the philosophy of containers. A **container** is a runnable instance of any configured
    image. A container is totally isolated from the other containers and the host
    machine. This very much resembles our microservice philosophy. We will see Docker
    in much more detail when we come to the deployment part. Let''s install Docker
    on our system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker for Windows requires Windows 10 Pro edition and Hyper-V. So as a generally
    available alternative, we will go for Linux. Windows users can download Oracle
    VM VirtualBox, download any Linux image, and then follow the same process. Follow
    along with the steps given here: [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the installation, hit the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845b957e-1d50-43e4-8650-6dd48e2bd2d0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker installation
  prefs: []
  type: TYPE_NORMAL
- en: Primer to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TypeScript** originated from shortcomings in JavaScript development with
    the advent of using JavaScript for large-scale applications. TypeScript introduced
    a JavaScript compiler with presets of syntactical language extensions, class-based
    programming, and ways to convert extensions into regular JavaScript. TypeScript
    became extremely popular as it introduced type safety in JavaScript, which happens
    to be one of the most flexible languages ever. This enables JavaScript to be a
    more object-oriented and compile safe language. TypeScript is more of a superset
    of ES standards, which enables developers to write cleaner, easy-to-refactor,
    and upgradable code. In this section, we will go through various primary topics
    of TypeScript, which are essential for our journey ahead. TypeScript is JavaScript
    with type annotations. TypeScript has a transpiler and type checker, which throws
    an error if there is a mismatch in types, and converts TypeScript code to JavaScript
    code. We will look at the following topics briefly, which will essentially help
    us to write Node.js in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `tsconfig.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging TypeScript in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding tsconfig.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a `tsconfig.json` file is an indication of having a directory that is
    of a TypeScript project, and a configuration file is needed to compile the TypeScript
    into JavaScript. You compile the TypeScript into JavaScript by using the `tsc`
    command. Invoking it, the compiler searches for configurations loaded in `tsconfig.json`.
    You can specify compilation for a complete project (from the current directory
    to the parent directory) or you can specify `tsc` for a particular project. You
    can find all possible options using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what the command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33387b74-28e6-4c61-ae9b-48fe117bb972.png)'
  prefs: []
  type: TYPE_IMG
- en: The tsc help command
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the version of TypeScript is **2.6.2** and all context
    would be made from the same version. If you do not have the updated version, run
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm uninstall typescript -g`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install typescript@latest -g`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look into the sample `tsconfig.json` file and all options that are
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now dissect this file and understand the most common options used.
  prefs: []
  type: TYPE_NORMAL
- en: compilerOptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All settings required to compile the project are mentioned here. A detailed
    list of all the compiler options, along with default values, can be found at this
    site: [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html).
    If we don''t specify this option, then the default values will be picked up. This
    is the file from where we instruct TypeScript on how to handle various things
    such as various decorators, supporting JSX files, and transpiling pure JavaScript
    files. The following are some of the most commonly used options, which we can
    understand with respect to the preceding sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `noImplicitAny` | This tells the `tsc` compiler to shout if it finds variable
    declarations that have declarations which accept any types, but the explicit type
    definition for any type is missing. |'
  prefs: []
  type: TYPE_TB
- en: '| `experimentalDecorators` | This option enables using decorators in TypeScript
    projects. ES has not yet introduced decorators, so they are disabled by default.
    A decorator is any declaration that can be attached to class declarations, method,
    accessors, properties, or parameters. Using decorators simplifies programming.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `emitDecoratorMetaData` | TypeScript supports emitting certain types of metadata
    for any declarations that have decorators. To enable this option, it must be set
    to true in `tsconfig.json`. |'
  prefs: []
  type: TYPE_TB
- en: '| `watch` | This option is more like `livereload`; whenever any of the source
    file is changed, then the compiling process is re-triggered to generate the transpiled
    files again. |'
  prefs: []
  type: TYPE_TB
- en: '| `reflect-metadata` | It preserves the type information in an object''s metadata.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `module` | It is the output module type. Node.js uses CommonJS, so that is
    why there are CommonJS in modules. |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | The output presets we are targeting; Node.js uses ES6, so we use
    ES6. |'
  prefs: []
  type: TYPE_TB
- en: '| `moduleResolution` | This option will tell TypeScript which resolution strategy
    to use. Node.js users require a module strategy, so TypeScript then uses this
    behavior to resolve these dependencies. |'
  prefs: []
  type: TYPE_TB
- en: '| `sourceMap` | This tells TypeScript to generate the sourcemaps, which can
    be easily used to debug TypeScript just like we debug JavaScript. |'
  prefs: []
  type: TYPE_TB
- en: '| `outDir` | The location in which the transpiled files should be kept. |'
  prefs: []
  type: TYPE_TB
- en: '| `baseUrl` and `paths` | Instructing TypeScript where it can find the type
    files. We basically tell TypeScript that for every (`*`) found in the `.ts` file,
    it needs to look in the file location `<base_url> + src/types/*`. |'
  prefs: []
  type: TYPE_TB
- en: include and exclude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we define our project context. It basically takes an array of global patterns
    that need to be included in the compilation path. You can include or exclude an
    array of global patterns that adds or removes files to the transpilation process.
    Note that this is not the final value; there are property files that take an array
    of filenames and they override include and exclude.
  prefs: []
  type: TYPE_NORMAL
- en: extends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to extend any of the base configurations, then we use this option
    and specify the file path that it has to extend. You can find the complete schema
    of `tsconfig.json` at [http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript needs to span across other JavaScript libraries too if we want to
    efficiently and globally use TypeScript. TypeScript uses the `.d.ts` files to
    provide types of JavaScript libraries that were not written in ES6 or TypeScript.
    Once the `.d.ts` file is defined, it becomes very easy to see the return types
    and provide easy type checking. The TypeScript community is very active and it
    provides types for most files: [https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types).
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting our `tsconfig.json` file, we have specified the option `noImplicitAny:
    true` and we need a mandatory `*.d.ts` file for any of the libraries we use. If
    we set that option to false, `tsc` will not give any errors, but that''s not a
    recommended practice at all. Having an `index.d.ts` file for every library we
    use is one of the standard practices. We''ll look at various topics such as how
    to install types, what if types are not available, how to generate types, and
    what the general processes for types are.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing types from DefinitelyTyped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Types from any library would be a `dev` dependency and all you have to do is
    install it from `npm`. The following command installs express types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads the express type to the `@types` folder, and TypeScript
    looks in the `@types` folder to resolve mappings for that type. As we only need
    it during development time, we have added the `--save-dev` option.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times we may need to write our own `.d.ts` file in order to efficiently
    use TypeScript. We will look at how we can generate our own typing and instruct
    TypeScript from where to find the types. We will use the automated tool and learn
    ways to manually write our own `.d.ts` file, then tell TypeScript where to find
    a location of custom types.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dts-gen tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an open sourced utility provided by Microsoft. We will use it to generate
    our typings for any project. Shoot up a Terminal as Admin or use `sudo su -` and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For all global modules, we will use the command prompt as Admin for Windows,
    and for Linux/Mac we will use the root user or `sudo su -`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use one globally available module and generate its typing. Install
    `lusca` and generate its typing using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should see output such as `Wrote 83 Lines to lusca.d.ts`, and when you check,
    you can see all method declarations there, just like an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own *.d.ts file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are writing your own `*.d.ts` file, the stakes are very high. Let''s
    create our own `*.d.ts` file for any module. Say we want to write a module for
    `my-custom-library`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create one blank file called `my-custom-library.d.ts` and write the following
    inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will silence the compiler and won't throw any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to define all the methods there and what the return type expected
    out of each method is. You can find several templates here: [http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html](http://www.typescriptlang.org/docs/handbook/declaration-files/templates.html).
    Here, we need to define the available methods and what they are returning. For
    example, take a look at the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next big important question would how to debug a Node.js application return
    in TypeScript. Debugging JavaScript was easy, and to give the same experience
    TypeScript has a feature called **sourcemaps**. When sourcemaps are enabled in
    TypeScript, it allows us to drop breakpoints in TypeScript code, which will be
    paused when the equivalent line of JavaScript is hit. The sole purpose of sourcemaps
    is to map the generated source to the original source that generated it. We will
    briefly see debugging a Node.js, and TypeScript application in our editor VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primarily, we need to enable sourcemaps. First of all, we need to ensure that
    TypeScript has sourcemap generation enabled. Go to your `tsconfig.json` file and
    write the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now when you transpile your project, next to every JavaScript file you generate
    you will see a `.js.map` file.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is to configure VS Code for debugging. Go create a folder, `.vscode`,
    and add a file named `launch.json`. This is very similar to using `node-inspector`.
    We will debug the `node-clusters` project, which you can find in the source code.
    Open that project in VS Code; if it doesn't have a `dist` folder then generate
    a distribution by executing the `tsc` command at the main level, which will create
    the `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a folder named `.vscode` and inside it create a `launch.json`
    file with the following configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2482e26a-b450-4d4d-82a0-d2400b8ad5ca.png)'
  prefs: []
  type: TYPE_IMG
- en: VS Code debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on Start Debugging, the following screen appears. Look at the
    screen, which has a detailed description of debugging points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf105aad-376e-4e7d-840a-bc795f0b03d3.png)'
  prefs: []
  type: TYPE_IMG
- en: VS debugger
  prefs: []
  type: TYPE_NORMAL
- en: Primer to Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has evolved over the years and has now become the go-to technology for
    anyone who wants to embrace microservices. Node.js was created to solve the massive
    I/O scaling problem, which when applied to our microservice design will result
    in a match made in heaven. The package manager for Node.js has more modules than
    Maven, RubyGems, and NuGet, which can be used directly and save lots of productive
    hours. Characteristics such as an asynchronous nature, event-driven I/O, and non-blocking
    mode make it one of the best solutions for creating high-end, efficient performance,
    real-time applications. When applied to microservices, it will be able to handle
    an extreme amount of load with low response times and low infrastructure. Let's
    look at one of the success stories of Node.js and microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '**PayPal**, seeing the trending Node.js, decided to go with Node.js in their
    accounts overview page. They were bewildered by the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js application development was developed at twice the rate of Java development
    and with fewer people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code had 33% fewer **Lines of Code** (**LOC**) and 40% fewer files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single core Node.js application handled double the requests per second when
    compared to five core Java application setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix, GoDaddy, Walmart, and many more have similar stories.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the primary and useful concepts essential for Node.js
    development that we will use throughout our journey. We will see various topics
    such as the Event Loop, how to achieve clustering, async fundamentals, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the single-threaded design of Node.js, it is considered to be one of
    the most complicated architectures. Being completely event-driven, understanding
    Event Loop is key to mastering Node.js. Node.js is designed as an event-based
    platform, meaning anything that occurs in Node.js is just a reaction to an event.
    Any operation done in Node.js passes through a series of callbacks. The complete
    logic is abstracted from developers and is handled by a library called `libuv`.
    We will gain a thorough understanding of the Event Loop in this section including
    how it works, common misconceptions, its various phases, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the common myths about Event Loop and a brief on
    the actual workings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Myth#1—Event Loop works in a different thread than the use code**: There
    are two threads maintained, one parent thread where the user-related code or user-related
    operations run, and another where the event looping code runs. Any time  an operation
    is executed, the parent thread passes over the work to the child thread, and once
    the child thread operation is completed, it pings the main thread to execute the
    callback:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fact**: Node.js is single-threaded and everything runs inside the single
    thread. Event Loop maintains the execution of the callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Myth#2—Thread pool handles asynchronous events**: All asynchronous operations,
    such as callbacks to data returned by a database, reading filestream data, and
    WebSockets streams, are off loaded from a thread pool maintained by `libuv`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fact**: The `libuv` library indeed creates a thread pool with four threads
    to pass on the asynchronous work, but today''s operating systems already provide
    such interfaces. So as a golden rule, `libuv` will use those asynchronous interfaces
    rather than the thread pool. The thread pool will only be used as the last alternative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Myth#3—Event Loop, like a CPU, maintains a stack or queue of operations**:
    The Event Loop goes through a maintained queue of asynchronous tasks maintained
    via the *FIFO rule*, and executes the defined callbacks maintained in a queue:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fact**: While there are queue-like structures involved in `libuv`, the callbacks
    are not processed through a stack. The Event Loop is more of a phase executioner
    with tasks processed in a round-robin manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have ruled out basic misconceptions regarding Event Loop in Node.js,
    let''s look at the workings of Event Loop in detail and all the phases that are
    in the Event Loop phase execution cycle. Node.js processes everything occurring
    in the environment in the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timers**: This is the phase where all the `setTimeout()` and `setInterval()`
    callbacks are executed. This phase will run early because it has to be executed
    in the time interval specified in the calling functions. When the timer is scheduled,
    then as long as the timer is active the Node.js Event Loop will continue to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I/O callbacks**: Most common callbacks are executed here except timers, close
    connection events, `setImmediate()`. An I/O request can be blocking as well as
    non-blocking. It executes more things such as connection error, failed to connect
    to a database, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poll**: This phase executes the scripts for timers when the threshold has
    elapsed. It processes events maintained in the poll queue. If the poll queue is
    not empty, the Event Loop will iterate through the entire queue synchronously
    until the queue empties out or the system hard peak size is reached. If the poll
    queue is empty, the Event Loop continues with the next phase—it checks and executes
    those timers. If there are no timers, the poll queue is free; it waits for the
    next callback and executes it immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check**: When the poll phase is idle, the check phase is executed. Scripts
    that have been queued with `setImmediate()` will be executed now. `setImmediate()`
    is a special timer that has use of the `libuv` API and it schedules callbacks
    to be executed after the poll phase. It is designed in such a way that it executes
    after the poll phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close callbacks**: When any handle, socket, or connection is closed abruptly,
    the close event is emitted in this phase, such as `socket.destroy()`, connection
    `close()`, that is, all on (`close`) event callbacks are processed here. Not technically
    parts of the Event Loop, but two other major phases are `nextTickQueue` and other
    micro tasks queue. The `nextTickQueue` processes after the current operation gets
    completed, regardless of the phase of Event Loop. It is fired immediately, in
    the same phase it was called, and is independent from all phases. The `nextTick` function
    can contain any tasks and they are just invoked as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next important part is the micro and the macro tasks. `NextTickQueue` has
    higher priority over micro and macro tasks. Any task that is in `nextTickQueue`
    will be executed first. Micro tasks include functions such as resolved promise
    callbacks. Some examples of micro tasks can be `promise.resolve`, `Object.resolve`.
    An interesting point to note here is native promises only come under micro tasks.
    If we use libraries such as `q` or `bluebird`, we will see them getting resolved
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js clusters and multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any Node.js instance runs in a single thread. If any error occurs, the thread
    breaks, the server stops, and you need to restart the server. To take advantage
    of all the cores available in a system, Node.js provides an option to launch a
    cluster of Node.js processes so that the load is evenly distributed. There are
    many tools available that do the same thing. We will look at a basic example and
    then learn about automated tools such as **PM2**. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create an express server. We will need `express`, `debug`,
    `body-parser`, and `cookie-parser`. Open up a Terminal and hit the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we download the types for these modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our `app.ts` and `www.ts` files. Construct your `app.ts` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5668248a-a9ed-4562-95b5-64d65ca58e95.png)'
  prefs: []
  type: TYPE_IMG
- en: Express the TypeScript way
  prefs: []
  type: TYPE_NORMAL
- en: 'For `www.ts`, we will use the `cluster` module and create workers available
    as a number of cores. Our logic would be divided as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now when we transpile the source and run `www.js`, we will see multiple workers
    online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete files can be found at `node-clusters/src/bin/www.ts`. Go and run the
    application. You should see multiple workers online now.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to use *PM2* ([https://www.npmjs.com/package/pm2](https://www.npmjs.com/package/pm2)).
    PM2 has various options for `livereload`, reload with zero downtime, and starting
    mode in clusters. Some sample commands available in PM2 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `pm2 start www.js -i 4` | Start four instances of an application in cluster
    mode. It will load balance requests to each node. |'
  prefs: []
  type: TYPE_TB
- en: '| `pm2 reload www.js` | Zero downtime needed for reloading `www.js` with changes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pm2 scale www.js 10` | Scaling clustered apps to 10 processes. |'
  prefs: []
  type: TYPE_TB
- en: Async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As JavaScript is asynchronous in nature, it becomes very difficult to maintain
    the execution of tasks once a process is completed. What once started with callbacks
    soon turned to promises, async module, generators and yield, and async and await.
    Let''s start with async/await 101:'
  prefs: []
  type: TYPE_NORMAL
- en: Async/await is one of the modern ways to write asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built on top of promises, it cannot be used with plain callbacks or Node promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async/await is non-blocking code even though it appears synchronous, which is
    its main power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on `node-fibers`, it is lightweight and is TypeScript friendly as typings
    are embedded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now see a practical implementation of async/await. What once started
    as huge callback hell and nested chains of `.then()` can simply be reduced to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will now look into two common async/await design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying failed requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we add back safe or retry requests in our system to make sure that if
    the service returns errors, we can retry the service if it is down for some time.
    In this sample, we have used an async/await pattern efficiently as an exponential
    retry parameter, that is, retry after 1, 2, 4, 8, and 16 seconds. A working example
    can be found in `retry_failed_req.ts` in a source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0133f7eb-5ef3-4e79-a29e-49463ddb510a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrying request exponentially
  prefs: []
  type: TYPE_NORMAL
- en: Multiple requests in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Executing multiple parallel requests becomes a piece of cake with async/await.
    Here, we can execute several asynchronous tasks at once, and use their values
    in different places. The complete source code can be found at `multiple_parallel.ts`
    in `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Briefly, a **stream** is an abstract interface for streaming data continuously
    in Node.js. A stream can be a sequence of data coming over time from a source
    and running to a destination. The source can be anything—a database of 50 million
    records, a file of size 4.5 GB, some HTTP call, and so on. Streams are not available
    all at once; they don''t fit in memory, they just come some chunks at a time.
    Streams are not only for handling large files or a huge amount of data, but also
    they give us a good option of composability through piping and chaining. Streams
    are one of the ways to do reactive programming, which we will look at in more
    detail in the next chapter. There are four streams available in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readable stream**: The streams from which data can be read only; that is,
    here data can only be consumed. Examples of readable streams can be HTTP responses
    on the client, `zlib` streams, and `fs` read streams. Data at any stage in this
    stream will either be in a flowing state or paused state. On any readable stream,
    various events can be attached such as data, error, end, and readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writable stream**: Streams to which data can be written. For example, `fs.createWriteStream()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplex stream**: Streams that are both readable and writable. For example,
    `net.socket` or a TCP socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transform stream**: A transform stream is basically a duplex stream that
    can be used to transform data while it is being written or read. For example,
    `zlib.createGzip` is one of the streams to compress a lot of data using gzip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s understand the workings of a stream via an example. We will create
    a custom `Transform` stream and extend the `Transform` class, thus seeing read,
    write, and transform operations all at once. Here, the output of the transform
    stream will be computed from its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: We have a user''s information and we want to hide sensitive parts
    such as email address, phone number, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: We will create one transform stream. The transform stream will
    read data and transform it by removing sensitive information. So, let''s start
    coding. Create one empty project with `npm init`, add one folder, `src`, and the `tsconfig.json` file
    of the earlier section. Now, we will add Node.js typings from `DefinitelyTyped`.
    Open up a Terminal and type the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write our custom filter transform stream. Create a `filter_stream.ts`
    file and inside it, let''s write the transform logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What did we just do?
  prefs: []
  type: TYPE_NORMAL
- en: We created a custom transform and exported it, so it can be used anywhere in
    other files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options are not mandatory in a constructor if they aren't passed; we create
    the default options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, streams expect buffer/string values. There is an `objectMode` flag
    that we have to set in the stream so it can accept any JavaScript object, which
    we did in the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We overrode the transform method to suit it to our needs. In the transform method,
    we removed those keys that are passed out in filter options and created a filtered
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will create an object of filter stream, to test out our results. Create
    a file called `stream_test.ts` parallelly to `filter_stream.ts` and add the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open up your `package.json` file and add `"start":"tsc && node .\\dist\\stream_test.js"`
    in your `scripts` tag. Now when you run `npm start`, you will be able to see the
    transformed output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you are on Linux/macOS, replace `\\` with `//`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Hello World microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by writing our first microservice. Based on the previous topics,
    we will construct our first microservice with best practices and the widely used
    `node_modules`. We will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CORS** ([https://www.npmjs.com/package/cors](https://www.npmjs.com/package/cors))
    | Adds CORS headers, so that cross applications can access it. |'
  prefs: []
  type: TYPE_TB
- en: '| **Routing Controllers** ([https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers))
    | Beautiful decorators provided in this module, which help us to write our API''s
    and routes easily. |'
  prefs: []
  type: TYPE_TB
- en: '| **Winston** ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston))
    | Perfect logging module with many advanced features. |'
  prefs: []
  type: TYPE_TB
- en: 'So, open up a Terminal and create one Node project with a default `package.json`.
    Follow these steps. The full source code for reference is available in the `first-microservice`folder
    in the extracted source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will download the preceding dependencies and basic express
    dependencies. Enter the following command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the types of necessary modules as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create our application structure, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fcd1e54d-7c71-41e4-9793-65ca1a840a45.png)'
  prefs: []
  type: TYPE_IMG
- en: Folder structure
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create our express file and configure it using the `routing_controllers`
    module. Create one express config class and instruct it to use our directory controllers
    as the source from where it can find the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write our application startup logic inside `application.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to write our controller and to return JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a new object of our `Application` file inside `index.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You are all done; compile your TypeScript and start a transpiled version of
    `index.ts`. When you hit `localhost:3000/hello-world`, you will see JSON output—`{"msg":"This
    is first Typescript Microservice"}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add the automation of all the tasks while starting a server, we define scripts
    in our `package.json`. The first script is to always clean before transpiling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next script is for building TypeScript using the `typescript` version available
    inside the `node` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The final one basically instructs it to clean, build, and start the server
    by executing `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a Docker build. Create one `Docker` file and let''s
    write the Docker image script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will learn about Docker in more detail in future chapters. Now, go ahead
    and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget the dot at the end of the command while building the image. A dot
    indicates that we are using Dockerfile in the local directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Docker image will be built. You will see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28607eda-e3e4-4929-8be0-c80a21019443.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker create image
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `sudo docker images` command to check the image, which you
    can later use anywhere. To run the image, just use the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can hit `localhost:8080/hello-world` to check the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While we just exposed the REST API, for the outer world it's just another service
    on port `8080`; the inner implementation is abstracted from the consumer. This
    is one of the major differences between REST API and microservices. Anything within
    the container can change at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a primary introduction to some of the most fundamental
    concepts of Node.js and TypeScript that are essential for making scalable applications
    suitable for enterprise needs. We set up our primary environment and learned about
    Docker, PM2, and NGINX. At the end, we created our traditional `Hello World` microservice
    the TypeScript way in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn the fundamentals of reactive programming,
    the advantages of reactive programming, and how you can do reactive programming
    in Node.js. We will see various operators available in reactive programming, which
    shorten and streamline our day-to-day development. We will see a combination of
    traditional SOA-based orchestration and reactive processes, and go through various
    situations to see which approach fits where.
  prefs: []
  type: TYPE_NORMAL
