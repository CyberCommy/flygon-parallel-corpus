- en: Ansible Automated Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered how to code playbooks and how to properly populate them with
    some handy modules. Now let's mix everything together and build real-life daily
    infrastructure management situations. This chapter will provide a series of examples
    in which we are going to use Ansible playbooks, with the help of some Linux tools.
    This will help automate daily tasks and other tasks that happen out of hours.
    These playbooks will have multiple tasks that work in sequence to allow you to
    plan your work efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automation of Linux systems and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation of Windows systems and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management of container configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation of network configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation of virtual and cloud infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux infrastructure automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by looking at various use cases that involve Linux administration.
    In this section, we are going to identify a task that is usually done manually
    and try to automate as much of it as possible. An administrator may still be required
    in situations where there are errors or misconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to divide the following use cases into subcategories to better
    identify their role in general. In each case, we will look at several Ansible
    tasks. These will either follow a playbook sequence, be executed if certain conditions
    are met, or be carried out within a loop.
  prefs: []
  type: TYPE_NORMAL
- en: System management automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this subsection, we are going to show some use cases involving system
    administration tasks that can be automated using Ansible playbooks. We will first
    describe the task and the environment in which it will be executed and then we
    will write a well-formatted and named playbook to illustrate how Ansible can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – system update automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This use case is built to update and clean a Linux-based host under the two
    main families: Debian and Red Hat. The task should be able to update the software
    list index, install any available updates, remove unnecessary packages, clean
    the package manager cache, and, finally, restart the hosts if required. This playbook
    can be used on either physical or virtual Linux hosts that are accessible to the
    Ansible management server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this playbook is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This playbook can then be scheduled to be executed using the `crontab` job
    during weekends or late at night when the system is idle. Alternatively, it can
    be scheduled to run during a maintenance period for a system that is active all
    the time. To accommodate redundant hosts, the user can add a batch size and a
    maximum failure percentage parameter to the playbook header, before defining the
    tasks. The following lines of code can be used to enable a level of protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to work on five hosts at a time. In the event of 20% failure
    on the total amount of hosts, the playbook stops.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – creating a new user with all its settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This use case allows you to automate the addition of a new user to your system.
    Basically, we are going to create a new user in all Linux hosts, with the password
    already set up. We are also going to create an SSH key so that it can be accessed
    remotely and add some `sudo` configurations for easier management. This is implemented
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When executed on the right inventory configuration, this playbook should be
    able to replace the hours’ worth of work that is usually involved in accessing
    multiple hosts to configure a single user. It is possible to add additional capabilities
    to any playbook with some tweaking. In this case, we can add any user configuration
    to a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 3 – services (systemd) management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this use case, we will use an Ansible playbook to automatically set up and
    configure some system services on multiple hosts. The following lines of code
    show how to make sure a service is installed and then how to carry out a configuration
    check to make sure it is well-configured. Finally, we start the service and enable
    it to start upon system startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be called by another playbook as part of a provisioning task
    to configure the hosts after they are built. It is also possible to add extra
    functionalities to enable aspects of a bigger Ansible role.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 4 – automated network drive mounting (NFS, SMB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to set up some remote hosts to be NFS and SMB clients. We
    will also configure some drives to connect to automatically using `AutoFS`, which
    was installed in an earlier use case. The following lines of code install the
    dependencies, configure the clients, and then start the services. This playbook
    works with both Debian and Red Hat Linux families:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be personalized, as is the case for any playbook. For example,
    it can be scheduled to run after the playbook that is responsible for setting
    up the shared drive servers.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 5 – automated backup of important documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this use case, we are trying to build a backup solution that does not use
    too much of the bandwidth by archiving everything that needs to be backed up.
    We are basically going to select a folder to be compressed and moved to a secure
    host. The following code makes sure that all the necessary dependencies are installed,
    prepares the backup folder, compresses it, and then sends it. We are going to
    use a module called synchronize, which is basically a wrapper around `rsync`,
    the famous data synchronization tool. It is frequently used to provide a quick
    backup solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be added to a `crontab` job to schedule regular backups to
    a specific folder.
  prefs: []
  type: TYPE_NORMAL
- en: Automation of applications and service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection is not too dissimilar from the previous one, but it focuses
    on the applications and services that are provided by the system to the outside
    world, rather than on those that are related to the host's internal system management.
    Here, we will present some use cases that handle tasks related to applications
    or services automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – setting up a Linux desktop environment with some pre-installed
    tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux administration is not limited to administrating servers. Nowadays, Linux
    GUI users are on the rise, due to the emergence of new scientific research and
    other sophisticated tools that are being developed to work better in a Linux environment.
    Some of these tools do require the Terminal to be used, but there are others that
    require a GUI interface, for example, to show a 3D-rendered molecular structure.
    In this first use case, we are going to make a playbook that ensures that Linux
    hosts have all the required tools for specific uses. This script will install
    a simple Linux graphical interface, Openbox. This script is only compatible with
    Linux systems from the Debian family, but it can be easily converted to support
    the Red Hat family, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following playbook code includes multiple ways of setting up applications
    in a Linux environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be executed after several hosts are deployed, either by calling
    it after the first script has finished or by setting up a watch script to wait
    for a specific host to be available to start this playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – LAMP server setup and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This use case automates a task that is usually carried out by system administrators
    manually. Using the following playbook, we are going to set up a LAMP server,
    which is basically a web server, Apache2; a content manager PHP; and a database
    manager, MySQL server. We will also add some plugins and configuration that adhere
    to best practice standards. The following script only works with the Debian Linux
    family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be personalized by modifying some of the configuration files
    and populating the Apache2 web folder.
  prefs: []
  type: TYPE_NORMAL
- en: Windows infrastructure automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Ansible playbooks, it is just as easy to automate a Windows infrastructure
    as it is to automate a Linux one. In this section, we are going to explore some
    use cases in which we are going to automate some Windows administration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: These use cases are tested on Windows 10\. Extra configurations may be required
    to make them run on Windows 7 or 8.
  prefs: []
  type: TYPE_NORMAL
- en: System management automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we are going to focus on use cases related to the management
    of the Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – system update automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This use case tackles the automation of Windows host systems and some application
    updates. We are going to make updates restricted to what the playbook asks the
    hosts to do by disabling auto update and only updating the permitted categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be scheduled to be executed out of hours or during a scheduled
    maintenance period. The reboot module is used to handle Windows updates that fail
    the update module because they require a system restart. Usually, most updates
    will trigger the return value of `require_reboot` that initiates the restart of
    the machine after an update been installed.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – automated Windows optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module is kind of a cleanup and organization of the system. It is primarily
    aimed at desktop Windows hosts, but some tasks can be used for servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This playbook will start by showing how to remote startup a Windows host that
    has been shut down. We then wait until it has properly powered on to do a disk
    defragmentation. After that, we perform some registry optimization tasks and finish
    by joining the host to a domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Application and services automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will focus on use cases related to Windows applications
    that are available on the Chocolatey repository and others that we would like
    to install traditionally for a variety of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – automating Windows application management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application management on a Windows machine can be a bit messy since Windows
    has always lacked a package manager. Chocolatey is one of the solutions that can
    help fix this issue. The following playbook code makes sure that all the requirements
    for Chocolatey are installed, then checks for updates to all the application that
    are installed by Chocolatey. Finally, it installs the latest version of new applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is advised to use this use case with desktop-based Windows hosts rather than
    for servers. It can be used on servers, however, since most Windows servers now
    have a graphical interface too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following playbook code shows how the preceding actions can be carried
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A more extensive list of applications is available on the Chocolatey packages
    index web page ([https://chocolatey.org/packages](https://chocolatey.org/packages)).
  prefs: []
  type: TYPE_NORMAL
- en: This playbook can be used to set up a generic image for specific users who use
    a number of specific applications on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – setting up an NSclient Nagios client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We always introduce new equipment to a certain environment. One of the tasks
    that is required to set up a new host properly is to link it to the monitoring
    system. For this use case, we are going to show how to set up a Nagios agent in
    a Windows host and configure it from a sample configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This playbook can be applied to a large number of applications that can be installed
    using an MSI file.
  prefs: []
  type: TYPE_NORMAL
- en: Network automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like computers, Ansible can be used to automate the management of network
    devices if they run some kind of remote service, preferably SSH. In this section,
    we are going to explore some use cases on CISCO network devices. We will look
    at various tasks that are time-consuming when done manually.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – automated patching of network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to follow the recommended method for upgrading a network device.
    We need to make sure that we back up both the running and startup configuration.
    We will then start patching one device at a time using the serial option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can create a fact variable called `provider` that has all the credentials
    and information about the device to be used for running commands. Defining the
    variables minimizes the amount of code that can be put in a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – adding a new configuration in network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this use case, we are going to change some of the generic configurations
    on Cisco devices. We are going to change the hostname, create a banner, upgrade
    the SSH to version 2, change the Cisco VTP mode, and configure the DNS server
    and the NTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you use these playbooks during downtime or in a planned
    maintenance window. A configuration might go wrong for one device but work perfectly
    fine with others. The Ansible summary always has a detailed execution status that
    tracks down problematic devices and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Automation of the cloud and container infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is more relevant to resource management than to the hosts themselves.
    Any of the preceding use cases can be used for either bare metal or virtual hosts
    that are located locally or on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The wake-on-LAN modules are less useful in a cloud or virtual environment. It
    is easier to manage virtual hosts and instances using the dedicated modules for
    their controllers.
  prefs: []
  type: TYPE_NORMAL
- en: VMware automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will look at some use cases for host management in a
    VMware environment, including managing the infrastructure around them.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 1 – creating virtual machines from a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This use case shows how to create virtual machines from a predefined template.
    After that, we make sure that all the VMs have been added to the inventory with
    the right parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The use of items in this playbook can be altered by using the predefined variables.
  prefs: []
  type: TYPE_NORMAL
- en: Use case 2 – ESXi hosts and cluster management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now try to carry out some higher-level infrastructure management. We
    will try to create a VMware cluster and add an ESXi host to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These playbooks can replace both the PowerCLI commands that are used to manage
    the VCenter and the manual process of accessing the Windows client or the web
    interface to manage hosts and clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many interesting use cases that any system administrator
    will need to run at some point. Many other tasks can be performed, like we did
    with customized playbooks. But not every script is considered to be a good automation;
    what matters is that the right nodes go from state A to state B with no errors
    and in less time. In [Chapter 6](f4ee28e0-db64-4180-b5fe-416a77c5032e.xhtml), *Ansible
    Coding for Configuration Management*, we are going to learn some advanced script
    optimization techniques based on best practices in order to get the best out of
    Ansible automation.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible documentation: [https://docs.ansible.com/ansible/latest/](https://docs.ansible.com/ansible/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible GitHub project: [https://github.com/ansible](https://github.com/ansible)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chocolatey packages index: [https://chocolatey.org/packages](https://chocolatey.org/packages)'
  prefs: []
  type: TYPE_NORMAL
