- en: Chapter 8. Responsive Go for the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any time developing applications on the Web (or off it, for that
    matter) it won't be long before you find yourself facing the prospect of interacting
    with an API from within a website itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll bridge the gap between the client and the server by allowing
    the browser to work as a conduit for our web service directly via a few technologies
    that includes Google's own AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this book, we created a stopgap client-side interface for our API.
    This existed almost exclusively for the purpose of viewing the details and output
    of our web service through a simple interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's important to keep in mind that it's not only machines that are
    processing APIs, but also client-side interfaces that are initiated directly by
    the users. For this reason, we're going to look at applying our own API in this
    format. We will keep it locked down by domain and enable RESTful and non-RESTful
    attributes that will allow a website to be responsive (not necessarily in the
    mobile sense) and operate exclusively via an API using HTML5 features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Using client-side frameworks like jQuery and AngularJS to dovetail with our
    server-side endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using server-side frameworks to create web interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing our users to log in, view other users, create connections, and post
    messages via a web interface to our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the functionality of our web service, and expanding it to allow direct
    access via an interface that we'll build in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing HTML5 and several JavaScript frameworks to complement our server-side
    frameworks for Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a frontend interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, we'll need to address a couple of issues with the way
    browsers restrict information flow from the client to the server.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to create an example site that works with our API. This should
    ideally be done on localhost on a different port or another machine because you
    will run into additional problems simply by using the `file://` access.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the sake of building an API, it's entirely unnecessary to bundle an interface
    with the API, as we did for a simple demonstration earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this may introduce cruft and confusion as a web service grows. In this
    example, we'll build our interface application separately and run it on port 444\.
    You can choose any available port that you like, assuming that it doesn't interfere
    with our web service (443). Note that on many systems access to ports 1024 and
    below require `root/sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: As is, if we attempt to run the interface on a different port than our secure
    web service, we'll run into cross-origin resource sharing issues. Make sure that
    any endpoint method that we expose for client-side and/or JavaScript consumption
    includes a header for `Access-Control-Allow-Origin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the nature and mechanism of **Access-Control-Allow-Origin**
    at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be tempted to just use the `*` wildcard for this, but this will cause
    a lot of browser issues, particularly with the frontend frameworks that we''ll
    be looking at. As an example, let''s see what happens if we attempt to access
    the `/api/users` endpoint via `GET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a frontend interface](img/1304OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results can be unreliable and some frameworks reject the wildcard entirely.
    Using a wildcard also disables some key features that you may be interested in
    such as cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the following code that we used to attempt to access the web service
    to induce this error. The code is built in Angular, which we''ll look at in more
    detail shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re making a `GET` request to our API endpoint. If this succeeds,
    we''ll add users to our `$scope.users` array that is iterated though an AngularJS
    loop, which is shown in the following code. Without a domain origin allowance
    for our client, this will fail due to cross-origin policies in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the way AngularJS deals with loops by allowing you to specify a JavaScript
    array that is associated directly with a DOM-specific variable or a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will get zero users due to the permissions' issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we have previously addressed this issue in our application by introducing
    a very high-level configuration setting inside our `v1.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that the `Init()` function accepts an array of allowed domains
    to which we can then set the `Access-Control-Allow-Origin` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, if we set a `*` wildcard domain, some browsers and libraries
    will disagree and the wildcard origin precludes the ability to neither set cookies
    nor honor SSL credentials. We can instead specify the domains more explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This permits you to retain the settings of the cookie and SSL certificate that
    are honoring the aspects of a non-wildcard access control header. It does open
    up some security issues that are related to cookies, so you must use this with
    caution.
  prefs: []
  type: TYPE_NORMAL
- en: If this loop is called within any function that can be accessible via a web
    interface, it will prevent the cross-origin issue.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we'll use Twitter's Bootstrap as a basic CSS framework, which allows
    us to quickly replicate a site structure that we might see anywhere online.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our earlier examples opened a login interface that simply passed
    a token to a third party for short-term use to allow the said application to perform
    actions on behalf of our users.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're now attempting to allow our users to interface directly with our
    API (through a browser conduit), we can change the way that operates and allow
    sessions to serve as the authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we were posting login requests directly via JavaScript to the API
    itself, but since we''re now using a full web interface, there''s no reason to
    do that; we can post directly to the web interface itself. This primarily means
    eschewing the `onsubmit="return false"` or `onsubmit="userCreate();"` methods
    and just sending the form data to `/interface/login` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This gives us enough to allow a web interface to create and login to our accounts
    utilizing existing code and still through the API.
  prefs: []
  type: TYPE_NORMAL
- en: Using client-side frameworks with Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we've spent the bulk of this book building a backend API, we've also been
    building a somewhat extensible, basic framework for the server-side.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to access an API from the client side, we're bound by the limitations
    of HTML, CSS, and JavaScript. Alternatively, we can render pages on the server
    side as a consumer and we'll show that in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: However, most modern web applications operate on the client-side, frequently
    in the **single-page application** or **SPA**. This attempts to reduce the number
    of "hard" page requests that a user has to make, which makes a site appear less
    like an application and more like a collection of documents.
  prefs: []
  type: TYPE_NORMAL
- en: The primary way this is done is through asynchronous JavaScript data requests,
    which allow an SPA to *redraw* a page in response to user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, there were two big drawbacks to this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the application state was not preserved, so if a user took an action
    and attempted to reload the page, the application would reset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, JavaScript-based applications fared very poorly in search engine optimization
    because a traditional web scraper would not render the JavaScript applications.
    It will only render the raw HTML applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But recently, some standardization and hacks have helped to mitigate these issues.
  prefs: []
  type: TYPE_NORMAL
- en: On state, SPAs have started utilizing a new feature in HTML5 that enables them
    to modify the address bar and/or history in browsers without requiring reloads,
    often by utilizing inline anchors. You can see this in an URL in Gmail or Twitter,
    which may look something like [https://mail.google.com/mail/u/0/#inbox/1494392317a0def6](https://mail.google.com/mail/u/0/#inbox/1494392317a0def6).
  prefs: []
  type: TYPE_NORMAL
- en: This enables the user to share or bookmark a URL that is built through a JavaScript
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: On SEO, this largely relegated SPAs to admin-type interfaces or areas where
    search engine accessibility was not a key factor. However, as search engines have
    begun parsing JavaScript, the window is open for widespread usage without negatively
    impacting the effects on SEO.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do any frontend work or have viewed the source of any of the most popular
    websites on the planet, then you've encountered jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: According to SimilarTech, jQuery is used by just about 67 million websites.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery evolved as a method of standardizing an API among browsers where consistency
    was once an almost impossible task. Between the brazen self-determination of Microsoft's
    Internet Explorer and browsers that stuck to standards at variable levels, writing
    cross-browser code was once a very complicated matter. In fact, it was not uncommon
    to see this website best viewed with tags because there was no guarantee of functionality
    even with the latest versions of any given browser.
  prefs: []
  type: TYPE_NORMAL
- en: When jQuery took hold (following other similar frameworks such as Prototype,
    Moo Tools, and Dojo), the world of web development finally found a way to cover
    most of the available, modern web browsers with a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming APIs with jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with our API using jQuery couldn't be much simpler. When jQuery first
    started to come to fruition, the notion of AJAX was really taking hold. **AJAX**
    or **Asynchronous JavaScript** and **XML** were the first iteration towards a
    web technology that utilized the `XMLHttpRequest` object to get remote data and
    inject it into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: It's with some degree of irony that Microsoft, which is often considered as
    the greatest offender of web standards, laid the groundwork for `XMLHttpRequest`
    in the Microsoft Exchange Server that lead to AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: Today, of course, XML is rarely a part of the puzzle, as most of what is consumed
    in these types of libraries is JSON. You can still use XML as source data, but
    it's likely that your responses will be more verbose than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Doing a simple `GET` request couldn't be easier as jQuery provides a simple
    shorthand function called `getJSON`, which you can use to get data from our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now iterate through our users and create some HTML data to inject into
    an existing DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `GET` requests will only "get" us so far though. To be fully compliant with
    a RESTful web service, we need to be able to do the `GET`, `POST`, `PUT`, `DELETE`,
    and `OPTIONS` header requests. In fact, the last method will be important to allow
    requests across disparate domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, `getJSON` is a shorthand function for the built-in
    `ajax()` method, which allows more specificity in your requests. For example,
    `$.getJSON(''/api/users'')` translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that we can technically handle all endpoints and methods in our API
    by setting the `HTTP` method directly.
  prefs: []
  type: TYPE_NORMAL
- en: While `XMLHttpRequest` accepts all of these headers, HTML forms (at least through
    HTML 4) only accept the `GET` and `POST` requests. Despite this, it's always a
    good idea to do some cross-browser testing if you're going to be using `PUT`,
    `DELETE`, `OPTIONS`, or `TRACE` requests in client-side JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can download and read the very comprehensive documentation that jQuery
    provides at [http://jquery.com/](http://jquery.com/). There are a few common CDNs
    that allow you to include the library directly and the most noteworthy is Google
    Hosted Libraries, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<script src="img/jquery.min.js"></script>`'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of the library is available at [https://developers.google.com/speed/libraries/devguide#jquery](https://developers.google.com/speed/libraries/devguide#jquery).
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we go beyond the basic toolset that jQuery provides, we'll start delving
    into legitimate, fully formed frameworks. In the last five years these have popped
    up like weeds. Many of these are traditional **Model-View-Controller** (**MVC**)
    systems, some are pure templating systems, and some frameworks work on both the
    client- and server-side, providing a unique push-style interface through websockets.
  prefs: []
  type: TYPE_NORMAL
- en: Like Go, Angular (or AngularJS) is a project maintained by Google and it aims
    to provide full-featured MVC on the client side. Note that over time, Angular
    has moved somewhat away from MVC as a design pattern and it has moved more towards
    MVVM or Model View ViewModel, which is a related pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Angular goes far beyond the basic functionality that jQuery provides. In addition
    to general DOM manipulation, Angular provides true controllers as part of a larger
    app/application as well as for robust unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, Angular makes interfacing with APIs from the client side
    quick, easy, and pleasant. The framework provides a lot more MVC functionality
    that includes the ability to bring in separate templates from `.html`/`template`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actual push notifications are expected by many to become a standard feature
    in HTML5 as the specifications mature.
  prefs: []
  type: TYPE_NORMAL
- en: The W3C had a working draft for the Push API at the time of writing this book.
    You can read more about it at [http://www.w3.org/TR/2014/WD-push-api-20141007/](http://www.w3.org/TR/2014/WD-push-api-20141007/).
  prefs: []
  type: TYPE_NORMAL
- en: For now, workarounds include libraries such as Meteor (which will be discussed
    later) and others that utilize WebSockets in HTML5 to emulate real-time communication
    without being able to work within the confines of other browser-related restraints
    such as dormant processes in inactive tabs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming APIs with Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling an Angular application to work with a REST API is, as with jQuery,
    built directly into the bones of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this call to the `/api/users` endpoint that we just looked at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Except syntax, Angular isn't all that different from jQuery; it also has a method
    that accepts a callback function or a promise as a second parameter. However,
    instead of setting the property for the method similar to jQuery, Angular provides
    short methods for most of the HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can do our `PUT` or `DELETE` requests directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding example, we''re reading header values. To make this
    work across domains, you need to also set a header that enables these headers
    to be shared for other domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since domains are explicitly whitelisted with the `Access-Control-Allow-Origin`
    header, this controls the specific header keys that will be available to clients
    and not domains. In our case, we will set something for the `Last-Modified` and
    `Date` values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about Angular and download it from [https://angularjs.org/](https://angularjs.org/).
    You can also include the library directly from Google Hosted Libraries CDN, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can find the most recent version of the library at [https://developers.google.com/speed/libraries/devguide#angularjs](https://developers.google.com/speed/libraries/devguide#angularjs).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an API-consuming frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of consuming an API, a frontend will be almost entirely free
    of internal logic. After all, the entirety of the application is called via HTML
    into a SPA, so we don't need much beyond a template or two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `header.html` file, which contains the basic HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The line with `application.js` is noteworthy because that's where all the logic
    will exist and utilize one of the frontend frameworks below.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng-view` directive is no more than a placeholder that will be replaced
    with the values within a controller's routing. We'll look at that soon.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're calling AngularJS, jQuery, and React all in this header. These
    are options and you shouldn't necessarily import all of them. In all likelihood,
    this will cause conflicts. Instead, we'll explore how to handle our API with each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, our footer will be primarily closing tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll utilize Go''s `http` template system to generate our basic template.
    The example here shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The heart of this template will not be hardcoded, but instead, it will be built
    by the JavaScript framework of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client-side Angular application for a web service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the `ng-view` directive within an `ng-app` element refers
    to dynamic content that is brought in according to the router that pairs URLs
    with controllers.
  prefs: []
  type: TYPE_NORMAL
- en: More accurately, it joins the pseudo-URL fragments (which we mentioned earlier)
    that are built on top of the `#` anchor tag. Let's first set up the application
    itself by using the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each one of these URLs, when they are accessed, tells Angular to pair a controller
    with a template and put them together within the `ng-view` element. This is what
    allows users to navigate across a site without doing hard page loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is `auth.html`, which is held in our `/views/` directory and allows us
    to log in and perform a user registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript used to control this, as mentioned earlier, is merely a thin
    wrapper around our API. Here''s the `Login()` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is the `Register()` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will like to make a note about the `OPTIONS` header here. This is an important
    part of how the CORS standard operates; essentially, requests are buffered with
    a preflight call using the `OPTIONS` verb that returns information on allowed
    domains, resources, and so on. In this case, we include a catchall called `APIDescribe`
    within `api.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Viewing other users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are logged in, we should be able to surface other users to an authenticated
    user to allow them to initiate a connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can quickly view other users within our `users.html` Angular
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We make a call to our `/api/users` endpoint, which returns a list of users who
    are logged in. You may recall that we put this behind the authentication wall
    in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing other users](img/1304OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's not a lot of flair with this view. This is just a way to see people
    who you may be interested in connecting with or friending in our social application.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering frameworks on the server side in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purposes of building pages, rendering frameworks is largely academic
    and it is similar to having prerendered pages from JavaScript and returning them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, our total code for an API consumer is extraordinarily simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we designate a directory to use for template access, which is the idiomatic
    template in this case. We don't use `views` because we'll use that for our Angular
    templates, and those chunks of HTML are called by `templateUrl`. Let's first define
    our SSL port and add a handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for our endpoint. Now, we''re simply showing the HTML page. This
    can be done simply in any language and still interface with our web service easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These last two lines allow serving files from a directory. Without these, we'll
    get error 404 when we attempt to call JavaScript or HTML include files. Let's
    add our SSLPort and certificates next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the choice of the port and even HTTP or HTTPS is wholly
    optional, given that you allow the resulting domain to be in your list of permitted
    domains within `v1.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a status update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last example allows a user to view their latest status updates and create
    another one. It's slightly different because it calls upon two different API endpoints
    in a single view—the loop for the latest statuses and the ability to post, that
    is, to create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `statuses.html` file looks a little like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call on a `createStatus()` function within the controller to post
    to the `/api/statuses` endpoint. The rest of the code shown here shows a list
    of previous statuses through the ng-repeat directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply displays the text as it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a status update](img/1304OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see a simple demonstration where previous status messages are displayed
    below a form for adding new status messages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've touched on the very basics of developing a simple web service interface
    in Go. Admittedly, this particular version is extremely limited and vulnerable
    to attack, but it shows the basic mechanisms that we can employ to produce usable,
    formalized output that can be ingested by other services.
  prefs: []
  type: TYPE_NORMAL
- en: Having superficially examined some of the big framework players for the Web
    as well as general purpose libraries such as jQuery, you have more than enough
    options to test your API against a web interface and create a single-page application.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have the basic tools at your disposal that are necessary
    to start refining this process and our application as a whole. We'll move forward
    and apply a fuller design to our API as we push forward, as two randomly chosen
    API endpoints will obviously not do much for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll dive in deeper with API planning and design, the nitty-gritty
    of RESTful services, and look at how we can separate our logic from our output.
    We'll briefly touch on some logic/view separation concepts and move toward more
    robust endpoints and methods in [Chapter 3](ch03.html "Chapter 3. Routing and
    Bootstrapping"), *Routing and Bootstrapping*.
  prefs: []
  type: TYPE_NORMAL
