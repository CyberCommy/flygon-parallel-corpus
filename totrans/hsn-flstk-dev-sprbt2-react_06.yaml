- en: Getting Started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the basics of React programming. We will cover the skills
    that are needed to create basic functionalities for the React frontend. In JavaScript,
    we use the ES6 syntax because it provides many features that make coding cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use state and props in components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful ES6 features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What JSX is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle events and forms in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we are using the Windows operating system, but all tools are available
    for Linux and macOS as well.
  prefs: []
  type: TYPE_NORMAL
- en: Basic React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Facebook, React is a JavaScript library for user interfaces. Since
    version 15, React has been developed under the MIT license. React is component-based
    and the components are independent and reusable. The components are basic building
    blocks of React. When you start to develop a user interface with React, it is
    good to start by creating  a mock interfaces. That way, it is easy to identify
    what kind of components you have to create and how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following diagram of the mock, we can see how the user interface can
    be split into components. In this case, there will be an application root component,
    a search bar component, a table component, and a table row component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea445c35-4e5f-4944-8d8c-fc3baaf3eb57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The components can then be arranged in the following tree hierarchy. The important
    thing to understand with React is that the dataflow is going from the parent component
    to the child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97b274c3-687d-47fa-ade1-1949c057daf1.png)'
  prefs: []
  type: TYPE_IMG
- en: React uses the Virtual DOM for selective re-rendering of the user interface,
    which makes it more cost effective. The Virtual DOM is a lightweight copy of the
    DOM and manipulation of the virtual DOM is much faster than the real DOM. After
    the virtual DOM is updated, React compares it to a snapshot that has been taken
    from the virtual DOM before updates have been run. After the comparison, React
    knows which parts have been changed and only these parts are updated to the real
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The React component can be defined by using a JavaScript function or the ES6
    JavaScript class. We will go more deeply into ES6 in the next section. The following
    is a simple component source code that renders the `Hello World` text. The first
    code block uses the JavaScript function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And this one is uses the class to create a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The component that was implemented using the class, contains the required `render()`
    method. This method shows and updates the rendered output of the component. The
    name of the user-defined component should start with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make changes to our component''s `render` method and a add new header
    element into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the app, you get the Adjacent JSX elements must be wrapped in
    an enclosing tag error. To fix this error, we have to wrap the headers in one
    element, such as `div`; since React version 16.2, we can also use `Fragments`,
    which look like empty JSX tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look more carefully at the first React app that we created in the previous
    chapter using `create-react-app`. The source code of the `Index.js` file in the
    root folder looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the file, there are `import` statements that load components
    or assets to our file. For example, the second line imports the `react-dom` package
    from the `node_modules` folder, and the fourth line imports the `App` (the `App.js`
    file in the root folder) component. The `react-dom` package provides DOM-specific
    methods for us. To render the React component to the DOM, we can use the `render` method
    from the `react-dom` package. The first argument is the component that will be
    rendered and the second argument is the element or container where the component
    will be rendered. In this case, the `root` element is `<div id="root"></div>`,
    which can be found in the `index.html` file inside the `public` folder. See the
    following `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following source code shows the `App.js` component from our first React
    app. You can see that `import` applies also to assets, such as images and style
    sheets. At the end of the source code, there is an `export` statement that exports
    the component and it is available to other components by using import. There can
    be only one default export per file, but there can be multiple named exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to import default and named exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the exports looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Basics of ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ES6** (**ECMAScript 2015**) was released in 2015 and it introduced a lot
    of new features. ECMAScript is a standardized scripting language and JavaScript
    is one implementation of it. Here, we will go through the most important features
    released in ES6 that we are going to use in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constants, or immutable variables, can be defined by using a `const` keyword.
    When using the `const` keyword, the variable content cannot be reassigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The scope of `const` is block-scoped, which is the same as `let` have. It means
    that the `const` variable can be used only inside the block where it is defined.
    In practice, the block is the area between curly brackets `{ }`. The following
    sample code shows how the scope works. The second `console.log` statement gives
    an error because we are trying to use the `total` variable outside the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is good to know that if the `const` is an object or array, the content can
    be changed. The following example demonstrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrow functions make function declaration much more compact. The traditional
    way of defining a function in JavaScript is using a `function` keyword. The following
    function gets one argument and just returns the argument value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the ES6 arrow function, the function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one argument, you have to wrap the arguments in parentheses
    and separate arguments with a comma. The following function gets two parameters
    and returns the sum of the parameters. If the function body is an expression,
    you don''t need to use the `return` keyword. The expression is always implicitly
    returned from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function doesn''t have any arguments, the syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Template literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template literals can be used to concatenate strings. The traditional way to
    concatenate strings is to use the plus operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the template literals, the syntax is the following. You have to use backticks
    (`` ``) instead of single or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Classes and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class definition in ES6 is similar to other object oriented languages like
    Java or C#. The keyword for defining the classes is `class`. The class can have
    fields, constructors, and class methods. The following sample code shows the ES6
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inheritance is done with an `extends` keyword. The following sample code shows
    an `Employee` class that inherits a `Person` class. Therefore, it inherits all
    fields from the parent class and can have its own fields that are specific to
    the employee. In the constructor, we first call the parent class constructor by
    using the `super` keyword. That call is required and you will get an error if
    it is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Although ES6 is already quite old but it is still only partially supported
    by modern web browsers. Babel is a JavaScript compiler that is used to compile
    ES6 to an older version that is compatible with all browsers. You can test the
    compiler on the Babel website ([https://babeljs.io](https://babeljs.io)). The
    following screenshot shows the arrow function compilating back to the older JavaScript
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6181624b-547b-4a21-9e8f-a50fc4306e18.png)'
  prefs: []
  type: TYPE_IMG
- en: JSX and styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSX is the syntax extension for JavaScript. It is not mandatory to use JSX
    with React but there are some benefits that make development easier. JSX, for
    example, prevents injection attacks because all values are escaped in the JSX
    before they are rendered. The most useful feature is that you can embed JavaScript
    expressions in the JSX by wrapping it with curly brackets and that will be used
    a lot in the following chapters. In this example, we can access the component
    props when using JSX. The component props are covered in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass a JavaScript expression as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'JSX is compiled to the `React.createElement()` calls by Babel. You can use
    both internal or external styling with the React JSX elements. The following are
    two examples of inline styling. The first one defines the style straight inside
    the `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second example creates the style object first, which is then used in
    the `div` element. The object name should use the camelCase naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the previous section, you can import a style sheet to the React
    component. To reference classes from the external CSS file, you should use a `className`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Props and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Props and state are the input data for rendering the component. Both props and
    state are actually JavaScript objects, and the component is re-rendered when props
    or state are changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The props are immutable, so the component cannot change its props. The props
    are received from the parent component. The component can access the props through
    the `this.props` object. For example, take a look at the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent component can send props to the `Hello` component in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the `Hello` component is rendered, it shows the `Hello World John` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state can be changed inside the component. The initial value of the state
    is given in the component''s constructor. The state can be accessed by using the `this.state`
    object. The scope of the state is the component, so it cannot be used outside
    the component where it is defined. As you can see in the following example, the
    props are passed to the constructor as an argument and the state is initialized
    in the constructor. The value of the state can then be rendered in JSX using curly
    brackets, `{this.state.user}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The state can contain multiple values of different types because it is a JavaScript
    object, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the state is changed using the `setState` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should never update the state by using the equals operator because then
    the React doesn''t re-render the component. The only way to change state is to
    use the `setState` method, which triggers re-rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `setState` method is asynchronous and therefore you cannot be sure when
    the state will be updated. The `setState` method has a callback function that
    is executed when the state has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of the state is always optional and it increases the complexity of
    the component. The components that have only the props are called **stateless**
    components. It will always render the same output when having the same input,
    which means they are really easy to test. The components that have both state
    and props are called **stateful** components. The following is an example of the
    simple stateless component and it is defined using the class. You can also define
    it by using the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are updating the state values that depend on the current state, you
    should pass an update function to the `setState()` method instead of the object.
    A common case to demonstrate this situation is the counter example shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Component life cycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React component has many life cycle methods that you can override. These
    methods are executed at certain phases of the component's life cycle.  The names
    of the life cycle methods are logical and you can almost guess when they are going
    to be executed. The life cycle methods that have a prefix are executed before
    anything happens and the methods with a prefix are executed after something happens.
    Mounting is one phase of the component life cycle and it is the moment when the
    component is created and inserted into the DOM. Two life cycle methods that we
    have already covered are executed when the component mounts: `constructor()` and
    `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: A useful method in the mounting phase is `componentDidMount()`, which is called
    after the component has been mounted. This method is suitable for calling some
    REST APIs to get data, for example. The following sample code gives an example
    of using the `componentDidMount()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example code, we first set the initial value of `this.state.user`
    to `John`. Then, when the component is mounted, we change the value to `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `componentWillMount()` life cycle method that is called before
    the component is mounted, but Facebook recommends not to use that because it might
    be used for internal development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `shouldComponentUpdate()` method is called when the state or props have been
    updated and before the component is rendered. The method gets new props as the
    first argument and a new state as the second argument, and it returns the Boolean
    value. If the returned value is `true`, the component will be re-rendered; otherwise,
    it won''t be re-rendered. This method allows you to avoid useless renders and
    improves performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A `componentWillUnmount()` life cycle method is called before the component
    is removed from the DOM. This is a good point to clean resources, clear timers,
    or cancel requests.
  prefs: []
  type: TYPE_NORMAL
- en: Error boundaries are the components that catch JavaScript errors in their child
    component tree. They should also log these errors and show fallback in the user
    interface. For that, there is a life cycle method called `componentDidCatch()`.
    It works with the React components like the standard JavaScript `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Handling lists with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For list-handling, we introduce a new JavaScript method, `map()`, which is
    handy when you have to manipulate a list. The `map()` method creates a new array
    with the results of calling a function to each element in the original array.
    In the following example, each array element is multiplied by two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `map()` method also has the `index` second argument, which is useful when
    handling lists in React. The list items in React need a unique key that is used
    to detect rows that have been changed, added, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows components that transform the array of integers
    to the array of list items and render these in the `ul` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what the component looks like when it is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c743b210-5e4e-44f1-a93e-36a62b76ffa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the data is an array of objects, it would be nicer to present the data in
    table format. The idea is the same as with the list, but now we just map the array
    to table rows and render these in the table element, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what the component looks like when it is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7cd5a40-a4be-40c7-9976-ec5828bf2dc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling events with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event handling in React is similar to handling DOM element events. The difference,
    compared to HTML event handling, is that event naming uses camelCase in React.
    The following sample code adds an event listener to the button and shows an alert
    message when the button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In React, you cannot return `false` from the event handler to prevent default
    behavior. Instead, you should call the `preventDefault()` method. In the following
    example, we are using a form and we want to prevent form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Handling forms with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form handling is a little bit different with React. An HTML form will navigate
    to the next page when it is submitted. A common case is that we want to invoke
    a JavaScript function that has access to form data after submission and avoid
    navigating to the next page. We already covered how to avoid submit in the previous
    section using `preventDefault()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a minimalistic form with one input field and the submit
    button. To be able to get the value of the input field, we are using the `onChange`
    event handler. When the value of the input field is changed, the new value will
    be saved to state. The `this.setState({text: event.target.value});` statement
    gets the value from the input field and saves it to the state called `text`. Finally,
    we will show the typed value when a user presses the submit button. The following
    is the source code for our first form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of our form component after the Submit button
    has been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9abef54-c2c6-4991-b125-2b7b1b4117b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now is a good time to look at the React Developer Tools, which are handy tools
    for debugging React apps. If we open the React Developer Tools with our React
    form app and type something into the input field, we can see how the value of
    the state changes. We can inspect the current value of  both props and state.
    The following screenshot shows how the state changes when we type something into
    the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d572fac-91b1-4dd8-9b37-fe65bac3f6a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Typically, we have more than one input field in the form. One way to handle
    multiple input fields is to add as many change handlers as we have input fields.
    But this creates a lot of boilerplate code, which we want to avoid. Therefore,
    we add the name attributes to our input fields and we can utilize that in the
    change handler to identify which input field triggers the change handler. The
    name attribute value of the input field must be the same as the name of the state
    where we want to save the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler now looks like the following. If the input field that triggers
    the handler is the first name field, then `event.target.name` is `firstName` and
    the typed value will be saved to a state called `firstName`. In this way, we can
    handle all input fields with the one change handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the full source code of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of our form component after the Submit button
    has been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc15c8f6-50a4-429d-931b-a6f58d46450b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to discover React, which we are going to use to
    build our frontend. Before starting to develop with React, we covered the basics,
    such as the React component, JSX, props, and state. In our frontend development,
    we are using ES6, which makes our code cleaner. We went through the features that
    we need for further development. We also learned how to handle forms and events
    with React.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the React component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are state and props?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does data flow in the React app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between stateless and stateful components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are component life cycle methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should we handle events in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should we handle forms in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has other great resources for learning about React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/getting-started-react](https://www.packtpub.com/web-development/getting-started-react)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/react-16-essentials-second-edition](https://www.packtpub.com/web-development/react-16-essentials-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
