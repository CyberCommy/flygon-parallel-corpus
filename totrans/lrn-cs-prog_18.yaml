- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of the C# language, 1.0, was released in 2002, bundled with
    .NET Framework 1.0 and Visual Studio .NET 2002\. The current version of the language,
    at the time of writing this book, is C# 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The CLI is a specification that describes how a runtime environment can be
    used on different computer platforms without being rewritten for specific architectures.
    The CLI describes four major components: The **Common Type System** (**CTS**),
    the **Common Language Specification** (**CLS**), the **Virtual Execution System**
    (**VES**), and the metadata of a program''s structure and content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CIL is a platform-neutral intermediate language that represents the intermediate
    language binary instruction set defined by the CLI. When you compile your program's
    source code, the compiler translates it into the CIL bytecode and produces a CLI
    assembly. When the CLI assembly is executed, the bytecode is passed through the
    Just-In-Time compiler to generate native code, which is then executed by the computer's
    processor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To view the content of an assembly you must use a disassembler. Examples of
    disassemblers are ildasm.exe, distributed with .NET Framework, or ILSpy, an open
    source .NET assembly browser and decompiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Common Language Runtime is. NET Framework's implementation of the VES. The
    CLR provides services such as memory management, type safety, garbage collection,
    exception handling, thread management, and others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The BCL is a component of the standard libraries that provides types to represent
    the CLI built-in types, simple file access, custom attributes, string handling,
    formatting, collections, streams, and others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current major .NET frameworks are .NET Framework, .NET Core, and Xamarin.
    Because Microsoft plans to make .NET Core the one framework to use for building
    applications for desktop, server, web, cloud, and mobile; .NET Framework is put
    on maintenance mode and will only include security updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assemblies are the basic unit for deployment, versioning, and security. They
    come in two forms: executables (`.exe`) and dynamic-link libraries (`.dll`). An
    assembly is a collection of types, resources, and meta-information that forms
    a logical unit of functionality. The identity of an assembly is composed of the
    name, version, culture, and a public key token.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GAC is a machine-wide code cache that enables the sharing of assemblies
    between applications. Its default location is `%windir%\Microsoft.NET\assembly`.
    The Runtime Package Store is the equivalent for .NET Core applications. It enables
    faster deployment and lower disk space requirements. Typically, this store is
    available at `/usr/local/share/dotnet/store` on macOS and Linux and `C:/Program
    Files/dotnet/store` on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The minimum a C# program must contain in order to compile and execute is a class
    that contains a static method called `Main()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in integral types in C# are `byte`, `sbyte`, `ushort`, `short`, `uint`,
    `int`, `ulong`, and `long`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `float` and `double` types represent numbers using the inverse powers of
    2 for the fractional part. Therefore, they cannot represent exactly numbers such
    as 1.23 or 19.99, but only an approximation of them. Although `double` has 15
    digits of precision, compared to `float,` which has only 7; precision loss accumulates
    when performing repeated calculations. The `decimal` type uses a decimal representation
    of real numbers, which is much slower to compute, but provides better precision.
    The `decimal` type has 28 digits of precision and is suitable for categories of
    applications, such as financial applications, where this is key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings can be concatenated using the `+` operator. Apart from concatenation,
    you can compose strings using the `String.Format()` static method, or with string
    interpolation, which is a syntactic shortcut for this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some characters have a special meaning within a string. These are called escape
    sequences and are prefixed with a backlash (`\`). Examples include single quotes
    (`\'`), double quotes (`\"`), newline characters (`\n`), and backslashes (`\\`).
    Verbatim strings are strings that are prefixed with the `@` token. For verbatim
    strings, the compiler does not interpret escape sequences. This makes it easier
    to write multi-line texts or file paths, for instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implicitly typed variables are declared using the `var` keyword instead of an
    actual type and must be initialized during declaration. The compiler infers the
    actual type from the value or expression used for their initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Value types and reference types are the two main categories of types in C# and
    .NET. A variable of a value type stores the value directly. A variable of a reference
    type stores a reference to (the address of) a memory location containing the actual
    object. Value types have value semantics (in simple terms, when you copy an object,
    its value is copied), and reference types have value semantics (when you copy
    an object, its reference is copied). Typically, value types are stored on a stack
    and reference types on the heap, but this is an implementation detail and not
    a characteristic of the types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boxing is the process of storing a value type inside an `object`, and unboxing
    is the opposite operation of converting the value of an `object` to a value type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A nullable type is an instance of `System.Nullable<T>`, a generic value type
    that can represent the values of an underlying `T` type that can only be a value
    type, as well as an additional null value. A nullable integer variable can be
    declared either as `Nullable<int>` or `int?`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are three types of arrays in C#. The first type is one-dimensional arrays,
    which are arrays of a single dimension. An example is `int[6]`, which is an array
    of 6 integers. The second type is multi-dimensional arrays, which are arrays of
    two or more dimensions, up to a maximum of 32\. An example is `int[2,3]`, which
    is an array of integers with 2 lines and 3 columns. The third type is jagged arrays,
    which are arrays of arrays. A jagged array is a one-dimensional array whose elements
    are other arrays, and each can be of another dimension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system-defined type conversions are implicit conversion (such as from `int`
    to `double`), and explicit conversion (such as from `double` to `int`). Explicit
    type conversions are also called casts and are necessary when conversion between
    two types bears the risk of losing information. User-defined conversions are possible
    by defining implicit or explicit operators for a certain type or with helper classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The selection statements in the C# language are `if` and `switch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `default` case of a `switch` statement can appear anywhere on the list.
    It is always evaluated last after all the case labels have been evaluated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `for` loop allows us to execute a block of code as long as a Boolean expression
    evaluates to true. A `foreach` loop allows us to iterate through the elements
    of a collection that implements the `IEnumerable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `while` loop is an entry controlled loop. That means it executes a block
    of statements as long as a specified Boolean expression evaluates to true. The
    expression is checked before the block is executed. The `do-while` loop is an
    exit-controlled loop. This means the Boolean expression will be checked at the
    end of the loop. This ensures that the `do-while` loop will always be executed
    at least once, even if the condition evaluates to false in the first iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To return from a function, you can use `return`, `yield`, or `throw`. The first
    two denote a normal return. The `throw` statement represents a return due to an
    erroneous situation in the execution flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A `break` statement can be used to exit from a `switch` case or to terminate
    the execution of a loop. It works for all loops: `for`, `while`, `do-while`, and
    `foreach`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It indicates that the method, operator, or `get` accessor where it appears preceding
    a `return` or `break` statement is an iterator. The sequence returned from an
    iterator method can be consumed using a `foreach` statement. The `yield` statement
    makes it possible to return values as they are produced and consume them as they
    are available, which is especially useful in an asynchronous context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can catch all the exceptions from a function call either with `catch(Exception)`,
    in which case you have access to information about the exception, or with a simple
    `catch` statement (without specifying an exception type), in which case you do
    not get any information about the exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `finally` block contains code that will execute after the `try` section.
    This happens regardless of whether the execution resumed normally or the control
    left the `try` block because of a `break`, `continue`, `goto`, or `return` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base class for all the exception types in .NET is the `System.Exception`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a template or a blueprint that specifies the form of an object. It
    contains both data and code that operates on that data. An object is an instance
    of a class. A class is introduced with the `class` keyword and defines a reference
    type. A structure is introduced with the `struct` keyword and defines a value
    type. Unlike classes, structures do not support inheritance and cannot have an
    explicit default constructor, and fields cannot be initialized during declaration
    unless they are declared `const` or `static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A read-only field is a field defined with the `readonly` specifier. Such a field
    can only be initialized in a constructor and its value cannot be changed later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expression body definitions are an alternative syntax, typically for methods
    and properties, that simply consist of evaluating an expression and perhaps returning
    the result of the evaluation. These have the form `member => expression`. They
    are supported for all class members, not just methods, but also fields, properties,
    indexers, constructors, and finalizers. The type of the result value of the expression
    evaluation must match the return type of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A default constructor is a constructor of a class that does not have any parameters.
    On the other hand, a static constructor is a constructor defined with the `static`
    keyword that has no parameters or access modifiers and cannot be called by the
    user. A static constructor is called by the CLR automatically in a static class
    when the first static member of the class is accessed for the first time, or in
    a non-static class when the class is instantiated for the first time. Static constructors
    are useful for initializing static fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto-implemented properties are properties for which the compiler will provide
    a private field and the implementation of the `get` and `set` accessors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An indexer is a class member that allows an object to be indexed like an array.
    An indexer defines a `get` and `set` accessor like properties do. An indexer does
    not have an explicit name. It is created by using the `this` keyword. An indexer
    has one or more parameters that can be of any type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A static class is a class declared with the `static` keyword. It can only contain
    static members and cannot be instantiated. Static class members are accessed using
    the class name and not through an object. A static class is basically the same
    as a non-static class with a private constructor and all members are declared
    as `static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The available parameter specifiers are `ref`, `out`, and `in`. The `ref` specifier
    modifies a parameter so that it becomes an alias for an argument, which must be
    a variable. It allows us to create a call-by-reference mechanism, rather than
    the implicit call-by-value one. The `in` specifier is similar in that it causes
    the argument to be passed by reference, but it does not allow the function to
    modify it. It is basically identical to `readonly ref`. The `out` keyword also
    defines a call-by-reference mechanism, but it requires a function to initialize
    a parameter before the function returns. It guarantees that a variable is assigned
    a value during the specified function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method with a variable number of arguments must have a parameter that is a
    single-dimensional array preceded by the `params` keyword. This does not have
    to be the only parameter of the function, but it must be the last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An enumeration is a set of named integral constants. You must use the `enum`
    keyword to declare an enumeration. An enumeration is a value type. Enumerations
    are useful when we want to use a limited number of integral values for some particular
    purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is a paradigm that allows us to write a program
    around objects. Its core principles are abstraction, encapsulation, inheritance,
    and polymorphism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation allows us to hide the data inside a class from the outside world.
    Encapsulation is important because it reduces the dependencies between different
    components by defining minimal public interfaces for them. It also increases code
    reusability and security and makes code easier to unit test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance is a mechanism through which a class can inherit the properties
    and functionalities of another class. C# supports single inheritance but only
    for reference types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A virtual method is a method that has an implementation in a base class but
    can be overridden in derived classes, which is helpful for changing or extending
    implementation details. The implementation in the base class is defined with the
    `virtual` keyword. The implementation in a derived class is called an overridden
    method and is defined with the `override` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can prevent a virtual member from being overridden in a derived class by
    declaring it with the `sealed` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An abstract class cannot be instantiated, which means we cannot create the object
    of an abstract class. An abstract class is declared using the `abstract` keyword.
    They can have both abstract and non-abstract members. An abstract member cannot
    be private and cannot have an implementation. An abstract class must provide an
    implementation for all the members of all the interfaces it implements (if any).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface defines a contract that is supported by all the types that implement
    the interface. An interface is a type introduced with the `interface` keyword
    and contains a set of members that must be implemented by any class or struct
    that implements the interface. Typically, an interface contains only declarations
    of members, but not implementations. Beginning with C# 8, interfaces can contain
    default methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two types of polymorphism: compile-time polymorphism, represented
    by method overloading, and runtime polymorphism. Runtime polymorphism has two
    aspects. On one hand, objects of derived classes can be seamlessly used as objects
    of base classes in arrays or other types of collections, method parameters, and
    other places. On the other hand, classes can define virtual methods that can be
    overridden in derived classes. At runtime, the CLR will invoke the implementation
    of the virtual member corresponding to the runtime type of the object. An object''s
    declared type and its runtime type differ when objects of derived classes are
    used in places of objects of base classes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overloaded methods are methods with the same name but with parameters of different
    types or different numbers of parameters. The return type is not considered for
    method overloading. Operators can also be overloaded. A type can provide a custom
    implementation for an overloadable operator when one or both operands are of that
    type. The `operator` keyword is used to declare an operator. Such methods must
    be `public` and `static`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The SOLID principles are the following: **Single responsibility principle (S)**,
    **Open-close principle (O)**, **Liskov substitution principle (L)**, **Interface
    segregation principle (I)**, and **Dependency injection principle (D)**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are types parametrized with other types. Generics provide reusability,
    promote type safety, and can provide better performance (by avoiding the need
    for boxing and unboxing for value types).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type used for parameterizing a generic type or method is called a type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic classes are defined in the same way as non-generic classes except for
    a list of one or more type parameters, specified within angle brackets (such as
    `<T>`) after the class name. The same is true for generic methods; the type parameters
    are specified after the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes can be derived from generic types. Structures do not support explicit
    inheritance, but they can implement any number of generic interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A constructed type is a type that is constructed from a generic type by replacing
    the type parameters with actual types. For instance, for a `Shape<T>` generic
    type, the `Shape<int>` is a constructed type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A covariant type parameter is a type parameter declared with the `out` keyword.
    Such a type parameter allows an interface method to have a return type that is
    more derived than the specified type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A contravariant type parameter is a type parameter declared with the `in` keyword.
    Such a type parameter allows an interface method to have a parameter that is less
    derived than the specified type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type parameter constraints are restrictions specified for type parameters that
    inform the compiler about what kind of capabilities the type parameters must have.
    Applying a constraint limits the types that can be used for constructing a type
    from a generic one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `new()` type constraint specifies that a type must provide a public default
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type parameter constraint introduced in C# 8 is `notnull`. It can only be
    used in a nullable context, otherwise the compiler generates a warning. It specifies
    that the type parameter must be a non-nullable type. It can be a non-nullable
    reference type (in C#8) or a non-nullable value type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BCL namespace containing the generic collections is `System.Collections.Generic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base interface for all the other interfaces that define functionalities
    for generic collections is `IEnumerable<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic collections are preferred over non-generic ones because they offer the
    benefit of type safety, have better performance for value types (because they
    avoid boxing and unboxing), and, in some cases, they provide functionalities not
    available in the non-generic collections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `List<T>` generic class represents a collection of elements that can be
    accessed by their index. `List<T>` is very similar to arrays, except that the
    size of the collection is not fixed but is variable and it can grow or decrease
    as elements are added or removed. You add elements with `Add()`, `AddRange()`,
    `Insert()`, and `InsertRange()`. You can remove elements with `Remove()`, `RemoveAt()`,
    `RemoveRange()`, `RemoveAll()`, and `Clear()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Stack<T>` generic class represents a collection with last-in, first-out
    semantics. Elements are added to the top with the `Push()` method and removed
    from the top with the `Pop()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Queue<T>` generic class represents a collection with first-in, first-out
    semantics. The `Dequeue()` method removes and returns the item from the front
    of the queue. The `Peek()` method returns the item from the front of the queue
    without removing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `LinkedList<T>` generic class represents a double linked list. Its elements
    are of the `LinkedListNode<T>` type. To add elements to the linked list you can
    use the `AddFirst()`, `AddLast()`, `AddAfter()`, and `AddBefore()` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Dictionary<TKey, TValue>` generic class represents a collection of key-value
    pairs that allows fast lookup based on a key. The elements of this dictionary
    class are of the `KeyValuePair<TKey, TValue>` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `HashSet<T>` generic class represents a set of distinct items that can be
    in any order but are stored contiguously. A hash set is logically similar to a
    dictionary where the values are also the keys. However, unlike `Dictionary<TKey,
    TValue>`, `HashSet<T>` is a non-associative container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is a class that implements the producer-consumer pattern
    defined by the `IProducerConsumerCollection<T>` interface. It is actually a simple
    wrapper over the `IProducerConsumerCollection<T>` interface and does not have
    internal underlying storage but must be provided with one (a collection that implements
    the `IProducerConsumerCollection<T>` interface). If no implementation is provided,
    it uses the `ConcurrentQueue<T>` class by default. It is suitable for scenarios
    when bounding and blocking are necessary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A callback is a function (or more generally, any executable code) that is passed
    as a parameter to another function in order to be called immediately (synchronous
    callbacks) or at a later time (asynchronous callbacks). A delegate is a strongly
    typed callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A delegate is defined using the `delegate` keyword. The declaration looks like
    a function signature, but the compiler actually introduces a class that can hold
    references to methods whose signatures match the signature of the delegate. Events
    are variables of a delegate type declared with the `event` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two kinds of tuples in C#: reference tuples, represented by the `System.Tuple`
    class, and value tuples, represented by the `System.ValueTuple` structure. The
    reference tuples can only hold up to eight elements, while the latter can hold
    a sequence of any number of elements, although at least two are required. Value
    tuples may have compile-type named fields, and have a simpler but richer syntax
    for creating, assigning, deconstructing, and comparing values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Named tuples are value tuples that have names for their fields. These names
    are synonyms for the fields `Item1`, `Item2`, and so on, but are only available
    at source-code level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pattern matching is the process of checking whether a value has a particular
    shape as well as extracting information out of the value when the matching is
    successful. It can be used with `is` and `switch` expressions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A null value does not match a type pattern, regardless of the type of the variable.
    A `switch` case label with a pattern matching for null can be added in a `switch`
    expression with type pattern matching to specifically handle null values. When
    using the `var` pattern, a null value always matches. Therefore, when using the
    `var` pattern, you must add an explicit null check because the value may be null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The .NET class that provides support for working with regular expressions is
    the `Regex` class from the `System.Text.RegularExpressions` namespace. By default,
    it uses the UTF-8 encoding for the string to match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Match()` method checks an input string for substrings that match a regular
    expression and returns the first match. The `Matches()` method does the same search
    but returns all the matches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extension methods are methods that extend the functionalities of a type without
    changing its source code. They are useful because they allow extensions without
    changing the implementation, creating a derived type, or recompiling the code,
    in general.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extension methods are defined as static methods of a static, non-nested, non-generic
    class and their first parameter is of the type they extend, preceded by the `this`
    keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stack is a relatively small segment of memory allocated by the compiler
    that keeps track of the memory necessary for running the application. The stack
    hasLIFO semantics and grows and shrinks as the program execution is invoking functions
    or returning from functions. The heap, on the other hand, is a large segment of
    memory that the program may use to allocate memory at runtime, and which, in .NET,
    is managed by the CLR. Objects of value types are, typically, allocated on the
    stack, and objects of reference types are allocated on the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The managed heap has three memory segments called generations. They are named
    generation 0, 1, and 2\. Generation 0 contains small, and usually short-lived,
    objects such as local variables or objects instantiated for the lifetime of a
    function call. Generation 1 contains small objects that have survived a garbage
    collection of memory from generation 0\. Generation 2 contains long-lived small
    objects that have survived a garbage collection of memory from generation 1 and
    large objects (which are always allocated on this segment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection has three phases. First, the garbage collector builds a graph
    of all live objects in order to figure out what is still in use and what may be
    deleted. Second, references to objects that will be compacted are updated. Third,
    the dead objects are removed, and the surviving objects are compacted. Typically,
    the large object heap containing large objects is not compacted because moving
    large chunks of data incurs performance costs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finalizer is a special method of a class (has the same name as the class but
    prefixed with `~`) that should dispose of unmanaged resources that the class has
    ownership of. This method is called by the garbage collector when the object is
    collected. This process is non-deterministic, which is the key difference between
    finalization and disposal. The latter is a deterministic process that occurs during
    the explicit invocation of the `Dispose()` method (for classes that implement
    the `IDisposable` interface).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GC.SuppressFinalize()` method requests the CRL not to invoke the finalizer
    of the specified object. This is typically called when implementing the `IDisposable`
    interface, so that unmanaged resources are not disposed of twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IDisposable` is an interface with a single method called `Dispose()` that
    defines a pattern for the deterministic disposal of objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `using` statement represents short-hand syntax for the deterministic disposal
    of objects of types that implement the `IDisposable` interface. The `using` statement
    introduces a scope for the variable defined in the statement and ensures the object
    is properly disposed of before the scope is exited. The actual disposal details
    depend on whether the resource is a value type, a nullable value type, a reference
    type, or a dynamic type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function from a native DLL can be invoked in C# using Platform Invocation
    Services, or P/Invoke. To do so, you must define a `static` `extern` method that
    matches the signature of the native function (using equivalent managed types for
    its parameters). This managed function must be decorated with the `DllImport`
    attribute, which defines the necessary information for the runtime to call the
    native function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsafe code is code for which the CLR cannot verify its safety. Unsafe code
    enables the use of pointer types and supports pointer arithmetic. Unsafe code
    is not necessarily dangerous, but it is your entire responsibility to ensure that
    you do not introduce pointer errors or security risks. The typical scenarios for
    using unsafe code are calling functions exported from a native DLL or COM server
    that require pointer types as parameters, and optimizing some algorithms where
    performance is critical.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsafe code is defined with the `unsafe` keyword, which can be applied to types
    (classes, structures, interfaces, and delegates), type members (methods, fields,
    properties, events, indexers, operators, instance constructors, and static constructors),
    and statement blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main characteristics of functional programming are immutability (objects
    have states that do not change) and side-effect free functions (functions do not
    modify values or states outside their local scope). Advantages of functional programming
    include the following: first, the code is easier to understand and maintain because
    functions do not change states and only depend on the arguments they receive.
    Second, the code is easier to test for the same reason. Third, it is simpler and
    more efficient to implement concurrency because data is immutable and functions
    don''t have side effects, which avoids data races.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A higher-order function is a function that takes one or more functions as arguments,
    returns a function, or both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C# provides the ability to pass functions as arguments, return functions from
    functions, assign functions to variables, store them in data structures, define
    anonymous functions, nest functions, and test references to functions for equality.
    All these characteristics make C# a language that is said to treat functions as
    first-class citizens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda expressions are a convenient way to write anonymous functions. This is
    a block of code, either an expression or one or more statements that behave like
    a function and can be assigned to a delegate. As a result, a lambda expression
    can be passed as an argument to a function or returned from a function. They are
    a convenient way to write LINQ queries, pass functions to higher-order functions
    (including code that should be executed asynchronously by `Task.Run()`), and create
    expression trees. A lambda expression has two parts separated by the lambda declaration
    operator, `=>`. The left part is the list of parameters, and the right part is
    an expression or a statement. An example of a lambda expression is `n => n%2==1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The rules that apply to variable scope in lambda expressions are as follows:
    first, the variables that are introduced in a lambda expression are not visible
    outside the lambda. Second, a lambda cannot capture `in`, `ref`, or `out` parameters
    from the enclosing method. Third, variables that are captured by a lambda are
    not garbage collected until the delegate that the lambda is assigned to is garbage
    collected, even if they would otherwise go out of scope. Fourth, and last, a return
    statement of a lambda expression refers solely to the anonymous method that the
    lambda represents and does not cause the enclosing method to return.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LINQ is a set of technologies that enable developers to query a multitude of
    data sources in a consistent manner. The LINQ standard query operators are a set
    of extension methods that operate on sequences that implement either `IEnumerable<T>`
    or `IQueryable<T>`. LINQ query syntax is basically syntactic sugar for the standard
    query operators. The compiler transforms queries written in query syntax into
    queries using the standard query operators. Query syntax is simpler and easier
    to read than the standard query operators, but they are semantically equivalent.
    However, not all the standard query operators have an equivalent in query syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Select()` method projects each element of a sequence into a new form. This
    requires a selector, which is a transformation function, to produce a new value
    for each element of the collection. However, when the elements of the collection
    are themselves collections, it is often necessary to flatten them to a single
    collection. This is what the `SelectMany()` method is doing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partial function application is the process of taking a function with *N* parameters
    and one argument and returning another function with *N-1* parameters after fixing
    the argument into one of the function's parameters. This technique is the opposite
    of currying, which is the process of taking a function with *N* arguments and
    decomposing it into *N* functions that take one argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A monoid is an algebraic structure with a single associative binary operation
    and an identity element. Any C# type that has those two elements is a monoid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A monad is a container that encapsulates some functionality on top of the value
    that it wraps. A monad has two operations: the first one that transforms a value,
    `v,` into a container that wraps it (`v -> C(v)`). In functional programming,
    this function is called a return. The second one that flattens two containers
    into a single container (`C(C(v)) -> C(v)`). In functional programming, this is
    called a bind. An example of a monad is `IEnumerable<T>` with the LINQ query operator
    `SelectMany()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit of deployment in .NET is the assembly. An assembly is a file (either
    an executable or a dynamic-link library) that contains the MSIL code, as well
    as metadata about the content of the assembly, and, optionally, resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reflection is the process of runtime type discovery and the ability to make
    changes to them. This means that we can retrieve information about types, their
    members, and their attributes at runtime. Reflection makes it possible to easily
    build extensible applications; to execute types and members that are private or
    have other access levels that makes them inaccessible otherwise, which is useful
    for testing; to modify existing types or creating entirely new types at runtime
    and execute code using them; and, in general, to change a system behavior at runtime,
    usually with the use of attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type that provides meta-information about types is `System.Type`. An instance
    of this type can be created with the `GetType()` method, the `Type.GetType()`
    static method, or with the C# `typeof` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A shared assembly is intended to be used by several applications and is usually
    located under the **Global Assembly Cache (GAC)**, a system repository for assemblies.
    A private assembly is intended to be used by a single application and is stored
    in the application directory or one of its sub-directories. Shared assemblies
    must be strongly named and enforce version constraints; these requirements are
    not necessary for private assemblies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In .NET, an assembly can be loaded in one of the following contexts: the load
    context (which contains assemblies loaded from the GAC, the app directory, or
    its subdirectories), the load-from context (which contains assemblies loaded from
    other paths than the previously mentioned), the reflection-only context (which
    contains assemblies loaded for reflection purposes only), or no context at all
    (such as when an assembly is loaded from an array of bytes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Early binding is the process of creating an assembly dependency (reference)
    during compile time. This offers the compiler full access to the types available
    in the assembly. Late binding is the process of loading assemblies at runtime,
    in which case the compiler has no access to the content of the assembly. However,
    this is important for building extensible applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Dynamic Language Runtime is a component of the .NET platform that defines
    a runtime environment that adds a set of services on top of the CLR in order to
    enable dynamic languages to run on the CLR and to add dynamic features to statically
    typed languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dynamic` type is a static type, meaning variables of this type are assigned
    the `dynamic` type at compile time. However, they bypass static type checking.
    That means the actual type of the object is only known at runtime and the compiler
    cannot know and cannot enforce any checks on operations performed on objects of
    this type. You can invoke any methods with any parameters and the compiler will
    not check and complain; however, if the operation is not valid, an exception will
    be thrown at runtime. The `dynamic` type is often used to simplify the consumption
    of COM objects when an interop assembly is not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attributes are types that derive from the `System.Attribute` abstract class
    and provide meta-information about assemblies, types, and members. This meta-information
    is consumed by the compiler, the CLR, or tools that use reflection services to
    read them. Attributes are specified in square brackets, such as in `[SerializableAttribute]`.
    The naming convention for attributes is that the type names are always suffixed
    with the word `Attribute`. The C# language provides a syntactic shortcut that
    allows specifying the name of the attribute without the suffix `Attribute`, such
    as in `[Serializable]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create user-defined attributes you must derive from the `System.Attribute`
    type and follow the naming convention of suffixing the type with the word `Attribute`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to execute some long-running, CPU-intensive code, manually creating
    a dedicated thread is the preferred choice. Another option is to create a Task
    with `TaskCreationOptions.LongRunning` or, in most advanced scenarios, to write
    a custom task scheduler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most performant synchronization techniques are those not using kernel objects
    but user-mode objects. In order to atomically write both a file and some value
    in memory, the Critical Section is the most appropriate technique and is available
    through the `lock` keyword of the C# language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Task.Delay` API is the most appropriate delay because it *schedules* the
    code in the continuation after the specified number of milliseconds, letting the
    thread be reused in the meantime. Conversely, the operating system `Sleep` API
    is exposed in .NET as `Thread.Sleep`, which suspends the thread execution for
    the given number of milliseconds, but it makes the thread unavailable from being
    reused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Task library offers the `WaitHandle.WaitAny` and `WaitHandle.WaitAll` methods,
    which respectively call the continuation code as soon as *any* or *all* of the
    operations have completed. The task results can be accessed as soon as the returned
    tasks have completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TaskCompletionSource` is a class used to create and control the `Task`.
    It can be used to transform any asynchronous behavior, such as a CLR event, in
    a Task-based operation. The client code, instead of subscribing to the event,
    can therefore await the task obtained from the `TaskCompletionSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Task` library provides the pre-built `Task.CompletedTask` to return an
    empty `Task`, and the methods `Task.FromResult`, `Task.FromCanceled` and `Task.FromException`
    to create tasks that either return a result, report a cancellation, or throw an
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Long-running tasks may be created by specifying `TaskCreationOptions.LongRunning`
    in the `Task` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The need to use `Control.Invoke` (or `Dispatcher.Invoke` in WPF) can be verified
    with `Control.InvokeRequired` (or `Dispatcher.CheckAccess()` in WPF) and depends
    on whether the library used to access the resource already marshaled the result
    in the main thread. If the library already embraced the tasks and the library
    author did not call `Task.ConfigureAwait(false)`, you can consume the result directly
    because the continuation executed after the `await` keyword is invoked in the
    main thread thanks to the synchronization context provided by the UI framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ConfigureAwait` method is useful to avoid useless marshaling operations
    that would occur when a synchronization context is in use in the process. This
    is normally created by UI frameworks and ASP.NET applications. The primary users
    of `ConfigureAwait` are library developers who don't need to access the application
    objects that can only be used from the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to verify whether the asynchronous operation has completed in the main
    thread first (for example, by using `Control.InvokeRequired` in Windows Forms
    or `Dispatcher.CheckAccess()` in WPF). If it completed in a different thread,
    you need to access the UI by means of `Control.Invoke` or `Dispatcher.Invoke`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important classes in the `System.IO` namespace for working with system
    objects are `Path` for paths, `File` and `FileInfo` for files, and `Directory`
    and `DirectoryInfo` for directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preferred way of concatenating paths is by using the `Path.Combine()` static
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The path of the temporary folder of the current user can be retrieved with the
    `Path.GetTempPath()` static method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `File` and `FileInfo` classes provide similar functionalities but `File`
    is a static class and `FileInfo` is a non-static class. Likewise, `Directory`
    is a static class and `DirectoryInfo` is a non-static class, although their functionalities
    are similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create directories, you can use the `Create()` and `CreateSubdirectory()`
    methods. The former creates a directory when its direct parent exists. The latter
    creates a subdirectory and all the other subdirectories in a hierarchy up to the
    root, if necessary. To enumerate directories, use the `EnumerateDirectories()`
    method, which retrieves an enumerable collection of directories that can be enumerated
    before the whole collection is returned. There are multiple overloads for the
    various search options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three categories of streams in .NET are backing stores (streams that represent
    a source or destination of a sequence of bytes), decorators (streams that read
    or write data from or to another stream, transforming it in some way), and adapters
    (not actually streams, but wrappers that help us work with sources of data at
    a higher level than bytes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The base class for streams in .NET is the `System.IO.Stream` class. This is
    an abstract class that provides methods and properties for reading from and writing
    to a stream. Many of these are abstract and are implemented in derived classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, both `BinaryReader` and `BinaryWriter` handle strings using the
    UTF-8 encoding. However, they both have overloaded constructors that allow the
    specifying of another encoding using the `System.Text.Encoding` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `XmlSerializer` class, from the `System.Xml.Serialization` namespace, can
    be used to serialize and deserialize data. `XmlSerializer` works by serializing
    to XML all the public properties and fields of a type. It uses some default settings,
    such as types becoming nodes, and properties and fields becoming elements. The
    name of a type, property, or field becomes the name of the node or element and
    the value of a field, or property, its text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON serializer shipped with .NET Core is called `System.Text.Json`. For
    .NET Framework and .NET Standard projects, it is available as a NuGet package,
    with the same name. You can use the `JsonSerializer.Serialize()` static method
    to serialize data and the `JsonSerializer.Deserialize<T>()` static method to deserialize
    data. You can use specific attributes to control the serialization process. On
    the other hand, if you want more control over what is written or read, you can
    use the `Utf8JsonWriter` and `Utf8JsonReader` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code that may potentially throw an exception must be put inside a `try`
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `catch` block, you may primarily want to try to recover the error.
    The recovery strategy may be very different and may vary from reporting a friendly
    error to the user to repeating the operation with different parameters. Logging
    is another typical operation done in the `catch` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exception type specified in the `catch` block captures exceptions matching
    the same type or any derived types. For this reason, the ones lower in the hierarchy
    must be specified last. In any case, the C# compiler will generate an error whenever
    the order is not correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By specifying the variable name in the `catch` statement, you get access to
    the exception object. It provides important information such as the message and
    other information that is very precious when logging an error. The exception object
    can also be used as the inner exception parameter when creating a new, more specific
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After examining the exception object, you may realize that you can't do anything
    to recover the operation. In this case, it is more appropriate to let the exception
    continue bouncing to the callers. This can be done with the use of the parameterless
    `throw` statement, or by creating and throwing a new exception by passing the
    exception object in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `finally` block is used to declare a block of code that must be executed
    regardless of whether the code specified in the `try` block failed or completed
    successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can specify a `finally` block without `catch` whenever you don't need to
    be notified about the failure of the code inside the `try` block. The `finally`
    code will be executed in any case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First-chance exceptions represent the exceptions at a very early stage, as soon
    as they are thrown and before jumping to their handlers, if any. The debugger
    may stop at them, giving a more accurate indication about a potential bug.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Visual Studio debugger allows us to select the first-chance exceptions we
    want to stop at. This can be done using the **Exception Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UnhandledException` event is fired right before the application is going
    to crash. This event can be used to provide better advice to the user, to log
    the error, or even to automatically restart the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By enabling the C# 8 nullable reference types feature and decorating the reference
    types in your code, you will dramatically reduce the occurrence of `NullReferenceException`
    exceptions in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new succinct syntax to access the last item in an array is `[^1]`, which
    makes use of the `System.Index` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a switch expression, the discard (`_`) character is equivalent to `default`,
    which is typically used in the switch statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C# 8 introduced the asynchronous dispose feature to provide an asynchronous
    behavior when disposing resources. This way, we can await the asynchronous closing
    operation from the `DisposeAsync` method and avoid the danger of using the `Task.Wait`
    method inside `Dispose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The null coalescing assignment `??=` is used to avoid the execution of the code
    on the right side (in our example, the `GetOrders()` method) of the assignment
    when the left side (`orders`) is not null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to be iterated with `async foreach`, a sequence must exhibit an asynchronous
    behavior that cannot be done using the `IEnumerable` and `IEnumerator` interfaces
    and their generic counterparts. The new `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>`
    interfaces were specifically designed to support the asynchronous behavior that
    is used by the `async foreach` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `global.json` file is used to determine which SDK will be used in a given
    directory tree. You can create this file in the solution root folder (or any parent
    folders) by using the `dotnet new globaljson` command and editing it manually
    to match one of the versions returned by the `dotnet --info` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Path.Combine` method is the best way to concatenate paths on both Windows
    and Linux, both of which use different path separators. This method is also very
    convenient to avoid mistakes when concatenating relative paths and doubling or
    omitting the separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Libraries conforming to the .NET Standard specification are binary compatible
    with any framework supporting it. When you need to share code among different
    frameworks, verify which is the most recent version of .NET Standard supported
    by them and create a library that uses it. If the APIs you need to use are not
    supported by the required version of .NET Standard, you can change strategy and
    create separate libraries and package them together in a single NuGet package.
    The package manifest will need to associate each assembly to the specific framework,
    platform, or architecture the library can run on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks to the new project file format, it is now possible to copy the desired
    `PackageReference` tags from one project to another. This can also be done in
    Visual Studio when the solution is opened and, as soon as the file is saved, the
    NuGet packages will be restored automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After analyzing the architectural implications, the very first step is upgrading
    the current solution to the latest version of .NET Framework, at least version
    4.7.2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To minimize the startup time, .NET Core 3 offers two new publishing options.
    The first is **AOT** compilation, which immediately generates the assembly code,
    dramatically reducing the need for the **JIT** compiler. The second is enabling
    the **Quick JIT** compiler, which is used at runtime and is faster than the traditional
    **JIT** compiler, but generates less-optimized code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a type of software testing where individual units of code are
    tested in order to validate whether they are working as they were designed to
    work. Unit testing helps to identify and fix bugs early in the development cycle,
    therefore helping to save time and money. It helps developers to better understand
    the code and allows them to make changes easier. It helps with code reuse by requiring
    the code to be more modular in order to test it better. It can act as project
    documentation. It also helps with debugging because when tests fail, only the
    latest changes need to be checked and debugged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio tools for unit testing are the **Test Explorer** (where you can
    view, run, debug, and analyze tests), the Microsoft unit testing framework for
    managed code, code coverage tools (which determine the amount of code that unit
    tests are covering), and the Microsoft Fakes isolation framework (which allows
    you to create substitutes for classes and methods).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Test Explorer** in Visual Studio allows you to view available unit tests,
    grouped by different levels (projects, classes, and so on). You can run and debug
    the unit tests from the **Test Explorer**, and you can view the results from their
    execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify that a class contains unit tests, you must decorate it with the `TestClass`
    attribute. Methods containing unit tests must be decorated with the `TestMethod`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class to use for performing assertions is called `Assert` and is available
    in the `Microsoft.VisualStudio.TestTools.UnitTesting` namespace. It contains many
    static methods, such as `AreEqual()`, `AreNotEqual()`, `IsTrue()`, `IsFalse()`,
    `AreSame()`, `AreNotSame()`, `IsNull()`, and `IsNotNull()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code coverage can be determined based on the available unit tests from the **Test
    Explorer** or from the **Test** top-level menu. The results are available in the
    **Code Coverage Results** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can provide fixtures that execute once per class by providing methods decorated
    with the `ClassInitialize` and the `ClassCleanup` attributes. The former executes
    once per class before all the tests are executed, and the latter once after all
    the tests are executed. For fixtures that execute before and after each unit test,
    you must provide methods decorated with the `TestInitialize` and `TestCleanup`
    attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data-driven unit testing means writing unit tests that fetch testing data from
    an external source (such as a file or a database). The test method is then executed
    once for each row in the data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DynamicData` attribute allows you to specify a method or property of the
    unit testing class as the source of data. The `DataSource` attribute allows you
    to specify an external source of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The external sources of data supported by the Microsoft unit testing framework
    for data-driven tests are SQL databases, CSV files, Excel documents, and XML documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
