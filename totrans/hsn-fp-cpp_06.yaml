- en: Partial Application and Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already gone far in our quest to understand functional programming! We
    learned about pure functions and lambdas and dived into lambda calculus with the
    help of functional composition. We now know how to create functions from other
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's still one more thing to learn about the basis of lambda calculus. Besides
    functional composition, we can also create functions from other functions through
    two operations—currying and partial application. This will complete our discussion
    on functional building blocks and allow you to move forward towards designing
    with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is partial application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use partial application in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is currying?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to curry functions in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between currying and partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine currying with functional composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is on GitHub at [https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter05` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository here:
    [https://github.com/onqtam/doctest](https://github.com/onqtam/doctest).'
  prefs: []
  type: TYPE_NORMAL
- en: Partial application and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you think about lambdas and what operations we could do on them to obtain
    other lambdas, two things spring to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Something about combining two lambdas, which we've seen in functional composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something about the parameters of a lambda, which we'll visit next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What could we do with a lambda''s parameters? There are two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Decompose a lambda with multiple arguments into more lambdas with one argument,
    an operation called **currying**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain a lambda with *N-1* arguments by binding an argument of a lambda with
    *N* arguments to a value, an operation called **partial application**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reasons that will soon become apparent, the two operations are connected,
    so we'll discuss them together.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a lambda with *N* arguments, partial application means obtaining
    another lambda by binding one argument to a value, hence obtaining a new lambda
    with *N-1* arguments. We could, for example, take an `add` function and do a partial
    application to bind one of its parameters to the value `1`, resulting in an `increment` function. In
    pseudo C++, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's it! The idea of partial application is fairly simple. Let's look at the
    syntax in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic implementation of partial application can be done manually. We can
    simply create a lambda called `increment` that calls the general `add` function, passing
    `1` as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is not the neat operation we're looking for, but it can be useful when
    you can't use the generic method for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, STL offers a better alternative in our friendly header file, `functional`—the
    `bind` function. It takes as parameters the function, the values you want to bind,
    and placeholder arguments that just forward the arguments. To obtain the `increment`
    function with a call to `bind`, we pass in the general `add` lambda; the argument
    value, `1`, for the first argument; and a placeholder that specifies an unbound
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While convenient, you should be aware that `bind` has a high compile-time overhead.
    When this is a problem, you can always revert to the previous option—calling the
    more general lambda directly from another manually written lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, nothing stops us from binding both parameters. Since programmers
    like the number `42`, I will bind both parameters of the `add` lambda to the values, `1`
    and `41`, in order to obtain another lambda, `number42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` syntax can be a bit tricky sometimes, so let's look at it in more
    detail. The key is to understand that the *parameter placeholder refers to the
    parameters of the resulting lambda and not of the initial lambda*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this clearer, let''s look at an example of a lambda that adds its three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to obtain another lambda, `addTwoNumbersTo10`, from our `addThree`
    lambda, by binding its first parameter to the value `10`, what is the syntax of
    `bind`? Well, our resulting lambda, `addTwoNumbersTo10`, will receive two parameters.
    Their placeholders will be denoted with `_1` and `_2`. So, we need to tell bind
    that the first argument to our initial lambda, `addThree`, is `10`. The second
    argument will be forwarded from `addTwoNumbersTo10`, so it''s `_1`. The third
    argument is forwarded as well, from the second argument of `addNumbersTo10`, so
    it''s `_2`. We end up with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go forward. We want to obtain another lambda, `addTo10Plus20`, from
    our initial `addThree` lambda by using partial application. The resulting function
    will have only one argument, `_1`. The other arguments to bind will be the values, `10`
    and `20`. We end up with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we wanted to bind the first and the third argument? It should be clear
    now that the parameters are exactly the same, but their order changes in the `bind`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to bind the second and third arguments instead? Well, the placeholder
    moves, but it''s still the only argument of the resulting function, so `_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to do partial application on a class method?
  prefs: []
  type: TYPE_NORMAL
- en: Partial application on class methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bind` function allows us to do partial application on a class method,
    but there''s a catch—the first argument has to be the instance of the class. For
    this example, we''ll use an `AddOperation` class that implements simple addition
    between two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a new function, `add`, by binding an instance of the `AddOperation`
    class to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'More interestingly, and closer to the concept of partial application, we can
    forward the instance parameter from the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The binding is possible as well if the method receives arguments. For example,
    let''s say we have another class implementing `AddToOperation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do a partial application of `addTo` with just an instance of the class,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The partial application of the class methods shows that it's quite easy to move
    between the functional and the OOP world. We'll see in the next chapters how we
    can take advantage of this. Until then, let's rejoice in the fact that we now
    know what partial application is and how to use it in C++. It's time to talk about
    its close cousin, currying.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try for a moment to name a few famous people from software development,
    without searching the internet. There's Alan Turing, Ada Lovelace (she has a fascinating
    story), Grace Hopper, Donald Knuth, Bjarne Stroustroup, Grady Booch, and probably
    many others. How many of them have given their name to not one, but two things
    that you hear about constantly in the industry? That's true for Alan Turing, definitely,
    with the Turing machine and the Turing test, but not so for many others.
  prefs: []
  type: TYPE_NORMAL
- en: It's therefore surprising to learn that both the name of the Haskell programming
    language and the name of the currying operation come from the same person—Haskell
    Curry. Haskell Curry was an American mathematician and logician. He worked on
    something called **combinatory logic**, which is the basis of part of functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: But what is currying? And how does it connect to partial application?
  prefs: []
  type: TYPE_NORMAL
- en: What is currying?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Currying** is a process of decomposing functions with *N* arguments into
    *N* functions with one argument. We can do this through variable capture or through
    partial application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our `add` lambda again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we decompose it? The key is that a lambda is just a normal value, which
    means we can return it from a function. We can therefore pass in the first parameter
    and return a lambda that captures the first parameter and uses both first and
    second arguments. It''s easier to understand in code than in words, so here it
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s unpack what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `curryAdd` lambda returns a lambda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned lambda captures the first parameter, takes a second argument, and
    returns their sum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's why, when calling it, we need to use double parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: But this looks familiar, as if it has something to do with partial application.
  prefs: []
  type: TYPE_NORMAL
- en: Currying and partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look again at how we did partial application previously. We created
    an `increment` function through partial application of the `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let''s curry our `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, `increment` is very easy to write. Can you see how?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `increment` lambda is just `curryAdd(1)`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us a trick that''s commonly used by functional programming languages—the
    functions can be curried by default. In such a language, writing the following
    means that we apply the `add` function first to the `first` argument, and then
    the resulting function to the `second` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks as if we are calling the function with a parameter list; in reality,
    it''s a partially applied curried function. In such a language, the `increment`
    function can be derived from `add` simply by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse is also true. Since C++ doesn''t do currying by default, but offers
    an easy method for partial application, we can implement currying through partial
    application. Instead of returning the complex lambda with value capture, just
    bind to the single value and forward the single parameter of the resulting function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But how far can we take this? Is it easy to curry functions with multiple arguments?
  prefs: []
  type: TYPE_NORMAL
- en: Currying functions with multiple arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen, in the previous section, how to curry functions with two arguments.
    When we move to three arguments, the curried function grows as well. We now need
    to return a lambda that returns a lambda. Once again, the code is easier to understand
    than any explanation, so let''s see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There seems to be a recursive structure going on there. Maybe by using `bind`
    we can make sense of it?
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out it''s not that simple, but it is possible. What I would like to
    write is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `addThree` has three arguments, so we''d need to bind them to something.
    The next `bind` results in a function with two arguments, and again, we need to
    bind them to something. So, it would actually look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The question marks should be replaced with the previously bound values, but
    that doesn't work with our current syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s a workaround. Let''s implement multiple `simpleCurryN` functions
    that use `bind` on functions with *N* arguments and reduce them to *N-1*. For
    a function with one argument, the result is simply the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For two arguments, we bind the first and forward the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar operations apply for three and four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This set of `simpleCurryN` functions allow us to write our `curryN` functions
    that take one function with *N* arguments and return its curried form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test them on `add` lambdas with two, three, and four arguments, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's likely that we can rewrite these functions with some imaginative use of
    templates. I will leave this exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it's important to see how partial application connects with currying.
    In programming languages that curry functions by default, partial application
    is very easy—just call the function with fewer arguments. For other programming
    languages, we can implement currying through partial application.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts are very interesting, but you're probably wondering if they are
    useful in practice. Let's have a look at how to remove duplication using these
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplication using partial application and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers have long looked for solutions to write less code that does more
    things. Functional programming proposes one solution—build functions by deriving
    from other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen this in action in the previous examples. Since `increment`
    is a particular case of addition, we can derive it from our addition function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How does this help us? Well, imagine your customer comes in one day and tells
    you *we want to use another type of addition.* Imagine having to search for `+`
    and `++` everywhere in your code and figuring out ways to implement the new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, with our `add` and `increment` functions, and a bit of template magic,
    this is what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our `add` method doesn't care what type it gets, as long as it has a plus operator.
    Our `increment` function doesn't care what type it uses and how `add` works, just
    that you provide a value for one. And we've done this within three lines of code.
    I rarely say this about code, but isn't it beautiful?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure, you might say, but our clients don''t really want to change the way we
    add things. You would be surprised how much you can do with a few simple operators.
    Let me give you just a simple example. Implement a game in which a character moves
    on a line that wraps, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e9654cf-b698-47a3-a965-8bc798779a06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Isn''t this just a modified version of addition? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, this code looks very similar with `add`. Maybe we can use partial application?
    Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our `increment` function is exactly the same as before, while our `add` function
    has become a partial application of `addWrapped`. It's worth noting that, to make
    the code cleaner, I would still change the function names to make it very clear
    what the functions are doing. However, the main point is that partial application
    and currying help us to remove certain types of duplication from our code, empowering
    us to open the code to implementations we didn't necessarily know about when designing
    the initial solution. And while we can do this with OOP or templates, the functional
    solution limits complexity by removing side effects and requires just a few lines
    of code. That makes it a worthy choice when designing a program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look how far we've gone in our understanding of functional programming! We learned
    about all of the building blocks—pure functions and lambdas—and about the operations
    we can use on them—currying, partial application, and functional composition.
    We also saw how the operations relate to one another and how we can use currying
    to implement partial application and vice versa. We also saw ways to implement
    currying in C++.
  prefs: []
  type: TYPE_NORMAL
- en: But our quest is just beginning. The next stop is—starting to use these constructs
    in more interesting contexts. It's time to tackle the difficult question—how exactly
    do we design with functions?
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a partial function application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is currying?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does currying help us to implement partial application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we implement partial application in C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
