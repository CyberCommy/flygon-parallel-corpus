- en: Turtle Class - Drawing on the Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not so long ago, programmers, especially game programmers, would face many intricacies
    while building programs. No wonder! Back then, there wasn't enough assistance
    from the internet portal, including no stack overflow, but more than that, there
    were no universal tools that programmers could use; they had to create one first
    and use it in the programs. The tools they created would handle some game specifics
    (specific drivers for sound and graphics). Programmers had to create games using
    assembly language due to the meager resources available, which would be trade-offs
    for processing power, display, sound, and control routines. Even the worst scenario
    would be encountered at the time of debugging. They would need complex and expensive
    machines in order to replicate their programs, and they would also have logging
    and debugging extensions. The main goal of this chapter will be to make us familiar
    with two-dimensional (2D) space drawing using turtle, along with the event handling
    method of turtle, and to create simple 2D idle animations.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, we have made gargantuan progress in the gaming industry.
    We have created tools that allow us to use any programming language in order to
    make games, such as Python and C (low-CPU-demanding games). All of the low-level
    routines are hidden by higher-level software due to the communication of device
    drivers. The high-level languages such as Python are abstract; they provide less
    access to the lower-level functions. We can group multiple things together as
    classes that can inherit characteristics from another class, which removes the
    duplication of code. Python provides modules such as turtle and Pygame, which
    contain a bunch of methods for designing game characters and handling user events.
    In this chapter, we will learn about the turtle module. Each of the things that
    will be built from this chapter onward will use techniques from the preceding
    chapters—with the addition of a few notable characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of turtle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to turtle commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turtle events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes with turtle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section takes you through the basic Python graphical programming module
    and its working. Therefore, you are expected to have the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.5 or later; refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python IDLE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mouse (a laptop's touchpad won't work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2pAmrCs](http://bit.ly/2pAmrCs)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the turtle module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the different components of a computer are equally important in order
    to provide a better computing experience, we also need the different components
    of a computer to work together in order to provide a better gaming experience.
    The video card of the computer is responsible for computing the visual images
    of the screen and then modularizing the image signal before sending it to the
    monitor. The input devices such as the mouse, keyboard, and joysticks are required
    to handle user events according to the programs. The audio card is required to
    process the audio signals and then send them to output devices such as the speaker.
    At the early age of game programming, programmers needed to read the technical
    manual for each of these devices separately and code each of them in isolation.
    This meant making communication between them would take a single year, even for
    simple games. However, with advancements in technology—and drivers in particular—programmers
    obviated the headache of making communication between these devices and the operating
    system manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we developed a simple program known as drivers, which acts as a common
    interface to communicate with different devices, different hardware and version
    incompatibilities made programmers'' lives harder when they were developing games
    that could be played across multiple platforms. Luckily, we have Python, a language
    that has the adept capability to make programs that can be platform independent.
    Turtle is the Python module that provides the drawing board that can be used to
    create pictures and packets. It is believed that the turtle module is the sister
    of another popular programming language from the 90s—*Logo—*which had an imaginary
    icon of a turtle, and a pen, which was used to draw over the screen. Python''s
    standard library, *turtle*, is similar to the Logo programming language. In order
    to use the turtle module, we have to import it. Importing it is easier as it comes
    packed as a standard Python library and it does not need to be installed manually.
    The following steps explain how to make any turtle application:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the turtle module with the `import` command. If you ignore this step,
    there won't be any interface to control turtle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a turtle to control. This step is used to instantiate turtle in order
    to create a new turtle controller, for example, `game = turtle.Turtle()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating a control, we use the new turtle to draw and carry out multiple
    tasks in the drawing screen by calling the methods of the turtle module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to call one important method explicitly, which holds the game screen,
    that is, `turtle.done()`. This method will pause the program. You need to close
    the window manually in order to close the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a turtle package, when we run the program that is made by calling the methods
    of the turtle module, a new window will appear with a pen, along with the shapes
    that are drawn by the turtle commands. Let's learn about a few important turtle
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to turtle commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The turtle module comes with multiple commands in the form of methods that
    can be used independently. There are methods to make the pen move forward and
    backward, and some to create shapes. Take a look at the following table to find
    out about the most important turtle commands. You can read about them in detail
    on their official Python documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Turtle()` | None | Creates and returns a new turtle object. |'
  prefs: []
  type: TYPE_TB
- en: '| `forward()` | Distance | Moves the turtle forward by the specified amount.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `backward()` | Distance | Moves the turtle backward by the specified amount.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `right()` | Angle | Turns the turtle clockwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `left()` | Angle | Turns the turtle counter-clockwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `penup()` | None | Picks up the turtle''s pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `pendown()` | None | Puts down the turtle''s pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `up()` | None | Picks up the turtle''s pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `down()` | None | Puts down the turtle''s pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `color()` | Color name | Changes the color of the turtle''s pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `fillcolor()` | Color name | Changes the color that the turtle will use to
    fill a polygon. |'
  prefs: []
  type: TYPE_TB
- en: '| `heading()` | None | Returns the current heading. |'
  prefs: []
  type: TYPE_TB
- en: '| `position()` | None | Returns the current position. |'
  prefs: []
  type: TYPE_TB
- en: '| `goto()` | *x*, *y* (positions) | Move the turtle to position *x*, *y*. |'
  prefs: []
  type: TYPE_TB
- en: '| `begin_fill()` | None | Remembers the starting point for a filled polygon.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `end_fill()` | None | Closes the polygon and fills it with the current fill
    color. |'
  prefs: []
  type: TYPE_TB
- en: '| `dot()` | None | Leaves the dot in the current position. |'
  prefs: []
  type: TYPE_TB
- en: '| `stamp()` | None | Leaves an impression of a turtle shape at the current
    location. |'
  prefs: []
  type: TYPE_TB
- en: '| `shape()` | Shape name | Should be *arrow*, *classic*, *turtle,* or *circle*.
    |'
  prefs: []
  type: TYPE_TB
- en: 'In the preceding table, we can guess the result of calling those methods by
    observing the literal meaning of the method''s name. For example, the `forward(amount)`
    method is going to move the pen forward with the amount specified as the argument.
    All of these methods are used to plot different shapes into the drawing canvas
    of turtle. Observe the first `>>> Turtle()` method. This will return the object
    of turtle, which must be used in order to invoke these methods. As an example,
    we are going to make a program that will draw a line onto the screen. The following
    is the code for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe the following output by running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6b556b6f-26e0-4e80-8b39-5a7fd539ebe5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with the Python shell, the new screen, like the preceding one, should
    pop out, and this represents the turtle drawing board. Initially, the pen attached
    to the imaginary turtle will reside at the center of the drawing board. Any method
    call from the turtle object must manipulate the movement of the pen. The preceding
    code can be explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to import turtle, which is a first step that will make sure all
    the commands that reside inside the turtle class will be available for us to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to create a turtle controller, and we refer to it as pacman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we make a movement of 100 pixels from the point that pacman is facing.
    Initially, the *pacman* turtle controller was facing toward the right; thus, the
    pen moved 100 pixels to the right from the center, creating the straight line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `turtle.done()` is going to pause the turtle drawing board screen so
    that we can observe the output clearly. In order to close the turtle screen, we
    have to manually close the Python shell or the turtle graphics screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ve just learned how to create a straight line, but the lines look boring
    and do not add any aesthetics to the program. It''s time to learn how to use another
    method, which is going to turn the pen in another direction. For example, we may
    want to change the direction of the pen from where it was originally facing to
    another direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are already familiar with the `forward` method, and alongside it, we have
    now introduced the `right()` method. If you have a look at the previous table
    of methods, you will see that the `right` method and angle have been passed as
    arguments. Thus, this method is going to perform some rotation, accompanied by
    the angle that was passed along with it. Since we passed 90 degrees to it, this
    method is going create a 90-degree clockwise rotation. If you want to rotate the
    pen anticlockwise, we have to call the left method and specify the angle of rotation.
    In the preceding program, we rotated it by 90 degrees. The geometrical shape that
    has all angles of 90 degrees is either the square or the rectangle. However, we
    know that the `forward` method will result in a straight line, which is the same
    as the sides of geometrical shapes. The sides that are created by the `forward`
    method will be equal in length, which is 50, and this is passed as an argument
    with the `forward` method. With all this evidence, we can surely expect the square
    shape to be drawn in the turtle board. Let''s run the preceding code to observe
    the output. As expected, the square shape is drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0ba32ee6-1a60-4f2c-9cdb-04c4e19b47da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a closer look at the preceding code; did you see some repetition of code?
    Obviously, the invocation of the `forward` and `left` methods is done multiple
    times, which ultimately disrespects the DRY principles. This epiphany does not
    come without practicing the paradigm of Python. Thus, we can say that practice
    is what differentiates good and bad programmers. Now, recall what we need in order
    to eliminate the redundancy of the code; we should use either loops or functions.
    We will use a loop here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I guess we won't have any problems in reading and understanding this code. As
    we mentioned in [Chapter 3](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml), *Flow
    Control - Building a Decision Maker For Your Game*, we can create an iteration
    level with a range of functions. Since we need to run these methods four times,
    we have created four iterations using the range function. Anything that needs
    to be repeated is indented by four blocks inside the scope of the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice in this example is that we have multiple methods for handling
    the movements of the pen in the drawing screen. The two turtle commands that we
    have learned so far are `forward(amount)`, which moves the turtle forward in the
    direction it is facing with some amount, and `right(degree)`, which makes the
    turtle turn clockwise by a specified degree. Notice here that the `right` and
    `left` commands are not going to write anything on the screen; instead, they are
    used for rotation only.
  prefs: []
  type: TYPE_NORMAL
- en: Following the patterns of everything that we have learned so far, we can predict
    that the `backward` method is going to move the pen in the backward direction
    from the original direction that it was facing by a specified amount. I recommend that
    you try modifying the preceding code a little bit—by refactoring the forward method
    using `backward`, and by refactoring `right` using `left`—and observe the result
    accordingly. I would like to take the time to conclude this topic here, without
    covering other functions, because we will go through each of them while making
    games in the upcoming chapters. We will make multiple games, such as the Snake
    game, the Pong game, and Flappy Bird using the turtle module. Now, we will explore
    the ways we can connect input devices, such as a mouse and a keyboard, to our
    game so that players can interact with the turtle environment.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring turtle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous chapters, handling the events of a user is one
    of the prime building blocks for creating any game. The event represents the action
    that needs to be performed at any time during the game. Have you ever wondered
    how the events are handled by programs at the low levels? When a user executes
    any event using the keyboard or mouse, that request is stored in a queue-like
    structure. The queue structure is important because the order of handling these
    events must be on a first come, first served basis. Then, according to the behavior
    of the user actions, events are handled by the program. These two tasks of rendering
    and action handling are performed independently by the programs. For example,
    in a counter strike game, the user can shoot from their gun, even when enemies
    are not around them. Here, the event is the user pressing a key to fire the gun
    and the rendering task is spawning the enemies around the player. These two tasks
    are not executed independently unless we write programs to make them. In this
    section, we are going to learn how to take a user action as an input, and handle
    it accordingly. Handling the user actions means serving the actions that are stored
    in the queue structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the events are based on the use of a mouse or a keyboard, but some
    events must be predicted automatically by the program and handled accordingly,
    such as the `ontimer(fun, time)` method. This method takes two arguments: function
    and time in milliseconds. This method sets a timer that calls the `fun` function
    after `time` in milliseconds. Let''s make a simple program to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of code (`turtle.mainloop()`) simply performs the same operations
    that are carried out while looping. Until, and unless, the user exits the window
    screen explicitly, the call to the `main` function will not be terminated. Its
    importance can be observed when the program has a while loop, which is used to
    listen to the incoming connection, but we don''t want the computer to be constantly
    focused on the one case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code works in exactly the same way as a while loop, but now the
    Python parser is not dedicated to performing only one task constantly. Instead,
    for every 100 milliseconds, `draw_objects()` tasks will be performed, and for
    the remaining 99.99 milliseconds, the Python parser is free to carry out any other
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the preceding code represents the proper outcome of any turtle
    program. Although calling a different function would make a different character
    on the screen, the main aim of using turtle is to render the game character onto
    the screen. Let''s break down the preceding code into the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The first couple of steps represent importing turtle and creating a turtle controller,
    which will allow us to call all the `turtle` methods through it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a `main` function, and inside it, we have some code to create
    a star pattern. The iteration is 100 times, which means we will have 100 stars
    printed onto the output screen, but remember, they will be closely spaced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to render the characters properly in the screen is by using the
    `ontimer` method. Let''s modify the same program with the `ontimer` method. Let''s
    see how we can use it in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike before, the preceding program is not going to print multiple stars;
    instead, it prints a single one. However, the `ontimer` method removes the overhead
    of calling the for loop since it sets the timer to call the same function again
    and again. In this program, we passed the `main` function and 500 as arguments,
    which means that the `main` function should be called in every `500` milliseconds.
    Running the preceding program will yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/56a5bc78-7ded-4b06-95fb-c27435241fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s time to learn how to handle keyboard and mouse events. As always, there
    are methods that have been defined to handle keyboard events and methods that
    have been defined to handle mouse events. But, before handling user events, turtle
    must launch a listener, which continuously remains awake to listen to any events.
    Such a listener controller is created using the `listen` method, that is, `>>>
    turtle.listen()`. The following table depicts the methods that are used to handle
    keyboard events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `turtle.onkeypress(function, key = None)` | **Function**: A function with
    no arguments or `None`.**Key**: A key in the form of strings or symbols, for example,
    `q` or `space`. | It is used to bind the function to any key events that are pressed
    on a keyboard. If no key is specified, any key will work. |'
  prefs: []
  type: TYPE_TB
- en: '| `turtle.onkeyrelease(function, key)` | **Function**: A function with no arguments
    or `None`.**Key**: A key in the form of string, `a`, or symbols, `enter`. | It
    is used to bind the function to key-release events that are performed by key actions.
    If the function is `None`, the binding of events is removed. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s make a simple program in order to grasp the idea of using these methods
    of handling keyboard actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the program and observe the output. After pressing *F5*, you will
    observe two screens, one of which will have the turtle graphics board and pen
    at the center of it. Now, press the *Spacebar* key on the keyboard. As soon as
    you press it, it starts to draw a star onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we have added some code that will make a star. However,
    as you can see, the `main` function has not been called explicitly, as we normally
    do while calling functions; instead, it is called using the `onkeypress` method.
    This method binds the key to the function, and whenever the key is pressed, the
    function is called automatically. If you remove the last line from the preceding
    code, the listener controller is not going to work. The `listen` method is used
    to make a controller for listening incessantly to these types of actions.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, we can call the `onkeyrelease` method. Replace `onkeypress`
    with `onkeyrelease` in the preceding code and observe the output. The output is
    going to be the same. The `onkeyrelease` method is used to bind the function to
    be called with the key-release event of the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the ways of handling mouse events are not too different—they are
    also handled by method calls. The following table depicts the methods that can
    be used to handle mouse events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `onclick(function, button = 1, add = None)` | **Function**: A function is
    called with two arguments (*x, y*), which represent the coordinates of the clicked
    position by mouse or pointer.**Button**: It represents the mouse button, `default
    = 1`, which means the left mouse button.**Add**: It is used to add multiple bindings.
    If `True` is passed, a new binding will be added, otherwise it will stick to the
    current one. | Binds functions to mouse-click events. If the user clicks on any
    position of the turtle canvas, the coordinates of the clicked position will be
    used to call the function. |'
  prefs: []
  type: TYPE_TB
- en: '| `onrelease(function, button = 1, add = None)` | **Function**: A function
    is called with two arguments (*x, y*), which represent the coordinates of the
    clicked position on the drawing board of turtle.**Button**: `Default = 1` means
    that the left mouse button is used. It is used to add a number for mouse-button.**Add**:
    According to its value of `True` or `False`, it decides whether to add a new binding
    or not. | Binds functions to mouse-button release event. |'
  prefs: []
  type: TYPE_TB
- en: '| `ondrag(function, button = 1, add = None)` | **Function**: A function with
    two arguments, which represent the coordinates of the clicked point into the game
    screen.**Button**: Adds a number to indicate the mouse button listener. | Binds
    functions to mouse move events on the current turtle controller. If the function
    is `None`, the current binding will be removed. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s make a simple program to grasp the idea of using the preceding methods
    for handling mouse events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `onclick` method was called with only the move function,
    which in turn calls the move method with the *x* and *y* coordinates representing
    the clicked point onto the canvas. Running the preceding program does not draw
    any lines on the screen until you click on the drawing canvas. When you click
    on any point of the screen, you will see its coordinate printed in the Python
    shell, and a straight line will appear on the canvas. We will cover the remaining
    `turtle` methods in the upcoming chapter, along with how to make some mini games.
    Before that, we will try to make some shapes using the `turtle` module and the
    Python design patterns that we have learned about so far.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing shapes with turtle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of making shapes may seem like a boring and tedious task for a human
    being, but it's not for computers. Imagine making a hexagonal shape with exact
    geometrical measurements while taking care of angles and sides. The process itself
    overwhelms most of us. On the other hand, computers are considered to work sedulously;
    we can throw as many tasks as we like at it, and it will perform them gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned previously, two critical pieces of information while drawing
    any shape are the angle and length of each side. We can make variables to store
    them so that we can refer to them in the program whenever they are needed. For
    any shape, there will be a different number of sides. For example, a triangle
    has three sides, while a hexagon has six sides. We need to specify the number
    of sides explicitly in the program. In this section, we are going to make two
    shapes, a hexagon and a star shape, with some added colors. The main aim of this
    section is to help you understand how the programming paradigm is used, along
    with a particular module, in order to make appealing games.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list of steps depicts the roadmap that is needed in order to
    create two shapes, one by one. The first shape that we will create is a hexagon:
    a shape that has six sides, with a custom length. After that, we will make a star
    pattern again, but this time, we will add color properties to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexagon**: We will create this shape by defining specific variables, such
    as the number of sides, interior angle, and length of sides. After that, we will
    use the for loop to create six iterations because we have to call the line rendering
    method six times (since a hexagon has six sides). We will use the `forward` method
    to draw a straight line and the `right` method to turn the turtle clockwise by
    a specific angle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see how convenient it is to draw the shapes onto the canvas using the
    `turtle` module. We are already familiar with these methods and the usage of loops
    in order to remove the repetition of multiple lines of code; thus, it won't be
    hard to grasp the code that we have written over here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Star**: Making a star shape with Turtle is easier than using any other module.
    We have already made it using two methods of `turtle`, that is `forward` and `left`.
    But in this section, we are going to color the star shape using the `color` method
    provided by the `turtle` module. We will start by defining the color palette,
    that is, different color names, and we will make a method call of `begin_fill`
    and `begin_end`, which will add the color to the shapes. The following table shows
    three methods that can be used for coloring shapes in turtle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Method** | **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|  `color(*args)` | Args represents the color''s name. The current color is
    used for drawing lines using the `forward` or `backward` methods. The color name
    can be given as `single value: color(“blue”)`, `double value: color(“black”,”green”)`,
    or `rgb` float values. | Used to change the color of the turtle pen. |'
  prefs: []
  type: TYPE_TB
- en: '| `begin_fill()` | None | This method will remember the starting point for
    filled polygons. |'
  prefs: []
  type: TYPE_TB
- en: '| `end_fill()` | None | It will close the shape drawn in the turtle canvas
    and fill it with the current fill color. |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, we will write a program that will use these methods to color
    the star pattern. We will use the color combination of red and yellow to make
    the star more attractive. We have been using the `import turtle` command to make
    `turtle` methods available for the program to use. Instead of doing it this way,
    we can import everything from turtle with the `from turtle import *` command.
    Now, instead of calling the `turtle` method with `>>> turtle.forward(100)`, we
    can call it directly, that is, `forward(100)`. Let''s write a program to create
    such a star pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I just love the way that turtle works with Python. Being able to bind every
    function to the programming paradigm of Python makes the `turtle` module effective
    to use. In the preceding code, we might not have any confusion with the first
    line of code, which simply imports everything from the `turtle` module—every attribute
    and member. We made a color palette of red and yellow using the `color` method.
    Inside the main loop, we will encounter two methods, which we have been using
    from the beginning of this chapter. In addition, we have added a conditional to
    indicate the stopping point for the turtle pen. The `abs()` method is used to
    return the absolute value of the number, that is, `>>> abs(-4)`, which yields
    4\. Inside the `abs()` function, we called the `pos()` method of the `turtle`
    module, which will return the position of turtle as a two-element list. We checked
    for the current position, and if it's less than 1, for example, 0, then it must
    represent the center position, because (0,0) represents the center position. If
    we encounter the center position after an iteration, that means we can terminate
    the program because at this point, we must have already drawn a star. If we proceed
    further, the turtle pen will draw another star on the same position, therefore
    overriding the old one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in order to prevent this continuous iteration, we have added a conditionals
    line: `if abs(pos()) < 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding programs yields the following output. One thing you
    must remember here is that, from the color palette, at the beginning, we used
    a red pen to draw the star, and after finishing it, we used yellow to fill the
    inner part of the star shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d9d18f00-4b2e-4228-9cad-dc4770931526.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you know everything about the ways of using `turtle` methods for creating
    shapes and coloring them, we will wrap this chapter up here. We will be using
    the concepts we've learned in this chapter, such as creating patterns and handling
    user events, in the upcoming chapters by making simple mini games such as Snake,
    Pong, and Flappy Bird.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python *turtle* module is a powerful platform for building 2D mini games.
    It contains a variety of methods in order to facilitate the design process of
    game characters. We have written a bunch of programs in this chapter, and also
    handled user events. We started this chapter by introducing the key features of
    the `turtle` module, and built a universal prototype for any game that can be
    made with the Python `turtle` module. This chapter taught us about animating a
    2D canvas using the `turtle` module. Along with animating game characters, we
    learned how to create interfaces that communicate between the game interface and
    the user controller by handling user events.
  prefs: []
  type: TYPE_NORMAL
- en: Following the completion of this chapter, you will be well equipped to create
    simple 2D games using the `turtle` module. You will also be able to handle the
    user actions that are provided by the mouse and the keyboard, which allows us
    to make user-interactive games. Now that you have learned how to create simple
    animations using the 2D Turtle canvas, you can create any geometrical shape; try
    a few more before hopping into the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't cover any games in this chapter, because in order to create games
    with the `turtle` module, we need to explore vectors first—creating vectors, storing
    vectors, finding the magnitude of vectors, vector additions, negations, diagonal
    movements, and many more. We will cover all of these concepts in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of vectors is undoubtedly the most essential topic for any game developer's
    toolkit. Vectors are mathematical terms that represent the magnitude and direction
    of our game character that appears on the screen. Magnitude represents the modulus
    of the current coordinates of a point in which the character resides, while direction
    represents a course that the game character moves on. Now would be the perfect
    time for you to play around with the `turtle` module and grasp the idea of handling
    user events and building appealing shapes and characters.
  prefs: []
  type: TYPE_NORMAL
