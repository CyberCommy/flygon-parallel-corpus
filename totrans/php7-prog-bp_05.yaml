- en: Chapter 5.  Creating a RESTful Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is to implement a RESTful Web Service that can be used
    to manage user profiles. Each user will have some basic contact information (such
    as a username, a given name, and a family name), a password for authentication,
    and a profile image.
  prefs: []
  type: TYPE_NORMAL
- en: This service will be implemented using the Slim micro framework, a small and
    lightweight framework that is available as an open-source library (MIT licensed)
    for PHP 5.5 and newer (we'll be using PHP 7, of course). For persistence, a MongoDB
    database will be used. This offers the perfect chance to explore PHP's MongoDB
    extension, which replaces the old (similarly named, but completely different)
    Mongo extension that was removed with PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of RESTful Web Services, most importantly the common HTTP request
    and response methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using the Slim framework, and also the basics of the PSR-7 standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and implementing the actual example RESTful Web Service using the
    Slim framework and MongoDB storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with PSR-7 streams and store large files in a MongoDB database with
    GridFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will recapitulate the basics of RESTful Web Services. You
    will learn about the basic architectural goals of REST Web Services and the most
    common protocol semantics of the **Hypertext Transfer Protocol** (**HTTP**), which
    is commonly used to implement such services.
  prefs: []
  type: TYPE_NORMAL
- en: REST architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **Representational State Transfer** was coined by Roy Fielding in 2000
    and describes an architectural style for distributed systems that is, in principle,
    independent of any concrete communication protocol. In practice, most REST architectures
    are implemented using the **Hypertext Transfer Protocol** - in short, HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key component of each RESTful Web Service is the resource. Each resource
    should meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addressability**: Each resource must be identifiable by a **Uniform Resource
    Identifier** (**URI**), which is standardized in RFC 3986\. For instance, a user
    with the username `johndoe` might have the URI `http://example.com/api/users/johndoe`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statelessness**: The participants'' communication between each other is stateless;
    this means that REST applications typically do not use user sessions. Instead,
    each request needs to contain all information that the server will need to fulfill
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: Each resource must be accessible by a set of standard
    methods. When using HTTP as a transfer protocol, you will typically use the HTTP
    methods for querying or modifying the state of resources. The next section of
    this chapter contains a short overview of the most common HTTP standard methods
    and response codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupling of resources and representation**: Each resource can have multiple
    representations. For example, a REST service might serve both a JSON and an XML
    representation of a user profile. Typically, the client specifies in which format
    the server should respond, and the server will choose a representation that best
    fits the requirements specified by the client. This process is called  **Content
    Negotiation**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn to implement all these architectural principles
    in a small RESTful Web Service. You will implement several different resource
    types with different representations and learn how to use different HTTP methods
    and response codes to query and modify these resources. Additionally, you will
    learn how you can use advanced HTTP features to your advantage (such as the rich
    set of cache-control headers).
  prefs: []
  type: TYPE_NORMAL
- en: Common HTTP methods and response codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP defines a set of standard methods (or *verbs*) that clients can use in
    requests, and status codes that servers can use in responses to said requests.
    In REST architectures, the different request methods are used to either query
    or modify the server-side state of the resource that is identified by the request
    URI. These request methods and response status codes are standardized in RFC 7231\.
    **Table 1** and **Table 2** show an overview of the most common request methods
    and status codes.
  prefs: []
  type: TYPE_NORMAL
- en: The request methods `GET`, `HEAD`, and `OPTIONS` are defined as *safe*. Servers
    should not modify their own state when processing these kinds of requests. Furthermore,
    both the safe methods and `PUT` and `DELETE` methods are defined as *idempotent*.
    Idempotency means that repeated identical requests should have the same effect
    as a single request - for instance, multiple `DELETE` requests to the `/api/users/12345`
    URI should still result in that one resource being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1, Common HTTP request methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Used for querying the state of the resource identified by the URI.
    The server responds with a representation of the queried resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Just like `GET`, except the server returns only the response headers
    and not the actual resource representation. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `POST` requests can contain a resource representation in their request
    body. The server should store this object as a new sub-resource of the resource
    identified by the request URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Just like `POST`, `PUT` requests also contain a resource representation
    in their request body. The server should ensure that a resource with the given
    URI and representation exists and should create one if necessary. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Deletes the resource with the specified URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Can be used by clients to query which operations are allowed
    for a given resource. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2: Common HTTP response status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `200 OK` | The request was successfully processed; the response message typically
    contains a representation of the requested resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | Like `200 OK`, but in addition, explicitly states that a
    new resource was created by the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `202 Accepted` | The request was accepted for processing, but has not yet
    been processed. This is useful when a server processes time-consuming requests
    asynchronously. |'
  prefs: []
  type: TYPE_TB
- en: '| `400 Bad Request` | The server was unable to interpret the client''s request.
    This might be the case when a request contains invalid JSON or XML data. |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | The client needs to authenticate before accessing this
    resource. The response can contain more information on the required authentication
    and the request can be repeated with appropriate credentials. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | Can be used when the client was authenticated, but is not
    authorized to access a given resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `404 Not Found` | Used when the resource specified by the URI does not exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `405 Method Not Allowed` | The request method is not allowed for the specified
    resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Internal Server Error` | An error occurred on the server while processing
    the request. |'
  prefs: []
  type: TYPE_TB
- en: First steps with the Slim framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will take you first steps with the Slim framework. For
    this, you will first use Composer to install the framework and then build a small
    sample application that will show you the basic principles of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Slim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Slim framework can be easily installed using Composer. It requires PHP
    in at least version 5.5, but also works well with PHP 7\. Start by initializing
    a new project with Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new project-level `composer.json` file for our project.
    Now you can add the slim/slim package as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A small sample application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can now start using the Slim framework in your PHP application. For this,
    create an `index.php` file in your web server''s document root with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a look at how the Slim framework works here. The central object here
    is the `$app` variable, an instance of the `Slim\App` class. You can then use
    this application instance to register routes. Each route is a mapping of an HTTP
    request path to a simple callback function that handles an HTTP request. These
    handler functions need to accept a request and a response object and need to return
    a new response object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can test this application, you may need to configure your web server
    to rewrite all requests to your `index.php` file. If you are using Apache as a
    web server, this can be done with a simple `.htaccess` file in your document root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will rewrite requests for all URLs to your `index.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your (admittedly still very simple) API with your browser. If
    you prefer the command line, I can recommend the **HTTPie** command-line tool.
    HTTPie is Python-based and you can easily install it using your operating system''s
    package manager or Python''s own package manager, **pip**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use `HTTPie` on the command-line to perform RESTful HTTP requests
    easily and also get syntax-highlighted output. See the following figure for an
    example output of HTTPie when used with the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A small sample application](graphics/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example output of HTTPie with the Slim example application
  prefs: []
  type: TYPE_NORMAL
- en: Accepting URL parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Slim routes can also contain parameters in their path. In your `index.php`,
    add the following route before the last `$app->run()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, any route specification can contain arbitrary parameters in
    curly brackets. The route handler function can then accept a third parameter that
    contains all path parameters from the URL as an associative array (such as the
    username parameter in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: Accepting HTTP requests with a message body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have only worked with HTTP `GET` requests. Of course, the Slim framework
    also supports any other kind of request method that is defined by the HTTP protocol.
    One interesting difference between a `GET` and - for example - a `POST` request,
    however, is that some requests (such as `POST`, `PUT`, and others) can contain
    a request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request body consists of structured data that is serialized as a string
    according to some pre-defined encoding. When sending a request to a server, the
    client uses the **Content-Type** HTTP header to tell the server which encoding
    is used for the request body. Common encodings include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded` is typically used by browsers when submitting
    an HTML form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/json` for JSON encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/xml` or `text/xml` for XML encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Luckily, the Slim framework supports all these encodings and determines the
    correct method to parse a request body automatically. You can test this with the
    following simple route handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `getParsedBody()` method that is offered by the `Request`
    class. This method will use the request body and automatically use the correct
    decoding method depending on the Content-Type header that was present in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use any of the preceding content encodings presented to `POST`
    data to this route. This can be easily tested using the following curl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All of these requests will yield the same response from your Slim application,
    as they're containing the exact same data, just using a different content encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The PSR-7 standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the Slim framework's main features is the PSR-7 compliance. PSR-7 is
    a **PHP Standard Recommendation** (**PSR**) defined by the **PHP Framework Interoperability
    Group** (**FIG**) and describes a set of standard interfaces that can be implemented
    by HTTP servers and client libraries written in PHP to increase operability between
    those products (or in plain English, to enable these libraries to be used with
    each other).
  prefs: []
  type: TYPE_NORMAL
- en: 'PSR-7 defines a set of PHP interfaces that the framework can implement. The
    following figure illustrates the interfaces that are defined by the PSR-7 standard.
    You can even install these interfaces in your project by acquiring the `psr/http-messages`
    package using Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PSR-7 standard](graphics/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The interfaces defined by the PSR-7 standard
  prefs: []
  type: TYPE_NORMAL
- en: The `Slim\Http\Request` and `Slim\Http\Response` classes that you have worked
    with in the previous examples already implement these PSR-7 interfaces (the `Slim\Http\Request`
    class implements the `ServerRequestInterface` and `Slim\Http\Response` implements `ResponseInterface`).
  prefs: []
  type: TYPE_NORMAL
- en: 'These standardized interfaces become especially useful when you want to use
    two different HTTP libraries together. As an interesting example, consider a PSR-7
    compliant HTTP server framework like Slim used together with a PSR-7 compliant
    client library, for example **Guzzle** (use the package key `guzzlehttp/guzzle`
    if you want to install it with Composer). You can use these two libraries and
    easily wire them together for a dead-simple reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What exactly happens here? The Slim request handler gets an implementation of
    the `ServerRequestInterface` passed as a first parameter (remember; this interface
    inherits the regular `RequestInterface`) and needs to return a `ResponseInterface`
    implementation. Conveniently, the `send()` method of `GuzzleHttp\Client` also
    accepts a `RequestInterface` and returns a `ResponseInterface`. Because of this,
    you can simply re-use the request object that you received in your handler and
    pipe it into the Guzzle client and also re-use the response object returned by
    the Guzzle client. Guzzle's `send()` method actually returns an instance of the
    `GuzzleHttp\Psr7\Response` class (and not `Slim\Http\Response`). That is completely
    acceptable, as both of these classes implement the same interface. In addition,
    the preceding example uses the method defined by the PSR-7 interfaces to modify
    the host part of the request URI.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Immutable Objects** You may have wondered about the `withUri` and `withHost`
    methods in the preceding code example. Why do the PSR-7 interfaces not imply declare
    methods such as `setUri` or `setHost`? The answer is that all PSR-7 implementations
    are designed to be immutable. This means that objects are not intended to be modified
    after they are created. All the methods starting with `with` (and PSR-7 actually
    defines a lot of them) are designed to return a copy of the original object with
    one modified property. So basically, instead of modifying objects with setter
    methods, you''ll be passing around clones of an original object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// using mutable objects (not supported by PSR-7)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$uri->setHost(''foobar.com'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// using immutable objects`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$uri = $uri->withHOst(''foobar.com'');`'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Middleware is one of the most important features of the Slim framework and
    similar libraries. It allows you to modify an HTTP request before it is passed
    to the actual request handler, modify an HTTP response after being returned from
    the request handler, or bypass a request handler entirely. There are quite a number
    of possible use cases for this:'
  prefs: []
  type: TYPE_NORMAL
- en: You can handle authentication and authorization in middleware. Authentication
    encompasses identifying a user from given request parameters (maybe the HTTP request
    contains an authorization header or a cookie with a session ID) and authorization
    involves checking if the authenticated user is actually allowed to access a particular
    resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement a rate limiting for your API by counting requests by a particular
    user and returning with an error response code early before hitting the actual
    request handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, all kinds of operations that enrich a request with additional data
    before being processed by the request handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware is also chainable. The framework can manage any number of middleware
    components, and an incoming request will be piped through all registered middleware.
    Each item of middleware must be callable as a function and accept a `RequestInterface`,
    a `ResponseInterface`, and a function that represents the next instance of middleware
    (or the request handler itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows middleware that adds an (admittedly extremely
    simple) HTTP authentication to an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `$app->add()` function can be used to register middleware that will be invoked
    on any request. As you can see, the middleware function itself looks similar to
    a regular request handler, with the only difference being the third parameter,
    `$next`. Each request can be passed through a potentially indeterminate amount
    of middleware. The `$next` function gives a component of middleware control over
    whether a request should be passed to the next component of middleware in the
    chain (or the registered request handler itself). It is important to note, however,
    that the middleware does not have to call the `$next` function at any time. In
    the preceding example, an unauthorized HTTP request will never even get through
    to the actual request handler, because the middleware that handles authentication
    does not invoke `$next` at all when there is no valid authentication.
  prefs: []
  type: TYPE_NORMAL
- en: This is where PSR-7 comes into play. Because of PSR-7, you can develop and distribute
    middleware and they will work with all frameworks and libraries that also implement
    PSR-7\. This guarantees interoperability between libraries and also ensures that
    there is a shared ecosystem of libraries that can be widely re-used. A simple
    Internet search for `PSR-7 middlewares` yields a plethora of libraries that you
    can use nearly out-of-the box.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will begin implementing the actual user profile service.
    As a first step, we will design the RESTful API of the service and then continue
    by implementing the designed API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to get to the actual task that we want to implement in this chapter.
    In this chapter, you will develop a RESTful Web Service using the Slim framework
    and MongoDB to access and read user profiles. In short, one of the first steps
    that you should take when designing a REST Web Service is to think about the resources
    that you want to offer to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Keeping RESTful** Be sure to design around resources whose state you modify
    with HTTP verbs such as `POST`, `PUT`, and `DELETE`. I''ve often seen HTTP APIs
    being developed around procedures, not resources, that end up in URLs such as `POST
    /users/create` or `POST /users/update` that resemble more of an RPC-based API
    design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The table that follows shows the resources and operations that we''ll be working
    with in this chapter. There are a few central resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/profiles` is a collection of all known profiles. It is read-only - meaning
    that only `GET` (and `HEAD`) operations will be allowed - and contains a collection
    of all user profiles. Users of your API should be able to filter the set by a
    set of constraints or limit the returned collection to a given length. Both filtering
    and limitations can be implemented as optional query parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`/profiles/{username}` is a resource that represents a single user. A `GET`
    request on this resource will return this user''s profile, while a `PUT` request
    will create the profile or update it if it already exists and a `DELETE` request
    will delete the profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/profiles/{username}/image` represents a user''s profile image. It can be
    set using a `PUT` operation, read with a `GET` operation, and removed with a `DELETE`
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Route** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /profiles` | Lists all users, optionally filtered by search parameters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /profiles/{username}` | Returns a single user |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT /profiles/{username}` | Creates a new user with a given username or
    updates an already existing one with that username |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE /profiles/{username}` | Deletes a user |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT /profiles/{username}/image` | Stores a new profile image for a user
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /profiles/{username}/image` | Retrieves the user''s profile image |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE /profiles/{username}/image` | Deletes a profile image |'
  prefs: []
  type: TYPE_TB
- en: One question that might arise is why this example uses a `PUT` request to create
    new profiles, and not `POST`. I've often seen `POST` being associated with *creating
    objects* and `PUT` with *updating objects* - this is an incorrect interpretation
    of the HTTP standards. Note that we're using the username as part of the profile's
    URI. This means that when creating a profile for a new user with a given user
    name, you already know which URI the resource will have after it's created.
  prefs: []
  type: TYPE_NORMAL
- en: And that is exactly what the `PUT` resource is for - ensuring that a resource
    with a given representation exists with the given URI. The advantage is that you
    can rely on `PUT` requests being idempotent. This means that a dozen identical
    `PUT` requests to `/profiles/martin-helmich` will not do any harm, while a dozen
    identical `POST` requests to `/profiles/` might very well create a dozen different
    user profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before beginning to implement your REST service, you will probably need to
    take care of some system requirements. For the sake of simplicity, we''ll be working
    with a set of linked Docker containers in this example. Start by creating a new
    container running a MongoDB instance using the official MongoDB image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the application container, you can use the official PHP image. However,
    as the MongoDB PHP driver is not part of the standard PHP distribution, you will
    need to install it via **PECL**. For this, you can create a custom **Dockerfile** to
    build your application container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, build your container and run it. Link it to the already running MongoDB
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new Apache container running PHP 7 with the current working
    directory mapped to the web server's document root. The `-p 80:80` flag allows
    the Apache container to be accessed using `http://localhost` from your browser
    or a command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the first examples in this chapter, we will be using Composer
    to manage the project''s dependencies and for automatic class loading. You can
    start with the following `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After creating the `composer.json` file, install the project's dependencies
    with `composer install`. If you are not running Composer in an environment that
    matches all specified constraints, you can add the `--ignore-platform-reqs` flag
    to the Composer command.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will be using Composer's PSR-4 autoloader with `Packt\Chp5`
    as a base namespace and all classes located in the `src/` directory. That means
    that a class such as `Packt\Chp5\Foo\Bar` needs to be defined in the file `src/Foo/Bar.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the persistence layer with MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step we''ll take in this example is to build an object-oriented model
    of the application''s domain - the user profile. In the first step, this will
    not be overly complicated. Let''s start by defining a `Profile` class with the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A username that uniquely identifies the user and can serve as a login username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A given name and a family name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of interests and hobbies that the user cares about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's birthday
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash value of the user's password, which will come in handy later when you
    want users to authenticate before editing their own profile (and keeping them
    from editing other people's profiles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be implemented as a simple PHP class. Note that the class is currently
    completely immutable, as its properties can only be set using the constructor.
    Also, this class does not contain any kind of persistence logic (meaning getting
    data from the database or putting it back). Following *Separation of Concerns*,
    modeling data and persisting it from and into a database are two different concerns
    that should be handled in different classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can model user profiles within your application - but you cannot do
    anything with them yet. Our first goal will be to store instances of the `Profile`
    class in the MongoDB database backend. This will be done in the `Packt\Chp5\Service\ProfileService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProfileService` gets an instance of the `MongoDB\Collection` class passed
    as a dependency into its constructor. This class is provided by the `mongodb/mongodb` Composer
    package and models one single MongoDB collection (although not exactly true, a
    collection is MongoDB''s equivalent to a MySQL table). Again, we follow Separation
    of Concerns: establishing the connection to the database is not the `ProfileService''s`
    concern and will be handled at a different place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a method in this service that can add new user
    profiles to the database. A fitting name for such a method is `insertProfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code example contains a private method, `profileToRecord()`,
    that converts an instance of the `Profile` class to a plain PHP array that will
    be stored as a document in the collection. This code was extracted into its own
    method, because it will be useful to have it as a re-usable function later. The
    actual insertion is performed by the collection's `insertOne` method, which takes
    a simple PHP array as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next step, let''s continue by extending the profile service with another
    method, `updateProfile`, that can - you guessed it - update existing profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter passed to the `findOneAndUpdate` method is a MongoDB query.
    It contains a set of constraints that a document should match (in this case, the
    document's `username` property being equal to whatever value `$profile->getUsername()`
    returns).
  prefs: []
  type: TYPE_NORMAL
- en: Just like SQL queries, these can get arbitrarily complex. For example, the following
    query will match all users whose given name is `Martin` and are born after January
    1st, 1980 and like either open source software or science fiction literature.
    You can find a full reference of MongoDB query selection operators at [https://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter to `findOneAndUpdate()` contains a set of update operations
    which will be applied to the first document found that matches the given query.
    In this example, the `$set` operator contains an array of property values that
    will be updated on matched documents. Just like queries, these update statements
    can get more complex. The following will update all matched users'' given names
    to `Max` and `add` music to their list of interests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a simple test script, you can now already test this profile service.
    For this, you will need to establish a connection to your MongoDB database. If
    you used the Docker commands previously, the hostname of your MongoDB server will
    simply be `db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding and updating user profiles is nice, but the profile service does not
    yet support loading those profiles back from the database. For this, you can extend
    your `ProfileService` with a few more methods. Start with a `hasProfile` method
    that simply checks if a profile for a given username exists or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `hasProfile` method simply checks if a profile for a given username is stored
    in the database. For this, the collection's `count` method is used. This method
    accepts a MongoDB query object and will return the count of all documents matching
    this constraint (in this case, the number of all documents with a given username).
    The `hasProfile` method will return true when a profile with the given username
    already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by implementing the `getProfile` method, which loads a user profile
    from the database and returns a respective instance of the `Profile` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `getProfile` method uses the collection's `findOne` method (which incidentally
    accepts the same query object), which returns the first document that matches
    the constraint (or null, when no document can be found). When no profile with
    the given username can be found, `Packt\Chp5\Exception\UserNotFoundException`
    will be thrown. The implementation of this class is left as an exercise for the
    reader. The document - if found - is then passed into the private `recordToProfile`
    method, which inverts the `profileToRecord` method that you've already implemented
    earlier. Note that all MongoDB query method do not return plain arrays as documents,
    but always returns instances of the `MongoDB\Model\BSONDocument` class. You can
    use these exactly as you would use a regular array, but can trip over it when
    type-hinting function arguments or return values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and retrieving users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have now successfully implemented the persistence logic of the profile
    REST service, you can now start implementing the actual REST Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we have used simple callback functions as request
    handlers for the Slim framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is perfectly fine for getting started quickly, but will get difficult to
    maintain as your application grows. In order to structure your application in
    a more scalable way, you can exploit the fact that a Slim request handler does
    not have to be an anonymous function, but can in fact be anything that is callable.
    In PHP, you can also make objects callable by implementing the `__invoke` method.
    You can use this to implement a request handler that can be a stateful class with
    its own properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing the request handler, though, let us take a look at the
    web service''s responses. As we have chosen JSON as our primary representation
    format, you will frequently need to convert instances of the `Profile` class to
    a JSON object - and of course also the other way around. In order to keep this
    conversion logic reusable, it is recommended that this functionality be implemented
    in a separate unit. For this, you can implement a `ProfileJsonMapping` trait as,
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the representation logic taken care of, you can now continue by implementing
    the route for getting a single user profile. In this example, we will implement
    this route in the `Packt\Chp5\Route\ShowUserRoute` class and use the `ProfileJsonMapping`
    trait shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `__invoke` method in this class has the same signature as
    the callback request handlers that you've seen in the previous examples. Also,
    this route class uses the `ProfileService` that you have implemented in the previous
    section. The actual handler first checks if a profile exists with a given username
    and returns a **404 Not Found** status code when the requested profile does not
    exist. Otherwise, the `Profile` instance will be converted to a plain array and
    returned as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now initialize your Slim application in your `index.php` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If your database still contains some test data from the previous section, you
    can now already test this API, for example, by using HTTPie.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and retrieving users](graphics/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the REST API to access user profiles
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating new user profiles (and updating existing ones), you can now create
    a new request handler class. As a `PUT` request to `/profiles/{username}` will
    either create a new profile or update an already existing one, the new request
    handler will need to do both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the `Request` class' `getParsedBody` method to
    retrieve the parsed message body. Fortunately, this method is intelligent enough
    to look at the request's `Content-Type` header and automatically choose an appropriate
    parsing method (in the case of an `application/json` request, the `json_decode`
    method will be used to parse the request body).
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the parsed message body, the `profileFromJson` method defined
    in the `ProfileJsonMapping` trait is used to create an actual instance of the
    `Profile` class from this body. Depending on whether a profile with this username
    already exists, we can then insert or update the user profile using the methods
    implemented in the `ProfileService` class. Note that depending on whether a new
    profile is created or an existing one is updated, a different HTTP status code
    is returned (`201 Created` when a new profile was created, or `200 OK` otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What about validation?** You will note that currently, you can pass literally
    anything as a body parameter and the request handler will try to save it as a
    user profile, even when necessary properties are missing or the body does not
    contain valid JSON. PHP 7''s new type safety features will give you some safety,
    as - thanks to strict typing, which is enabled with `declare(strict_types=1)`
    - they will simply throw a `TypeError` when some fields are missing in the input
    body. A more thorough implementation of input validation will be looked at in
    the *Validating input* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now connect this class with a new route in your `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, you can try to create a new user profile using HTTPie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also try to update the created profile by simply repeating the same
    PUT request with a different set of parameters. The HTTP response code (`201 Created`
    or `200 OK`) allows you to determine if a new profile was created or an existing
    one was updated.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and searching users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current state of your API allows users to read, create, and update specific
    user profiles. However, the web service is still missing functionality for searching
    the profile collection or listing all known user profiles. For listing profiles,
    you can extend the `ProfileService` class with a new function, `getProfiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you are not familiar with this syntax: the previous function is a **generator**
    function. The `yield` statement will cause the function to return an instance
    of the `Generator` class, which itself implements the `Traversable` interface
    (meaning that you can iterate over it using a `foreach` loop). This construct
    is particularly handy when dealing with large data sets. As the `find` function
    itself also returns a `Traversable`, you can stream the matching profile documents
    from the database, lazily map them to user objects, and pass the data stream into
    your request handler, without the need to put the entire collection of objects
    into memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, consider the following implementation, which works with plain
    arrays instead of generators. You will notice that, due to usage of the `ArrayObject`
    class, even the method''s interface stays the same (returning a `Traversable`).
    However, this implementation stores a list of all found profile instances within
    the `ArrayObject` instance, whereas the previous implementation only handled one
    object at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As the MongoDB API directly accepts well-structured query objects for matching
    documents instead of a custom text-based language (yes, I'm looking at you, SQL),
    you will not have to worry about injection attacks that traditional SQL-based
    systems are (not always, but often) vulnerable to. This allows our `getProfiles`
    function to accept a query object in the `$filter` argument that we simply pipe
    into the `find` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, you can extend the `getProfiles` function by adding new arguments
    for sorting the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this new function, it is easy to implement a new class, `Packt\Chp5\Route\ListProfileRoute`,
    that you can use to query the entire user collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can register the new request handler at your Slim application
    in the `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Deleting profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting user profiles should be an easy task by now. First, you''ll need a
    new method in your `ProfileService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The MongoDB collection's `findOneAndDelete` method does exactly what it promises.
    The first parameter to this function is a MongoDB query object as you have already
    used it in the previous sections. The first document matched by this query object
    will be deleted from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can implement a new request handler class that uses the profile
    service to delete a profile, if present. When trying to delete a non-existing
    user, the request handler will respond with the correct status code, **404 Not
    Found**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there is now some duplicate code in our example codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Both `ShowProfileRoute` and `DeleteProfileRoute` need to check if a user profile
    with a given username exists, and if not, return a `404 Not Found` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good use case for using middleware. As already stated in the previous
    section, middleware can either send a response to an HTTP request by itself, or
    pass the request to the next middleware component or the actual request handler.
    This allows you to implement middleware that takes the username from the route
    parameters, check if a profile exists for that user, and return an error response
    if that user does not exist. If that user does in fact exist, the request can
    be passed to the request handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All PSR-7 requests can have arbitrary attributes that can be set with `$req->withAttribute($name,
    $value)` and retrieved with `$req->getAttribute($name)`. This allows middleware
    to pass any kind of value to the actual request handler - this is exactly what
    `ProfileMiddleware` does by attaching the `profile` attribute to the request.
    The actual request handler can then retrieve the user profile, which has already
    been loaded, by simply calling `$req->getAttribute('profile')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware is registered in a similar fashion to regular request handlers.
    Each time you register a new request handler with `$app->get(...)` or `$app->post(...)`,
    this method will return an instance of the route configuration to which you can
    assign different middleware. In your `index.php` file, you can register your middleware
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering the middleware for the `GET /profiles/{username}` and `DELETE
    /profiles{username}` route, you can modify the respective route handlers to simply
    use the profile request attribute and remove the error checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for the `DeleteProfileRoute` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Validating input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When implementing the `PUT /profiles/{username}` route, you might have noticed
    that we did not pay that much attention to the validation of user inputs. To an
    extent, we can actually use PHP 7''s new strict typing for validating user inputs.
    You can activate strict typing by using a `declare(strict_types = 1)` statement
    in the first line of your code. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming, for example, that the `Profile` class'' `$givenName` parameter is
    type-hinted with `string`, the previous statement will throw a `TypeError` when
    `$json[''givenName'']` is not set. You would then be able to catch this error
    using a `try`/`catch` statement and return the appropriate **400 Bad Request**
    HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: However, this provides only rudimentary error checking, as you can only verify
    data types and cannot assert logical constraints. Also, this approach provides
    a bad user experience, as the error response will only contain the first triggered
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For implementing a more elaborate validation, you can add another middleware
    to your application (using middleware is a good choice here, because it allows
    you to keep the concern of validation logic encapsulated in a single class). Let''s
    call this class `Packt\Chp5\Middleware\ProfileValidationMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the validation middleware class, you can register it in your
    `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Streams and large files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our web service can perform the basic operations on a user profile.
    In this chapter, we will extend the user profile service to also handle a user's
    profile image. During the course of this chapter, you will learn how you can process
    even very large files using PHP streams.
  prefs: []
  type: TYPE_NORMAL
- en: Profile image upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, in a RESTful application, you can treat an image just as any other
    resource. You can create and update it using `POST` and/or `PUT` operations, and
    you can retrieve it using `GET`. The only difference is the chosen representation
    of the resource. Instead of JSON encoding using `application/json` as a Content-Type,
    you will now work with resources that have a JPEG or PNG representation, with
    their respective `image/jpeg` or `image/png` content types.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it will be useful to understand how the PSR-7 standard models
    HTTP requests and response bodies. Since technically, each message (both request
    and response) body is just a string of characters, these could be modeled as simple
    PHP strings. This works fine for the messages that you have been working with
    in the past few sections, but may present problems when working with larger messages
    (say, for example, images). This is why PSR-7 models all message bodies as streams
    that a user can read from (in case of request bodies) or write to (in case of
    response bodies). You can pipe data from a stream into a file or another networked
    stream, without ever needing to fit the entire contents into the memory of your
    PHP process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we will implement the user''s profile image as a new resource.
    A user''s profile image will have the URI, `/profiles/{username}/image`. Loading
    a user''s image will be a simple `GET` request (returning a response with the
    appropriate `Content-Type: image/jpeg` or `image/png` header and the image''s
    binary contents as message body). Updating an image will work the other way around,
    using a `PUT` request with a Content-Type header and the image contents as message
    body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by implementing a new request handler class, in which you read blocks
    from the request streams and write them into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This request handler opens a file handle for writing using `fopen(...)`, then
    reads the request body in blocks of 4 KB and writes them into the opened file.
    The advantage of this solution is that it does not really matter if the file you
    are saving is 4 KB or 400 MB. As you are only reading 4 KB blocks of the input
    at any time, you will have a more-or-less constant memory usage, independent of
    input size.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**On scalability** Storing files in the local filesystem is not very scalable
    and should only be considered as an example in this case. In order to keep this
    scalable, you could put your image directory on a network storage (for example,
    NFS) or use other distributed storage solutions. In the following section, *Using
    GridFS storage* you will also learn how to use GridFS to store files in a scalable
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, register the request handler at your Slim application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this route, find an arbitrary-sized image file on your computer
    and use the following curl command on the command line (remember; as we are using
    `profileMiddleware` for the new route, you will need to specify a user profile
    that actually exists in your database for this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, you should find a `jdoe` file in the `images/` directory
    in your project folder with the exact same contents as the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delivering profile images back to your users works in a similar way. For this,
    implement a new request handler called `Packt\Chp5\Route\ShowImageRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `mime_content_type` method to load the actual content
    type of the uploaded file. The content type is needed, because the HTTP response
    needs to contain a Content-Type header, which is in turn required by the browser
    to correctly display the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we are using the `Slim\Http\Body` class, which makes the implementation
    even easier: this class implements the PSR-7 `StreamInterface` and can be initialized
    with an open stream (which might, for example, be an open file handler). The Slim
    framework will then take care of delivering the contents of this file to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This request handler can also be registered in the `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you have uploaded a test image after implementing the `PUT` route, you can
    now test the `GET` route with the same user profile. As a curl command will only
    return a large blob of binary data, it might be preferable to visit `http://localhost/profiles/jdoe/image`
    in a browser of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using GridFS storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing user-uploaded files in the server's local filesystem is a viable solution
    for small sites. However, as soon as you feel the need to horizontally scale your
    application, you will need to look into distributed filesystems. For example,
    you could replace your user images folder with a network device that is mounted
    via the NFS filesystem. As you have already been working with MongoDB a lot in
    this chapter, in this section you will learn about GridFS. GridFS is a specification
    for storing - potentially very large - files in a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GridFS specification is simple. You will need two collections - `fs.files`
    and `fs.chunks`. The former will be used to store file metadata, while the latter
    will store the actual content of the files. Since MongoDB documents are limited
    to 16 MB by default, each stored file will be split into several *chunks* of (by
    default) 255 KB. A file document will have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A chunk document will have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that GridFS is simply a recommendation on how you can store files in a
    MongoDB database, and you would be free to implement any other kind of file storage
    in a MongoDB store. However, GridFS is a widely accepted standard, and the chances
    are good that you will find GridFS implementations for nearly every language.
    So, if you want to write files into a GridFS storage using a PHP application,
    and then read them from there using a Python program, you'll find standard implementations
    for both runtimes that you can use out-of-the-box, without having to re-invent
    the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 7, you can use the `helmich/gridfs` library for GridFS access. You can
    acquire it using Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: GridFS is oriented around buckets. Each bucket can contain an arbitrary number
    of files, and internally stores them in two MongoDB collections, `<bucket name>.files`
    and `<bucket name>.chunks`.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by modifying your application Bootstrap in your `index.php` by creating
    a new bucket for the user profile images, using the `Helmich\GridFS\Bucket` class.
    Each bucket can be initialized with a `BucketOptions` instance, in which you can
    configure several bucket options, such as the bucket name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the bucket, you can pass it as a dependency into the `ShowImageRoute`
    and `PutImageRoute` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PutImageRoute` and `ShowImageRoute` now get a GridFS bucket passed as
    a dependency. You can now adjust these classes to write uploaded files into that
    bucket. Let''s start by adjusting the `PutImageRoute` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of a GridFS bucket is described in the `BucketInterface`, which
    we are using in this example. You can now modify the `__invoke` method of `PutImageRoute`,
    to store uploaded profile images in the bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the `$req->getBody()->detach()`method to get the
    actual underlying input stream from the request body. This stream is then passed
    into the bucket's `uploadFromStream` method, together with a filename (in this
    case, simply the username) and an `UploadOptions` object. The `UploadOptions`
    object defines configuration options for the file upload; among others, you can
    specify arbitrary metadata that will be stored alongside GridFS' own metadata
    in the `<bucketname>.files` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that''s left is to adjust the `ShowProfileRoute` to also use the GridFS
    bucket. First of all, modify the class'' constructor to accept a `BucketInterface`
    as parameter, just as we did with the `PutProfileRoute`. Then, you can adjust
    the `__invoke` method to download the requested profile images from the GridFS
    bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the Bucket's `openDownloadStreamByName` method
    to find a file in the bucket by its name and return a stream object from which
    we can download the file.
  prefs: []
  type: TYPE_NORMAL
- en: The opened download stream is an implementation of the `Helmich\GridFS\Stream\DownloadStream`
    interface. Unfortunately, you cannot use this interface directly in your HTTP
    response. However, you can use the `Helmich\GridFS\Stream\Psr7\DownloadStreamAdapter`
    interface to create a PSR-7 compatible stream from the GridFS stream that you
    can use in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the basic architectural principles of
    RESTful Web Services and also how to build one on your own using the Slim framework.
    We have also had a look at the PSR-7 standard that allows you to write HTTP components
    in PHP that are portable across frameworks and become highly re-usable. Finally,
    you have also learned how to use PHP's new MongoDB extension for both direct access
    to stored collections, and also in combination with other high-level abstractions, such
    as the GridFS standard.
  prefs: []
  type: TYPE_NORMAL
- en: Both your newly acquired Slim knowledge and your understanding of the PSR-7
    standard will benefit you in the following chapter, in which you will build a
    real-time chat application using the Ratchet framework - and then use PSR-7 to
    integrate Ratchet with the Slim framework.
  prefs: []
  type: TYPE_NORMAL
