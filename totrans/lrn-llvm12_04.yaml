- en: '*Chapter 3*: The Structure of a Compiler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiler technology is a well-studied field of computer science. Its high-level
    task is to translate a source language into machine code. Typically, this task
    is divided into two parts: the frontend and the backend. The frontend mainly deals
    with the source language, while the backend is responsible for generating machine
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of a compiler, in which you will learn about the components
    typically found in a compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An arithmetic expression language, which will introduce you to an example language.
    You will learn how grammar is used to define a language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical analysis, which will discuss how you implement lexers for the language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntactical analysis, which covers how to construct a parser from grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic analysis, in which you will learn how a sematic check can be implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code generation with the LLVM backend, which will discuss how to interface with
    the LLVM backend and how you can glue all the phases together to create a complete
    compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of a compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After computers became available in the middle of the last century, it quickly
    became apparent that a more abstract language than assembler would be useful for
    programming. As early as 1957, Fortran was the first available higher programming
    language. Since then, thousands of programming languages have been developed.
    It turns out that all compilers must solve the same tasks and that the implementation
    of a compiler is best structured according to these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, a compiler consists of two parts: the frontend and the
    backend. The frontend is responsible for language-specific tasks. It reads a source
    file and computes a semantic analyzed representation of it, usually an annotated
    **abstract syntax tree** (**AST**). The backend creates optimized machine code
    from the frontend''s result. The motivation behind there being a distinction between
    the frontend and the backend is reusability. Let''s assume that the interface
    between the frontend and the backend is well defined. Here, you can connect a
    C and a Modula-2 frontend to the same backend. Alternatively, if you have one
    backend for X86 and one for Sparc, then you can connect your C++ frontend to both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend and backend have specific structures. The frontend usually performs
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The lexer reads the source file and produces a token stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parser creates an AST from the token stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The semantic analyzer adds semantic information to the AST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code generator produces an **intermediate representation** (**IR**) from
    the AST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The intermediate representation is the interface of the backend. The backend
    does the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The backend performs target-independent optimization on the IR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then selects instructions for the IR code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, it performs target-dependent optimizations on the instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it emits assembler code or an object file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, these instructions are only at a conceptual level. The implementations
    vary a lot. The LLVM core libraries define an intermediate representation as a
    standard interface to the backend. Other tools could use the annotated AST. The
    C preprocessor is a language of its own. It can be implemented as a standalone
    application that outputs preprocessed C source or as an additional component between
    the lexer and the parser. In some cases, the AST must not be constructed explicitly.
    If the language to be implemented is not too complex, then combining the parser
    and the semantic analyzer, and then emitting code while parsing, is a common approach.
    Even if a given implementation of a programing language does not explicitly name
    these components, it is good to remember that the tasks must still be done.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will construct a compiler for an expression language
    that produces LLVM IR from its input. The LLVM static compiler, `llc`, which represents
    the backend, can then be used to compile the IR into object code. It all begins
    with defining the language.
  prefs: []
  type: TYPE_NORMAL
- en: An arithmetic expression language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic expressions are part of every programming language. Here is an example
    of an arithmetic expression calculation language called **calc**. calc expressions
    are compiled into an application that evaluates the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The variables that are used in the expression must be declared with the `with`
    keyword. This program is compiled into an application, which asks the user for
    the values of the `a` and `b` variables and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are always welcome but as a compiler writer, you need a more thorough
    specification than this for implementation and testing. The vehicle for the syntax
    of the programming language is its grammar.
  prefs: []
  type: TYPE_NORMAL
- en: Formalism for specifying the syntax of a programming language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elements of a language, such as its keywords, identifiers, strings, numbers,
    and operators, are called **tokens**. In this sense, a program is a sequence of
    tokens, and the grammar specifies which sequences are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, grammar is written in the **extended Backus-Naur form (EBNF)**. One
    of the rules of grammar is that it has a left-hand side and a right-hand side.
    The left-hand side is just a single symbol called a **non-terminal**. The right-hand
    side of a rule consists of non-terminals, tokens, and meta-symbols for alternatives
    and repetitions. Let''s have a look at the grammar for the calc language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, `calc` is a non-terminal. If not otherwise stated, then the
    first non-terminal of grammar is the start symbol. The colon, `:`, is the separator
    between the left-hand side and the right-hand side of the rule. `"with"`, `","`,
    and `":"` are tokens that represent this string. Parentheses are used for grouping.
    A group can be optional or repeated. A question mark, `?`, after the closing parenthesis
    denotes an optional group. A star, `*`, denotes zero or more repetitions, while
    a plus, `+`, denotes one or more repetitions. `ident` and `expr` are non-terminals.
    For each, another rule exists. The semicolon, `;`, marks the end of a rule. The
    pipe, `|`, in the second line, denotes an alternative. Finally, the brackets,
    `[ ]`, in the last two lines denote a character class. The valid characters are
    written inside the brackets. For example, the `[a-zA-Z]` character classes matches
    an uppercase or lowercase letter and `([a-zA-Z])+` matches one or more of these
    letters. This corresponds to a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: How grammar helps the compiler writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Such grammar may look like a theoretical toy, but it is of value to the compiler
    writer. First, all the tokens are defined, which is needed to create the lexical
    analyzer. The rules of the grammar can be translated into the parser. And of course,
    if questions arise regarding whether the parser works correctly, then the grammar
    serves as a good specification.
  prefs: []
  type: TYPE_NORMAL
- en: However, grammar does not define all the aspects of a programming language.
    The meaning – the semantics – of the syntax must also be defined. Formalisms for
    this purpose were developed too, but often, it is specified in plain text, similar
    to when the language was first introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with this knowledge, the next two sections will show you how lexical
    analysis turns the input into a sequence of tokens and how grammar is coded in
    C++ for syntactical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the example in the previous section, a programming language consists
    of many elements, such as keywords, identifiers, numbers, operators, and so on.
    The task of lexical analysis is to take the textual input and create a sequence
    of tokens from it. The calc language consists of the `with`, `:`, `+`, `-`, `*`,
    `/`, `(`, and `)` tokens and the `([a-zA-Z])+` (an identifier) and `([0-9])+`
    (a number) regular expressions. We assign a unique number to each token to make
    handling them easier.
  prefs: []
  type: TYPE_NORMAL
- en: A handwritten lexer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of a lexical analyzer is often called a `Lexer`. Let''s
    create a header file called `Lexer.h` and start defining `Token`. It begins with
    the usual header guard and the required headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `llvm::MemoryBuffer` class provides read-only access to a block of memory,
    filled with the content of a file. On request, a trailing zero character (`''\x00''`)
    is added to the end of the buffer. We use this feature to read through the buffer
    without checking the length of the buffer at each access. The `llvm::StringRef`
    class encapsulates a pointer to a C string and its length. Because the length
    is stored, the string doesn''t need to be terminated with a zero character (`''\x00''`)
    like normal C strings. This allows an instance of `StringRef` to point to the
    memory managed by `MemoryBuffer`. Let''s take a look at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `Token` class contains the definition of the enumeration for the
    unique token numbers mentioned previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides defining a member for each token, we added two additional values: `eoi`
    and `unknown`. `eoi` stands for `unknown` is used in case of an error at the lexical
    level; for example, `#` is not a token of the language, so it would be mapped
    to `unknown`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the enumeration, the class has a member, `Text`, which points
    to the start of the text of the token. It uses the `StringRef` class mentioned
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for semantic processing, in that it is useful to know the identifier's
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is()` and `isOneOf()` methods are used to test if the token is of a certain
    kind. The `isOneOf()` method uses a variadic template, which allows a variable
    number of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Lexer` class itself has a similar simple interface and comes next in the
    header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Except for the constructor, the public interface only contains the `next()`
    method, which returns the next token. The method acts like an iterator, always
    advancing to the next available token. The only members of the class are pointers
    to the beginning of the input and to the next unprocessed character. It is assumed
    that the buffer ends with a terminating `0` (like a C string).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `Lexer` class in the `Lexer.cpp` file. It begins with
    some helper functions to help classify characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These functions are used to make conditions more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are not using the functions provided by the `<cctype>` standard library header
    for two reasons. First, these functions change behavior based on the locale defined
    in the environment. For example, if the locale is a German-language local, then
    German umlauts can be classified as letters. This is usually not wanted in a compiler.
    Second, since the functions have `int` as a parameter type, we must convert from
    the `char` type. The result of this conversion depends on whether `char` is treated
    as a signed or unsigned type, which causes portability problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the grammar in the previous section, we know all the tokens of the language.
    But the grammar does not define the characters that should be ignored. For example,
    a space or a new line only adds whitespace and is often ignored. The `next()`
    method begins by ignoring these characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make sure that there are still characters left to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is at least one character to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we first check whether the character is lowercase or uppercase. In this
    case, the token is either an identifier or the `with` keyword, because the regular
    expression for the identifier also matches the keyword. The common solution is
    to collect the characters that are matched by the regular expression and check
    if the string happens to be the keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The private `formToken()` method is used to populate the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check for a number. The following code is very similar to the code
    shown previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, only the tokens defined by fixed strings are left. This is done easily
    with a `switch`. Since all these tokens have only one character, the `CASE` preprocessor
    macro is used to reduce typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to check for unexpected characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Only the private helper method, `formToken()`, is still missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This private helper method populates the members of the `Token` instance and
    updates the pointer to the next unprocessed character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll have a look at how to construct a parser for syntactical
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactical analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Syntactical analysis is done by the parser, which we will implement next. Its
    base is the grammar and the lexer from the previous sections. The result of the
    parsing process is a dynamic data structure called an **abstract syntax tree**
    (**AST**). The AST is a very condensed representation of the input and is well-suited
    for semantic analysis. First, we will implement the parser. After that, we will
    have a look at the AST.
  prefs: []
  type: TYPE_NORMAL
- en: A handwritten parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface of the parser is defined in the `Parser.h` header file. It begins
    with some `include` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AST.h` header file declares the interface for the AST and will be shown
    later. The coding guidelines from LLVM forbid the use of the `<iostream>` library,
    so the header of the equivalent LLVM functionality must be included. It is required
    to emit an error message. Let''s take a look at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `Parser` class declares some private members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Lex` and `Tok` are instances of the classes from the previous section. `Tok`
    stores the next token (the look-ahead), while `Lex` is used to retrieve the next
    token from the input. The `HasError` flag indicates if an error was detected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of methods deal with the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`advance()` retrieves the next token from the lexer. `expect()` tests whether
    the look-ahead is of the expected kind and emits an error message if not. Finally,
    `consume()` retrieves the next token if the look-ahead is of the expected kind.
    If an error message is emitted, the `HasError` flag is set to true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each non-terminal in the grammar, a method to parse the rule is declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are no methods for `ident` and `number`. Those rules only return the token
    and are replaced by the corresponding token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public interface follows. The constructor initializes all the members and
    retrieves the first token from the lexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A function is required to get the value of the error flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `parse()` method is the main entry point into parsing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn to implement the parser.
  prefs: []
  type: TYPE_NORMAL
- en: Parser implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s dive into the implementation of the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the parser can be found in the `Parser.cpp` file and
    begins with the `parse()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The main point of the `parse()` method is that the whole input has been consumed.
    Do you remember that the parsing example in the first section added a special
    symbol to denote the end of the input? We'll check this here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `parseCalc()` method implements the corresponding rule. It''s worth having
    a closer look at this method as the other parsing methods follow the same patterns.
    Let''s recall the rule from the first section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The method begins by declaring some local variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first decision to be made is whether the optional group must be parsed
    or not. The group begins with the `with` token, so we compare the token to this
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we expect an identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If there is an identifier, then we save it in the `Vars` vector. Otherwise,
    it is a syntax error, which is handled separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the grammar now follows a repeating group, which parses more identifiers,
    it''s separated by a comma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: At this point, this should not be surprising to you. The repetition group begins
    with the, token. The test for the token becomes the condition of the `while` loop,
    implementing zero or more repetition. The identifier inside the loop is treated
    as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the optional group requires a colon at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the rule for `expr` must be parsed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this call, the rule has been parsed successfully. The information that
    we''ve collected is now used to create the AST node for this rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, only the error handling code is missing. Detecting a syntax error is easy
    but recovering from it is surprisingly complicated. Here, a simple approach called
    **panic mode** must be used.
  prefs: []
  type: TYPE_NORMAL
- en: In panic mode, tokens are deleted from the token stream until one is found that
    the parser can use to continue its work. Most programming languages have symbols
    that denote an end; for example, in C++, we can use `;` (end of a statement) or
    `}` (end of a block). Such tokens are good candidates to look for.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the error can be that the symbol we are looking for is missing.
    In this case, a lot of tokens are probably deleted before the parser can continue.
    This is not as bad as it sounds. Today, it is more important that a compiler is
    fast. In case of an error, the developer looks at the first error message, fixes
    it, and restarts the compiler. This is quite different from using punch cards,
    where it was important to get as many error messages as possible, since the next
    run of the compiler would only be possible on the next day.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using some arbitrary tokens, another set of tokens is used. For
    each non-terminal, there is a set of tokens that can follow this non-terminal
    in a rule. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `calc`, only the end of the input follows this non-terminal.
    Its implementation is trivial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The other parsing methods are constructed in a similar fashion. `parseExpr()`
    is the translation of the rule for `expr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The repeated group inside the rule is translated into a `while` loop. Note how
    the use of the `isOneOf()` method simplifies the check for several tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coding of the `term` rule looks the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This method is strikingly similar to `parseExpr()`, and you may be tempted to
    combine them into one. In grammar, it is possible to have one rule that deals
    with multiplicative and additive operators. The advantage of using two rules instead
    of one is that the precedence of the operators fits well with the mathematical
    order of evaluation. If you combine both rules, then you need to figure out the
    evaluation order somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement the rule for `factor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using a chain of `if` and `else if` statements, a `switch` statement
    seems more suitable here, because each alternative begins with just one token.
    In general, you should think about which translation patterns you like to use.
    If you need to change the parsing methods later, then it is an advantage if not
    every method has a different way of implementing a grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a `switch` statement, then error handling happens in the `default`
    case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We guard emitting the error message here because of the fall-through.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there was a syntax error in the parenthesis expression, then an error message
    would have been emitted. The guard prevents a second error message from being
    emitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That was easy, wasn't it? As soon as you have memorized the used patterns, it
    is almost tedious to code the parser based on the grammar rules. This type of
    parser is called a **recursive descent parser**.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive descent parser can't be constructed from all grammar
  prefs: []
  type: TYPE_NORMAL
- en: 'Grammar must satisfy certain conditions to be suitable for constructing a recursive
    descent parser. This class of grammar is called LL(1). In fact, most grammar that
    you can find on the internet does not belong to this class of grammar. Most books
    about the theory of compiler construction explain the reason for this. The classic
    book on this topic is the so-called "dragon book", *Compilers: Principles, Techniques,
    and Tools* by Aho, Lam, Sethi, and Ullman.'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract syntax tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The result of the parsing process is an `;`, denotes the end of a single statement.
    Of course, this information is important for the parser. As soon as we turn the
    statement into an in-memory representation, the semicolon is not important anymore
    and can be dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the first rule of the example expression language, then it is
    clear that the `with` keyword, the comma, `,`, and the colon, `:`, are not really
    important for the meaning of a program. What is important is the list of declared
    variables that could be used in the expression. The result is that only a couple
    of classes are required to record the information: `Factor` holds a number or
    an identifier, `BinaryOp` holds the arithmetic operator and the left-hand and
    right-hand sides of an expression, and `WithDecl` stores the list of declared
    variables and the expression. `AST` and `Expr` are only used to create a common
    class hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the information from the parsed input, tree traversal while
    using the `AST.h` header file. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It begins with the visitor interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The visitor pattern needs to know each class it must visit. Because each class
    also refers to the visitor, we declare all the classes at the top of the file.
    Please note that the `visit()` methods for `AST` and `Expr` have a default implementation,
    which does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AST` class is the root of the hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `Expr` is the root for the `AST` classes related to expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Factor` class stores a number or the name of a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, numbers and variables are treated almost identically, so we
    decided to create only one AST node class to represent them. The `Kind` member
    tells us which of both cases the instances represent. In more complex languages,
    you usually want to have different AST classes, such as a `NumberLiteral` class
    for numbers and a `VariableAccess` class for a reference to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BinaryOp` class holds the data that''s needed to evaluate an expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to the parser, the `BinaryOp` class makes no distinction between
    multiplicative and additive operators. The precedence of the operators is implicitly
    available in the tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `WithDecl` stores the declared variables and the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The AST is constructed during parsing. The semantic analysis checks that the
    tree adheres to the meaning of the language (for example, that used variables
    are declared) and possibly augments the tree. After that, the tree is used for
    code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The semantic analyzer walks the AST and checks for various semantic rules of
    the language; for example, a variable must be declared before use or types of
    variables must be compatible in an expression. The semantic analyzer can also
    print out warnings if it finds a situation that can be improved. For the example
    expression language, the sematic analyzer must check that each used variable is
    declared, because that is what the language requires. A possible extension (which
    will not be implemented here) is to print a warning message if a declared variable
    is not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantic analyzer is implemented in the `Sema` class, and semantic analysis
    is performed by the `semantic()` method. Here is the complete `Sema.h` header
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is in the `Sema.cpp` file. The interesting part is the semantic
    analysis, which is implemented using a visitor. The basic idea is that the name
    of each declared variable is stored in a set. While the set it being created,
    we can check that each name is unique and then check that the name is in the set
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the `Parser` class, a flag is used to indicate that an error occurred.
    The names are stored in a set called `Scope`. In a `Factor` node that holds a
    variable name, we check that the variable name is in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For a `BinaryOp` node, we only need to check that both sides exist and have
    been visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In a `WithDecl` node, the set is populated and the walk over the expression
    is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `semantic()` method only starts the tree walk and returns an error flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If required, much more could be done here. It would also be possible to print
    a warning message if a declared variable is not used. We leave it to you to implement
    this. If the semantic analysis finishes without error, then we can generate the
    LLVM IR from the AST. We will do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code with the LLVM backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backend's task is to create optimized machine code from an **IR** of a module.
    The IR is the interface to the backend and can be created using a C++ interface
    or in textual form. Again, the IR is generated from the AST.
  prefs: []
  type: TYPE_NORMAL
- en: Textual representation of the LLVM IR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before trying to generate the LLVM IR, we need to understand what we want to
    generate. For the example expression language, the high-level plan is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the user for the value of each variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the value of the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To ask the user to provide a value for a variable and to print the result,
    two library functions, `calc_read()` and `calc_write()`, are used. For the `with
    a: 3*a` expression, the generated IR is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The library functions must be declared, like in C. The syntax also resembles
    C. The type before the function name is the return type. The type names surrounded
    by parenthesis are the argument types. The declaration can appear anywhere in
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calc_read()` function takes the variable name as a parameter. The following
    construct defines a constant, holding `a` and the null byte that''s used as a
    string terminator in C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It follows the `main()` function. The parameter''s names are omitted because
    they are not used. Like in C, the body of the function is enclosed in braces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Each basic block must have a label. Because this is the first basic block of
    the function, we name it `entry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calc_read()` function is called to read the value for the `a` variable.
    The nested `getelemenptr` instruction performs an index calculation to compute
    the pointer to the first element of the string constant. The function''s result
    is assigned to the unnamed `%2` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the variable is multiplied by `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is printed to the console via a call to the `calc_write()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `main()` function returns `0` to indicate successful execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Each value in LLVM IR is typed, with `i32` denoting the 32-bit bit integer type
    and `i8*` denoting a pointer to a byte. IR code is very readable (maybe except
    for the `getelementptr` operation, which will be explained in detail in [*Chapter
    5*](B15647_05_ePub_RK.xhtml#_idTextAnchor079)*, Basics of IR Generation*). Since
    it is now clear what the IR looks like, let's generate it from the AST.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the IR from the AST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The interface, which is provided in the `CodeGen.h` header file, is very small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the AST contains the information from semantic analysis phase, the
    basic idea is to use a visitor to walk the AST. The `CodeGen.cpp` file is implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The required includes are at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The namespace of the LLVM libraries is used for name lookups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, some private members are declared in the visitor. Each compilation unit
    is represented in LLVM by the `Module` class and the visitor has a pointer to
    the module call, `M`. For easy IR generation, the `Builder` (of the `IRBuilder<>`
    type) is used. LLVM has a class hierarchy to represent types in IR. You can look
    up the instances for basic types such as `i32` in the LLVM context. These basic
    types are used often. To avoid repeated lookup, we cache the needed type instance,
    which can be either `VoidTy`, `Int32Ty`, `Int8PtrTy`, `Int8PtrPtrTy`, or `Int32Zero`.
    `V` is the current calculated value, which is updated through tree traversal.
    Finally, `nameMap` maps a variable name to the value that''s returned by the `calc_read()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes all the members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For each function, a `FunctionType` instance must be created. In C++ terminology,
    this is a function prototype. A function itself is defined with a `Function` instance.
    First, the `run()` method defines the `main()` function in LLVM IR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the `BB` basic block with the `entry` label and attach it to
    the IR builder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With this preparation done, tree traversal can begin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After tree traversal, the computed value is printed via a call to the `calc_write()`
    function. Again, a function prototype (an instance of `FunctionType`) must be
    created. The only parameter is the current value, `V`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The generation finishes by returning a `0` from the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A `WithDecl` node holds the names of the declared variables. First, we must
    create a function prototype for the `calc_read()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The method loops through the variable names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For each variable, a string with a variable name is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the IR code to call the `calc_read()` function is created. The string
    that we created in the previous step is passed as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned value is stored in the `mapNames` map for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Tree traversal continues with the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Factor` node is either a variable name or a number. For a variable name,
    the value is looked up in the `mapNames` map. For a number, the value is converted
    into an integer and turned into a constant value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for a `BinaryOp` node, the right calculation operation must be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, the visitor class is complete. The `compile()` method creates the
    global context and the module, runs the tree traversal, and dumps the generated
    IR to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have implemented the frontend of the compiler, from reading the
    source to generating the IR. Of course, all these components must work together
    on user input, which is the task of the compiler driver. We also need to implement
    the functions that are required at runtime. We will cover both of these in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The missing pieces – the driver and the runtime library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the phases from the previous sections are glued together by the `Calc.cpp`
    driver, which we will implement here. At this point, a parameter for the input
    expression is declared, the LLVM is initialized, and all the phases from the previous
    sections are called. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must include the required header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'LLVM comes with its own system for declaring command-line options. You only
    need to declare a static variable for each option you need. In doing so, the option
    is registered with a global command-line parser. The advantage of this approach
    is that each component can add command-line options when needed. We must declare
    an option for the input expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `main()` function, the LLVM libraries are initialized. You need
    to call `ParseCommandLineOptions` to handle the options on the command line. This
    also handles printing help information. In the case of an error, this method exits
    the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the lexer and the parser. After syntactical analysis, we check
    if errors occurred. If this is the case, then we exit the compiler with a return
    code, indicating a failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And we do the same if there was a semantic error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the driver, the code generator is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have successfully created IR code for the user input. We delegated
    the object code generation to the LLVM static compiler, `llc`, so this finishes
    the implementation of our compiler. We must link all the components together to
    create the `calc` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The runtime library consists of a single file called `rtcalc.c`. It contains
    the implementation of the `calc_read()` and `calc_write()` functions, written
    in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`calc_write()` only writes the resulting value to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`calc_read()` reads an integer number from the terminal. Nothing prevents the
    user from entering letters or other characters, so we must carefully check the
    input. If the input is not a number, we exit the application. A more complex approach
    would be to make the user aware of the problem and ask for a number again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can try out our compiler. The `calc` application creates IR from an
    expression. The LLVM static compiler, `llc`, compiles the IR as an object file.
    Then, you can use your favorite C compiler to link against the small runtime library.
    On Unix, you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you will most likely use the `cl` compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have created your first LLVM-based compiler! Please take some
    time to play around with the various expressions. Also check that multiplicative
    operators are evaluated before additive operators and that using parentheses changes
    the evaluation order, as we expect from a basic calculator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the typical components of a compiler. An
    arithmetic expression language was used to introduce you to grammar for programming
    languages. You then learned how to develop the typical components of a frontend
    for this language: a lexer, a parser, a semantic analyzer, and a code generator.
    The code generator only produced LLVM IR, and the LLVM static compiler, `llc`,
    was used to create object files from it. Finally, you developed your first LLVM-based
    compiler!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will deepen this knowledge to construct the frontend
    for a programming language.
  prefs: []
  type: TYPE_NORMAL
