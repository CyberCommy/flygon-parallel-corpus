- en: Chapter 7. Kotlin Variables, Operators, and Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the next, we are going to learn and practice the core fundamentals
    of Kotlin. In fact, we will explore the main principles of programming in general.
    In this chapter, we will focus on the creation and understanding of data itself,
    and in the next chapter, we will explore how to manipulate and respond to it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on the simplest type of data in Kotlin – variables.
    We will revisit more complex and powerful types of data in [Chapter 15,](ch15.html
    "Chapter 15. Handling Data and Generating Random Numbers") *Handling Data and
    Generating Random Numbers.*
  prefs: []
  type: TYPE_NORMAL
- en: The core Kotlin fundamentals that we'll learn about apply when working within
    classes that we inherit from (such as `Activity` and `AppCompatActivity`) and
    the classes that we write ourselves (as we will start to do in [Chapter 10,](ch10.html
    "Chapter 10. Object-Oriented Programming") *Object-Oriented Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: As it is more logical to learn the basics before we write our own classes, we
    will learn the basics and then use the extended `Activity` class, `AppCompatActivity`,
    to put this new theory into practice. We will use `Log` and `Toast` again to see
    the results of our coding. In addition, we will use more functions that we will
    write ourselves (called from buttons) as well as the overridden functions of the
    `Activity` class to trigger the execution of our code. We will save studying the
    full details on functions, however, until [Chapter 9,](ch09.html "Chapter 9. Kotlin
    Functions") *Kotlin Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: When we move onto [Chapter 10,](ch10.html "Chapter 10. Object-Oriented Programming")
    *Object-Oriented Programming*, and start to write our own classes, as well as
    gain an understanding about how classes that are written by others work, everything
    we have learned here will still apply then too.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will be comfortable writing Kotlin code that
    creates and uses data within Android. This chapter will take you through the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the jargon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning some more about code comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are variables?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different ways to declare variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The express yourself demo app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by finding out exactly what a variable is.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the jargon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, I will use simple English to explain a number of technical
    concepts. I will not ask you to read the technical explanation of a Kotlin or
    Android concept that has not been previously explained in non-technical language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A note to Java programmers who are new to Kotlin: if you have done some Java
    programming, then things are about to get weird! You might even swear that I have
    made some errors; perhaps you might even think that I have forgotten to add semicolons
    to the ends of all the lines of code! I urge you to keep reading because I think
    you will discover that Kotlin has some advantages over Java because it is more
    succinct and expressive. Learning Java still has its place because most of the
    Android API is still Java, and even if the entire Android community were to drop
    Java immediately (and they haven''t), there would still be legacy Java code for
    years to come. I won''t continually point out the differences between Java and
    Kotlin because there are so many and such an analysis is unnecessary. If you are
    interested, I recommend this article: [https://yalantis.com/blog/kotlin-vs-java-syntax/](https://yalantis.com/blog/kotlin-vs-java-syntax/).
    Ultimately, Kotlin and Java compile to the exact same Dalvik-compatible Java byte
    code. In fact, Java and Kotlin are 100% interoperable and can even be mixed together
    in a project. You can even paste Java code into a Kotlin project, and it will
    be instantly converted to Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin and Android communities are full of people who speak in technical
    terms; therefore, to join in and learn from these communities, you need to understand
    the terms that they use.
  prefs: []
  type: TYPE_NORMAL
- en: So, the approach that this book takes is to learn a concept or get a rough outline
    using entirely simple language, but at the same time introduce the jargon or technical
    terms as part of the learning.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin syntax is the way that we put together the language elements of Kotlin
    to produce code that executes. The Kotlin syntax is a combination of the words
    that we use and the formation of those words into sentence-like structures that
    is our code.
  prefs: []
  type: TYPE_NORMAL
- en: These Kotlin "words" are many in number but, taken in small chunks, they are
    certainly easier to learn than any human language. We call these words **keywords**.
  prefs: []
  type: TYPE_NORMAL
- en: I am confident that if you can read plain English then you can learn Kotlin,
    because learning Kotlin is much easier than learning to read English. So, what
    then separates someone who has finished an elementary Kotlin course such as this
    one and an expert programmer?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the exact same things that separate a student of language and
    a master poet. Expertise in Kotlin comes not in the number of Kotlin keywords
    we know how to use, but in the way that we use them. Mastery of the language comes
    through practice, further study, and using the keywords more skillfully. Many
    consider programming an art as much as a science, and there is some truth to this.
  prefs: []
  type: TYPE_NORMAL
- en: More on code comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you become more advanced at writing Kotlin programs, the solutions that you
    use to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Kotlin was designed to manage complexity by
    having us divide up our code into separate classes, usually across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code comments** are a part of the Kotlin files that do not have any function
    in the program execution itself; that is, the compiler ignores them. They serve
    to help the programmer to document, explain, and clarify their code to make it
    more understandable to themselves later, or to other programmers who might need
    to use or change it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen a single-line comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. So, anything on that line is for people only,
    whereas anything on the next line (unless it''s another comment) needs to be syntactically
    correct Kotlin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use multiple single-line comments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Refer back to this code, which tells Android to load our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, the layout will not be loaded, and the app will have a blank
    screen when run as the entire line of code is ignored by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw this in [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView
    and ScrollView"), *Beautiful Layouts with CardView and ScrollView* when we temporarily
    commented out one of the lines of code in a function.
  prefs: []
  type: TYPE_NORMAL
- en: There is another type of comment in Kotlin known as the **multiline comment**.
    The multiline comment is useful for longer comments that span across multiple
    lines and for adding things such as copyright information at the top of a code
    file. Like the single-line comment, a multiline comment can be used to temporarily
    disable code; in this case, usually across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in between the leading `/*` character and the ending `*/` character
    is ignored by the compiler. Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no limit to the number of lines in a multiline comment; the type of
    comment that is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly in the text, but you will often find
    liberally sprinkled comments within the code itself that add further explanation,
    insight, or context. So, it''s always a good idea to read all the code thoroughly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the best programmers liberally sprinkle their code with comments!
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of a **variable** as a named storage box. We choose a name, perhaps
    `variableA`. These names are the programmer's access into the memory of the user's
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Variables are values in memory that are ready to be used when necessary by referring
    to them with their name.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory has a highly complex system of addresses that, fortunately,
    we do not need to directly interact with. Kotlin variables allow us to devise
    our own convenient names for all the data that we need our app to work with. The
    operating system will, in turn, interact with the physical (hardware) memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can think of our Android device''s memory as a huge warehouse waiting
    for us to add our variables. When we assign names to our variables, they are stored
    in the warehouse, ready for when we need them. When we use our variable''s name,
    the device knows exactly what we are referring to. We can then tell it to do things,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign a value to `variableA`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `variableA` to `variableB`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the value of `variableB` and take an action based on the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a typical app, we might have a variable named `unreadMessages`; perhaps to
    hold the number of unread messages that the user has. We can add to it when a
    new message arrives, take away from it when the user reads a message, and show
    it to the user somewhere in the app's layout, so that they know how many unread
    messages they have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations that might arise can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The user gets three new messages, so add three to the value of `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user logs into the app, so use `Toast` to display a message along with the
    value stored in `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user sees that a couple of the messages are from someone they don't like
    and deletes two messages. We could then subtract two from `unreadMessages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names are arbitrary, and if you don't use any of the characters or
    keywords that Kotlin restricts, you can call your variables whatever you like.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, it is best to adopt a **naming convention** so that your
    variable names will be consistent. In this book, we will use a simple convention
    of variable names starting with a lowercase letter. When there is more than one
    word in the variable's name, the second word will begin with an uppercase letter.
    This is called **camel casing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of camel-case variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unreadMessages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contactName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFriend`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we take a look at some real Kotlin code that uses some variables, we
    need to first look at the **types** of variables that we can create and use.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hard to imagine that even a simple app will have quite a few variables.
    In the previous section, we introduced the `unreadMessages` variable as a hypothetical
    example. What if the app has a list of contacts and needs to remember each of
    their names? Then, we might need variables for each contact.
  prefs: []
  type: TYPE_NORMAL
- en: And what about when an app needs to know whether a contact is also a friend,
    or just a regular contact? We might need code that tests for friend status and
    then adds messages from that contact into an appropriate folder, so that the user
    knows whether they were messages from a friend or not.
  prefs: []
  type: TYPE_NORMAL
- en: Another common requirement in a computer program, including Android apps, is
    the right or wrong test. Computer programs represent right or wrong calculations
    using **true** and **false**.
  prefs: []
  type: TYPE_NORMAL
- en: To cover these and many other types of data that you might want to store or
    manipulate, Kotlin uses variables of different **types**.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of variables, and we can even invent our own types as well.
    But, for now, we will look at the most commonly-used Kotlin types, and these will
    cover just about every situation that we are likely to run into. The best way
    to explain types is through a number of examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed the hypothetical `unreadMessages` variable. This variable
    is, of course, a number.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the hypothetical `contactName` variable will hold the characters
    or letters that make up a contact's name.
  prefs: []
  type: TYPE_NORMAL
- en: The type that holds a regular number is called an **Int** (an abbreviation of
    integer) type, and the type that holds name-like data is called a **String**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the types of variables that we will use in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int`: The `Int` type is for storing integers and whole numbers. This type
    can store values with a size that is in excess of 2 billion, including negative
    values too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Long`: As the name suggests, `Long` data types can be used when even larger
    numbers are needed. A `Long` variable can store numbers up to 9,223,372,036,854,775,807\.
    That''s a lot of unread messages. There are plenty of uses for `Long` variables,
    but if a smaller variable will do, we should use it because our app will use less
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`: This variable is used for floating point numbers. That is, numbers
    where there is precision beyond the decimal point. As the fractional part of a
    number takes memory space just as the whole number part, the range of a number
    that is possible in a `Float` variable is, therefore, decreased compared to non-floating-point
    numbers. So, unless our variable will use the extra precision, `Float` will not
    be our data type of choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double`: When the precision in a `Float` variable is not enough, we have `Double`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`: We will be using plenty of Booleans throughout the book. The `Boolean`
    variable type can be either `true` or `false`; nothing else. Booleans answer questions,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the contact a friend?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any new messages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are two examples of Booleans enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Char`: This stores a single alphanumeric character. It''s not going to change
    the world on its own, but it could be useful if we put lots of them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`: Strings can be used to store any keyboard character. It is similar
    to a `Char` variable but of almost any length. Anything from a contact''s name
    to an entire book can be stored in a single `String`. We will be using Strings
    regularly, including in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class`: This is the most powerful data type and we have already discussed
    it a little. We will take a deep dive into classes in [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Array`: This type comes in lots of different flavors and is key for handling
    and organizing large sets of data. We will explore the variations of `Array` in
    [Chapter 15](ch15.html "Chapter 15. Handling Data and Generating Random Numbers")*,
    Handling Data and Generating Random Numbers.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know what variables are and that there is a wide selection of types,
    we are nearly ready to see some actual Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use a variable type that we just discussed, we must **declare**
    them, so that the compiler knows they exist, and we must also **initialize** them,
    so they hold a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the variable types in Kotlin, such as `Int`, `Float`, and `String`,
    there are two keywords that we can use to declare them: `val` and `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `val` type is for storing values that are decided by the programmer before
    the application starts or during initialization and cannot be changed again during
    execution. The `var` type is for values that can be manipulated and altered throughout
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `val` type is only readable. In technical terms, it is known
    as **immutable**. The `var` type is readable and writeable, and this is called
    **mutable**. Writing code that attempts to change the value of a `val` type during
    execution will cause Android Studio to show an error and the code will not compile.
    There are also rules for `var` that we will explore later.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the two ways that we can declare and initialize a `String` type;
    first, by using `val`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, a new `val` variable named `contactName` and
    of type `String` is declared and now holds the `Gordon Freeman` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `Gordon Freeman` text is now the only value that `contactName`
    can hold for the duration of the app''s execution. You could attempt to change
    it with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what you will see if you paste the preceding code into the `onCreate`
    function in an Android project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring and initializing variables](img/B12806_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Android Studio is helping us to enforce our decision to make the variable **constant**.
    Of course, we will frequently need to change the value held by a variable. When
    we do, we will use `var` instead; take a look at the next two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use `var` to declare a `String` type, and this time
    we successfully change the value held by `contactName` to `Alyx Vance`.
  prefs: []
  type: TYPE_NORMAL
- en: The point to take away here is that if the variable does not need to change
    during the execution of the app, then we should use `val`, because the compiler
    can help to protect us from making mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare and initialize some different types of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the previous code, I declared variables as `val` when they are
    unlikely to change and as `var` when it is likely that they will change. As you
    develop your app, you can guess whether to use `val` or `var` and, if necessary,
    you can change a `var` variable to a `val` variable, or the other way around.
    Also, in the preceding code notice that `String` types are initialized with the
    value between speech marks but `Int`, `Float`, `Long`, and `Boolean` are not.
  prefs: []
  type: TYPE_NORMAL
- en: Saving keystrokes with type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin was designed to be as succinct as possible. It was one of the aims of
    the JetBrains team to let developers get as much done with as little code as possible.
    We will see examples of this throughout the Kotlin language. If you have previously
    coded in another language, especially Java, you will notice a significant reduction
    in typing. The first example of this is **type inference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin can often infer the type you need from the context, and if this is the
    case, then you don''t need to write the type explicitly; consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a `String` type called `contactName` is declared and
    initialized using "Xian Mei". If you think about it for a moment, it must be a
    `String`. Fortunately, this is obvious to the Kotlin compiler too. We could (and
    should) improve the preceding line of code using type inference, such as with
    this next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The colon and the type have been omitted, but the result is identical.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java programmers will also notice that Kotlin code does not need to have a
    semicolon at the end of each line. If you like semicolons, however, the compiler
    will not complain if you do add one to the end of each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We must remember, however, that although we haven''t specified `String` explicitly,
    it is still a `String` type – and only a `String` type. If we try to do something
    unsuitable for a `String` type, then we will get an error; for example, as we
    do when we try to reinitialize it to a number value as in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be flagged in Android Studio and compilation won''t
    work. Here are all the declarations and initializations from the previous section
    of code, but this time using type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will see more type inference with variables in the next two sections, and
    in later chapters, we will use type inference with more complex types such as
    classes, Arrays, and Collections. Type inference will also become a good timesaver,
    by making our code shorter and more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might sound obvious, but it is worth mentioning that if you are declaring
    a variable for initialization later then type inference is not possible, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code will cause an error and the app will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using type inference, it will usually be obvious what type a variable
    is but, if there is ever any doubt, you can select a variable in Android Studio
    and press *Shift* + *Ctrl* + *P* simultaneously to get a handy onscreen hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving keystrokes with type inference](img/B12806_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Omitting the occasional `String`, `Int`, or colon (`:`) type isn't going to
    change much on its own, so let's learn how to make **expressions** with our variables
    by combining them with **operators**.
  prefs: []
  type: TYPE_NORMAL
- en: Operators and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, in almost any program, we are going to need to "do things" with these
    variables' values. We can manipulate and change variables with operators. When
    we combine operators and variables for a result, it is called an expression.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections list the most common Kotlin operators that allow us to
    manipulate variables. You do not need to memorize them as we will look at every
    line of code as and when we use them for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw the first operator when we initialized our variables in the previous
    section, but we will see it again being a bit more adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes the variable to the left of the operator the same as the value to
    the right; for example, as in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After the previous line of code has executed, the value stored in `unreadMessages`
    will be the same as the value stored in `newMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: The addition operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the addition operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It will add together values on either side of the operator. It''s usually used
    in conjunction with the assignment operator. For example, it can add together
    two variables that have numeric values, as in this next line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the previous code has executed, the sum of the values held by `newMessages`
    and `unreadMessages` will be stored in `unreadMessages`. As another example of
    the same thing, take a look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it is perfectly acceptable (and quite common) to use the same variable
    simultaneously on both sides of an operator.
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the subtraction operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It will subtract the value on the right side of the operator from the value
    on the left. This is usually used in conjunction with the assignment operator,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of the subtraction operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After the previous line of code has executed, `accountBalance` will hold its
    original value minus whatever the value held in `withdrawals` is.
  prefs: []
  type: TYPE_NORMAL
- en: The division operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the division operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It will divide the number on the left by the number on the right. Again, it''s
    usually used in conjunction with the assignment operator; here is an example line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If, in the previous line of code, `numSweets` held nine and `numChildren` held
    three, then `fairShare` would now hold the value of three.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the multiplication operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will multiply variables and numbers together and, as with many of the other
    operators, is usually used in conjunction with the assignment operator; for example,
    look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of the multiplication operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After the previous two lines of code have executed, `answer` holds the value
    100, and `biggerAnswer` holds the value 1000.
  prefs: []
  type: TYPE_NORMAL
- en: The increment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the increment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The increment operator is a quick way to add one to something. For example,
    take a look at this next line of code, which uses the addition operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line of code has the same result as this much more compact code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The decrement operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the decrement operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The decrement operator (as you have you probably guessed) is a quick way to
    subtract one from something. For example, take a look at this next line of code,
    which uses the subtraction operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code is the same as `myVariable --.`
  prefs: []
  type: TYPE_NORMAL
- en: Now we can put this new knowledge into a working app.
  prefs: []
  type: TYPE_NORMAL
- en: The express yourself demo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try using some declarations, assignments, and operators. When we bundle
    these elements together into some meaningful syntax, we call it an **expression**.
    Let's write a quick app to try some out. We will then use `Toast` and `Log` to
    check our results.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Express Yourself`, use an **Empty Activity** project
    template, and leave all the other options in their usual settings. The completed
    code that we will write in this project can be found in the `Chapter07` folder
    of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **MainActivity** tab in the editor and we will write some code.
    In the `onCreate` function, just before the closing curly brace (`}`), add this
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have just added four variables to the `onCreate` function. The first two
    are `val` variables that cannot be altered. They are a `String` type that holds
    a person's name and an `Int` type holding a year of birth. The types are not explicitly
    mentioned in the code; they are inferred.
  prefs: []
  type: TYPE_NORMAL
- en: The next two variables are `var` variables. We have an `Int` type to represent
    the current year, and an `Int` type that is uninitialized to represent the age
    of a person. As the `age` variable is uninitialized, its type cannot be inferred,
    and so we must specify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the previous code, still inside `onCreate`, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and notice the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `$` symbol in the speech marks of the `Log.i…` code indicates
    to the compiler that we want to output the *value stored in* the `age` variable,
    not the literal word "age".
  prefs: []
  type: TYPE_NORMAL
- en: The actual value itself (76), indicates that the value stored in `yearOfBirth`
    (1943) was subtracted from the value stored in `currentYear` (2019), and the result
    was used to initialize the `age` variable. As you will see, we can include as
    many `$` symbols in speech marks as we like and mix them with text and even Kotlin
    expressions. This feature is known as **String templates**. Let's try another
    String template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these two lines of code after the previous code inside the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to explain about the code is that although it is formatted as
    four lines in this book, when you enter it into Android Studio it must be entered
    as two. The first line, `currentYear++`, increments (adds one) to the value stored
    in `currentYear`. All the rest of the code is one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and observe the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works because of Kotlin String templates. Let''s break down this rather
    long line of code. First, we call the `Log.i` function as we have done many times
    before. In the first String, we pass `"info"` and, in the second, we pass a selection
    of variable names preceded by the `$` symbol mixed up with some literal text.
    The most interesting part of the breakdown is the second to last part as we use
    an expression to form part of the String:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$name` prints Nolan Bushnell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Was born in` is literal text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$yearOfBirth` prints 1943'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The literal text, `and is`, follows next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$currentAge` prints 76'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, follows the literal text of `years old`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The literal text, `Next year he will be`, follows next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${currentYear - yearOfBirth}` is an expression, and the result of the expression
    (77) is printed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final literal text, `years old`, is printed to conclude the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This demonstrates that we can include any valid Kotlin expression inside a
    `String` type using the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${expression}`'
  prefs: []
  type: TYPE_NORMAL
- en: We will see more complex and powerful expressions in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the fundamental building blocks of data in
    Kotlin. We have explored the different types and an overview of their different
    uses. We have also learned how to use String templates to build Strings from literal
    values, variables, and expressions. We also saw how we can and should use type
    inference to make our code more concise when possible.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't see much of the Boolean variable type, but we will right that wrong
    in the next chapter when we learn about Kotlin decisions and loops.
  prefs: []
  type: TYPE_NORMAL
