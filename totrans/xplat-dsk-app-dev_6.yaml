- en: 'Creating a Screen Capturer with NW.js: Enhancement, Tooling, and Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In[Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml), *Creating a Screen
    Capturer with NW.js, React, and Redux â€“ Planning, Design, and Development,*
    we applied the Redux store to manage the application state. Now, we are going
    to get a look at how to use middleware for tooling Redux and how to unit-test
    Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of this chapter though is to eventually teach our Screen Capturer
    to take screenshots and record screencasts. For that, you will learn how to use
    WebRTC APIs to capture and record a media stream. We will examine generating a
    still frame image from the stream by using canvas. We will put in practice the
    Notification API to inform the user about actions performed regardless of what
    window is in focus. We will add a menu to the system tray and bind it with the
    application state. We will make capturing action available via global keyboard
    shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml)*,* *Creating a* *Screen
    Capturer with NW.js, React and Redux Planning, Design and Development,* you have
    learned the essentials of the Redux state container. We built a functional prototype
    using Redux. However, when building your own application, you may need to know
    when and what is happening to the state tree exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Redux accepts middleware modules to deal with cross-cutting concerns.
    The concept is pretty similar to the one of the Express framework. We can extend
    Redux by hooking third-party modules on the event when an action gets dispatched
    but hasn''t yet reached the reducers. It doesn''t make much sense to write a custom
    logger as many are already available ([http://bit.ly/2qINXML](http://bit.ly/2qINXML)).
    For example, for tracing changes in the state tree, we can use the `redux-diff-logger`
    module that reports only the state diffs, which makes it much easier to read.
    So, we will install the package (`npm i -S redux-diff-logger`) and add a few lines
    to the entry script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we export `logger` from `redux-diff-logger` and pass it in the `applyMiddleware`
    function of the `redux` module to create a store enhancer. The store enhancer
    applies a given middleware to the `dispatch` method of the store. With the `compose`
    function of `redux`, we can combine multiple enhancers. We pass the derivative
    as the second argument to the `createStore` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build the project and start it up. We play a bit with the UI and
    take a look in DevTools. The JavaScript console panel will output the state diffs
    we caused:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/091a0e4d-93e6-4501-85c6-264ce2f96794.png)'
  prefs: []
  type: TYPE_IMG
- en: Though the redux-diff-logger middleware we receive reports in the JavaScript
    console of DevTools as we perform any action causing state change. For example,
    we modified screenshot filename template and that immediately reflected in the
    console. In fact we received a whole new object for the state tree, but redux-diff-logger
    is smart enough to show us only what really interested in - the diff of the state.
  prefs: []
  type: TYPE_NORMAL
- en: Redux DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logging reports is already something, but it would be more useful if we could
    get a tool like `DevTools` to interact with the state. Third-party package `redux-devtools`
    brings in an extensible environment, which supports state live-editing and time
    traveling. We will examine it in conjunction with two additional modules, `redux-devtools-log-monitor`
    and `redux-devtools-dock-monitor`. The first allows us to inspect the state and
    time travel. The second is a wrapper that docks the Redux DevTools UI to window
    edges when we press the corresponding hot-key. To see it in action, we create
    a new component out of custom describing DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/DevTools.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use the `createDevTools` function to create the component. It takes in JSX,
    where we configure visibility and the position of React DevTools UI through the
    props of `DockMonitor` and color theme in `LogMonitor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The derived component exposes the method instrument, which returns as a store
    enhancer. So, we can pass it to the compose function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `DevTools` component itself, we have to add it to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the application, we can see the dock. We can press *Ctrl*
    + *Q* to change its position and *Ctrl* + *H* to hide or to show it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c456a00f-2cb4-469b-afc5-2ae172e74f5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit-testing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already fiddled with the Jest testing framework in [Chapter 4](96f22864-d4f7-488d-b0fe-5451fd997e3d.xhtml)*,
    Chat System with Electron and React: Enhancement, Testing, and Delivery (Writing
    Unit-tests section)*. Redux introduces new concepts, such as actions and reducers.
    Now, we are going to unit-test them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, to run Jest, we need to configure Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.babelrc`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, with `env` preset, we target Babel on Node.js 7 and enable the extra
    plugins we used in the webpack configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Testing action creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actually, that''s quite simple with action creators because they are pure functions.
    We pass in an input according to the function interface and verify the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Actions/index.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written a test for the `toggleRecording` function. We assert the fact
    that the function produces an action object with `{ toggle: FLAG }` in the payload.
    As mentioned in the previous chapter, any action is supposed to have a mandatory
    property `type`. When we omit the description while calling the `createAction`
    function of the `redux-act` module, the derived action creator will produce an
    action with dynamically generated identifiers, which is hardly testable. However,
    we give it a string as the first argument, for example, `TOGGLE_RECORDING`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7eb9fa04-1fae-442a-99ed-0d4d87e6d374.png)'
  prefs: []
  type: TYPE_IMG
- en: Pretty much the same way we can test every action creator in our current application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reducers, as well as action creators, are pure functions. They accept the last
    state tree object and the dispatched action in parameters and produce a new state
    tree object. So, when testing a reducer, we are checking whether a given action
    modifies the state as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Reducers/index.spec.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the very first time, Redux calls our reducer with the `undefined` state.
    What we expect from the reducer is to take a predefined object as the default
    state. So, if we call the function with no arguments, it is supposed to receive
    at entry point the default state and return it without modifications as no action
    was given.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can import an action creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an action and pass it to the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we test that the reducer produces a new state, changed in accordance
    with the given action. An action is created by calling `toggleRecording( true
    )` is supposed to set the state object property `isRecording` to true. That is
    what we assert in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95b08e9c-3e88-4333-8261-c2dcc9ea0693.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking a screenshot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previously created static prototype may look fancy, but is not of much use.
    We need a service capable of taking screenshots and recording screencasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it was about a screenshot of the application window, we would simply use
    the API on NW.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But we need a screenshot of the screen and, therefore, we have to get access
    to display input. W3C includes a specification draft, "Media Capture and Streams"
    ([http://bit.ly/2qTtLXX](http://bit.ly/2qTtLXX)), which describes an API to capture
    displayed media (`mediaDevices.getDisplayMedia`). Unfortunately, at the time of
    writing, it's not yet supported in NW.js or, to be honest, by any browser. However,
    we can still use `webkitGetUserMedia`, which streams the desktop input. This API
    was once a part of technology known as WebRTC ([https://webrtc.org](https://webrtc.org)),
    designed for real-time video, audio, and data communication.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, currently, it is removed from the specification, but still available in
    both NW.js and Electron. It seems like we don't really have a choice, so we go
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '`webkitGetUserMedia` takes in the so-called `MediaStreamConstraints` object
    describing what we want to capture and returns a promise. In our case, the constraints
    object may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We disable audio recording, set boundaries for video (`webkitGetUserMedia`
    determines a suitable size based on your display resolution. When the resolution
    does not fit the range it causes `OverconstrainedError`), and describe the media
    source. But we need a valid media stream ID. That we can obtain, for example,
    from the NW.js API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When combining all together, we get the following service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Capturer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When running it, we get a dialog prompting us to choose a media source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa06bcfb-2640-4c53-afc2-26fd0d0d16ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I do not really like this UX. I would rather make it detect desktop media.
    We achieve that with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `DesktopCaptureMonitor` of the NW.js API for detecting available media
    devices, rejecting an app window (the type `"screen"`), and obtaining the media
    stream ID with the method `registerStream`. Now, we replace the `chooseDesktopMedia`
    of the NW.js API with our custom method, `detectDesktopStreamId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Well we manage to receive the stream. We have to direct it somewhere. We can
    create a hidden `HTMLVideoElement` and use it as a video stream receiver. We encapsulate
    this functionality in a separate module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Capturer/Dom.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'During construction, the class creates a new DIV container and video element
    in it. The container gets attached to the DOM. We also need to support the new
    elements with CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./assets/main.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we move the container out of view. So, the video will be streamed
    into a hidden `HTMLVideoElement`. The task is now to capture a still frame and
    convert it into an image. That we can do with the following trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We create a canvas context matching the video size. By using the context method
    `drawImage`, we draw an image from the video stream. Finally, we convert canvas
    to Data URI and obtain the Base64-encoded image by striping the `data:scheme`
    prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to inject our `Dom` module instance in the `Capturer` service
    as a dependency. For that, we need to modify the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Capturer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to forward the media stream into `HTMLVideoElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a method for saving screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when this method is called in a component, the image gets saved silently.
    To tell the truth, it''s not very user-friendly. A user presses the button and
    receives no information about whether the image really is saved or not. We can
    improve user experience by showing a desktop notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the newly created screenshot is saved, the corresponding message
    gets displayed at the system level. So, even if the application window is hidden
    (for example, we use system tray or a shortcut), the user still receives a notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a04c0844-73e1-4232-a379-d2115a19b210.png)'
  prefs: []
  type: TYPE_IMG
- en: Recording a screencast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In fact, while building the service for taking screenshots, we have done most
    of the work for screencast recording. We already have the `MediaStream` object
    delivered by `webkitGetUserMedia`. We just need a way to define the start and
    end of recording and save the collected frames in a video file. That is where
    we can benefit from the `MediaStream` Recording API, which captures the data produced
    by `MedaStream` or `HTMLMediaElement` (for example, `<video>`) so that we can
    save it. So, we modify the service again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Capturer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After receiving `MediaStream`, we use it to make an instance of `MediaRecorder`.
    We subscribe for the `dataavailable` event on the instance. The handler accepts
    a Blob (a file-like object representing a frame of the stream). To make a video,
    we need a sequence of the frames. So, we push every received Blob into the chunks
    array. We also subscribe a handler for the stop event, which creates a new Blob
    of the type `webm` from the collected chunks. Thus, we have a Blob representing
    the screencast, but we can't just save it in a file.
  prefs: []
  type: TYPE_NORMAL
- en: For a stream of binary data, Node.js will expect from us an instance of the
    Buffer class. We use the `blob-to-buffer` package to convert Blob to Buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we rely on two events, `dataavailable` and `stop`. The first
    one gets fired when we start the recorder and the second when we stop it. These
    actions we make public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the method `record` is called, the instance of `MediaRecorder` starts recording
    and, on the contrary, with the `stop` method, it ceases the process. In addition,
    we define `saveAnimationBuffer` callback that will be called when recording stops
    (`this.mediaRecorder.onstop`) . The callback (`saveAnimationBuffer`) receives
    with the `buffer` parameter the binary stream of the recorded screencast and saves
    it with the `writeFileSync` method of the `fs` core module. Similar to a screenshot,
    on saving a screencast, we create a desktop notification to inform the user about
    the performed action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service is almost ready. But as you can remember from our wireframes, the
    Screen Capturer accepts a template for the filename, such as `screenshot{N}.png`
    or `animation{N}.webm`, where `{N}` is a placeholder for the file index. Therefore,
    I would like to encapsulate filesystem operations in the dedicated class, `Fsys`,
    where we can process the template as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Capturer/Fsys.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This class has the static method `getStoredFiles`, which returns an array of
    all the files of a given type (extension) from the working directory. Before saving
    a file in the `saveFile` method, we get the list of the earlier stored files and
    calculate the value for `{N}` as `files.length + 1`. Thus, the very first screenshot
    will be saved under the name `screenshot1.png`, the second as `screenshot2.png`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Fsys` instance we inject in the `Capturer` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will instantiate the service in the entry script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./func-services/js/app.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We import the `Capturer` class and the dependencies. While constructing `Capturer`,
    we pass it in the instances of `Fsys` and `Dom`. The derived instance of `Capturer`
    we pass with the props to the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the instance of the service arrives into the `ScreenshotTab` component
    and we can use it for taking a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/ScreenshotTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in `AnimationTab`, we apply the methods record and stop of the instance
    from the corresponding handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Components/AnimationTab.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after building the application, we can use it to take a screenshot and
    record screencasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad8aa105-24b3-4921-87c3-aeb3382e23f6.png)'
  prefs: []
  type: TYPE_IMG
- en: From our image, we can observe that the buttons to take screenshots and record
    screencasts are parts of the window UI. However, we also need to provide functionality
    for hiding a window. So how do we reach capturing actions while application is
    hidden? The answer is to do with system tray.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the system tray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *[Chapter 2](ed6645a7-d7e6-4322-909d-0777d9763560.xhtml), Creating a File
    Explorer with NW.js – Enhancement and Delivery* , we already examined adding and
    managing the application menu in the system tray. Briefly, we created menu items
    with `nw.MenuItem`, added them to the `nw.Menu` instance, and attached the menu
    to `nw.Tray`. So, the boilerplate for the tray menu may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Tray.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For this application, we need the following menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Start recording` and `Stop recording` get enabled depending on the state
    `isRecording` property. Besides, we need the `Capturer` instance and state properties
    `screenshotFilename` and `animationFilename` to run the capturing action on user
    request. So, we inject both dependencies in the `Tray` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Tray.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we defined a few instance properties. `screenshotFilename` and
    `animationFilename` will receive the latest user-defined filename templates from
    the state. The property `isRecording` will take in the corresponding value of
    the state when it changes. In order to receive state updates, we subscribe for
    store changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the callback, we compare the actual `isRecording` value from the state with
    the earlier store one in the instance property `isRecording`. This way, we know
    when `isRecording` has really changed. Only then, we update the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can populate the array of menu items options in the `getItems`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We use the `close` method of the application window to quit and the method `show`
    to restore the window if it is hidden. We rely on passed in the `Capturer` instance
    for capturing actions. We also update the state by dispatching (`store.dispatch`)
    the `toggleRecording` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we instantiate the `Tray` class in entry script and call it the `render`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/app.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the application, we can see in the system notification area the
    Screen Capturer menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4836b957-32a2-4321-a36b-ac46e654f3fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Registering global keyboard shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Menu in tray is a solution, but actually, we have an option to perform capturing
    actions even without opening the menu. NW.js allows us to assign global keyboard
    shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We use `nw.Shortcut` to create an object representing a shortcut. With `nw.App.registerGlobalHotKey`,
    the shortcut is registered. We use `nw.App.unregisterGlobalHotKey` to unregister
    the shortcut when the application closes or reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'That brings us to the following service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Service/Shortcut.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty much like in the `Tray` class, we inject capturer and store instances.
    With the first one, we access capturing actions, and use the second to access
    the global state. We subscribe for state changes to get actual values for filename
    templates and `isRecording`. The method `registerOne` creates and registers a
    shortcut instance based on the given key and callback, and subscribes for the
    `close` and `beforeunload` events to unregister the shortcut. In the method `registerAll`,
    we declare our action shortcuts. The shortcuts key we will define in the constants
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./js/Constants/index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also append the keys to tray menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the application, we get the following tray menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e00b57cc-45e1-4a7e-a4ec-d03d2b714f29.png)'
  prefs: []
  type: TYPE_IMG
- en: We can hide the application by hitting the Hide window (left hand-side) button
    of the title bar and take screenshots by pressing *Shift* + *Alt* + *4* and screencasts,
    with *Shift* + *Alt* + *5* and *Shift* + *Alt* + *6* for starting and stopping
    recording, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by introducing the Redux middleware. As an example,
    we used `redux-diff-logger` to monitor mutations in the store. We also plugged
    in a collection of tools (`redux-devtools`), enabling DevTools-like panels on
    a page for inspecting the store and traveling back in time using the cancelling
    actions. Closing with Redux, we examined unit-testing of action creators and reducers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we created the `Capturer` service responsible for taking screenshots
    and recording screencasts. We achieved capturing of desktop video input in `MediaStream`
    by using `webkitGetUserMedia` API. With the Canvas API, we managed to take a still
    frame from the video stream and convert it into an image. For video recording,
    we went with the `MediaRecorder` API. Both screenshot and screencast actions we
    have provided with the corresponding desktop notifications. We implemented an
    application menu in the system tray and bound it to the store. To access capturing
    actions even without opening the tray menu, we registered global keyboard shortcuts.
  prefs: []
  type: TYPE_NORMAL
