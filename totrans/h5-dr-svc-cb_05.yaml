- en: Chapter 5. Custom Input Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using contentEditable for basic rich text input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced rich text input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a drop-down menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating autocomplete for input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom single-selection list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multiple-selection list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geographic location input using maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we presented several different ways for getting input from the user.
    HTML5 offers many new features that enable the functionality of input components
    that was previously done with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Often, there comes the need to extend this standard functionality. In this chapter,
    we will see ways for creating some custom input components and using the already
    available ones, where we add additional functions to extend or simplify the end
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using contentEditable for basic rich text input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the new `contentEditable` attribute in HTML5, we can turn every element
    into an editable rich text field. In theory, this could enable us to write complex
    rich text editors that would work right inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, the new APIs can be used to send editing commands. This
    is done using the `document.execCommand` function, which takes a command string
    as the first argument, and options as the third.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, every browser vendor implements the interface slightly differently.
    However, most modern browsers are fully compliant.
  prefs: []
  type: TYPE_NORMAL
- en: You can test your browser's compliance at [http://tifftiff.de/contenteditable/compliance_test.html](http://tifftiff.de/contenteditable/compliance_test.html);
    however, the test doesn't take into account the possibility that some browsers
    might act differently on the same command.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to make a very simple `contentEditable` field that
    supports few commands (paragraph style, undo/redo, bold/italic/underline, bullets,
    and numbered lists).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create an HTML page with a `contentEditable` div inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to add some padding to the div to make it easier to click. Above
    the div, we''re going to place our formatting buttons and a dropdown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can make the editing controls work in our `example.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to put all our `editCommand` bindings in an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will apply them to the appropriate edit controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will define and add additional paragraph styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `document.execCommand` function allows us to send commands to the currently
    active `contentEditable` field. These commands work just as toolbar buttons would
    in a regular rich text editor. For example, the command "bold" toggles the boldness
    of the text; applied the second time, it restores the text back to its original
    state. The function takes the following three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`commandName`: This is the name of the command to execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`showDefaultUI` (`boolean`): This tells the browser if it should show a default
    user interface related to the command to the user, if such interface is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Value`: This provides an argument for the command that depends on the type
    of the command. For example, bold, italic, and underline takes a `boolean` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we're not tracking the state at the current selection of cursor.
    We're going to leave that kind of tracking for a recipe where we will create a
    more advanced version of the editor. However, it's worth mentioning here that
    we can use the `document.queryCommandState` function to retrieve the state pertaining
    to the command at the current cursor position (or if there is an active selection
    of the current selection).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced rich text input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the basic `contentEditable`-based rich text input field is sufficient
    in most cases, sometimes it is not enough. We might want to allow the users to
    insert more complex objects such as images and tables.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to make an advanced rich text editor that supports
    inserting images and basic tables.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to build this editor based on the simple rich text editor demonstrated
    in the *Using contentEditable for basic rich text input* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to start with the code from the *Using contentEditable for basic
    rich text input* recipe and improve upon it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to take the original `index.html` and `example.js` files but we
    will modify the HTML file. We''re going to add two controls: a table button and
    a file picker to insert images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To add tables to our rich text, we will create a new script called `example-table.js`.
    The table button will have dual functionality. One function will be changing the
    number of rows/columns in the currently active table. If there is no active table,
    it will insert a new one with the specified number of rows and columns. The following
    is the code in `example-table.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To add images to our rich text, we will create a new script called `example-image.js`.
    The image picker will insert the user-selected image at the specified position.
    The following is the content of `example-image.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We added two new controls to the editor: the table control and the insert image
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: The table control asks the user to specify the number of rows and columns first.
    It figures out if the user is currently inside a table by inspecting the parent
    elements of the current cursor position. If a table is found, its content are
    remembered.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, a new table is constructed with the specified number of columns and
    rows. If the old table contained some content at that row/column position, that
    content is copied to the newly constructed cell. Finally, the old table is removed
    if present and the new table is added using the `insertHTML` command.
  prefs: []
  type: TYPE_NORMAL
- en: The image insertion control uses the HTML5 File API for file inputs to read
    image files selected by the user as data URLs. After reading them, it adds them
    to the content using the same `insertHTML` command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using this method, it's easy to construct new controls that add any type of
    content to the `contentEditable` field. This enables us to create custom rich
    text or page editors with specialized functionality.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the goal is to add a fully capable generic rich text editor to our
    page, we recommend using one of the many excellent editor components already available,
    such as TinyMCE ([http://www.tinymce.com/](http://www.tinymce.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a drop-down menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drop-down menus are often used in web applications to show extended functionality.
    Actions that are used less often or useful to a small number of users can be added
    to the menu, resulting with a cleaner interface.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 and CSS3 allow us to build drop-down menus written entirely in CSS. We're
    going to create such a menu in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s analyze the structure of a drop-down menu. A drop-down menu has an activation
    button that displays it and one or more items from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular (action) item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separator item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A submenu item (that activates a sub-menu)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our HTML element structure should reflect the drop-down menu structure. Our
    CSS code will control the positioning and display of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to have three buttons showing slightly different, yet structurally
    same, menus.
  prefs: []
  type: TYPE_NORMAL
- en: The first will have the default behavior—drops down, is left-aligned with a
    submenu appearing on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: The second will have a modified behavior—right-aligned with a submenu appearing
    on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third will have a very different behavior; it will come above the
    button with submenus appearing to the right-hand side, but going up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/9282OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the menu, we will use HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create the menu structures in the HTML file. Essentially, it''s
    the same structure discussed previously, copied three times with slight variations
    in styles, particularly on the unordered list elements that contain menus and
    submenus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s add the appropriate CSS for this menu in `example.css`. We''re
    going to use a `border-box` sizing model. Unlike the regular model, where the
    borders and padding are outside the specified dimensions of the element (width
    or height), in the `border-box` model the padding and borders are included in
    the specified dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to add styling to the menu items that display the dropdowns as
    well as the menu itself. By default, the inner menu is absolutely positioned below
    the rest of the content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make the menu show on hover when the button is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need submenus to be positioned relative to their parent items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll set the style of a regular items and a separator item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular submenus will be positioned slightly differently: in-line with their
    parent item but 90% from the left-hand side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we apply the specialized styles for right-aligned and roll-up menus,
    as well as submenus that are bottom-aligned with their parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To display our menus dynamically, we use the `hover` and `active` CSS pseudo-selectors.
    They enable us to style elements differently when the cursor is hovering over
    them or when the elements are marked as `active`. Putting the entire menu inside
    the menu item allows us to display it by using these selectors on the menu item.
  prefs: []
  type: TYPE_NORMAL
- en: To position the menus and submenus, we use a combination of a `position:relative`
    parent menu item and `position:absolute` submenu child items. When we use this
    combination, our child positioning attributes are relative to the first relative
    parent, namely, the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to place the menu anywhere: below the parent by default or above
    as an option (for submenus, to the right by default, to the left as an option).
    It also allows us to align the submenu any way we like: left by default, right
    as an option (for submenus, top-aligned by default, bottom-aligned as an option).'
  prefs: []
  type: TYPE_NORMAL
- en: These combinations should allow us to construct menus at arbitrary locations
    without worrying that the menu might go off-screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom dialogs can be used for all kinds of user input. We can ask the user
    to fill a form (for example, a login form can be displayed as a dialog). We can
    also use them to ask the user to accept or decline some action that requires immediate
    attention (for example, a dialog asking the user "Are you sure you want to delete
    the selected items?").
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can theoretically display any other page segment in a dialog, it would
    be great if we had a single flexible method to do it. The easiest way to attain
    flexibility is to split the dialog into three parts: view, model, and controller.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to create a general dialog. It will consist of a
    view (HTML that supports JavaScript templating), a model (available from the template),
    and a list of event bindings that make the controller.
  prefs: []
  type: TYPE_NORMAL
- en: This is an advanced recipe. If you're not familiar with **Embedded JavaScript
    Templates** (**EJS**), we recommend reading the EJS recipes in [Chapter 9](ch09.html
    "Chapter 9. Client-side Templates"), *Client-side Templates*, before reading this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom dialogs](img/9282OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use John Resig's simple implementation of EJS-like templates.
    It's a compiler that converts EJS templates to JavaScript functions. We're not
    going to explain the compiler—it's sufficient to know that it takes the ID of
    the element containing the template content and returns a template function. This
    function gives an HTML output when applied to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the template compiler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original article explaining JavaScript Micro-Templating can be found at
    [http://ejohn.org/blog/javascript-micro-templating/](http://ejohn.org/blog/javascript-micro-templating/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to write the page code and the dialog library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file named `index.html`. It will contain a secret `div` area
    and a template for a login dialog with the ability to pre-fill `username` and
    the ability to show an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how we would like the dialog API to work, we''re going to create `example.js`
    next. It will immediately show a login dialog that will close once a correct password
    is input, then the secret content will be shown. Otherwise, an error message will
    be displayed inside the dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s create `dialog.js`. It should export a function called `dialog`
    that takes three arguments: the ID of the dialog template, the data to fill into
    the template, and an object containing event bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, build the `dialog` chrome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill it with the templated HTML, set the title, and display it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the bindings that are in the `selector => event` format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the `dialog` object to return. Provide the `find()` function for fields,
    the `data()`function to extract all form data as a JSON object, as well as event
    binding and close functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will customize the positioning and style of the dialog in `dialog.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make a flexible dialog library, we split the data needed to show the dialog
    into view, model, and controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `tmpl.js` library provides a function that processes an EJS template using
    the provided model object. The innards of this function are out of the scope of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Our `dialog` function constructs a chrome containing a title bar, a Close button,
    and a form. Afterwards, it fills out the form with the template and data. Finally,
    it applies our bindings to the content of this form. The bindings are in the jQuery
    `selector => event` format and can be used to respond to any kind of user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function returns a `dialog` object (constructed in the variable self).
    The object provides the following convenience functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find`: This allows the user to find elements within the form using selectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This extracts all data inputs into the form as an easy-to-use JSON
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`: This closes the dialog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on`: This allows the user to add extra bindings (for example, the `dialog:close`
    event)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object also provides a convenience event named `dialog:close` that gets
    triggered when the dialog is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We style this dialog using `dialog.css`. The dialog is positioned with a pure
    CSS-based positioning method: using fixed-width and negative margins, we avoid
    the need to read the width of the window, and hence manage to fully avoid using
    JS.'
  prefs: []
  type: TYPE_NORMAL
- en: The flexible templating language allows us to create dialog content of any complexity,
    while the `bindings` syntax allows full control over of all user input. We can
    simplify the creation of some common dialogs by providing the template and some,
    or all, of the bindings.
  prefs: []
  type: TYPE_NORMAL
- en: With this generic method, creating simple message boxes, generic text prompts,
    or complex dialog forms with a variable number of fields are all equally easy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating autocomplete for input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common functionality usually related to search fields or input is that we
    can guess the text after typing some of the data. This can be any field that we
    have in our database such as employee names. In this recipe, we will take a look
    at some of the possible ways to create autocomplete for input; it is up to you
    to decide what is best fit for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating autocomplete for input](img/9282OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example we are going to use a sample JSON file that will simulate a
    result returned by a REST API. The file can be retrieved from the examples, and
    it's with the name `countries.json` where we have a list of objects—mapping of
    countries with their corresponding languages. In the example, we will use both
    **jQueryUI** ([http://jqueryui.com/](http://jqueryui.com/)) and a library called
    **Chosen** ([https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen)).
    Why use both? Well, we can use either of them, or none, but the idea here is to
    show different ways of creating a good user experience with list selection. Additionally,
    as we will be simulating the REST service, we need a server running; more on this
    is available in [Appendix A](apa.html "Appendix A. Installing Node.js and Using
    npm"), *Installing Node.js and Using npm*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the example, we will use HTML and accompanying JavaScript and CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first start with the `head` section and add the CSS dependencies for
    jQueryUI and Chosen. Also, we add a small CSS section in which we will define
    the size of the single selectors for Chosen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can add the body part of the HTML where we will create the form. First,
    we will create a block that will have an input text filed that shall be connected
    to a list of suggested fruits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next input field is for the selection of country, where we will be using
    the Chosen type of selector that will have auto complete as part of the control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another input element is for language selection. We are going to make it using
    the JSON data retrieved from the server, or a JSON file in our case. Also, we
    are going to add an input for occupation and a Submit button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget that this block needs to be part of a `form` in order to be submitted.
    One other option is to have the element specify a `form` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This sets who is the owner of the given element, allowing us to place the element
    anywhere in the document. The restriction here is that we can have only one form
    for a given element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next part is to include the external vendor JavaScripts for jQuery, jQueryUI
    and Chosen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can start the jQuery selections and logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable Chosen for elements, we select them and call the plugin directly
    on them; it''s as simple as that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to use the jQueryUI `autocomplete` plugin. One way is to
    have the data locally, and then apply it on some selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the configuration of the component, the `source` attribute can accept a list
    of possible string options, and the `minLength` attribute designates the minimal
    number of characters that should be inserted before the autocomplete is triggered.
    The `delay` can be set in milliseconds between a keystroke and a search on the
    source data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that setting the delay to `low` can create a bad side-effect of making
    a lot requests to the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data can also be on a remote server and retrieved as source to the plugin
    where some additional filtering can be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest case is one where we use the standard HMTL5 tags in order to get
    autocomplete. There we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This `list="fruit"` attribute connects the input filed to the `datalist`. This
    attribute is used to identify a list of predefined options that will be suggested
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other option was to use Chosen, a JavaScript plugin that enables user-friendly
    selections. This can be achieved by the following simple HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be picked up by the plugin using jQuery Selector to activate the
    plugin element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Chosen will automatically style the selection and add autocomplete, and if we
    have the `data-placeholder` attribute set, it will mimic the standard behavior
    of the HTML5 `placeholder` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, for simplicity, other countries are removed, in practical use cases
    you can use a list of countries defined in ISO 3166-1 ([http://www.iso.org/iso/country_codes.htm](http://www.iso.org/iso/country_codes.htm))
    and the corresponding Wikipedia article [http://en.wikipedia.org/wiki/ISO_3166-1](http://en.wikipedia.org/wiki/ISO_3166-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use the jQueryUI autocomplete component. That is why we
    are going to analyze in more detail an example with a server-side data source.
    There are three options to go with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side filtering**: We get the entire JSON document, or any other document
    for that matter, and we filter the data on the client side. This is generally
    a great approach if possible. This might not be the case for every situation.
    The data containing the list could be huge. Consider the autocomplete feature
    on a search engine, the possible result list is huge there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side filtering**: We get only a portion of the data filtered by some
    query parameter. The filtering is done on the server, making it slower in most
    of the cases. Making additional request adds some additional lagging even if the
    data is returned instantly without doing to much processing, which may not be
    the case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side and client-side filtering**: When working with large datasets,
    a combination of the both methods may be our best way. We could only ask the server
    for more data only if a certain threshold is met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As as side note, it is worth mentioning that if we are creating a search input
    field, it is semantically correct to use the HTML5 `input type="search"`. This
    control enables a single-line input filed and can have the `autosave` attribute
    added to enable the out-of-the-box dropdown of previously searched terms. The
    code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the data that is retrieved from the server as the user types,
    we can use a function in the `source` attribute of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `request` object, we can get the current data inserted in the `input`
    element via the `request.term` attribute. We can then create a regex matcher if
    we like to filter the data on the client side like in our case, as we always will
    access the same JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we read the data using an Ajax call to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that most of the REST API''s have their own functionality for filtering
    usually via `request` parameters, in our case we don''t have that, but to illustrate
    we could easily do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So the callback function receives the JSON data, but as we get all the data
    unfiltered, we do that using `jQuery.map( arrayOrObject, callback( value, indexOrKey
    ) )` that translates all the items in the new array from the original array of
    objects following the rules defined in the `callback` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the JSON has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to filter the data using the `language` names, we should return a
    sublist of those objects that match our criteria defined in the `matcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the result returned has the `label` and `value` properties;
    this is because it is one of the possible formats for the `source` where we have
    an array of objects like these.
  prefs: []
  type: TYPE_NORMAL
- en: If we are to compare the jQueryUI method of handing data versus the Chosen library,
    we can conclude that jQueryUI is more flexible when working with different data
    sources. On the other hand, Chosen, in a way, just styles the standard HTML elements
    and is more compliant than doing clever hacks. Additionally, Chosen is very focused
    on doing few things very nicely, and makes a great user experience while not having
    the baggage that comes with a size-heavy library such as jQueryUI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `list` attribute can be used on all input types except for `hidden`, `checkbox`,
    `radio`, `file`, or `button` types where it gets ignored. When you think about
    it, it makes a lot sense not to work those types because there is not much practical
    use in having autocomplete on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to have the same behavior on older browsers, or to have a fallback
    mode, we can place that content in the `datalist` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This data will not be displayed if the `datalist` element is supported, enabling
    us to add support for legacy browsers.
  prefs: []
  type: TYPE_NORMAL
- en: There are various other data sources that can be used with jQueryUI autocomplete,
    such as JSONP or XML, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom single-selection list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used Chosen. In this recipe, we will take a deeper
    look into the creation of simple select boxes, making one the most user-friendly
    way pickers out there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use Chosen ([https://github.com/harvesthq/chosen](https://github.com/harvesthq/chosen))
    and its dependency jQuery by adding them from a CDN.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create an HTML file and the accompanying JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will start with the head section of the HTML, where we will include
    the Chosen CSS style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to create a simple form where the user can select their favorite
    programming language and job title. To do that, we add `select` elements with
    several available options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The possible options can be grouped using the `optgroup` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And at last, we just add a simple submit for the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to include Chosen, we add their implementation from a CDN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To designate to what element should have Chosen applied, we use jQuery selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best thing about Chosen is its simplicity; we just select the elements
    with jQuery and apply the plugin. There is an option allowing deselect that we
    can enable during creation of these kind of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Chosen can be used with **Prototype JS** instead of jQuery; there
    the selection of elements would be `new Chosen(someElement);`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can add an attribute named `data-placeholder` that will contain default
    text, such as `Occupation`, as in our example. If this is not specified, it will
    default to `Select Some Option` for single select.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On `select` elements, the browser assumes the first element to be selected if
    `selectedIndex` is not specified or if there is no option with the `selected`
    attribute. In order to allow none selected, we can set the first option blank,
    thus enabling the `data-placeholder` text support.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to use data for the options that will change after the initial
    creation of Chosen, you can update the component dynamically and then trigger
    the `liszt:updated` event on the selected field. The `liszt:updated` event is
    a Chosen-specific internal event. Chosen, after calling the event, will rebuild
    the list based on the updated content. For example, on an element with ID as `countries`,
    the triggering would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Creating a multiple-selection list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chosen can be used to create beautiful-looking multiple selections. In this
    recipe, we will create a form for a menu ordering that uses this type of selections
    in a form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a multiple-selection list](img/9282OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will contain the same parts as *Creating a custom single-selection
    list*, and build upon them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by having the same base as *Creating a custom single-selection list*,
    and add the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the selections that will have the `drop-down` CSS class we created
    in the head section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use grouping of the options for the `select` element having sections,
    such as `Starters` and `Pizza`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply select all elements that have the `drop-down` CSS class and enable Chosen
    for them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Painless setup is one of the main features for Chosen so the JavaScript part
    is fairly simple because we only have a basic selection of elements. Options can
    be selected before the page is rendered to the user by having the `selected` attribute
    on options, such as `Mojito`. They can also be disabled from selection by using
    the `disabled` attribute, so in our case, the option `Long Island Iced Tea` will
    not appear in the selection.
  prefs: []
  type: TYPE_NORMAL
- en: Optgroups, selected states, multiple attributes, as well as other attributes
    are respected just like the standard HTML5 behavior. This means that we are not
    required to expect something special or do some customization on the server side
    handling for the forms.
  prefs: []
  type: TYPE_NORMAL
- en: Geographic location input using maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the introduction of the HTML5 geolocation API, reading the user's location
    became much simpler. However, sometimes we might want to allow the user to correct
    or verify his location or to specify a location different than their own.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to make a location input that allows the user to
    specify a location by marking it on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Our location picker will be represented as a link. Upon clicking the link, the
    user will have the option to search for their location using an input field, and
    then select the location by clicking on the map.
  prefs: []
  type: TYPE_NORMAL
- en: As with all our map recipes, we're going to use the popular Leaflet ([http://leafletjs.com/](http://leafletjs.com/))
    map library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We would like our map input to behave similar to most input fields. We're going
    to use a drop-down style mechanism, similar to most date picker components. The
    user will click on a link to modify the location, and a map dropdown will appear
    as a result. After the user makes their selection, the dropdown will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to add a search box to aid the user in finding the desired
    location on the map. To do this, we will use **Nominatim** ([http://nominatim.openstreetmap.org/](http://nominatim.openstreetmap.org/)),
    a free geocoding service provided by OpenStreetMap. The following is an example
    of how a Nominatim JSON response looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It's an array of search results containing various data among which the data
    that we will need, such as latitude, longitude, and display name, are present.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we start with our HTML page. Our input field consists of three components:
    the link to be clicked, a hidden input field containing latitude and longitude
    data, and a map-based location picker. The map and search box are not included
    in the HTML—they''re created on demand.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the map drop down below the link, it's positioned relatively to its
    container. To make autocomplete links appear on separate lines, their display
    style is set to `block`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make this picker work, the following code is added in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/9282OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code found in `example.js` enables the user to click on the **Set location**
    link and choose a location using the map. The `click` event binding is added to
    the document body to make it easier to add a new location input to the page.
  prefs: []
  type: TYPE_NORMAL
- en: We parse the latitude and longitude from the hidden input field and then create
    a map centered at those coordinates with a marker placed at the same place.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the map, the location is updated and the map is removed
    after 500 milliseconds. This should be long enough for the user to notice that
    his change was successfully applied.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we added a search box next to the clicked link. When the user
    types in a search query inside, a search is performed by making an Ajax request
    to Nominatim. To avoid overloading the service, the search is delayed by 1 second;
    if the user types something before that second passes, the query is canceled and
    a new one is scheduled for sending 1 second later.
  prefs: []
  type: TYPE_NORMAL
- en: Upon fetching the results, the code displays them as a list of links. When clicked,
    they will reposition the map to be centered at the exact location of the clicked
    search result. The list of search results will be removed and the user will be
    allowed to select the exact location.
  prefs: []
  type: TYPE_NORMAL
