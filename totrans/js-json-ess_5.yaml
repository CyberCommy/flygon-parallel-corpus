- en: Chapter 5. Cross-domain Asynchronous Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used jQuery's `getJSON` method to ingest the `students`
    JSON feed; in this chapter we will take a step forward and send request parameters
    over to the server. Data feeds are often large amounts of data that are made available;
    the data that is part of such feeds is normally generic and can be considered
    too heavy for a targeted search. For example, in the `students` JSON feed, we
    are exposing the whole list of student information that is available. For a data
    vendor who is looking for students who are enrolled in certain courses or who
    reside in a given ZIP code to hire them as interns, this feed is going to be generic.
    It is common to see development teams build **Application Programming Interfaces**
    or **APIs** to give such data vendors numerous ways to target their search. This
    is a win-win situation for both the data vendor and for the company that owns
    the information since the data vendor only gets the information that they are
    looking for and the data supplier only sends the requested data, thereby saving
    a lot of bandwidth and server resources.
  prefs: []
  type: TYPE_NORMAL
- en: Making GET and POST AJAX calls with JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to understand that both synchronous and asynchronous calls are
    made over HTTP, so the data transfer process is the same. The popular methods
    to transfer data from the client machine to the server machine are `GET` and `POST`.
    The most common request method in HTTP is `GET`. When a client requests a web
    page, the web server uses the URL to process the HTTP request. Any other parameters
    that are appended to the URL serve as the data that is being sent from the client
    to the server. Since the parameters are part of the URL, it is important to make
    a clear distinction between when to and when not to use the `GET` request method.
    The `GET` method should be used to pass idempotent information such as a page
    number, a link address, or the limits and offsets that are a part of pagination.
    Keep in mind that there is a size constraint as to how much data can be transferred
    via the `GET` request method.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` request method is commonly used while sending the data that is big
    in size and that is non-trivial. Unlike the `GET` method, the data is transferred
    through the HTTP message body; we can use tools such as Fiddler and the developer
    tools available in the browser to track the data that is going out through the
    HTTP message body. The data that is being passed through the `POST` method cannot
    be bookmarked or cached, unlike the `GET` method. The `POST` method is often used
    to send data while using forms. For our examples in this chapter, let us use jQuery's
    `ajax` method to send data over to the server in JSON format. We will be working
    with a modified `students` API where we will be able to query complete student
    information—the ZIP code they live in, the classes that they take, and so on—and
    use a combination search to find students who live in a certain area and are taking
    a certain class. A new addition to our API is the functionality to add a student
    via a `POST` request; the student information has to be sent as a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This API is built in PHP and MySQL. The PHP and MySQL files would be made available
    in the `scripts-chap5` folder present in the code bundle..
  prefs: []
  type: TYPE_NORMAL
- en: Before we start building scripts to make our asynchronous calls, let's take
    a look at the URLs that our `students` API provides. The first API call will be
    the generic search that will retrieve information for all the students in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we have not started our targeted search, the URL has been kept for a generic
    search. Now let's look at the URL for our first targeted search—by ZIP code. This
    API call will return all the students that reside in the given ZIP code area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the URL will return the information for all the students that
    reside in the ZIP code `08810`. Let's switch the search criteria from the ZIP
    code to the class that a student has enrolled into.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the URL will return information for all the students that have
    enrolled for the class `Economics`. Now that we have the power of targeting the
    search by a ZIP code and a class, let us look at another call in our API to retrieve
    information by using both the ZIP code that the user resides in and the class
    that he or she has enrolled in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, a call to the URL will return information for all the students
    that have enrolled for the class `Accounting` and reside in the ZIP code `77082`.
  prefs: []
  type: TYPE_NORMAL
- en: The calls had until now used the HTTP `GET` method to transfer data from the
    client to the server. The last call in our API is powered by the HTTP `POST` method
    for adding a student. This call needs heavy data input, as a user can have multiple
    ZIP codes and multiple addresses and can be enrolled in multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this call we start by importing the jQuery library; we can start using the
    `$` variable as we have jQuery on the page. We begin by adding a callback that
    is fired when the document is ready. We are using the `ajax` method for this example
    as it allows us to make the `GET` and `POST` requests, and when required, we can
    modify the `datatype` property in the `ajax` call to `JSONP` to make asynchronous
    cross-domain calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not necessary to explicitly mention when the type is GET, but it helps
    us build consistency with our code.
  prefs: []
  type: TYPE_NORMAL
- en: In our `ajax` call we begin by setting the `url` property to the link to our
    API call to retrieve the student information; we specify that this will be performed
    via the HTTP `GET` method. The fourth property that we are setting is the `dataType`
    property; this is used to mention the type of the data that we are expecting returned.
    As we are working with the `students` feed, we will have to set the `dataType`
    property to JSON. It is important to note the `done` callback that is fired when
    the server sends a response back to our asynchronous request. We are passing the
    data that is sent over from the server as a response, initiating the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`done` is the same as `readyState=4` and `request.status=200`; we have looked
    at this in [Chapter 4](ch04.xhtml "Chapter 4. AJAX Calls with JSON Data"), *AJAX
    Calls with JSON Data*, while making asynchronous calls using JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the console window, we can view the JSON feed response that comes back from
    the server. This JSON feed contains a lot of information, as it gets the data
    for all the students. Now let us fetch the student records based on the ZIP code.
    For this example, we will be using the `zip_code` parameter and will asynchronously
    pass a value to the server via the HTTP `GET` method. This API call will serve
    the purpose for data vendors who want to search for interns who are available
    in a specific area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous example, we start by importing the jQuery library and we bind
    a callback to ready the event that is fired when the document has loaded. It is
    important to notice that we are sending a key-value pair for the ZIP code using
    the `data` property in line 12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the call is fired, we log the response to the console window. The ZIP code
    `08810` matches one user, and the student information is being passed back via
    the JSON feed. Targeted searches help us narrow down our results, thereby providing
    us with the data that we are looking for; the next target search in line would
    be to retrieve data using a certain class that a student is enrolled in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous example is the same as the targeted search with ZIP code; here
    we are replacing the ZIP code information with the class information. We are retrieving
    all the students who have enrolled for `Economics`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The targeted search returns student information for those who have enrolled
    for an Economics class. Now let us target our search with a combination of class
    and ZIP code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous example, we add the class and the ZIP code key-value pairs to
    send multiple search parameters to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This call retrieves the student information for students who have enrolled for
    the `Accounting` course and reside in the ZIP code `77082`. We have seen multiple
    examples of making asynchronous calls via the HTTP `GET` method; now it is time
    for us to push the data onto the server in order to add a student using our API.
    We will be using our `addUser` call to add a student on the fly. This helps the
    development teams to add student information into our database from external resources.
    For example, we are a student information aggregator and we sell consolidated
    student information to multiple data vendors. For us to aggregate all this information,
    we might be aggregating it via spiders, where a script would go to a website and
    fetch the data, or external resources, where the data will be unstructured. So
    we will structure our data and use this `addUser` API call to ingest the structured
    student data information into our data storage. Simultaneously, we can expose
    this method to trusted data vendors who would like to store the student information
    that is not available with us, thereby helping them to make our data storage a
    single point data location. It is a win-win for both the companies as we get more
    student information and our data vendors get to store their student information
    on a remote location. Now let's take a look at how this `addUser` post call will
    be made.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this call, we are doing multiple things; we start by declaring a few variables
    to hold local data. We have local variables that hold string values for the first
    name and last name of the student, and we also have variables that are holding
    arrays for classes, ZIP codes, and addresses, as Superman has to be at multiple
    locations in a span of few minutes. In our `ajax` call, the first change to note
    is the `type` property; as we are pushing a large amount of user data, it is common
    to use the HTTP `POST` method. The `data` property is going to use the local variables
    that are declared for the first name, last name, addresses, ZIP codes, and the
    classes. From the API, when a user is added to the database successfully, we send
    a success message in response, and that will be logged to our console window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now to verify that the new student has been added to our database, we can run
    our `getStudents` API call to see a list of all the users.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making GET and POST AJAX calls with JSON data](img/6034OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last student in the `students` feed is `Kent Clark`; it is always important
    to test our code to see that everything is working as expected. As we are dealing
    with dynamic data, it is very important to maintain data integrity. Whenever a
    CRUD operation is performed on a user or on their dependencies, the verification
    for data integrity on that data storage has to be performed by looking at the
    retrieved data and by performing data validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with cross-domain AJAX calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the asynchronous calls that we have made until now have been on the same
    server. There are situations where we would want to load data from a different
    domain, such as fetching data from other APIs. Server-side programs are designed
    to handle these kinds of calls; we can use cURL to make HTTP calls to different
    domains to fetch such data. This increases our dependency on server-side programs
    as we would have to make a call to our server, which would in turn make a call
    to another domain to fetch the data, which would be returned to a client-side
    program. It might come across as being a trivial issue, but we are adding an extra
    layer to our web architecture. To avoid making a server-side call, let us try
    and see if we can make an asynchronous call to a different domain. For this example,
    let us use Reddit's JSON API to fetch the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem with cross-domain AJAX calls](img/6034OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to the asynchronous calls that we have made earlier to retrieve
    data from our `students` API. It is important to understand that we did not have
    to mention the whole URL in the previous cases as we were making a call to the
    same domain.
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem with cross-domain AJAX calls](img/6034OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Reddit site provides an excellent JSON API, whereby we can append `.json`
    to the URL and will get the JSON feed for that aggregated web page, given that
    the page is part of Reddit. Let's take a look at the output that is generated
    when we make this asynchronous call across domains.
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem with cross-domain AJAX calls](img/6034OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our asynchronous call, the data would have been logged to the console window,
    if the request were successful, but we see an error in the console window. The
    error says that the `XMLHTTPRequest` object cannot load the URL that we have provided
    as it doesn't originate from our [www.training.com](http://www.training.com) domain.
    The **same domain policy** is a security measure followed by web browsers in order
    to prevent one domain from accessing information on another domain. Web applications
    use cookies to store basic information about a user's session so as to provide
    an intuitive user experience when the user requests the same web page another
    time or requests a different web page on the same domain. To prevent an external
    website from stealing this information, web browsers follow the **same origin
    policy**.
  prefs: []
  type: TYPE_NORMAL
- en: The same domain policy looks for three things in an incoming request; they are
    the host, the port, and the protocol. If any of them is different from the existing
    domain, the request will not be completed and the cross-domain error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '| Variant of http://www.training.com | RESULT |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.training.com/index.php` | PASS |'
  prefs: []
  type: TYPE_TB
- en: '| `https://www.training.com/index.php` | FAIL (Protocol) |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.training:81.com/index.php` | FAIL (Port) |'
  prefs: []
  type: TYPE_TB
- en: '| `http://test.training.com.com/index.php` | FAIL (Host) |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.differentsite.com/index.php` | FAIL (Host) |'
  prefs: []
  type: TYPE_TB
- en: Introduction to JSONP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get around the same origin policy, we will be using JSONP, which
    is JSON with Padding. One exception under the same origin policy is the `<script>`
    tag so scripts can be passed across domains. JSONP uses this exception in order
    to pass data across domains as a script by adding padding to make the JSON object
    look like a script. In JavaScript, when a function with a parameter is invoked,
    we call the function and add a parameter. With JSONP, we pass the JSON feed as
    a parameter to a function; thereby, we pad our object into a function callback.
    This function into which the JSON feed has been padded has to be used on the client-side
    to retrieve the JSON feed. Let's take a quick look at a JSONP example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to JSONP](img/6034OS_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we are padding the `students` object into the `myCallback`
    function and we have to reuse the `myCallback` function in order to retrieve the
    `students` object. Now that we understand how JSONP works, let's use Reddit's
    JSON API to fetch the data. We need to make one change to the way we access the
    data—we need to find a way to pad the feed into a callback that can be used on
    the client-side. The Reddit website provide a `jsonp` `GET` parameter that will
    take the name of the callback to provide the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to JSONP](img/6034OS_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing JSONP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using the same URL as before to fetch the data, but we have added the
    `jsonp` parameter and are setting it to `getRedditData`; it is important to note
    that the feed is now padded into our callback `getRedditData`. Now let's replace
    the URL property in our earlier script to create a new script that will fetch
    us the JSON feed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing JSONP](img/6034OS_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A few properties such as `url` and `dataType` have been modified and a few new
    properties such as `contentType` and `jsonpCallback` have been added. We have
    already discussed the change in the `url` property, so let us look at the other
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing JSONP](img/6034OS_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earlier, the `dataType` property was set to `json` as the incoming feed was
    of type `json`, but now the JSON feed is being padded into a callback, and it
    has to be switched so that the browser expects a callback rather than JSON itself.
    The new properties that have been added are `contentType` and `jsonpCallback`;
    the property `contentType` specifies the type of content being sent to the web
    server. `jsonpCallback` takes the name of the callback function into which the
    JSON feed has been padded.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing JSONP](img/6034OS_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the script is fired, the data from the `getRedditData` callback has been
    retrieved and is passed over into the `success` property that logs our JSON object
    onto the console window. An important fact to make a note of is that a JSONP call
    is a script call and not an XHR request, so the JSONP call will be available in
    the `JS` or `<scripts>` tab and not in the `XHR` tab of the console window.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP `GET` and `POST` request methods are two of the most popular HTTP methods
    that are used to transfer data from clients to servers. This chapter provides
    an in-depth understanding of how `GET` and `POST` request methods are used to
    transfer data using asynchronous requests. We then proceeded to look at what the
    issues are with cross-domain asynchronous requests; we used the exception of the
    `<script>` tag to perform our JSONP asynchronous script calls to fetch the data
    from a different domain. In the next chapter, we will be building our photo gallery
    application.
  prefs: []
  type: TYPE_NORMAL
