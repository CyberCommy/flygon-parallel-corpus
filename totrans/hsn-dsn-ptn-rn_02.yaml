- en: View Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very demanding skill is writing good view code the first time around. It
    comes with experience and becomes almost automatic at some point. Hence, it is
    vital to do it right from the beginning. In this chapter, we will explore best
    practices and go through the React JSX patterns that you already used in the previous
    chapter. We will also focus on the broader spectrum of built-in components, which
    include input and forms. At the very end, I will show you a nice tool called a
    linter that is essential for any new frontend project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Write concise JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use common React Native built-in components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create simple forms using `TextInput`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguish between controlled and uncontrolled input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create error boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminate Mixins from your code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a linter to enforce your code style guide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about various patterns, along with their code
    snippets. However, to run them, you will need the Create React Native App package.
    I have separated every example into a standalone application that you can launch
    on your phone or simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Android/iOS phone or simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git, to pull the examples: [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the installation and running instructions from the GitHub page to get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using JSX so far, but what does it mean? JSX stands for JavaScript
    extension. How can it be an extension?
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know, ECMAScript is also an extension to JavaScript (kind of).
    ECMAScript transpiles to JavaScript. What does this mean? It means that it just
    transforms ECMAScript code into valid JavaScript code. JavaScript misses out on
    many features that we like from ECMAScript, such as arrow functions, classes,
    and destructuring operators.
  prefs: []
  type: TYPE_NORMAL
- en: JSX works the same way. JSX is being transpiled to JavaScript, and its main
    feature is creating React elements based on the markup you write.
  prefs: []
  type: TYPE_NORMAL
- en: Could we use only JavaScript? Yes. Is it worth it? Most likely not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check this out in action. This is JSX *and* ECMAScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compare this to pure JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There's no doubt that the first code snippet is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Babel transpiles JSX to JavaScript. Check out this interactive tool so that
    you can play around and see what the output is in more complex examples: [https://goo.gl/RjMXKC](https://goo.gl/RjMXKC).
  prefs: []
  type: TYPE_NORMAL
- en: JSX standard tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed further, I want to show you the best practices when it comes
    to writing your JSX markup. This will make your journey through my further examples
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are no children within your component, use a self-closing tag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to display a component based on some condition, then use the `&&` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding practices only apply if the other option is `null`. If the false
    case is also a component, you can use the *b ? x : y* operator or even a simple `if-else` approach,
    however, it should comply with your project''s best practices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the *b ? x : y* operator, then you may find that curly braces (`{}`)
    come in handy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use curly braces (`{}`) to destructure props objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to pass `isLoggedIn` as `true`, you can do so by just writing the
    prop name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may want to pass on all of the other props. You can use
    the spread operator in such a case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A beginner's guide to naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naming may sound trivial, but there are some standard practices in React that
    you should comply with. These practices may vary from project to project, but
    keep in mind that you should respect at least the ones that are mentioned here.
    In other cases, check your project's style guide and possibly your linter configuration.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great React style guides comes from Airbnb and can be checked out
    at [https://github.com/airbnb/javascript/tree/master/react#naming](https://github.com/airbnb/javascript/tree/master/react#naming).
  prefs: []
  type: TYPE_NORMAL
- en: 'A component name should start with an uppercase letter unless it''s a HOC.
    Use the component name as the filename. The filename should be in UpperCamelCase
    (for more information on CamelCase, see [https://en.wikipedia.org/wiki/Camel_case](https://en.wikipedia.org/wiki/Camel_case)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are rules on importing your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If it's HOC, start its name with a lowercase letter in lower CamelCase, for
    instance, `makeExpandable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Airbnb also suggests that you take care of the name of the inner component.
    We need to specify a `displayName` prop to do, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a valid point as in some tools you may benefit from seeing the proper
    component names. Following this pattern is optional and up to the team to decide
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: One can create a HOC that takes care of the `displayName` prop. Such a HOC can
    be reused on top of the HOCs we created in [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml),
    *React Component Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: When defining new props, please avoid the common props that used to mean something
    else. An example may be the style prop we used to pass styles to our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check out the following links to check what props you should avoid using:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Props corresponding to your application layout:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Props reserved for component styling, as it may create confusion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/image-style-props.html](https://facebook.github.io/react-native/docs/image-style-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/view-style-props.html](https://facebook.github.io/react-native/docs/view-style-props.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't get too scared. It will feel more natural sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking with PropTypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React comes with support for basic type checking. It does not require you to
    upgrade to TypeScript or another, more advanced solution. To achieve type checking
    straight away, you can use the `prop-types` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s provide type definitions for our `HelloBox` component from`Chapter 1/Example
    12`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, we force `isExpanded` to be of the Boolean type (`true` or `false`),
    and `expandOrCollapse` to be a function. We also let React know about two optional
    style props (`containerStyles` and `expandedTextStyles`). If styles are not provided,
    we simply return the default styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a neat feature to avoid explicit `if` in the markup—default props.
    Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Now, if `containerStyles` or `expandedTextStyles` are be null, then they
    will get a respective default value. However, if you run your application now,
    you will notice a little warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be freaking out right now, but this is correct. This is a nice optimization
    that has been made by the React Native team that you may not be aware of. It caches
    the stylesheet and simply sends the cached ID. The following line is returning
    the number and ID of a stylesheet that represents the `styles` object that was
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, we need to adapt our type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can remove explicit `if` statements in the component markup. It should
    look more or less like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Good job! We have defined default props and type checks for our component. Please
    check the full working `Example 2` in the `src/chapter 2` directory for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, from now on, all code examples will be split into a few modular
    source files. All files will be placed under the `./src` directory of the respective
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `Example 2` is organized in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloBox.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloText.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeExpandable.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure will evolve as the application grows. In [Chapter 10](02308da0-7093-4573-97b0-30d147b28cc2.xhtml),
    *Managing Dependencies*, you will learn how to organize files in big projects
    with over one million lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in components you need to know about
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native is growing fast and changing often. I have selected a curated list
    of components that are likely to stay within the API for a long time. We will
    spend some time learning them so that we will be able to proceed faster later
    on in this book. Any further examples will rely on these components and will assume
    that you know what these components are for.
  prefs: []
  type: TYPE_NORMAL
- en: The ScrollView component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we know about three components: `View` , `Text`, and `StyleSheet`.
    Now, imagine a case where we have a lot of rows to show in the application—something
    such as table of information pops into my mind. Obviously, it will be a long table,
    but the screen is small, so we will make it scrollable—up and down, like in a
    browser. This may seem trivial as a concept, but this isn''t very easy to implement,
    which is why React Native provides the `ScrollView` component.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see this problem in action. Check out `Example 3_ No ScrollView problem`
    from the `Chapter 2` folder to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a typical `TaskList` component, which converts every task into
    a `Task` component. `Task` displays its name and description as `Text`. It''s
    a very simple mechanism, but once a number of tasks is huge, such as 20 or more
    tasks, it fills the entire screen, and suddenly you realize that you cannot scroll
    like in a browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this issue and make the content scrollable, replace `View` with `ScrollView`.
    You also need to rename the `style` prop to `contentContainerStyle`. Please see
    the full example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I have also included `PropTypes` definitions so that you can practice what we
    have learned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `key` prop (`key={task.name + task.description}`) on the
    `Task` component. This is required when you render collections so that React can
    distinguish elements on prop changes and, if possible, avoid unnecessary repainting
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: The Image component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next component that you will often use is the `Image` component. Let''s
    extend our task list with the React logo. After each task, we will show a `.png`
    image of the React logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Please note that not every image type is supported right now. For instance,
    SVG images will need a separate library to work.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the props that the `Image` component consumes in the official
    documentation here: [https://facebook.github.io/react-native/docs/image](https://facebook.github.io/react-native/docs/image).
    You will find useful props such as `loadingIndicatorSource` here—this is an image
    that is shown while a big source image is loading.
  prefs: []
  type: TYPE_NORMAL
- en: The TextInput component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use this component often in the next section. The general idea is to
    be able to pass data from a smartphone keyboard. `TextInput` is used in login
    and registration forms and many other places where the user needs to send text
    data to an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the `HelloWorld` example from [Chapter 1](dd223c16-7a14-4b66-a073-2ae7c53f7352.xhtml),
    *React Component Patterns*, to accept a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If a user enters text in the `TextInput` component, then we display the entered
    text in a short greeting. Conditional rendering uses `state` to check whether
    the name has been defined or not. As the user types, the `onChangeText` event
    handler is invoked, and the function we passed updates the state with the new
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, native keyboards may overlap with your `View` component and hide
    important information. Please get familiar with the `KeyboardAvoidingView` component
    if this is the case in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://facebook.github.io/react-native/docs/keyboardavoidingview.html](https://facebook.github.io/react-native/docs/keyboardavoidingview.html) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: The Button component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Button` is such a common component that you will find yourself using it in
    any kind of app. Let''s build a small `like` counter with up and down buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Further modifications to this concept can implement upvotes/downvotes for comments
    or a star system for reviews.
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` component is very limited, and those who are used to web development
    may be surprised. For instance, you cannot set the text in a web-way, for example, `<Button>Like</Button>`, nor
    can you pass the style prop. If you need to style your button, please use `TouchableXXXX`.
    Check out the next section for an example on `TouchableOpacity`.
  prefs: []
  type: TYPE_NORMAL
- en: Touchable opacity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a button needs a custom look, it quickly seems like you need a better
    alternative. This is where `TouchableOpacity` comes into play. It serves every
    purpose when inner content needs to become touchable. Hence, we will make our
    own button and style it as we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Some example styles follow. We will dig further into styles in [Chapter 3](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml),
    *Styling Patterns*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The button's contents are centered vertically and horizontally. We have a custom
    gray background color and padding inside of the button. Padding is the space from
    the children to the border of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about these simple components, we are ready to proceed further
    and explore how forms are built and how to handle more complicated use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Building forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore how we can handle text input from users. Traditional
    means of collecting input from so-called forms is divided into two major ways:
    controlled and uncontrolled. In a native environment, this means either handling
    any keypress on the React Native side (c*ontrolled input*), or letting it be handled
    on the native system level and collecting data in React on demand (*uncontrolled
    input*).'
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a web development background, please note that, at the time
    of writing this book, there is no form component, and I don't see it coming. There
    are also limitations to refs and what you can do with them. For instance, you
    cannot ask a ref to a `TextInput` for its current value. Please follow the following
    two subsections for more details. You can also use custom libraries, but I will
    not discuss such solutions here as these tend to change often.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlled inputs are those which handle all user input on the JavaScript side,
    most likely in the React state or some other state alternative (see [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml),
    *Store Patterns,* for more information). This means that, as the user types, the
    keystrokes are remembered on both the native system level and the JavaScript level.
    This, of course, may be ineffective and should not be used in complicated UIs,
    which appear to be rare in the mobile world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember the *hello world with your name* example from earlier in this
    chapter? This is a perfect example of controlled input. Let''s see it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We listen on every change in the text (`onChangeText`) and then immediately
    update the component state (`this.setState({name})`). State becomes a single source
    of truth. We do not need to ask for a native component value. We only care about
    what is in the state. Hence, we use state to display the new `Hello` message,
    along with the typed text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works in a more complex example. Our task is to create a
    login form with a login `TextInput`, password `TextInput`, and a `Button` component
    with the displayed text Login. Upon a user pressing the button, it should log
    information to our debug console. In a real application, you would pass the login
    details to the server to verify and then log the user in. You will learn how to
    do this in [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns*,
    when we talk about side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note three important things here:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides the ability to pass remembered login text. The complete feature
    would require remembering the login on the physical device memory, and so I omitted
    this for clarity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `secureTextEntry` prop of `TextInput` that hides the password behind dots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onPress` handler on the button component so that it can do something with
    the collected data. In this simple example, we just log to the debug console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncontrolled input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uncontrolled input in React Native is not really what it is in web development.
    In fact, `TextInput` cannot be uncontrolled entirely. You need to listen to a
    value change in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onChangeText` fires every time the text input changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubmitEditing` fires when the text input''s submit button is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `TextInput` by itself is a controlled component. Check further
    for an explanation. A long time ago, it used to have a prop called `controlled`
    that allowed you to specify a Boolean value, but this has changed. The documentation
    at that time specified the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"If you really want this to behave as a controlled component, you can set this
    to true, but you will probably see flickering, dropped keystrokes, and/or laggy
    typing, depending on how you process onChange events."'
  prefs: []
  type: TYPE_NORMAL
- en: – [https://facebook.github.io/react-native/docs/0.7/textinput.html](https://facebook.github.io/react-native/docs/0.7/textinput.html).
  prefs: []
  type: TYPE_NORMAL
- en: I realize that the React Native team did put a lot of effort into addressing
    these issues and they fixed `TextInput`. However, `TextInput` became a controlled
    input to some extent. For instance, selection on `TextInput` is managed by React
    Native within the `componentDidUpdate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '"Selection is also a controlled prop. If the native value doesn''t match JS,
    update to the JS value."'
  prefs: []
  type: TYPE_NORMAL
- en: – React Native source code for TextInput: [https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js](https://github.com/facebook/react-native/blob/c595509048cc5f6cab360cd2ccbe7c86405baf92/Libraries/Components/TextInput/TextInput.js).
  prefs: []
  type: TYPE_NORMAL
- en: Unless you specify the `onChangeText` or `value` props, then your component
    does not appear to get any more overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact is that you can still use refs. Check out the following example to
    learn how to use React''s latest API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, there are some limitations. You cannot ask ref for the input value**.**
    Sadly, I find this unlikely to change. If you look at this from the other side,
    it feels more natural. You probably only need controlled components. The benefit
    from uncontrolled ones is performance that, as of now, does not differ much. Hence,
    I doubt that you need uncontrolled components in React Native. I couldn't even
    come up with a use case where you would need a lot of uncontrolled components
    because of performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: The closest I could get to leaving a component on its own was by using `onSubmitEditing` or
    `onEndEditing`. Such callbacks can be used like the `onChangeText` prop. They
    do not fire until the user presses the Submit/Return button on the native keyboard.
    Unfortunately, you can probably imagine the case when the user, instead of pressing
    the expected button, presses the login button instead. In such a case, the state
    would not be updated with the latest data, because the native keyboard remains
    opened. Such nuances may lead to incorrect data submission and critical bugs.
    Be careful.
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing websites using React, don't get discouraged by this section.
    refs are powerful for brown field websites and are useful for those who cannot
    afford to rewrite existing pieces into React. If this is your case, please also
    check out the portals API from React v16 [https://reactjs.org/docs/portals.html](https://reactjs.org/docs/portals.html).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to error boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is quite an overlooked feature that came with React version 16\. As you
    should already know, JavaScript can throw errors. Such errors should not break
    your app, especially if it is from the financial sector. The regular imperative
    solution from JavaScript is a `try-catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is hard to use with JSX. Hence, the React team developed an alternative
    solution for React views. It''s called `Error Boundaries`. Any class component
    can become an `ErrorBoundary` component, given that it implements the `componentDidCatch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you follow along with these examples, you may see a red screen with an error
    nonetheless. This is a default behavior in development mode. You will have to
    dismiss the screen to see what the app looks like: the error boundary will work
    as expected. If you switch to release mode, the error screen will not appear.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginForm` is now wrapped into `ErrorBoundary`. It catches any error that
    occurs while rendering `LoginForm`. If `Error` is caught, we display a short message
    stating that `Something went wrong`. We can get a real error message from the
    error object. However, it is not good practice to share it with the end user.
    Instead, send it to your analytics server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How error boundaries catch errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It appears that error boundaries are meant to catch runtime errors that prevent
    rendering to finish successfully. Hence, they are very specific to React and are
    implemented using a special life cycle hook of the class component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error boundaries do not catch errors for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous code (for example, setTimeout or requestAnimationFrame callbacks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors thrown in the error boundary itself (rather than its children)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- React official documentation at [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the previously mentioned error boundaries limitations further:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event handlers**: This limitation is due to event handlers asynchronous nature.
    Callbacks are being invoked by an external function, and the event object is passed
    to a callback as a parameter. We do not have any control over this and when this
    will happen. The code is executed and never goes into the catch clause. Hint:
    This also impacts `try-catch` in the same way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous code**: Most asynchronous code will not work with error boundaries.
    The exception to this rule is asynchronous render functions, which will come with
    future releases of React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side rendering**: This usually concerns server-side rendered websites.
    Such websites are computed on the server and sent to the browser. Thanks to this,
    a user can immediately see the website''s content. Most of the time, such server
    responses are cached and reused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Errors thrown in the error boundary itself**: You cannot catch errors that
    occur within the same class component. Hence, error boundaries should contain
    as little logic as possible. I always recommend using a separate component for
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding error boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error boundaries can be placed in many different fashions, and each approach
    has its own benefits. Choose one that fits your use case. For ideas, skip to the
    next section. Here, we will demonstrate how the app behaves, depending on the
    placement of the error boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first example uses two error boundaries around the `LikeCounter` component.
    If one of the `LikeCounter` components crashes, the other one will still be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This second example uses one `ErrorBoundary` around two `LikeCounter` components.
    If one crashes, the other one will also be replaced by `ErrorBoundary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When to use error boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ErrorBoundary` is a great pattern for sure. It takes the `try-catch` concept
    into declarative JSX. The first time I saw it, I immediately came up with the
    idea to wrap the whole application into a boundary. This is fine, but it is not
    the only use case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following use cases for error boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Widgets**: Given some incorrect data, your widget may run into problems.
    If, in the worst case scenario, it cannot handle the data, it may throw an error.
    You will want the rest of the app to be usable, given that this widget is not
    crucial for the rest of the application. Your analytics code should collect the
    error and save at least a stack trace so that the developers can fix it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modals**: Preserve the rest of the application from the faulty modal. These
    are usually meant to display some data and short messages. You do not want a modal
    to blow up your application. Such errors should be considered very rare, but *better
    safe than sorry*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundaries on feature containers:** Let''s say that your app is divided into
    major features that are represented by container components. For example, let''s
    take a messaging app such as Facebook Messenger. You may add error boundaries
    to the sidebar, my story bar, footer, start new message button, and messages history
    list view. This will ensure that, if one feature breaks, the others have a chance
    to still work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we know about all of the pros, let''s discuss the cons ones: Mixins.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Mixins are anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a Mixin pattern, you mix in a certain behavior with your React components.
    You kind of inject a behavior for free, and you can reuse the same Mixin in different
    components. This all sounds great, but it isn't – and you will easily find articles
    on why. Here, I want to show you this anti-pattern by example.
  prefs: []
  type: TYPE_NORMAL
- en: Mixin example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of shouting *Mixins are harmful,* let''s create a component that is
    using them and look at what the issues are. Mixins are deprecated, so the first
    step is finding a way to use them. It turns out that they still live in a legacy
    way of creating React class components. Previously, instead of ES6 classes, there
    was a special function called `createReactClass`. In one of the major releases,
    the function was removed from the React library and is now available in a separate
    library called `''create-react-class''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create `LoggerMixin`, which is taking care of logging the necessary
    information. In this simple example, it's just information regarding that component
    that has been rendered, but it could be easily extended further.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used `componentDidMount`, which is one of the component
    life cycle hooks. These can be used in ES6 classes, too. Please check out the
    official documentation for insights about the other methods: [https://reactjs.org/docs/react-component.html#the-component-lifecycle](https://reactjs.org/docs/react-component.html#the-component-lifecycle).
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you need more loggers, you can mix them into a single component by
    using a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is a book on patterns, so it is crucial to stop here and look at the `createReactClass`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why has it been deprecated? The answer is actually pretty simple. The React
    Team prefers explicit APIs over implicit APIs. The `CreateReactClass` function
    is another implicit abstraction that hides implementation details from you. Instead
    of adding a new function, it is better to use the standard way: ES6 classes. ES6
    classes have their own cons, but that is another topic entirely. Additionally,
    you may use classes in other languages that are built on top of ECMAScript, for
    instance, TypeScript. This is a huge advantage, especially nowadays, with TypeScript
    going mainstream.'
  prefs: []
  type: TYPE_NORMAL
- en: To find out more on this thought process, I recommend that you watch a great
    talk from Sebastian Markbåge called **Minimal API Surface Area**. It was originally
    delivered at JSConf EU in 2014, and can be found at [https://www.youtube.com/watch?v=4anAwXYqLG8](https://www.youtube.com/watch?v=4anAwXYqLG8).
  prefs: []
  type: TYPE_NORMAL
- en: Using HOCs instead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I believe that you can easily translate the preceding use case into HOC. Let''s
    do this together, and then we will discuss why HOCs are better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you will immediately spot is that HOCs stack on top of each
    other. HOCs literally compose with each other. This is much more flexible and
    protects you from name clashes that may happen when using Mixins. React developers
    mention the `handleChange` function as a problematic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"There is no guarantee that two particular mixins can be used together. For
    example, if FluxListenerMixin defines handleChange() and WindowSizeMixin defines handleChange(),
    you can’t use them together. You also can’t define a method with this name on
    your own component.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s not a big deal if you control the mixin code. When you have a conflict,
    you can rename that method on one of the mixins. However, it’s tricky because
    some components or other mixins may already be calling this method directly, and
    you need to find and fix those calls as well."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Official React blog post by Dan Abramov ([https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)).*'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Mixins may lead to adding more and more state. Looking at the
    preceding examples, it may appear that HOCs do the same, but in fact, shouldn't.
    This is an issue that I struggle with in the React ecosystem. It gives you a lot
    of power and you may not realize that the patterns you begin to use are so-so.
    To me, stateful components should be rare, and so should stateful HOCs. In this
    book, I will teach you how to avoid using state objects in favor of a better solution
    that decouples state from your components as much as possible. We will learn about
    this further in [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store
    Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Linters and code style guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at quite a different set of patterns,
    namely, patterns on how to structure your code. Over the years, there have been
    tens of approaches to styling, and the general rule is this: the more people,
    the more preferred ways there are.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the **crucial point** of setting up the project is **selecting your style
    guide**, and your set of defined and precise rules. This will save enormous amounts
    of time for you as it removes any potential discussion.
  prefs: []
  type: TYPE_NORMAL
- en: In an era of advanced IDEs, it is possible to quickly reformat a whole code
    base in seconds. This will come in handy in case you need to allow for small future
    changes to the style of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a linter to create a React Native app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your own linter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and navigate to the project directory. The `cd` command for
    changing the directory will come in handy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List (`ls`) the files in the directory and make sure that you are in the root
    and that you can see the `package.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following packages by using the `yarn add` command. The newly added
    packages will be automatically added to `package.json`. `--dev` installs it under
    the development dependencies within `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: ESLint is the linter that we will be using, and by running the preceding command,
    you will have installed it in the `node_modules` directory of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to define a new script for your project. Please edit `package.json`
    and add the following line under the `scripts` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs ESLint and passes one argument to it. This argument
    is the name of the directory that will contain files to lint. If you aren't going
    to follow along with this book, we are using the `src` directory to store source
    JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is specifying a code style—more precisely, a linter configuration
    that implements your code style. In this example, we will use a well-known Airbnb
    style guide. However, we will also tweak it to adhere to my preferred style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firstly, create your linter configuration by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A special prompt will follow. Choose the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A configuration file will be created for you called `.eslintrc.json`. Open
    the file and add the following rules. In the next section, I will explain these
    choices. For now, proceed with the given set of rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the linter by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The complete setup is provided in `Example 14` under the `Chapter 2_View patterns`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Airbnb React style guide rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Airbnb React style guide defines tens of well-thought-out rules. This is
    a great resource and a foundation for your next React project. I highly recommend
    looking into them. You can find the Airbnb React style guide at [https://github.com/airbnb/javascript/tree/master/react](https://github.com/airbnb/javascript/tree/master/react).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, everyone should find their own style. Mine just adapts a few things
    from the Airbnb:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comma-dangle`: Airbnb advises that you leave a trailing comma at the end of
    array multiline elements, lists, or object multiline key-value lists. This is
    not what I''m used to. I prefer the JSON style, which does not leave a trailing
    comma:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`react/jsx-filename-extension`: In my opinion, this rule should be changed
    in the style guide. It tries to convince you to use the `.jsx` extension for files
    using JSX. I don''t agree with this. I would like to quote Dan Abramov''s comment
    on this matter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"The distinction between .js and .jsx files was useful before Babel, but it’s
    not that useful anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other syntax extensions (for example, Flow). What would you call a
    JS file that uses Flow? .flow.js? What about a JSX file that uses Flow? .flow.jsx?
    What about some other experimental syntax? .flow.stage-1.jsx?
  prefs: []
  type: TYPE_NORMAL
- en: Most editors are configurable, so you can tell them to use a JSX-capable syntax
    scheme for .js files. Since JSX (or Flow) are strict supersets of JS, I don’t
    see this as an issue."
  prefs: []
  type: TYPE_NORMAL
- en: – Dan Abramov: [https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904](https://github.com/facebook/create-react-app/issues/87#issuecomment-234627904).
  prefs: []
  type: TYPE_NORMAL
- en: '`no-use-before-define`: This is a smart rule. It prevents you from using variables
    and functions that are defined later, besides the fact that the JavaScript hoisting
    mechanism lets you to do so. However, I like to put my StyleSheets in the bottom
    on every component file. Hence, I have relaxed this rule to allow usage of variables
    before their definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also prefer an indentation of four spaces for clarity when I copy snippets
    into this book.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have a linter set up, we can try it on one of the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along with this example, just copy `Example 9_Controlled
    TextInput` from [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View
    Patterns*, and set up a linter in that copied project. After that, follow with
    the following command, which executes your linter script on the source directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'I tried it on `LoginForm.js` from `Example 9_ Controlled TextInput`. Unfortunately,
    it listed a few errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '13 problems! Luckily, ESLint may attempt to fix them automatically. Let''s
    try. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Lovely —we reduced the issues to just three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can skip the last two. Those warnings are relevant, but the console is handy
    for this book: it provides an easy way to print information. Do not use `console.log`
    in production. However, `''initLogin'' is missing in props validation react/prop-types`
    is a valid error, and we need to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`LoginForm` now has its props validated. This will fix the linter error. To
    check this, rerun the linter. It looks like we have run into yet another issue!
    Correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true—we should have defined default props in case `initLogin` is not
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, if we do not explicitly provide `initLogin`, it will be assigned
    a default value, that is, an empty string. Rerun the linter. It will now show
    a new error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At least it's an easy one. It correctly advises you to maintain `prop-types`
    dependencies explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `prop-types` dependency by running the following command in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the linter. Great! Finally, there are  no errors. Good job.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about view patterns that will be very useful later
    on in this book. Now we know how to write concise JSX and type check components.
    We can also compose common built-in components from the React Native library.
    When we need to, we can write the markup of a simple form and know how to handle
    the input. We compared controlled and uncontrolled inputs and dove deep into how
    `TextInput` works. If some errors occur, our error boundaries will handle the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we made sure that we have a strict style guide on how to write React
    Native code, and we enforced these rules by using ESLint.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on styling the components we have learned.
    Thanks to this, our application will look nice and professional.
  prefs: []
  type: TYPE_NORMAL
