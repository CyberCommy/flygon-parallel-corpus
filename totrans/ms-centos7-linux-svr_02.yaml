- en: Chapter 2. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will find different tools and utilities that we can use
    to secure the CentOS system we are using. Security is the most important part
    for a system or server and thus, a System Administrator's job is always to keep
    the system up to date and secure from different kind of attacks that happen on
    a regular basis on servers.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss several tools here starting from SELinux to other security tools
    and measures that we can take on a CentOS 7 system. Let's dive into them one by
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into:'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux and its tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing SELinux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux audit logs and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security Enhanced Linux** (**SELinux**) is a set of kernel modifications
    and user-space tools that have been present in CentOS for quite a long time. It
    is a kind of mechanism that supports Mandatory Access Control security policies,
    which were initially developed by the US National Security Agency and later released
    in the public domain to protect computer systems from malicious intrusion and
    tampering.'
  prefs: []
  type: TYPE_NORMAL
- en: Not many System Administrators use SELinux. Commonly, people are reluctant to
    learn about SELinux and just disable it directly. However, a properly configured
    SELinux system can reduce the security risks to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux implements **Mandatory Access Control** (**MAC**), which works on top
    of already available **Discretionary Access Control** (**DAC**) on CentOS 7\.
    DAC is the traditional security model that we have on Linux systems where we have
    three entities: User, Group, and Others who can have a combination of read, write,
    and execute permission for files and directories. By default, if a user creates
    any file in his home directory, the user and his group will have the read access
    and the user will have write access to the file but the other entity might also
    have read access to it.'
  prefs: []
  type: TYPE_NORMAL
- en: The user who owns the file can change this access policy and grant or revoke
    access as well as ownership of the file. This might leave critical files exposed
    to accounts that don't need access to these files and thus pose as a security
    threat to the running system. It confines every process to its own domain and
    makes sure that it can interact only with a defined type of files and processes
    and thus protect the system from a hacker hijacking a script or process and gaining
    system-wide control through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check what SELinux packages are installed on your system, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing SELinux](img/B04674_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install all the packages with the following command; this will install the
    rest of the packages and update the already installed packages on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will have all the packages required by SELinux installed on the system.
    Let''s install two more services apache (`httpd`) for the web server and FTP (`vsftpd`)
    server on the system, so that we can test the SELinux with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the apache service now using either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of httpd using either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will show that it''s running, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing SELinux](img/B04674_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, `start vsftpd` using either of the following commands and then check
    the status of `vsftp` in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of ftpd using either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Installing SELinux](img/B04674_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SELinux mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of SELinux modes; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforcing**: In this mode, SELinux enforces its policies onto the system
    and makes sure that all access by unauthorized users or processes are denied.
    These access denial events are also logged in to the system as well, which we
    will look into later on in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permissive**: This is like a semi-enabled mode state where SELinux doesn''t
    deny any access as the policies are in permissive mode. This is the best mode
    to test the SELinux policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: In this mode, the SELinux is in a completely disabled state and
    no logs are created or permissions are denied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can run the following commands to get the present SELinux status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs from the preceding commands are shown in the following image when
    SELinux is enabled on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux mode](img/B04674_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main SELinux configuration file is `/etc/selinux/config`. We will now enable
    SELinux by setting up `SELINUX=permissive` in this file, and then saving and rebooting
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux mode](img/B04674_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `SELINUXTYPE` parameter in the `config` file also has three options, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Targeted**: This is the default value that allows you to customize and fine-tune
    your policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum**: In this mode, only the selected processes are protected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MLS**: Multi Level Security is an advanced mode of protection and you need
    an additional package to install it as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will keep the `SELINUXTYPE` at the default value (that is, targeted).
  prefs: []
  type: TYPE_NORMAL
- en: This is necessary to set the SELinux into the permissive mode the first time
    it runs, as it's required to label all files on the system. Otherwise, processes
    running under confined domains might fail as they can't access the files with
    correct contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are set and we reboot the system, it will label all the files, which
    will take some time depending on the system with SELinux contexts. Since it's
    in the permissive mode, only failures and access denials will be reported.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must check the system once it is up for any errors using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you outputs such as the following if the SELinux is running
    in permissive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, since all the rules are loaded and the files are labeled, we have to enable
    the SELinux enforcing mode instead of the permissive mode. So, edit the `SELinux
    config` file once again and set the following to enforcing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux mode](img/B04674_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, reboot the server once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is back, check the SELinux status with the `sestatus` command and it
    will show you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux mode](img/B04674_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you `grep` SELinux in `/var/log/messages` you will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To check the SELinux enforcing status, run the `getenforce` command, and it
    will display the status as `enforcing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sestatus` command will display more details about the operating SELinux
    configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux mode](img/B04674_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to change the SELinux mode temporarily while running SELinux, we
    can do that using the `setenforce` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `sestatus` will show you the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux mode](img/B04674_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Switch back to the enforcing mode using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: SELinux policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You must have noticed from the previous SELinux outputs in `/var/log/messages`
    that it is based on Policy. Policy means a set of rules that defines the relation,
    security and access rights to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: All regular Linux users are defined by one or more SELinux users.
    However, please note that SELinux users are different from Linux users. Also,
    note that a running process or a program is defined as subject in the SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role**: They are like filters that define which user can access a process
    and so on. It''s like a gateway between a user and a process. A user can only
    run a specific process if the role grants it and the user has access to the role.
    SELinux is based on **Role Based Access Control** (**RBAC**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject** and **Object**: Subject is like a process or a program and object
    is anything than can be acted on; like a file, port, directory, and so on. The
    actions that are performed by a subject on an object depend on the subject''s
    permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: This is like a wrapper around the Subject (process), which tells
    the process what it can or can''t do. For example, the domain will define the
    directories, folders, files, ports, and so on a process can access. Domains are
    related to subject in SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: A file''s context is called its type. For example, the context of
    a file describes whether it''s only accessible to the local web server process
    or it''s available to any process within any other directory such as `/` and so
    on or which specific SELinux user is the owner of the file. Type is related to
    the object in SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In SELinux, policy defines rules for users access to roles, role access to domains,
    and domain access to types.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three forms of access control in SELinux defined by the `SELINUXTYPE`
    in the `/etc/selinux/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Enforcement** (**TE**): This is the primary mechanism of access control
    used in the targeted policy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-Based Access Control** (**RBAC**): This is based around SELinux users
    (not necessarily the same as the Linux user), but not used in the default targeted
    policy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Level Security** (**MLS**): This is not commonly used and often hidden
    in the default targeted policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The targeted policy is used by default in SELinux and we will continue our discussion
    based on it here.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that SELinux doesn't replace the traditional DAC policy in the
    Linux system. Instead, if a file access is prohibited by the DAC policy, the SELinux
    policy will not be evaluated and will not grant access to the file even if is
    allowed by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux policies are loaded in a modular format much like a kernel module into
    the memory and can be viewed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux policy](img/B04674_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `semodule` command can be used for installing, removing, reloading, upgrading,
    enabling, and disabling SELinux policy modules as well.
  prefs: []
  type: TYPE_NORMAL
- en: The module files are located in `/etc/selinux/targeted/modules/active/modules/`
    with the `.pp` extension and are not human readable. But, if you look into them
    closely, you will surely find that they are actually related to different applications
    in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux policy](img/B04674_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These policy modules are combined into an active policy and are then loaded
    into the memory. This combined binary policy can be found in the `/etc/selinux/targeted/policy/`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux policy](img/B04674_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We cannot modify these rules directly but can manage them using the `semanage
    boolean` command. The output of the `semanage boolean -l | less` command will
    show us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux policy](img/B04674_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is clearly evident in the second line of the preceding output that the FTP
    service access to user home directories is turned off at this moment. We can also
    see just the status of the `ftpd` service policies using the following command
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux policy](img/B04674_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to allow FTP users to access their home directories and allow read-write
    access we have to issue the following commands. First check the status of the
    `ftp_home_dir` policy using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enable access to the user home directory using `setsebool -P` for permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the status again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, users will be allowed to access their home directories via the FTP provided;
    the FTP protocol is allowed in the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux files and processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have looked into the basics of SELinux and how to allow a service
    like `vsftpd` to allow users to access their files from ftp. Let's look into the
    details of the context of files and how they are defined in SELinux. Context in
    SELinux is a collection of information related to security, which helps SELinux
    determine access control policies. In Linux, everything can have a security context
    such as files, directories, services, or ports but security context means different
    type of things for different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the SELinux file context for any file by using the `ls –Z` parameter
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux files and processes](img/B04674_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding output, this part is the SELinux context for that specific
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are four parts, each separated by a colon (`:`). The first part is the
    SELinux user context, which is shown as `system_u` here. As you already know,
    each Linux system user is mapped to a SELinux user and here it is `system_u`.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the SELinux role, which is `object_r` here.
  prefs: []
  type: TYPE_NORMAL
- en: The most important part here is the third part, which is mentioned as `user_home_t`.
    This is the one that defines the type of file, and from this, we can understand
    that it belongs to the user's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth part (s0) actually explains the sensitivity of the file and it actually
    works with the Multi-Level Security. The first three parts are more important,
    so we will only work with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the SELinux process context using the `httpd` file that
    we installed before. Let''s start the `httpd` process first using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the `ps` command with the additional `-Z` flag to see the process
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux files and processes](img/B04674_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The security context in the preceding output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In SELinux, users are suffixed by `_u`, roles are suffixed by `_r`, and types
    are suffixed by `_t`.
  prefs: []
  type: TYPE_NORMAL
- en: For a process to run like `httpd`, it needs to access its files and action them.
    We already have seen that each process can only have access to certain types (files,
    directories, ports, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux defines these access rules in a policy. These access rules follow the
    standard `allow` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A generic `allow` statement indicates:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether a process is of a certain domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the resource object the process is trying to access is of a certain class
    and type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it can allow access or deny access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how this works in consideration with the security context of the https
    process that we have already looked into.
  prefs: []
  type: TYPE_NORMAL
- en: 'The document root or the default directory for `httpd` is `/var/www/html`.
    Now, let''s create a file in there and check its security context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux files and processes](img/B04674_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The file context for the `index.html` file we created is shown to be `httpd_sys_content_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `sesearch` command in the following way to check the type of
    access allowed for the `httpd` daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux files and processes](img/B04674_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The flags used in the preceding command are easily understandable; source domain
    is `httpd_t`, which the domain apache is running within. We wanted to list the
    target resources that are files and have the type context `httpd_sys_content_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the first line of context output in the preceding screenshot is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you relate it with the generic allow statement previously, we will clearly
    understand that the `httpd` service has I/O control, read, get attribute, lock,
    and open access to the files of the `httpd_sys_content_t` type. And, in our case,
    the `index.html` file that we created is also of the same type, which means the
    `httpd` service will have access to this `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a test web page modifying the `index.html` file so that we can
    check its output from the browser. Add the following lines into the `index.html`
    file using your favorite editor and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change the permission of the `/var/www` folder followed by `httpd restart`
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have to allow the http port in the firewall if you are doing it for
    the first time using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to access it from the browser. It will show you the output as in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux files and processes](img/B04674_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see if we change the type context of the `index.html` file and
    whether we will still be able to access it or not. We will use the `chcon` command
    to change the type context and will use the `–type` flag for this purpose as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the context of the file using `ls -Z` , it will show us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is visible that the type has been changed to `var_t` here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you try to access the web page again, it will show you an error or you
    might see a default page but not the same page that we saw before. This is because
    we have changed the type context for the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To revert it, we will use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we access the site again, we will see that it works again as before.
  prefs: []
  type: TYPE_NORMAL
- en: The SELinux enforcing mode guarantees that unless otherwise specified by the
    policy, processes and files are created with the same context as their parents.
    What this means is that if process A is spawning process B, the spawned process
    B will run in the same domain as process A unless specified differently by the
    SELinux policy, and similarly, if we have a directory with some `context_t` type,
    unless defined otherwise, the files or directories under it will inherit the same
    `context_t` type.
  prefs: []
  type: TYPE_NORMAL
- en: In CentOS 7, the contexts of all files that exist in the system are listed in
    the `/etc/selinux/targeted/contexts/files/file_contexts` file and contexts of
    new directories and files are recorded in the `/etc/selinux/targeted/contexts/files/file_contexts.local`
    file. Since `chcon` is used to change context temporarily and `restorecon` is
    used to restore the context, `restorecon` actually looks into this file to restore
    the original context of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `/www/html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we copy the contents from `/var/www/html` to `/www/html` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we check the context of the file, we will find that it's different from what
    we have for `/var/www/html/index.html` and its `default_t` because that is the
    context of its parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: Further, even if we change the `httpd` configuration file to an open `index.html`
    file from this new location, we will still face errors because the contexts are
    not right yet. While copying the `index.html` file from `/var/www/html to /www/html`,
    it inherited the context from its parent directory, which is `default_t`.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue we will have to change its context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To permanently change the context of the `index.html` file under `/www/html`
    that we created before, we will follow two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we check the context database from the `/etc/selinux/targeted/contexts/files/file_contexts.local`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux files and processes](img/B04674_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will run the `restorecon` command to relabel the file or directory
    to what has been recorded in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will work in three levels; first it will relabel the `/www` directory,
    then the `/www/html` directory, and finally, the `/www/html/index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux files and processes](img/B04674_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we try to access the web page it should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a command called `matchpathcon`, and it is very handy to troubleshoot
    context related issues. It can compare the context of a current resource with
    what''s under the SELinux context database and report back. If the match is different,
    it suggests the changes required. We can run the command using the `-V` flag for
    `/www/html/index.html` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Domain transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's find out how a process accesses other processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider that the `vsftpd` process is running; if it''s not started,
    we can start it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `vsftpd` process is started by the `systemd` process; this is a replacement
    of the `Sys V init` process and runs within a context of `init_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![Domain transition](img/B04674_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `systemd` process running under the `init_t` domain is very short lived;
    it invokes `/usr/sbin/vsftpd`, which has a type context `ftpd_exec_t`, and when
    this binary executable starts, it becomes the `vsftpd` service itself and runs
    in the `ftpd_t` domain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Domain transition](img/B04674_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, here's the `systemd` process running under the `init_t` domain executing
    a binary file with the `ftpd_exec_t` type. The binary file then starts a service
    within the `ftpd_t` domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Domain transition is followed by three strict rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The parent process of the source domain must have the permission to execute
    the application between both the domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file context for that application must be identified as an entry point for
    the target domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original domain must be allowed to transit to the target domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run the `sesearch` command for the `vsftpd` service to check whether
    it follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the source domain `init_t` must have permission to execute the application
    in the `ftpd_exec_t` context. So we run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We found the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, the `init_t` can read, get attribute, execute, and open files of the `ftpd_exec_t`
    context.
  prefs: []
  type: TYPE_NORMAL
- en: '![Domain transition](img/B04674_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we check whether the binary file is the entry point for the target domain
    `ftpd_t`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We found that it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![Domain transition](img/B04674_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the source domain `init_t` needs to have permission to transit to
    the target `ftpd_t` domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the source domain has that permission as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![Domain transition](img/B04674_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SELinux also supports processes that run under unconfined domains; for example,
    `unconfined_t`. This is the domain where logged in users run their processes by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained before, SELinux users are different from normal Linux users. SELinux
    users are defined in the policy that's loaded into the memory at boot time, and
    there are only a few of these users.
  prefs: []
  type: TYPE_NORMAL
- en: After SELinux is enforced, each regular user account is mapped to a SELinux
    user account. There can be multiple user accounts mapped to the same SELinux user.
    This enables the normal user account to inherit the permission of its SELinux
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the mapping, we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux users](img/B04674_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we will find that there are only three Login Names as shown in the preceding
    screenshot representing the Linux user accounts. Any Linux user is mapped to the
    entry shown as `__default__` here. The user root is not mapped to default, instead
    it has its own entry and there is `system_u` for the running processes or services.
    The second column indicates the SELinux user they are mapped to. Normal user accounts
    and roots are mapped to `unconfined_u`, whereas the processes and services are
    mapped to the `system_u` SELinux user. For now, ignore the third column, which
    shows the **Multi-Level Security** (**MLS**) **Multi Category Security** (MCS)
    class for the user, and the last column (service) as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the SELinux users that are available in the system, use the `semanage`
    user command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![SELinux users](img/B04674_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The table in the preceding screenshot shows the SELinux users available in the
    system and the roles they have access to. We already discussed that SELinux roles
    are like gateways between a user and a process. We also compared them to filters,
    where a user can enter a role, provided the role grants it. If a role is authorized
    to access a process domain, the users associated with that role will be able to
    enter that process domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the id `-Z` command as the root user. It will show the SELinux security
    context for the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SELinux users](img/B04674_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the root user is mapped to the `unconfined_t` SELinux user, which is authorized
    to the `unconfined_r` role, which in turn is authorized to run processes in the
    `unconfined_t` domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw that there are several SELinux users available in the system.
    Let''s discuss some of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`guest_u`: This type of user doesn''t have access to the X Windows system or
    networking and also cannot execute the `su` or `sudo` commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xguest_u`: This type of user has access to GUI and the network via the browser
    only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_u`: This type of user has general access to GUI and the network but cannot
    run `su` or `sudo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`staff_u`: This is the same as `user_u` except that they can run `sudo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system_u`: This is meant for system services and are not mapped with regular
    user accounts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access to su or sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can restrict a user from running the `su` or `sudo` commands by changing
    the user''s SELinux user mapping like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will change the Linux `test` user's mapping to `user_u`
    and will not allow the `su` or `sudo` commands access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will only take effect when the user is not logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting permissions to run scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To restrict the Linux `test` user''s ability to run scripts we have to do two
    things. First, we change the user''s mapping to `guest_u`, the same way as we
    did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, SELinux allows users mapped to `guest_t` to execute scripts from
    their home directories. We can confirm the same using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show that `guest_exec_content` is on. So, the second step is that we
    disable the `guest_exec_content` using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, the test user for whom we changed the mapping won't be able to execute
    any scripts even if he has full access to his home directory and the files that
    he creates there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do a grep to see what SELinux is preventing `/var/log/messages`, it will
    show us the access denial along with an alert ID. We can note the alert ID and
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It will show us full details about the access denial along with some suggestions
    to remove it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume we have a user admin with access to `sudo` so that it can run commands
    with `sudo` to start and stop services like `httpd`. Now, even if the user has
    `sudo` accesses, we can stop him from management access to services by changing
    his user mapping to `user_u`, the same way we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will restrict the user admin from restarting or stopping services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify the `user_u` access info by running the `seinfo` command as the
    root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Restricting access to services](img/B04674_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This output shows the roles `user_u` can have access to; they are `object_r`
    and `user_r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go one step further and run the same command to find out what domains
    the `user_r` role is authorized to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![Restricting access to services](img/B04674_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a long list of domains the role can enter. Now, let''s find out whether
    the role can enter the domain `httpd_t` by just filtering the output with grep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will return nothing, which means that the `user_r` role is not authorized
    to enter the `httpd_t` domain, and therefore, it is unable to start the `httpd`
    process or daemon.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux audit logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CentOS 7, we should look into two files for SELinux-related errors and alerts;
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/log/audit/audit.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/log/messages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux comes with some tools that are very useful for checking errors and
    troubleshooting. We already saw one, `sealert -l <alert id>`, where we gather
    the alert ID by looking into `/var/log/messages`. There is another command called
    `ausearch`, which is also very helpful in checking errors if the `auditd` service
    is running, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into various aspects of SELinux and how to configure
    it; we also demonstrated how to use it according to our needs. However, be cautious
    and never test SELinux on a production system. It is better to use a production
    replica and test everything there first. The SELinux facility will enhance the
    security of a system when it's properly configured, but it's best used when strict
    security controls are necessary and only when it is deployed with care.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how Linux can be used for a variety of
    purposes.
  prefs: []
  type: TYPE_NORMAL
