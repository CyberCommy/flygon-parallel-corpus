- en: '*Chapter 12*: Using Python in Experimental and Data Analysis Problems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at how Python can help us understand and
    analyze data using algorithms and libraries created specifically for data analysis
    and data science. We will first go through experimental data and then move on
    to algorithms that use two main libraries: **NumPy** and **pandas**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining experimental data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data libraries in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding data analysis with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using additional libraries for plotting and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to define types of experiments,
    data gathering, and how computational thinking helps when designing models and
    solutions. You will also learn how to use data libraries, particularly, **NumPy**,
    **pandas**, and **Matplotlib**, to help in analyzing and displaying data. Finally,
    you'll be able to design algorithms that help with data analysis in order to learn
    from existing data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to install the latest version of Python for running the code in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to have a few libraries installed, including **NumPy**, **pandas**,
    **Matplotlib**, and **Seaborn**.
  prefs: []
  type: TYPE_NORMAL
- en: You may choose to use an integrated environment to run Python, such as **Anaconda**,
    which can simplify the library dependencies and is helpful in organizing your
    algorithm in notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code used in this chapter can be found in the GitHub repository
    here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter12](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter12)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining experimental data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We''re finally at the data chapter of this book*. *We all have our biases
    and areas where we just love to live in. This is one of mine*. There are many
    reasons why data is so important, but let''s start with the fact that data, how
    we collect it, how we analyze it, and how we present it has a massive impact on
    our daily lives.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing algorithms to display information, we have a responsibility to
    share that data in the least biased way possible, making sure that our data is
    inclusive and representative of our communities and our people. I wanted to make
    sure I said that before we talk about the topic in as much depth as a chapter
    will allow me to. For me, this is how I fell in love with code and Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to go over experimental data, defining what it
    is as well as key terms used when working with experimental data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started. **Experimental data** is a term that gets its use from
    science and engineering. However, we also use experimental data in other areas,
    such as education, civics, and much more. Experimental data includes the methodology,
    how we measure data, the design of the experiments we are conducting, and how
    we present the data we gather and analyze from those designs. For the purposes
    of this chapter, we're not designing the experiments. We're going to be focusing
    on how we use Python to analyze existing data. But it is important to note that,
    if we have a say in the experiment, we need to make sure we are designing it fairly.
  prefs: []
  type: TYPE_NORMAL
- en: If the experimental design and the data collection methods are sound, then the
    data we use and analyze will be much more helpful than if we begin with a biased
    experiment. While we can never eliminate bias completely, as researchers and developers,
    it is our responsibility to present data with the least amount of bias possible.
    *Why is this important?* Think of all the policy changes that happen based on
    data, graphs, and information presented from experiments. If the experiments are
    biased to begin with, the results will lead to policies that may not adequately
    encompass the needs of a community, for example.
  prefs: []
  type: TYPE_NORMAL
- en: When working with data, we are always using computational thinking elements.
    As we tackle problems, we have to define what the problems are, what we want to
    study, how we want to measure it, how we'll be able to create and generalize the
    patterns, and what algorithm we'll need to use to produce the best representations
    of our data. Everything we do in data analysis benefits from us using computational
    thinking elements.
  prefs: []
  type: TYPE_NORMAL
- en: Data science is a growing field in **STEM**. In 2017, it was named the fastest-growing
    field in the US. The US Bureau of Labor Statistics stated that there is an estimated
    11.5 million new jobs expected in data science and statistics by 2026\. Currently,
    there are more jobs available than qualified candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how Python lets us tackle data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In experimental data, we want to gather information using independent, dependent,
    and control variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent variables** are variables that are changed or controlled by the
    researcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependent variables** are variables that are being measured or tested by
    the researcher; dependent variables *depend* on independent variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control variables** are variables or factors in the experiment that must
    remain the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a simple example of these variables in an experiment. A common
    example involves the study of plant growth. The independent variables can be one
    or multiple variables. For our example, our independent variable will be the amount
    of fertilizer we add to the plants. The plant growth will be a dependent variable.
    The **control** will not get any fertilizer, just water. So, in our experiment,
    let's say we have five plants that we will be measuring. One plant will only get
    water. That's our **control**. The other four will have varying levels of fertilizer
    added to them. Those are our **experimental** plants. The growth is **dependent**
    on the amount of fertilizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we design experiments, there are three things we want to be true: that
    they are reliable, valid, and can be generalized. Here''s what each of these things
    means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable** relates to the consistency of the measurements. This means that
    if we mimic the conditions, our results should be reliably similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valid** relates to whether or not the experiment measured what it intended
    to measure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generalizable** relates to the results being something that can be generalized
    and applied to other settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot more detail and depth we could go into about experiments, but
    we are only looking at what happens once we have the data for this chapter. It
    is important to understand these basic terms for when we are involved in the design
    of the experiments. As developers, depending on our roles, that may be the case.
    For example, in a start-up, everyone may be involved in all aspects of product
    development. So, in those instances, we could be working on the experiment and
    also the subsequent analysis algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's move on to what we can do with data analysis and how Python libraries
    can help us achieve what we need when analyzing the experiment results.
  prefs: []
  type: TYPE_NORMAL
- en: Using data libraries in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at some libraries and packages that
    we can use with the Python programming language. We refer to *packages* and *libraries*,
    using both terms interchangeably sometimes, but for clarity, a package contains
    modules, while a library is a collection of packages.
  prefs: []
  type: TYPE_NORMAL
- en: We use Python libraries much like we use modules that are built-in, such as
    the `math` module we first used in [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071),
    *Understanding Logical Reasoning*. In our source code, we imported the `math`
    module by using `import math` before creating the algorithm. In the example under
    the *Applying inductive reasoning* section of [*Chapter 4*](B15413_04_Final_SK_ePub.xhtml#_idTextAnchor071),
    *Understanding Logical Reasoning*, we used the `math.floor()` function of the
    module, which allowed us to round a number down, regardless of what the decimal
    value was. When we import modules or libraries in Python, we are tapping into
    additional functions and capabilities that allow us to take the programming language
    much further.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, what is a library?* In Python, a **library** refers to chunks of code
    that can be reused. Libraries contain a collection of modules. There are many
    libraries available for Python, and like Python itself, a large number of the
    libraries are **open source**, which means they can be downloaded and used by
    anyone. Because we''re going to be working with data in this chapter, we''re going
    to stick with pandas, NumPy, and Matplotlib for now. However, there are many other
    libraries and many types of libraries. For example, there are **Graphical User
    Interface** (**GUI**) frameworks, such as **Kivy**, **tkinter**, **PyQt**, **PySimpleGUI**,
    and others. For gaming, there are other libraries, such as **Pygame** and **Pyglet**.
    In machine learning, the **TensorFlow** library is a popular tool developed by
    **Google** in collaboration with the **Brain** team. But these are only some examples
    of the libraries available and the areas that use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the `math` module is built into the Python language, libraries need
    to be installed. In **Python 3.9**, the program we use to install libraries is
    the **pip** **installer**. This is a command built into Python and run from the
    **Command Prompt** window. One caveat I will mention here is that permissions
    and where we install Python matter, so if your computer belongs to your employer,
    make sure that the Python program paths are adapted as needed so that you can
    access all modules and install libraries. The permissions may vary.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, while my main computer does not belong to me, I have administrator
    access to it, so I can run my Command Prompt as an administrator and run `pip`
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an installation of the `sympy` Python library.
    As you can see, using the `pip install sympy` command installs the library onto
    our system. For the record, `sympy` is a symbolic math library available for Python.
    Since I have the other libraries we''ll be using already installed, I had to show
    the installation for a package I hadn''t yet installed on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Installing a Python library'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.01_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Installing a Python library
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re trying to install a library that you''ve already installed—for example,
    if I tried to install pandas again—you''ll get a **Requirement already satisfied**
    message, such as the one shown in the following screenshot. Notice that the user
    information will be filled in with your user, not blacked out as shown in the
    screenshot, and this also shows the location where the library package can be
    found on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Requirement already satisfied message'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.02_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Requirement already satisfied message
  prefs: []
  type: TYPE_NORMAL
- en: You may also wish to use Anaconda, which is an open source distribution of the
    Python and R programming languages. When Anaconda is installed, you can use the
    `CMD.exe` prompt window to install your libraries using `conda install` or `pip
    install`. The Jupyter notebook included in the Anaconda navigator can run and
    save your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: There are more programs and packages included in the Anaconda distribution program
    and they can simplify how we interact with the Python programming language. It's
    a great resource if you are doing extensive coding.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so already, this would be a good time to install the NumPy,
    pandas, and Matplotlib libraries before we start using them in analyzing and displaying
    data and creating models.
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy and pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NumPy**, like so many of the libraries in Python and the Python programming
    language itself, is an open source library. NumPy is used for multi-dimensional
    arrays and matrix data structures. Python itself doesn''t have arrays; it has
    lists. So, libraries can be used to provide that capability for our algorithms.
    When we have multiple elements of the same type, we can use a data structure to
    save them – that is, an **array**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `pandas` library is used to analyze data and is built on the `numpy` package.
    The pandas and NumPy libraries are often used together. When we need graphical
    models, we add a third library, Matplotlib, or another similar library. In this
    chapter, we're going to stick with Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we import libraries, we can import them as the whole name, `numpy` in
    this case, or we can shorten them for ease of use. If we want to import the library,
    we can use `import numpy`. Let''s say we wanted to create an array of the numbers
    from `0` to `11`. We can use `numpy` to organize that by combining the `arange`
    and `reshape` functions. Let''s take a look at the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_abbreviate.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we imported `numpy as np` instead of just `numpy`. That means that
    I can now call the NumPy functions using `np` instead of having to type `numpy`
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that `np` is a standard abbreviation of NumPy, so you may see it
    often. You can import NumPy as anything, any name, but `np` is the standard convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding snippet, we are asking the algorithm to split the list of
    numbers from `0` to `11` into `2` rows of `6` elements each. Then, we print the
    array to see our result. Take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we start at `0`, which is our lower bound in the range `0`
    to `12`. We have two rows now, with six numbers in each of the two rows. *We do
    not include 12*. If we had tried to do `0` to `13`, we wouldn''t be able to reshape
    our array because we cannot evenly split 13 numbers. We would have gotten the
    following traceback error (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Recall that your information will be different where you see the ellipses (`…`).
    It will have your file location, or path, based on how your Python is set up.
    For example, your file location may be something like `C:/Users/JohnSmith/Documents/ch12_abbreviate.py`.
    This should replace the file location in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the `ValueError` message, we cannot reshape an array into
    the `(2, 6)` shape because we'd have one number left over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a pandas `DataFrame`. We use `DataFrames` so that
    we can manipulate our data in rows and columns. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_pdDataFrame.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we created a dictionary with value pairs for the names and numbers
    of our contacts. After doing so, we saved our address book as `DataFrame`, which
    will organize our information in tabular form. Finally, we printed our address
    book. Take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that pandas used the information from the dictionary to create the labels
    for our columns. We did not give it information for labeling our rows, so the
    numbers `0` to `4` were automatically used by Python and pandas. The algorithm
    resulted in a table that provides the names and numbers in our address book.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, pandas and NumPy simply add more capabilities to Python. Before
    we move on to Matplotlib, notice that we haven't really seen actual data analysis
    yet. We'll get to that soon. Right now, we know how to use our libraries and that
    we can use them to organize and analyze data. Let's talk quickly about Matplotlib
    and then move on to an example where we can use a data file to do some analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Using Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the previous section, pandas and NumPy do not provide a
    visual representation or visual model for our data. In order to create graphs
    from our data, we can use the Matplotlib library in Python. Much like we imported
    the pandas and NumPy libraries as `pd` and `np`, respectively, we can also shorten
    Matplotlib. The full library contains multiple modules. We''ll use the `pyplot`
    module a lot. The most commonly used abbreviation for `Matplotlib.pyplot` is `plt`.
    If we''re calling Matplotlib, we usually abbreviate that as `mlt`. Let''s take
    a look at a quick sample:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_matplotlib.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this particular library has an even longer name than `matplotlib`.
    To import the library, we have to import it using `matplotlib.pyplot`. Imagine
    having to write all that every time we need it in an algorithm. *No thanks!* Instead,
    we import it as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the second line in the code snippet. We''re creating
    a plot that matches each of the numbers in the first list to the numbers in the
    second list. So, we have three coordinate pairs: `(0, 4)`, `(3, 5)`, and `(6,
    6)`. The output when using this code isn''t just a line of output; it''s a plot.
    Now, the algorithm creates that plot in the second line of the preceding code
    snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But it won''t show it to you unless you tell it that''s what you want. Think
    of the `show()` function as our `print()` function in Python. Unless we tell the
    algorithm that we want to see something, the algorithm will perform the task in
    the background but won''t show it to us. The following graph shows the output
    for this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Matplotlib sample graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.03_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Matplotlib sample graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as you can see, the graph itself is already helpful. We can see that this
    is a linear relationship defined by those points. But notice that the bottom of
    the screen gives you some options. The home icon at the bottom left will reset
    your graph at any time to its original window. The **Zoom** function, shown in
    the following screenshot, allows us to select a piece of the graph that we want
    to look at more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Zoom feature of Matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.4_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Zoom feature of Matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the left graph shows our selection for the piece of the graph we
    wanted to take a closer look at. Then, the graph on the right is only showing
    us the values we selected. Matplotlib also allows us to configure subplots and
    navigate with the arrows back and forth between multiple representations. For
    example, if I were to click on the left arrow on the graph after zooming, it would
    take me back to the previous representation. Clicking the **Home** button takes
    me back to the original graph.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not the only type of graph or representation Matplotlib allows.
    This is just a tiny glimpse into visual representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional resource for the types of plots available is available here:
    [https://matplotlib.org/3.3.2/tutorials/introductory/sample_plots.html](https://matplotlib.org/3.3.2/tutorials/introductory/sample_plots.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the Matplotlib library. We learned how to
    create a simple plot and how we can zoom into sections of our graphs from the
    outputs when we create our graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to access our libraries and what each can do for us, let's
    take a look at how we use them to analyze data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data analysis with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced some of the libraries that we can use
    to analyze data in Python. In this section, we will be looking at one example
    and multiple code snippets to build a bar graph using real data and Matplotlib,
    but before we do so, let's review why Python is so important with regard to data
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As Python is object-oriented, it allows us to streamline really complex and/or
    large datasets. This allows great readability of the data and using the libraries
    can produce data representations such as tables and visual models that allow us
    to predict where our data is going, create regression analyses, and much more.
    As mentioned in the introduction of this chapter, data analysis is also critical
    for decision-making. A well-designed experiment produces data that we can rely
    on and that is generalizable. Data analysis can be a tool for more equality and
    equity in our society.
  prefs: []
  type: TYPE_NORMAL
- en: All that being said, we are going to look more at the mechanical aspects of
    what we can do with Python rather than how we interpret it so that we can understand
    how Python does data analysis and presents results using our libraries. That said,
    we'll use more examples in [*Chapter 15*](B15413_15_Final_SK_ePub.xhtml#_idTextAnchor199),
    *Applied Computational Thinking Problems*, and [*Chapter 16*](B15413_16_Final_SK_ePub.xhtml#_idTextAnchor219),
    *Advanced Applied Computational Thinking Problems*, in various areas that will
    not only use some of these tools but will also provide us with an opportunity
    to explore what data analysis means in the context of those samples.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to take a look at an example that can help us further understand the
    capabilities of these tools and how we can write algorithms that solve some of
    the presented problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we''ll be using a data file, `ch12_data.csv`, which can be
    found in the GitHub repository. This file contains graduation rates for degree-seeking
    students from 1996 through 2012 by race/ethnicity, time to completion, sex, control
    of institution, and the percentage of applications accepted. The data was downloaded
    from the **National Center for Education Statistics** here: [https://nces.ed.gov/programs/digest/d19/tables/dt19_326.10.asp](https://nces.ed.gov/programs/digest/d19/tables/dt19_326.10.asp).'
  prefs: []
  type: TYPE_NORMAL
- en: The data file in our repository only contains the data for all four-year institutions
    rather than the entire file. Some of the headings are also simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to work with a data file, it is important that we tell Python
    where it can locate it so that it knows what to use when running the algorithm.
    To do so, we use the `os` module, which allows our algorithm to interact with
    our **operating system** (**OS**). Notice that our snippet already includes the
    other libraries as well (we''ll use them later):'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_csvAnalysis.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we've done previously, make sure you replace the ellipses in the user information
    with your own location. In the algorithm provided in the repository, you'll also
    need to adjust that location in order to run this algorithm, as the location for
    that algorithm would be for my own path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve told Python where to find the file, we can use it in the algorithm.
    If we run this algorithm, we''ll see that the output should match the path we
    noted in the line that starts with `os.chdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice again that our paths will not match. That will all depend on where you
    have your files saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the same data and file as our `.csv` file in `.xls`
    format, as it is easier to point out what we need from it. Note that we will use
    the `.csv` file for the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Data to be used in Python formatted as an .xls file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.05_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Data to be used in Python formatted as an .xls file
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only want to pull the rows shown, we can use the following code snippet
    to get that information from our `.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_csvAnalysis_2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our algorithm imported the pandas library. The `read_csv()` function
    tells Python that we''ll be using the filename and the index of the column we
    want to start working with. That index gives us the values we''ll use as row headers.
    If the index wasn''t in the first column, we could change that to a different
    value. Then, we print the rows we want to see. Because our data is wide, our output
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Output of ch12_csvAnalysis.py algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.06_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Output of ch12_csvAnalysis.py algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are only seeing the first two columns, then we have ellipses.
    That shows us that there are more columns between the second column and the third
    shown. That doesn't mean that Python didn't read the rest of the information,
    it's just not visible to us. The last output line, `[13 rows x 10 columns]`, actually
    tells us how many rows and columns are in the data we pulled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say I wanted to see data for one group, say `Hispanic`, as a comparison
    using a bar chart for the years between 1996 and 2012\. Then, I can use the **bar
    chart plot** from the Matplotlib library. Let''s take a look at the adjustments
    made to the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_csvAnalysis_3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are some things we should look at closely from our preceding code. The
    first thing we did was add the `fig, ax = plt.subplots()` line. This line allows
    us to create the plot, but also allows us to create multiple plots in a figure
    if we wanted to. If we were adding four plots, we'd use `fig, ax = plt.subplots(2,
    2)`, which would tell the algorithm that we're creating four plots in two rows
    and two columns. If we leave the parentheses empty, as we did in the preceding
    code, we have just one subplot.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are identifying the figure we'll create, which is a bar graph. We want
    to just compare the numbers for the Hispanic population over the years, so we
    identify that in our `ax.bar(graduates.index, graduates['Hispanic'])` line.
  prefs: []
  type: TYPE_NORMAL
- en: I should note here that many developers use `dataframe` as their variable. I
    prefer to name my `DataFrame` descriptively instead, so instead of calling my
    `DataFrame` `df`, I've called it `graduates` in the algorithm. Whatever your preference
    is, this is the `DataFrame` that we are currently working with to create a readable
    plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the ticks and tick labels in the code; we first identify where we''ll
    get the data from for the ticks and what the labels will be. Then, we can add
    more formatting to our plot by adding rotation (if we want to tilt our labels),
    alignment, and so on. We could also change the font size here. Finally, we set
    the *y* -axis title and the bar graph title before we show the plot. The following
    screenshot shows the plot for this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Plot of Hispanic graduates for ch12_csvAnalysis_3.py'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.07_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Plot of Hispanic graduates for ch12_csvAnalysis_3.py
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our graph has labels and shows the data clearly, and we were able
    to modify our formatting so that it was legible. As we analyze the information,
    we also notice the gap between the first year and the year **2000**, and between
    **2000** and **2002**. The data for those years is not included in the data file.
  prefs: []
  type: TYPE_NORMAL
- en: This is only one of the plots possible using Matplotlib. We'll have a chance
    to explore a few more in [*Chapter 15*](B15413_15_Final_SK_ePub.xhtml#_idTextAnchor199),
    *Applied Computational Thinking Problems*, and [*Chapter 16*](B15413_16_Final_SK_ePub.xhtml#_idTextAnchor219),
    *Advanced Applied Computational Thinking Problems*, which are solely dedicated
    to samples in multiple areas using everything we've discussed throughout earlier
    chapters of this book. For now, let's move on to some other applications of data
    and Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using additional libraries for plotting and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we end this chapter on experimental data, the use of libraries, and
    plotting and analyzing data, let''s look at three more libraries that are helpful
    in data analysis and plotting. These are not the only libraries for analysis and
    plotting, nor will they be the only ones we explore throughout the rest of this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Seaborn** is a library used for data visualization; built on top of Matplotlib.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SciPy** is a library used for linear algebra, optimization, statistics, and
    more; built on top of NumPy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scikit-Learn** is a library used in machine learning; part of the SciPy stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following chapters, we'll go deeper into the use of some of these libraries
    as we tackle some of the application problems that require their use. For now,
    let's take a quick look at what each of these libraries can help us with when
    looking at datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Seaborn library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Seaborn library provides us with more features on top of the Matplotlib
    visualization features. There are many things we can do with the Seaborn library,
    which we usually import as `sns` for simplification of the code. Here are some
    of the common uses of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: Correlations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate statistics (observation of categorical values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear regression plots for dependent variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating abstractions and grids with multiple plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the greatest things about Seaborn is that it also works well with pandas.
    Creating statistical representations of data and visualizations is easy when combining
    with pandas DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seaborn has some sample datasets that can be accessed – that is, they are built-in
    – if we know the name of the dataset. We can then call the built-in dataset with
    a simple line of code. Let''s take a look at the following snippet of code and
    resulting graphics:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_seabornSample.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, you can see that we''ve set a style for our plots.
    We are adding a `''darkgrid''` style to our plots and called it after importing
    the library. Seaborn has a few built-in styles: `white`, `whitegrid`, `dark`,
    `darkgrid`, and `ticks`. The following screenshot shows the resulting plot from
    Seaborn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Graph of exercise sample dataset with darkgrid style'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.08_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Graph of exercise sample dataset with darkgrid style
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the graphs, we would be able to analyze whether or not there
    are correlations between pulse and time or any other variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use pair plotting to show whether there are correlations between
    the variables. Let''s use another built-in dataset, flights, to see what the pair
    plotting does:'
  prefs: []
  type: TYPE_NORMAL
- en: ch12_pairplotSNS.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet of code is very similar to the previous one for the exercise
    data. The difference is that we call the `pairplot()` function in this case. The
    following screenshot shows our resulting grid of plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Pair plotting using Seaborn'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.09_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – Pair plotting using Seaborn
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the number of passengers and the years seem to be positively correlated.
    That is, there are more passengers in later years than in the early years of flight.
    When analyzing this dataset, we would probably want to make a prediction, such
    as stating that more passengers would be flying in modern times.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the graphs to help us make predictions. That said, this data is
    fairly old, so we'd need more updated data to make accurate predictions. The more
    data we have, the better. For massively large amounts of data, we can also use
    machine learning, which we will briefly explore in [*Chapter 13*](B15413_13_Final_SK_ePub.xhtml#_idTextAnchor174),
    *Using Classification and Clusters*, and [*Chapter 14*](B15413_14_Final_SK_ePub.xhtml#_idTextAnchor184),
    *Computational Thinking and Python in Statistical Analysis*, so that we can learn
    how to manipulate and learn from the data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to another library, one more thing about the pair plots—if
    there are 10 columns of data, the pair plot will compare each column with itself,
    then every other column available, creating a pretty large display with all the
    compared variables. We will look at some more pair plotting in [*Chapter 14*](B15413_14_Final_SK_ePub.xhtml#_idTextAnchor184),
    *Computational Thinking and Python in Statistical Analysis*. There are also problems
    in [*Chapter 15*](B15413_15_Final_SK_ePub.xhtml#_idTextAnchor199), *Applied Computational
    Thinking Problems*, and [*Chapter 16*](B15413_16_Final_SK_ePub.xhtml#_idTextAnchor219),
    *Advanced Applied Computational Thinking Problems*, that will allow us to practice
    more with those graphs and what we can get from them.
  prefs: []
  type: TYPE_NORMAL
- en: The Seaborn library is helpful to visualize statistical data, much like Matplotlib.
    The ease of some of the built-in functions in Seaborn makes it a great tool for
    visualization and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the SciPy library.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SciPy library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SciPy library is mostly used to solve scientific and mathematical problems.
    Some of the helpful sub-packages and their uses are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster` is used for clustering algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constants` contains physical and mathematical constants and units, such as
    `golden` (the golden ratio) and `mu_0` (the magnetic constant).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fftpack` utilizes fast Fourier transform routines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integrate` is used for differential equation solvers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interpolate` contains interpolation and smoothing splines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io` relates to input and output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linalg` is associated with linear algebra.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ndimage` is used for processing *N*-dimensional images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`odr` is used for orthogonal distance regression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimize` is used for optimization and root-finding routines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal` is used for signal processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sparse` is used for sparse matrices and associated routines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spatial` is used for spatial data structures and algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`special` is used for special functions (such as elliptic functions and integrals).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stats` is used for statistical distributions and functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within each of the sub-packages, SciPy contains many functions to aid in the
    visualization and optimization of scientific data. Because it was created specifically
    with that purpose, it is a common tool used in the scientific area. That said,
    the statistical packages are also robust, so the library is helpful to use even
    in non-scientific statistical analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the Scikit-Learn library, which we'll use in the following
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Scikit-Learn library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scikit-Learn is probably the most important library for machine learning available
    in Python. We will explore this library in samples in the following chapters as
    we explore some of the problems that would be suitable for machine learning, so
    we won''t go too deep into the functionalities here. That said, here are some
    of the functionalities that Scikit-Learn gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clustering** helps with grouping data that is unlabeled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression** measures the relationship between the variable (the mean of
    the variable) and the values of the other variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classification** has multiple classifiers within Scikit-Learn, similar to
    regression. Some of the classifiers are **linear discrimination analysis**, **bagging
    classifiers**, **K-nearest neighbors classifiers**, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model selection** has tools for creating training and testing models in machine
    learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preprocessing** contains tools to standardize the dataset (more details on
    data preprocessing can be found in [*Chapter 14*](B15413_14_Final_SK_ePub.xhtml#_idTextAnchor184),
    *Computational Thinking and Python in Statistical Analysis)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scikit-Learn library is something we will become fairly familiar with in
    the upcoming examples in [*Chapter 14*](B15413_14_Final_SK_ePub.xhtml#_idTextAnchor184),
    *Computational Thinking and Python in Statistical Analysis*, [*Chapter 15*](B15413_15_Final_SK_ePub.xhtml#_idTextAnchor199),
    *Applied Computational Thinking Problems*, and [*Chapter 16*](B15413_16_Final_SK_ePub.xhtml#_idTextAnchor219),
    *Advanced Applied Computational Thinking Problems*, so we'll leave some of that
    discussion for those chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The libraries and packages that we have available in Python allow us to perform
    detailed analysis for our dataset and create a wide array of useful plots that
    aid in data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over the definitions of experimental data and validity,
    reliability, and generalizability in the context of experiments. We also discussed
    how to install and use the pandas, NumPy, and Matplotlib libraries so that we
    could use them to organize and display data. Some of the skills you learned include
    defining an experiment, data gathering, and how computational thinking helps us
    define problems and design what we'd use to display our results.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned about data analysis and data science and its growth
    and importance in our current world. We were able to use the libraries to produce
    a plot that represented a subset of a data file using a Matplotlib bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be learning more about data and other applications
    of data science and data analysis.
  prefs: []
  type: TYPE_NORMAL
