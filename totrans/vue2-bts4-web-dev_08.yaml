- en: Chapter 9. Test Test and Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we implemented the workout management page. We learned
    how to use the Google Firebase data storage mechanism to store static files and
    we again used the real-time database to store the workout objects. We used Bootstrap
    to build a responsive layout for the workout'' management page and we learned
    how to use Bootstrap''s modal component to display each individual workout in
    a nice popup. Now we have a totally responsible application. Thanks to Bootstrap,
    we had to implement nothing special to have a nice mobile representation. Here''s
    what adding new workouts looks like on a mobile screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test Test and Test](../images/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new workout on a mobile screen
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is what our modal looks like on a mobile device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test Test and Test](../images/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Workout modal displayed on a mobile device
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to test our application. We are going to use Jest ([https://facebook.github.io/jest/](https://facebook.github.io/jest/))
    to build unit tests and run snapshot testing. In this chapter, we are going to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to configure our Vue.js application to work with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test Vuex stores using Jest assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to mock complex objects with the `jest.mock` and `jest.fn` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to implement snapshot testing for Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is testing important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our ProFitOro application works just fine, doesn't it? We have opened it so
    many times in the browser, we have checked all the implemented features, so it
    just works, right? Yes, that's true. Now go to your settings page and try to change
    the values of the timer to something strange. Try it with negative values, try
    it with huge values, try it with strings, and try it with empty values…do you
    think that can be called a nice user experience?
  prefs: []
  type: TYPE_NORMAL
- en: '![Why is testing important?](../images/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You wouldn't like to work during this number of minutes, would you?
  prefs: []
  type: TYPE_NORMAL
- en: Have you tried to create a strange workout? Have you tried to introduce a huge
    workout name at its creation and see how it displays? There are thousands of corner
    cases and all of them should be carefully tested. We want our application to be
    maintainable, reliable, and something that offers an amazing user experience.
  prefs: []
  type: TYPE_NORMAL
- en: What is Jest?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You know that Facebook guys are never tired of creating new tools. React, redux,
    react-native and all this reactive family was not enough for them and they created
    a really powerful, easy-to-use testing framework called Jest: [https://facebook.github.io/jest/](https://facebook.github.io/jest/).
    Jest is pretty cool because it''s self-contained enough for you to not to be distracted
    by extensive configuration or by looking for asynchronous testing plugins, mocking
    libraries, or fake timers to use along with your favorite framework. Jest is all
    in one, although pretty lightweight. Besides that, on every run, it only runs
    those tests that have been changed since the last test run, which is pretty elegant
    and nice because it''s fast!'
  prefs: []
  type: TYPE_NORMAL
- en: Initially created for testing React applications, Jest turned out to be suitable
    for other purposes, including Vue.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the great talk given by Roman Kuba during the Vue.js conference in
    June 2017 in Poland ([https://youtu.be/pqp0PsPBO_0](https://youtu.be/pqp0PsPBO_0)),
    where he explains in a nutshell how to test Vue components with Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is not just a Vue application, it is a Nuxt application that
    uses Vuex stores and Firebase in it. All these dependencies make it a little bit
    more difficult to test because of all the things we have to mock and because of
    the Nuxt application particularities themselves. However, it is possible and after
    everything is set up, the joy of writing tests is enormous! Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by testing a small sum function and check that it correctly sums
    two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step would be, of course, to install Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a directory `test` and add a file called `sum.js` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a test spec file for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a command to run tests. Add an entry `"test"` to the `package.json`
    file that will call a command `jest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run `npm test`, you will see some errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Jest](../images/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Errors in the test output with when we run tests with Jest
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens because our Jest is not aware we are using *ES6*! So, we need
    to add the `babel-jest` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After *babel-jest* is installed, we have to add a `.babelrc` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Aren''t you annoyed about your IDE warnings regarding `describe`, `it`, and
    other globals that are not being recognized? Just add an entry `jest: true` to
    your `.eslintrc.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run `npm test`, the tests are passing!
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Jest](../images/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You've just set up and run your first Jest test!
  prefs: []
  type: TYPE_NORMAL
- en: Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit tests help to guarantee that the pieces (units) of code that they are
    checking work for any possible and impossible input. Every written unit test covers
    the corresponding piece of code as a blanket, protecting this code from future
    failures and making ourselves comfortable with our code''s functionality and maintainability.
    There are different types of code coverage: statement coverage, line coverage,
    branch coverage, and so on. The more the code is covered, the more stable it is
    and the more comfortable we are. That''s why, while we are writing unit tests,
    it is very important to check the code coverage every time we run it. It''s easy
    to check the code coverage with Jest. You don''t need to install any external
    tool or write extra configuration. Just execute the test command with the coverage
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will magically see this beautiful coverage output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage](../images/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running Jest tests with coverage
  prefs: []
  type: TYPE_NORMAL
- en: Works like a charm, right?
  prefs: []
  type: TYPE_NORMAL
- en: Find the code in the `chapter9/1/profitoro` directory. Don't forget to run `npm
    install` on it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing utility functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test our code now! Let''s start with utils. Create a file called `utils.spec.js`
    and import the `leftPad` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at this function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function should return the input string if this string's length is greater
    than `1`. If the string's length is `1`, it should return the string with a preceding
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seems quite easy to test it, right? We would write two test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Argh...if you run this test, you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing utility functions](../images/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, poor Jest, it is not aware of the aliases we''ve been using in our
    Nuxt application. The `~` notation for it equals nothing! Luckily for us, it is
    easy to fix. Just add the `jest` entry to the `package.json` file with a name
    mapper entry inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now Jest will know that everything that starts with `~` should be mapped to
    the root directory. If you run `npm test -- --coverage` now, you will see that
    the tests are passing!
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing utility functions](../images/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After mapping the root directory alias, tests run without any problem
  prefs: []
  type: TYPE_NORMAL
- en: The code coverage, however, is really low. It's because we have another function
    in our utils to be tested. Check the `utils.js` file. Can you see the `numberOfSecondsFromNow`
    method? It also needs some test coverage. It calculates the time that has passed
    from the given input time until now. How should we deal with this `Date.now`?
    We can't predict the test result because we can't guarantee that the moment of
    *now* of test running will be the same as when we check it. Every millisecond
    matters. Easy! We should mock the `Date.now` object!
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Turns out that even something that seems impossible (stopping time) is possible
    with Jest. Mocking the `Date.now` object is fairly easy using the `jest.fn()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the documentation about mocking with Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic](http://facebook.github.io/jest/docs/en/snapshot-testing.html#tests-should-be-deterministic)'
  prefs: []
  type: TYPE_NORMAL
- en: We can mock the `Date.now` function by just invoking `Date.now = jest.fn(()
    => 2000)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can easily test the `''numberOfSecondsFromNow''` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The coverage is better now but it could be perfect if we could cover our funny
    `beep` function. What should we test in it? Let''s try to test that when the `beep`
    function is invoked, the `Audio.play` method is called. Mocked functions have
    a special property called **mock** that contains all the information about this
    function—the number of calls that have been performed on it, the information that
    has been passed to them, and so on. Thus, we can mock the `Audio.prototype.play`
    method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After invoking the beep method, we can check the number of performed calls
    on the mock like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can assert that the mock has been called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole test might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to avoid side effects due to mocking the native function, we might
    want to reset our mock after the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Jest documentation in this regard: [https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset](https://facebook.github.io/jest/docs/en/mock-function-api.html#mockfnmockreset).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you might configure your Jest settings to reset mocks automatically
    after each test. For this, add the `clearMocks` attribute to the Jest `config`
    object inside the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Yay! The tests are passing. Check the coverage. It looks quite nice; however,
    the branch coverage is still not perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking with Jest](../images/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Branch coverage in for the utils.js file is only 75%
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this happening? First of all, check the column `Uncovered Lines`. It
    shows us the line that hasn''t been covered by the test. It''s line `22` of the
    `numberOfSecondsFromNow` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, you can check the `coverage` folder inside your project''s
    directory and open the `lcov-report/index.html` file in the browser to check in
    a more visual way what exactly is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking with Jest](../images/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Code coverage HTML shows the covered and uncovered lines in a nice visual way
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can clearly see that line `22` is marked as red, which means it has
    not been covered by tests. Well, let''s cover it! Just add a new test covering
    the case when the `startTime` property is not passed to this method and ensure
    that it returns `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests with the coverage flag now. OMG! Isn't it just fantastic?
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking with Jest](../images/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 100% code coverage, isn't it fantastic?
  prefs: []
  type: TYPE_NORMAL
- en: The final code for this section can be found in the `chapter9/2/profitoro` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vuex store with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now try to test our Vuex store. The most critical parts of our store
    to test are our actions and mutations because they can actually mutate the store''s
    state. Let''s start with the mutations. Create the `mutations.spec.js` file in
    the `test` folder and import `mutations.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to write unit tests for our mutation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mutations are very simple functions that receive a state object and set some
    of its attribute to the given value. Thus, testing mutations is fairly easy—we
    have just to mock the state object and pass it to the mutation we want to test
    with a value we want to set. In the end, we have to check whether the value has
    been actually set. Let''s, for example, test the mutation `setWorkingPomodoro`.
    This is what our mutation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test, we need to create a mock for the state object. It doesn''t need
    to represent the complete state; it needs to at least mock the `workingPomodoro`
    property of the state''s `config` object. Then we will call the mutation, passing
    it our mocked state and the new value for the `workingPomodoro` and we will assert
    that this value has been applied to our mock. Thus, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a mock for the state object: `let state = {config: {workingPomodoro:
    1}}`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the mutation with a new value: `mutations.setWorkingPomodoro(state, 30)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assert that the value has been set to the mocked object: `expect(state.config).toEqual({workingPomodoro:
    30})`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete code for this test looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The exact same mechanism should be applied to test the rest of the mutations.
    Go ahead and finish them all!
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous testing with Jest – testing actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s move on to the more complex stuff to test—our actions! Our actions are
    mostly asynchronous and they use complex Firebase application objects inside.
    This makes them quite challenging to test but we do love challenges, don''t we?
    Let''s have a look at the first action in the `actions.js` file. It''s the `uploadImages`
    action that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What could we possibly test here? We could, for example, test that the `_uploadImage`
    function has been called the exact same number of times as the size of the array
    of images that was passed. For this, we must mock the `_uploadImage` method. In
    order to do that, let''s export it as well in our `actions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can mock this method and check the number of times the `mock` has been
    called. The mocking itself is pretty easy; we just need to assign the `actions._uploadImage`
    to the `jest.fn()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, our `actions._uploadImage` has a special magical property called
    `mock` that we have already talked about. This object gives us the opportunity
    of accessing the number of calls being done on the `_uploadImage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to assert that the number of calls is three, we can just run the following
    assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check the full documentation regarding mocking functions in Jest here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/jest/docs/mock-functions.html#content](https://facebook.github.io/jest/docs/mock-functions.html#content)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very well, but where should we call this expectation? The `uploadImages` function
    is asynchronous; it returns a promise. Somehow, we could sneak into the future
    and listen to the promise resolution and call our assertion there. Shall we define
    some *callbacks* and invoke them once the promise is resolved? No, no need for
    that. Just call your function and run the assertions inside the `then` callback.
    Thus, our test will look as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It just works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a more complex mock – for our `firebaseApp`. How do we decide
    what and how to mock? Just look at the code and check what''s being done. So let''s,
    for example, check the `createNewWorkout` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What's going on here? Some new key is generated by the state's `workoutsReference`
    and then the object called `updates` is created. This object contains two entries—one
    for each of the Firebase database resources that held the workout object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then Firebase''s database `update` method is called with this object. Thus,
    we have to mock the database''s `update` method so we can check the data that
    it''s being called with. We have also to inject this mock somehow into the big
    Firebase application mock. Create a folder to hold our mock files and call it
    `__mocks__`. Add two files to this directory—`firebaseMocks.js` and `firebaseAppMock.js`.
    Create an empty function for the `update` method in the `firebaseMocks` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mock for the `firebaseApp` object that will call the mocked `update`
    function inside its `database` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the `createNewWorkout` method, we will use the `jest.mock`
    function to bind the Firebase object to its mock. Check the detailed documentation
    regarding the `jest.mock` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options](http://facebook.github.io/jest/docs/en/jest-object.html#jestmockmodulename-factory-options).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to bind our mock before importing the `actions.js` module. In this
    way, it will already use the mocked object. Thus, our import section will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what is going on with a workout object so we know what and how to
    mock and have a deterministic test. We have these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our mock of the state object must contain the user object with the predefined
    `displayName` and `uid`. Let''s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What happens next?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we need to mock the `Date.now` object. Let''s do the same as we
    did in the `utils` test spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s read our method further. It contains a line that generates the `newWorkoutKey`
    variable based on the `workoutsRef` state''s object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s mock the `workoutsRef` in our state mock as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know that when we call the `addNewWorkout` method, in the end it is
    expected to call the Firebase database `update` method with an object that will
    contain two entries – one with a key `/user-workouts/1/59` and another with a
    key `/workouts/59`, both with the same entry for the `workout` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, first we need to create a spy. A spy is a special function that will replace
    the function we bind it to and spy on whatever has been happening with this function.
    Again, you don't need to install any external plugin or library for spies. Jest
    provides them out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out Jest spies in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname](http://facebook.github.io/jest/docs/jest-object.html#jestspyonobject-methodname)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we want to spy on the `update` mock function. Let''s create a spy on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, our assertion will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole test will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to create mocks on different Firebase methods and how to create
    spies on them, you can create the rest of test specifications to test the rest
    of the actions. Check out the code for this section in the `chapter9/3/profitoro`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward and learn how we can actually test our Vue components with
    Jest!
  prefs: []
  type: TYPE_NORMAL
- en: Making Jest work with Vuex, Nuxt.js, Firebase, and Vue components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not the easiest task to test Vue components that rely on the Vuex store
    and Nuxt.js. We have to prepare several things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must install `jest-vue-preprocessor` in order to tell Jest
    that Vue components files are valid. We must also install `babel-preset-stage-2`,
    otherwise Jest will complain about the ES6 *spread* operator. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependencies are installed, add the `stage-2` entry to the `.babelrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to tell Jest that it should use the `babel-jest` transformer for
    the regular JavaScript files and the `jest-vue-transformer` for the Vue files.
    In order to do so, add the following to the jest entry in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We use some images and styles in our components. This might result in some
    errors because Jest doesn''t know what these SVG files are about. Let''s add yet
    another entry to the `moduleNameMapper` Jest entry in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are doing this because we don't really want to test pictures or CSS/SCSS
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `styleMock.js` and `fileMock.js` to the `__mocks__` directory with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the official documentation for more details in this regard: [https://facebook.github.io/jest/docs/webpack.html](https://facebook.github.io/jest/docs/webpack.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add name mappers for both Vue and Vuex files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step of configuration, we need to map the names for the Vue files.
    Jest is dumb and it can''t understand that we are actually importing the Vue file
    if we are importing it without its extension. Thus, we must tell it that whatever
    is being imported from the `components` or `pages` folder is a Vue file. So, in
    the end of these configuration steps, our `moduleNamMapper` entry for jest will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to test our components. You can find the final code with all
    these configuration steps in the `chapter9/4/profitoro` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vue components using Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by testing the `Header` component. Since it depends on the Vuex
    store which, in its turn, highly depends on Firebase, we must do the exact same
    thing we just did to test our Vuex actions—mock the Firebase application before
    injecting the store into the tested component. Start by creating a spec file `HeaderComponent.spec.js`
    and paste the following to its `import` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we first mock the Firebase application and then import our store.
    Now, to be able to properly test our component with the mocked store, we need
    to inject the store into it. The best way to do that is to create a `Vue` instance
    with the `HeaderComponent` in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have bound the reference to the mounted component. Now we will
    be able to access our header component by invoking `$mounted.$refs.headercomponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What can we test in this component? It actually doesn''t have so many functionalities.
    It has a method `onLogout` which calls the `logout` action and pushes the `/`
    path to the component''s `$router` property. So, we could actually mock the `$router`
    property, call the `onLogout` method, and check this property''s value. We can
    also spy on the `logout` action and check that it has been called. Thus, our test
    for the `onLogout` method of the component can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests. You will see a lot of errors related to the Nuxt component not
    being properly registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing Vue components using Jest](../images/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Vue errors regarding the nuxt-link component
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, if you can live with these errors, just live with them. Otherwise, run
    your tests in production mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that if you run your tests in production mode, you can actually miss
    some relevant errors.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You were able to test a Vue component that depends on Nuxt,
    Vuex and Firebase with Jest! Check the code for this test in the `chapter9/5/profitoro`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the coolest features of Jest is *snapshot testing*. What is snapshot
    testing? When our components are being rendered, they produce some HTML markup,
    right? It would be really important that once your application is stable, none
    of the newly added functionality breaks the already existing stable markup, don''t
    you think? That''s why snapshot testing exists. Once you generate a snapshot for
    some component, it will persist in the snapshot folder and on each test run, it
    will compare the output with the existing snapshot. Creating a snapshot is really
    easy. After you mount your component, you should just call the expectation `toMatchSnapshot`
    on this component''s HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'I will run snapshot testing for all the pages inside one test suite file. Before
    doing that, I will mock the getters of our Vuex store because there are some pages
    that use the user object, which is not initialized, thus resulting in an error.
    So, create a file `gettersMock` inside our `__mocks__` folder and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to the imports. As we''ve already figured out, Jest is not really
    great in figuring out what is what in our imports, thus it will complain about
    relative imports (those that start from the dot, for example, in our `index.js`
    files inside each of the `components` folders). Let''s replace all those relative
    import paths with their absolute equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve also added one more mapping to the name mapper entry inside the `package.json`
    `jest` entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Create a `pages.snapshot.spec.js` file and import all the necessary
    mock objects and all the pages. Don''t forget to bind the corresponding mocks
    to Vuex `getters` functions and to the Firebase application object. Your import
    section should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a test spec for each of the pages. We will bind each page component
    in the same way as we have bound the `Header` component. We will export the components
    that we want to test as components of a Vue instance and mount this Vue instance
    after being created. Thus, the index component binding will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that you have to do now is to execute the snapshot expectation.
    Thus, the full test spec for the index page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the exact same steps for all the pages. Run the tests! Check the coverage.
    Now we are talking! We''ve actually touched almost all the components of our application!
    Look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Snapshot testing with Jest](../images/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Almost all the components and files of our application appear in the coverage
    report!
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing, which is actually the whole purpose of the snapshot
    testing, is the generated folder called `__snapshots__` inside the test folder.
    Here, you will find the newly generated snapshots of all the HTML markup of all
    your pages. These snapshots look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Snapshot testing with Jest](../images/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Jest snapshots of the ProFitOro pages
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you do something that will affect your markup, the tests will fail.
    If you really want to update snapshots, run the tests with the update flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: I find snapshot testing a really fun and exciting feature!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is very important that you commit your snapshot files! Check the detailed
    documentation regarding the snapshot testing in the official Jest website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/jest/docs/snapshot-testing.html](https://facebook.github.io/jest/docs/snapshot-testing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The final code for this chapter can be found in the `chapter9/6/profitoro` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used very hot technology to test our Vue application. We
    used Jest and learned how to create mocks, test components, and run snapshot testing
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally see our application live! We will deploy
    it using Google Firebase Hosting and provide the necessary CI/CD tooling so our
    application is deployed and tested automatically each time it is pushed to the
    master branch. Are you ready to see your work live, up and running? Let's go!
  prefs: []
  type: TYPE_NORMAL
