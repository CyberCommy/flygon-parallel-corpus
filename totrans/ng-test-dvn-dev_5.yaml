- en: Chapter 5. Protractor, a Step Ahead
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。Protractor，更进一步
- en: End-to-end testing is real fun as long as it interacts directly with the browser,
    but a good developer should know the advanced features of Protractor to perform
    large-scale application testing. Besides that, debugging is kind of a challenge
    in e2e testing as it depends on the DOM element of the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试真的很有趣，只要直接与浏览器交互，但是一个好的开发者应该了解Protractor的高级功能，以进行大规模的应用程序测试。此外，在端到端测试中调试是一种挑战，因为它取决于浏览器的DOM元素。
- en: 'Protractor has some APIs for debugging. This chapter will mostly cover those
    APIs and features, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor有一些用于调试的API。本章将主要涵盖这些API和功能，包括以下内容：
- en: Setting up and configuring Protractor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和配置Protractor
- en: Some advanced Protractor APIs such as browser, locator, and action
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些高级的Protractor API，比如browser，locator和action
- en: Debugging Protractor with the `browser.pause()` and `browser.debug()` APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`browser.pause()`和`browser.debug()`API来调试Protractor
- en: Advanced setup and configuration
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设置和配置
- en: In the previous chapter, we saw a basic and commonly used setup and configuration
    for Protractor. Here, we will take a look at some advanced configurations that make
    installation simpler and more powerful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Protractor的基本和常用的设置和配置。在这里，我们将看一些高级配置，使安装更简单和更强大。
- en: Installing Protractor globally
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局安装Protractor
- en: 'Here are the steps to install Protractor globally:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全局安装Protractor的步骤：
- en: 'Once Node.js has been installed and is available in command prompt, type the
    following command to install Protractor globally on the system:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Node.js被安装并在命令提示符中可用，输入以下命令在系统上全局安装Protractor：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command uses Node's `npm` command to install Protractor globally
    so that we can use Protractor just with the `protractor` command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令使用了Node的`npm`命令全局安装Protractor，这样我们就可以只用`protractor`命令来使用Protractor了。
- en: 'Test whether the Protractor version can be determined as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试Protractor版本是否可以如下确定：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Advanced configuration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级配置
- en: 'In this section, we will be configuring Protractor a bit more using the following
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下步骤对Protractor进行更详细的配置：
- en: 'Update the protractor `config` file to support multiple browsers in a single
    test suite. The `multiCapabilities` parameter is an array that takes multiple
    `browserName` objects for any test suite, as shown here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新protractor的`config`文件以支持单个测试套件中的多个浏览器。`multiCapabilities`参数是一个数组，可以为任何测试套件传递多个`browserName`对象，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can set advanced settings for browsers in the `capabilities` parameter;
    for example, for `chrome`, we can pass extra parameters as `chromeOptions`, as
    follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`capabilities`参数中为浏览器设置高级设置；例如，对于`chrome`，我们可以传递额外的参数作为`chromeOptions`，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sometimes, we may need to run Protractor directly without Selenium or WebDriver.
    This is possible by passing a parameter in the `config.js` file. The parameter
    is `directConnect: true` in the configuration object, as shown here:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '有时，我们可能需要直接运行Protractor而不使用Selenium或WebDriver。这可以通过在`config.js`文件中传递一个参数来实现。该参数是配置对象中的`directConnect:
    true`，如下所示：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! We have configured Protractor a step ahead.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经配置了Protractor更进一步。
- en: Protractor APIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protractor API
- en: The main activities of an e2e test for any web page are to get the DOM elements
    of that page, interact with them, assign an action to them, and share information
    with them; then, the user can get the current state of the website. To enable
    us to perform all these actions, Protractor provides a wide array of APIs (some
    are from the web driver). In this chapter, we will look at some commonly used
    APIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Protractor works with an Angular project,
    where we had to interact with UI elements. For that, we used a few Protractor
    APIs, such as `element.all`, `by.css`, `first`, `last`, and `getText`. However,
    we didn't see or understand the workings of these APIs in depth. To understand
    the workings of APIs in Protractor is very simple, but in real life we will mostly
    have to work with bigger, complex projects. Hence, it's important that we understand
    and know more about these APIs in order to interact with the UI and play with
    its events.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protractor works with Selenium WebDriver, which is a browser automation framework.
    We can use a method from the Selenium WebDriver API to interact with the browser
    from the test spec. We will take a look at a few of them in the following sections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate the browser to a specific web address and load the mock modules
    for that page before the Angular load, we will use the `.get()` method by passing
    the specific address or relative path:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the current page''s web URL, use the `CurrentUrl()` method, as shown
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To navigate to another page and browse it using in-page navigation, `setLocation` is
    used, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get the title of the current page (basically, the title that is set in the
    HTML page), the `getTitle` method is used, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To reload the current page with the mocks module before the Angular load, the
    `refresh()` method is used, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To pause the test process, the `pause()` method is used. This is useful for debugging
    the test process, and we will use this test debugging section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To debug the test process, the `debugger()` method is used. This method is
    different and can be considered an advanced level of the `pause()` method. This
    is useful for advanced debugging of the test process, along with injecting custom
    helper function into the browser. We will use this test debugging section as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To close the current browser, `close()` is used. This is useful for complex
    multimodule testing, when we sometimes need to close the current browser before
    opening a new one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To support Angular in Protractor, we have to set the `useAllAngularAppRoots`
    params to `true`. The logic behind doing this is that, when we set this parameter
    to `true`, it will search for all Angular apps in the page while the element finder
    traverses through the page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Elements
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor itself exposes some global functions, and `element` is one of them.
    This function takes a locator (a kind of selector--we will discuss it in the next
    step) and returns an `ElementFinder`. This function basically finds a single element
    based on the locator, but it supports multiple element singing along with chaining
    another method as `element.all`, which also takes a locator and returns an `ElementFinderArray`.
    Both of them support chaining methods for the next action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: element.all
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we already know, `element.all` returns an `ElementArrayFinder` that supports
    chaining methods for the next action. We will look at a few of them and how they
    actually work:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To select multiple elements as an array with a specific locator, we should
    use `element.all`, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After getting a bunch of elements as an array, we may need to select a specific
    element. In that case, we should be chaining `get(position)` by passing the specific
    array index as the position number:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After getting a bunch of elements as an array, we might need to select child
    elements again with a preferred locator, and for that we can chain the `.all(locator)`
    method again with the existing elements, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After getting the desired elements, we might want to check whether the number
    of elements selected is as expected. There is a method, `count()`, that is used
    to chain to get the total number of selected elements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to the `get(position)` method, we can get the first element from the
    array by chaining the `first()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to the `first()`method, we can get the last element from the array
    by chaining the `last()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As long as we have a bunch of elements as an array, we may need to traverse
    though the elements to take any action. In that case, we may need to go through
    a loop by chaining the `each()` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just like the `each()` method, there is another method, `filter()`, to chain
    with the element array to traverse through the items and assign a filter to them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: element
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `element` class returns `ElementFinder`, which means a single element in
    the element array, and this also supports chaining methods for the next action.
    In the previous examples, we saw how to obtain a single selected element from
    the element array so that all of the chaining methods work on that single element
    as well. There are a lot of chaining methods for working on a single element,
    and we will look at a few that are most commonly used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'By passing a specific locator as an argument to the `element` method, we can
    select a single DOM element, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After getting a specific single element, we may need to find the child element
    of the element on which we have to chain the `element.all` method with the rerun
    `elementFinder` object. For this, pass a specific locator to find the child `elementFinderArray`,
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After selecting a specific element, we might need to check whether that element
    is present while chaining the `isPresent()` method, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Actions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions mainly change the method that affects or triggers the selected DOM element.
    The goal of selecting a DOM element is to interact with it by triggerring some
    actions so that it can act like a real user. There are some commonly used actions
    for specific interaction. We will look at a few of them here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the inner text or contained text of any element, we have to chain the
    `getText()`method with the `elementFinder` object after selecting the specific
    element, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get the inner HTML of any element, we have to chain the `getInnerHtml()`method
    with the `elementFinder` object after selecting the specific element, as shown
    here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can find any specific attribute value of any element by passing the attribute
    key to the `getAttribute()` method, which will chain with the selected `elementFinder`
    object, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In most cases, we need to clear the value of the input field. For that, we
    can chain the `clear()`method with the selected `elementFinder` object, as shown:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that it's only the input or texture that may have some value and needs
    you to clear/reset the value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'When we need to trigger a click event on any button, link, or image, after
    selecting a specific `elementFinder` object, we will need to chain the `click()`
    method, and it will act like a real click on that element:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sometimes, we might need to trigger the `submit()` method for form submission.
    In that case, we have to chain the `submit()` method with the selected element.
    The selected element should be a `form` element:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Locators
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Locators inform Protractor how to find a certain element in the DOM element.
    Protractor exports `locator` as a global factory function, which will be used
    with a global `by` object. We can use them in many ways based on our DOM, but
    let's look at some of the most commonly used ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'We can select any element by passing any of the CSS selectors to the `by.css`
    method, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can select any element by passing its element ID to the `by.id` method,
    as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also select a specific element or elements by tag name by passing it
    to `by.tagName`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To select the DOM element of any specific input field, we can pass the name
    in the `by.name` method, as shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Besides a CSS selector or ID, we can select a specific button by passing its
    text label to `by.buttonText`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can find an element by passing the model name defined as an `ng-model` on
    `by.model`, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, we can find a specific DOM element by passing its binding defined
    with `ng-bind` in `by.bindings`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Besides all the locators explained earlier, there is another way to find a
    specific DOM element: a custom locator. Here, we have to create a custom locator
    using `by.addLocator` by passing the locator name and callback. Then, we have
    to pass that custom locator with `by.customLocatorName(args)`, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Protractor tests - postmortem
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's kind of difficult to debug e2e tests as they depend on the entire ecosystem
    of an application. Sometimes they depend on prior actions such as login, and sometimes
    they depend on permissions. Another major barrier to debugging e2e is its dependency
    on WebDriver. As it acts differently with different operating systems and browsers,
    this makes it difficult to debug e2e. Besides that, it generates long error messages,
    which makes it difficult to separate browser related issues and test process errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Still, we will try to debug all e2e tests and see how that works for our case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Types of failure
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There might be various reasons for the failure of a test suite as long as it
    depends on WebDriver and various parts throughout the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some known failure types:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**WebDrive failure**: WebDriver throws an error when a command can''t be completed.
    For example, a browser can''t get the address that''s defined to help it navigate,
    or maybe an element is not found as expected.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebDriver unexpected failure**: Sometimes, WebDriver fails and gives an error
    when it fails to update the web driver manager. This is a browser and OS-related
    issue, although it''s not common.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor failure for Angular**: Protractor will fail when Angular is not found
    in the library as expected because the Protractor test depends on Angular itself.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor Angular2 failure**: Protractor will fail for an Angular project''s
    test spec when the `useAllAngular2AppRoots` parameter is missing in the configuration
    because, without this, the test process will look at one single root element while
    expecting more elements in the process.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor failure for timeout**: Sometimes, Protractor fails for the timeout
    when the test spec falls into a loop or a long pool and fails to return data in
    time. However, a timeout is configurable, so it can be increased as needed.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expectation failure**: This is a common failure in the test spec.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an existing project
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code used in this test comes from [Chapter 4](ch04.html "Chapter 4. End-to-End
    Testing with Protractor"), *End to End Testing with Protractor*. We will copy
    the code to a new directory: `angular-protractor-debug`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the application was a to-do application that had some items in
    the to-do list, and we added some items to it. It has a single component class,
    `AppComponent`, which has a list of items, and an `add` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The current directory should be structured as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an existing project](graphics/image_05_001.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'After verifying that the folder structure is the same as shown in the preceding
    screenshot, the first job is to get the required dependencies, `node_modules`,
    locally by running the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will install all the required modules. Now, let''s build and run the project
    with the `npm` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything should be fine now: the project should run on `http://localhost:3000`,
    and the output should be as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an existing project](graphics/image_05_002.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: With that, we are ready to go on to the next step of implementing a debugger
    in our Angular project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Including the debugger in the project
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before adding the debugger to our project, let's run the e2e test in our existing
    project. We hope to pass without any failure in the e2e test specs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run it using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As expected, our tests passed. The result is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Including the debugger in the project](graphics/image_05_003.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'We can add our debugging code in the same place where the passed test specs
    are, but let''s keep the passed test case separate and play with the debugger
    in a different directory. Let''s create a new directory, `debug/`. We will need
    two files in the directory: one for the configuration and the other for the spec.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: For the Protractor configuration file, we can copy the `protractor.conf.js`
    file and rename it to `debugConf.js`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Everything in the configuration will be the same as the previous configuration.
    However, we need to increase the default timeout for the Jasmine test, or the
    test will timeout during debugging.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s increase the timeout to `3000000` ms:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we will need a spec file to which to write the test spec and debug tests.
    Save the new spec file as `app.debug.e2e.ts`. Oh yes, we will need to change the
    config file once again to define the spec files for debugging.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can make a simple test spec file for `app.debug.e2e.ts`. Then, we can add
    debug codes and play with them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple test specs are as shown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Pausing and debugging
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To debug any test spec, we must pause the test process and see what is going
    on step-by-step. Protractor also has built-in methods to pause the process. Here
    are two methods to pause and debug the test process:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`browser.pause()`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browser.debugger()`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pause
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging Protractor tests becomes easy and simple with the `browser.pause()`
    command. Using the `pause()` method, we can enter the Protractor debugger control
    flow and execute some commands to check out what's happening in the control flow
    of the test. Mostly, developers use debuggers in tests when the test fails with
    an unknown error and there are long error messages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: After using the `browser.pause()` command, we can use a few more commands based
    on our needs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a brief look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`c`: If we type `c` as a command, it will move one step forward in the test,
    and we will see how the test command works in depth. If we plan to move forward
    with a test, it''s better to do it quickly as there is a timeout issue ( the Jasmine
    default timeout), which we''ve learned about. We will see an example later on.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repl`: By typing `repl` as a command, we can enter the interactive mode of
    debugging. It''s known as as the interactive mode as, from there, we can interact
    directly with the browser from the terminal by typing WebDriver commands. A response,
    result, or error from the browser will be displayed on the terminal as well. We
    will see more hands-on examples later.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ctrl + C`: Press ***Ctrl*** + C to exit pause mode and continue the test.
    When we will use this, the test will continue from the point where it paused.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick example
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use `browser.pause()` in test specifications, we will have to add the method
    to the test spec at the places we want to pause the test and watch the control
    flow for debugging. Here, we just have one test spec with a wrong/failing test
    case, we know it will fail, and we will find out why it failed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to add the `pause()` method, as shown, to the test `spec it()
    {}` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's time to run the test. As we've separated the test spec for the debugger,
    we will run the test via Protractor (not `npm`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test with the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we have placed the `browser.pause()` method before the `expect()` method,
    it will pause there. We can see in the control flow that this makes it wait for
    Angular:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](graphics/image_05_004.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'We will move forward; for that, let''s type `C`. It will run `executeAsyncScript`
    and will wait for Angular to load:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](graphics/image_05_005.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'We will move another step ahead by typing `C`. It will try to select the element
    based on the locator provided by us, that is, `element(by.id(''my_id'')`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](graphics/image_05_006.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'We are close to getting the test result now. For that, we will have to move
    another step forward by typing `C`. Now, it will try to select the element based
    on the locator, and it will fail to select that. This will give a result with
    an error message, as expected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](graphics/image_05_007.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Debugging with interactive mode
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enter interactive mode, we have to type `repl`, after which we can run any
    command used in the test spec.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find the element and its text:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result is the same as we got previously, by moving forward step by step,
    by typing `C`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: `NoSuchElementError: No element found using locator: By (css selector,`
    `*[id="my_id"])`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how interactive mode works for a valid locator, when the `element`will
    be found:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Result**: `test`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using the debugger
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging with the `browser.debugger()` command is a bit complex and more advanced
    than using `browser.pause()`. With the `browser.pause()` command, we can pause
    the control flow of the test and inject the custom helper functions into the browser
    so that debugging happens in the same way as we would debug in a browser console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This debugging should be under node in debug mode, like here in Protractor debugging.
    This debugging is not useful for someone bad at node debugging.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: To use the `browser.debugger()` method in the test spec, we will have to add
    the method to the test spec at the points where we want to set a breakpoint and
    watch the control flow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'For us, we have to add the `debugger()` method, as follows, to the `test spec
    it() {}` function, and this will be our breakpoint:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now let''s run it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the debugger, we have to add `debug` to the command after `protractor`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command, we have to move forward by typing `C`, but here
    we need to do it just once. The output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the debugger](graphics/image_05_008.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Self-test questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. `Selenium WebDriver` is a browser automation framework.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q2\. Using `browser.debugger()` is a simple way to debug Protractor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q3\. What are `by.css()`, `by.id()`, and `by.buttonText()` called?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Elements
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locators
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsers
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protractor has various kinds of API. In this chapter, we tried to understand
    some of the most commonly used APIs with some examples. We also covered API types
    (such as browser, elements, locator, and actions), and how they are chained with
    one another, in some detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Debugging was introduced in this chapter, and we tried to learn a simple way
    to debug, using `browser.pause()`, in more detail, and then we moved on to a complex
    method (`browser.debugger()`), and understood that complex developers need node
    debugger experience.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into more real-life projects; further, we
    will go through the top-down and bottom-up approaches and learn them both.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
