- en: A Closer Look at Type Deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn all of the ins and outs of type deduction in
    C++, including some of the new additions in C++17\. This chapter is important
    as it will teach you all of the ways in which the compiler will attempt to deduce
    type information automatically for you. Without a firm understanding of how type
    deduction works in C++, it is possible to create code that doesn't work as expected,
    especially when using `auto` and template programming. The knowledge gained from
    this chapter will provide you with the skills to properly leverage type deduction
    in your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using auto and type deduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how `decltype` type deduction rules work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with template function type deduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging template class type deduction in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with user-defined type deduction in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Using auto and type deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how the compiler handles the `auto` keyword, specifically
    for type deduction. This recipe is important because how `auto` is handled is
    not intuitive, and without a clear understanding of how `auto` works, your code
    will likely contain bugs and performance issues. The topics included in this recipe
    have a general description of `auto`, type deduction, forwarding (or universal)
    references, l-values, and r-values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `auto` keyword is a feature added to C++11 called a **placeholder type specifier**.
    In other words, the `auto` keyword is used to tell the compiler a variable's type
    will be deduced from its initializer. Unlike other languages that use placeholder
    types, the `auto` keyword must still adhere to the strict type system of C++,
    meaning `auto` should not be confused with `std::any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is possible with `std::any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is not allowed with `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we define `std::any`, which stores an integer. We then
    replace the integer inside `std::any` with a C-style string. With respect to `auto`,
    this is not possible as, once the compiler deduces the variable's type at initialization,
    the type cannot change (no different than any other variable in C++).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example of how to initialize a variable using `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a971f5a-11f4-4d46-a47e-a62cfab04dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding code, we create four variables using `auto`, initialize
    them, and then use a function called `show_type()` to return the output of the
    variable's type.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how the `show_type()` function works, please see
    the code that comes with this chapter (the details of this function will make
    more sense after you finish reading this entire chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The first variable in our example, `i1`, is deduced as an integer. This is because
    numeric types in C++ are always deduced as an integer, which we see with the `c`
    and `r` variables in our example as well. The reason is the compiler is allowed
    to increase the size of any variable during compilation, meaning, when the compiler
    sees `c + 42`, the first thing it does is store the value of `c` in a temporary
    integer before completing the addition.
  prefs: []
  type: TYPE_NORMAL
- en: The second variable, `i2`, in our example is also deduced as an integer as the
    `{}` notation is another form of initialization for any type in C++, with some
    additional rules. Specifically, `i3` and `i4` are deduced as `std::initializer_list`
    of integers since the last two use the `= {}` notation, which is defined by the
    C++ specification to always deduce to `std::initializer_list` in C++17\. It should
    be noted that this assumes the compiler adheres to the specification, which is
    not always the case in this specific example, which is why critical system specifications
    such as AUTOSAR do not allow this type of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` keyword can also be combined with CV qualifiers (that is, `const`/`volatile`)
    as well. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding examples results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a02c94-dc87-4f79-b3bf-e2e8118cf556.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, each variable is decorated with the proper
    CV qualifiers as defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until now, in each example, we could have simply replaced the use of `auto`
    with `int` and nothing would have changed, which begs the question, why use `auto`
    in the first place? There are a couple of reasons why:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using something other than `auto` means your code is likely specifying a variable''s
    type twice. For example, `int *ptr = new int;` states that the `ptr` variable is
    an integer twice: once in the variables declaration, and a second time in the
    variable''s initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some types in C++ are really long (for example, iterators), and the use of `auto`
    can greatly simplify the verbosity of your code, for example, `auto i = v.begin()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing template code, `auto` is required to properly handle reference
    types such as forwarding references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with references is where the use of `auto` gets confusing, and where
    most people make mistakes. To better explain, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we create an integer, `i`, and set it to
    `42`. We then create two more integers: one is a copy of `i`, while the second
    is a reference to `i`. As shown in the output, we get the expected types, `int`
    and `int&`. Using the `auto` keyword, we could expect that if we said something
    like `auto a = i2`, we would get an `int&` type as `i2` is a reference to an integer,
    and since `auto` deduced its type based on how it is initialized, we should get `int&`.
    The problem is, we do not. Instead, we get `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that `auto` gets its type based on how it is initialized
    without including the reference type. In other words, the use of `auto` in the
    example is only picking up on the `i2` type, without paying attention to whether
    or not `i2` is an integer or a reference to an integer. To force `auto` to be
    a reference to an integer, we must use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This output is as expected. The same rules apply to r-value references, but
    become even more complicated. For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This output is again as expected. Based on what we have already learned, we
    would expect that the following would be required to get an r-value reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that this results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we did not get an r-value reference as expected.
    Anything labeled `auto &&` in C++ is considered a forwarding reference (this is
    also known as a universal reference, a term coined by Scott Meyers). The universal
    reference will deduce to either an l-value or r-value reference, depending on
    what the universal reference is initialized with.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because `i1` was defined earlier as an integer, and so `a6` becomes
    an l-value reference to `i1`. The following is also true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because `i2` was defined earlier as an l-value reference to an integer,
    which means that the universal reference becomes an l-value reference to an integer
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The confusing result is the following, as already shown in the preceding code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This again results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `i3` was defined earlier as an r-value reference to an integer (proven
    by the resulting output), but the universal reference did not forward the r-valueness
    from `i3`. This is because, although `i3` was defined as an r-value reference,
    once it is used, it becomes an l-value reference. As Scott Meyer has stated in
    the past, if a variable has a name (in our case, `i3`), it is an l-value, even
    if it starts off as an r-value. Another way to look at this is once a variable
    is used (as in accessed in any way), the variable is an l-value. So, the preceding
    code actually works as it should. `i3`, although defined as an r-value, is an
    l-value, and so the universal reference becomes an l-value reference to an integer,
    just the same as `i1` and `i2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an r-value reference using `auto`, you must do the same thing as you
    would without the use of `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the best way to think about `auto` is
    to simply replace the word `auto` with the actual type (in this case, `int`),
    and whatever rules apply to the actual type also apply to `auto`. The difference
    is that if you attempted to write `int &&blah = i`, you would get an error as
    the compiler would recognize that you are attempting to create an r-value reference
    from an l-value reference, which is not possible (as you can only create an r-value
    reference from another r-value reference).
  prefs: []
  type: TYPE_NORMAL
- en: The reason the preceding examples are so important is that `auto` will not generate
    a complaint from the compiler. Instead, it will produce an l-value when you meant
    to create an r-value, which could result in inefficiencies or bugs. The most important
    thing to learn about the use of `auto` is that if it has a name, it is an l-value;
    otherwise, it is an r-value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As the numeric value `42` does not have a variable name, it is a constant, and
    hence, the universal reference becomes an r-value reference to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should also be noted that the use of `auto` confusingly does inherit CV
    qualifiers when dealing with references. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/638a9ffc-4c76-48bd-9656-a209fb3c43b6.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, the first integer remains an `int` type
    because a copy of `const int` is an `int`. Both `i2` and `i3`, however, become
    references to `const int`. If we were to replace `auto` with `int`, we would get
    a compiler error as you cannot create a non-`const` reference to `const int`,
    yet the use of `auto` will gladly convert your non-`const` variable into a `const`
    variable for you. The problem with this is that you will end up with odd error
    messages when you attempt to modify your variable, complaining that the variable
    is read-only when, in fact, you have not explicitly defined the variable as `const`.
    In general, it is good practice to always mark a variable defined with `auto`
    as `const` if you expect `const`, or non-`const` if you do not, preventing these
    sometimes hard-to-identify bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how decltype type deduction rules work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about how type deduction works with `decltype()`
    and `decltype(auto)`, and how to avoid the issues of referenceness with `auto`
    using `decltype(auto)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important as `auto` has some strange behavior in how it handles
    references that `decltype()` addresses, providing C++ with a means to handle type
    deduction more predictably, especially when working with C++ templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Neither `auto` nor `typename` in C++ provides the ability to get a variable''s
    type and create new types using that information. To better explain why you might
    want to do this, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our example with a function that takes any function as an input and
    returns the result of this function plus `10`. We can then execute this function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we pass the `question()` function a pointer
    to another function that returns `short`. On executing this function, we store
    the results and then we use a function called `show_type()`, which is designed
    to output what type the provided type is. This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8f08892-9ea4-4d72-9d86-197819b5e39f.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem with this example is the fact that the type that is returned is
    not the same type that we were given. C++ is allowed to increase the size of any
    variable as needed, and often does with shorts, especially when you attempt to
    perform arithmetic on a short with numeric values as numeric values are represented
    as integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we do not know what the return type of the provided function will be
    in the `question()` function, there is no way to fix this issue. Enter `decltype()`.
    To explain, let''s update our example to address the preceding problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we replaced `auto` with `decltype(func())`.
    This tells the compiler to get the return type of `func()` and use that type to
    define `x`. As a result, the compiler converts this template into the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens instead of the following, which was expected initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This then results in the following output when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74f2a492-4468-4399-82cf-1bcb78645046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, we are now getting the proper type returned
    from our `question()` function. With C++14, we can take this example a bit further
    and write it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example in the preceding code snippet, we converted the `question()`
    function into `constexpr`, which allows the compiler to optimize out the function
    call, replacing a call to `question()` with the `func() + 10` statement. We also
    remove the need for a stack-based variable by explicitly telling the compiler
    what type we wish the function to return using the `-> decltype()` function return
    syntax. It should be noted that this syntax is needed as the following would not
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will not compile because the compiler does not have the definition
    of `func()` yet, and hence it doesn't know what its type is. The `->` syntax addresses
    this by placing the return type at the end of the function definition instead
    of at the front.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decltype()` specifier can also be used in place of `auto` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb6593f6-0f30-46a3-9beb-ca5ecc548089.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we create two integers using `decltype(auto)` and initialize
    them to `42`. In this specific case, `decltype(auto)` and `auto` operate exactly
    the same. Both define the placeholder type as an integer as both are initialized
    using a numeric value, which, by default, is `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `auto`, you can decorate `decltype(auto)` with CV qualifiers (that is,
    `const`/`volatile`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ded88455-57d8-42c0-bf42-bf31d47ed56a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The real magic of `decltype(auto)` is how it handles references. To demonstrate
    this, let''s start with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we have created an integer, an l-value reference
    to an integer, and an r-value reference to an integer. Let''s see what happens
    if we attempt to use `auto` instead of `int` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We then see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding example, we are only given integers. All of the references
    were removed. The only way to get references with `auto` is if we explicitly define
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following, expected, output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The problem with having to add the extra `&` operators to explicitly define
    the reference type is that this assumes that, in our template code, we actually
    know what the references should be. If this information is not available, we would
    have no way of writing a template function and know whether we could create an
    l-value or r-value reference, likely resulting in a copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, `decltype(auto)` not only inherits the type and CV qualifiers
    during initialization, it also inherits the references as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code, when executed, results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, `decltype(auto)` can be used to inherit all
    of the type information of the value it is being initialized to, including referenceness.
  prefs: []
  type: TYPE_NORMAL
- en: Working with template function type deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how template function type deduction works. Specifically,
    this recipe will teach you how template function type deduction works the same
    as `auto` type deduction, as well as how function type deduction can be used with
    some odd types (for example, C-style arrays).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important as it will teach you how to write function templates
    properly, eliminating the need to explicitly define type information when invoking
    a function template.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to lessons being taught in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++11, the standards committee added the ability to automatically deduce
    a template function's type information based on the arguments that were passed
    to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function creates a standard template function that executes a
    function called `show_type()` designed to output the type information that it
    is provided with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C++11, we would use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler already knows that the template should define the `T` type as
    an integer as that is what the function was provided for. C++11 removes this redundancy,
    allowing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf27d37-b223-47d6-8cca-91327b06bcef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like `auto`, however, this type deduction gets interesting when r-value references
    are used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example defines `t` as a forwarding reference (also known as
    a universal reference). The universal reference takes on whatever reference type
    it is passed. For example, we call this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55fe5e8f-d61e-4087-9c56-e55f50384a8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output shows that the template function was given an l-value
    reference to an integer. This is because `i`, in our main function, is an l-value,
    even though the function appears to be requesting an r-value reference. To get
    an r-value reference, we must provide an r-value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04ac53de-9f09-4000-afe6-8a9a9d78835b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, now that we have given the universal
    reference an r-value, we get an r-value. It should be noted that a universal reference
    only has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following is not a universal reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither is the following a universal reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of the preceding examples are r-value references, and hence require that
    an r-value be provided (in other words, both of these functions define move operations).
    A universal reference will accept both an l-value and an r-value reference. Although
    this seems like an advantage, it has the downside that it is sometimes difficult
    to know whether your template function has received an l-value or an r-value.
    Currently, the best way to ensure your template function acts like an r-value
    reference and not a universal reference is to use SFINAE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is also possible to perform type deduction on less common types
    such as C-style arrays, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function states that we wish to have a C-style array of type
    `T` and size `N` passed to the function and then outputs its type when executed.
    We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This automatically deduces to an r-value reference of a C-style array of type
    `int` and size `6`. As shown in this recipe, C++ provides several mechanisms for
    allowing the compiler to determine what types are leveraged in template functions.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging template class type deduction in C++17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how class type deduction works with class templates
    in C++17\. This recipe is important as C++17 added the ability to deduce the type
    of a template class from its constructor, which reduces both the verbosity and
    redundancy of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge gained from this recipe will provide you with the ability to write
    C++ classes that properly deduce their types from the class constructor without
    the need for explicit type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class template type deduction is a new feature added in C++17 that provides
    the ability to deduce the type of a template class from its constructor. Suppose
    we have the following class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, we have a simple class template that
    takes a type `T` during construction and uses a `show_type()` function to output
    whatever type it is given. Before C++17, this class would have been instantiated
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'With C++17, we can now instantiate this class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason this works is that the constructor of the class takes a type `T`
    as an argument. Since we provided a numeric integer as the parameter, type `T` of
    the class is deduced as an integer. This type deduction includes support for references
    as well. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, our class takes `T&` as a parameter in the constructor of
    the class, which allows us to instantiate the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b10d531e-b7d8-49ce-b509-30aa6f695860.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding example, type `T` of the class was deduced as an
    l-value reference to an integer. Most of the type deduction rules that apply to
    function templates also apply to class templates, but there are some exceptions.
    For example, class template constructors do not support forwarding references
    (universal references). Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding constructor is not a universal reference; it is an r-value reference,
    meaning we cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not possible as it would be attempting to bind an l-value to an r-value,
    which is not allowed. Instead, like any other r-value reference, we must instantiate
    the class using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can bind it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason universal references are not supported for class template type deduction
    is the fact that class template type deduction uses the constructor to deduce
    the type and then fills in the type for the rest of the class based on whatever
    type was deduced, meaning by the time the constructor is compiled, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This defines an r-value reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a universal reference in the constructor, or any other function, you
    must use a member function template, which itself can still support type deduction
    but is not used to deduce any of the class''s types. Check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create a class template with type `T`, and we
    define the constructor as a member function template. The constructor itself takes `T
    &&t` and `U &&u`. In this case, however, `t` is an r-value reference and `u` is
    a universal reference, even though they look identical. Both can be deduced by
    the compiler with C++17 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'It should also be noted that the constructor does not have to have any of the
    types in any specific order for deduction to work. The only requirement is that
    all of the types are present in the constructor''s arguments. For example, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example can be instantiated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, type deduction also supports more than one template type, as in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example creates a class template with two generic types. The
    constructor for this class creates a `const` l-value reference to a type `T`,
    while also taking an r-value reference to a type `U`. This class can be instantiated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/137fb1ac-46dc-4fe1-b8f4-6d95dcdbdfcf.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, both `T` and `U` are successfully deduced.
  prefs: []
  type: TYPE_NORMAL
- en: Working with user-defined type deduction in C++17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to help the compiler with class template type
    deduction using user-defined deduction guides. Most of the time, user-defined
    deduction guides are not needed, but in some cases, they might be to ensure the
    compiler deduces the proper types. This recipe is important because, without user-defined
    type deduction, certain types of template schemes are simply not possible, as
    will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following command to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class template type deduction is a much-needed feature in C++17 as it helps
    to reduce both the redundancy and verbosity of our C++. There are situations where,
    however, the compiler will deduce the wrong type—an issue that could be addressed
    if we didn''t rely on type deduction. To better understand this type of issue,
    let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created a simple class template whose constructor
    takes a type `T` and uses a `show_type()` function to output whatever type it
    is given. Now suppose that we wish to use this class to instantiate a version
    that takes an unsigned integer. There are two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method is the most obvious as we are explicitly telling the compiler
    what type we wish to have, while not using type deduction at all. Another method
    to get an unsigned integer would be to use the proper numeric literal syntax as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are leveraging type deduction, but we have to make
    sure we always add `U` to our integers. The advantage of this approach is that
    the code is explicit. The disadvantage to this approach is that if we forget to
    add `U` to state that we wish to have an unsigned integer, we could inadvertently
    create a class with the `int` type instead of the `unsigned` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this issue, we can leverage a user-defined type deduction to tell
    the compiler that if it sees an integer type, we really mean an unsigned type,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement tells the compiler that if it sees a constructor with
    an `int` type, `int` should produce a class with the `unsigned` type.
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side takes a constructor signature, while the right-hand side
    takes a class template signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this method, we can take any constructor signature that we see and convert
    it into the class template type we wish, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The user-defined type deduction guide tells the compiler that if it sees a
    C-style string, it should create `std::string` instead. We can then run our example
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33a212a7-2507-4906-af8c-813b8dcb6bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, the class was constructed with `std::string`
    (or at least GCC's internal representation of `std::string`) and not a C-style
    string.
  prefs: []
  type: TYPE_NORMAL
