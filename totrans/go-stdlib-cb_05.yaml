- en: In and Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading standard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing standard output and error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a file by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the file into a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing a different charset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeking a position within a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to multiple writers at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piping between writer and reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects to binary format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing ZIP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a large XML file effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from an incomplete JSON array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will go through typical I/O operations and related tasks, as well
    as the writing and reading of various input sources. We will go through XML processing,
    unzipping compressed files, and using the random access file.
  prefs: []
  type: TYPE_NORMAL
- en: Check if Go is properly installed. The *Getting ready* section from *Retrieving
    the Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    with the Environment,* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Reading standard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every process owns its standard input, output, and error file descriptor. The
    `stdin` serves as the input of the process. This recipe describes how to read
    the data from the `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `fmt.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run fmt.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the input `John` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the input `40` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/532e051a-c31e-40f6-b1ca-34985ad0bad5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the file `scanner.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run scanner.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the input `Hello` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *CTRL* + *C* to send `SIGINT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae3dadf0-5209-47e0-9fcb-8cbfb0c0d3e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the file `reader.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with the piped input `echo 'Go is awesome!' | go run reader.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0742d0f6-4be5-4905-93f4-f03a22399cb2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `stdin` of the Go process could be retrieved via the `Stdin` of the `os` package.
    In fact, it is a `File` type which implements the `Reader` interface. Reading
    from the `Reader` is then very easy. The preceding code shows three very common
    ways of how to read from the `Stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: The first option illustrates the use of the `fmt` package, which provides the
    functions `Scan`, `Scanf`, and `Scanln`. The `Scanf` function reads the input
    into given variable(s). The advantage of `Scanf` is that you can determine the
    format of the scanned value. The `Scan` function just reads the input into a variable
    (without predefined formatting) and `Scanln,` as its name suggests, reads the
    input ended with the line break.
  prefs: []
  type: TYPE_NORMAL
- en: The `Scanner`, which is the second option shown in the sample code, provides
    a convenient way of scanning larger input. The `Scanner` contains the function
    `Split` by which the custom split function could be defined. For example, to scan
    the words from `stdin`, you can use `bufio.ScanWords` predefined `SplitFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: The reading via the `Reader` API is the last presented approach. This one provides
    you with more control of  how the input is read.
  prefs: []
  type: TYPE_NORMAL
- en: Writing standard output and error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the previous recipe describes, each process has `stdin`, a `stdout` and `stderr` file
    descriptors. The standard approach is the use of `stdout` as a process output
    and `stderr` as process error output. As these are the file descriptors, the destination
    where the data is written could be anything, from the console to the socket. This
    recipe will show you how to write the `stdout` and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `stdouterr.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run stdouterr.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af239952-6510-453a-991a-45c10e728bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the `Stdin` from the previous recipe, the `Stdout` and `Stderr` are
    the file descriptors. So these are implementing the `Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example shows a few ways of how to write into these via the `io.WriteString`
    function, with the use of the `Writer` API and by the `fmt` package and `FprintXX`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a file by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File access is a very common operation used to store or read the data. This
    recipe illustrates how to open a file by its name and path, using the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the directory `temp` and create the file `file.txt` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `file.txt` file and write `This file content` into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `openfile.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The file structure should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c224f1d-45a2-4bbd-9301-f8bffef58e2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Execute the code with `go run openfile.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output there should also be a new file, `test.txt`, in the `temp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1a5de54-acc5-4330-bb9b-a6716fff71f3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os` package offers a simple way of opening the file. The function `Open`
    opens the file by the path, just in read-only mode. Another function, `OpenFile,`
    is the more powerful one and consumes the path to the file, flags, and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The flag constants are defined in the `os` package and you can combine them
    with use of the binary OR operator `|`.  The permissions are set by the `os` package
    constants (for example, `os.ModePerm` ) or by the number notation such as `0777` (permissions: `-rwxrwxrwx`).
  prefs: []
  type: TYPE_NORMAL
- en: Reading the file into a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw the reading from `Stdin` and the opening of
    the file. In this recipe, we will combine these two a little bit and show how
    to read the file into a string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the directory `temp` and create the file `file.txt` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `file.txt` file and write multiple lines into the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `readfile.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run readfile.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17491f12-c0cc-4f82-9557-3a857bddb2d7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reading from the file is simple because the `File` type implements both
    the `Reader` and `Writer` interfaces. This way, all functions and approaches applicable
    to the `Reader` interface are applicable to the `File` type. The preceding example
    shows how to read the file with the use of `Scanner` and write the content to
    the bytes buffer (which is more performant than string concatenation). This way,
    you are able to control the volume of content read from a file.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach with `ioutil.ReadFile` is simpler but should be used carefully,
    because it reads the whole file. Keep in mind that the file could be huge and
    it could threaten the stability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Reading/writing a different charset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not an exception that the input from various sources could come in various
    charsets. Note that a lot of systems use the Windows operating system but there
    are others. Go, by default, expects that the strings used in the program are UTF-8
    based. If they are not, then decoding from the given charset must be done to be
    able to work with the string. This recipe will show the reading and writing of
    the file in a charset other than UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `charset.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run charset.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83161d00-7702-4063-ac5c-b3f274b805b6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `golang.org/x/text/encoding/charmap` package contains the `Charmap` type
    pointer constants that represent the widely used charsets. The `Charmap` type
    provides the methods for creating the encoder and decoder for the given charset.
    The `Encoder` creates the encoding `Writer` which encodes the written bytes into
    the chosen charset. Similarly, the `Decoder` can create the decoding `Reader`,
    which decodes all read data from the chosen charset.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](f6e11b1c-c7b2-49db-9f21-b6f741edf021.xhtml), *String and Things,* also
    contains the recipe *Decoding a string from the non-Unicode charset* for encoding/decoding
    a string into another charset.'
  prefs: []
  type: TYPE_NORMAL
- en: Seeking a position within a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you need to read from or write to a particular location in a
    file, such as an indexed file. The recipe will show you how to use the position
    seeking in the context of flat file operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `flatfile.txt` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `fileseek.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code with `go run fileseek.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6601b762-377d-4627-822d-055bcecc676e.png)'
  prefs: []
  type: TYPE_IMG
- en: Display the file in hex `xxd flatfile.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcd5da38-fab2-4e69-9631-050403bc2387.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example uses the `flatfile` as an illustration of how to seek,
    read and write at the position in the file. In general, for moving the position
    of the current pointer in the `File`, the `Seek` method can be used. It takes
    two arguments and these are, position and how to count the position, `0 - relative
    to file origin, 1 - relative to current position, 2 - relative to the end of file`.
    This way you are able to move the cursor within the file. The `Seek` method is
    used in the implementation of the `readLine` function in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flatfile` is the most basic form of how to store the data. The record
    structure has a fixed length and the same for the record parts. The structure
    of the flat file in the example is: `ID` - 4 chars, `FirstName` - 10 chars, `LastName`
    - 10 chars. The whole record is 24 chars long, ended by a line break which is
    the 25^(th) character.'
  prefs: []
  type: TYPE_NORMAL
- en: The `os.File` also contains the `ReadAt` and `WriteAt` methods. These methods
    consume that the bytes to be written/read and the offset where to start. These
    simplify the writing and reading to a certain position in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the example assumes that each rune is only one byte, which does not
    have to be true for special characters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to write and read any type in the binary form.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `rwbinary.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run rwbinary.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b458f916-abcd-4d50-9727-088ac0d7f720.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary data could be written with the use of the `encoding/binary` package.
    The function `Write` consumes the `Writer` where the data should be written, the
    byte order (`BigEndian`/`LittleEndian`) and finally, the value to be written into
    `Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: To read the binary data analogically, the `Read` function could be used. Note
    that there is no magic in reading the data from the binary source. You need to
    be sure what data you are fetching from the `Reader`. If not, the data could be
    fetched into any type which fits the size.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to multiple writers at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to write the same output into more than one target, there is a
    helping hand available in the built-in package. This recipe shows how to implement
    writing simultaneously into multiple targets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `multiwr.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run multiwr.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7b4294a-1497-4682-93c1-9cdef3d746ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the content of the created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io` package contains the `MultiWriter` function with variadic parameters
    of  `Writers`.  When the `Write` method on the `Writer` is called, then the data
    is written to all underlying `Writers`.
  prefs: []
  type: TYPE_NORMAL
- en: Piping between writer and reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pipes between processes are the easy way to use the output of the first
    process as the input of other processes. The same concept could be done in Go,
    for example, to pipe data from one socket to another socket, to create the tunneled
    connection. This recipe will show you how to create the pipe with use of the Go
    built-in library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `pipe.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run pipe.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fbd9339-5bc4-4ade-988e-637e7f30cc9c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io.Pipe` function creates the in-memory pipe and returns both ends of the
    pipe, the `PipeReader` on one side and `PipeWriter` on the other side. Each `Write`
    to `PipeWriter` is blocked until it is consumed by `Read` on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows the piping output from the executed command to the standard
    output of the parent program. By assigning the `pWriter` to `cmd.Stdout`, the
    standard output of the child process is written to the pipe, and the `io.Copy`
    in `goroutine` consumes the written data, by copying the data to `os.Stdout.`
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects to binary format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the well-known JSON and XML, Go also offers the binary format, `gob`.
    This recipe goes through the basic concept of how to use the `gob` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `gob.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run gob.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e247b11-1775-4a73-a368-b5c28527e458.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gob` serialization and deserialization need the Encoder and Decoder. The
    `gob.NewEncoder` function creates the `Encoder` with the underlying `Writer`.
    Each call of the `Encode` method will serialize the object into a `gob` format.
    The gob format itself is the self-describing binary format. This means each serialized
    struct is preceded by its description.
  prefs: []
  type: TYPE_NORMAL
- en: To decode the data from the serialized form, the `Decoder` must be created by
    calling the `gob.NewDecoder` with the underlying `Reader`. The `Decode` then accepts
    the pointer to the structure where the data should be deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the gob format does not need the source and destination type to match
    exactly. For the rules, refer to the `encoding`/`gob` package.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing ZIP files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ZIP compression is a widely used compression format. It is usual to use the
    ZIP format for an application to upload a file set or, on the other hand, export
    zipped files as output. This recipe will show you how to handle ZIP files programmatically
    with the use of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `zip.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run zip.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04dd5561-7394-45e2-a537-63d42ea2003a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in package `zip` contains the `NewWriter` and `NewReader` functions
    to create the `zip.Writer` to compress, and the `zip.Reader` to decompress the
    zipped content.
  prefs: []
  type: TYPE_NORMAL
- en: Each record of the ZIP file is created with the `Create` method of the created
    `zip.Writer` . The returned `Writer` is then used to write the content body.
  prefs: []
  type: TYPE_NORMAL
- en: To decompress the files, the `OpenReader` function is used to create the `ReadCloser` of
    the records in the zipped file. The `File` field of the created `ReaderCloser`
    is the slice of `zip.File` pointers. The content of the file is obtained by calling
    the `Open` method and by reading the returned `ReadCloser`.
  prefs: []
  type: TYPE_NORMAL
- en: The folders could be created by only adding slashes to the name of the file
    in the `Create` method. An example could be  `folder/newfile.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a large XML file effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML is a very common format for data exchange. The Go library contains support
    for parsing XML files the same way as the JSON. Usually, the struct which corresponds
    to the XML scheme is used and with this help, the XML content is parsed at once.
    The problem is when the XML file is too large to fit into memory and so you need
    to parse the file in chunks. This recipe will reveal how to handle a large XML
    file and parse the required information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `data.xml` file with the following XML content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `xml.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run xml.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9dec79ca-2012-491d-ba36-30ef711dad80.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `NewDecoder` function of the `xml` package, the `Decoder` for the XML
    content is created.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the `Token` method on the `Decoder,` the `xml.Token` is received.
    The `xml.Token` is the interface which holds the token type. The behavior of the
    code can be defined, based on the type. The sample code tests if the parsed `xml.StartElement`
    is one of the `book` elements. Then it partially parses the data into a `Book`
    structure. This way, the position of the pointer in the underlying `Reader` in
    the `Decoder` is shifted by the struct data, and the parsing can continue.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from an incomplete JSON array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe contains a very specific use case, where your program consumes the
    JSON from an unreliable source and the JSON contains an array of objects which
    has the beginning token `[` but the number of items in the array is very large,
    and the end of the JSON could be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter05/recipe13`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `json.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run json.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00a98c28-2459-4493-b61a-5b8799235dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the `Unmarshall` function, the `json` package also contains the `Decoder`
    API. With `NewDecoder`, the `Decoder` could be created. By calling the `Token`
    method on the decoder, the underlying `Reader` is read and returns the `Token`
    interface. This could hold multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: One of these is the `Delim` type, which is a rune containing one of the `{`,
    `[`, `]`, `}` characters. Based on this, the beginning of the JSON array is detected.
    With the `More` method on the decoder, more objects to decode could be detected.
  prefs: []
  type: TYPE_NORMAL
