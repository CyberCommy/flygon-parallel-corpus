- en: Working with New Date and Time APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: How to construct time zone-independent date and time instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to construct time zone-dependent time instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a date-based period between date instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a time-based period between time instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to represent epoch time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate date and time instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compare date and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with different calendar systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to format dates using `DateTimeFormatter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with `java.util.Date` and `java.util.Calendar` was a pain for Java
    developers until Stephen Colebourne ([http://www.joda.org/](http://www.joda.org/))
    introduced Joda-Time ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/)),
    a library for working with date and time in Java. Joda-Time provided the following
    advantages over the JDK API:'
  prefs: []
  type: TYPE_NORMAL
- en: Richer API for getting date components, such as the day of a month, the day
    of a week, the month, and the year, and time components, such as the hour, minutes,
    and seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of manipulation and comparison of dates and time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both time zone-independent and time zone-dependent APIs are available. Most
    of the time, we will be using time zone-independent APIs, which makes it easier
    to use the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazing APIs to compute duration between dates and times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date formatting and duration computation follow ISO standards by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports multiple calendars such as Gregorian, Buddhist, and Islamic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joda-Time inspired JSR-310 ([https://jcp.org/en/jsr/detail?id=310](https://jcp.org/en/jsr/detail?id=310)),
    which ported the API to JDK under the `java.time` package and was released as
    part of Java 8\. As the new Date/Time API is based on ISO standards, it makes
    it dead simple to integrate date/time libraries across different layers of your
    application. For example, at the JavaScript layer, we can use moment.js ([https://momentjs.com/docs/](https://momentjs.com/docs/))
    to work with date and time and use its default formatting style (which is ISO-compliant)
    to send data to the server. At the server layer, we can use the new Date/Time
    API to obtain date and time instances as required. So we are interacting between
    the client and server using standard date representations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at different ways we can leverage the new Date/Time
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with time zone-independent date and time instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to JSR-310, it was not straightforward to create date and time instances
    for any point in time or any day in a calendar. The only way was to use the `java.util.Calendar`
    object to set the required dates and time, and then invoke the `getTime()` method
    to get an instance of `java.util.Date`. And those date and time instances contained
    time zone information as well, which sometimes led to bugs in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In new APIs, it's far simpler to get date and time instances, and these date
    and time instances do not have any time zone information associated with them.
    In this recipe, we will show you how to work with date-only instances represented
    by `java.time.LocalDate`, time-only instances represented by `java.time.LocalTime`,
    and date/time instances represented by `java.time.LocalDateTime`. These date and
    time instances are time zone-independent and represent the information in the
    current time zone of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have at least JDK 8 installed to be able to use these newer libraries,
    and the samples in this chapter use the syntax that is supported on Java 10 and
    onward. If you want, you can run these code snippets directly in JShell. You can
    visit [Chapter 12](3eb4f1fb-a9ad-422c-b8fb-0fad844f29af.xhtml), *The Read-Evaluate-Print
    Loop (REPL) Using JShell,* to learn more about JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current date wrapped in `java.time.LocalDate` can be obtained using the
    `now()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get individual fields of the `java.time.LocalDate` instance using the
    generic `get(fieldName)` method or specific methods such as `getDayOfMonth()`,
    `getDayOfYear()`, `getDayOfWeek()`, `getMonth()`, and `getYear()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get an instance of `java.time.LocalDate` for any date in the calendar
    using the `of()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is the `java.time.LocalTime` class, which is used to represent any time
    instance irrespective of the date. The current time can be obtained using the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `java.time.LocalTime` class also comes with the `of()` factory method, which
    can be used to create an instance representing any time. Similarly, there are
    methods to get different components of the time, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`java.time.LocalDateTime` is used to represent an entity containing both time
    and date. It is made up of `java.time.LocalDate` and `java.time.LocalTime` to
    represent date and time respectively. Its instance can be created using `now()`
    and different flavors of the `of()`  factory method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following three classes in the `java.time` package represent date and time
    values in the default time zone (the system''s time zone):'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.LocalDate`: Contains only date information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalTime`: Contains only time information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalDateTime`: Contains both date and time information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the classes is made up of fields, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All classes contain the `now()` method, which returns the current date and time
    values. There are `of()` factory methods provided to build the date and time instances
    from their fields, such as day, month, year, hour, and minute. `java.time.LocalDateTime`
    is made up of `java.time.LocalDate` and `java.time.LocalTime`, so one can build
    `java.time.LocalDateTime` from `java.time.LocalDate` and `java.time.LocalTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important APIs learned from this recipe are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`now()`: This gives the current date and time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of()`: This factory method is used to construct the required date, time and
    date/time instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java 9, there's a new API, `datesUntil`, which takes the end date and returns
    a stream of sequential dates (in other words, `java.time.LocalDate`) from the
    date of the current object until the end date (but excluding it). Using this API
    groups all the dates for the given month and year into their respective days of
    the week, namely, Monday, Tuesday, Wednesday, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s accept the month and year and store it in the `month` and `year` variables respectively.
    The start of the range will be the first day of the month and year, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The end date of the range will be the number of days in the month, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are making use of the `lengthOfMonth` method to fetch the number of days
    in the month. We then use the `datesUntil` method to get a stream of `java.time.LocalDate`
    and then we perform some stream operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping `java.time.LocalDate` instances by day of the week.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the grouped instances into `java.util.ArrayList`. But before that,
    we are applying a transformation to convert the `java.time.LocalDate` instances
    into a simple day of the month, which gives us a list of integers representing
    the day of the month.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding two operations in the code are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code for this can be found at `Chapter13/1_2_print_calendar` of the downloaded
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to construct time zone-dependent time instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *How to construct time zone-independent date and time
    instances,* we constructed date and time objects that didn't contain any time
    zone information. They implicitly represented the values in the system's time
    zone; these classes were `java.time.LocalDate`, `java.time.LocalTime`, and `java.time.LocalDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Often we would need to represent the time with respect to some time zone; in
    such scenarios we will make use of `java.time.ZonedDateTime`, which contains time
    zone information along with `java.time.LocalDateTime`. The time zone information
    is embedded using `java.time.ZoneId` or `java.time.ZoneOffset` instances. There
    are two other  classes, `java.time.OffsetTime` and `java.time.OffsetDateTime`,
    which are also time zone-specific variants for `java.time.LocalTime` and `java.time.LocalDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to make use of `java.time.ZonedDateTime`,
    `java.time.ZoneId`, `java.time.ZoneOffset`, `java.time.OffsetTime`, and `java.time.OffsetDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make use of Java 10 syntax that uses `var` for local variable declarations
    and modules. Apart from Java 10 and higher, there is no other prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make use of the `now()` factory method to get the current date, time,
    and time zone information based on the system''s time zone, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make use of `java.time.ZoneId` to get the current date and time information
    based on any given time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`java.time.ZoneOffset` can also be used to provide time zone information for
    the date and time, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We make use of the `of()` factory method to build an instance of `java.time.ZonedDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even extract `java.time.LocalDateTime` from`java.time.ZonedDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's look at how the time zone information is captured. It's captured
    based on the number of hours and minutes from **Greenwich Mean Time (GMT)**, also
    known as Coordinated Universal Time (UTC). For example, Indian Standard Time (IST),
    also known as Asia/Kolkata, is 5:30 hours ahead of GMT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides `java.time.ZoneId` and `java.time.ZoneOffset` to represent time
    zone information. `java.time.ZoneId` captures time zone information based on the
    time zone name, such as Asia/Kolkata, US/Pacific, and US/Mountain. There are around
    599 zone IDs. This has been computed using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will print 10 of the zone IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Time zone names, such as Asia/Kolkata, Africa/Nairobi, and America/Cuiaba, are
    based on the time zone database released by International Assigned Numbers Authority
    (IANA). The time zone region names provided by IANA are the default for Java.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes time zone region names are also represented as GMT+02:30 or simply
    +02:30, which indicates the offset (ahead or behind) of the current time zone
    from the GMT zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `java.time.ZoneId` captures `java.time.zone.ZoneRules`, which contains
    rules for obtaining the time zone offset transitions and other information, such
    as the daylight savings time. Let''s investigate the zone rules for US/Pacific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `getDaylightSavings()` method returns a `java.time.Duration` object, which
    represents some duration in terms of hours, minutes, and seconds. The default
    `toString()` implementation returns the duration represented using ISO 8601 seconds-based
    representation where a duration of 1 hour, 20 minutes, and 20 seconds is represented
    as `PT1H20M20S`. More about this will be covered in the *How to create a time-based
    period between time instances* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going into the details of how it's been calculated. For those interested
    to know more about `java.time.zone.ZoneRules` and `java.time.ZoneId`, visit the
    documentation at [https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html ](https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html)and
    [https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html](https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.time.ZoneOffset` class captures the time zone information in terms
    of the number of hours and minutes the time zone is ahead of or behind GMT. Let''s
    create an instance of the `java.time.ZoneOffset` class using the `of*()` factory
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `java.time.ZoneOffset` class extends from `java.time.ZoneId` and adds a
    few new methods. The important thing to remember is to construct the right instance
    of `java.time.ZoneOffset` and `java.time.ZoneId` based on the required time zone
    to be used in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of time zone representation, `java.time.ZonedDateTime`
    is nothing but `java.time.LocalDateTime` along with `java.time.ZoneId` or `java.time.ZoneOffset`.
    There are two other classes, `java.time.OffsetTime` and `java.time.OffsetDateTime`,
    which wraps `java.time.LocalTime` and `java.time.LocalDateTime` respectively,
    along with `java.time.ZoneOffset`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some ways to construct instances of `java.time.ZonedDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is using `now()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first usage of `now()` uses the system's clock, as well as the system time
    zone to print the current date and time. The second usage of `now()` uses the
    system's clock, but the time zone is provided by `java.time.ZoneId`, which in
    this case is Asia/Kolkata. The third usage of `now()` uses the fixed clock provided
    and the time zone provided by `java.time.ZoneId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixed clock is created using the `java.time.Clock` class and its static
    method, `fixed()`, which takes an instance of `java.time.Instant` and `java.time.ZoneId`.
    The instance of `java.time.Instant` has been built using some static number of
    seconds after epoch. `java.time.Clock` is used to represent a clock which can
    be used by the new Date/Time API to determine the current time. The clock can
    be fixed, as we have seen earlier, then we can create a clock which is one hour
    ahead of the current system time in the Asia/Kolkata time zone, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this new clock to build instances of `java.time.LocalDateTime` and
    `java.time.ZonedDateTime`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both date and time values are based on the same time zone, that is, `Asia/Kolkata`,
    but as we have already learned, `java.time.LocalDateTime` doesn't have any time
    zone information and it bases the values on the time zone of the system or the
    `java.time.Clock` provided in this case. On the other hand, `java.time.ZonedDateTime`
    contains and displays the time zone information as `[Asia/Kolkata]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other approach for creating an instance of `java.time.ZonedDateTime` is
    using its `of() ` factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned the `java.time.OffsetTime` and `java.time.OffsetDateTime` classes.
    Both contain time zone-specific time values. Let''s play around with those classes
    before we wrap up this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `of()` factory method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `now()` factory method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting the way we built a `java.time.Clock` instance, which is 330
    minutes (5 hours and 30 minutes) ahead of the UTC clock. The other class, `java.time.OffsetDateTime`,
    is the same as `java.time.OffsetTime`, except that it uses `java.time.LocalDateTime`.
    So you will be passing the date information, namely, year, month, and day, along
    with the time information to its factory method, `of()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a date-based period between date instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times in the past when we tried to measure the period between two
    date instances but, due to the lack of an API prior to Java 8 and also lack of
    proper support to capture this information, we resorted to different means. We
    remember using SQL-based approaches to process such information. But from Java
    8 and onward, we have a new class, `java.time.Period`, which can be used to capture
    a period between two date instances in terms of the number of years, months, and
    days.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this class supports parsing ISO 8601 standard-based strings for representing
    the period. The standard states that any period can be represented in the form
    of `PnYnMnD`, where **P** is a fixed character to represent the period, **nY**
    stands for the number of years, **nM** for the number of months, and **nD** for
    the number of days. For example, a period of 2 years, 4 months, and 10 days is
    represented as `P2Y4M10D`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need at least JDK8 to play around with `java.time.Period`, JDK 9 to be able
    to make use of JShell, and at least JDK 10 to make use of the examples used in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an instance of `java.time.Period` using its `of()` factory method, which
    has the signature `Period.of(int years, int months, int days)` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are specific variants of the `of*()` method, namely, `ofDays()`, `ofMonths()`,
    and `ofYears()`, which can be used as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ofWeeks()` method is a helper method to build `java.time.Period`
    based on days by accepting the number of weeks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The period can also be constructed using the period string, which is generally
    of the form `P<x>Y<y>M<z>D` where `x`, `y`, and `z` represent the number of years,
    months, and days respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compute the period between two instances of `java.time.ChronoLocalDate`
    (one of its implementations is `java.time.LocalDate`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These are the most useful ways to create an instance of `java.time.Period`.
    The start date is inclusive and the end date is exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We make use of the factory methods in `java.time.Period` to create its instance.
    The `java.time.Period` has three fields to hold the values for year, month, and
    day respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an interesting set of methods, namely, `withDays()`, `withMonths()`,
    and `withYears()`. These methods return the same instance if the field that it''s
    trying to update has the same value; otherwise, it returns a new instance with
    updated values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can even compute `java.time.Period` between the two date instances using
    the `until()` method present in `java.time.ChronoLocalDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Given an instance of `java.time.Period`, we can use it to manipulate a given
    date instance. There are two possible ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `addTo` or `subtractFrom` method of the period object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `plus` or `minus` method of the date object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of the approaches are shown in the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On similar lines, you can try out the `subtractFrom` and `minus` methods. There
    is another set of methods used to manipulate the `java.time.Period` instance,
    namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minus`, `minusDays`, `minusMonths`, and `minusYears`: Subtract the given value
    from the period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plus`, `plusDays`, `plusMonths`, and `plusYears`: Add the given value to the
    period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`negated`: Returns the new period with each of its values negated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normalized`: Returns a new period by normalizing its higher-order fields,
    such as months and days. For example, 15 months is normalized to 1 year and 3
    months.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will show you these methods in action as follows, starting with the `minus`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will see the `plus` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here are the `negated()` and `normalized()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Observe that, in both of the earlier cases, it is not mutating the existing
    period, instead of returning a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a time-based period between time instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we created a date-based period, which is represented
    by `java.time.Period`. In this recipe, we will look at creating a time-based difference
    between time instances in terms of seconds and nanoseconds using the `java.time.Duration`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at different ways to create an instance of `java.time.Duration`,
    manipulate the duration instance, and obtain the duration in terms of different
    units, such as hours and minutes. The ISO 8601 standard specifies one of the possible
    patterns for representing duration to be `PnYnMnDTnHnMnS`, where the following
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Y`, `M`, and `D` represent the date component fields, namely, year, month,
    and day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` separates the date with the time information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`, `M`, and `S` represent the time component fields, namely, hour, minutes,
    and seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string representation implementation of `java.time.Duration` is loosely
    based on the ISO 8601\. There is more on this in the *How it works* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need at least JDK 8 to play around with `java.time.Duration` and JDK 9 to
    be able to make use of JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`java.time.Duration` instances can be created using the `of*()` factory methods.
    We will show using a few of them, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be created by parsing the duration string, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'They can be constructed by finding the span between two `java.time.Temporal`
    instances, which support time information (that is, instances of `java.time.LocalDateTime`
    and the likes), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data required for `java.time.Duration` is stored in two fields representing
    seconds and nanoseconds respectively. There are convenience methods provided to
    get the duration in terms of minutes, hours, and days, namely, `toMinutes()`,
    `toHours()`, and `toDays()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the string representation implementation. `java.time.Duration`
    supports parsing the ISO string representation containing only the day component
    in the date part and hours, minutes, seconds, and nanoseconds in the time part.
    For example, `P2DT3M` is acceptable, whereas parsing `P3M2DT3M` results in `java.time.format.DateTimeParseException`
    because the string contains the month component in the date part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toString()` method of `java.time.Duration` always returns a string of
    the `PTxHyMz.nS` form, where `x` represents the number of hours, `y` represents
    the number of minutes, and `z.n` represents the number of seconds to nanosecond
    precision. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the manipulation methods provided, which allow adding/subtracting
    a value from the specific unit of time, such as days, hours, minutes, seconds,
    or nanoseconds. Each of these methods is immutable, so a new instance is returned
    each time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can try out the `minus*()` methods, which does the subtraction.
    Then there are methods that manipulate the instances of  `java.time.LocalDateTime`,
    `java.time.ZonedDateTime`, and their like. These methods add/subtract the duration
    to/from the date/time information. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can observe in the preceding example that we got an exception when we tried
    to add the duration to the entity containing only date information.
  prefs: []
  type: TYPE_NORMAL
- en: How to represent epoch time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at using `java.time.Instant` to represent a point
    in time, as well as convert that point in time to epoch seconds/milliseconds.
    The Java epoch is used to refer to the time instant 1970-01-01 to 0:00:00Z and
    `java.time.Instant` stores the number of seconds from the Java epoch. A positive
    value indicates the time is ahead of the epoch and negative indicates the time
    is behind the epoch. It uses the system clock in UTC to compute the current time
    instant value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have JDK supporting new Date/Time APIs and JShell installed to be
    able to try out the solution provided.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will just create an instance of `java.time.Instant` and print out the epoch
    seconds, which will give the time in UTC after the Java epoch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also print out the epoch milliseconds, which shows the number of milliseconds
    after the epoch. This is a bit more precise than just seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.time.Instant` class stores the time information in its two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Seconds, which is of the `long` type: This stores the number of seconds from
    the epoch of 1970-01-01T00:00:00Z.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nanos, which is of the `int `type: This stores the number of nanoseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you invoke the `now()` method,  `java.time.Instant` uses the system clock
    in UTC to represent that time instant. And then we can use `atZone()` or `atOffset()`
    to convert it into the required time zone, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Use this class if you want to just represent the timeline of actions in UTC;
    that way, the timestamp stored for different events will be based on UTC and you
    can then convert it into your required time zone as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can manipulate the `java.time.Instant` by adding/subtracting nanoseconds,
    milliseconds, and seconds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can try out the `minus*()` methods. We can also obtain the time
    zone-dependent date time using the `java.time.Instant` methods, `atOffset()` and
    `atZone()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How to manipulate date and time instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The date and time classes, `java.time.LocalDate`, `java.time.LocalTime`, `java.time.LocalDateTime`,
    and `java.time.ZonedDateTime`, provide methods to add and subtract values from
    their components, namely, days, hours, minutes, seconds, weeks, months, years,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at a few such methods, which can be used to manipulate
    date and time instances by adding and subtracting different values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a JDK installation that supports the new Date/Time APIs and the
    JShell console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s manipulate`java.time.LocalDate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s manipulate the date and time instance, `java.time.LocalDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s manipulate the time zone-dependent date and time, `java.time.ZonedDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just looked at a few of the add and subtract APIs represented by `plus*()`
    and `minus*()`. There are different methods provided to manipulate different components
    of date and time, such as years, days, months, hours, minutes, seconds, and nanoseconds.
    You can try those APIs as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: How to compare date and time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we would want to compare date and time instances with others to check
    if they are before, after, or the same as that of the other. To achieve this,
    JDK provides `isBefore()`, `isAfter()`, and `isEqual()` methods in the `java.time.LocalDate`,
    `java.time.LocalDateTime`, and `java.time.ZonedDateTime` classes. In this recipe,
    we will look at using these methods to compare date and time instances.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a JDK installation that has the new Date/Time APIs and supports
    JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try out comparing two `java.time.LocalDate` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compare the time zone-dependent date and time instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comparison can be performed on `java.time.LocalTime` and `java.time.LocalDateTime`.
    This is left to the reader to explore.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with different calendar systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in our recipes, we worked with the ISO calendar system, which is the
    de facto calendar system followed in the world. There are other regional calendar
    systems followed in the world, such as Hijrah, Japanese, and Thai. JDK provides
    support for such calendar systems as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at working with two calendar systems: Japanese
    and the Hijri.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a JDK installed that supports the new Date/Time APIs and the
    JShell tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s print the current date in the different calendar systems supported by
    JDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s play around with the date represented in the Japanese calendar system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Different eras supported in the Japanese calendar can be enumerated using `java.time.chrono.JapeneseEra`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a date in the Hijrah calendar system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even convert the ISO date/time into date/time in the Hijrah calendar
    system as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The calendar system is represented by `java.time.chrono.Chronology` and its
    implementations, a few of which are `java.time.chrono.IsoChronology`, `java.time.chrono.HijrahChronology`,
    and `java.time.chrono.JapaneseChronology`. `java.time.chrono.IsoChronology` is
    the ISO-based de facto calendar system used in the world. The date in each of
    these calendar systems is represented by `java.time.chrono.ChronoLocalDate` and
    its implementations, some of which are `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`,
    and the well-known `java.time.LocalDate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use these APIs in JShell, you need to import the relevant packages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is applicable to all the recipes that use JShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly play with the implementations of `java.time.chrono.ChronoLocalDate`,
    such as `java.time.chrono.JapaneseDate`, or use the implementation of `java.time.chrono.Chronology`
    to obtain relevant date representations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippets, we can see that one can convert the ISO system
    date into dates in the required calendar system by using their calendar system's
    `date(TemporalAccessor temporal)` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can play around with the other calendar systems supported in JDK, namely,
    Thai, Buddhist, and Minguo (Chinese) calendar systems. It's also worth exploring
    to create our custom calendar systems by writing an implementation of `java.time.chrono.Chronology`,
    `java.time.chrono.ChronoLocalDate`, and `java.time.chrono.Era`.
  prefs: []
  type: TYPE_NORMAL
- en: How to format dates using the DateTimeFormatter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with `java.util.Date`, we made use of `java.text.SimpleDateFormat`
    to format the date into different text representations and vice versa. Formatting
    a date means, given a date or a time object representing it in different formats,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 23 Jun 2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23-08-2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2018-08-23'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23 Jun 2018 11:03:33 AM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These formats are controlled by format strings, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dd MMM yyyy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dd-MM-yyyy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yyyy-MM-DD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dd MMM yyyy hh:mm:ss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will look at `java.time.format.DateTimeFormatter` to format
    the date and time instances in the new date and time API and also look at the
    most commonly used pattern letters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a JDK that has the new Date/Time APIs as well as the `jshell`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the built-in formats to format the date and time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a custom date/time format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the custom `java.time.format.DateTimeFormatter` for formatting the
    current date/time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand the most commonly used format letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Meaning** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | day of the month | 1,2,3,5 |'
  prefs: []
  type: TYPE_TB
- en: '| `M`, `MMM`, `MMMM` | month of the year | `M`: 1,2,3,`MMM`: Jun, Jul, Aug`MMMM`:
    July, August |'
  prefs: []
  type: TYPE_TB
- en: '| `y`, `yy` | year | `y`, `yyyy`: 2017, 2018`yy`: 18, 19 |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | hour of the day (1-12) | 1, 2, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | hour of the day (0-23) | 0, 1, 2, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | minutes | 1, 2, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | seconds | 1, 2, 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | AM/PM of the day | AM, PM |'
  prefs: []
  type: TYPE_TB
- en: '| `VV` | Time zone ID | Asia/Kolkata |'
  prefs: []
  type: TYPE_TB
- en: '| `ZZ` | Time zone name | IST, PST, AST |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | Time zone offset | GMT+5:30, GMT+3 |'
  prefs: []
  type: TYPE_TB
- en: 'Based on the preceding format letters, let''s format `java.time.ZonedDateTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`java.time.format.DateTimeFormatter` comes shipped with plenty of default formatting
    based on the ISO standards. These formats should be more than enough when you
    are dealing with the date manipulation without any user being involved, that is,
    when the date and time is being exchanged between different layers of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But for presenting the date and time information to an end user, we would need
    to format it in a readable format and, for that, we would need a custom `DateTimeFormatter`.
    If you need a custom `java.time.format.DateTimeFormatter`, here are two ways of
    creating one:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a pattern, such as dd MMMM yyyy and the `ofPattern()` method in `java.time.format.DateTimeFormatter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `java.time.DateTimeFormatterBuilder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Pattern**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an instance of `java.time.format.DateTimeFormatter`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we apply the format to a date and time instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The pattern approach also uses `DateTimeFormatterBuilder` wherein the builder
    parses the given format string to build a `DateTimeFormatter` object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using `java.time.format.DateTimeFormatterBuilder`:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build `DateTimeFormatter` using `DateTimeFormatterBuilder`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can observe that a `DateTimeFormatter` object consists of a set of instructions
    on how to represent the date and time. These instructions are presented in form
    of `Value()`, `Text()`, and delimiters.
  prefs: []
  type: TYPE_NORMAL
