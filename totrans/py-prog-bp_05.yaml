- en: Building a Web Messenger with Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's application development world, Microservices have become the standard
    in designing and architecting distributed systems. Companies like Netflix have
    pioneered this shift and revolutionized the way in which software companies operate,
    from having small autonomous teams to designing systems that scale with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will guide you through the process of creating two microservices
    that will work together to make a messaging web application that uses Redis as
    a datastore. Messages will automatically expire after a configurable amount of
    time, so for the purpose of this chapter, let's call it TempMessenger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Nameko?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Nameko microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nameko Dependency Providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving all messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying messages in the web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages via `POST` requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser polling for messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TempMessenger Goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting, let''s define some goals for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: A user can go to a website and send messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user can see messages that others have sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages automatically expire after a configurable amount of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this, we will be using Nameko - A microservices framework for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any point during this chapter you would like to refer to all of the code
    in this chapter in its entirety, feel free to see it, with tests, at: [http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb).'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to partake in this chapter, your local machine will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker - If you haven't installed Docker already, see the official documentation: [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other requirements will be installed as we progress through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All instructions in this chapter are tailored towards macOS or Debian/Ubuntu
    systems. I have, however,  taken care to only use cross-platform dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, there will be blocks of code. Different types of code
    will have their own prefixes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`: To be executed in your terminal, always within your virtualenv'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>>`: To be executed in your Nameko/Python shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'No prefix: Block of Python code to be used in your editor'
  prefs: []
  type: TYPE_NORMAL
- en: What is Nameko?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nameko is an open-source framework used for building microservices in Python.
    Using Nameko, you can create microservices that communicate with each other using
    **RPC** (**Remote Procedure Calls**) via **AMQP** (**Advanced Message Queueing
    Protocol**).
  prefs: []
  type: TYPE_NORMAL
- en: RPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RPC stands for Remote Procedure Call, and I''ll briefly explain this with a
    short example based on a cinema booking system. Within this cinema booking system,
    there are many microservices, but we will focus on the booking service, which
    is responsible for managing bookings, and the email service, which is responsible
    for sending emails. The booking service and email service both exist on different
    machines and both are unaware of where the other one is. When making a new booking,
    the booking service needs to send an email confirmation to the user, so it makes
    a Remote Procedure Call to the email service, which could look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the preceding code how the booking service makes the call as if it
    were executing code that was local to it? It does not care about the network or
    the protocol and it doesn''t even give details on which email address it needs
    to send it to. For the booking service, email addresses and any other email related
    concepts are irrelevant! This allows the booking service to adhere to the **Single
    Responsibility Principle**, a term introduced by Robert C. Martin in his article
    *Principles of Object Orientated Design* ([http://url.marcuspen.com/bob-ood](http://url.marcuspen.com/bob-ood)),
    which states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Class should have only one reason to change"'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of this quote can also be extended to microservices, and is something
    we should keep in mind when developing them. This will allow us to keep our microservices
    self-contained and cohesive. If the cinema decided to change its email provider,
    then the only service that should need to change is the email service, keeping
    the work required minimal, which in turn reduces the risk of bugs and possible
    downtime.
  prefs: []
  type: TYPE_NORMAL
- en: However, RPCs do have their downsides when compared to other techniques such
    as REST, the main one being that it can be hard to see when a call is remote.
    One could make unnecessary remote calls without realizing it, which can be expensive
    since they go over the network and use external resources. So when using RPCs,
    it's important to make them visibly different.
  prefs: []
  type: TYPE_NORMAL
- en: How Nameko uses AMQP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AMQP stands for Advanced Message Queueing Protocol, which is used by Nameko
    as the transport for our RPCs. When our Nameko services make RPCs to each other,
    the requests are placed on the messaging queue, which are then consumed by the
    destination service. Nameko services use workers to consume and carry out requests;
    when an RPC is made, the target service will spawn a new worker to carry out the
    task. Once it's complete, it dies. Since there can be multiple workers executing
    tasks simultaneously, Nameko can scale up to the amount of workers it has available.
    If all workers are exhausted, then messages will stay on the queue until a free
    worker is available.
  prefs: []
  type: TYPE_NORMAL
- en: You can also scale Nameko horizontally by increasing the amount of instances
    running your service. This is known as clustering, which is also where the name
    *Nameko* originates, since Nameko mushrooms grow in clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Nameko can also respond to requests from other protocols such as HTTP and websockets.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RabbitMQ is used as the message broker for Nameko and allows it to utilize AMQP.
    Before we start, you will need to install it on your machine; to do so, we will
    use Docker, which is available on all major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: For those new to Docker, it allows us to run our code in a standalone, self-contained
    environment called a container. Within a container is everything that is required
    for that code to run independently from anything else. You can also download and
    run pre-built containers, which is how we are going to run RabbitMQ. This saves
    us from installing it on our local machine and minimizes the amount of issues
    that can arise from running RabbitMQ on different platforms such as macOS or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not already have Docker installed, please visit [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
    where there are detailed installation instructions for all platforms. The rest
    of this chapter will assume that you already have Docker installed.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a RabbitMQ container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your terminal, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start a RabbitMQ container with the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: Specifies we want to run the container in daemon mode (background process).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: Allows us to expose ports `5672` and `15672` on the container to our
    local machine. These are needed for Nameko to communicate with RabbitMQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name`: Sets the container name to `rabbitmq`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check that your new RabbitMQ container is running by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing Python requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, I'll be using Python 3.6, which, at the time of writing, is
    the latest stable release of Python. I recommend always using the latest stable
    version of Python, not only for the new features but to also ensure the latest
    security updates are applied to your environment at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyenv is a really simple way to install and switch between different versions
    of Python: [http://url.marcuspen.com/pyenv](http://url.marcuspen.com/pyenv).'
  prefs: []
  type: TYPE_NORMAL
- en: I also strongly recommend using virtualenv to create an isolated environment
    to install our Python requirements. Installing Python requirements without a virtual
    environment can cause unexpected side-effects with other Python applications,
    or worse, your operating system!
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about virtualenv and how to install it visit: [http://url.marcuspen.com/virtualenv](http://url.marcuspen.com/virtualenv)'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when dealing with Python packages, you would create a `requirements.txt`
    file, populate it with your requirements and then install it. I'd like to show
    you a different way that will allow you to easily keep track of Python package
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s install `pip-tools` within your virtualenv:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new folder called `requirements` and create two new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `base.in` file will contain the requirements needed in order for the core
    of our service to run, whereas the `test.in` file will contain the requirements
    needed in order to run our tests. It's important to keep these requirements separate,
    especially when deploying code in a microservice architecture. It's okay for our
    local machines to have test packages installed, but a deployed version of our
    code should be as minimal and lightweight as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `base.in` file, put the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `test.in` file, put the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided you are in the directory containing your `requirements` folder, run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate two files, `base.txt`, and `test.txt`. Here''s a small sample
    of the `base.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we now have a file that contains all of the latest dependencies and
    sub-dependencies of Nameko. It specifies which versions are required and also
    what caused each sub-dependency to be installed. For example, `six` is required
    by `nameko` and `mock`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it extremely easy to troubleshoot upgrade issues in the future by
    being able to easily track version changes between each release of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Nameko is currently version 2.8.3 and Pytest is 3.4.0\.
    Feel free to use newer versions of these packages if available, but if you have
    any issues throughout the book then revert back to these by appending the version
    number in your `base.in` or `test.in` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the requirements, simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pip-sync` command installs all requirements specified in the files while
    also removing any packages that are in your environment that aren''t specified.
    It''s a nice way to keep your virtualenv clean. Alternatively, you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating your first Nameko microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder titled `temp_messenger` and placing a
    new file inside, named `service.py`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We first start by importing `rpc` from `nameko.rpc`. This will allow us to decorate
    our methods with the `rpc` decorator and expose them as entrypoints into our service.
    An entrypoint is any method in a Nameko service that acts as a gateway into our
    service.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a Nameko service, we simply create a new class, `KonnichiwaService`,
    and assign it a `name` attribute. The `name` attribute gives it a namespace; this
    will be used later when we attempt to make a remote call to the service.
  prefs: []
  type: TYPE_NORMAL
- en: We've written a method on our service which simply returns the word `Konnichiwa!`.
    Notice how this method is decorated with `rpc`. The `konnichiwa` method is now
    going to be exposed via RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we test this code out we need to create a small `config` file which
    will tell Nameko where to access RabbitMQ and what RPC exchange to use. Create
    a new file, `config.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `AMQP_URI` configuration here is correct for users who have started the
    RabbitMQ container using the instructions given earlier. If you have adjusted
    the username, password or location, ensure that your changes are reflected here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have a directory structure that resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in your terminal, within the root of your project directory, execute the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Making a call to our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our microservice is now running! In order to make our own calls, we can launch
    a Python shell that has Nameko integrated to allow us to call our entrypoints.
    To access it, open a new terminal window and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you access to a Python shell with the ability to make Remote
    Procedure Calls. Let''s try that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It worked! We have successfully made a call to our Konnichiwa Service and received
    some output back. When we executed this code in our Nameko shell, we put a message
    on the queue, which was then received by our `KonnichiwaService`. It then spawned
    a new worker to carry out the work of the `konnichiwa` RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing a Nameko microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the documentation, [http://url.marcuspen.com/nameko](http://url.marcuspen.com/nameko),
    Nameko is:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A microservices framework for Python that lets service developers concentrate
    on application logic and encourages testability."'
  prefs: []
  type: TYPE_NORMAL
- en: We will now focus on the testability part of Nameko; it provides some very useful
    tools for isolating and testing its services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder, `tests`, and place two new files inside, `__init__.py`
    (which can be left blank) and `test_service.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When running outside of the test environment, Nameko spawns a new worker for
    each entrypoint that is called. Earlier, when we tested our `konnichiwa` RPC,
    the Konnichiwa Service would have been listening for new messages on the Rabbit
    queue. Once it received a new message for the `konnichiwa` entrypoint, it would
    spawn a new worker that would carry out that method and then die.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the anatomy of Nameko services, see: [http://url.marcuspen.com/nam-key](http://url.marcuspen.com/nam-key).'
  prefs: []
  type: TYPE_NORMAL
- en: For our tests, Nameko provides a way to emulate that via a `woker_factory`.
    As you can see, our test uses `worker_factory`, which we pass our service class,
    `KonnichiwaService`. This will then allow us to call any entrypoint on that service
    and access the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, from the root of your code directory, simply execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The test suite should now pass. Have a play around and try to make
    it break.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing HTTP entrypoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create a new microservice responsible for handling HTTP requests.
    First of all, let''s amend our imports in the `service.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Beneath the `KonnichiwaService` we made earlier, insert the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the follows a similar pattern to the `KonnichiwaService`. It has
    a `name` attribute and a method decorated in order to expose it as an entrypoint.
    In this case, it is decorated with the `http` entrypoint. We specify inside the
    `http` decorator that it is a `GET` request and the location of that request -
    in this case, the root of our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also one more crucial difference: This service holds a reference to
    the Konnichiwa Service via an `RpcProxy` object. `RpcProxy` allows us to make
    calls to another Nameko service via RPC. We instantiate it with the `name` attribute,
    which we specified earlier in `KonnichiwaService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out - simply restart the Nameko using the command from earlier
    (this is needed to take into account any changes to the code) and go to `http://localhost:8000/`
    in your browser of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/10d861cc-6456-4160-b51e-71bc67b982c9.png)'
  prefs: []
  type: TYPE_IMG
- en: It worked! We've now successfully made two microservices—one responsible for
    showing a message and one responsible for serving web requests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing Nameko microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier we looked at testing a service in isolation by spawning a single worker.
    This is great for unit testing but it is not a viable option for integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nameko gives us the ability to test multiple services working in tandem in
    a single test. Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, Nameko also gives us access to the following
    test fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`web_session`: Gives us a session in which to make HTTP requests to the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web_config`: Allows us to access the configuration for the service (outside
    of testing, this is equivalent to the `config.yaml` file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container_factory`: This allows us to simulate a service as a whole rather
    than just an instance of a worker, which is necessary when integration testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this is running the actual services, we need to specify the location
    of the AMQP broker by injecting it into the `web_config`. Using `container_factory`,
    we create two containers: `web_server` and `konnichiwa`. We then start both containers.'
  prefs: []
  type: TYPE_NORMAL
- en: It's then a simple case of using `web_session` to make a `GET` request to the
    root of our site and checking that the result is what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through the rest of the chapter, I encourage you to write your own
    tests for the code, as it will not only prevents bugs but also help to solidify
    your knowledge on this topic. It's also a good way to experiment with your own
    ideas and modifications to the code as they can tell you quickly if you have broken
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on testing Nameko services, see: [http://url.marcuspen.com/nam-test](http://url.marcuspen.com/nam-test).'
  prefs: []
  type: TYPE_NORMAL
- en: Storing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The messages we want our application to display need to be temporary. We could
    use a relational database for this, such as PostgreSQL, but that would mean having
    to design and maintain a database for something as simple as text.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is an in-memory data store. The entire dataset can be stored in memory
    making reads and writes much faster than relational databases, which is useful
    for data that is not going to need persistence. In addition, we can store data
    without making a schema, which is fine if we are not going to need complex queries.
    In our case, we simply need a data store that will allow us to store messages,
    get messages, and expire messages. Redis fits our use case perfectly!
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Redis container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your terminal, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start a Redis container with the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d`: Specifies we want to run the container in daemon mode (background process).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p`: Allows us to expose port `6379` on the container to our local machine.
    This are needed for Nameko to communicate with Redis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name`: Sets the container name to `redis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check that your new Redis container is running by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Python Redis client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will also need to install the Python Redis client to allow you to interact
    with Redis via Python. To do this, I recommend amending your `base.in` file from
    earlier to include `redis` and recompiling it to generate your new `base.txt`
    file. Alternatively, you can run `pip install redis`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s briefly look at the types of Redis commands that could be useful to
    us for TempMessenger:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SET`: Sets a given key to hold a given string. It also allows us to set an
    expiration in seconds or milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: Gets the value of the data stored with the given key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TTL`: Gets the time-to-live for a given key in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTTL`: Gets the time-to-live for a given key in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEYS`: Returns a list of all keys in the data store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To try them out, we can use `redis-cli` which is a program that ships with
    our Redis container. To access it, first log in to the container by executing
    the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then access `redis-cli` in the same terminal window by simply running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are some examples given as follows on how to use `redis-cli`; if you're
    not familiar with Redis then I encourage you to experiment with the commands yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set some data, `hello`, to key `msg1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Get data stored at key, `msg1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set some more data, `hi there`, at key `msg2`  and retrieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve all keys currently stored in Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Save data at `msg3` with an expiry of 15 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the time-to-live for `msg3` in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the time-to-live for `msg3` in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve `msg3` before it expires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve `msg3` after it expires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Nameko Dependency Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building microservices, Nameko encourages the use of dependency providers
    to communicate with external resources such as databases, servers, or anything
    that our application depends on. By using a dependency provider, you can hide
    away logic that is specific only to that dependency, keeping your service level
    code clean and agnostic to the ins-and-outs of interfacing with this external
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: By structuring our microservices like this, we have the ability to easily swap
    out or re-use dependency providers in other services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nameko provides a list of open source dependency providers that are ready to
    use: [http://url.marcuspen.com/nam-ext](http://url.marcuspen.com/nam-ext)[.](https://nameko.readthedocs.io/en/stable/community_extensions.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Redis Dependency Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Redis is an external resource for our application, we will create a dependency
    provider for it.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a new folder named `dependencies` inside of our `temp_messenger`
    folder. Inside, place a new file, `redis.py`. We will now create a Redis client
    with a simple method that will get a message, given a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off our code by implementing the `__init__` method, which creates
    our Redis client and assigns it to `self.redis`. `StrictRedis` that can take a
    number of optional arguments, however, we have only specified the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url`: Rather than specifying the host, port and database number separately,
    we can use `StrictRedis`'' `from_url`, which will allow us to specify all three
    with a single string, like so—`redis://localhost:6379/0`. This is a lot more convenient
    when it comes to storing it in our `config.yaml` later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decode_responses`: This will automatically convert the data we get from Redis
    into a Unicode string. By default, data is retrieved in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, in the same class, let''s implement a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside of our new class, let''s also implement a new error class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a method, `get_message`, that takes a `message_id` that will be
    used as our Redis key. We use the `get` method on our Redis client to retrieve
    the message with our given key. When retrieving values from Redis, if the key
    does not exist, it will simply return `None`. Since this method expects there
    to be a message, we should handle raising an error ourselves. In this case, we've
    made a simple exception, `RedisError`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Dependency Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we''ve created a Redis Client with a single method. We now need to create
    a Nameko Dependency Provider to utilize this client for use with our services.
    In the same `redis.py` file, update your imports to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you can see that our new `MessageStore` class inherits
    from the `DependencyProvider` class. The methods we have specified in our new
    MessageStore class will be called at certain moments of our microservice lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup`: This will be called before our Nameko services starts. Here we get
    the Redis URL from `config.yaml` and create a new `RedisClient` using the code
    we made earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: When our Nameko services begin to shut down, this will be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_dependency`: All dependency providers need to implement this method. When
    an entrypoint fires, Nameko creates a worker and injects the result of `get_dependency`
    for each dependency specified in the service into the worker. In our case, this
    means that our workers will all have access to an instance of `RedisClient`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nameko offers more methods to control how your dependency providers function
    at different moments of the service lifecycle: [http://url.marcuspen.com/nam-writ](http://url.marcuspen.com/nam-writ).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Message Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `service.py`, we can now make use of our new Redis Dependency Provider.
    Let''s start off by creating a new service, which will replace our Konnichiwa
    Service from earlier. First, we need to update our imports at the top of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create our new service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to our earlier services; however, this time we are specifying
    a new class attribute, `message_store`. Our RPC entrypoint, `get_message`, can
    now make use of this and call `get_message` in our `RedisClient` and simply return
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: We could have done all of this by creating a new Redis client within our RPC
    entrypoint and implementing a Redis `GET`. However, by creating a dependency provider,
    we promote reusability and hide away the unwanted behavior of Redis returning
    `None` when a key does not exist. This is just a small example of why Dependency
    Providers are extremely good at decoupling our services from external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try out the code we have just created. Start by saving a new key-value
    pair to Redis using the `redis-cli`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start our Nameko services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `nameko shell` to make remote calls to our new `MessageService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we were able to retrieve a message that we set earlier using `redis-cli`
    via our `MessageService` entrypoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now try to get a message that does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This isn't the prettiest of errors and there are certain things we can do to
    reduce the traceback with this, but the final line states the exception we defined
    earlier and clearly shows us why that request failed.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to saving messages.
  prefs: []
  type: TYPE_NORMAL
- en: Saving messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, I introduced the Redis `SET` method. This will allow us to save a message
    to Redis, but first, we need to create a new method in our dependency provider
    that will handle this.
  prefs: []
  type: TYPE_NORMAL
- en: We could simply create a new method that called `redis.set(message_id, message)`,
    but how would we handle new message IDs? It would be a bit troublesome if we expected
    the user to input a new message ID for each message they wanted to send, right?
    An alternative is to have the message service generate a new random message ID
    before it calls the dependency provider, but that would clutter our service with
    logic that could be handled by the dependency itself.
  prefs: []
  type: TYPE_NORMAL
- en: We'll solve this by having the dependency create a random string to be used
    as the message ID.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a save message method to our Redis client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `redis.py`, let''s amend our imports to include `uuid4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`uuid4` generates us a unique random string that we can use for our message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add our new `save_message` method to the `RedisClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: First off, we generate a new message ID using `uuid4().hex`. The `hex` attribute
    gives us the UUID as a 32-character hexadecimal string. We then use it as a key
    to save the message and return it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a save message RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the RPC method that is going to call our new client method.
    In our `MessageService`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy here, but notice how easy it is becoming to add new functionality
    to our service. We are separating logic that belongs in the dependency from our
    entrypoints, and at the same time making our code reusable. If another RPC method
    we create in the future needs to save a message to Redis, we can easily do so
    without having to recreate the same code again.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this out by only using the `nameko shell` - remember to restart your
    Nameko service for changes to take effect!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The ID returned here is random and will differ from the one you get from your
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have successfully saved a message and used the UUID that
    is returned to retrieve our message.
  prefs: []
  type: TYPE_NORMAL
- en: This is all well and good, but for the purposes of our app we don't expect the
    user to have to supply a message UUID in order to read messages. Let's make this
    a bit more practical and look at how we can get all of the messages in our Redis
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving all messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to our previous steps, we will need to add a new method to our Redis
    dependency in order to add more functionality. This time, we will be creating
    a method that will iterate through all of our keys in Redis and return the corresponding
    messages in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a get all messages method to our Redis client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the following to our `RedisClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We start off by using `self.redis.keys()` to gather all keys that are stored
    in Redis, which, in our case, are the message IDs. We then have a list comprehension
    that will iterate through all of the message IDs and create a dictionary for each
    one, containing the message ID itself and the message that is stored in Redis,
    using `self.redis.get(message_id)`.
  prefs: []
  type: TYPE_NORMAL
- en: For large scale applications in a production environment, it is not recommended
    to use the Redis `KEYS` method, since this will block the server until it has
    finished completing its operation. For more information, see: [http://url.marcuspen.com/rediskeys](http://url.marcuspen.com/rediskeys).
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer to use a list comprehension here to build the list of messages,
    but if you are struggling to understand this method, I recommend writing it as
    a standard for loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this example, see the following code for the same method built
    as a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Both of these methods do exactly the same thing. Which do you prefer? I'll leave
    that choice to you...
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I write a list or dictionary comprehension, I always start by having
    a test that checks the output of my function or method. I then write my code with
    a comprehension and test it to ensure the output is correct. I'll then change
    my code to a for loop and ensure the test still passes. After that, I look at
    both versions of my code and decide which one looks the most readable and clean.
    Unless the code needs to be super efficient, I always opt for code that reads
    well, even if that means a few more lines. This approach pays off in the long
    run when it comes to reading back and maintaining that code later!
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to obtain all messages in Redis. In the preceding code, I
    could have simply returned a list of messages with no dictionaries involved, just
    the string value of the message. But what if we wanted to add more data to each
    message later? For example, some metadata to say when the message was created
    or how long the message has until it expires... we'll get to that part later!
    Using a dictionary here for each message will allow us to easily evolve our data
    structures later on.
  prefs: []
  type: TYPE_NORMAL
- en: We can now look at adding a new RPC to our `MessageService` that will allow
    us to get all of the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a get all messages RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `MessageService` class, simply add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure that by now, I probably do not need to explain what is going on here!
    We are simply calling the method we made earlier in our Redis dependency and returning
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within your virtualenv, using `nameko shell`, we can now test this out.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There we have it! We can now retrieve all of the messages in our data store.
    (For the sake of space and readability, I've truncated the message IDs.)
  prefs: []
  type: TYPE_NORMAL
- en: There is one issue with the messages that are returned here - can you spot what
    it is? The order in which we put the messages into Redis is not the same order
    that we have received when we get them out again. We'll come back to this later,
    but for now, let's move on to displaying these messages in our web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying messages in the web browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we added the `WebServer` microservice to handle HTTP requests; we will
    now amend this so that when a user lands on the root home page, they are shown
    all of the messages in our data store.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to use a templating engine such as Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Jinja2 Dependency Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is a templating engine for Python that is extremely similar to the templating
    engine in Django. For those who are familiar with Django, you should feel right
    at home using it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, you should amend your `base.in` file to include `jinja2`, re-compile
    your requirements and install them. Alternatively, simply run `pip install jinja2`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the template renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When generating a simple HTML template in Jinja2, the following three steps
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three steps, it's important to identify which parts are never subject
    (or at least extremely unlikely) to change while our application is running...
    and which are. Keep this in mind as I explain through the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your dependencies directory, add a new file, `jinja2.py` and start with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In our `__init__` method, we require a package name and a template directory.
    With these, we can then create the template environment. The environment requires
    a loader, which is simply a way of being able to load our template files from
    a given package and directory. We've also specified that we want to enable auto-escaping
    on our HTML files for security.
  prefs: []
  type: TYPE_NORMAL
- en: We've then made a `render_home` method that will allow us to render our `home.html`
    template once we've made it. Notice how we render our template with `messages`...
    you'll see why later!
  prefs: []
  type: TYPE_NORMAL
- en: Can you see why I've structured the code this way? Since the `__init__` method
    is always executed, I've put the creation of our template environment there, since
    this is unlikely to ever change while our application is running.
  prefs: []
  type: TYPE_NORMAL
- en: However, which template we want to render and the variables we give to that
    template are always going to change, depending on what page the user is trying
    to access and what data is available at that given moment in time. With the preceding
    structure, it becomes trivial to add a new method for each webpage of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our homepage template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now look at the HTML required for our template. Let's start by creating
    a new directory next to our dependencies, titled `templates`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our new directory, create the following `home.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This HTML is nothing fancy, and neither is the templating logic! If you are
    unfamiliar to Jinja2 or Django templating then you're probably thinking that this
    HTML looks weird with the curly braces everywhere. Jinja2 uses these to allow
    us to input Python-like syntax into our template.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we start off with an `if` statement to see if we have
    any messages (the format and structure of `messages` will be the same as the messages
    that are returned by the `get_all_messages` RPC we made earlier). If we do, then
    we have some more logic, including a for loop that will iterate and display the
    value of `'message'` for each dictionary in our `messages` list.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no messages, then we will just show the `No messages!` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Jinja2, visit: [http://url.marcuspen.com/jinja2](http://url.marcuspen.com/jinja2).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Dependency Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now need to expose our `TemplateRenderer` as a Nameko Dependency Provider.
    In the `jinja2.py` file we made earlier, update our imports to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely similar to our previous Redis dependency. We specify a `setup`
    method that creates an instance of our `TemplateRenderer` and a `get_dependency`
    method that will inject it into the worker.
  prefs: []
  type: TYPE_NORMAL
- en: This is now ready to be used by our `WebServer`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a HTML response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now start to use our new Jinja2 dependency in our `WebServer`. First,
    we need to include it in our imports of `service.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now amend our `WebServer` class to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have assigned a new attribute, `templates`, like we did earlier
    in our `MessageService` with `message_store`. Our HTTP entrypoint now talks to
    our `MessageService`, retrieves all of the messages in Redis, and uses them to
    create a rendered template using our new Jinja2 dependency. We then return the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Restart your Nameko services and let''s try this out in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb3800d5-490c-4191-b33d-48391301b765.png)'
  prefs: []
  type: TYPE_IMG
- en: It's worked... sort of! The messages we stored in Redis earlier are present,
    which means the logic in our template is functioning properly, but we also have
    all of the HTML tags and indentation from our `home.html`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is because we haven't yet specified any headers for our
    HTTP response to indicate that it is HTML. To do this, let's create a small helper
    function outside of our `WebServer` class, which will convert our rendered template
    into a response with proper headers and a status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `service.py`, amend our imports to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following function outside of our classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a headers dictionary, which contains the correct content
    type, HTML. We then create and return a `Response` object with an HTTP status
    code of `200`, our headers, and the content, which in our case will be the rendered
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now amend our HTTP entrypoint to use our new helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `home` HTTP entrypoint now makes use of the `create_html_reponse`, giving
    it the rendered template, and then returns the response that is made. Let''s try
    this out again in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4fa4561f-41cd-471f-9798-b7b696ff5924.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can now see, our messages now display as we expect them with no HTML
    tags to be found! Have a try at deleting all data in Redis with the `flushall`
    command using the `redis-cli` and reload the webpage. What happens?
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to sending messages.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages via POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we've made good progress; we have a site that has the ability to display
    all of the messages in our data store with two microservices. One microservice
    handles the storing and retrieval of our messages, and the other acts as a web
    server for our users. Our `MessageService` already has the ability to save messages;
    let's expose that in our `WebServer` via a `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a send messages POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `service.py`, add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the following to our `WebServer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With our new `POST` entrypoint, we start off by extracting the data from the
    request. We specify the parameter `as_text=True`, because we would otherwise get
    the data back as bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have that data, we can then attempt to load it from JSON into a Python
    dictionary. If the data is not valid JSON then this can cause a `JSONDecodeError`
    in our service, so it's best to handle that nicely and return a bad request status
    code of `400`. Without this exception handling, our service would return an internal
    server error, which has a status code of `500`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the data is in a dictionary format, we can obtain the message inside
    it. Again, we have some defensive code which will handle any occurrences of an
    absent `'message'` key and return another `400`.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceed to save the message using the `save_message` RPC we made earlier
    in our `MessageService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, TempMessenger now has the ability to save new messages via an HTTP
    `POST` request! If you wanted to, you can test this out using curl or another
    API client, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We will now update our `home.html` template to include the ability to use this
    new `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an AJAX POST request in jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now before we start, let me say that at the time of writing, I am in no way
    a JavaScript expert. My expertise lie more in back-end programming than front-end.
    That being said, if you have worked in web development for more than 10 minutes,
    then you know that trying to avoid JavaScript is near impossible. At some point,
    we will probably have to dabble in some just to deliver a piece of work.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, *please do not be scared off!*
  prefs: []
  type: TYPE_NORMAL
- en: The code you are about to read is something that I learned just by reading the
    jQuery documentation, so it's extremely simple. If you are comfortable with front-end
    code then I'm sure there are probably a million different and probably better
    ways to do this in JavaScript, so please amend as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will first need to add the following after the `<!DOCTYPE html>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This will download and run the latest version of jQuery in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `home.html`, before the closing `</body>` tag, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We start off here with some simple HTML to add a basic form. This only has a
    text input and a submit button. On its own, it will render a text box and a submit
    button, but it will not do anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now follow that code with some jQuery JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now add some functionality to our submit button. Let''s briefly cover
    what is happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: This will create an event listener for our page that listens for the `postMessage`
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also prevent the default behavior of our submit button using `event.preventDefault();`.
    In this case, it would submit our form and attempt to perform a `GET` on `/messages?message=I%27m+a+new+message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once that is triggered, we then find the message and URL in our form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these, we then construct our AJAX request, which is a POST request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `JSON.stringify` to convert our payload into valid JSON data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember earlier, when we had to construct a response and supply header information
    to say that our content type was `text/html`? Well, we are doing the same thing
    here in our AJAX request, but this time, our content type is `application/json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the `datatype` to `json`. This tells the browser the type of data we
    are expecting back from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also register a callback that reloads the webpage if the request is successful.
    This will allow us to see our new message on the page (and any other new ones)
    since it will get all of the messages again. This forced page reload is not the
    most elegant way of handling this, but it will do for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s restart Nameko and try this out in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e58ffe52-a0b1-40b3-9733-27e950d20384.png)'
  prefs: []
  type: TYPE_IMG
- en: Provided you haven't cleared the data from Redis (this can be done by manually
    deleting them or by simply restarting your machine), you should still see the
    old messages from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve typed your message, click the Post button to submit your new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19fa394e-4f12-420b-916c-91e819e7edcf.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks like it worked! Our application now has the ability to send new messages.
    We will now move onto the last requirement for our application, which is to expire
    messages after a given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Expiring messages in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now onto the last requirement for our app, expiring messages. Since we
    are using Redis to store our messages, this becomes a trivial task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look back at our `save_message` method in our Redis dependency. Redis''
    `SET` has some optional parameters; the two we are most interested in here are
    `ex` and `px`. Both allow us to set the expiry of the data we are about to save,
    with one difference: `ex` is in seconds and `px` is in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that the only amendment to the code I've
    made is to add `ex=10` to the `redis.set` method; this will cause all of our messages
    to expire in 10 seconds. Restart your Nameko services now and try this out. When
    you send a new message, wait 10 seconds and refresh the page, and it should be
    gone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Please note** that if there were any messages in Redis before you made this
    change, they will still be present, since they were saved without an expiry. To
    remove them, delete all data in Redis with the `flushall` command using the `redis-cli`.'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around with the expiry time, setting it to whatever you wish
    with either the `ex` or `px` parameters. One way you could make this better is
    to move the expiry time constant to the configuration file, which is then loaded
    whenever you start Nameko, but for now, this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing you will quickly notice with the current state of our app is that
    the messages are not in any order at all. When you send a new message it could
    be inserted anywhere in the thread of messages, making our app pretty inconvenient,
    to say the least!
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, we will sort the messages by the amount of time left before
    they expire. First, we will have to amend our `get_all_messages` method in our
    Redis dependency to also get the time-to-live for each message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we have added a new `expires_in` value
    to each message. This uses the Redis PTTL command, which returns the time to live
    in milliseconds for a given key. Alternatively, we could also use the Redis TTL
    command, which returns the time to live in seconds, but we want this to be as
    precise as possible to make our sorting more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when our `MessageService` calls `get_all_messages`, it will also know how
    long each message has to live. With this, we can create a new helper function
    to sort the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following to our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside of the `MessageService` class, create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This uses Python's built-in `sorted` function, which has the ability to return
    a sorted list from a given iterable; in our case the iterable is `messages`. We
    use `key` to specify what we want `messages` to be sorted by. Since we want the
    `messages` to be sorted by `expires_in`, we use an `itemgetter` to extract it
    to be used as the comparison. We've given the `sort_messages_by_expiry` function
    an optional parameter, `reverse`, which, if set to `True`, will make `sorted`
    return the sorted list in a reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new helper function, we can now amend our `get_all_messages` RPC
    in our `MessageService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app will now return our messages, sorted with the newest messages at the
    bottom. If you''d like to have the newest messages at the top, then simply change
    `sorted_messages` to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Our app now fits all the acceptance criteria we specified earlier. We have the
    ability to send messages and get existing messages, and they all expire after
    a configurable amount of time. One thing that is less than ideal is that we rely
    on a browser refresh to fetch the latest state of the messages. We can fix this
    in a number of ways, but I will demonstrate one of the simplest ways to solve
    this; via polling.
  prefs: []
  type: TYPE_NORMAL
- en: By using polling, the browser can constantly make a request to the server to
    get the latest messages without forcing a page refresh. We will have to introduce
    some more JavaScript to achieve this, but so would any other method.
  prefs: []
  type: TYPE_NORMAL
- en: Browser polling for messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the browser makes a poll to get the latest messages, our server should
    return the messages in a JSON format. To achieve this, we'll need to create a
    new HTTP endpoint that returns the messages as JSON, without using the Jinja2
    templating. We will first construct a new helper function to create a JSON response,
    setting the correct headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside of our WebServer, create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to our `create_html_response` from earlier, but here it sets
    the Content-Type to `'application/json'` and converts our data into a valid JSON
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, within the WebServer, create the following HTTP entrypoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This will call our `get_all_messages` RPC and return the result as a JSON response
    to the browser. Notice how we are using the same URL, `/messages`, as we do in
    our endpoint, here to send a new message. This is a good example of being RESTful.
    We use a POST request to `/messages` to create a new message and we use a GET
    request to `/messages` to get all messages.
  prefs: []
  type: TYPE_NORMAL
- en: Polling with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable our messages to update automatically without a browser refresh, we
    will create two JavaScript functions—`messagePoll`, which will get the latest
    messages, and `updateMessages`, which will update the HTML with these new messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by replacing the Jinja2 `if` block in our `home.html`, which iterates
    through our list of messages, with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This will be used later to hold our new list of messages generated by our jQuery
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `<script>` tags in our `home.html`, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another AJAX request, similar to the one we made earlier to send a
    new message, with a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are performing a `GET` request to the new endpoint we made in our `WebServer`
    instead of a `POST` request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successful, we use the `success` callback to call the `updateMessages` function
    that we will create later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `timeout` to 500 milliseconds - this is the amount of time in which we should
    expect a response from our server before giving up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `complete`, which allows us to define what happens once the `success` or
    `error` callback has completed - in this case, we set it to call `poll` again
    after 1000 milliseconds using the `setTimeout` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now create the `updateMessages` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'By using this function, we can replace all of the code in our HTML template
    that generates the list of messages in the Jinja2 template. Let''s go through
    this step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the `messageContainer` within the HTML so that we can update it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate an empty `messageList` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate the `emptyMessages` text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We check if the amount of messages is equal to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, we use `.html()` to replace `messageContainer` HTML with `"No messages!"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, for each message in `messages`, we first strip any HTML tags that
    could be present using jQuery's built-in `.text()` function. Then we wrap the
    message in `<p>` tags and append them to the `messageList` using `.push()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use `.html()` to replace the `messageContainer` HTML with the `messagesList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In point *4b*, it's important to escape any HTML tags that could be present
    in the message, as a malicious user could send a nasty script as a message, which
    would be executed by everyone using the app!
  prefs: []
  type: TYPE_NORMAL
- en: This is by no means the best way to solve the issue of having to force refresh
    the browser to update the messages, but it is one of the simplest ways for me
    to demonstrate in this book. There are probably more elegant ways to achieve the
    polling, and if you really wanted to do this properly then WebSockets is by far
    your best option here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This now brings us to a close with the guide to writing the TempMessenger application.
    If you have never used Nameko before or written a microservice, I hope I have
    given you a good base to build on when it comes to keeping services small and
    to the point.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating a service with a single RPC method and then used that
    within another service via HTTP. We then looked at ways in which we can test Nameko
    services with fixtures that allow us to spawn workers and even the services themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced dependency providers and created a Redis client with the ability
    to get a single message. With that, we expanded the Redis dependency with methods
    that allowed us to save new messages, expire messages, and return them all in
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how we can return HTML to the browser using Jinja2, and at creating
    a dependency provider. We even looked at some JavaScript and JQuery to enable
    us to make requests from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main themes you will have probably noticed is the need to keep dependency
    logic away from your service code. By doing this we keep our services agnostic
    to the workings that are specific to only that dependency. What if we decided
    to switch Redis for a MySQL database? In our code, it would just be a case of
    creating a new dependency provider for MySQL and new client methods that mapped
    to the ones our `MessageService` expects. We'd then make the minimal change of
    swapping Redis for MySQL in our `MessageService`. If we did not write our code
    in this way then we would have to invest more time and effort to make changes
    to our service. We'd also introduce more scope for bugs to arise.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with other Python frameworks, you should now see how Nameko
    allows us to easily create scalable microservices while still giving us a more
    *batteries not included *approach when compared to something like Django. When
    it comes to writing small services that serve a single purpose that are focused
    on backend tasks, Nameko can be a perfect choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at extending TempMessenger with a User Authentication
    microservice using a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
