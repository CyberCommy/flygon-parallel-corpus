- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Code Reusability in C# 9
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reusability is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse, as well as to help you
    understand how .NET 5 goes in this direction to solve the problem of managing
    and maintaining a reusable library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of code reuse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of working with .NET 5 versus .NET Standard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable libraries using .NET Standard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although code reuse is an exceptional practice, as a software architect you
    must be aware when this is important for the scenario you are dealing with. Many
    good software architects agree that there is a lot of overengineering due to trying
    to make things reusable even though they are often single-use or not understood
    well enough.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: You need the free Visual Studio 2019 Community edition or better with all the
    database tools installed.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the principles of code reusability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a single reason that you can always use to justify code reuse – you
    cannot spend your valuable time recreating the wheel if it is already running
    well in other scenarios. That is why most engineering domains are based on reusability
    principles. Think about the light switches you have in your house.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In software engineering, code reuse is one of the techniques that can bring
    a software project a bunch of advantages, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: There is confidence in the software, considering that the reused piece of code was
    already tested in another application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is better usage of software architects and the senior team since they
    can be dedicated to solving this kind of problem.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is the possibility of bringing to the project a pattern that is already
    accepted by the market.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development speed goes up due to the already implemented components.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance is easier.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These aspects indicate that code reuse should be done whenever it is possible.
    It is your responsibility, as a software architect, to ensure the preceding advantages
    are utilized and, more than that, that you incentivize your team to enable reuse
    in the software they are creating.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: What is not code reuse?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you must understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate that you are properly working with reusability
    principles. Let us imagine a scenario that we will find in this book's use case,
    the WWTravelClub evaluation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project scenario, you may want to evaluate different kinds of subjects,
    such as the **Package**, **DestinationExpert**, **City**, **Comments**, and so
    on. The process for getting the evaluation average is the same, no matter which
    subject you are referring to. Due to this, you may want to *enable* reuse by copying
    and pasting the code for each evaluation. The (bad) result will be something like
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Bad implementation – there is no code reuse here'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the process of calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach is
    used in other applications. For instance, if there is a new specification about
    how you have to calculate the average or if you just get a bug in the calculation
    formula, you will have to fix it in all instances of code. If you do not remember
    to update it in all places, you will possibly end up with an inconsistent implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: What is code reuse?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution to the problem mentioned in the previous section is quite simple:
    you must analyze your code and select the parts of it that would be good to decouple
    from your application.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The greatest reason why you should decouple them is related to how you are
    sure that this code can be reused in other parts of the application, or even in
    another application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: An implementation focused on code reuse'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The centralization of the code brings to you, as a software architect, a different
    responsibility for it. You will have to keep in mind that a bug or incompatibility
    in this code could cause damage to many parts of the application or different
    applications. On the other hand, once you have this code tested and running, you
    will be able to propagate its usage with no worries. Besides, if you need to evolve
    the average calculation process, you will have to change the code in a single
    class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Cost needs to be mentioned because, in general, the conception
    of reusable software costs more in the beginning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Reusability in the development life cycle
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you understood that reusability will take you to another level of code implementation,
    you should have been thinking about how to make this technique available in your
    development life cycle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, creating and maintaining a component library is not very
    easy, due to the responsibility you will have and the lack of good tools to support
    the search for existing components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there are some things that you may consider implementing
    in your software development process every time you initiate a new development:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Use** already implemented components from your user library, selecting features
    in the software requirements specification that need them.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify** features in the software requirements specification that are candidates
    to be designed as library components.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify** the specification, considering that these features will be developed
    using reusable components.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build** the project architecture with the new component library version.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document** the component library version so that every developer and team
    knows about it.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implementing every time you need to enable software reuse. As soon as you have
    the components you need to write for this library, you will need to decide on
    the technology that will provide these components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: During the history of software development, there have been many approaches
    to doing this; some of them were discussed in *Chapter 5*, *Applying a Microservice
    Architecture to Your Enterprise Application*, in the *Microservices and the evolution
    of the concept of modules* section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET 5 or .NET Standard for code reuse
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has evolved a lot since its first version. This evolution is not only related
    to the number of commands and performance issues, but the supported platforms
    too. As we discussed in *Chapter 1*, *Understanding the Importance of Software
    Architecture*, you can run C# .NET on billions of devices, even if they are running
    Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced
    together with .NET Core 1.0, but .NET Standard became particularly important with
    .NET Standard 2.0, when .NET Framework 4.6, .NET Core, and Xamarin were compatible
    with it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is that .NET Standard was not only a kind of Visual Studio project.
    More than that, it was a formal specification available to all .NET implementations.
    As you can see in the following table, it covers everything from .NET Framework
    to Unity:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| .NET Core and .NET 5 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1 | 4.6.1 | 4.6.1
    | N/A |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: You can find a full .NET Standard overview at [https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table indicates that if you build a class library that is compatible
    with this standard, you will be able to reuse it in any of the platforms presented.
    Think about how fast your development process could become if you plan to do this
    in all your projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft's official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The initiative of having a single framework for all platforms brought us to
    .NET 5\. Microsoft indicates that from now, net5.0 or later will run everywhere.
    The next question you, as a software architect, might have is: what is going to
    happen to .NET Standard?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this question is well explained by Immo Landwerth at the dotnet
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET 5.0 (and future versions) needs to be thought of
    as the foundation for sharing code moving forward.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET Standard library
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite simple to create a class library compatible with .NET Standard.
    Basically, you need to choose the following project when creating the library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Creating a .NET Standard library'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have concluded this part, you will notice that the only difference
    between a common class library and the one you created is the target framework
    defined in the project file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all the project types we
    checked previously. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: How does C# deal with code reuse?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many approaches where C# helps us deal with code reuse. The ability
    to build libraries, as we did in the previous section, is one of them. The most
    important one is the fact that the language is object-oriented. Besides, it is
    worth mentioning the facilities that generics brought to the C# language. This
    section will discuss the last two we mentioned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented analysis
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming will let you implement abstraction
    and encapsulation too.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how using the object-oriented approach makes reuse
    easier. As you can see, there are different ways to calculate the grades of an evaluation,
    considering you can be a basic or a prime user of the system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Object-oriented case analysis'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there is no need to declare the properties in each child class since inheritance
    is doing it for you.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is the opportunity to use polymorphism, enabling different behaviors
    for the same method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, you can see the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    look at how easy it is to call different objects inherited by the same class.
    Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users too:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage will need study and practice. You, as a software architect,
    should always incentivize your team to study object-oriented analysis. The more
    abstraction abilities they have, the easier code reuse will become.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generics were introduced in C# in version 2.0, and it is considered an approach
    that increases code reuse. It also maximizes type safety and performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, or even a delegate, a placeholder that will be replaced
    with a specific type at a later time when one of the preceding entities is used.
    The opportunity you have with this feature is incredible since you can use the
    same code to run different versions of the type, generically.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the previous section. The idea here is to enable the generalization of the
    service, giving us the opportunity to define the goal of evaluation since its
    creation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This declaration indicates that any class that implements the `IContentEvaluaded`
    interface can be used for this service. Besides, the service will be responsible
    for creating the evaluated content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the evaluated content that was created since
    the construction of the service. This code uses `System.Reflection` and the generic
    definition from the class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is worth mentioning that this code will work because all the classes are
    in the same assembly. Besides, reflection is not mandatory while using generics.
    The result of this modification can be checked in the instance creation of the
    service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The good news is that, now, you have a generic service that will automatically
    instantiate the list object with the evaluations of the content you need. It's
    worth mentioning that generics will obviously need more time dedicated to the
    first project's construction. However, once the design is done, you will have
    good, fast, and easy-to-maintain code. This is what we call reuse!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: What if the code is not reusable?
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In fact, any code can be reusable. The key point here is if the code you intend
    to reuse is well-written and follows good patterns for reuse. There are several
    reasons why code should be considered not ready for reuse:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**The code was not tested before**: Before reusing code, it is a good approach
    to guarantee that it works.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code is duplicated**: If you have duplicate code, you will need to find
    each place where it is being used so you only have a single version of the code
    being reused.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code is too complex to understand**: Code that is reused in many places
    needs to be written with simplicity to enable easy understanding.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code has tight coupling**: This is a discussion related to composition
    versus inheritance when building separate class libraries. Classes (with interfaces)
    are usually much easier to reuse than base classes that can be inherited.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In any of these cases, considering a refactoring strategy can be a great approach.
    When you are refactoring code, you are writing it in a better way while respecting
    the input and output data that this code will process. This enables more comprehensive
    and lower-cost code when it comes to changing it. Martin Fowler indicates some
    reasons why we should consider refactoring:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**It improves software design**: The more expert your team becomes, the better
    the design will be. A better software design will deliver not only faster coding,
    but it will bring us the opportunity to process more tasks in less time.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It makes the software easier to understand**: Regardless of whether we are
    talking about juniors or seniors, good software needs to be understood by each
    developer you have in the team.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It helps us find bugs**: While you are refactoring, you will find business
    rules that may have not been well-programmed, so you will find bugs.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It makes us program quicker**: The result of refactoring will be code that
    will enable faster development in the future.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of refactoring depends on some steps that we shall follow to guarantee
    good results and minimize errors during the journey:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Be sure you have a set of tests to guarantee the correct processing**: The
    set of tests you have will eliminate the fear of having to clean code.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminate duplication**: Refactoring is a good opportunity to eliminate code
    duplication.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize complexity**: Considering you will have the goal of making the code
    more understandable, following the best practices of programming, as mentioned
    in *Chapter 17*, *Best practices in Coding C# 9*, will reduce the complexity of
    the code.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean up the design**: Refactoring is a good time for reorganizing the design
    of your libraries too. Do not forget to update them too. This can be a great way
    to eliminate bugs and security issues.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a software architect, you will receive many refactoring demands from your
    team. The incentive for doing so must be continuous. But you must remind your
    team that refactoring without following the preceding steps might be risky. So,
    it is your responsibility to make it happen in a way that can both enable fast
    programming and less impact, thus delivering real business value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: I have my libraries. How do I promote them?
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering you have made all the necessary effort to guarantee you have good
    libraries that must be reused in many of your projects, you will find another
    difficult situation arises when enabling reusability: it is not simple to let
    programmers know you have libraries ready to reuse.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There are some simple approaches to documenting a library. As we mentioned when
    we talked about the development life cycle, documenting is a good way to help
    developers take notice of the libraries they have. There are two examples of documenting
    reusable code that we would like to mention here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Documenting .NET libraries using DocFX
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This tool is a good alternative for documenting a library using comments made
    in its code. By simply adding the NuGet package `docfx.console`, the tool allows
    you to create a task that will run once your library has been built:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: docfx.console NuGet library'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this compilation is a stylish static website that contains the
    documentation of your code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_06.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: DocFx result'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: This website is useful because you can distribute the documentation to your
    team so that they can search for the libraries you have. You can check the customizations
    of the output and find more information about it at [https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a Web API using Swagger
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no doubt that a Web API is one of the technologies that facilitates
    and promotes code reuse. For this reason, having its documentation well done and,
    more than that, respecting a standard is good practice and indicates that you
    are up to date on to this approach. To do this, we have Swagger, which respects
    the OpenAPI Specification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI Specification is known as the standard for describing modern APIs.
    One of the most widely used tools for documenting it in an ASP.NET Core Web API
    is `Swashbuckle.AspNetCore`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about implementing the `Swashbuckle.AspNetCore` library is that
    you can set the Swagger UI viewer for your Web API, which is a good, graphical
    way to distribute the APIs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to use this library in ASP.NET Core Web APIs in the next chapter.
    Until then, it is important to understand that this documentation will help not
    only your team, but any developer who might use the APIs you are developing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Use case – reusing code as a fast way to deliver good and safe software
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final design of the solution for evaluating content for WWTravelClub can
    be checked as follows. This approach consists of using many topics that were discussed
    in this chapter. First, all the code is placed in a .NET Standard class library.
    This means that you can add this code to different types of solutions, such as
    .NET Core web apps and Xamarin apps for the Android and iOS platforms:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_13_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: WWTravelClub reuse approach'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: This design makes use of object-oriented principles such as inheritance, so
    you do not need to write properties and methods more than once that can be used
    in many classes; and polymorphism, so that you can change the behavior of the
    code without changing the name of the method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To finish, the design abstracts the idea of the content by introducing generics
    as a tool that can facilitate the manipulation of similar classes, such as the
    ones we have in WWTravelClub to evaluate content regarding cities, comments, destination
    experts, and travel packages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between a team that incentivizes code reuse and one that
    does not is the velocity of delivering good software to end users. Of course,
    beginning this approach is not easy, but rest assured that you will get good results
    after some time working with it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what is not properly reused code. This chapter also presented
    approaches for reusing and refactoring code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Considering that technology without processes does not take you anywhere, a
    process was presented that helps enable code reuse. This process is related to
    using already completed components from your library; identifying features in
    the software requirements specification that are candidates to be designed as
    library components; modifying the specification considering these features; designing
    the reusable components; and building the project architecture with the new component
    library version.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, this chapter presented .NET Standard libraries as an approach to
    reusing code for different C # platforms, indicating that .NET 5 and new versions
    shall be used for reusing code in different platforms. This chapter also reinforced
    the principles of object-oriented programming when reusing code and presented
    generics as a sophisticated implementation to simplify the treatment of objects
    with the same characteristics. In the next chapter, we will learn how to apply
    a **service-oriented architecture** (**SOA**) with .NET Core.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that SOA is considered a way to implement code reuse
    in sophisticated environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make use of code reuse without copying and pasting code?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a process that can help with code reuse?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between .NET Standard and .NET Core?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of creating a .NET Standard library?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建.NET Standard库的优势是什么？
- en: How does object-oriented analysis help with code reuse?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象分析如何帮助代码重用？
- en: How do generics help with code reuse?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型如何帮助代码重用？
- en: Will .NET Standard be replaced with .NET 5?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard将被.NET 5取代吗？
- en: What are the challenges related to refactoring?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与重构相关的挑战是什么？
- en: Further reading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are some books and websites where you will find more information about
    this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，您将在其中找到有关本章的更多信息：
- en: '*Clean Code: A Handbook of Agile Software Craftmanship by* Martin, Robert C.
    Pearson Education, 2012.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《干净的代码：敏捷软件工艺的手册》（Martin，Robert C. Pearson Education，2012年）。
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《干净的架构：软件结构和设计的工匠指南》（Martin，Robert C. Pearson Education，2018年）。
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erica Gamma
    [et al.] Addison-Wesley, 1994.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可重用面向对象软件的元素》（Erica Gamma等人著，Addison-Wesley，1994年）。
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计原则和设计模式》（Robert C. Martin，2000年）。
- en: '*Refactoring* by Martin Fowler, 2018.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《重构》（Martin Fowler，2018年）。
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
- en: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
- en: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
- en: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
- en: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
