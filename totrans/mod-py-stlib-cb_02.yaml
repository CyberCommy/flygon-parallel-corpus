- en: Text Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching—regular expressions are not the only way to parse patterns;
    Python provides easier and just as powerful tools to parse patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text similarity—detecting how two similar strings in a performing way can be
    hard but Python has some easy-to-use built-in tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text suggestion—Python looks for the most similar one to suggest to the user
    the right spelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templating—when generating text, templating is the easiest way to define the
    rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting strings preserving spaces—splitting on empty spaces can be easy, but
    gets harder when you want to preserve some spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleanup text—removes any punctuation or odd character from text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normalizing text—when working with international text, it's often convenient
    to avoid having to cope with special characters and misspelling of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning text—when outputting text, properly aligning it greatly increases readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python was born for system engineering and a very frequent need when working
    with shell scripts and shell-based software is to create and parse text. That's
    why Python has very powerful tools to handle text.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking for patterns in text, regular expressions are frequently the most
    common way to attach those kind of problems. They are very flexible and powerful,
    and even though they cannot express all kinds of grammar they frequently can handle
    most common cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of regular expressions comes out of the wide set of symbols and expressions
    they can generate. The problem is that for developers that are not used to regular
    expressions, they can look just like plain noise, and even people who have experience
    with them will frequently have to think a bit before understanding an expression
    like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This expression actually tries to detect phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most common cases, developers need to look for very simple patterns: for
    example, file extensions (does it end with `.txt`?), separated text, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fnmatch` module provides a simplified pattern-matching language with a
    very quick and easy-to-understand syntax for most developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very few characters have a special meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*` means any text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` means any character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[...]` means the contained characters within square brackets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[!...]` means everything apart from the characters contained within the square
    brackets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will probably recognize this syntax from your system shell, so it''s easy
    to see how `*.txt` means *every name that has a .txt extension*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practically, `fnmatch` can be used to recognize pieces of text separated by
    some kind of constant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I have a pattern that defines the `type`, `name`, and `value`
    of a variable separated by `:`, we can recognize it through `fnmatch` and then
    declare the described variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `fnmatch` obviously shines is with filenames. If you have a list of files,
    it''s easy to extract only those that match a specific pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While very convenient, `fnmatch` is surely limited, but one of the best things
    a tool can do when it reaches its limits is to provide compatibility with an alternative
    tool that can overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I wanted to find all files that contained the word `git` or
    `vs`, I couldn't do that in a single `fnmatch` pattern. I have to declare two
    different patterns and then join the results. But, if I could use a regular expression,
    that is absolutely possible.
  prefs: []
  type: TYPE_NORMAL
- en: '`fnmatch.translate` bridges between `fnmatch` patterns and regular expressions,
    providing the regular expression that describes an `fnmatch` pattern, so that
    it can be extended how you wish.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could create a regular expression that matches both patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The real advantage of `fnmatch` is that it is an easy and safe enough language
    that you can expose to your users. Suppose you are writing an email client and
    you want to provide a search feature, how could you let your users search for
    Smith as a name or surname if you have emails from Jane Smith and Smith Lincoln?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well with `fnmatch` that''s easy because you can just expose it to your users
    and let them write `*Smith` or `Smith*`, depending on whether they are looking
    for someone named Smith or with Smith as a surname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Text similarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, when working with text, we might have to recognize text that
    is similar to other text, even when the two are not equal. This is a very common
    case in record linkage, finding duplicate entries, or for typing errors correction.
  prefs: []
  type: TYPE_NORMAL
- en: Finding similarity across text is not a straightforward task. If you try to
    go your own way, you will quickly realize that it gets complex and slow pretty
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: The Python library provides tools to detect differences between two sequences
    in the `difflib` module. Since text itself is a sequence (a sequence of characters),
    we can apply the provided functions to detect similarities in strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a string, we want to compare:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we want to compare a set of strings to the first string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `difflib.SequenceMatcher` to compute the similitude (from 0 to 1)
    between the strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So `SequenceMatcher` was able to detect that `s` and `s2` are very similar (98%),
    and apart from a typo in `weather`*,* they are in fact the same exact phrase.
    Then it stated that `Today the weather is nice` is 80% similar to `Yesterday the
    weather was nice` and finally that `Today the weather is nice` and `Today my dog
    ate steak` have very little in common.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SequenceMatcher` provides support for marking some values as *junk.* You
    might expect this to mean that those values are ignored, but in fact that's not
    what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing ratios with and without junk will return the same value in most cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `a` results were not ignored even though we provided an `isjunk` function
    that reports all `a` results as junk (the first argument to `SequenceMatcher`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see by using `.get_matching_blocks()` that in both cases the only parts
    of the string that match are the `X` in position `13` and `0` for `a` and `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to ignore some characters when computing the difference, you will
    have to strip them before running the `SequenceMatcher`, maybe using a translation
    map that discards them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Text suggestion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we saw how `difflib` can compute the similitude between
    two strings. This means that we can compute the similitude between two words and
    suggest corrections to our users.
  prefs: []
  type: TYPE_NORMAL
- en: If the set of *correct* words is known (which usually is for any language),
    we can first check if the word is in this set and, if not, we can look for the
    most similar one to suggest to the user the right spelling.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to follow this recipe are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all we need the set of valid words. To avoid bringing in the whole
    English dictionary, we will just sample some words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can make a function that for any provided phrase looks for the words
    in our dictionary and, if they are not there, provides the most similar candidate
    through `difflib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `suggest` function will be able to detect misspellings and suggest a corrected
    phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first returned argument is the number of wrong words detected and the second
    is the string with the most reasonable corrections.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our phrase has no errors, we will just get back `0` with the original phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very frequent need when showing text to users is to generate it dynamically
    depending on the state of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, this leads to code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This makes it very hard to foresee the upcoming structure of the message and
    it's also very hard to maintain in the long term. To generate text, it's usually
    more convenient to reverse the approach and instead of putting text in code, we
    shall put code in text. That's exactly what template engines do and, while the
    standard library has very complete solutions for formatting, it lacks a template
    engine out of the box, but it can easily be extended to make one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `string.Formatter` object allows you to extend its syntax, so we can specialize
    it to support injecting code into the expressions that it''s going to accept:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `TemplateFormatter` can then be used to generate text similar to our example
    in a much cleaner way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `string.Formatter` supports the same language that the `str.format` method
    supports. Practically, it parses expressions contained with `{}` according to
    what Python calls *format string syntax*. Everything outside of `{}` is preserved
    as is, while anything within `{}` is parsed for the `field_name!conversion:format_spec`
    specification. So, as our `field_name` doesn't contain `!` or `:`, it can be anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: The `field_name` extracted is then provided to `Formatter.get_field` to look
    up the value of that field in the provided arguments of the `format` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, take an expression like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because the `{name}` is identified as a block to parse, the name is looked up
    in `.format` arguments and the rest is preserved as is.
  prefs: []
  type: TYPE_NORMAL
- en: This is very convenient and can solve most string formatting needs, but it lacks
    the power of a real template engine like loops and conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: What we did is extended `Formatter` not only to resolve variables specified
    in `field_name`, but also to evaluate Python expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know that all `field_name` resolutions go through `Formatter.get_field`,
    overriding that method in our own custom class would allow us to change what happens
    whenever a `field_name` like `{name}` is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To distinguish plain variables from expressions, we used the `$` symbol. As
    a Python variable could never start with `$`, there was no risk that we would
    collide with an argument provided to format (as `str.format($something=5` is actually
    a syntax error in Python). So, a `field_name` like `{$something}` would not mean
    looking up the value of `''''$something`, but to evaluate the `something` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eval` function runs any code written in a string and restricts execution
    to an expression (expressions in Python always lead to a value, differently from
    statements which don''t), so we also had syntax checking that would prevent template
    users from writing `if something: x=''hi''`, which wouldn''t provide any value
    to display in the text resulting from rendering the template.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, as we want users to be able to look up any variable that was referenced
    by the expressions they provided (like `{$len(messages)}`), we provide `kwargs`
    as the `locals` variables to `eval`, so that any expression referring to a variable
    would properly resolve. We also provide an empty global context `{}`, so that
    we don't inadvertently touch any global variable of our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part left is just returning the result of the expression execution
    provided by `eval` as the result of the `field_name` resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The really interesting part is that as all the processing happens in the `get_field`
    phase. Conversion and format specification are still supported as they are applied
    over the value returned by `get_field`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to write something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We get back `1.50` as the output instead of `1.5`. This is because we evaluate
    `3/2.0` as first thing in our specialized `TemplateFormatter.get_field` method
    and then the parser goes on applying the formatter specification (`.2f`) to the
    resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our simple template engine is convenient, but limited to cases where we can
    express the code generating our text as a set of expressions and static text.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that more advanced templates are not always possible to represent.
    We are restricted to plain expressions, so practically anything that cannot be
    represented in a `lambda` cannot be executed by our template engine.
  prefs: []
  type: TYPE_NORMAL
- en: While some would argue that very complex software can be written by combining
    multiple `lambda`, most people would recognize that statements lead to far more
    readable code.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, if you need to process very complex text, you should go to
    a full-featured template engine and look for something such as Jinja, Kajiki,
    or Mako as a solution to your problem. Especially for generating HTML, solutions
    such as Kajiki, which is also able to validate your HTML, are very convenient
    and can go much further than our `TemplateFormatter`.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting strings and preserving spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually when splitting strings on spaces, developers will tend to rely on `str.split`,
    which is able to serve that purpose pretty well. But when the need to *split some
    spaces and preserve others* arises, things quickly become harder and implementing
    a custom solution can require investing time in proper escaping.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just rely on `shlex.split` instead of `str.split`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`shlex` is a module originally created to parse Unix shell code. For that reason,
    it supports preserving phrases through quotes. Typically, in Unix command lines,
    words separated by spaces are provided as arguments to the called command, but
    if you want to provide multiple words as a single argument, you can use quotes
    to group them.'
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly what `shlex` reproduces, providing us with a reliable way to
    drive the splitting. We just need to wrap everything we want to preserve in double
    or single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When analyzing user-provided text, we are frequently interested only in meaningful
    words; punctuation, spaces, and conjunctions might easily get in our way. Suppose
    you want to count word frequencies in a book, you don't want to end up with "world"
    and "world" being counted as two different words.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Supply the text you want to clean up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rely on `string.punctuation` to know which characters we want to discard
    and make a translation table to discard them all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a cleaned-up version of our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core of this recipe is the usage of translation tables. Translation tables
    are mappings that link a character to its replacement. A translation table like `{''c'':
    ''A''}` means that any `''c''` must be replaced with an `''A''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str.maketrans` is the function used to build translation tables. Each character
    in the first argument will be mapped to the character in the same position in
    the second argument. Then all characters in the last argument will be mapped to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `97`, `98`, and `99` are the Unicode values for `''a''`, `''b''`, and `''c''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our mapping can be passed to `str.translate` to apply it on the target
    string. The interesting part is that any character that is mapped to `None` will
    be just removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In our previous example, we provided as `str.maketrans` the third argument `string.punctuation`.
  prefs: []
  type: TYPE_NORMAL
- en: '`string.punctuation` is a string that contains the most common punctuation
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, we built a transaction map that mapped each punctuation character
    to `None` and didn''t specify any other mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This, once applied with `str.translate`, made it so that punctuation characters
    were all discarded, preserving all the other characters as they were:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Normalizing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, a single word can be written in multiple ways. For example, users
    who wrote "Über" and "Uber" probably meant the same word. If you were implementing
    a feature like tagging for a blog, you certainly don't want to end up with two
    different tags for the two words.
  prefs: []
  type: TYPE_NORMAL
- en: So, before saving your tags, you might want to normalize them to plain ASCII
    characters so that they end up all being considered as the same tag.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we need is a translation map that converts all accented characters to
    their plain representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can apply it to any word to normalize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know as explained in the *Cleanup text* recipe how `str.translate` works:
    each character is looked up in a translation table and it’s substituted with the
    replacement specified in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what we need is a translation table that maps `"Ü"` to `"U"` and `"ç"` to `"c"`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we know all these mappings? One interesting property of these characters
    is that they can be considered plain characters with an added symbol. Much like
    `à` can be considered an `a` with an accent.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode equivalence knows this and provides multiple ways to write what's considered
    the same character. What we are really interested in is decomposed form, which
    means to write a character as multiple separated symbols that define it. For example, `é`
    would be decomposed to `0065` and `0301`, which are the code points for `e` and
    the accent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides a way to know the decomposed version of a character through
    the `unicodedata.decompostion` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first code point is the one of the base character, while the second is
    the added symbol. So to normalize our `è`, we would pick the first code point
    `0065` and throw away the symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now we can't use the code point by itself, but we want the character it represents.
    Luckily, the `chr` function provides a way to get a character from the integer
    representation of its code point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unicodedata.decomposition` function provided the code points as strings
    representing hexadecimal numbers, so first we need to convert them to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can apply `chr` to know the actual character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to decompose these characters and get the base characters to
    which we want to normalize them all, but how can we build a translation map for
    all of them?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is we don't. Building the translation map beforehand for all characters
    wouldn't be very convenient, so we can use a feature provided by dictionaries
    to build the translation for a character dynamically when it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: Translation maps are dictionaries and whenever a dictionary needs to look up
    a key that it doesn't know, it can rely on the `__missing__` method to generate
    a value for that key. So our `__missing__` method has to do what we just did and
    use `unicodedata.decomposition` to grab the normalized version of a character
    whenever `str.translate` tries to look it up in our translation map.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have computed the translation for the requested character, we just store
    it in the dictionary itself, so the next time it will be asked for, we won't have
    to compute it again.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `unaccented_map` of our recipe is just a dictionary providing a `__missing__`
    method that relies on `unicodedata.decompostion` to retrieve the normalized version
    of each provided character.
  prefs: []
  type: TYPE_NORMAL
- en: If it is unable to find a denormalized version of the character, it will just
    return the original version once so that the string doesn't get corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When printing tabular data, it's usually very important to ensure that the text
    is properly aligned to a fixed length, no longer and no shorter than the space
    we reserved for our table cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the text is too short, the next column might start too early; if it''s too
    long, it might start too late. This leads to results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both of these are really hard to read and are far from showing a proper table.
  prefs: []
  type: TYPE_NORMAL
- en: Given a fixed column width (20 characters), we want our text to always be of
    that exact length so that it won't result in a misaligned table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textwrap` module once combined with the features of the `str` object can
    help us achieve the expected result. First we need the content of the columns
    we want to print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to fix the size of a column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those are ready, we can actually implement our indentation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can properly print any table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three problems we have to solve to implement our `maketable` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Lengthen text shorter than 20 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split text longer than 20 characters on multiple lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill missing lines in columns with fewer lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we decompose our `maketable` function, the first thing it does is to split
    text longer than 20 characters into multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That applied to each column leads us to having a list of columns, each containing
    a list of rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to ensure that each row shorter than 20 characters is extended
    to be exactly 20 characters, so that our table retains shape, and that''s achieved
    by applying the `ljust` method to each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining `ljust` with `textwrap` leads to the result we were looking for:
    a list of columns containing rows of 20 characters each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to find a way to flip rows and columns, as when printing we need
    to print by row due to the `print` function printing one row at a time. Also,
    we need to ensure that each column has the same amount of rows, as we need to
    print all the rows when printing by row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both these needs can be solved by the `itertools.zip_longest` function, which
    will generate a new list by interleaving the values contained in each one of the
    provided lists until the longest list is exhausted. As `zip_longest` goes on until
    the longest iterable is exhausted, it supports a `fillvalue` argument that can
    be used to specify a value used to fill values for shorter lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a list of rows, each containing a column, with empty columns
    for rows that didn''t have a value for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The tabular form of the text is now clearly visible. The last two steps in
    our function involve adding a `|` separator between the columns and merging the
    columns in a single string through `'' | ''.join`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a list of strings containing the text of all three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the rows can be printed. For the purpose of returning a single string,
    our function applies one last step and joins all the lines in a single string
    separated by newline characters by applying a final `''n''.join()`, which leads
    to returning a single string containing the whole text ready for printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
