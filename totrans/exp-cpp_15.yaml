- en: Debugging and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and testing take an extremely important role in the pipeline of the
    software development process. Testing helps us to find problems while debugging
    fixes them. However, if we follow certain rules during the implementation stage,
    lots of potential defects can be prevented. Additionally, since a test process
    is very costly, it would be great if we could automatically analyze software by
    using certain tools before human testing is required. Moreover, when, how, and
    what we should test regarding software is also important.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the root cause of an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging C++ programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding static and dynamic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring unit testing, TDD, and BDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will learn how to analyze a software defect, how
    to use a **GNU Debugger** (**GDB**) tool to debug a program, and how to use tools
    to automatically analyze software. We will also learn about the concepts of **unit
    testing**, **test-driven development** (**TDD**), and **behavior-driven development**
    (**BDD**), as well as how to practice using them during the software engineering
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the root cause of an issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In medicine, a good doctor needs to understand the difference between treating
    the symptoms and curing the condition. For example, giving painkillers to a patient
    with a broken arm will only take away the symptoms; surgery is probably the right
    way to help bones heal gradually.
  prefs: []
  type: TYPE_NORMAL
- en: '**Root Cause Analysis** (**RCA**) is a systematic process that''s used to identify
    the fundamental cause of a problem. With the help of associated proper tools,
    it tries to identify the origin of the primary cause of the problem using a specific
    set of steps. By doing so, we can determine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What happened?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How did it happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why did it happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What proper approach would be used to prevent or reduce it so that it never
    happens again?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RCA assumes that an action in one place triggers another action in another place,
    and so on. By tracing the action chain back to the beginning, we can discover
    the source of the problem and how it grows into the symptom we have. Aha! This
    is exactly the process we should follow to fix or reduce software defects. In
    the following subsections, we will learn about the basic RCA steps, how to apply
    the RCA process to detect software defects, and what certain rules a C++ developer
    should follow to prevent such defects from occurring in software.
  prefs: []
  type: TYPE_NORMAL
- en: The RCA overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, an RCA process contains the following five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the problem**: In this stage, we may find answers to the following
    questions: what is happening? What are the symptoms of the problem? In what environment
    or conditions is the problem happening in/under?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Collect data**: To make a cause factor chart, we need to collect enough data.
    This step may be expensive and time-consuming.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Make a causal factor chart**: A causal factor chart provides a visualization
    structure that we can use to organize and analyze the collected data. The causal
    factor chart is nothing but a sequence diagram with logic tests that explains
    the events leading up to the occurrence of a symptom. This charting process should
    drive the data collection process until the investigators are satisfied with the
    thoroughness of the chart.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify the root causes**: By examining the causal factor chart, we can
    make a decision diagram known as the **root cause map** to identify the cause
    or causes of the root.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Recommend and implement solutions**: Once a root cause or multi-causes have
    been identified, the answers to the following questions can help us to find a
    solution: What can we do to prevent the problem from happening again? How will
    a solution be implemented? Who will be responsible for it? What are the costs
    or risks of implementing the solution?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An RCA tree diagram is one of the most popular factor diagrams used in the
    software engineering industry. The following is an example structure of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9263dd4-03a3-4449-90b4-6e7d6d187b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's assume we have a problem that has **A**, **B**, and **C** symptoms. Symptom
    **A** can be caused by events **A1** or **A2**, symptom **B** can be caused by
    either event **B1** and **B2** or **B3** and **B4**, and symptom **C** is caused
    by events **C1** and **C2**. After data collection, we found that symptoms **A**
    and **C** never appeared and that we only have symptom **B**. Further analysis
    shows that events **B1** and **B2** are not involved when the problem occurs,
    so we can identify that the root cause of this problem is happening because of
    events **B3** or **B4**.
  prefs: []
  type: TYPE_NORMAL
- en: If the software has a defect, instead of just fixing it at the failing point,
    we should apply RCA to it and investigate the original fundamental root cause(s)
    of the problem. Then, the root cause(s) of the problem can be traced back to the
    requirements, the design, the implementation, the verification, and/or the test
    planning and input data. When the issues at the root are found and fixed, the
    quality of the software can be improved and hence the maintenance expenses will
    be drastically reduced.
  prefs: []
  type: TYPE_NORMAL
- en: We have just learned how to find the root cause of a problem, but remember that
    *the best defense is a good offense*. So, instead of analyzing and fixing a problem,
    what if we can prevent it from happening?
  prefs: []
  type: TYPE_NORMAL
- en: Prevention is better than the cure – a good coding behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a cost point of view, an IBM study has shown that assuming the overall
    cost of the requirements and design is 1X, then the implementation and coding
    process will take 5X, the unit and integration tests will take about 10X, comprehensive
    customer beta test costs will take about ~15X, and the costs to fix bugs in post-product
    release occupies about 30X! Therefore, minimizing code defects is one of the most
    effective ways to keep production costs down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the generic methodology of finding the root causes of software defects
    is very important, it would be even better if we could prevent some defects at
    the implementation stage. To do that, we need to have good coding behavior, which
    means that certain rules must be followed.  These rules can be classified at low
    and high levels. The low-level rules may include the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer divisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mistakenly using  `=`  instead of  `==`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially assign a signed variable to an unsigned variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing `break` in `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects in compound expressions or function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to the high-level rules, we have topics related to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B. Stroustrup and H. Sutter have suggested following these rules in their live
    document, *C++ Core Guidelines (Release 0.8)*, where static type safety and resource
    safety are emphasized. They also emphasize the possibilities of range checking
    in order to avoid dereferencing null-ptr, dangling pointers, and the systematic
    use of exceptions. If a developer follows such rules, it will lead to his/her
    code being statically type-safe without any resource leaks. Additionally, it will
    not only catch many more programming logic errors, but it will also run faster.
  prefs: []
  type: TYPE_NORMAL
- en: Because of page limitations, we will only look at a few examples of this in
    this subsection. If you want to look at more examples, please go to [https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines).
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized variable problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An uninitialized variable is one of the most common mistakes a programmer can
    make. When we declare a variable, a certain amount of continuous memory will be
    allocated to it. If it is not initialized, it still has some value, but there
    is no deterministic way of predicting it. Consequently, unpredictable behavior
    shows up when we execute the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when `x` is declared, the OS will assign 4 bytes of unused
    memory to it, which means that the value of `x` is whatever value was residing
    in that memory. Each time we run this program, both the address and value of `x`
    might be different. Additionally, some compilers, such as Visual Studio, will
    initialize the value of `x` as `0` in the debug version but keep it uninitialized
    in the release version. In that case, we have a totally different output in the
    debug and release versions.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects in compound expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an operator, expression, statement, or function has finished being evaluated,
    it may be prolonged or may continuously exist inside its compound. This continuous
    existence has some side effects that may lead to some undefined behaviors. Let''s
    have a look at the following code to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Because of the undefined behavior of the evaluation order of operands, the result
    of the preceding code could be either 16 or 12.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing signed and unsigned problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, binary operators (`+`,`-`, `*`, `/`, `%`, `<`, `<=`,`>`, `>=`, `==`,
    `!=`, `&&`, `||`, `!`,  `&`, `|`, `<<`, `>>`, `~`, `^`, `=`, `+=`, `-=`, `*=`,
    `/=`, and `%=`) require both side operands to be of the same type. If the two
    operands are of different types, one will be promoted to the same type as the
    other. Roughly speaking, there are three C standard conversion rules given in
    subclause 6.3.1.1 [ISO/IEC 9899:2011]:'
  prefs: []
  type: TYPE_NORMAL
- en: When we mix types of the same rank, the signed one will be promoted to an unsigned
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we mix types of a different rank, the lower-ranked one will be promoted
    to the higher-ranked type if all the values of the lower-ranked side can be represented
    by the higher-ranked side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all the values of the lower-ranked type cannot be represented by the higher-ranked
    type in the preceding case , then the unsigned version of the higher-ranked type
    will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the traditional signed integer minus unsigned integer
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the signed `int` will be automatically converted into
    an unsigned `int` and the result will be `uint32_t z` = `-10`. On the other hand,
    because `−10` cannot be represented as an unsigned `int` value, its hexadecimal
    value, `0xFFFFFFF6`, will be interpreted as `UINT_MAX - 9` ( that is, `4294967286`)
    on two's complement machines.
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example is concerned with the initialization order of class members
    in a constructor. Since the initialization order is the order the class members
    appear in the class definition, it''s good practice to separate the declaration
    of each member into different lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In class `A`, although the declaring order is `v1 -> v2`,  putting them in one
    line confuses other developers. In the first constructor of class `B`, `v1` will
    be initialized as `x`, then `v2` will be initialized as `v1` because its declaration
    order is `v1->v2`. However, in its second constructor, `v1` will be initialized
    as `v2` first (at this point, `v2` is not initialized yet!), then `v2` will be
    initialized by `x`. This causes the different output values of `v1` in debug and
    release versions.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time checking versus runtime checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows that runtime checking (number of bits for an integer
    type variable cloud) can be replaced by compile-time checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `int` can be either 16 or 32 bits, depending on the operating system,
    this example fails to achieve what it is trying to achieve. We should use `int32_t`
    or just replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is concerned with reading the max number of `n` integers into
    a one-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be fixed using `span<int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The general rule here is to do the analysis at compile-time as much as possible
    and to not postpone it until runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A memory leak means that the allocated dynamic memory can never be freed. In
    C, we use `malloc()` and/or `calloc()`  to allocate memory and `free()` to release
    it. In C++, the `new` operator and the `delete` or `delete []` operators are used
    to manage memory dynamically. Although the risks of memory leak can be reduced
    with the help of smart pointers and **Resource Acquisition Is Initialization**
    (**RAII**), there are still some rules we need to follow if we wish to build high-quality
    code.
  prefs: []
  type: TYPE_NORMAL
- en: First, the easiest memory management way is the memory you never allocated by
    your own code. For example, whenever you can write `T x;`, don't write `T* x =
    new T();` or `shared_ptr<T> x(new T() );`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, do not manage the memory using your own code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, try to use RAII, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use `unique_ptr` to replace `shared_ptr` unless you need to share its
    ownership, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `b` is locally used without copying it, its `refcount` will be always
    `1`. This means we can use a `unique_ptr` to replace it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, even if you really need to dynamically manage the memory by yourself,
    don't manually allocate the memory if there is an `std container` library class
    available.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to locate a problem using RCA and how to prevent
    a problem by coding best practices. Next, we'll learn how to use a debugger tool
    to control the line-by-line execution of a program and examine the values of variables
    and expressions during its running time.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging C++ programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of finding and resolving the problems or defects of
    a program. This may include interactive debugging, data/control flow analysis,
    and unit and integration testing. In this section, we will only focus on interactive
    debugging, which is the process of executing your source code line-by-line with
    breakpoints, all while showing the values of the variables being used and their
    corresponding memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Tools to debug a C/C++ program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your development environment, there are lots of tools available
    in the C++ community. The following list shows the most popular ones on different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux/Unix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB**: A free open source **Command-Line Interface** (**CLI**) debugger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse**: A free open source **Integrated Development Environment** (**IDE**).
    It supports not only debugging but also compiling, profiling, and smart editing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valgrind**: Another open source dynamic analysis tool; it is good for debugging
    memory leaks and threading bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affinic**: A commercial **Graphic User Interface** (**GUI**) tool built for
    the **GDB**,  **LLDB**, and **LLVM debugger**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DDD** : An open source data display debugger for **GDB**, **DBX**, **JDB**,
    **XDB,** and **Python**, it displays data structures as graphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB in Emacs mode**: An open source GUI tool that uses GNU Emacs to view
    and edit source code when debugging with GDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KDevelop**: A free and open source IDE and debugger tool for programming
    languages such as C/C++, Objective-, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nemiver**: An open source tool that works well in the **GNOME** desktop environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SlickEdit**: A good tool for debugging multithreaded and multiprocessor code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio**: A commercial tool with GUI that''s free for community versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB**: This can run in Windows as well with the help of **Cygwin** or **MinGW**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse**: Its **C++ Development Tooling** (**CDT**) can be installed on
    Windows with the MinGW GCC compiler in the toolchains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLDB**: This is the default debugger in **Xcode** on macOS and supports C/C++
    and Objective-C on desktop and iOS devices and their simulators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB**: This CLI debugger is also used on macOS and iOS systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse**: This free IDE using GCC works for macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since GDB can be run on all platforms, we will show you how to use GDB in the
    following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: GDB overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GDB stands for GNU debugger, which allows a developer to see *what is going
    on inside another program while it executes, or what another program was doing
    at the moment it crashed*. GDB can do the following four main things:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a program and specify anything that might affect its behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a program stop on given conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine what happened when a program stopped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the values of variables while running a program. This means we can experiment
    with something to correct the effects of one bug and/or go on to learn the side
    effects of another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that two programs or executable files are involved: one is GDB, while
    the other is the program to be debugged. Since these two programs can run either
    on the same machine or different ones, we may have three categories of debugging,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native debugging**: Both programs run on the same machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote debugging**: GDB  runs on a host machine, while the debugged program
    runs on a remote machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulator debugging**: GDB runs on a host machine, while the debugged program
    runs on a simulator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the latest release (GDB v8.3) at the time of writing this book, the
    languages supported by GDB including C, C++, Objective-C, Ada, Assembly, D, Fortran,
    Go, OpenCL, Modula-2, Pascal, and Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Since GDB is a state-of-the-art tool in the debugging industry and is complex
    and has lots of functions, it won't be possible to learn about all its features
    in this section. Instead, we will study the most useful features by looking at
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before practicing these examples, we need to check if `gdb` has been installed
    on our system by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the following kind of information is displayed,  we will be ready to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we need to install it. Let''s go over how we can install it on the
    different operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For Redhat-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Windows users can install GDB through MinGW distributes. macOS will need a taskgated
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Then, type `gdb --help` again to check if it was successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting breakpoints and inspection variable values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we will learn how to set breakpoints, continue, step
    into or step over a function, print values of variables, and how to use help in
    `gdb`. The source code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml),
    *Details of Object-Oriented Programming, *let''s build this program in debug mode,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for g++, the `-g` option means the debugging information will be
    included in the output binary file. If we run this program, it will show the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use `gdb` to see where the bug is. To do that, we need to execute
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the various commands in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break` and `run`: If we type `b main` or `break main` and press *Enter*, a
    `breakpoint` will be inserted at the main function. Then, we can type `run` or
    `r` to start debugging the program. The following information will be shown in
    a Terminal window. Here, we can see that our first `breakpoint` is at the sixth
    line in the source code and that the debugged program has been paused in order
    to wait for a new command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`next`, `print`, and `quit`:The `n` or`next`commandwill go to the next line
    of the code. If the line calls a subroutine, it does not enter the subroutine;
    instead, it steps over the call and treats it as a single source line. If we want
    to show the value of a variable, we can use the `p` or `print` command, followed
    by the variable''s name.  Finally, if we want to exit from `gdb`, the `q` or `quit` command
    can be used. Here is the output from the Terminal window after running these operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`step`: Now let''s learn how to step into the `multiple()` function and find
    the bug. To do that, we need to start over by using the `b`, `r`, and `n` command
    to reach line 7 first. Then, we can use the `s` or `step` command to step into
    the `multiple()` function. Next, we use the `n` command to reach line 14 and `p`
    to print the value of the `ret` variable, which is 30\. At this point, we''ve
    figured out that by using `ahha the bug is at line 14!:`, instead of `x*y`, we
    have a typo, that is, `x+y`. The following code block is the corresponding outputs
    from these commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`help`: Lastly, let''s learn about the `help` command to end this small example.
    When `gdb` is launched, we can use the `help` or `h` command to get the usage
    information of a particular command in its command input line. For instance, the
    following Terminal window summarizes what have we learned so far:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have learned about a few basic commands we can use to debug
    a program. These commands are `break`, `run`, `next`, `print`, `quit`, `step`,
    and `help`. We will learn about function and conditional breakpoints, watchpoint,
    and the `continue` and `finish` commands in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Function breakpoints, conditional breakpoints,  watchpoint, and the continue
    and finish commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will learn how to set function breakpoints, conditional
    breakpoints, and use the `continue` command. Then, we will learn how to finish
    a function call without the need to execute all the code lines in a step by step
    format. The source code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, after building and running `ch13_gdb_2.cpp`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since both `dot(x,x)` and `dot(x,y)` give us the same results, something must
    be wrong here. Now, let''s debug it by learning how to set a breakpoint in the `dot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function breakpoint**: To set a breakpoint at the beginning of a function,
    we can use the `b function_name` command. As always, we can use tab completion
    during input. For instance, let''s say we type the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command line will automatically pop up if we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a member function of a class, its class name should be included, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Conditional breakpoint**: There are several ways to set a conditional breakpoint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**List and delete breakpoints**: Once we''ve set a few breakpoints, we can
    list or delete them, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Remove make** **a breakpoint** **unconditional**: Since each breakpoint has
    a number, we can remove a condition from a breakpoint, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Watchpoint**: A watchpoint can stop execution when the value of an expression
    changes, without having to predict where (in which line) it may happen. There
    are three kinds of watchpoints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watch`: `gdb` will break when a write occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwatch`: `gdb` will break when a read occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awatch`: `gdb` will break when either a write or a read happens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**continue**: When we''ve finished examining the values of variables at a breakpoint,
    we can use the `continue` or `c` command to continue program execution until the
    debugger encounters a breakpoint, a signal, an error, or normal process termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**finish**: Once we go inside a function, we may want to execute it continuously
    until it returns to its caller line. This can be done using the `finish` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s put these commands together to debug `ch13_gdb_2.cpp`.The following
    is the output from our Terminal window. For your convenience, we''ve separated
    it into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In part one, we have the following six commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd 1`: We start `gdb` with the parameter of the built executable file, `ch13_gdb_2.out`.
    This briefly shows us its version and document and usage information, and then
    tells us that the reading symbols process has been completed and is waiting for
    the next command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 2`:  We set a `breakpoint` function (at `dotproduct()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 3`: A conditional `breakpoint` is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 4`: It lists information about the breakpoints and tells us that we have
    two of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 5`: We set `breakpoint 2` as `unconditional`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 6`: We list the breakpoint information again. At this point, we can see
    two breakpoints. These are located at lines 20 and 24 in the `ch13_gdb_2.cp` file,
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `gdb` output in part two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Part two has the following cmds:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd 7`: By giving the `run` command, the program starts running and stops
    at the first breakpoint in line 20.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 8`: We print the value of `x`, whichshows its address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 9`: We continue the program.  Once it''s been continued, it stops at the
    second breakpoint in line 24.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 10`: The value of `i` is printed, which is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 11-12`: We use the `next` command twice. At this point, the `s += (*p) 
    *  (*q)` statement is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 13`:  The value of `s` is printed, which is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 14`:  We print the value of `s` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, part three is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part, we have the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd 15`: We use the `next` command to see what the value of `s` is if the
    next iteration is executed. It shows that the old value of`s` is `1` (s = 1*1)
    and that the new value is `5` (s=1*1+2*2). So far, so good!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 16`: A `finish` command is used to continue running the program until
    it exits from the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 17`:  We delete breakpoints 1  to 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 18`: A `continue` command is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 19`: We quit `gdb` and go back to the Terminal window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging gdb into a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with a long stack trace or multi-thread stack trace, viewing and
    analyzing `gdb` output from a Terminal window can be inconvenient. However, we
    can log either an entire session or specific output into a text file first, then
    browse it offline later using other text editor tools. To do this, we need to
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this command, `gdb` will save all the Terminal window outputs
    into a text file named `gdb.txt` in the currently running `gdb` folder.  If we
    want to stop logging, we can just type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: One great thing about GDB is that we can turn set logging commands on and off
    as many times as we want, without worrying about the dumped file names. This is
    because all the outputs are concatenated into the `gdb.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of returning `ch13_gdb_2.out` with the `gdb` output being
    dumped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands that were used in the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd 1`:  `gdb` is launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 2`:  We set the logging flag to on. At this point, `gdb` says the output
    will be copied into the `gdb.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 3`:  A conditional `break point` is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 4`: We run the program, and it stops when it reaches the conditional `breakpoint`
    at line 24.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 5`and `cmd 6`: We print the values of `i` and `s`, receptively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 7`: By executing the step out of the function command, it shows that `sxx`
    is `55` (after calling `sxx=dotproduct( x, x, 5))`) and that the program stops
    at line `sxy *=* dotproduct( x, y, 5).`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 8`: We delete `breakpoint 1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 9`: We set the logging flag to off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 10`: Once a continue instruction is given, it runs out of the `main` function
    and `gdb` waits for a new command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 11`:  We input `q ` to quit `gdb`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd 12`: When it goes back to the Terminal window, we print the content of
    the logged `gdb.txt` file by running the `cat` command in the OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have learned enough GDB commands to debug a program. As you may have
    noticed, it's time-consuming and thus very costly. Sometimes, it becomes even
    worse because of debugging in the wrong places. To debug efficiently, we need
    to follow the right strategies. We will cover this in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Practical debugging strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since debugging is the costliest stage in the software development life cycle,
    finding bugs and fixing them isn''t feasible, especially for large, complex systems.
    However, there are certain strategies that can be used in practical processes,
    some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use printf() or std::cout**: This is the old-fashioned way of doing things.
    By printing some information to the Terminal, we can check the values of variables
    and perform where and when kinds of log profiles for further analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a debugger**: Although learning to use a GDB kind of debugger tool is
    not an overnight thing, it can save lots of time. So, try to become familiar with
    it step by step and gradually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reproduce bugs**: Whenever a bug is reported in the field, make a record
    of the running environment and input data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dump log files**: An application program should dump log messages into a
    text file.  When a crash happens, we should check the log files as the first step
    to see if an abnormal event occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Have a guess**: Roughly guess a bug''s location and then prove whether it
    was right or wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide and conquer**: Even in the worst scenario that we do not have any
    idea of what bugs there are, we still can use **the binary search** strategy to
    set breakpoints and then narrow down and eventually locate them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify**: Always start from the most simplified scenario and gradually
    add peripherals, input modules, and so on until the bug can be reproduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code version controlled**: If a bug has suddenly appeared on a release
    but it had run fine previously, do a source code tree check first. Someone may
    have made a change!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t give up**: Some bugs are really hard to locate and/or fix, especially
    for complex and multi-team involved systems. Put them aside for a while and rethink
    it on your way home – the *aha moment* may reveal itself eventually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have learned about macro-level problem localization using RCA and
    the good coding practices we can follow to prevent problems from occurring. Furthermore,
    by using a state-of-the-art debugger tool such as GDB, we can control the execution
    of a program line by line so that we can analyze and fix the problem at the micro
    level. All these activities are programmer centralized and manual.  Can any automatic
    tools help us diagnose the potential defects of a program? We'll take a look at
    static and dynamic analysis in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static and dynamic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned about the root cause analysis process and
    how to use GDB to debug a defect. This section will discuss how to analyze a program
    with and without executing it. The former is called dynamic analysis, while the
    latter is called static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis evaluates the quality of a computer program without executing
    it. Although this can usually be done by examining source code via automatic tools
    and code reviews/inspections, we will only focus on automatic tools in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automatic static code analysis tools are designed to analyze a set of code
    against one or multiple sets of coding rules or guidelines. Normally, people use
    static code analysis*,* static analysis, or source code analysis interchangeably.
    By scanning the entire code base with every possible code execution path, we can
    find lots of potential bugs before the testing phases. However, it also has several
    limitations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It can produce false positive and false negative alarms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only applies the rules that were implemented inside the scanning algorithm,
    and some of them may be subjectively interpreted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot find vulnerabilities that were introduced in a runtime environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can provide a false sense of security that everything is being addressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are about 30 automatic C/C++ code analysis tools [9] under both commercial
    and free open source categories. The names of these tools include Clang, Clion,
    CppCheck, Eclipse, Visual Studio, and GNU g++, just to name a few. As examples,
    we would like to introduce the `**-**Wall`,  `-Weffcc++`, and `-Wextra` options,
    which are built into GNU compiler g++[10]:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wall`: This enables all construction warnings, which are questionable for
    some users. These warnings are easy to avoid or modify, even in conjunction with
    macros. It also enables some language-specific warnings described in C ++ Dialect
    Options and Objective-C/C ++ Dialect Options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wextra`: As its name implies, it examines certain extra warning flags that
    are not checked by `-Wall`. Warning messages for any of the following cases will
    be printed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer is compared against integer zero with the `<`, `<=`, `>`, or `>=`
    operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-enumerator and an enumerator show up in a conditional expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguous virtual bases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscripting a `register` type array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the address of a `register` type variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A derived class' copy constructor does not initialize its base class. Note that
    (b)-(f) are C++ only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Weffc++`:  It checks the violations of some guidelines suggested in *Effective
    and More Effective C++*, written by Scott Meyers.  These guidelines include the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a copy constructor and an assignment operator for classes with dynamically
    allocated memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer initialization over assignment in constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make destructors virtual in base classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the `=` operator return a reference to `*this`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't try to return a reference when you must return an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguish between prefix and postfix forms of increment and decrement operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never overload `&&`, `||`, or `,`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explore these three options, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s build this without any options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This can be built successfully, but if we run it, as expected, it will crash
    with a **segmentation fault** (**core dumped**) message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the `-Wall`,`-Weffc++`,and`-Wextra`options and rebuild it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `-Wall` and `-Weffc++` give us the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, it's complaining that, in the `int & getVal()` function (line 9 of the
    `cpp` file), a reference to a local variable is returned. This will not work because
    once the program goes out of the function, `x` is garbage (The lifetime of `x` is
    only limited in the scope of the function). It does not make any sense to reference
    a dead variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wextra` gives us the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that `*-*Wextra` not only gives us the warning from
    `-Wall` but also checks the six things we mentioned earlier. In this example,
    it warns us that there is a comparison between a pointer and integer zero in line
    16 of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about how to use the static analysis options during compile
    time, we'll take a look at dynamic analysis by executing a program.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dynamic analysis* is a short version of *dynamic program analysis*, which
    analyzes the performance of a software program by executing it either on a real
    or virtual processor. Similar to static analysis, dynamic analysis can also be
    done automatically or manually. For instance, unit tests, integration tests, system
    tests, and acceptance tests are typically human-involved dynamic analysis processes.
    On the other hand, memory debugging, memory leak detection, and profiling tools
    such as IBM purify, Valgrind, and Clang sanitizers are automatic dynamic analysis
    tools. We will focus on automatic dynamic analysis tools in this subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A  dynamic analysis process contains steps such as preparing the input data,
    launching a test program, gathering the necessary parameters, and analyzing its
    output. Roughly speaking, the mechanism of dynamic analysis tools is that they
    use code instrumentation and/or a simulation environment to perform checks on
    the analyzed code as it executes. We can interact with a program in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code instrumentation**: A special code segment is inserted into the
    original source code before compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object code instrumentation**: A special binary code is added directly into
    the executable file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compilation stage instrumentation**: A checking code is added through special
    compiler switches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't change the source code. Instead, it uses special execution stage
    libraries to detect errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic analysis has the following pros:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no false positive or false negative results because an error will
    be detected that isn't predicted from a model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not need source code, which means the proprietary code can be tested
    by a third-party organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of dynamic analysis are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It only detects defects on the routes related to the input data. Other defects
    may not be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can only check one execution path at a time. To obtain a complete picture,
    we need to run the test as many times as possible. This requires a significant
    amount of computational resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot check the correctness of the code. It is possible to get the correct
    result from the wrong operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing incorrect code on a real processor may have unanticipated results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s use Valgrind to find the memory leak and out-of-boundary problems
    given in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Valgrind for dynamic analysis, the following steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install `valgrind`. We can do this using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has been installed successfully, we can run `valgrind` by passing the
    executable as an argument, along with other parameters, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build this program, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we run `valgrind`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can check the contents of `log.txt`. The bold and italic lines
    indicate the memory leak''s location and size. By checking the address (`0x4844BFC`)
    and its corresponding function name (`main()`), we can see that this `malloc`
    is in the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `malloc()` is called to allocate some memory at address
    `0x4844BFC`. The heap summary section indicates that we have 40 bytes of memory
    loss at `0x4844BFC`. Finally, the leak summary section shows that there is definitely
    one block of 40 bytes memory loss. By searching the address value of `0x4844BFC`
    in the `log.txt` file, we eventually figured out that there is no `free(p)` line
    being called in the original code. After uncommenting this line, we redo the `valgrind`
    analysis so that the leakage problem is now out of the report.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, with the help of static and dynamic analysis tools, the potential
    defects of a program can be greatly reduced automatically. However, to ensure
    the quality of software, humans must be in the loop for final tests and evaluations.
    Now, we're going to explore the unit testing, test-driven development, and behavior-driven
    development concepts in software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring unit testing, TDD, and BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about automatic static and dynamic program analysis in the previous
    section. This section will focus on human-involved (preparing test code) tests,
    which are another part of dynamic analysis. These are unit testing, test-driven
    development, and behavior-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing assumes that if we already have a single unit of code, then we
    need to write a test driver and prepare input data to check if its output is correct.
    After that, we perform integration tests to test multiple units together, and
    then the acceptance tests, which test the entire application. Since the integration
    and acceptance tests are more difficult to maintain and more project-related than
    unit tests, it is very challenging to cover them in this book. Those of you who
    are interested can find out more by going to [https://www.iso.org/standard/45142.html](https://www.iso.org/standard/45142.html).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to unit tests, TDD believes that we should have test code and data
    first, develop some code and make it pass quickly, and finally refactor until
    the customer is happy. On the other hand, BDD has the philosophy that we should
    not test the implementation of a program and instead test its desired behavior.
    To this end, BDD emphasizes that a communication platform and language among people
    involved in software production should be set up as well.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss each of these methodologies in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unit is an individual component in a larger or more complex application.
    Typically, a unit has its own user interface, such as a function, a class, or
    an entire module. Unit testing is a software testing method that''s used to determine
    whether a unit of code behaves as expected in terms of its design requirements.
    The main features of unit testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is small and simple, quick to write and run, and, as a result, it finds problems
    in the early development cycle and hence the problems can be fixed easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it is isolated from dependencies, each test case can be run in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test drivers help us understand the unit interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It greatly helps integration and acceptance tests when tested units are integrated
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is normally prepared and performed by developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we can write a unit test package from scratch, there are a lot of **Unit
    Test Frameworks** (**UTFs**) already being developed in the community. Boost.Test,
    CppUnit, GoogleTest, Unit++, and CxxTest are the most popular ones. These UTFs
    typically offer the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: They only require a minimal amount of work for setting up a new test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They depend on standard libraries and supports cross-platform, which means they
    are easy to port and modify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support test fixtures, which allow us to reuse the same configuration for
    objects for several different tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They handle exceptions and crashes well. This means that a UTF can report exceptions
    but not crashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have good assert functionalities. Whenever an assertion fails, its source
    code location and the values of the variables should be printed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support different outputs and these outputs can be conveniently analyzed
    either by humans or other tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support test suites, and each suite may contain several test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at an example of Boost UTF (since v1.59.0).  It supports
    three different usage variants: the single-header only variant, the static library
    variant, and the shared library variant. It includes four types of test cases:
    test cases without parameters, data-driven test cases, template test cases, and
    parameterized test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It also has seven types of check tools: `BOOST_TEST()`, `BOOST_CHECK()`, `BOOST_REQUIRE(`),
    `BOOST_ERROR()`, `BOOST_FAIL()`, `BOOST_CHECK_MESSAGE( )`, and `BOOST_CHECK_EQUAL()`.
    It supports fixtures and controls the test output in many ways as well. When writing
    a test module, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the name of our test program. This will be used in output messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose a usage variant: header-only, link with a static, or as a shared library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose and add a test case to a test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform correctness checks on the tested code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the code under test before each test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customize the ways in which test failures are reported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control the runtime behavior of the built test module, which is also called
    runtime configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the following example  covers *steps 1-4*. If you are interested,
    you can get examples of *steps 5-7* at [https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To build this, we may need to install boost, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can build and run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that there are failures in `test_case1`  and `test_case3`.
    In particular, in `test_case1`, the value of `x` is not equal to `b`, and obviously
    a false check cannot pass the test in `test_case3`.
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, a TDD process starts by writing failing
    test code and then adds/modifies the code to let the test pass. After that, we
    refactorize the test plan and code until all the requirements are satisfied [16,17].
    Let''s have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48d849fe-1729-4c98-8497-c0500b7f3080.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 1* is to write a failing test. Instead of developing code first, TDD
    starts to write test code initially. Because we do not have code yet, we know
    that, if we run the test, it will fail. During this stage, the test data format
    and interface is defined, and the code implementation details are imagined.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of *step 2* is to make the test pass as quickly as possible with minimal
    development effort. We don't want to implement everything perfectly; we only want
    it to pass the test. Once it goes green, we will have something to show and tell
    to the customer, at which point the customer may refine the requirement after
    seeing the initial product. Then, we move on to the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: The third phase is refactoring. During this stage, we may go in, look at, and
    see what we would like to change and how to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To traditional developers, the most difficult thing about TDD is the mindset
    change from the coding -> testing pattern to the testing -> coding pattern. To
    get a vague idea of a test suite, J. Hartikainen suggested that a developer considers
    the following five steps[18] to start:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide the inputs and outputs first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose class/function signatures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide only one tiny aspect of the functionality to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we've finished this iteration, we can gradually refactor it until the overall
    comprehensive goal is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Example of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will demonstrate the TDD process through the implementation of a case
    study. In this study, we will develop a Mat class to perform 2D matrix algebra,
    just like we do in the Matlab. This is a class template that can hold an m-by-n
    matrix for all data types. The matrix algebra includes adding, subtracting, multiplying,
    and dividing matrices, and it also has element operation abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – writing a failing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we will only need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Mat` object from a given a number of rows and cols (the default should
    be 0-by-0, which is an empty matrix).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print its elements row by row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the matrix size from `rows()` and `cols()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these requirements, we can have failing unit testing code to boost
    UTF, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that our testing code is ready, we are ready to develop the code.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – developing code to let the test pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to implement a minimal code segment is to pass the preceding test,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the preceding header file, we can develop its corresponding `cpp`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we build and execute it using g++, which supports `-std=c++11` or
    higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In `test_case1`, we created three matrices and tested the `rows()`, `cols()`,
    and `print()` functions. The first one is a 2x3 `int` type matrix. Since it is
    not initialized, the values of its elements are unpredictable, which is why we
    can see these random numbers from `print()`. We also passed the `rows()` and `cols()`
    test at this point (no errors from the two `BOOST_TEST() calls`). The second one
    is an empty float type matrix; its `print()` function gives nothing, and both
    its `cols()` and `rows()` are zeros. Finally, the third one is a 1x10 `char` type
    uninitialized matrix. Again, all the outputs of the three functions are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, so good – we passed the test!  However, after showing the preceding
    result to our customer, he/she may ask us to add two more interfaces, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an m x n matrix with a given initial value for all elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `numel()` to return the total number of elements of the matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `empty()`, which returns true if the matrix either has zero rows or zero
    columns and false otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''ve added the second test case to our test suite,  the overall refactorized
    test code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to modify the code to pass this new test plan. For brevity,
    we won''t print the `ch13_tdd_v2.h` and `ch13_tdd_v2.cpp` files here. You can
    download them from this book''s [GitHub](https://github.com/PacktPublishing/Expert-CPP) repository. After
    building and executing `ch13_tdd_Boost_UTF2.cpp`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the first output, since we just defined a 2x3 integer matrix and did not
    initialize it in `test_case1`, the undefined behavior – that is, six random numbers
    – is printed out. The second output comes from `test_case2`, where all six elements
    of `x` are initialized to `10`. After we've done a show and tell of the preceding
    result, our customer may ask us to add other new features or modify the currently
    existing ones. But, after a few iterations, eventually, we will reach the *happy
    point* and stop factorizing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about TDD, we will discuss BDD.
  prefs: []
  type: TYPE_NORMAL
- en: BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most difficult part of software development is communicating with business
    participants, developers, and the quality analysis team. A project can easily
    exceed its budget, miss deadlines, or fail completely because of misunderstood
    or vague requirements, technical arguments, and slow feedback cycles.
  prefs: []
  type: TYPE_NORMAL
- en: (BDD) [20] is an agile development process with a set of practices that aim
    to reduce communication gaps/barriers and other wasteful activities. It also encourages
    team members to continuously communicate with real-world examples during the production
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD contains two main parts: deliberate discovery and TDD. To let people in
    different organizations and teams understand the right behavior of the developed
    software,  the deliberate discovery phase introduces an *example mapping* technique
    to make people in different roles have conversations through concrete examples.
    These examples will become automated tests and living documentation of how the
    system behaves later. In its TDD phase, BDD specifies that the tests for any software
    unit should be specified in terms of the desired behavior of the unit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several BDD framework tools (JBehave, RBehave, Fitnesse, Cucumber
    [21], and so on) for different platforms and programming languages. Generally
    speaking, these frameworks perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Read a specification format document that's been prepared by a business analyst
    during the deliberate discovery phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the document into meaningful clauses. Each individual clause is capable
    of being set into test cases for QA. Developers can implement source code from
    the clause as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the test for each clause scenario automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In summary, we have learned about the strategies regarding what, when, and
    how, and a testing process should be involved in an application development pipeline. As
    shown in the following diagram, the traditional V-shape[2] model emphasizes the
    pattern of requirement -> design -> coding -> testing. TDD believes a development
    process should be driven by test, while BDD adds communication between people
    from different backgrounds and roles into the TDD framework and focuses on behavior
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcf1a324-da5d-4573-9146-c831408113a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Moreover, unit testing emphasizes testing individual components when coding
    is complete. TDD focuses more on how to write tests before writing code, and then
    add/modify code through next-level test plans. BDD encourages collaborations between
    customers, business analysts, developers, and quality assurance analysts. Although
    we can use each one individually, we really should combine them for the best results
    in this agile software development era.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly introduced testing and debugging-related topics
    in the software development process. Testing finds problems, and root cause analysis
    helps in locating a problem at the macro level. However, good programming practices
    can prevent software defects in the early stages. Additionally, the command-line
    interface debugging tool known as GDB can help us set breakpoints and execute
    a program line by line while printing the values of variables during the runtime
    of a program.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the automatic analyzing tools and human-involved testing processes. Static
    analysis evaluates the performance of a program without executing it. On the other
    hand, dynamic analysis tools can find defects by executing the program.  Finally,
    we learned about the strategies of what, when, and how, a testing process should
    be involved in a software development pipeline. Unit testing emphasizes testing
    individual components when coding is complete. TDD focuses more on how to write
    tests before developing code and then reiterates this process through a next-level
    test plan. BDD encourages collaborations between customers, business analysts,
    developers, and quality assurance analysts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use Qt to create **Graphic User Interface**
    (**GUI**) programs for cross-platform applications that run on Linux, Windows,
    iOS, and Android systems. First, we will dive into the fundamental concepts of
    cross-platform GUI programming. Then we will introduce an overview of Qt and its
    widgets. Finally, using a case study example, we will learn how to design and
    implement a network application using Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: J.  Rooney and L. Vanden Heuvel, *[Root Cause Analysis For Beginners](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.618.8544&rep=rep1&type=pdf),*  Quality
    Progress,  July 2004, p.45-53.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T. Kataoka, K. Furuto and T. Matsumoto, *[The Analyzing Method of Root Causes
    for Software Problem](https://global-sei.com/technology/tr/bn73/pdf/73-13.pdf)s*,
    SEI Tech. Rev., no. 73, p. 81, 2011.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K. A. Briski, et al. *[Minimizing code defects to improve software quality and
    lower development costs](ftp://ftp.software.ibm.com/software/rational/info/do-more/RAW14109USEN.pdf),*
    IBM Rational Software Analyzer and IBM Rational PurifyPlus software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch](https://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B. Stroustrup and  H. Sutter,  *C++ Core Guidelines*: [https://isocpp.github.io/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/](https://www.fayewilliams.com/2014/02/21/debugging-for-beginners/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.perforce.com/blog/qac/what-static-code-analysis](https://www.perforce.com/blog/qac/what-static-code-analysis).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/1/g++](https://linux.die.net/man/1/g++).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/](https://www.embedded.com/static-vs-dynamic-analysis-for-secure-code-development-part-2/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISO/IEC/IEEE 29119-1:2013 [*SOFTWARE AND SYSTEMS ENGINEERING – SOFTWARE TESTING*](https://www.iso.org/standard/45142.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K. Beck, *[Test-Driven Development by Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530),*
    published by Addison Wesley, ISBN 978-0321146533.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: H. Erdogmus,  T. Morisio, [*On the Effectiveness of Test-first Approach to Programming*](https://ieeexplore.ieee.org/document/1423994),
    Proc. of the IEEE Trans. on Software Engineering, 31(1). January 2005.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd](https://codeutopia.net/blog/2015/03/01/unit-testing-tdd-and-bdd).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cucumber.io/blog/intro-to-bdd-and-tdd/](https://cucumber.io/blog/intro-to-bdd-and-tdd/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. North,  Introducing BDD,  [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)  (March
    2006).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. North, E. Keogh, et. al, "[jbehave.org/team-list](https://jbehave.org/)", 
    May 2019.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from these, you can have a look at the following sources (these are not
    directly mentioned in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'B. Stroustrup and H. Sutter, *C++ Core Guidelines*: [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)[.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'G. Rozental and R. Enficiaud, *Boost.Test*: [https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D. North,* Introducing BDD*: [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises and questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `gdb` function breakpoints, conditional breakpoints and the `watchpoint`,
    `continue`, and `finish` commands, debug `ch13_gdb_2.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `g++ -c -Wall -Weffc++ -Wextra  x.cpp -o x.out` to build out `cpp files
    ch13_rca*.cpp`. What do you see from their warning outputs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does static analysis produce false alarms, but dynamic analysis does not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download `ch13_tdd_v2.h/.cpp`  and perform next phase refactoring. In this
    phase, we will add a copy constructor, assignment operator, and element-wise operation
    operators such as `+`, `-`, `*`, `/`, and more. More specifically, we need to
    do the following things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the third test case to our test suite, that is, `ch13_tdd_Boost_UTF2.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the implementations of these functions to files; for example, `ch13_tdd_v2.h/.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test suite to test them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
