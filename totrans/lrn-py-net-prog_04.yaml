- en: Chapter 4. Engaging with E-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'E-mail is one of the most popular ways of digital communication. Python has
    a rich number of built-in libraries for dealing with e-mails. In this chapter,
    we will learn how to use Python to compose, send, and retrieve e-mails. The following
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails with SMTP through the `smtplib` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing e-mails transport with TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving e-mails by using POP3 with `poplib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving e-mails by using IMAP with `imapclient`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating e-mails on the server with IMAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails with the help of the `logging` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start composing our first e-mail with the help of Python, let us
    revisit some of the elementary concepts of e-mail. Often, an end-user uses a piece
    of software or a graphical user interface (GUI) for composing, sending, and receiving
    e-mails. This piece of software is known as an e-mail client, for example, Mozilla
    Thunderbird, Microsoft Outlook, and so on are e-mail clients. The same tasks can
    be done by a web interface, that is, a webmail client interface. Some common examples
    of these are: Gmail, Yahoo mail, Hotmail and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The mail that you send from your client interface does not reach the receiver's
    computer directly. Your mail travels through a number of specialized e-mail servers.
    These servers run a piece of software called the **Mail Transfer Agent** (**MTA**),
    and its primary job is to route the e-mail to the appropriate destinations by
    analyzing the mail header, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of other things also happen en-route, and then the mail reaches the recipient's
    local e-mail gateway. Then, the recipient can retrieve the e-mail by using his
    or her e-mail client.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few protocols are involved in the aforementioned process. The most common
    of those have been listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**): The SMTP protocol is used by
    the MTA for delivering your e-mail to the recipient''s e-mail server. The SMTP
    protocol can only be used for sending e-mails from one host to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Office Protocol 3** (**POP3**): The POP3 protocol provides a simple
    and standardized way for the users to gain access to the mailboxes and then download
    the messages to their computers. When using the POP3 protocol, your e-mail messages
    will be downloaded from the Internet service provider''s (ISP) mail server to
    the local computer. You can also leave the copies of your e-mails on the ISP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Message Access Protocol** (**IMAP**): The IMAP protocol also provides
    a simple and standardized way for accessing your e-mail from the ISP''s local
    server. IMAP is a client/server protocol in which the e-mails are received and
    held for you by your ISP. As this requires only a small data transfer, this scheme
    works well even over a slow connection, such as the mobile phone network. Only
    if you send a request to read a specific e-mail, that email message will be downloaded
    from the ISP. You can also do some other interesting things, such as creating
    and manipulating folders or mailboxes on the server, deleting messages, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has three modules, `smtplib`, `poplib`, and `imaplib`, which support
    SMTP, POP3, and the IMAP protocols respectively. Each module has options for transmitting
    the information securely by using the **Transport Layer Security** (**TLS**) protocol.
    Each protocol also uses some form of authentication for ensuring the confidentiality
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails with SMTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can send an e-mail from a Python script by using `smtplib` and `e-mail` packages.
    The `smtplib` module provides an SMTP objects which is used for sending mail by
    using either an SMTP or an **Extended SMTP** (**ESMTP**) protocol. The `e-mail`
    module helps us in constructing the e-mail messages with the help of the various
    header information and attachments. This module conforms to the **Internet Message
    Format** (**IMF**) described at [http://tools.ietf.org/html/rfc2822.html](http://tools.ietf.org/html/rfc2822.html).
  prefs: []
  type: TYPE_NORMAL
- en: Composing an e-mail message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us construct the e-mail message by using classes from the `email` module.
    The `email.mime` module provides classes for creating the e-mail and MIME objects
    from scratch. **MIME** is an acronym for **Multi-purpose Internet Mail Extensions**.
    This is an extension of the original Internet e-mail protocol. This is widely
    used for exchanging different kinds of data files, such as audio, video, images,
    applications, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many classes have been derived from the MIME base class. We will use an SMTP
    client script using `email.mime.multipart.MIMEMultipart()` class as an example.
    It accepts passing the e-mail header information through a keyword dictionary.
    Let''s have a look at how we can specify an e-mail header by using the `MIMEMultipart()`
    object. Multi-part mime refers to sending both the HTML and the TEXT part of an
    e-mail message in a single e-mail. When an e-mail client receives a multipart
    message, it accepts the HTML version if it can render HTML, otherwise it presents
    the plain text version, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, attach a plain text message to this multi-part message object. We can
    wrap a plain-text message by using the `MIMEText()` object. The constructor of
    this class takes the additional arguments. For example, we can pass `text` and
    `plain` as its arguments. The data of this message can be set by using the `set_payload()`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will attach the plain text message to the Multi-part message, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The message is ready to be routed to the destination mail server by using one
    or more SMTP MTA servers. But, obviously, the script only talks to a specific
    MTA and that MTA handles the routing of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an e-mail message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `smtplib` module supplies us with an SMTP class, which can be initialized
    by an SMTP server socket. Upon successful initialization, this will give us an
    SMTP session object. The SMTP client will establish a proper SMTP session with
    the server. This can be done by using the `ehlo()` method for an SMTP `session`
    object. The actual message sending will be done by applying the `sendmail()` method
    to the SMTP session. So, a typical SMTP session will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our example SMTP client script, we have made use of Google's free Gmail service.
    If you have a Gmail account, then you can send an e-mail from a Python script
    to that account by using SMTP. Your e-mail may get blocked initially, as Gmail
    may detect that it had been sent from a less secure e-mail client. You can change
    your Gmail account settings and enable your account to send/receive e-mails from
    less secure e-mail clients. You can learn more about sending e-mail from an app
    on the Google website, which can be found at [https://support.google.com/a/answer/176600?hl=en](https://support.google.com/a/answer/176600?hl=en).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have a Gmail account, then you can use a local SMTP server setup
    in a typical Linux box and run this script. The following code shows how to send
    an e-mail through a public SMTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, then you can see that the output is similar to what
    is mentioned here. For the sake of anonymity, real e-mail addresses have not been
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This script will send a very simple e-mail message by using Python's standard
    library module, `smtplib`. For composing the message, `MIMEMultipart` and `MIMEText`
    classes have been imported from the `email.mime` submodule. This submodule has
    various types of classes for composing e-mail messages with different types of
    attachments, for example, `MIMEApplication()`, `MIMEAudio()`, `MIMEImage()`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `send_mail()` function has been called by two arguments:
    sender and receiver. Both of these arguments are e-mail addresses. An e-mail message
    is constructed by the `MIMEMultipart()` message class. The essential headers,
    such as `To`, `From`, and `Subject` have been added to this class namespace. The
    body of the message is composed with the instance of the `MIMEText()` class. This
    is done by the class `set_payload()` method. Then, this payload is attached to
    the main message by the `attach()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to communicate with the SMTP server, a session with the server will
    be created by instantiating the `smtplib` module's `SMTP()` class. The server
    name and the port arguments will be passed to the constructor. According to the
    SMTP protocol, an extended hello message through `ehlo()` method will be sent
    by the client to the server. The message will be sent by the `sendmail()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that if the `set_debuglevel()` method is called on an SMTP session object,
    then it will produce additional debug messages. The line is commented out in the
    preceding example. Un-commenting that line will produce a debug message such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is interesting because the message has been sent through a public SMTP
    server in a step-by-step fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails securely with TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TLS** protocol is a successor of **SSL** or **Secure Socket Layer**. This
    ensures that the communication between the client and the server is secure. This
    is done by sending the message in an encrypted format so that unauthorized people
    cannot see the message. It is not difficult to use TLS with `smtplib`. After you
    create an SMTP session object, you need to call the `starttls()` method. Before
    sending an e-mail, you need to login to the server by using the SMTP server credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example for the second e-mail client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to our first example, except for the authentication
    to the server. In this case, the SMTP user is authenticated against the server.
    If we run the script after turning on the SMTP debugging, then we would be seeing
    an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After the user input, communication with the server will begin. It will start
    by the `ehlo()` method. In response to this command, the SMTP server will send
    a few response lines with the return code `250`. This response will include the
    features supported by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The summary of these responses will indicate that the server is ready to proceed
    with the client, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the initial command, the client will use the `starttls()` method to upgrade
    the connection to TLS, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the authentication phase, the authentication data is sent by the client-side
    script with the help of the `login()` method. Note that the authentication token
    is a base-64 encoded string and the username and password are separated by a null
    byte. There other supported authentication protocols exists for the sophisticated
    clients. The following is the example of authentication token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the client is authenticated, it can send e-mail messages by using the
    `sendmail()` method. Three arguments are passed to this method, sender, recipient,
    and the message. The sample output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving e-mails by using POP3 with poplib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stored e-mail messages can be downloaded and read by the local computer.
    The POP3 protocol can be used to download the messages from the e-mail server.
    Python has a module called `poplib`, and it can be used for this purpose. This
    module provides two high-level classes, `POP()` and `POP3_SSL()`,which implement
    the POP3 and POP3S protocols respectively for communicating with a POP3/POP3S
    server. It accepts three arguments, host, port, and timeout. If port is omitted,
    then the default port (110) can be used. The optional timeout parameter determines
    the length (in seconds) of the connection timeout at the server.
  prefs: []
  type: TYPE_NORMAL
- en: The secure version of `POP3()` is its subclass `POP3_SSL()`. It takes additional
    parameters, such as keyfile and certfile, which are used for supplying the SSL
    certificate files, namely the private key and certificate chain file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing for a POP3 client is also very straightforward. To do this, instantiate
    a mailbox object by initializing the `POP3()` or `POP3_SSL()` class. Then, invoke
    the `user()` and `pass_()` methods to login to the server by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can call the various methods for manipulating your accounts and messages.
    A few interesting methods have been listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stat()`: This method returns the mailbox status according to tuples of two
    integers, that is, the message count and the size of the mailbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`(): This method sends a request for getting a message list, which has
    been demonstrated in the example shown later in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retr()`: This method gives an argument message a number that indicates the
    message that has to be retrieved. It also marks the message as read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dele()`: This method provides an argument for the message that has to be deleted.
    On many POP3 servers, the deletion is not performed until QUIT. You can reset
    the delete flag by using the `rset()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit()`: This method takes you off the connection by committing a few changes
    and disconnecting you from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us see how we can read out the e-mail messages by accessing the Google''s
    secure POP3 e-mail server. By default, the POP3 server listens on port `995` securely.
    The following is an example of fetching an e-mail by using POP3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `fetch_email()` function has created
    a mailbox object by calling `POP3_SSL()` along with the server socket. The username
    and the password are set on this object by calling the `user()` and `pass_()`
    method. Upon successful authentication, we can invoke the POP3 commands by using
    methods, such as the `list()` method, which is called to list the e-mails. In
    this example, the total number of messages has been displayed on the screen. Then,
    the `retr()` method has been used for retrieving the content of a single message.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample output has been shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving e-mails by using IMAP with imaplib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, accessing e-mail over the IMAP protocol doesn't
    necessarily download the message to the local computer or mobile phone. So, this
    can be very efficient, even when used over any low bandwidth Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a client-side library called `imaplib`, which can be used for
    accessing e-mails over the IMAP protocol. This provides the `IMAP4()` class, which
    implements the IMAP protocol. It takes two arguments, that is, host and port for
    implementing this protocol. By default, `143` has been used as the port number.
  prefs: []
  type: TYPE_NORMAL
- en: The derived class, that is, `IMAP4_SSL(),` provides a secure version of the
    IMAP4 protocol. It connects over an SSL encrypted socket. So, you will need an
    SSL friendly socket module. The default port is `993`. Similar to `POP3_SSL()`,
    you can supply the path to a private key and a certificate file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of what an IMAP client looks like can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned code will try to initiate an IMAP4 encrypted client session.
    After the `login()` method is successful, you can apply the various methods on
    the created object. In the aforementioned code snippet, the `select()` method
    has been used. This will select a user's mailbox. The default mailbox is called
    `Inbox`. A full list of methods supported by this mailbox object is available
    on the Python Standard library documentation page, which can be found at [https://docs.python.org/3/library/imaplib.html](https://docs.python.org/3/library/imaplib.html).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we would like to demonstrate how you can search the mailbox by using the
    `search()` method. It accepts a character set and search criterion parameter.
    The character set parameter can be `None`, where a request for no specific character
    will be sent to the server. However, at least one criterion needs to be specified.
    For performing advance search for sorting the messages, you can use the `sort()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to POP3, we will use a secure IMAP connection for connecting to the
    server by using the `IMAP4_SSL()` class. Here''s a lightweight example of a Python
    IMAP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an instance of `IMPA4_SSL()`, that is, the mailbox object,
    has been created. In this, we have taken the server address and port as arguments.
    Upon successfully logging in with the `login()` method, you can use the `select()`
    method for choosing the mail box folder that you want to access. In this example,
    the `Inbox` folder has been selected. In order to read the messages, we need to
    request for the data from the Inbox. One way to do that is to use the `search()`
    method. Upon the successful reception of some mail metadata, we can use the `fetch()`
    method for retrieving the e-mail message envelope part and data. In this example,
    the RFC 822 type of standard text message has been sought with the help of the
    `fetch()` method. We can use the Python pretty print or the print module for showing
    the output on the screen. Finally, apply the `close()` and the `logout()` methods
    to the mailbox object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code will display an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Sending e-mail attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen how plain text messages can be sent by
    using the SMTP protocol. In this section, let us explore how to send attachments
    through e-mail messages. We can use our second example, in which we have sent
    an e-mail by using TLS, for this. While composing the e-mail message, in addition
    to adding a plain text message, include the additional attachment field.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can use the `MIMEImage` type for the `email.mime.image`
    sub-module. A GIF type of image will be attached to the e-mail message. It is
    assumed that a GIF image can be found anywhere in the file system path. This file
    path is generally taken on the basis of the user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to send an attachment along with your e-mail
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding script, then it will ask the usual, that is, the e-mail
    sender, the recipient, the user credentials, and the location of the image file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sending e-mails via the logging module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any modern programming language, the logging facilities are provided with
    common features. Similarly, Python's logging module is very rich in features and
    flexibilities. We can use the different types of log handlers with the logging
    module, such as the console or the file logging handler. One way in which you
    can maximize your logging benefits is by e-mailing the log messages to the user
    just as the log is being produced. Python's logging module provides a type of
    handler called `BufferingHandler,` which is capable of buffering the log data.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of extending `BufferingHandler` has been displayed later. A child
    class called `BufferingSMTPHandler` is defined by `BufferingHandler`. In this
    example, an instance of the logger object is created by using the logging module.
    Then, an instance of `BufferingSMTPHandler` is tied to this logger object. The
    logging level is set to DEBUG so that it can log any message. A sample list of
    four words has been used for creating the four log entries. Each log entry should
    resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us take a look at the full code. The following is an example of sending
    an e-mail with the help of the logging module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `BufferingSMTPHandler` method only overrides one method,
    that is, `flush()`. On the constructor, `__init__()`, the basic variable is setup
    as well as the logging format by using the `setFormatter()` method. In the `flush()`
    method, we have created an instance of an `SMTP()` object. The SMTP message header
    has been created by using the data available. The log message has been appended
    to the e-mail message, and the `sendmail()` method has been called to send the
    e-mail message. The code in the `flush()` method is wrapped inside a `try-except`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the script discussed will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you check the e-mail message with the e-mail command (native to Linux/UNIX
    machines), you can expect that the e-mail would have been received by the local
    user, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the content of the message by typing the message ID on the command
    prompt with `&`, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can quit the mail program by typing the shortcut `q` on the command
    prompt, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter demonstrates how Python can interact with the three major e-mail
    handling protocols: SMTP, POP3, and IMAP. In each of these cases, how to work
    the client code has been explained. Finally, an example for using SMTP in the
    Python''s logging module has been shown.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use Python to work with remote systems
    to perform various tasks, such as administrative tasks by using SSH, file transfer
    through FTP, Samba, and so forth. Some remote monitoring protocols, such as SNMP,
    and the authentication protocols, such as LDAP, will also be discussed briefly.
    So, enjoy writing more Python codes in the next chapter.
  prefs: []
  type: TYPE_NORMAL
