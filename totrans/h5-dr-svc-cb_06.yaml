- en: Chapter 6. Data Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating text by length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating numbers by range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the built-in pattern validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced use of built-in constraints and custom validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating password strength
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating US zip codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous server-side validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining client-side and server-side validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms usually expect the user to behave in a certain way and to insert data
    as requested. This is where data validations come in. Server-side validation is
    always a must to do and form validation at the client side should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Validation makes the application user-friendly, saves time and bandwidth. Client-side
    and server-side validation complement each other and they should be used always.
    In this chapter, we are going to look at some new mechanisms provided mostly for
    client-side checks by HTML5 as well as how to tackle some common problems.
  prefs: []
  type: TYPE_NORMAL
- en: Validating text by length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic checks at the client side is the length of the text being
    inserted or submitted with the form. This is often left out, but it is one of
    the checks that must be done and not just at the client side. Imagine if we had
    no restriction on any of our inputs, a few large texts could overload the server
    without making much effort.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple HTML form that will contain a few different inputs on
    which we will apply some constrains:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head of the page is a standard one, so we will directly go into creating the
    form, first adding the `name` input limited to `20` characters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we will add another `input` field that initially has an invalid
    value, longer than the one specified for testing purpose, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will add the `textarea` tag that will have the `spellcheck`
    attribute added as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we will add two buttons, one for submitting the form and another
    for enabling the JavaScript fallback validation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are going to test out a fallback version using the jQuery Validate
    plugin, we will add the dependency for those two libraries and include our own
    `formValidate.js` file that will be defined later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to select the form that is to be submitted and add the JavaScript-based
    validations using the plugin, when the button for enabling the fallback is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we also add the messages that will be shown on validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The button for enabling JavaScript is used only for demonstrative purpose,
    in a real application you are probably going to have it as a fallback or as the
    only approach. Since we are only checking for maximum length, validation should
    not be a problem unless we previously have rendered the HTML with incorrect values.
    As for the message for validation, at the time of writing it is supported in all
    of the modern browsers and IE 10, but none of the mobile browsers have added support
    for it yet. We can first check that if the browsers support the spellcheck attribute,
    and then act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Initially, we will take a look at the `maxlength` attribute. As you would expect
    the browsers do not allow this type of constraint to be broken by user input,
    they generally stop the input after the maximum has been inserted.
  prefs: []
  type: TYPE_NORMAL
- en: So the question is how can this constraint be violated?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, if the rendered HTML is invalid to start with or if the data was changed
    programmatically, then the form will be submitted without validation. This is
    actually the specified behavior; there is a dirty flag that designates if the
    input was from the user or not. In our case, as long as we don''t change anything
    in the input labeled **Initially invalid**, the form will get submitted successfully.
    On the other hand, when the user changes some of the data in that element the
    form fails with a validation error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: validation pop up as shown on Chrome Version 28 development release
  prefs: []
  type: TYPE_NORMAL
- en: In the validation error pop up displayed beside the error message will have
    the contents of the `title` attribute, meaning that this attribute has another
    usage besides the standard hint. This message box looks differently on various
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the major control when enabling grammar and spellchecker on the
    browsers is up to the user, there is an attribute called `spellcheck`, that can
    be added to hint the browser to do spelling checks. In our example, the comment
    would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This attribute is inheritable and can be combined with the `lang` attribute.
    For example, if we have the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the example we have multiple different languages used. Since the page has
    the `lang="en"` attribute set, the English dictionary will be used for all elements
    that are nested inside. And because the `div` element has the `lang="fr"` attribute,
    all the nested elements (`textarea` and `input type = text`) will be checked against
    the French dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on the spellcheck can be found on the WHATWG page [http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking](http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#spelling-and-grammar-checking).
    One other thing to note is that the `spellcheck` attribute in the past had to
    be set to `true` or `false`, but with the latest changes it can be left to be
    empty [http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.spellcheck).
  prefs: []
  type: TYPE_NORMAL
- en: Why do we say that the user has the full control? Well, if the user had always
    picked spellcheck in the browser or never checked, that option overrides the behavior
    that comes with this tag. This attribute can be applied to text input related
    elements, as well as the elements whose content has been made editable.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback or in a way different approach is to use JavaScript to validate for
    the text length. Because there is no `minlength` attribute in HTML5, there is
    no standard way of validation for minimal length. Therefore, we are going to use
    jQuery Validation plugin. There is a way to do this also by using the `pattern`
    attribute and regex, but that we are going to discuss in detail later in the *Using
    built-in pattern validation* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the validation, we select the form and set the rules by specifying
    the validation rule, where the keys are the form parameter names, and values are
    the applied validation checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we add the message for each individual check, where again the keys
    are the form parameter names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation rules will also include the original attributes added to the
    form elements. In our case, the input labeled **Initially invalid** has the `maxlength`
    attribute, and this will be added as part of other rules that are part of the
    JavaScript configuration. Also, the rules that are defined in JavaScript can be
    moved to be a part of appropriate form elements. Finally, the result of the JavaScript
    version should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The style of the side text displayed by the jQuery Validation plugin in our
    example is the same as labels. There is a simple CSS class named `.error` added
    when there are validation errors, also there is an option to execute function
    when validation problem happens or is removed. This can be done while configuring
    the validate element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As far the topic of styling validation messages and elements is concerned, they
    will be discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Validating numbers by range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes down to numbers in forms, the basic validation is to check if
    the number is in a given range. For achieving this, there are the `min` and `max`
    attributes that should be applied to input types number, range, and date/time
    related inputs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a form containing a few input elements that need to have a range
    restriction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will start by creating the form with a number `input` field
    for age, limiting it to minimum of `18`, as given in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the `range` input for the `Bet` value the user would place as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we include inputs limited with `min`, `max`, and `step` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will add the dependency for jQuery, our `example.js`, and an
    input `submit` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also just link the range input with the output field in order to have
    a simple display in the `example.js` script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might expect, the range for the age 18 to 140 is expected by the user,
    and if that input is not in that range we get an underflow constraint violationthat
    will display the appropriate (**The value must be greater than or equal to {min}**)
    message. Similarly, we get an overflow constraint violation with the message,
    **Value must be less than or equal to {max}**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the input type `range`, there is no way for the user to get outside the
    range or even to trigger the step mismatch validation error. The step mismatch
    error should only be triggered if the initial value was not within the `min` value
    and some multiples of the `step` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here `11` should not be valid, because the value of the `step` attribute is
    `3`, and there is no way of getting to `11` using a slider, but the value is initially
    as such, so we should get an validation error, but this is browser specific. Most
    of the current versions of the browsers just correct the initially selected value
    while rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to submit the form for the **Doubles** input we should get a validation
    message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we receive the message because the value is `4`, but the constrains are
    `min="0" step="5" max="10"`, meaning that the value entered must be a multiple
    of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: The user cannot get a validation message using the input type `range`, but this
    can happen using an input type `number`, since the user can manually Insert data
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in pattern validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create more complex validation, we need to use JavaScript. To ease
    the development, the `pattern` attribute was introduced for the `input` fields.
    This enables us to use regex for making validation checks, and in this recipe
    we will take a look at some of the elements that can be used in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will create a form using simple HTML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the form directly in the `body` section, starting with the
    **Username** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add **Phone** as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will include `url` for **Webpage** as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the **Emails** and **Gmail** input as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pattern` attribute, if specified, uses an earlier version of the JavaScript
    regex. Whole text must be matched against the given expression. For our example,
    we used loose validation, where, for example, for input type `tel`, we allow numbers
    and optional leading `+` specified by the pattern `[\+]?[1-9]+`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other input types, such as `URL` and `email` use their built-in
    validation. All mails must match the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is very permissive so we can add additional validations as we added
    in the input labeled **Gmail**. Constrains can be combined, or if some attribute
    accepts multiple entries all of these will get validated according the constrains,
    as we did in the following e-mails example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also remember that we need to add a hint using title or placeholder or any other
    way, because the user will get the **Please match the requested format** message
    by default, and will not know what is he or she doing wrong.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a site named [http://html5pattern.com/](http://html5pattern.com/) that
    is intended as the source of regularly used input patterns. It's definitely a
    good resource, and we encourage you to visit it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced use of built-in constraints and custom validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have already used some of the built-in validation mechanisms. Now
    we are going to take a deeper look at some of them, and how we can add our own
    customization. We will change the style and apply some more advanced checks as
    well, when we will see how we can disable validation on certain elements by creating
    a form that has most of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current working draft version for the form validation can be found at [http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a form that will have error messages styled using CSS, and custom
    validation using HTML and JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by creating the head section, where we will include `example.css`,
    where the CSS file will contain selectors for the `input` elements with valid,
    invalid, optional, and required state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the `example.css` file. The `valid.png` image can
    be found in the source examples. In real life, you would probably not use all
    of these states to style the look of the forms, but we added it here in order
    to show what can be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS `box-shadow` is not fully supported in legacy browsers, for example IE 8\.
    The specification for `box-shadow` can be found at [http://www.w3.org/TR/css3-background/#box-shadow](http://www.w3.org/TR/css3-background/#box-shadow).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the `head` section, we will start with adding the form elements in
    the `body` section. First, we will add the `name` and `nickname` fields, making
    them `required`, and for which later we will ensure not to have the same value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also include two date/time related inputs, one for `week` and other
    for `month`, where we will limit the weeks from second week of 2013 to second
    week of 2014 and allow every other month to be selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will add three buttons: one for submitting the form, another for checking
    the validity using JavaScript, and one more for submitting without validation
    and constraint checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the form, we will add one `div` element for displaying some log information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the JavaScript, we add the dependency for jQuery and include `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `example.js` file, we will add an event for the check validity button,
    where we will print the `ValidityState` value to `validLog`, on the validation
    errors of each of the form elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To add custom validation, we will use the `.setCustomValidity()` method, so
    it will check if the `name` and `nickname` values are the same, and if so, we
    will add validation error, and if they are not, we will remove the custom check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `required` attribute marks the HTML element inside the form, required to
    have a value before the form can be submitted. The first field that will not have
    a value would get focused upon submission and a hint with a message would be shown
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several ways to customize the message displayed to the user on Firefox;
    we can use the `x-moz-errormessage` attribute. In our case, this is `x-moz-errormessage="We
    need this."`, but this will only work there. On Chrome, the `title` attribute
    gets additionally displayed beside the standard message, but the original message
    stays. Another way for changing the message would be to set the value using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As for styling the form elements, there are the CSS pseudo class selectors `:required`
    and `:optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In WebKit, there are browser-specific CSS selectors that can be used to style
    the hint box, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`::-webkit-validation-bubble {…}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`::-webkit-validation-bubble-message {…}`'
  prefs: []
  type: TYPE_NORMAL
- en: But because they are browser-specific, they are not very helpful in a practical
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: The `min`, `max`, and `step` attributes can be used on date-related input types
    and not just on numbers. The default step is one day for date type, one week for
    week types, and so on. If we set a different step than the default one, for example
    on the month input if we have the step with value two, the user will not be able
    to select every other month from the DatePicker control, but he or she can still
    enter the wrong date in text, triggering `stepMismatch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because validation is triggered before the form is submitted, and if the input
    is invalid, the `submit` event is never called. If we need to have a way of submitting
    data without validation, we can do that by using the `formnovalidate` attribute
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We may sometimes need to access the `validityState` value of an element from
    JavaScript; for that purpose there is a `checkValidity()` method executed on the
    form and the input elements in the form. As the name suggests, it checks the state
    of elements, and when it is called on the form, all the child elements are checked
    for validation and additionally, we can call the method on each individual element,
    for example `input`, `select`, or `textarea`. In our case for the form, it was
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$(''form'')[0]` element gives us the wrapped DOM element of the selected
    jQuery''s object, this can also be done by calling `.get()` on the selected element.
    Each element has a `validitystate` value that we can read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several built-in checks we can access at this point that are properties
    of the `validityState` object: `valueMissing`, `typeMismatch`, `patternMismatch`,
    `tooLong`, `rangeUnderflow`, `rangeOverflow`, `stepMismatch`, `badInput`, and
    `customError`. Each of these will return `true` if there is such constraint violation.
    In the example code for this recipe, we just print out the name of the constraint
    violation to the log.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we have fields that depend on each other or when we need to
    implement some custom validation logic? No problem there we are covered, we can
    use the `setCustomValidity()` method on each of the fields that depend. In our
    case, we wanted the input for the `name` and `nickname` variables to be different.
    So we added change listener and if they are the same we just set the message with
    `customValidity("your message here")` and when we need to remove the violation,
    we set the message to be an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, there are two more CSS pseudo selectors for `:valid` and `:invalid`
    that we will be used to style elements, depending on their `validityState` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specification for client-side form validation can be found at: [http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation](http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#client-side-form-validation).
    As for the constraints API, more info is found at [http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api](http://www.whatwg.org/specs/web-apps/current-work/#the-constraint-validation-api).'
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note is that all the browsers do not have full support
    for all the features. IE 9, for example, has no support for any of the constrains
    as well as none of the new input types. More on current browsers support can be
    found at [http://caniuse.com/#search=form%20vali](http://caniuse.com/#search=form%20vali)
    and [http://www.quirksmode.org/compatibility.html](http://www.quirksmode.org/compatibility.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to use some of the attributes to disable the entire form from validating,
    we can set the form attribute called `novalidate`. For example, this will disable
    the checks, but allow use of `min` and `max` for input type range.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an another way to disable the standard browser hint box and create
    a custom one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Several questions should be thought through before using built-in constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to know when the user has clicked on the **Submit** button?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need client-side validation for browsers that don't support the Form Validation
    API yet?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need to know when the user has tried to submit the form, we can attach
    event listener for click rather than submit. As for legacy browsers, we may choose
    to rely on server-side validation that must be present, but if we don't want to
    lose functionality at the client side, there are some ways of doing this by adding
    webshim, [http://afarkas.github.com/webshim/demos/index.html](http://afarkas.github.com/webshim/demos/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/9282OT_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating password strength
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of websites display the strength of the password chosen by the user on
    their registration forms. The goal of this practice is to help the user choose
    a better, stronger password which cannot be guessed or brute-forced easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to make a password strength calculator. It will
    determine the password strength by calculating the number of brute-force attempts
    that a potential attacker must make before guessing the password. It will also
    warn the user if his password is in a list of 500 commonly used passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, its important to look at how we''re going to calculate the
    number of brute-force attempts that an attacker must make. We''re going to take
    a look at two factors: the length of the password and the size of the character
    set used by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the character set can be determined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the user adds a lowercase alphabet letter in his password, the size of the
    character set grows by 26 (the number of letters in the alphabet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional 26 are added if the user uses an uppercase letter anywhere except
    at the beginning of the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 characters are added if the user adds a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 24 characters are added if the user adds a special character such as dot, comma,
    braces, ampersand, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20 characters are added if the user uses a unicode character not found in other
    tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the HTML and JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple HTML page with a `password` input, then add a `div` element,
    which we will update with the password strength result. Common passwords will
    be included via a script named `common-passwords.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `common-passwords.js` script is not included here, but can be found in the
    supplementary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code checking the logic is in `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `div` element indicating password strength when a key is pressed
    in the `password` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The calculation is split into two parts: checking for password commonality
    and password complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: We check if the password is common simply by checking if it can be found in
    the `commonPasswords` array provided by `common-password.js`. `Array#indexOf`
    returns 1 if the entry was not found. The bitwise not operator `~` turns that
    value into zero, which evaluates to false. All the other numbers greater than
    or equal to 0 will have negative values, which are true values. Thus, the entire
    expression returns true if the password is found in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bruteMagnitude` function we calculate the password''s brute-force order
    of magnitude using the `passwordLength` and character `setsize` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is an approximate order of magnitude of the number of passwords that a
    brute-force password attacker must try to guess the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this information, we can now give an actual password strength. If
    the password is among the top 500 common passwords, it will be classified as poor.
    Otherwise it will be classified according to its brute force magnitude using the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Magnitude | Number of passwords | Rating |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Less than 7 | Less than 10 million | Very poor |'
  prefs: []
  type: TYPE_TB
- en: '| 7 to 8 | 10 million to 1 billion | Poor |'
  prefs: []
  type: TYPE_TB
- en: '| 9 to 10 | 1 billion to 100 billion | Passing |'
  prefs: []
  type: TYPE_TB
- en: '| 11 to 12 | 100 billion to 10 trillion | Fair |'
  prefs: []
  type: TYPE_TB
- en: '| 13 to 14 | 10 trillion to 1 quadrillion | Good |'
  prefs: []
  type: TYPE_TB
- en: '| 15 to 17 | 1 to 100 quadrillion | Very good |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than 17 | Greater 100 quadrillion | Excellent |'
  prefs: []
  type: TYPE_TB
- en: The classification, along with the descriptive text will be updated on every
    key press and displayed to the user below the password field.
  prefs: []
  type: TYPE_NORMAL
- en: Validating US zip codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating zip codes at the client side can be useful on web pages with address
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Entering numbers is an error-prone process. It would be great for the user if
    we could provide some kind of basic immediate validation to inform them of a possible
    error in their data entry.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a satisfyingly complete zip code database has a non-trivial
    size. Loading the complete database at the client side might be difficult and
    non-optimal.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to write a client-side zip code validation function.
    In the process, we're going to learn what it takes to convert a non-trivial zip
    code database to a smaller representation which can be loaded at the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's download the zip code database file first. The [unitedstateszipcode.org](http://unitedstateszipcode.org)
    website provides a free zip code database in a CSV format ([http://www.unitedstateszipcodes.org/zip-code-database/](http://www.unitedstateszipcodes.org/zip-code-database/)).
  prefs: []
  type: TYPE_NORMAL
- en: We're going to extract a smaller database from this file which can be loaded
    at the client side. To do this, we're going to write a Node.js script, so make
    sure you have Node.js installed. Download Node.js from [http://nodejs.org/](http://nodejs.org/),
    explained in [Appendix A](apa.html "Appendix A. Installing Node.js and Using npm"),
    *Installing Node.js and Using npm*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Node.js` is a platform built on top of Chrome''s V8 JavaScript engine, meant
    for writing fast asynchronous network applications. It comes with a great module
    manager called `npm` and a registry containing tens and thousands of module libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same directory with `zip_code_database.csv`, we're going to create a
    new Node.js script. To process a CSV file, we're going to use a CSV parsing library.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a command prompt in the same directory, let''s install the node module
    CSV by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''re going to make `createdb.js`, which will parse the CSV file and
    extract the minimum amount of data from it, US state, and zip code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a usable array of zip codes. However, if we were to
    write them all directly, it would result in a fairly large 400 KB JSON array,
    150 KB when compressed with GZIP. Many of the valid zip code numbers are sequential.
    We can take advantage of this and represent them as ranges instead. By applying
    this technique we get a 115 KB file, 45 KB when compressed. This size seems a
    lot more acceptable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The final representation will be a JSON array sorted by the `state` name. Every
    element in this array represents a state and contains two attributes: state name
    and a list of valid zip codes represented as numbers, or zip code ranges represented
    as two-dimensional arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script in the command line from the same directory `node createdb.js
    > zipcodedb.js` will result with the `zipcodedb.js` file, which contains the database.
    Here is a sample of the database JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this database to create the basic validator by including it
    in our `index.html` page. The page will contain a simple state selection dropdown
    and a zip code field. Below the zip code field will be the validation message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re going to write a `lookup` function to check if a given zip
    code is in our database, which we''re going to use to validate the user input
    as they type. We will populate the states dropdown using the same database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To validate zip codes at the client side, we first had to convert our database
    to a smaller size.
  prefs: []
  type: TYPE_NORMAL
- en: The downloaded database contained a lot of extra data such as city to zip code
    mappings, zip code types, time zone and geographic coordinates, as well as decommissioned
    zip codes. We removed the extra data, leaving only the US zip codes that are still
    in use along with their state.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the database even further, we represented longer valid zip code ranges
    as arrays containing the first and the last number in the range. This helped to
    reduce the database size further to a reasonable size as compared to the size
    of a medium website image.
  prefs: []
  type: TYPE_NORMAL
- en: To use the database, we wrote a simple `lookup` function that checks if the
    zip code is inside the list of values of `zipcode` and `ranges` in any of the
    states and returns the state if found.
  prefs: []
  type: TYPE_NORMAL
- en: The validation information updates automatically while the user is entering
    the zip code.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous server-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many validation checks can only be performed at the server side. The following
    are the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: When validating a user registration form, we need to check if the entered username
    is available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user enters a postal address, we might need to ask an external service
    to verify if the address is correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with server-side validation checks is that they need to be asynchronous.
    As a result, they cannot be written in JavaScript as functions that return validation
    results.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, in this recipe we're going to make a validator that uses
    the continuation-passing style. The example has a username input field that is
    validated against the server. The server checks if the username is available for
    registration or already occupied by another user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to briefly look at the continuation-passing style. It''s a style
    used by most of the JavaScript libraries for asynchronous operations, for example,
    server communication. For example in jQuery, instead of writing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the same transformation to a validation function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we also need to change the `validate` function. For example, if
    we had as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After transforming it to the continuation-passing style we will have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to use the server-side calls, for example, `$.getJSON` in our
    validation function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use our server-side validator from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to write the HTML page containing the form to be validated and the
    JavaScript code that implements the validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the HTML page. It must contain a form with a username input
    and a validation result with red text hidden by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation code will be in `example.js` – it contains a function that simulates
    an `async` server call, a function that used to delay the execution of the `async`
    server call to prevent multiple calls, and a function that displays the validation
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in the `validate` function from `example.js` simulates a server call
    by using the `setTimeout` function. It would be easy to replace this code with
    a real call to the server validation API using something similar to `jQuery.getJSON`
    to get the validation results.
  prefs: []
  type: TYPE_NORMAL
- en: The `createDelayed` function creates a `delayer` object. The `delayer` object
    wraps the function to be delayed. It is different from `setInterval`, because
    if the `delayer` object is called again before the delay expires, the previous
    timeout will be canceled and restarted. This helps us to avoid overloading the
    server with requests on every single keystroke, instead the request is sent `1500ms`
    after the user stops typing.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `delayer` object on every user keypress, binding "`this`" to `null`,
    the first argument to the current value of the input field, and the `callback`
    function to a function that shows the returned validation error if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Combining client-side and server-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with real web forms we usually need to do various kinds of validation
    on multiple fields. Some fields may only need checks that can be performed at
    the client side, while some might also require server-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to design and implement our own validation plugin
    that supports asynchronous validation. It will work similarly to jQuery Validate.
    We're also going to implement some basic validation methods such as `required`,
    `minLength`, and `remote`.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use these methods on a simple user registration form, which will
    be blocked from submission until the user enters valid data in all fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in our design process is to design the data structures that
    will be used in our validator. We''re going to make an API similar to jQuery Validate,
    which takes a configuration object as its parameter. However, we''re going to
    opt into a more modern, HTML5 approach where the validation rules are embedded
    into the HTML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In order to support this rule and message structure, Validate will utilize validation
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Each plugin will have a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin will be a function that takes three parameters: the element being,
    the rule parameters object, and a `callback` function to call when the validation
    is complete. The `callback` function will take two arguments: the first will indicate
    if the field is valid and the second will contain the message parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin will prevent the submission of the form unless it verifies the validity
    of all the fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write the HTML and JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.html` page will contain the form with its validation rules embedded.
    Note that we can also mix in standard HTML form validation, for example via the
    `required` attribute as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interesting part about this HTML file is that there are no other scripts
    included besides `avalidate.js` and `avalidate-plugins.js`, yet they provide full
    validation to this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code that we need to add to `avalidate.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly execute asynchronous validation we need to be able to the delay
    the request until the user stops typing. To do this we use `createDelayed` – it
    creates timeouts which reset themselves on each call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`showError` displays the appropriate error besides the form, filling it with
    templated text. The first time it runs, it moves the template out of the `error`
    element inner text and adds into a new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`elementVerifier` executes on an element. It looks up all verifier plugins
    specified by the `data-v-pluginName` attributes, reads the plugin options from
    the attribute, and then runs the async plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the plugins finish verifying, it marks the element as valid if no
    errors were found. Otherwise it displays the errors as they appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`setupFormVerifier` enables the validation process on a certain form by binding
    to all changes, keyboard and mouse events that happen in its fields. It creates
    a separate `delayer` variable for every element and runs the `elementVerifier`
    object with that `delayer`. Finally, it forbids the form submission unless all
    the fields are marked as valid by the `elementVerifier` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the part that makes everything work without manual intervention.
    We listen to all the events arriving on the document `body` object, and if an
    event arrives at a form that is supposed to have validation enabled but doesn''t,
    we run `setupFormVerifier` on it (once):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugins are much easier to write. Here is `avalidate-plugins.js`. Note
    that the server plugin is simulated with `setTimeout`. The same principles apply
    when making an AJAX call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This validator takes advantage of the new HTML5 data attribute features. HTML5
    does include some great new validation options by adding input element attributes
    and types, but they're not enough. To solve this, we follow the HTML5 model and
    add our own data attributes for validation methods and validation error messages.
  prefs: []
  type: TYPE_NORMAL
- en: To make these new data attributes work we need to load JavaScript code. One
    of the pitfalls of JavaScript-initialized elements is the need to call the initialization
    functions whenever we add a new element on the page. This plugin successfully
    avoids the pitfall by using the new jQuery binding APIs. Instead of binding to
    the forms directly, the listener is attached to the document `body` object. As
    such, it works with all the form elements including the newly added ones.
  prefs: []
  type: TYPE_NORMAL
- en: The flexible plugins enable easy extension of the validator without modifications
    to the core. Adding a new validation rule is as simple as adding a new function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our error messages can have user-friendly templates filled with optional
    message strings provided by the validators.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the JavaScript files start with a semicolon character
    (`;`). This makes them safer for concatenation and minification. If we prepend
    a script that ends with a value (treated as a function call while the entire contents
    of the script without a semicolon) to another that is wrapped within parenthesis,
    the value will be will be treated as an argument to that function call. To avoid
    this, we prepend a semicolon before the parenthesis, terminating any previous
    statements that may be missing a semicolon.
  prefs: []
  type: TYPE_NORMAL
