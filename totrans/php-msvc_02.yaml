- en: Chapter 2. Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start building our application based on microservices
    now that we know why microservices are necessary for the development of our application
    and the advantages we can enjoy if we base the application on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The application that we will develop in this book (which is similar to Pokemon
    GO) is called *Finding secrets*. This application will be like a game using geolocation
    to find different secrets around the world. The entire world keeps a lot of hidden
    secrets and the players will have to find them as soon as possible. There are
    100 different kinds of secrets, and they will generate and appear in different
    parts of the world every day, so the players will be able to find them by walking
    around different areas and checking to see if there are any kind of secrets nearby.
  prefs: []
  type: TYPE_NORMAL
- en: The secrets will be saved in the application wallet and if the player finds
    a secret that they already have in their wallet, they will not be able to collect
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The players will be able to duel against other players if they are close. The
    duel consists of throwing a dice to get the highest number, and the player who
    loses will give a random secret to the other player.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapters, the specific functions will be more detailed, but
    in this chapter, we only need to know how the applications works in order to have
    a general overview of the entire application to start building the basic platform
    based on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Design and architecture to build the basic platform for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an application based on microservices is not like a monolithic application.
    For this reason, we have to divide our functionalities into different services.
    To do this, it is important to follow an adequate design and structure each of
    the microservices according to its requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The design takes care of dividing the application into logical parts and groups
    them according to their existing relationship. The architecture takes care of
    defining which concrete elements support each of the microservices, for example,
    where the data is stored or the communication between the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, we will follow the given structure for each microservice.
    In the following image, you will see the structure of one of the microservices,
    the rest of them are similar; however, some parts are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design and architecture to build the basic platform for microservices](graphics/B06142_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the requests for our microservices come from a **REVERSE PROXY** as this
    allows us to balance the load. Also, we use **NGINX** as a gateway for the **API**
    built in PHP. To reduce the load and increase the performance of PHP and **NGINX**,
    we can use a **CACHE** layer.
  prefs: []
  type: TYPE_NORMAL
- en: In case we need to execute big, resource consuming tasks, or the tasks do not
    need to be executed in a concrete time window, our **API** can use a **QUEUE** system.
  prefs: []
  type: TYPE_NORMAL
- en: In case we need to store some data, our **API** is responsible for managing
    the access and saving the data in our **DATA STORE**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we will be using containerization, a new virtualization method
    which spins ups containers instead of full virtual machines. Each container will
    have only the minimum resources and software installed to run your application.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Telemetry (it is a system that gets the stats from the container)
    and autodiscovery (it is a system that helps us to see which containers are working
    properly) to supervise the container ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements to start working on microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand why you can use PHP (especially the latest release,
    version 7) for your next project, it is time to talk about other requirements
    for the success of your microservices project.
  prefs: []
  type: TYPE_NORMAL
- en: You probably have the importance of the scalability of your application in mind,
    but how can you do it within a budget? The response is virtualization. With this
    technology, you will be wasting less resources. In the past, only one **Operating
    System** (**OS**) could be executed at a time on the same hardware, but with the
    birth of virtualization, you can have multiple OSes running concurrently. The
    greatest achievement in your project will be that you will be running more servers
    dedicated to your microservices but using less hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Given the advantages provided by the virtualization and containerization, nowadays
    using containers in the development of an application based on microservices is
    a default standard. There are multiple containerization projects, but the most
    used and supported is Docker. For this reason, this is the main requirement to
    start working with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different tools/software that we will be using in our
    Docker environment:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data storage: Percona, MySQL, PostgreSQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reverse proxy: NGINX, Fabio, Traefik,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency management: composer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing tools: PHPUnit, Behat, Selenium'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version control: Git'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Microservices Development"), *Microservices
    Development*, we will explain how to add each one to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that our main requirement is a containerization suite, we will
    explain how to install and test Docker in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker can be installed from two different channels, each one with advantages
    and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable channel**: As the name indicates, everything you install from this
    channel is fully tested and you will have the latest GA version of the Docker
    engine. This is the most reliable platform and therefore, suitable for production
    environments. Through this channel, the releases follow a version schedule with
    long testing and beta times, only to ensure that everything should work as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beta channel**: If you need to have the latest features, this is your channel.
    All the installers come with the experimental version of the Docker engine where
    bugs can be found, so it is not recommended for production environments. This
    channel is a continuation of the Docker beta program where you can provide feedback
    and there is no version schedule, so you will have more frequent releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be developing for a stable production environment, so you can forget
    about the beta channel for now as all you need is on the stable releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker was born in Linux, so the best implementation was done for this OS.
    With other OSes, such as Windows or macOS, you have two options: a native implementation
    and a toolbox installation if you cannot use the native implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On macOS, you have two options to install Docker depending on whether your machine
    matches the minimum requirements or not. With relatively new machines (OS X 10.10
    Yosemite and higher), you can install the native implementation that uses Hyperkit,
    a lightweight OS X virtualization solution built on top of **Hypervisor.Framework**.
    If you have an older machine that does not match the minimum requirements, you
    can install the Docker Toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Mac (alias, native implementation) versus Docker toolbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Docker Toolbox was the first implementation of Docker on macOS and it does
    not have a deep OS integration. It uses VirtualBox to spin a Linux virtual machine
    where Docker will be running. Using a **Virtual Machine** (**VM**) where you will
    be running all your containers has numerous problems, the most noticeable being
    the poor performance. However, it is the desired choice if your machine does not
    match the requirements for the native implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Mac is a native Mac application with a native user interface and
    auto-update capability, and it is deeply integrated with OS X native virtualization
    (Hypervisor.Framework), networking, and filesystem. This version is faster, easier
    to use, and more reliable than the Docker Toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mac must be a 2010 or newer model, with Intel's hardware support for **Memory
    Management Unit** (**MMU**) virtualization; that is, **Extended Page Tables**
    (**EPT**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS X 10.10.3 Yosemite or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox prior to version 4.3.30 must not be installed (it is incompatible
    with Docker for Mac)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker for Mac installation process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your machine passes the requirements, you can download the Docker for Mac
    from the official page, that is [https://www.docker.com/products/docker](https://www.docker.com/products/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the image downloaded on your machine, you can carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the downloaded image (called `Docker.dmg`) to open the installer.
    Once the image is mounted, you need to drag and drop the Docker app into the `Applications`
    folder:![Docker for Mac installation process](graphics/B06142_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Docker.app` may ask you for your password during the installation process
    to install and set up network components in the privileged mode.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, Docker will be available on your Launchpad and
    in your `Applications` folder. Execute the application to start Docker. Once Docker
    starts up, you will see the whale icon in your toolbar. This will be your quick
    access to settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the toolbar whale for **Preferences...** and other options:![Docker
    for Mac installation process](graphics/B06142_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **About Docker** to find out if you are running the latest version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Docker on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Docker ecosystem was developed on top of Linux, so the installation process
    on this OS is easier. In the following pages, we will only cover the installation
    on **Community ENTerprise Operating System** (**CentOS**)/**Red Hat Enterprise
    Linux** (**RHEL**) (they use yum as the package manager) and Ubuntu (uses apt
    as the package manager).
  prefs: []
  type: TYPE_NORMAL
- en: CentOS/RHEL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker can be executed on CentOS 7 and on any other binary compatible EL7 distribution
    but Docker is not tested or supported on these compatible distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The minimum requirement to install and execute Docker is to have a 64-bit OS
    and a kernel version 3.10 or higher. If you need to know your current version,
    you can open a terminal and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that it's recommended to have your OS up to date as it will avoid any potential
    kernel bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker using yum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First of all, you need to have a user with root privileges; you can log in on
    your machine as this user or use a `sudo` command on the terminal of your choice.
    In the following steps, we assume that you are using a root or privileged user
    (add sudo to the commands if you are not using a root user).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, ensure that all your existing packages are up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that your machine has the latest packages available, you need to add the
    official Docker `yum` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the yum repository to your CentOS/RHEL, you can easily install
    the Docker package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the Docker service to the startup of your OS with the `systemctl` command
    (this step is optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same `systemctl` command can be used to start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you have everything installed and running, so you can start testing and
    playing with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Post-install setup - creating a Docker group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any Docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    By making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed are the commands to create a Docker group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After these commands, you need to log out and log in again to refresh your permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ubuntu is officially supported and the main recommendation is to use an LTS
    (the last version is always recommended):'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Xenial 16.04 (LTS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu Trusty 14.04 (LTS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu Precise 12.04 (LTS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as in the previous Linux installation steps, we are assuming that you are
    using a root or privileged user to install and set up Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with other Linux distributions, a 64-bit version is required and your kernel
    version needs to be at least a 3.10\. Older kernel versions have known bugs that cause
    data loss and frequent kernel panics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check your current kernel version, open your favorite terminal and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Installing Docker using apt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First of all, ensure that you have your apt sources pointing to the Docker
    repository, especially if you have previously installed Docker from the apt. In
    addition to this, update your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your system up to date, it is time to install some required
    packages and the new GPG key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With Ubuntu, it is very easy to add the official Docker repository; you only
    need to create (or edit) the `/etc/apt/sources.list.d/docker.list` file in your
    favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of having the previous lines from old repositories, delete all
    the content and add one of the following entries. Ensure that you match your current
    Ubuntu version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, you need to update the `apt` package index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of having a previous Docker repo on your Ubuntu, you need to purge
    the old repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On Trusty and Xenial, it is recommended that you install the `linux-image-extra-*`
    kernel package that allows you to use the AFUS storage driver. To install them,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: On Precise, Docker requires a 3.13 kernel version, so ensure that you have the
    correct kernel; if your version is older, you must upgrade it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your machine will be more than ready to install Docker. It can
    be done with a single command, as with `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have everything installed and running, you can start playing and
    testing Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Common issues on Ubuntu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you see errors related to swap limits while you are using Docker, you need
    to enable memory and swap on your system. It can be done on GNU GRUB by following
    the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `/etc/default/grub` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `GRUB_CMDLINE_LINUX` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update grub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Reboot the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UFW forwarding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ubuntu comes with **Uncomplicated Firewall** (**UFW**) and if it is enabled
    on the same host as the one where you run Docker, you will need to make some adjustments
    because, by default, UFW will drop any forwarding traffic. Also, UFW will deny
    any incoming traffic, making the reach of your containers from a different host
    impossible. The Docker default port is 2376 when TLS is enabled and 2375 in other
    cases. On a clean installation, Docker runs without TLS enabled. Let's configure
    UFW!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can check if UFW is installed and enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you are sure that UFW is installed and running, you can edit the `config`
    file, `/etc/default/ufw`, with your favorite editor and set up the `DEFAULT_FORWARD_POLICY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now save and close the `config` file and, after the restart of the
    UFW, your changes will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Allowing incoming connections to the Docker port can be done with the `ufw`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: DNS server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ubuntu and its derivatives use 127.0.0.1 as the default name server in the `/etc/resolv.conf`
    file, so when you start containers with this configuration, you will see warnings
    because Docker can't use the local DNS nameserver.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to avoid these warnings you need to specify a DNS server to be used
    by Docker or disable `dnsmasq` in the `NetworkManager`. Note that disabling `dnsmasq`
    will make DNS resolutions a little bit slower.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a DNS server, you can open the `/etc/default/docker` file with your
    favorite editor and add the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `8.8.8.8` with your local DNS server. If you have multiple DNS servers,
    you can add multiple `--dns` records separated with spaces. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you have your changes saved, you need to restart the Docker daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have a local DNS server and you want to disable `dnsmasq`, open
    the `/etc/NetworkManager/NetworkManager.conf` file with your editor and comment
    out the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the changes and restart the NetworkManager and Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Post-install setup – creating a Docker group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    Making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a Docker group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After these steps, you need to log out and log in again to refresh your permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Docker on boot
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ubuntu 15.04 onwards uses the `systemd` system as its boot and service manager,
    while for versions 14.10 and the previous ones, it uses the `upstart` system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the 15.04 and up systems, you can configure the Docker daemon to start
    on boot by running the given command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the case of using older versions, the installation method automatically configures
    upstart to start the Docker daemon on boot.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Docker team has made a huge effort to bring their entire ecosystem to any
    OS and they didn''t forget about Windows. As on macOS, you have two options to
    install Docker on this OS: a toolbox and a more native option.'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker for Windows requires a 64-bit Windows 10 Pro, Enterprise, and Education
    (1511 November update, Build 10586 or later), and the `Hyper-V` package must be
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: In case your machine is running a different version, you can install the Toolbox
    that requires a 64-bit OS running at least Windows 7 and with virtualization enabled
    on the machine. As you can see, it has lighter requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that Docker for Windows requires at least a Pro/Enterprise/Education
    version and the majority of computers are sold with a different version, we will explain
    how to install Docker with the toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Docker tools use VirtualBox to spin a virtual machine that will run the
    Docker engine. The installation package can be downloaded from `https://www.docker.com/products/docker-toolbox`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the installer, you only need to double-click on the downloaded
    executable to start the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first window shown by the installer allows you to send debug information
    to Docker to improve the ecosystem. Allowing the Docker engine to send debug information
    from your development environment can help the community to find bugs and improve
    the ecosystem. The recommendation on this option is to have it enabled at least
    in your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Docker tools](graphics/B06142_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just like any other Windows installer, you can choose where it will be installed.
    In most cases, the default will be fine for your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the installer will add all the required packages and some extras
    to your machine. In this step of the installation, you can purge some non-required
    software. Some of the optional packages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker compose for Windows**:In our opinion, this is a must as we will be
    using the package in our book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kitematic for Windows:** This application is a GUI to manage your containers
    easily. If you are not comfortable with the command line, you can install this
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git for Windows:** This is another must-install package; we will be using
    Git to store and manage our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After choosing the packages we want to install, it is time for some additional
    tasks. The default selected tasks will be fine for your dev environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you only need to confirm all the setup you have done in the previous steps
    before the installation starts.
  prefs: []
  type: TYPE_NORMAL
- en: The installation can take several minutes to complete, so be patient.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the installation progresses, you may be alerted about the installation
    of an Oracle device. This is due to the fact that the tools are using VirtualBox
    to spin up a virtual machine to run the Docker engine. Install this device to
    avoid future headaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Docker tools](graphics/B06142_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have Docker installed on your Windows machine. Don't waste
    another minute and start testing and playing with your Docker ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: How to check your Docker engine, compose, and machine versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have Docker installed, you only need to open your favorite terminal
    and type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Quick example to check your Docker installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should have the Docker running and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the container in the background with `-d`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map the 8080 port of your machine to the 80 port of the container with `-p 8080:80`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a name to your container with `--name webserver-test`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the NGINX Docker image and make the container to run this image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, open your favorite browser and navigate to `http://localhost:8080`, where
    you will see a default NGINX page.
  prefs: []
  type: TYPE_NORMAL
- en: Common management tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By executing `docker ps` on your terminal, you can see the running containers.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command gives us a deeper view of the containers that are running
    on your machine, the image they are using, when they were created, the status,
    and the port mapping or the assigned name.
  prefs: []
  type: TYPE_NORMAL
- en: Once you finish playing with your container, it's time to stop it. Execute `docker
    stop webserver-test` and the container will end its life.
  prefs: []
  type: TYPE_NORMAL
- en: Oops! You need the same container again. No problem, because a simple `docker
    start webserver-test` will again spin up the container for you.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to stop and remove the container because you are not going to
    use it anymore. Executing `docker rm -f webserver-test` on your terminal will
    do the trick. Note that this command will remove the container but not the downloaded
    image we have used. For this last step, you can do a `docker rmi nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Version control – Git versus SVN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control is a tool that helps you recall the previous versions of your
    source code to check them and work with them; it is agnostic of the language or
    technology used and it is possible to use a version control in all softwares developed
    in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can categorize the versioning control tools into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized version**: Control system needs a centralized server to work
    and all developers need to be connected to it so that they synchronize and download
    the changes from it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed version**: Control system is not centralized; in other words,
    each developer has the entire management version control system on their own machine,
    so it is possible to work locally and then synchronize it with a common server
    or with each developer. **Distributed Version Control Systems** (**DVCS**) are
    faster because they need less changes on the centralized or shared server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion (SVN) is a centralized version control system and, for this reason,
    some developers think that it is the best way to work respecting the entire project,
    so the developer just needs to write and read the access controllers in one place.
  prefs: []
  type: TYPE_NORMAL
- en: The entire code is hosted in one place, so it is possible to think that this
    way, it is easier to understand SVN better than Git. The truth is that the SVN
    command line is easier and there are more GUIs available for SVN. The reason is
    clear: SVN has existed since the year 2000, and Git came 5 years later.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of SVN is that the system to number the versions is clearer;
    it uses a sequential number system (1,2,3,4...) and Git uses SHA-1 codes, which
    are more difficult to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with SVN, it is possible to get a subdirectory to work with it without
    the need of having the entire project. This is not a problem for small projects,
    but it can be difficult when you have a large project.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we will use Git for our version control. We made this decision
    because Git is definitely faster and more lightweight (it takes up 30 times less
    disk space than SVN). Also, Git became the standard version control on web development
    version control and our goal is to create an application based on microservices
    using PHP, so Git is a great solution for the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of Git are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The branches are more lightweight than SVN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is a lot of faster than SVN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is a DVCS from the start, so the developer has total control of its local
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git provides better auditory in branching and merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the subsequent chapters, we will use Git commands on our project, explaining
    each one and giving examples, but until then, let''s take a look at the basic
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to create a new repository**: Create a new folder, open it, and execute
    Git in it to create a new Git repository.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to checkout an existing repository**: Create a local copy from the repository
    executing Git clone `/path/to/repository`. If you are using a remote server (hosting
    centralized servers will be explained in the following lines), execute Git clone
    `username@host:/path/to/repository` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the Git workflow, it is necessary to know that there are three
    different trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git](graphics/B06142_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WORKING DIRECTORY**: This contains the files of your project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INDEX**: This works as the intermediate area; files will be here until they
    are committed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HEAD**: This points to the last commit done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding files to the INDEX and committing them are easy tasks. After working
    with files on your project and changing them, you have to add them to the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to add files to the INDEX**: Checking the files before adding them to
    the INDEX is recommended. You can do this by executing `git diff <file>`. It will
    show you the added and deleted lines, and some more interesting information about
    the file you modified. Once you are happy with the changes made, you can execute
    `git add <filename>` to add a specific file or add Git to all the files you have
    modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to add files to the HEAD**: Once you have included all the necessary
    files in the INDEX, you have to commit them. You can do this by executing `git
    commit -m "Commit message"` . Now the files are included in the HEAD in your local
    copy, but they are still not in the remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to send changes to the remote repository**:To send the changes included
    in your HEAD local copy to the remote repository, execute `git push origin <branch
    name>;` you can choose the branch where you want to include the changes, for example,
    master. If you did not clone an existing repository and you want to connect your
    local repository to a remote one, execute `git remote add origin <server>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The branches are used to develop isolated functions and can be merged with
    the main branch in the future. The default branch when a new repository is created
    is called master. The workflow overview will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git](graphics/B06142_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**How to create a new branch**:Once you are in the branch from where you want
    to create a new one, execute `git checkout -b new_feature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to change the branch**:You can navigate through the branches by executing
    `git checkout <branch name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to delete a branch**: You can delete a branch by executing `git branch
    -d new_feature`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to make your branch available to everyone**: A branch will not be available
    to the rest of developers until you upload your branch to the remote repository
    by executing `git push origin <branch>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to update your local copy with the changes made on the remote repository,
    you can execute `git fetch` to check if there are any new updates and then `git
    pull` to get that update.
  prefs: []
  type: TYPE_NORMAL
- en: To merge your active branch with a different branch, execute `git merge <branch>`
    and Git will attempt to fuse both branches but, sometimes, if two or more developers
    changed the same file, there could be conflicts and you will need to solve those
    conflicts manually before the merge and then put the modified files into the INDEX
    again.
  prefs: []
  type: TYPE_NORMAL
- en: If you fail, maybe you want to trash your local changes and get the ones from
    the repository again. You can do this by executing `git checkout -- <filename>`
    . In case you want to trash all your local changes and commits, execute `git fetch
    origin and git reset --hard origin/master`.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are working in a team, maybe we want to have a common repository with
    a centralized server. Remember that Git is a DVCS and it is not necessary to use
    a place to have the code centralized, but in case you want to use it for different
    reasons, we will look at the two famous ones.
  prefs: []
  type: TYPE_NORMAL
- en: The hostings provide you with a better way to manage your repository using a
    web interface.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub is the place to host the code chosen by a majority of developers. It
    is based on Git, and companies, such as Twitter and Facebook, use this service
    to put their open source projects. GitHub became the most famous source host in
    just a few years and currently, many companies ask for a candidate's GitHub repository
    before their technical interview.
  prefs: []
  type: TYPE_NORMAL
- en: This hosting is free for all developers; they can create unlimited projects
    with unlimited collaborators and only one condition; the project needs to be open
    source and public. If you want to have a private project, you will have to pay.
  prefs: []
  type: TYPE_NORMAL
- en: Having your project as public on GitHub is a good opportunity to show your project
    to the world and take advantage of the big GitHub community. It is possible to
    ask for help because there are many registered and active developers.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://github.com/](https://github.com/).
  prefs: []
  type: TYPE_NORMAL
- en: BitBucket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBucket is an alternative place to host your project. It uses Git, but you
    can use Mercurial too. The interface is pretty similar to GitHub. A great advantage
    of BitBucket is the company that makes it possible--Atlassian. It has many functionalities
    for developers included in their hosting, for example, the possibility of integrating
    other Atlassian tools or a small continuous delivery tool which allows you to
    build, test, and deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is free regardless of the project you want: public or private. The
    only limitation is that it only allows five collaborators for each project; if
    you need more people working on your project you will have to pay.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Official website**: [https://bitbucket.org/](https://bitbucket.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Version control strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are developing an application, it is important to keep your code nice
    and clean, but it is even more important when you work with other developers.
    In this section, we will give you a small introduction to the most known version
    control strategies you can use in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This strategy is the most common for developers who were previously using SVN
    (old school) or similar version controls. Like Subversion, the project is hosted
    in a central repository with a unique point of entry. This strategy does not need
    more branches except master (trunk in SVN).
  prefs: []
  type: TYPE_NORMAL
- en: Developers clone the entire project on their local machines, work on the project,
    and then they commit the changes. When they want to publish the changes, they
    execute push.
  prefs: []
  type: TYPE_NORMAL
- en: Feature branch workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the next step from centralized work. It works with a centralized repository
    also, but developers create a local feature branch in their copy and this one
    is published on the centralized repository too, so all the developers have the
    chance to participate in that feature. The branches will have descriptive names
    or number of issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this strategy, the master never contains errors, so this is a great improvement
    for continuous integration. Also, having specific branches for each feature is
    a good encapsulation to not disturb the main code base.
  prefs: []
  type: TYPE_NORMAL
- en: Gitflow workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gitflow workflow does not add more new concepts than feature branch workflow.
    It just assigns different roles for each branch. Gitflow workflow works with a
    centralized repository too, and developers create branches on it, such as feature
    branch workflow. However, the branches have a specific function, for example,
    development, release, or feature. So, the feature branches will be merged with
    a specific release and then with master. This way, it is possible to have different
    releases for the same project.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is used for large projects or projects that need releases.
  prefs: []
  type: TYPE_NORMAL
- en: Forking workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last strategy is quite different to others that we have looked at in this
    chapter. Instead of cloning a copy from the centralized server and working on
    it, this one gives a fork of that to every developer. This means that every developer
    has two copies of the project: a *private* one and the *server-side*.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the developer makes the changes they want, they are sent to the project
    maintainer to be reviewed and checked so that they do not break the project and
    then they are merged with the main repository.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is used in open source projects, so the developers cannot break
    the current project.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is really important to have a versioning system in our microservice or API.
    This allows the consumers and yourself to have a coherent system of versioning
    so that everyone can know the importance of a release or feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the version number as `MAJOR.MINOR.PATCH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAJOR` will be incremented when incompatible API changes are made, so developers
    need to trash the current API version and use the new one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MINOR` will be incremented when a new feature is added and it is compatible
    with the current code. The developer, therefore, does not need to change the entire
    API just to update the current one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH` will be incremented when a new bug fix for the current version is done.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a summary of semantic versioning, but you can find more information
    at [http://semver.org/](http://semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest benefits of using Docker and its container ecosystem is
    that you don't need to install anything else on your machine. For example, if
    you need a MySQL database, you don't need to install anything on your local dev;
    it is easier to spin a container with the version you want and start using it.
  prefs: []
  type: TYPE_NORMAL
- en: This way of developing is more flexible, therefore we will be working with Docker
    containers throughout the whole book. In this section, we will learn how to build
    a basic Docker environment; it will be our foundation and we will be improving
    and adapting this base to each of our microservices in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the folder structure of our project, we will have some root folders
    on our development machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Docker`: This folder will contain all the Docker environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source`: This folder will have the source of each of our microservices![Setting
    up a development environment for microservices](graphics/B06142_02_08.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this structure is flexible and can be changed and adapted to your
    specific requirements without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: All the required files are available on our GitHub repository, at [https://github.com/php-microservices/docker](https://github.com/php-microservices/docker),
    on the master branch with the `chapter-02` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig deeper into the Docker setup. Open your docker folder and create
    a file called `docker-compose.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These two lines indicate that we are using the latest syntax for Docker compose
    and they define a list of services that we will be spinning every time we do a
    `docker-compose up`. All our services will be added after the `services` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Autodiscovery service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autodiscovery is a mechanism in which we don't specify the endpoints of each
    of our microservices. Each one of our services use a shared registry in which
    they say that they are available. When a microservice needs to know the location
    of another microservice, it can consult our autodiscovery registry to know the
    required endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we will be using an autodiscovery mechanism to ensure that
    our microservices can be scaled easily and if a node is not healthy, we stop sending
    requests to it. Our choice for this purpose is to use Consul (by HashiCorp), a
    very small application that we can add to our project. The main role for our Consul
    container is to keep everything in order, keeping a list of the available and
    healthy services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the project by opening your `docker-compose.yml` file with your
    favorite IDE/editor and adding the next piece of code just after the `services:`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In a Docker compose file, the syntax is very easy to understand and always follows
    the same flow. The first line defines a container type (it is like a class name
    for devs); in our case it is `autodiscovery`, and inside this container type we
    can specify several options to adapt the container to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `build: ./autodiscovery/`, we are telling Docker where it can find a Dockerfile
    that describes what we want in our container in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mem_limit: 128m` sentence will limit the memory consumption of any container
    of the `autodiscovery` type to not more than 128 Mb. Note that this instruction
    is optional.'
  prefs: []
  type: TYPE_NORMAL
- en: Each container needs different ports open and, by default, when you spin a container,
    none of them are open. For this reason, you need to specify which ports you want
    open for each container. For example, a container with a web server will need
    the `port 80` open but for a container that runs MySQL, the required port may
    be `3306`. In our case, we are opening the ports `53`, `8300`, `8301`, `8302`,
    `8400`, and `8500` for each one of our `autodiscovery` containers.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to reach the container on one of the opened ports, it will not work.
    The container ecosystem resides in a separate network and you can only access
    it if you create a bridge between your environment and the Docker network. Our
    `autodiscovery` container runs Consul and it has a nice web UI on port `8500`.
    We want to be able to use this UI; so, when we use `ports`, we are mapping our
    local `8500` port to the container `8500` port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to create a new folder called `autodiscovery` in the same path
    of your `docker-compose.yml file`. Inside this new folder, place a file called
    `Dockerfile` with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This small sentence inside the `Dockerfile` indicates that we are using a Docker
    `consul` image with tag `v0.7.0`. This image will be fetched from the official
    Docker hub, a repository for container images.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, doing a `$ docker-compose up` will spin up a Consul machine,
    give it a try. Since we didn't specify the `-d` option, the Docker engine will
    output all the logs to your terminal. You can stop your container with a simple
    *CTRL*+*C*. When you add the `-d` option, the Docker compose runs as a daemon
    and returns the prompt; you can do a `$ docker-compose stop` to stop the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice base core - NGINX and PHP-FPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP-FPM is an alternative to the old way of executing PHP in our web server.
    The main benefit of using PHP-FPM is its small memory footprint and the high performance
    under hight loads. The best web server you can find nowadays to run your PHP-FPM
    is NGINX, a very light web server and reverse proxy used in the most important
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application will be using an autodiscovery pattern, we need an easy
    way of dealing with the service registering, deregistering, and health check.
    One of the simplest and fastest applications you can use is ContainerPilot, a
    small micro-orchestration application created by Joyent that works with your favorite
    container scheduler, in our case Docker compose. This small app is being executed
    as PID 1 and forks the application we want to run inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: We will be working with ContainerPilot because it relieves the developer of
    dealing with the autodiscovery, so we need to have the latest version on each
    container we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start defining our base `php-fpm` container. Open the `docker-compose.yml`
    and add a new service for the `php-fpm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are defining a new service and one interesting attribute
    is links. This attribute defines which other containers our service can see or
    connect. In our example, we want to link this type of container to any `autodiscovery` container.
    Without this explicit definition, our `fpm` container won't see the `autodiscovery`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `microservices/base/php-fpm/Dockerfile` file on your IDE/editor
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What we have done on this file is tell Docker how it needs to create our `php-fpm`
    container. The first line declares the official version we want to use as a foundation
    for our container, in this case php7 fpm. Once the image is downloaded, the first
    `RUN` line will add all the extra `PHP` packages we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: The two `RUN` sentences will add bespoke PHP configurations; feel free to adapt
    these lines to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the PHP tasks are done, it is time to install a small application on
    the container that will help us to deal with templates--`consul-template`. This
    application is used to build configuration templates on the fly using the information
    we have stored on our Consul service.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, we are using ContainerPilot. So, after the `consul-template`
    installation, we are telling Docker how to install this application.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, Docker finishes installing all the required packages and copies
    some configuration and shell scripts needed by ContainerPilot
  prefs: []
  type: TYPE_NORMAL
- en: The last line starts ContainerPilot as PID 1 and forks `php-fpm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explain the configuration file required by ContainerPilot. Open
    your IDE/editor and create the `microservices/base/php-fpm/config/containerpilot.json`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This JSON configuration file is very easy to understand. First, it defines where
    we can find our Consul container and which command we want to run on the ContainerPilot
    preStart event. In `services`, you can define all the services you want to declare
    that the current container is running. On the `backends`, you can define all the
    services you are listening for changes. In our case, we are listening for changes
    to services called `microservice_base_nginx` (the `BACKEND` variable is defined
    on the `docker-compose.yml`). If something changes on Consul on these services,
    we will execute the `onChange` command in the container.
  prefs: []
  type: TYPE_NORMAL
- en: For a more information about ContainerPilot, you can visit the official page,
    that is, [https://www.joyent.com/containerpilot](https://www.joyent.com/containerpilot).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the `microservices/base/php-fpm/scripts/reload.sh` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a dummy script, but it is up to you to adapt it to your requirements.
    For example, it can be changed to `run execute consul-template` and rebuild the
    NGINX configuration once ContainerPilot fires the script. We will be explaining
    a more complex script later.
  prefs: []
  type: TYPE_NORMAL
- en: We have our base `php-fpm` container ready, but our basic environment can't
    be complete without a web server. We will be using NGINX, a very light and powerful
    reverse proxy and web server.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will build our NGINX server is very similar to the `php-fpm`, so
    we will only explain the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that all the files are available in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a new service definition for NGINX to the `docker-compose.yml`
    file and link it to our `autodiscovery` service and also to our `php-fpm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `microservices/base/nginx/config/containerpilot.json`, we now have a
    new option `telemetry`. This config setting allows us to specify a remote telemetry
    service used to collect stats from our service. Having this kind of service included
    in our environment allows us to see how our containers are performing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use a bespoke bash script to obtain the container stats,
    and the content of our `microservices/base/nginx/scripts/sensor.sh` script is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This bash script gets some `nginx` stats that we will be sending to our `telemetry`
    server with ContainerPilot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `microservices/base/nginx/scripts/reload.sh` is a little more complex than
    the one we created before for `php-fpm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use `consul-template` to rebuild our NGINX config on the
    startup or when ContainerPilot detects a change in the list of backend services
    we will be monitoring. This behavior allows us to stop sending requests to unhealthy
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have our base environment ready and we are ready to test it
    with a simple `$ docker-compose up`. We will be using all these pieces to create
    bigger and more complex services. In the upcoming chapters, we will be adding
    the telemetry service or a data storage among others.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A framework is a skeleton that we can use for sofware development. Using a framework
    will help us use standard and robust patterns in our application, making it more
    stable and well known by other developers. PHP has many different frameworks you
    can use in your daily work. We will see some standards used on the most common
    frameworks so that you can pick the best for your project.
  prefs: []
  type: TYPE_NORMAL
- en: PHP-FIG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For years, the PHP community has been working on their own projects and following
    their own rules. Thousands of different projects with different developers have
    been released since the first years of PHP, and none followed any common standards.
  prefs: []
  type: TYPE_NORMAL
- en: This was a problem for PHP developers, firstly because there was no way of knowing
    if the steps they were following to build applications were the correct ones.
    Only their own experience and the Internet could help the developer guess if their
    code was written properly and if it would be readable by other developers in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the developers felt that they were trying to reinvent the wheel. Developers
    were making the same existing applications for their projects because there was
    no standard to fit third-party application into their projects.
  prefs: []
  type: TYPE_NORMAL
- en: In 2009, the **PHP Framework Interoperability Group** (**PHP-FIG**) was born
    with the main goal of creating a unique standard for development in PHP. PHP-FIG
    is a big community of members that works on the **PHP Standards Recommendation **(**PSR**),
    discussing what the best way to use the PHP language is.
  prefs: []
  type: TYPE_NORMAL
- en: PHP-FIG is supported by big projects such as Drupal, Magento, Joomla!, Phalcon,
    CakePHP, Yii, Zend, and Symfony and that is the reason the PSRs they propose are
    implemented by the PHP frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Some standards, such as PSR-1 and PSR-2, are about the use of code and its style
    (using tabs or spaces, opening tags of PHP, using camelCasing or filenames) and
    others are about the autoloading (PSR-0 and then PSR-4). Since PHP 5.3, namespaces
    were included and it was the most important thing to implement `autoloading`.
  prefs: []
  type: TYPE_NORMAL
- en: The `autoloading` was possibly one of the most important improvements to PHP.
    Before PHP-FIG, frameworks had their own methods to implement the autoloading,
    their own way to format them, initialize them, and name them, and each one was
    different, so it was a disaster (Java already solved this problem using its beans
    system).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Composer implemented autoloading, which was written by PHP-FIG. So,
    developers don't need to worry about `require_once()`, `include_once()`, `require()`,
    or `include()` anymore.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about PHP-FIG at [http://www.php-fig.org/](http://www.php-fig.org/).
  prefs: []
  type: TYPE_NORMAL
- en: PSR-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we will use the **PHP Standard Recommendation 7** (**PSR-7**).
    It is about the HTTP messages interfaces. This is the essence of web development;
    it is the way to communicate with a server. An HTTP client or web browser sends
    an HTTP request message to a server and it replies with an HTTP response message.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of messages are hidden from normal users, but developers need to
    know the structure to manipulate them. The PSR-7 talks about the recommended ways
    to manipulate them, doing it simply and clearly.
  prefs: []
  type: TYPE_NORMAL
- en: We will use HTTP messages to communicate with microservices, so it is necessary
    to know how they work and what their structure is.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP request has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the request, there are all the necessary things to allow the server to understand
    the request message and to be able to reply with a response. In the first line,
    we can see the method used for the request (`GET`, `POST`, `PUT`, `DELETE`), the
    request target, and the HTTP protocol version, and then one or more HTTP headers,
    an empty line, and the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the HTTP response will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response body. The response has the HTTP protocol version, such
    as the request and the HTTP status code, followed by a text to describe the code.
    You will find all the available status codes in the next chapters. The rest of
    the lines are like the request: one or more HTTP headers, an empty line, and then
    the body.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we know the structure of HTTP request messages and HTTP response messages,
    we will understand what the recommendations of PHP-FIG on PSR-7 are.
  prefs: []
  type: TYPE_NORMAL
- en: Messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any message is an HTTP request message (RequestInterface) or an HTTP response
    message (ResponseInterface). They extend MessageInterface and may be implemented
    directly. Implementors should implement RequestInterface and ResponseInterface.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Case-insensitive for header field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Headers with multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Host header
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Usually, the host header is the same as the host component of the URI and the
    host used when establishing the TCP connection, but it can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestInterface::withUri()` will replace the request host header.'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep the original state of the host by passing true for the second argument;
    it will keep the host header unless the message does not have a host header.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: StreamInterface is used to hide the implementation details when a stream of
    data is read or written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams expose their capabilities using the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Request targets and URIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A request target is in the second segment of the request line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `getRequestTarget()` method will use the URI object to make the origin-form
    (the most common request-target).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `withRequestTarget()`, the user can use the other three options. For
    example, an asterisk-form, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP request will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Server-side requests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RequestInterface gives the general representation for an HTTP request, but
    the server-side requests needs to be processed into an account **Common Gateway
    Interface** (**CGI**). PHP provides simplification via its superglobals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: ServerRequestInterface provides an abstraction around these superglobals to
    reduce coupling to the superglobals by consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Uploaded files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `$_FILES` superglobal has some well-known problems when working with arrays
    or file inputs. For example, with the input name `files`, submitting files[`0`]
    and files[`1`], PHP will be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So, the customers need to know these kinds of problems and write code to fix
    the given data.
  prefs: []
  type: TYPE_NORMAL
- en: '`getUploadedFiles()` provides the normalized structure for consumers.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detailed information and the interfaces and classes that we
    discussed at [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/).
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A middleware is a *mechanism to filter the HTTP requests on an application*;
    it allows you to add additional layers to the business logic. It executes before
    and after the piece of code we want to reach to handle input and output communication.
    The middleware uses the recommendations on PSR-7 to modify the HTTP requests.
    This is the reason PSR-7 and middleware are united.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common example of middleware is on the authentication. In an application
    where it is necessary to log in to get user privileges, the middleware will decide
    if the user can see specific content of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Middleware](graphics/B06142_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we can see a typical PSR-7 HTTP **REQUEST** and **RESPONSE** with
    two **MIDDLEWARE**. Usually, you will see the middleware implementations as lambda
    (λ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take a look at some examples of typical implementations of middlewares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `request` and `response` are the objects, and the last param `$next` is
    the name of the next middleware to call. If the middleware is the last one, you
    can leave it empty. In the code, we can see three different parts: the first one
    is to modify and do things before the next middleware, in the second one the middleware
    calls the next middleware (if it exists), and the third one is to modify and do
    things after the previous middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to see the code before and after the `$next`(`$request`,
    `$response`) form as onion layers around the middleware, but it is necessary to
    be on the ball regarding the order of execution of the middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: Another good practice is looking at the real application (the part of code the
    middlewares reach, usually a controller function) as a middleware too, because
    it receives a request and a response and it has to return a response, but this
    time without the next param because it is the last one; however, the execution
    continues after this. This is the reason we have to look at the end code in the
    same way as the last middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a complete example to understand how you can use it on your application
    based on microservices. As we saw in the preceding image, there were two middlewares,
    we will call them first and second, and then the end function will be called endfunction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Every framework has its own middleware handler, but each one works very similarly.
    The middleware handler is used to manage the stack, so you can add more middleware
    on it and they will be called sequentially. This is a generic middleware handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution track will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests a specific path to the server. For example, `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `first` middleware is executed adding `word` equals to `hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `first` middleware sends the execution to `second`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `second` middleware adds the sentence `word: hello`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `second` middleware sends the execution to the `end` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `end` function adds the sentence `function reached` and finishes its own
    job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution continues by the `second` middleware and this one sets the HTTP
    status 200 to response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution continues by the `first` middleware and this one adds a custom
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is returned to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, if you get an error during the middleware execution, you can manage
    it using the following common code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The response will be sent immediately to the user without ending the entire
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Available frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are hundreds of frameworks available to develop your application, but
    when you need one to be used to make microframeworks, it is necessary to look
    for some characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A microframework able to process the maximum requests per second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight in terms of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is possible, with a great community developing applications for that framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will look at possibly the five most-used frameworks at the moment. Finding
    the best framework is not a unique opinion, every developer has their own opinion,
    so let me introduce you to the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Framework** | **Request per second** | **Peak memory** |'
  prefs: []
  type: TYPE_TB
- en: '| Phalcon 2.0 | 1,746.90 | 0.27 |'
  prefs: []
  type: TYPE_TB
- en: '| Slim 2.6 | 880.24 | 0.47 |'
  prefs: []
  type: TYPE_TB
- en: '| Lumen 5.1 | 412.36 | 0.95 |'
  prefs: []
  type: TYPE_TB
- en: '| Zend Expressive 1.0 | 391.97 | 0.80 |'
  prefs: []
  type: TYPE_TB
- en: '| Silex 1.3 | 383.66 | 0.86 |'
  prefs: []
  type: TYPE_TB
- en: '**Source**: *PHP Framework Benchmark*. The project attempts to measure minimum
    overhead PHP frameworks in the real world.'
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Phalcon is a popular framework, it gained fame because its speed made it the
    fastest framework. Phalcon is very optimized and modular; in other words, it only
    uses the things that you need or want, without adding extra things that you won't use.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is excellent, but its disadvantage is that the community is
    not as big as Silex or Slim, so the third-parties' community is small and it is
    sometimes a little difficult to find fast solutions when you have issues.
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon ORM is based on the C language. This is really important if you are
    developing a microservice based on databases.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, it is the best framework; however, it is not recommended for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://phalconphp.com](https://phalconphp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Slim framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Slim is one of the fastest micro RESTful frameworks available. It provides
    you with every feature that a framework should have. Also, Slim framework has
    a very big community: you can find a lot of resources, tutorials, and documentation
    on the Internet because there are a lot of developers using it.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the release of version 3, the framework has a better architecture, making
    it better in terms of overall architecture and security. This new version is a
    little slower than version 2, but all the introduced changes make this framework
    suitable for projects of all sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is not bad, but it could be better. It is too short.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good microframework for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official website at [http://www.slimframework.com/](http://www.slimframework.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Lumen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lumen is one of the fastest micro RESTful frameworks made by Laravel. This microframework
    was specially made to work with ultra fast microservices and APIs. Lumen is really
    fast, but there are some microframeworks that are faster, such as Slim, Silex,
    and Phalcon.
  prefs: []
  type: TYPE_NORMAL
- en: This framework became famous because it was pretty similar to CodeIgniter syntax,
    and it is very easy to use, so maybe this is why Lumen is the best microframework
    to start working with microservices using a microframework. Also, Lumen has very
    good and clear documentation; you can find it at [https://lumen.laravel.com/docs](https://lumen.laravel.com/docs).
    If you use this framework, you can start to work in little time as the setup is
    really fast.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantages of Lumen is that you can start working with it and then,
    if you need the complete Laravel in the future, it is very easy to transform and
    update the framework into Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Lumen still enforces an application structure (convention over
    configuration) that might limit your options when you design your application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to use Lumen, it is because you have used Laravel and you liked
    it; if you do not like Laravel, Lumen is not the best solution for you.
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://lumen.laravel.com/](https://lumen.laravel.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Zend Expressive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lumen is the equivalent of Laravel and Zend Expressive is for Zend Framework.
    It is a microframework built to make microservices and is prepared to be used
    exclusively following PSR-7 and based on middleware.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to set it up in a few minutes and you have all the advantages
    of Zend Framework on it in terms of community. Also, being a product of Zend is
    a synonym of quality and security.
  prefs: []
  type: TYPE_NORMAL
- en: It comes with a minimal core and you can choose what components you want to
    include. It has very good flexibility and ability to extend it too.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the official website at [https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/).
  prefs: []
  type: TYPE_NORMAL
- en: Silex (based on Symfony)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Silex is also a very good micro RESTful PHP framework. It is one of the five fastest
    microframeworks and currently, it is one of the best known because the Silex community
    is one of the bigger ones and they develop really good third parties, so developers
    have many solutions for their projects.
  prefs: []
  type: TYPE_NORMAL
- en: The community and its connection to Symfony guarantee stable implementation
    with many available resources. Also, the documentation is really good, and this
    microframework is specially good for large projects.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Silex and Slim Framework are pretty similar; maybe the competition
    made them better.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official website at [http://silex.sensiolabs.org/](http://silex.sensiolabs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we talked about what we are going to build in this book as an
    example application. We also showed you how you can set up your development machine
    using Docker, and we even talked about the different microframeworks you can use
    .In the next chapter, we will learn how to go about designing our application
    and different types of microservices patterns.
  prefs: []
  type: TYPE_NORMAL
