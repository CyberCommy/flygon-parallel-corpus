- en: Chapter 2. Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开发环境
- en: In this chapter, we will start building our application based on microservices
    now that we know why microservices are necessary for the development of our application
    and the advantages we can enjoy if we base the application on microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建基于微服务的应用程序，现在我们知道为什么微服务对于应用程序的开发是必要的，以及如果我们基于微服务构建应用程序可以享受到的优势。
- en: The application that we will develop in this book (which is similar to Pokemon
    GO) is called *Finding secrets*. This application will be like a game using geolocation
    to find different secrets around the world. The entire world keeps a lot of hidden
    secrets and the players will have to find them as soon as possible. There are
    100 different kinds of secrets, and they will generate and appear in different
    parts of the world every day, so the players will be able to find them by walking
    around different areas and checking to see if there are any kind of secrets nearby.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中开发的应用程序（类似于Pokemon GO）被称为“寻找秘密”。这个应用程序将像一个使用地理位置信息来寻找世界各地不同秘密的游戏。整个世界都隐藏着许多秘密，玩家们必须尽快找到它们。有100种不同类型的秘密，它们每天会在世界的不同地方生成和出现，因此玩家可以通过在不同地区四处走动并检查附近是否有任何类型的秘密来找到它们。
- en: The secrets will be saved in the application wallet and if the player finds
    a secret that they already have in their wallet, they will not be able to collect
    it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密将保存在应用程序钱包中，如果玩家发现他们已经拥有的秘密，他们将无法收集它。
- en: The players will be able to duel against other players if they are close. The
    duel consists of throwing a dice to get the highest number, and the player who
    loses will give a random secret to the other player.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以在附近与其他玩家进行决斗。决斗包括掷骰子以获得最高点数，输掉的玩家将向另一名玩家随机透露一个秘密。
- en: In the subsequent chapters, the specific functions will be more detailed, but
    in this chapter, we only need to know how the applications works in order to have
    a general overview of the entire application to start building the basic platform
    based on microservices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，具体功能将更加详细，但在本章中，我们只需要了解应用程序的工作方式，以便对整个应用程序有一个总体概述，从而开始构建基于微服务的基本平台。
- en: Design and architecture to build the basic platform for microservices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于构建微服务基本平台的设计和架构
- en: Creating an application based on microservices is not like a monolithic application.
    For this reason, we have to divide our functionalities into different services.
    To do this, it is important to follow an adequate design and structure each of
    the microservices according to its requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于微服务的应用程序不像单片应用程序。因此，我们必须将功能划分为不同的服务。为此，根据其要求，按照适当的设计和结构每个微服务是很重要的。
- en: The design takes care of dividing the application into logical parts and groups
    them according to their existing relationship. The architecture takes care of
    defining which concrete elements support each of the microservices, for example,
    where the data is stored or the communication between the services.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计负责将应用程序分成逻辑部分，并根据它们的现有关系对它们进行分组。架构负责定义哪些具体元素支持每个微服务，例如数据存储位置或服务之间的通信。
- en: 'Throughout the book, we will follow the given structure for each microservice.
    In the following image, you will see the structure of one of the microservices,
    the rest of them are similar; however, some parts are optional:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将遵循每个微服务的给定结构。在下图中，您将看到一个微服务的结构，其余的微服务类似；但是，有些部分是可选的：
- en: '![Design and architecture to build the basic platform for microservices](graphics/B06142_02_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![用于构建微服务基本平台的设计和架构](graphics/B06142_02_01.jpg)'
- en: All the requests for our microservices come from a **REVERSE PROXY** as this
    allows us to balance the load. Also, we use **NGINX** as a gateway for the **API**
    built in PHP. To reduce the load and increase the performance of PHP and **NGINX**,
    we can use a **CACHE** layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有微服务的请求都来自反向代理，因为这样可以平衡负载。此外，我们使用NGINX作为PHP构建的API的网关。为了减少负载并提高PHP和NGINX的性能，我们可以使用缓存层。
- en: In case we need to execute big, resource consuming tasks, or the tasks do not
    need to be executed in a concrete time window, our **API** can use a **QUEUE** system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行大型、消耗资源的任务，或者任务不需要在具体时间窗口内执行，我们的API可以使用队列系统。
- en: In case we need to store some data, our **API** is responsible for managing
    the access and saving the data in our **DATA STORE**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要存储一些数据，我们的API负责管理访问并将数据保存在我们的数据存储中。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will be using containerization, a new virtualization method
    which spins ups containers instead of full virtual machines. Each container will
    have only the minimum resources and software installed to run your application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用容器化，这是一种新的虚拟化方法，它会启动容器而不是完整的虚拟机。每个容器只会安装运行应用程序所需的最低资源和软件。
- en: We can use Telemetry (it is a system that gets the stats from the container)
    and autodiscovery (it is a system that helps us to see which containers are working
    properly) to supervise the container ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用遥测（它是一个从容器获取统计数据的系统）和自动发现（它是一个帮助我们查看哪些容器正常工作的系统）来监督容器生态系统。
- en: Requirements to start working on microservices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用微服务的要求
- en: Now that you understand why you can use PHP (especially the latest release,
    version 7) for your next project, it is time to talk about other requirements
    for the success of your microservices project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了为什么可以使用PHP（特别是最新版本7）来进行下一个项目，是时候谈谈您的微服务项目成功的其他要求了。
- en: You probably have the importance of the scalability of your application in mind,
    but how can you do it within a budget? The response is virtualization. With this
    technology, you will be wasting less resources. In the past, only one **Operating
    System** (**OS**) could be executed at a time on the same hardware, but with the
    birth of virtualization, you can have multiple OSes running concurrently. The
    greatest achievement in your project will be that you will be running more servers
    dedicated to your microservices but using less hardware.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Given the advantages provided by the virtualization and containerization, nowadays
    using containers in the development of an application based on microservices is
    a default standard. There are multiple containerization projects, but the most
    used and supported is Docker. For this reason, this is the main requirement to
    start working with microservices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different tools/software that we will be using in our
    Docker environment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data storage: Percona, MySQL, PostgreSQL'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reverse proxy: NGINX, Fabio, Traefik,'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency management: composer'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing tools: PHPUnit, Behat, Selenium'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version control: Git'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Microservices Development"), *Microservices
    Development*, we will explain how to add each one to our project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that our main requirement is a containerization suite, we will
    explain how to install and test Docker in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker can be installed from two different channels, each one with advantages
    and disadvantages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable channel**: As the name indicates, everything you install from this
    channel is fully tested and you will have the latest GA version of the Docker
    engine. This is the most reliable platform and therefore, suitable for production
    environments. Through this channel, the releases follow a version schedule with
    long testing and beta times, only to ensure that everything should work as expected.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beta channel**: If you need to have the latest features, this is your channel.
    All the installers come with the experimental version of the Docker engine where
    bugs can be found, so it is not recommended for production environments. This
    channel is a continuation of the Docker beta program where you can provide feedback
    and there is no version schedule, so you will have more frequent releases.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be developing for a stable production environment, so you can forget
    about the beta channel for now as all you need is on the stable releases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker was born in Linux, so the best implementation was done for this OS.
    With other OSes, such as Windows or macOS, you have two options: a native implementation
    and a toolbox installation if you cannot use the native implementation.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on macOS
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On macOS, you have two options to install Docker depending on whether your machine
    matches the minimum requirements or not. With relatively new machines (OS X 10.10
    Yosemite and higher), you can install the native implementation that uses Hyperkit,
    a lightweight OS X virtualization solution built on top of **Hypervisor.Framework**.
    If you have an older machine that does not match the minimum requirements, you
    can install the Docker Toolbox.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Mac (alias, native implementation) versus Docker toolbox
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Docker Toolbox was the first implementation of Docker on macOS and it does
    not have a deep OS integration. It uses VirtualBox to spin a Linux virtual machine
    where Docker will be running. Using a **Virtual Machine** (**VM**) where you will
    be running all your containers has numerous problems, the most noticeable being
    the poor performance. However, it is the desired choice if your machine does not
    match the requirements for the native implementation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Mac is a native Mac application with a native user interface and
    auto-update capability, and it is deeply integrated with OS X native virtualization
    (Hypervisor.Framework), networking, and filesystem. This version is faster, easier
    to use, and more reliable than the Docker Toolbox.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Mac上的Docker是一个本地Mac应用程序，具有本地用户界面和自动更新功能，并且与OS X本地虚拟化（Hypervisor.Framework）、网络和文件系统深度集成。这个版本比Docker
    Toolbox更快、更易于使用，更可靠。
- en: Minimum requirements
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: Mac must be a 2010 or newer model, with Intel's hardware support for **Memory
    Management Unit** (**MMU**) virtualization; that is, **Extended Page Tables**
    (**EPT**)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac必须是2010年或更新的型号，具有英特尔硬件对**内存管理单元**（**MMU**）虚拟化的支持；也就是**扩展页表**（**EPT**）。
- en: OS X 10.10.3 Yosemite or newer
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS X 10.10.3 Yosemite或更新版本
- en: At least 4 GB of RAM
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少4GB的RAM
- en: VirtualBox prior to version 4.3.30 must not be installed (it is incompatible
    with Docker for Mac)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装Docker for Mac之前，不能安装VirtualBox 4.3.30之前的版本（它与Mac上的Docker不兼容）
- en: Docker for Mac installation process
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mac上的Docker安装过程
- en: If your machine passes the requirements, you can download the Docker for Mac
    from the official page, that is [https://www.docker.com/products/docker](https://www.docker.com/products/docker).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器符合要求，你可以从官方页面下载Mac上的Docker，即[https://www.docker.com/products/docker](https://www.docker.com/products/docker)。
- en: 'Once you have the image downloaded on your machine, you can carry out the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的机器上下载了镜像，你可以执行以下步骤：
- en: Double-click on the downloaded image (called `Docker.dmg`) to open the installer.
    Once the image is mounted, you need to drag and drop the Docker app into the `Applications`
    folder:![Docker for Mac installation process](graphics/B06142_02_02.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下载的镜像（名为`Docker.dmg`）以打开安装程序。一旦镜像被挂载，你需要将Docker应用程序拖放到`Applications`文件夹中：![Mac上的Docker安装过程](graphics/B06142_02_02.jpg)
- en: The `Docker.app` may ask you for your password during the installation process
    to install and set up network components in the privileged mode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker.app`在安装过程中可能会要求你输入密码，以特权模式安装和设置网络组件。'
- en: Once the installation is complete, Docker will be available on your Launchpad and
    in your `Applications` folder. Execute the application to start Docker. Once Docker
    starts up, you will see the whale icon in your toolbar. This will be your quick
    access to settings.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Docker将出现在你的Launchpad和`Applications`文件夹中。执行该应用程序以启动Docker。一旦Docker启动，你将在工具栏中看到鲸鱼图标。这将是你快速访问设置的方式。
- en: Click on the toolbar whale for **Preferences...** and other options:![Docker
    for Mac installation process](graphics/B06142_02_03.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏上的鲸鱼图标以获取**首选项...**和其他选项：![Mac上的Docker安装过程](graphics/B06142_02_03.jpg)
- en: Click on **About Docker** to find out if you are running the latest version.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**关于Docker**以查看你是否在运行最新版本。
- en: Installing Docker on Linux
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux上安装Docker
- en: The Docker ecosystem was developed on top of Linux, so the installation process
    on this OS is easier. In the following pages, we will only cover the installation
    on **Community ENTerprise Operating System** (**CentOS**)/**Red Hat Enterprise
    Linux** (**RHEL**) (they use yum as the package manager) and Ubuntu (uses apt
    as the package manager).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统是在Linux上开发的，因此在这个操作系统上的安装过程更容易。在接下来的页面中，我们将只涵盖在**Community ENTerprise
    Operating System**（**CentOS**）/**Red Hat Enterprise Linux**（**RHEL**）（它们使用yum作为包管理器）和Ubuntu（使用apt作为包管理器）上的安装。
- en: CentOS/RHEL
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CentOS/RHEL
- en: Docker can be executed on CentOS 7 and on any other binary compatible EL7 distribution
    but Docker is not tested or supported on these compatible distributions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以在CentOS 7上执行，也可以在任何其他二进制兼容的EL7发行版上执行，但Docker在这些兼容的发行版上没有经过测试或支持。
- en: Minimum requirements
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: 'The minimum requirement to install and execute Docker is to have a 64-bit OS
    and a kernel version 3.10 or higher. If you need to know your current version,
    you can open a terminal and execute the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和执行Docker的最低要求是拥有64位操作系统和3.10或更高版本的内核。如果你需要知道你当前的版本，你可以打开终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that it's recommended to have your OS up to date as it will avoid any potential
    kernel bugs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，建议你的操作系统保持最新，以避免任何潜在的内核错误。
- en: Installing Docker using yum
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用yum安装Docker
- en: First of all, you need to have a user with root privileges; you can log in on
    your machine as this user or use a `sudo` command on the terminal of your choice.
    In the following steps, we assume that you are using a root or privileged user
    (add sudo to the commands if you are not using a root user).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要有一个具有root权限的用户；你可以以这个用户登录你的机器，或者在你选择的终端上使用`sudo`命令。在接下来的步骤中，我们假设你正在使用一个root或特权用户（如果你没有使用root用户，请在命令中添加sudo）。
- en: 'First of all, ensure that all your existing packages are up to date:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保你所有现有的包都是最新的：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that your machine has the latest packages available, you need to add the
    official Docker `yum` repository:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的机器已经有了最新的可用包，你需要添加官方Docker `yum`存储库：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After adding the yum repository to your CentOS/RHEL, you can easily install
    the Docker package with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在将yum存储库添加到你的CentOS/RHEL之后，你可以使用以下命令轻松安装Docker包：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can add the Docker service to the startup of your OS with the `systemctl` command
    (this step is optional):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`systemctl`命令将Docker服务添加到你的操作系统的启动中（这一步是可选的）：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same `systemctl` command can be used to start the service:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`systemctl`命令可以用来启动服务：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you have everything installed and running, so you can start testing and
    playing with Docker.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装并运行了所有东西，所以你可以开始测试和玩Docker了。
- en: Post-install setup - creating a Docker group
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后设置 - 创建Docker组
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any Docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    By making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker作为绑定到Unix套接字的守护程序执行。此套接字由root拥有，因此其他用户访问它的唯一方式是使用`sudo`命令。每次使用任何Docker命令都要使用`sudo`命令可能很痛苦，但您可以创建一个名为`docker`的Unix组，并将用户分配给该组。通过进行这个小改变，Docker守护程序将启动并将Unix套接字的所有权分配给这个新组。
- en: 'Listed are the commands to create a Docker group:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建Docker组的命令：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After these commands, you need to log out and log in again to refresh your permissions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这些命令后，您需要注销并重新登录以刷新权限。
- en: Installing Docker on Ubuntu
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Docker
- en: 'Ubuntu is officially supported and the main recommendation is to use an LTS
    (the last version is always recommended):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu得到官方支持，主要建议使用LTS（始终建议使用最新版本）：
- en: Ubuntu Xenial 16.04 (LTS)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Xenial 16.04（LTS）
- en: Ubuntu Trusty 14.04 (LTS)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Trusty 14.04（LTS）
- en: Ubuntu Precise 12.04 (LTS)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Precise 12.04（LTS）
- en: Just as in the previous Linux installation steps, we are assuming that you are
    using a root or privileged user to install and set up Docker.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的Linux安装步骤一样，我们假设您是使用root或特权用户来安装和设置Docker。
- en: Minimum requirements
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最低要求
- en: As with other Linux distributions, a 64-bit version is required and your kernel
    version needs to be at least a 3.10\. Older kernel versions have known bugs that cause
    data loss and frequent kernel panics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Linux发行版一样，需要64位版本，并且您的内核版本至少需要3.10。较旧的内核版本存在已知的错误，会导致数据丢失和频繁的内核崩溃。
- en: 'To check your current kernel version, open your favorite terminal and run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前的内核版本，请打开您喜欢的终端并运行：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Docker using apt
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用apt安装Docker
- en: 'First of all, ensure that you have your apt sources pointing to the Docker
    repository, especially if you have previously installed Docker from the apt. In
    addition to this, update your system:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您的apt源指向Docker存储库，特别是如果您之前是通过apt安装Docker。另外，更新您的系统：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that you have your system up to date, it is time to install some required
    packages and the new GPG key:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的系统已经更新，是时候安装一些必需的软件包和新的GPG密钥了：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With Ubuntu, it is very easy to add the official Docker repository; you only
    need to create (or edit) the `/etc/apt/sources.list.d/docker.list` file in your
    favorite editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，很容易添加官方Docker存储库；您只需要在您喜欢的编辑器中创建（或编辑）`/etc/apt/sources.list.d/docker.list`文件。
- en: 'In the case of having the previous lines from old repositories, delete all
    the content and add one of the following entries. Ensure that you match your current
    Ubuntu version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的旧存储库中有上述行，请删除所有内容并添加以下条目之一。确保与您当前的Ubuntu版本匹配：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After saving the file, you need to update the `apt` package index:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，您需要更新`apt`软件包索引：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of having a previous Docker repo on your Ubuntu, you need to purge
    the old repo:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Ubuntu上有以前的Docker存储库，则需要清除旧存储库：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Trusty and Xenial, it is recommended that you install the `linux-image-extra-*`
    kernel package that allows you to use the AFUS storage driver. To install them,
    run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Trusty和Xenial上，建议安装`linux-image-extra-*`内核包，允许您使用AFUS存储驱动程序。要安装它们，请运行以下命令：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On Precise, Docker requires a 3.13 kernel version, so ensure that you have the
    correct kernel; if your version is older, you must upgrade it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Precise上，Docker需要3.13内核版本，因此请确保您有正确的内核；如果您的版本较旧，则必须升级。
- en: 'At this point, your machine will be more than ready to install Docker. It can
    be done with a single command, as with `yum`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的机器将准备好安装Docker。可以使用单个命令，如`yum`：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have everything installed and running, you can start playing and
    testing Docker.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装并运行了所有内容，可以开始使用和测试Docker。
- en: Common issues on Ubuntu
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Ubuntu上的常见问题
- en: 'If you see errors related to swap limits while you are using Docker, you need
    to enable memory and swap on your system. It can be done on GNU GRUB by following
    the given steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用Docker时看到与交换限制相关的错误，则需要在系统上启用内存和交换。可以通过GNU GRUB按照给定的步骤完成：
- en: Edit the `/etc/default/grub` file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/default/grub`文件。
- en: 'Set the `GRUB_CMDLINE_LINUX` as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GRUB_CMDLINE_LINUX`设置如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update grub:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新grub：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reboot the system.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动系统。
- en: UFW forwarding
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UFW转发
- en: Ubuntu comes with **Uncomplicated Firewall** (**UFW**) and if it is enabled
    on the same host as the one where you run Docker, you will need to make some adjustments
    because, by default, UFW will drop any forwarding traffic. Also, UFW will deny
    any incoming traffic, making the reach of your containers from a different host
    impossible. The Docker default port is 2376 when TLS is enabled and 2375 in other
    cases. On a clean installation, Docker runs without TLS enabled. Let's configure
    UFW!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu配备了**简化防火墙**（**UFW**），如果在运行Docker的同一主机上启用了它，您需要进行一些调整，因为默认情况下，UFW将丢弃任何转发流量。此外，UFW将拒绝任何传入流量，使得无法从不同主机访问您的容器。在干净的安装中，Docker在未启用TLS的情况下运行时，Docker默认端口为2376。让我们配置UFW！
- en: 'First, you can check if UFW is installed and enabled:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以检查UFW是否已安装并启用：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that you are sure that UFW is installed and running, you can edit the `config`
    file, `/etc/default/ufw`, with your favorite editor and set up the `DEFAULT_FORWARD_POLICY`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您确定UFW已安装并运行，可以使用您喜欢的编辑器编辑`config`文件`/etc/default/ufw`，并设置`DEFAULT_FORWARD_POLICY`：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can now save and close the `config` file and, after the restart of the
    UFW, your changes will be available:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以保存并关闭`config`文件，在重新启动UFW后，您的更改将生效：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Allowing incoming connections to the Docker port can be done with the `ufw`
    command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 允许传入连接到Docker端口可以使用`ufw`命令完成：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: DNS server
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DNS服务器
- en: Ubuntu and its derivatives use 127.0.0.1 as the default name server in the `/etc/resolv.conf`
    file, so when you start containers with this configuration, you will see warnings
    because Docker can't use the local DNS nameserver.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If you want to avoid these warnings you need to specify a DNS server to be used
    by Docker or disable `dnsmasq` in the `NetworkManager`. Note that disabling `dnsmasq`
    will make DNS resolutions a little bit slower.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a DNS server, you can open the `/etc/default/docker` file with your
    favorite editor and add the following setting:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Replace `8.8.8.8` with your local DNS server. If you have multiple DNS servers,
    you can add multiple `--dns` records separated with spaces. Consider the following
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As soon as you have your changes saved, you need to restart the Docker daemon:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you don''t have a local DNS server and you want to disable `dnsmasq`, open
    the `/etc/NetworkManager/NetworkManager.conf` file with your editor and comment
    out the following line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the changes and restart the NetworkManager and Docker:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Post-install setup – creating a Docker group
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker is executed as a daemon that binds to a Unix socket. This socket is owned
    by root, so the only way for other users to access it is with the `sudo` command.
    Using the `sudo` command every time you use any docker command can be painful,
    but you can create a Unix group, called `docker`, and assign users to this group.
    Making this small change, the Docker daemon will start and assign the ownership
    of the Unix socket to this new group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a Docker group:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After these steps, you need to log out and log in again to refresh your permissions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Starting Docker on boot
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ubuntu 15.04 onwards uses the `systemd` system as its boot and service manager,
    while for versions 14.10 and the previous ones, it uses the `upstart` system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'For the 15.04 and up systems, you can configure the Docker daemon to start
    on boot by running the given command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the case of using older versions, the installation method automatically configures
    upstart to start the Docker daemon on boot.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Windows
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Docker team has made a huge effort to bring their entire ecosystem to any
    OS and they didn''t forget about Windows. As on macOS, you have two options to
    install Docker on this OS: a toolbox and a more native option.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Minimum requirements
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker for Windows requires a 64-bit Windows 10 Pro, Enterprise, and Education
    (1511 November update, Build 10586 or later), and the `Hyper-V` package must be
    enabled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In case your machine is running a different version, you can install the Toolbox
    that requires a 64-bit OS running at least Windows 7 and with virtualization enabled
    on the machine. As you can see, it has lighter requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that Docker for Windows requires at least a Pro/Enterprise/Education
    version and the majority of computers are sold with a different version, we will explain
    how to install Docker with the toolbox.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker tools
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Docker tools use VirtualBox to spin a virtual machine that will run the
    Docker engine. The installation package can be downloaded from `https://www.docker.com/products/docker-toolbox`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the installer, you only need to double-click on the downloaded
    executable to start the installation process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The first window shown by the installer allows you to send debug information
    to Docker to improve the ecosystem. Allowing the Docker engine to send debug information
    from your development environment can help the community to find bugs and improve
    the ecosystem. The recommendation on this option is to have it enabled at least
    in your development environment:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Docker tools](graphics/B06142_02_04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Just like any other Windows installer, you can choose where it will be installed.
    In most cases, the default will be fine for your development environment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the installer will add all the required packages and some extras
    to your machine. In this step of the installation, you can purge some non-required
    software. Some of the optional packages are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装程序将向您的计算机添加所有必需的软件包和一些额外的软件。在安装的这一步，您可以清除一些不必要的软件。以下是一些可选软件包：
- en: '**Docker compose for Windows**:In our opinion, this is a must as we will be
    using the package in our book.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Docker compose**：在我们看来，这是必不可少的，因为我们将在我们的书中使用这个软件包。'
- en: '**Kitematic for Windows:** This application is a GUI to manage your containers
    easily. If you are not comfortable with the command line, you can install this
    package.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Kitematic**：这个应用程序是一个GUI，可以轻松管理您的容器。如果您不习惯使用命令行，可以安装这个软件包。'
- en: '**Git for Windows:** This is another must-install package; we will be using
    Git to store and manage our project.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows的Git**：这是另一个必须安装的软件包；我们将使用Git来存储和管理我们的项目。'
- en: After choosing the packages we want to install, it is time for some additional
    tasks. The default selected tasks will be fine for your dev environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要安装的软件包后，是时候进行一些额外的任务了。默认选择的任务对于您的开发环境来说是合适的。
- en: Now, you only need to confirm all the setup you have done in the previous steps
    before the installation starts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要在安装开始之前确认您在之前步骤中所做的所有设置。
- en: The installation can take several minutes to complete, so be patient.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可能需要几分钟才能完成，所以请耐心等待。
- en: 'While the installation progresses, you may be alerted about the installation
    of an Oracle device. This is due to the fact that the tools are using VirtualBox
    to spin up a virtual machine to run the Docker engine. Install this device to
    avoid future headaches:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，您可能会收到有关安装Oracle设备的警报。这是因为工具正在使用VirtualBox来启动一个虚拟机来运行Docker引擎。安装此设备以避免将来的麻烦：
- en: '![Installing the Docker tools](graphics/B06142_02_05.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![安装Docker工具](graphics/B06142_02_05.jpg)'
- en: Congratulations! You have Docker installed on your Windows machine. Don't waste
    another minute and start testing and playing with your Docker ecosystem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经在Windows机器上安装了Docker。别浪费时间，开始测试和玩弄您的Docker生态系统。
- en: How to check your Docker engine, compose, and machine versions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何检查您的Docker引擎、compose和machine版本
- en: 'Now that you have Docker installed, you only need to open your favorite terminal
    and type in the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Docker，您只需要打开您喜欢的终端，并输入以下命令：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Quick example to check your Docker installation
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速检查Docker安装的示例
- en: 'You should have the Docker running and execute the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经运行Docker并执行以下命令：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding command will do the following things:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行以下操作：
- en: Execute the container in the background with `-d`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-d`在后台执行容器
- en: Map the 8080 port of your machine to the 80 port of the container with `-p 8080:80`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-p 8080:80`将您机器的8080端口映射到容器的80端口
- en: Assign a name to your container with `--name webserver-test`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--name webserver-test`为您的容器分配一个名称
- en: Get the NGINX Docker image and make the container to run this image.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取NGINX Docker镜像并使容器运行此镜像。
- en: Now, open your favorite browser and navigate to `http://localhost:8080`, where
    you will see a default NGINX page.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您喜欢的浏览器，导航到`http://localhost:8080`，您将看到一个默认的NGINX页面。
- en: Common management tasks
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的管理任务
- en: By executing `docker ps` on your terminal, you can see the running containers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端上执行`docker ps`，您可以查看正在运行的容器。
- en: The preceding command gives us a deeper view of the containers that are running
    on your machine, the image they are using, when they were created, the status,
    and the port mapping or the assigned name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令让我们更深入地了解了在您的机器上运行的容器，它们正在使用的镜像，它们的创建时间，状态以及端口映射或分配的名称。
- en: Once you finish playing with your container, it's time to stop it. Execute `docker
    stop webserver-test` and the container will end its life.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 玩完容器后，是时候停止它了。执行`docker stop webserver-test`，容器将结束它的生命周期。
- en: Oops! You need the same container again. No problem, because a simple `docker
    start webserver-test` will again spin up the container for you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！您需要再次使用相同的容器。没问题，因为简单的`docker start webserver-test`将再次为您启动容器。
- en: Now, it is time to stop and remove the container because you are not going to
    use it anymore. Executing `docker rm -f webserver-test` on your terminal will
    do the trick. Note that this command will remove the container but not the downloaded
    image we have used. For this last step, you can do a `docker rmi nginx`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候停止并删除容器了，因为您不再需要它。在您的终端上执行`docker rm -f webserver-test`就可以了。请注意，此命令将删除容器，但不会删除我们使用过的下载的镜像。对于最后一步，您可以执行`docker
    rmi nginx`。
- en: Version control – Git versus SVN
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制 - Git与SVN
- en: Version control is a tool that helps you recall the previous versions of your
    source code to check them and work with them; it is agnostic of the language or
    technology used and it is possible to use a version control in all softwares developed
    in plain text.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是一种工具，它可以帮助您回顾以前的源代码版本，以便检查和处理它们；它与使用的语言或技术无关，并且可以在所有以纯文本开发的软件中使用版本控制。
- en: 'We can categorize the versioning control tools into the following categories:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将版本控制工具分类为以下几类：
- en: '**Centralized version**: Control system needs a centralized server to work
    and all developers need to be connected to it so that they synchronize and download
    the changes from it.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式版本**：控制系统需要一个集中的服务器来工作，所有开发人员都需要连接到它，以便从中同步和下载更改。'
- en: '**Distributed version**: Control system is not centralized; in other words,
    each developer has the entire management version control system on their own machine,
    so it is possible to work locally and then synchronize it with a common server
    or with each developer. **Distributed Version Control Systems** (**DVCS**) are
    faster because they need less changes on the centralized or shared server.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式版本**：控制系统不是集中的；换句话说，每个开发人员在自己的机器上拥有整个管理版本控制系统，因此可以在本地工作，然后与公共服务器或每个开发人员同步。**分布式版本控制系统**（**DVCS**）更快，因为它们在集中或共享服务器上需要更少的更改。'
- en: Subversion (SVN) is a centralized version control system and, for this reason,
    some developers think that it is the best way to work respecting the entire project,
    so the developer just needs to write and read the access controllers in one place.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The entire code is hosted in one place, so it is possible to think that this
    way, it is easier to understand SVN better than Git. The truth is that the SVN
    command line is easier and there are more GUIs available for SVN. The reason is
    clear: SVN has existed since the year 2000, and Git came 5 years later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of SVN is that the system to number the versions is clearer;
    it uses a sequential number system (1,2,3,4...) and Git uses SHA-1 codes, which
    are more difficult to read and understand.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with SVN, it is possible to get a subdirectory to work with it without
    the need of having the entire project. This is not a problem for small projects,
    but it can be difficult when you have a large project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Git
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we will use Git for our version control. We made this decision
    because Git is definitely faster and more lightweight (it takes up 30 times less
    disk space than SVN). Also, Git became the standard version control on web development
    version control and our goal is to create an application based on microservices
    using PHP, so Git is a great solution for the project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of Git are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The branches are more lightweight than SVN
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is a lot of faster than SVN
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is a DVCS from the start, so the developer has total control of its local
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git provides better auditory in branching and merging
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the subsequent chapters, we will use Git commands on our project, explaining
    each one and giving examples, but until then, let''s take a look at the basic
    ones:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**How to create a new repository**: Create a new folder, open it, and execute
    Git in it to create a new Git repository.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**How to checkout an existing repository**: Create a local copy from the repository
    executing Git clone `/path/to/repository`. If you are using a remote server (hosting
    centralized servers will be explained in the following lines), execute Git clone
    `username@host:/path/to/repository` .'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the Git workflow, it is necessary to know that there are three
    different trees:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Git](graphics/B06142_02_06.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '**WORKING DIRECTORY**: This contains the files of your project'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INDEX**: This works as the intermediate area; files will be here until they
    are committed'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HEAD**: This points to the last commit done'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding files to the INDEX and committing them are easy tasks. After working
    with files on your project and changing them, you have to add them to the index:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**How to add files to the INDEX**: Checking the files before adding them to
    the INDEX is recommended. You can do this by executing `git diff <file>`. It will
    show you the added and deleted lines, and some more interesting information about
    the file you modified. Once you are happy with the changes made, you can execute
    `git add <filename>` to add a specific file or add Git to all the files you have
    modified.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to add files to the HEAD**: Once you have included all the necessary
    files in the INDEX, you have to commit them. You can do this by executing `git
    commit -m "Commit message"` . Now the files are included in the HEAD in your local
    copy, but they are still not in the remote repository.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to send changes to the remote repository**:To send the changes included
    in your HEAD local copy to the remote repository, execute `git push origin <branch
    name>;` you can choose the branch where you want to include the changes, for example,
    master. If you did not clone an existing repository and you want to connect your
    local repository to a remote one, execute `git remote add origin <server>`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The branches are used to develop isolated functions and can be merged with
    the main branch in the future. The default branch when a new repository is created
    is called master. The workflow overview will be something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Git](graphics/B06142_02_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: '**How to create a new branch**:Once you are in the branch from where you want
    to create a new one, execute `git checkout -b new_feature`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to change the branch**:You can navigate through the branches by executing
    `git checkout <branch name>`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to delete a branch**: You can delete a branch by executing `git branch
    -d new_feature`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to make your branch available to everyone**: A branch will not be available
    to the rest of developers until you upload your branch to the remote repository
    by executing `git push origin <branch>`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to update your local copy with the changes made on the remote repository,
    you can execute `git fetch` to check if there are any new updates and then `git
    pull` to get that update.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To merge your active branch with a different branch, execute `git merge <branch>`
    and Git will attempt to fuse both branches but, sometimes, if two or more developers
    changed the same file, there could be conflicts and you will need to solve those
    conflicts manually before the merge and then put the modified files into the INDEX
    again.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: If you fail, maybe you want to trash your local changes and get the ones from
    the repository again. You can do this by executing `git checkout -- <filename>`
    . In case you want to trash all your local changes and commits, execute `git fetch
    origin and git reset --hard origin/master`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Hosting
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are working in a team, maybe we want to have a common repository with
    a centralized server. Remember that Git is a DVCS and it is not necessary to use
    a place to have the code centralized, but in case you want to use it for different
    reasons, we will look at the two famous ones.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The hostings provide you with a better way to manage your repository using a
    web interface.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub is the place to host the code chosen by a majority of developers. It
    is based on Git, and companies, such as Twitter and Facebook, use this service
    to put their open source projects. GitHub became the most famous source host in
    just a few years and currently, many companies ask for a candidate's GitHub repository
    before their technical interview.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This hosting is free for all developers; they can create unlimited projects
    with unlimited collaborators and only one condition; the project needs to be open
    source and public. If you want to have a private project, you will have to pay.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Having your project as public on GitHub is a good opportunity to show your project
    to the world and take advantage of the big GitHub community. It is possible to
    ask for help because there are many registered and active developers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://github.com/](https://github.com/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: BitBucket
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBucket is an alternative place to host your project. It uses Git, but you
    can use Mercurial too. The interface is pretty similar to GitHub. A great advantage
    of BitBucket is the company that makes it possible--Atlassian. It has many functionalities
    for developers included in their hosting, for example, the possibility of integrating
    other Atlassian tools or a small continuous delivery tool which allows you to
    build, test, and deploy your application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is free regardless of the project you want: public or private. The
    only limitation is that it only allows five collaborators for each project; if
    you need more people working on your project you will have to pay.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Official website**: [https://bitbucket.org/](https://bitbucket.org/).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Version control strategies
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are developing an application, it is important to keep your code nice
    and clean, but it is even more important when you work with other developers.
    In this section, we will give you a small introduction to the most known version
    control strategies you can use in your project.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Centralized work
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This strategy is the most common for developers who were previously using SVN
    (old school) or similar version controls. Like Subversion, the project is hosted
    in a central repository with a unique point of entry. This strategy does not need
    more branches except master (trunk in SVN).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Developers clone the entire project on their local machines, work on the project,
    and then they commit the changes. When they want to publish the changes, they
    execute push.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Feature branch workflow
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the next step from centralized work. It works with a centralized repository
    also, but developers create a local feature branch in their copy and this one
    is published on the centralized repository too, so all the developers have the
    chance to participate in that feature. The branches will have descriptive names
    or number of issues.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In this strategy, the master never contains errors, so this is a great improvement
    for continuous integration. Also, having specific branches for each feature is
    a good encapsulation to not disturb the main code base.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Gitflow workflow
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gitflow workflow does not add more new concepts than feature branch workflow.
    It just assigns different roles for each branch. Gitflow workflow works with a
    centralized repository too, and developers create branches on it, such as feature
    branch workflow. However, the branches have a specific function, for example,
    development, release, or feature. So, the feature branches will be merged with
    a specific release and then with master. This way, it is possible to have different
    releases for the same project.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is used for large projects or projects that need releases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Forking workflow
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last strategy is quite different to others that we have looked at in this
    chapter. Instead of cloning a copy from the centralized server and working on
    it, this one gives a fork of that to every developer. This means that every developer
    has two copies of the project: a *private* one and the *server-side*.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Once the developer makes the changes they want, they are sent to the project
    maintainer to be reviewed and checked so that they do not break the project and
    then they are merged with the main repository.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is used in open source projects, so the developers cannot break
    the current project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is really important to have a versioning system in our microservice or API.
    This allows the consumers and yourself to have a coherent system of versioning
    so that everyone can know the importance of a release or feature.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the version number as `MAJOR.MINOR.PATCH`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`MAJOR` will be incremented when incompatible API changes are made, so developers
    need to trash the current API version and use the new one.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MINOR` will be incremented when a new feature is added and it is compatible
    with the current code. The developer, therefore, does not need to change the entire
    API just to update the current one.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH` will be incremented when a new bug fix for the current version is done.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a summary of semantic versioning, but you can find more information
    at [http://semver.org/](http://semver.org/).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment for microservices
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest benefits of using Docker and its container ecosystem is
    that you don't need to install anything else on your machine. For example, if
    you need a MySQL database, you don't need to install anything on your local dev;
    it is easier to spin a container with the version you want and start using it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: This way of developing is more flexible, therefore we will be working with Docker
    containers throughout the whole book. In this section, we will learn how to build
    a basic Docker environment; it will be our foundation and we will be improving
    and adapting this base to each of our microservices in the subsequent chapters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the folder structure of our project, we will have some root folders
    on our development machine:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`Docker`: This folder will contain all the Docker environment'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source`: This folder will have the source of each of our microservices![Setting
    up a development environment for microservices](graphics/B06142_02_08.jpg)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this structure is flexible and can be changed and adapted to your
    specific requirements without any problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: All the required files are available on our GitHub repository, at [https://github.com/php-microservices/docker](https://github.com/php-microservices/docker),
    on the master branch with the `chapter-02` tag.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig deeper into the Docker setup. Open your docker folder and create
    a file called `docker-compose.yml` with the following content:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These two lines indicate that we are using the latest syntax for Docker compose
    and they define a list of services that we will be spinning every time we do a
    `docker-compose up`. All our services will be added after the `services` declaration.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Autodiscovery service
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autodiscovery is a mechanism in which we don't specify the endpoints of each
    of our microservices. Each one of our services use a shared registry in which
    they say that they are available. When a microservice needs to know the location
    of another microservice, it can consult our autodiscovery registry to know the
    required endpoint.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we will be using an autodiscovery mechanism to ensure that
    our microservices can be scaled easily and if a node is not healthy, we stop sending
    requests to it. Our choice for this purpose is to use Consul (by HashiCorp), a
    very small application that we can add to our project. The main role for our Consul
    container is to keep everything in order, keeping a list of the available and
    healthy services.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the project by opening your `docker-compose.yml` file with your
    favorite IDE/editor and adding the next piece of code just after the `services:`
    line:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a Docker compose file, the syntax is very easy to understand and always follows
    the same flow. The first line defines a container type (it is like a class name
    for devs); in our case it is `autodiscovery`, and inside this container type we
    can specify several options to adapt the container to our requirements.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'With `build: ./autodiscovery/`, we are telling Docker where it can find a Dockerfile
    that describes what we want in our container in detail.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mem_limit: 128m` sentence will limit the memory consumption of any container
    of the `autodiscovery` type to not more than 128 Mb. Note that this instruction
    is optional.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Each container needs different ports open and, by default, when you spin a container,
    none of them are open. For this reason, you need to specify which ports you want
    open for each container. For example, a container with a web server will need
    the `port 80` open but for a container that runs MySQL, the required port may
    be `3306`. In our case, we are opening the ports `53`, `8300`, `8301`, `8302`,
    `8400`, and `8500` for each one of our `autodiscovery` containers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If you try to reach the container on one of the opened ports, it will not work.
    The container ecosystem resides in a separate network and you can only access
    it if you create a bridge between your environment and the Docker network. Our
    `autodiscovery` container runs Consul and it has a nice web UI on port `8500`.
    We want to be able to use this UI; so, when we use `ports`, we are mapping our
    local `8500` port to the container `8500` port.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to create a new folder called `autodiscovery` in the same path
    of your `docker-compose.yml file`. Inside this new folder, place a file called
    `Dockerfile` with the following line:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This small sentence inside the `Dockerfile` indicates that we are using a Docker
    `consul` image with tag `v0.7.0`. This image will be fetched from the official
    Docker hub, a repository for container images.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: At this point, doing a `$ docker-compose up` will spin up a Consul machine,
    give it a try. Since we didn't specify the `-d` option, the Docker engine will
    output all the logs to your terminal. You can stop your container with a simple
    *CTRL*+*C*. When you add the `-d` option, the Docker compose runs as a daemon
    and returns the prompt; you can do a `$ docker-compose stop` to stop the containers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Microservice base core - NGINX and PHP-FPM
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP-FPM is an alternative to the old way of executing PHP in our web server.
    The main benefit of using PHP-FPM is its small memory footprint and the high performance
    under hight loads. The best web server you can find nowadays to run your PHP-FPM
    is NGINX, a very light web server and reverse proxy used in the most important
    projects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Since our application will be using an autodiscovery pattern, we need an easy
    way of dealing with the service registering, deregistering, and health check.
    One of the simplest and fastest applications you can use is ContainerPilot, a
    small micro-orchestration application created by Joyent that works with your favorite
    container scheduler, in our case Docker compose. This small app is being executed
    as PID 1 and forks the application we want to run inside the container.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We will be working with ContainerPilot because it relieves the developer of
    dealing with the autodiscovery, so we need to have the latest version on each
    container we will be using.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start defining our base `php-fpm` container. Open the `docker-compose.yml`
    and add a new service for the `php-fpm`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we are defining a new service and one interesting attribute
    is links. This attribute defines which other containers our service can see or
    connect. In our example, we want to link this type of container to any `autodiscovery` container.
    Without this explicit definition, our `fpm` container won't see the `autodiscovery`
    service.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `microservices/base/php-fpm/Dockerfile` file on your IDE/editor
    with the following content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What we have done on this file is tell Docker how it needs to create our `php-fpm`
    container. The first line declares the official version we want to use as a foundation
    for our container, in this case php7 fpm. Once the image is downloaded, the first
    `RUN` line will add all the extra `PHP` packages we will be using.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The two `RUN` sentences will add bespoke PHP configurations; feel free to adapt
    these lines to your requirements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Once all the PHP tasks are done, it is time to install a small application on
    the container that will help us to deal with templates--`consul-template`. This
    application is used to build configuration templates on the fly using the information
    we have stored on our Consul service.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, we are using ContainerPilot. So, after the `consul-template`
    installation, we are telling Docker how to install this application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: At this point, Docker finishes installing all the required packages and copies
    some configuration and shell scripts needed by ContainerPilot
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The last line starts ContainerPilot as PID 1 and forks `php-fpm`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explain the configuration file required by ContainerPilot. Open
    your IDE/editor and create the `microservices/base/php-fpm/config/containerpilot.json`
    file with the following content:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This JSON configuration file is very easy to understand. First, it defines where
    we can find our Consul container and which command we want to run on the ContainerPilot
    preStart event. In `services`, you can define all the services you want to declare
    that the current container is running. On the `backends`, you can define all the
    services you are listening for changes. In our case, we are listening for changes
    to services called `microservice_base_nginx` (the `BACKEND` variable is defined
    on the `docker-compose.yml`). If something changes on Consul on these services,
    we will execute the `onChange` command in the container.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: For a more information about ContainerPilot, you can visit the official page,
    that is, [https://www.joyent.com/containerpilot](https://www.joyent.com/containerpilot).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the `microservices/base/php-fpm/scripts/reload.sh` file
    with the following content:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we created a dummy script, but it is up to you to adapt it to your requirements.
    For example, it can be changed to `run execute consul-template` and rebuild the
    NGINX configuration once ContainerPilot fires the script. We will be explaining
    a more complex script later.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: We have our base `php-fpm` container ready, but our basic environment can't
    be complete without a web server. We will be using NGINX, a very light and powerful
    reverse proxy and web server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The way we will build our NGINX server is very similar to the `php-fpm`, so
    we will only explain the differences.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that all the files are available in our GitHub repository.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a new service definition for NGINX to the `docker-compose.yml`
    file and link it to our `autodiscovery` service and also to our `php-fpm`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In our `microservices/base/nginx/config/containerpilot.json`, we now have a
    new option `telemetry`. This config setting allows us to specify a remote telemetry
    service used to collect stats from our service. Having this kind of service included
    in our environment allows us to see how our containers are performing:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we use a bespoke bash script to obtain the container stats,
    and the content of our `microservices/base/nginx/scripts/sensor.sh` script is
    as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This bash script gets some `nginx` stats that we will be sending to our `telemetry`
    server with ContainerPilot.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `microservices/base/nginx/scripts/reload.sh` is a little more complex than
    the one we created before for `php-fpm`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we use `consul-template` to rebuild our NGINX config on the
    startup or when ContainerPilot detects a change in the list of backend services
    we will be monitoring. This behavior allows us to stop sending requests to unhealthy
    nodes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have our base environment ready and we are ready to test it
    with a simple `$ docker-compose up`. We will be using all these pieces to create
    bigger and more complex services. In the upcoming chapters, we will be adding
    the telemetry service or a data storage among others.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks for microservices
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A framework is a skeleton that we can use for sofware development. Using a framework
    will help us use standard and robust patterns in our application, making it more
    stable and well known by other developers. PHP has many different frameworks you
    can use in your daily work. We will see some standards used on the most common
    frameworks so that you can pick the best for your project.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: PHP-FIG
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For years, the PHP community has been working on their own projects and following
    their own rules. Thousands of different projects with different developers have
    been released since the first years of PHP, and none followed any common standards.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This was a problem for PHP developers, firstly because there was no way of knowing
    if the steps they were following to build applications were the correct ones.
    Only their own experience and the Internet could help the developer guess if their
    code was written properly and if it would be readable by other developers in the
    future.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the developers felt that they were trying to reinvent the wheel. Developers
    were making the same existing applications for their projects because there was
    no standard to fit third-party application into their projects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: In 2009, the **PHP Framework Interoperability Group** (**PHP-FIG**) was born
    with the main goal of creating a unique standard for development in PHP. PHP-FIG
    is a big community of members that works on the **PHP Standards Recommendation **(**PSR**),
    discussing what the best way to use the PHP language is.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: PHP-FIG is supported by big projects such as Drupal, Magento, Joomla!, Phalcon,
    CakePHP, Yii, Zend, and Symfony and that is the reason the PSRs they propose are
    implemented by the PHP frameworks.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Some standards, such as PSR-1 and PSR-2, are about the use of code and its style
    (using tabs or spaces, opening tags of PHP, using camelCasing or filenames) and
    others are about the autoloading (PSR-0 and then PSR-4). Since PHP 5.3, namespaces
    were included and it was the most important thing to implement `autoloading`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The `autoloading` was possibly one of the most important improvements to PHP.
    Before PHP-FIG, frameworks had their own methods to implement the autoloading,
    their own way to format them, initialize them, and name them, and each one was
    different, so it was a disaster (Java already solved this problem using its beans
    system).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Composer implemented autoloading, which was written by PHP-FIG. So,
    developers don't need to worry about `require_once()`, `include_once()`, `require()`,
    or `include()` anymore.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about PHP-FIG at [http://www.php-fig.org/](http://www.php-fig.org/).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: PSR-7
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we will use the **PHP Standard Recommendation 7** (**PSR-7**).
    It is about the HTTP messages interfaces. This is the essence of web development;
    it is the way to communicate with a server. An HTTP client or web browser sends
    an HTTP request message to a server and it replies with an HTTP response message.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of messages are hidden from normal users, but developers need to
    know the structure to manipulate them. The PSR-7 talks about the recommended ways
    to manipulate them, doing it simply and clearly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: We will use HTTP messages to communicate with microservices, so it is necessary
    to know how they work and what their structure is.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP request has the following structure:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the request, there are all the necessary things to allow the server to understand
    the request message and to be able to reply with a response. In the first line,
    we can see the method used for the request (`GET`, `POST`, `PUT`, `DELETE`), the
    request target, and the HTTP protocol version, and then one or more HTTP headers,
    an empty line, and the body.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'And the HTTP response will look like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is the response body. The response has the HTTP protocol version, such
    as the request and the HTTP status code, followed by a text to describe the code.
    You will find all the available status codes in the next chapters. The rest of
    the lines are like the request: one or more HTTP headers, an empty line, and then
    the body.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Once we know the structure of HTTP request messages and HTTP response messages,
    we will understand what the recommendations of PHP-FIG on PSR-7 are.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Messages
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any message is an HTTP request message (RequestInterface) or an HTTP response
    message (ResponseInterface). They extend MessageInterface and may be implemented
    directly. Implementors should implement RequestInterface and ResponseInterface.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Case-insensitive for header field names:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Headers with multiple values:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Host header
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Usually, the host header is the same as the host component of the URI and the
    host used when establishing the TCP connection, but it can be modified.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestInterface::withUri()` will replace the request host header.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: You can keep the original state of the host by passing true for the second argument;
    it will keep the host header unless the message does not have a host header.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: StreamInterface is used to hide the implementation details when a stream of
    data is read or written.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams expose their capabilities using the following three methods:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Request targets and URIs
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A request target is in the second segment of the request line:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `getRequestTarget()` method will use the URI object to make the origin-form
    (the most common request-target).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `withRequestTarget()`, the user can use the other three options. For
    example, an asterisk-form, as illustrated:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The HTTP request will be as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Server-side requests
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RequestInterface gives the general representation for an HTTP request, but
    the server-side requests needs to be processed into an account **Common Gateway
    Interface** (**CGI**). PHP provides simplification via its superglobals:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ServerRequestInterface provides an abstraction around these superglobals to
    reduce coupling to the superglobals by consumers.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Uploaded files
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `$_FILES` superglobal has some well-known problems when working with arrays
    or file inputs. For example, with the input name `files`, submitting files[`0`]
    and files[`1`], PHP will be represented like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expected representation is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So, the customers need to know these kinds of problems and write code to fix
    the given data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`getUploadedFiles()` provides the normalized structure for consumers.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detailed information and the interfaces and classes that we
    discussed at [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A middleware is a *mechanism to filter the HTTP requests on an application*;
    it allows you to add additional layers to the business logic. It executes before
    and after the piece of code we want to reach to handle input and output communication.
    The middleware uses the recommendations on PSR-7 to modify the HTTP requests.
    This is the reason PSR-7 and middleware are united.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common example of middleware is on the authentication. In an application
    where it is necessary to log in to get user privileges, the middleware will decide
    if the user can see specific content of the application:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![Middleware](graphics/B06142_02_09.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we can see a typical PSR-7 HTTP **REQUEST** and **RESPONSE** with
    two **MIDDLEWARE**. Usually, you will see the middleware implementations as lambda
    (λ).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take a look at some examples of typical implementations of middlewares:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `request` and `response` are the objects, and the last param `$next` is
    the name of the next middleware to call. If the middleware is the last one, you
    can leave it empty. In the code, we can see three different parts: the first one
    is to modify and do things before the next middleware, in the second one the middleware
    calls the next middleware (if it exists), and the third one is to modify and do
    things after the previous middleware.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to see the code before and after the `$next`(`$request`,
    `$response`) form as onion layers around the middleware, but it is necessary to
    be on the ball regarding the order of execution of the middlewares.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Another good practice is looking at the real application (the part of code the
    middlewares reach, usually a controller function) as a middleware too, because
    it receives a request and a response and it has to return a response, but this
    time without the next param because it is the last one; however, the execution
    continues after this. This is the reason we have to look at the end code in the
    same way as the last middleware.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a complete example to understand how you can use it on your application
    based on microservices. As we saw in the preceding image, there were two middlewares,
    we will call them first and second, and then the end function will be called endfunction:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Every framework has its own middleware handler, but each one works very similarly.
    The middleware handler is used to manage the stack, so you can add more middleware
    on it and they will be called sequentially. This is a generic middleware handler:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The execution track will be something like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The user requests a specific path to the server. For example, `/`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `first` middleware is executed adding `word` equals to `hello`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `first` middleware sends the execution to `second`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `second` middleware adds the sentence `word: hello`.'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `second` middleware sends the execution to the `end` function.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `end` function adds the sentence `function reached` and finishes its own
    job.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution continues by the `second` middleware and this one sets the HTTP
    status 200 to response.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution continues by the `first` middleware and this one adds a custom
    header.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is returned to the user.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, if you get an error during the middleware execution, you can manage
    it using the following common code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The response will be sent immediately to the user without ending the entire
    execution.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Available frameworks
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are hundreds of frameworks available to develop your application, but
    when you need one to be used to make microframeworks, it is necessary to look
    for some characteristics:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: A microframework able to process the maximum requests per second
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight in terms of memory
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is possible, with a great community developing applications for that framework
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will look at possibly the five most-used frameworks at the moment. Finding
    the best framework is not a unique opinion, every developer has their own opinion,
    so let me introduce you to the following ones:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '| **Framework** | **Request per second** | **Peak memory** |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| Phalcon 2.0 | 1,746.90 | 0.27 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| Slim 2.6 | 880.24 | 0.47 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| Lumen 5.1 | 412.36 | 0.95 |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| Zend Expressive 1.0 | 391.97 | 0.80 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| Silex 1.3 | 383.66 | 0.86 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '**Source**: *PHP Framework Benchmark*. The project attempts to measure minimum
    overhead PHP frameworks in the real world.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Phalcon is a popular framework, it gained fame because its speed made it the
    fastest framework. Phalcon is very optimized and modular; in other words, it only
    uses the things that you need or want, without adding extra things that you won't use.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is excellent, but its disadvantage is that the community is
    not as big as Silex or Slim, so the third-parties' community is small and it is
    sometimes a little difficult to find fast solutions when you have issues.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon ORM is based on the C language. This is really important if you are
    developing a microservice based on databases.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, it is the best framework; however, it is not recommended for beginners.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://phalconphp.com](https://phalconphp.com/).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Slim framework
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Slim is one of the fastest micro RESTful frameworks available. It provides
    you with every feature that a framework should have. Also, Slim framework has
    a very big community: you can find a lot of resources, tutorials, and documentation
    on the Internet because there are a lot of developers using it.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Since the release of version 3, the framework has a better architecture, making
    it better in terms of overall architecture and security. This new version is a
    little slower than version 2, but all the introduced changes make this framework
    suitable for projects of all sizes.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is not bad, but it could be better. It is too short.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: It is a good microframework for beginners.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official website at [http://www.slimframework.com/](http://www.slimframework.com/).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Lumen
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lumen is one of the fastest micro RESTful frameworks made by Laravel. This microframework
    was specially made to work with ultra fast microservices and APIs. Lumen is really
    fast, but there are some microframeworks that are faster, such as Slim, Silex,
    and Phalcon.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: This framework became famous because it was pretty similar to CodeIgniter syntax,
    and it is very easy to use, so maybe this is why Lumen is the best microframework
    to start working with microservices using a microframework. Also, Lumen has very
    good and clear documentation; you can find it at [https://lumen.laravel.com/docs](https://lumen.laravel.com/docs).
    If you use this framework, you can start to work in little time as the setup is
    really fast.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Another advantages of Lumen is that you can start working with it and then,
    if you need the complete Laravel in the future, it is very easy to transform and
    update the framework into Laravel.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Lumen still enforces an application structure (convention over
    configuration) that might limit your options when you design your application.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to use Lumen, it is because you have used Laravel and you liked
    it; if you do not like Laravel, Lumen is not the best solution for you.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the official website at [https://lumen.laravel.com/](https://lumen.laravel.com/).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Zend Expressive
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lumen is the equivalent of Laravel and Zend Expressive is for Zend Framework.
    It is a microframework built to make microservices and is prepared to be used
    exclusively following PSR-7 and based on middleware.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to set it up in a few minutes and you have all the advantages
    of Zend Framework on it in terms of community. Also, being a product of Zend is
    a synonym of quality and security.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: It comes with a minimal core and you can choose what components you want to
    include. It has very good flexibility and ability to extend it too.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Visit the official website at [https://zendframework.github.io/zend-expressive/](https://zendframework.github.io/zend-expressive/).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Silex (based on Symfony)
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Silex is also a very good micro RESTful PHP framework. It is one of the five fastest
    microframeworks and currently, it is one of the best known because the Silex community
    is one of the bigger ones and they develop really good third parties, so developers
    have many solutions for their projects.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: The community and its connection to Symfony guarantee stable implementation
    with many available resources. Also, the documentation is really good, and this
    microframework is specially good for large projects.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Silex and Slim Framework are pretty similar; maybe the competition
    made them better.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official website at [http://silex.sensiolabs.org/](http://silex.sensiolabs.org/).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we talked about what we are going to build in this book as an
    example application. We also showed you how you can set up your development machine
    using Docker, and we even talked about the different microframeworks you can use
    .In the next chapter, we will learn how to go about designing our application
    and different types of microservices patterns.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
