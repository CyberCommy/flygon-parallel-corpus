- en: '*Chapter 2*: Writing Your First Uno Platform App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a new Uno Platform app and see
    how a typical Uno Platform app is structured. First, we will go over the default
    Uno Platform app template, including the different projects included, and get
    you running on Windows 10 with your first Uno Platform app. After that, we will
    dive deeper into running and debugging your app on different platforms by showing
    how to use emulators and debugging the WebAssembly (Wasm) version of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Uno Platform supports a plethora of platforms and more and more platforms
    are being added to the list of supported platforms, in this book, we will only
    develop for a subset of supported platforms. The following platforms are the most
    prominent and widely used platforms, and as such, we will target them: Windows
    10, Android, Web/Wasm, macOS, and iOS.'
  prefs: []
  type: TYPE_NORMAL
- en: While we mention the other platforms in this chapter for completeness, the other
    chapters will only include the platforms mentioned earlier. This means that we
    will not show you how to run or test your app on **Linux**, **Tizen**, or **Windows
    7/8**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Uno Platform app and understanding its structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging your app, including using **XAML Hot Reload** and **C#
    Edit and Continue**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific code using C# compiler symbols and **XAML** prefixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other project types besides the Uno Platform app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have written your first Uno Platform app
    and created customizations based on the running platform. In addition to that,
    you will be able to make use of the different Uno Platform project types.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter assumes that you already have your development environment set
    up, including installing the project templates, as was covered in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*. You can find the source code for this chapter here:
    [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter02](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [https://bit.ly/37Dt0Hg](https://bit.ly/37Dt0Hg)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the digital version of this book, we advise you to type the
    code yourself or access the code from the book's GitHub repository Doing so will
    help you avoid any potential errors related to the copying and pasting of code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways of creating your project, so we will start with the
    most common one, using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your project with the Uno Platform solution templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of creating an Uno Platform app project is the same as for other
    project types in Visual Studio. Depending on the extensions and project templates
    installed, you will be greeted by the list of options in *Figure 2.1* when filtering
    for **Uno Platform**. Note that for *Figure 2.1*, only the **Uno Platform Solution
    Templates** extension was installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – List of Uno Platform project templates in the new project dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.01_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – List of Uno Platform project templates in the new project dialog
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to get started with Uno Platform is using the **Multi-Platform
    App (Uno Platform)** project template as this contains all the necessary projects
    to build and run Uno Platform apps for every platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating your app by selecting the **Multi-Platform App (Uno Platform)**
    project type and click **Next**. Be careful that you are not selecting the **Multi-Platform
    Library (Uno Platform)** option as that will create a different project type,
    which we cover in the *Going beyond the default cross-platform app structure section*.
    Now you need to choose the name of your project, the location, and the solution
    name as seen in *Figure 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Author_Figure_2.02_B17132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Configuring Multi-Platform App (Uno Platform)
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will call our project `HelloWorld` and save it under `D:\Projects`
    meaning that the project will be stored in `D:\Projects\HelloWorld` with the `HelloWorld.sln`
    solution being the top-level element. Of course, you can create the project in
    any folder you want; `D:\Projects` is just an example here. Note though that you
    should create your project as close as possible to the root of your drive to avoid
    issues with paths that are too long. After clicking **Create**, Visual Studio
    will create your project and open the solution for you. You will see all the generated
    projects in **Solution Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating your project in Visual Studio for Mac, the generated solution
    will include project heads for **Windows Presentation Foundation** (**WPF**) and
    **Universal Windows Platform** (**UWP**) apps. A project or platform head is the
    corresponding project that will be compiled when you compile your app for a specific
    platform. So, in the case of Windows 10, the UWP head will be compiled. You will
    need to use a Windows PC to build these apps. If you don't want to build for these
    platforms, you can remove the projects from the solution. If you will build these
    on a Windows machine separately, unload them from the solution when working on
    a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since your app might not target every platform supported by Uno Platform, you
    might want to remove those heads for your app. To do that, remove those projects
    from the solution by right-clicking the project in the project view and clicking
    **Remove** as shown in *Figure 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Removing the Skia.Tizen head from the solution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Removing the Skia.Tizen head from the solution
  prefs: []
  type: TYPE_NORMAL
- en: After removing the project from the solution, the project is still on disk.
    To remove it entirely, you will have to delete the project by opening the project
    folder and deleting the corresponding folders. Since we will only target Windows
    10, Android, Web, macOS, and iOS, you can remove the `Skia.GTK`, the `Skia.Tizen`,
    `Skia.Wpf`, and `Skia.WpfHost` projects from your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your project with the .NET CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, you don''t have to use Visual Studio to create your Uno Platform
    app. You can also use the `dotnet new` templates for Uno Platform. You can create
    a new project by opening a terminal and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new project called **MyApp**. You can find an overview of
    all the dotnet new templates in Uno Platform's template documentation ([https://platform.uno/docs/articles/get-started-dotnet-new.html](https://platform.uno/docs/articles/get-started-dotnet-new.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, not everyone wants to target every platform with their app nor is
    it appropriate for every app to run on every platform. You can opt out of creating
    the target projects for specific platforms (more on those in the next section)
    by including specific flags in your commands. For example, with the following
    command, you will create a new project that will not run on Linux and other Skia-based
    platforms as we exclude the Skia heads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To get a list of all the available options for the `unoapp` template, you can
    run `dotnet new unoapp -h`.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure and the heads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating the project in Visual Studio on Windows, with the Uno Platform
    Solution templates, there are two different top-level elements in `Platforms`
    folder and the `HelloWorld.Shared` shared C# project. Note that in the solution
    view, those are the two top-level elements, however, the `Platforms` folder does
    not exist on disk. Instead, all projects including the shared project have their
    own folder as shown in *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – HelloWorld project in File Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – HelloWorld project in File Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of the generated solution is a file called `.vsconfig`. This file
    contains a list of all the Visual Studio components required to work with the
    generated project. If you set your environment up as in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*, then you''ll have everything you need. But, if you
    see the prompt in *Figure 2.5*, click on the **Install** link and add the missing
    workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Missing components warning in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Missing components warning in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Platforms` solution folder, you will find a `C#` project for every
    one of the supported platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HelloWorld.Droid.csproj` for Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.iOS.csproj` for iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.macOS.csproj` for macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.Skia.Gtk.csproj` for Linux with GTK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.Skia.Tizen.csproj` for Tizen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.Skia.Wpf.csproj`: Base project for Windows 7 and Windows 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.Skia.Wpf.WpfHost.csproj`: Host for the `HelloWorld.Skia.Wpf` project
    on Windows 7 and Windows 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.UWP.csproj` for Windows 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld.Wasm.csproj` for WebAssembly (WASM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those projects are also called `UIApplication` for iOS, creating and displaying
    an `NSApplication` on macOS, or starting the application on WASM.
  prefs: []
  type: TYPE_NORMAL
- en: Some specific settings and configurations, such as permissions required by your
    app, will differ based on the platform. Some platforms allow you to use APIs without
    any restrictions. In contrast, other platforms are more prohibitive and require
    your app to specify those APIs beforehand or ask the user for permission, which
    is something you have to configure in the head project. As those configurations
    need to be done in the individual heads, the experience will differ based on the
    different platforms. We will only cover parts of those differences when configuring
    the platform heads in [*Chapter 3*](B17132_03_Final_VK_ePub.xhtml#_idTextAnchor052),
    *Working with Forms and Data*, (Mac, WASM, and UWP) and [*Chapter 4*](B17132_04_Final_VK_ePub.xhtml#_idTextAnchor064),
    *Mobilizing Your App*, (Android and iOS) as part of developing apps for those
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the head projects, the **shared project** is where almost all
    of your app's code will be, including your pages and views, the core logic of
    the app, and any assets such as resources or images that will be used on every
    platform. The shared project is referenced by all of the platform heads, so any
    code placed in there will be used on all of the platforms. If you are not familiar
    with C# shared projects, shared projects are nothing more than a list of files
    that will be included when compiling a project that references the shared project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A newly created cross-platform app like our **Hello World** app already comes
    with a few files in the shared project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.xaml.cs`: This is the app''s entry point; it will load the UI and navigate
    to `MainPage`. In here, you can also configure the logging of events by uncommenting
    the respective lines in the `InitializeLogging` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.xaml`: This contains the list of common XAML resources such as resource
    dictionaries and theme resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml.cs`: This file contains the C# code of your `MainPage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPage.xaml`: This is where you can put the UI of your `MainPage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assets/SharedAssets.md`: This is a demo asset file that is included to show
    how assets work inside an Uno Platform app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Strings/en/Resources.resw`: This is also a demo asset file that you can use
    to get started with localization inside your Uno Platform app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you are familiar with the project structure of your first Uno Platform
    app, let's dive into building and running your app.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running your first Uno Platform app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you are familiar with the structure of an Uno Platform app, we can get
    to building and running your first Uno Platform app! In this section, we will
    go over the different ways of building and running your app.
  prefs: []
  type: TYPE_NORMAL
- en: Running and debugging your app with Visual Studio on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running your Uno Platform app from within Visual Studio is exactly the same
    as running a regular UWP, `Xamarin.Forms`, or WASM app. To build and run the app
    on a specific device or emulator, you can select the corresponding head from the
    startup project dropdown. Note that depending on the selected configuration, target
    platform, and architecture, not every project will be compiled to the expected
    output and might even not get compiled at all. For example, the UWP project always
    targets explicit architectures and as such, will compile to x86 when selecting
    the **Any CPU** architecture. That means not all combinations of target architecture
    and project will compile into what is specified but rather will fall back to a
    default architecture such as x86 in the case of UWP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the UWP app, select the **HelloWorld.UWP** project as the startup project
    if it isn''t already selected, by choosing **HelloWorld.UWP** from the startup
    project dropdown as shown in *Figure 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Configuration, architecture, startup project, and target machine
    options in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Configuration, architecture, startup project, and target machine
    options in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, select the correct architecture for your machine and the run configuration,
    debug, or release you want to run. Since we are going to debug the app in the
    next section, choose **Debug** for now. After that, you can choose the target
    device to deploy to, that is, the local machine, a connected device, or an emulator.
    To do that, use the dropdown to the right of the project list shown in *Figure
    2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – List of Android emulators in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – List of Android emulators in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then start the project by clicking on the green arrow or hitting *F5*.
    The app will build, and you should be greeted by something like *Figure 2.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Screenshot of the HelloWorld app running on Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.08_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Screenshot of the HelloWorld app running on Windows 10
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have just run your first Uno Platform app! Of course, running
    your app on Windows is not the only part of developing your cross-platform app.
    Running and debugging your app on Android, iOS, and other platforms is vital when
    writing cross-platform apps to ensure your apps work on all platforms supported.
  prefs: []
  type: TYPE_NORMAL
- en: For Android development, there are multiple different ways to try out and run
    your apps. One possibility is using an Android emulator, which comes with Visual
    Studio. For that, simply select the Android emulator from the target list dropdown
    as shown in *Figure 2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already added an Android emulator device image, you will only
    see **Android Emulator** as an option. To learn how to add and configure devices,
    the Visual Studio documentation ([https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager](https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager))
    covers creating new devices and configuring them for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: If you have connected an Android phone to your computer, it will show up in
    the list of available target devices. An example of this can be seen with the
    Samsung device shown in *Figure 2.7*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For optimal development experience with Visual Studio, when editing C# or XAML
    files, ensure Visual Studio will use the UWP head for IntelliSense since, otherwise,
    IntelliSense might not work correctly. For this, when you have opened a C# or
    XAML file, select the UWP head from the dropdown below the tab name of the opened
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing Visual Studio for Windows with a Mac
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For testing and debugging the iOS head, you can either directly develop on a
    Mac, which we will cover in the next section, or you can pair your Visual Studio
    for Windows with a Mac to remotely debug the iOS head.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Mobile development with .NET* workload in Visual Studio includes the software
    needed to connect to a Mac. However, there are three steps required to fully configure
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Install **Xcode** and **Visual Studio for Mac** on the Mac and open these apps
    to ensure all dependencies are installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Remote login** on the Mac.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the Mac from Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enabling remote login on the Mac requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Sharing** pane in **System Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Remote Login** and specify the users to **Allow access for:**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change any firewall settings as prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To connect from Visual Studio, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Tools** >**iOS**>**Pair to Mac.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're doing this for the first time, select **Add Mac…** and enter the Mac
    name or IP address, and then the username and password when prompted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Mac is already listed, select it and click **Connect**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool will check everything needed is installed and available on the Mac,
    and then it will open the connection.
  prefs: []
  type: TYPE_NORMAL
- en: If there's a problem, it will tell you what to do to address it.
  prefs: []
  type: TYPE_NORMAL
- en: Note.
  prefs: []
  type: TYPE_NORMAL
- en: More detailed instructions on pairing Visual Studio to a Mac and advice on addressing
    any problems you may encounter are available at [https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/](https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/).
  prefs: []
  type: TYPE_NORMAL
- en: With Visual Studio now successfully paired to your Mac, you're able to debug
    the app from your Windows machine and see it running on the remoted iOS simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Running and debugging your apps with Visual Studio for Mac
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are primarily working on a Mac, using Visual Studio for Mac is the easiest
    way of developing your Uno Platform app.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Uno Platform app using Visual Studio for Mac is the same as running
    other apps. You will need to select the correct head project in the startup project
    list (for example, `HelloWorld.macOS` or `HelloWorld.iOS`), select the correct
    target architecture to run the app for, and the device or emulator to run the
    app on.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in addition to running the app on your local machine, you can also
    run the Android or iOS app on an emulator. Any suitable devices that you can run
    the Android or iOS build of your app on will show up as targets in Visual Studio
    for Windows, including any emulators or simulators.
  prefs: []
  type: TYPE_NORMAL
- en: Since debugging the WASM build of your Uno Platform apps will happen outside
    of Visual Studio and Visual Studio for Mac, we will cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the WASM head of your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of writing, debugging WASM from inside Visual Studio or Visual
    Studio for Mac is not well supported, however, there are alternative options.
    Because of this, the debugging experience for WASM will instead take place inside
    your browser when using Visual Studio for Windows or Visual Studio for Mac. For
    the best debugging experience, we recommend using the latest Canary build of Google
    Chrome. This is available from [https://www.google.com/chrome/canary/](https://www.google.com/chrome/canary/).
    Since debugging WASM is still experimental, and as such will likely change, we
    highly recommend visiting the official documentation ([https://platform.uno/docs/articles/debugging-wasm.html](https://platform.uno/docs/articles/debugging-wasm.html))
    to get the latest information. You can learn more about debugging the WASM head
    with Visual Studio here: [https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/](https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use Visual Studio Code to debug the WASM version of
    your app. For an optimal experience, you should create your Uno Platform app with
    the `dotnet new` CLI. You must include the `–vscodeWasm` flag, as shown here,
    since it will add build configurations that you can use in Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that with the preceding `dotnet new` command, we opted out of the other
    heads since, at the time of writing, only the WASM version can be debugged with
    Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have created your app, please follow the steps shown in the documentation
    at [https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code](https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code).
    This also works when heads for other platforms are already present in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start your app and debug it with Visual Studio, first restore NuGet packages
    using `dotnet restore`. After that, you will need to start the development server.
    To do this, open the **RUN AND DEBUG** panel shown in *Figure 2.9* by clicking
    on the triangle-bug icon on the left of Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – RUN AND DEBUG view of Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – RUN AND DEBUG view of Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the arrow, which will run the **.NET Core Launch** configuration,
    which builds the app and starts a development server. The development server will
    host your app. Check the terminal output to see on which URL you can visit the
    WASM app on your local machine, as shown in *Figure 2.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Terminal output of the development server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Terminal output of the development server
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to start the app and continue without debugging capabilities,
    you are done here. However, if you want to take advantage of the debugging and
    breakpoint support, you will also have to select the **.NET Core Debug Uno Platform
    WebAssembly in Chrome** configuration. After selecting the launch configuration
    in the **Run and Debug** panel, start it, which will start the debugging server.
    The debugging server then opens a browser window with your Uno Platform WASM app
    opened.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, the debugging server will start using the latest stable release
    of Google Chrome. If you have no stable release of Google Chrome installed, the
    server will not start. If you wish to use the latest stable release of Edge instead,
    you can update the `.vscode/launch.json` file and change `pwa-chrome` to `pwa-msedge`.
  prefs: []
  type: TYPE_NORMAL
- en: After the debugging server has started and is ready for requests, it will open
    the website in Chrome or Edge depending on your configuration. Any breakpoints
    you place in Visual Studio Code will be respected by the browser and pause your
    WASM app, similar to how breakpoints would work with Visual Studio on non-WASM
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully completing these steps, you can open your app in a browser
    of your choice and it will look like *Figure 2.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – HelloWorld app running in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – HelloWorld app running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we covered running and debugging your app, let''s quickly cover two
    very helpful features for developing with Uno Platform: XAML Hot Reload and C#
    Edit and Continue.'
  prefs: []
  type: TYPE_NORMAL
- en: XAML Hot Reload and C# Edit and Continue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make development easier and faster, especially UI development, Uno Platform
    supports XAML Hot Reload and C# Edit and Continue when developing with Visual
    Studio. XAML Hot Reload allows you to modify the XAML code of your views and pages,
    and the running app will update in real time, while C# Edit and Continue allows
    you to modify C# code without having to restart your app for changes to be picked
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Since the UWP head of your app is being built using the UWP toolchain, you can
    use XAML Hot Reload and C# Edit and Continue. Since at the time of writing, UWP
    is the only platform supporting both, we will use UWP to showcase it. Other platforms
    do not support C# Edit and Continue, but do, however, support XAML Hot Reload.
  prefs: []
  type: TYPE_NORMAL
- en: XAML Hot Reload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To try out XAML Hot Reload, open your `MainPage.xaml` file inside the shared
    project. The page''s content will just be a `Grid` and a `TextBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now let's change our page by replacing the text with **Hello from hot reload!**,
    save the file (*Ctrl* + *S*), and voilà, our app now looks like as shown in *Figure
    2.12* without having restarted the app!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Our HelloWorld app with XAML Hot Reload changes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.12_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Our HelloWorld app with XAML Hot Reload changes
  prefs: []
  type: TYPE_NORMAL
- en: XAML Hot Reload works on UWP, iOS, Android, and WebAssembly. However, not all
    types of changes are supported, for example, changing the event handler of controls
    is not supported by XAML Hot Reload and requires an app restart. In addition to
    that, updating `ResourceDictionary` files will also not update the app and will
    require an app restart.
  prefs: []
  type: TYPE_NORMAL
- en: C# Edit and Continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you also need to make changes to your "*code-behind*", and that''s
    where C# Edit and Continue will be your friend. Note that you will need to use
    the UWP head of your app since it is the only platform supporting C# Edit and
    Continue. Before we continue with trying out C# Edit and Continue, you will need
    to add a few things since our HelloWorld app doesn''t contain much C# code yet.
    For that, first, you will need to close the debugger and the app since the following
    code changes are not supported by C# Edit and Continue. Update your page to contain
    a button with a `Click` event handler by changing your `MainPage` content to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your `MainPage` class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you run the app and click on the button, the text will change to **Hello
    from code behind!**. Now click the **Break all** button highlighted in *Figure
    2.13* or press *Ctrl* + *Alt* + *Break:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Break all button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Break all button
  prefs: []
  type: TYPE_NORMAL
- en: 'Your app is now paused and you can make changes to your C# code, which will
    be picked up when you resume your app by clicking on `Click` event handler to
    `Hello from C# Edit and Continue!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then resume the app. If you now click on the button, the text will now change
    to **Hello from C# Edit and Continue!**.
  prefs: []
  type: TYPE_NORMAL
- en: There are some limitations on the changes you can make with Edit and Continue
    though; not all code changes are supported, for example, changing the type of
    an object. For a full list of unsupported changes, please visit the official documentation
    ([https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp](https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp)).
    Note that at the time of writing, C# Edit and Continue only works on Windows for
    the UWP and the Skia heads.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered building and running your app, let's talk about conditional
    code, namely platform-specific C# and XAML.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific XAML and C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Uno Platform allows you to run your app on any platform without having
    to worry about the underlying platform-specific API, there are still cases where
    you might want to write code that is specific to a platform, for example, accessing
    native platform APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing platform-specific C# code is similar to writing architecture-specific
    or runtime-specific C# code. Uno Platform ships with a set of compiler symbols
    that will be defined when your code is being compiled for a specific platform.
    This is achieved using preprocessor directives. Preprocessor directives will only
    be respected by the compiler if the symbol was set for the compilation, otherwise,
    the compiler will completely ignore the preprocessor directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Uno Platform comes with the following preprocessor
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NETFX_CORE` for UWP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ANDROID__` for Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__IOS__` for iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HAS_UNO_WASM` (or `__WASM__`) for the web using WebAssembly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__MACOS__` for macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HAS_UNO_SKIA` (or `__SKIA__`) for Skia-based heads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that WASM and Skia have two different symbols available. Both are equally
    valid and have no difference except their name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use those exactly like you would any other symbols, such as `DEBUG`,
    and you can even combine them, for example, `if __ANDROID__ || __ MACOS__`. Let''s
    try it out in our example from earlier and have the `TextBlock` element indicate
    whether we are on desktop, the web, or mobile using C# symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you run the UWP head of your app and click the button, the text will then
    change to `NETFX_CORE` symbol being set. Now, if you run the app on an Android
    or iOS emulator (or device) and click on the button, it will display `__ANDROID__`
    or the `__IOS__` symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific XAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While platform-specific C# code is great, there are also cases where you need
    to render a control on a specific platform. This is where platform-specific XAML
    prefixes come in. XAML prefixes allow you to render controls only on specific
    platforms, similar to conditional namespaces for UWP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, at the time of writing, the following XAML prefixes that you can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Table of namespace prefixes, the supported platforms, and their
    namespace URIs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Table of namespace prefixes, the supported platforms, and their
    namespace URIs
  prefs: []
  type: TYPE_NORMAL
- en: To include a specific XAML prefix in your XAML, you have to add `xmlns:[prefix-name]=[namespace
    URI]` at the top of the XAML file with all other namespace declarations. **Prefix-name**
    is the XAML prefix (column 1 in *Figure 2.14*) while **namespace URI** is the
    URI of the namespace (column 3 in *Figure 2.14*) the prefix should be used with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For prefixes that will be excluded from Windows, you need to add the prefixes
    to the `mc:Ignorable` list. Those prefixes are `android`, `ios`, `wasm`, `macos`,
    `skia`, `xamarin`, `netstdref`, `not_netstdref`, and `not_win`, so all prefixes
    that are not in `http: //schemas.microsoft.com/winfx/2006/xaml/presentation.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try out a few platform XAML prefixes by updating our HelloWorld
    project to have a `TextBlock` element that only renders on WASM. For that, we
    will first add the prefix to our `MainPage.xaml` file (note that we have omitted
    some definitions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the Android, iOS, WASM, macOS, and Skia XAML prefixes will be excluded
    on Windows, we need to add them to the `mc:Ignorable` list. This is because they
    are not part of the standard XAML specification and would result in errors otherwise.
    After adding them, we can add controls that will render only if the app is running
    on a specific platform, for example, WASM or iOS. To try that out, we will add
    a `TextBlock` element to welcome users on each platform as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you start the WASM head of your app and open the app in your browser
    (if it''s not open already), the app will show the `TextBlock` element, as shown
    on the left side of *Figure 2.15*. If you start the UWP head of your app now,
    the app will show **Welcome on Windows!** instead, as shown on the right side
    of *Figure 2.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – HelloWorld app running using WASM (left) and using UWP (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – HelloWorld app running using WASM (left) and using UWP (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the XAML prefixes in cross-targeted libraries such as the
    `Cross Target Library (Uno Platform)` project template, which is covered in the
    next section, the XAML prefixes behave slightly differently. Because of the way
    cross-targeted libraries work, the `wasm` and `skia` prefixes will always evaluate
    to false. An example of a cross-targeted library is the `Cross-Runtime Library`
    project type, which we''ll cover in the next section. This is because both compile
    to .NET Standard 2.0 instead of the WASM or Skia heads. Instead of those prefixes,
    you can use the `netstdref` prefix with the namespace URI `http: //uno.ui/netstdref`,
    which will evaluate to true if running on WASM or Skia. In addition to that, there
    is also the `not_netstdref` prefix with the namespace URI `http: //uno.ui/not_netstdref`,
    which is the exact opposite of `netstdref`. Note that you will need to add both
    prefixes to the `mc:Ignorable` list. Now that you have learned about platform-specific
    code using C# compiler symbols and XAML prefixes, let''s look into the other project
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond the default cross-platform app structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a cross-platform app that contains the heads for every
    platform. But there are also different project types that you can use to write
    your Uno Platform app, which we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet` CLI, do this now by opening a terminal and running `dotnet new
    -i Uno.ProjectTemplates.Dotnet`, since we will use these in the remaining part
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-platform library project type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important project types besides the **Multi-Platform App (Uno
    Platform)** project type is the **Cross-Platform Library (Uno Platform)** type.
    The **Cross-Platform Library (Uno Platform)** project type allows you to write
    code that can be consumed by Uno Platform apps. The easiest way of getting to
    know the project type is by creating a new cross-platform library. We will do
    this by creating a new project inside our existing HelloWorld solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use all the project templates installed with the `dotnet new`
    CLI, you will need to allow Visual Studio to include the `dotnet new` templates
    in the project type list. You can do this by opening the options under **Tools
    > O****ptions** and opening the **Preview Features** section located under **Environment**
    by checking **Show all .NET Core templates in the New Project dialog**. After
    this, you will need to restart Visual Studio for the changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling that option, restart Visual Studio and open the new project
    dialog by right-clicking on the solution in the solution view and clicking **Add**
    > **New Project**. The dialog will look like *Figure 2.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The Add a new project dialog in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.16_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – The Add a new project dialog in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the `HelloWorld.Helpers`. After entering the name, click **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a new cross-platform Uno Platform library in your solution.
    On disk, the library has its own folder named after itself and your solution view
    will look like *Figure 2.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – HelloWorld solution view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – HelloWorld solution view
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some code to our cross-platform library. We will rename the
    class `Class1` to `Greetings` and introduce a new public static function called
    `GetStandardGreeting` that will return the string `"Hello from a cross-platform
    library!"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In addition to creating the library, you must also add a reference to it in
    each of the head projects you want to use the project in. The process of adding
    a reference to the library is the same for all heads, that's why we will only
    show you how to add the reference to the UWP head.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the reference to the UWP head, right-click the UWP project in Solution
    Explorer. Inside the context menu, you will find the **Add** category, which contains
    the **Reference…** option, which is also shown in *Figure 2.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Add | Reference… option for the UWP head'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Add | Reference… option for the UWP head
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Reference…**, a new dialog where you can select the reference
    to add will open. In our case, you will need to select the project, as shown in
    *Figure 2.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Reference Manager for the UWP head'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B17132.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Reference Manager for the UWP head
  prefs: []
  type: TYPE_NORMAL
- en: 'After checking the `HelloWorld.Helpers` project, click **OK** to save the changes.
    Now we can use our library in the UWP version of the app. Let''s update our event
    handler from the platform''s conditional code section to use the Greetings helper
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you run the UWP version of the app now and click on the button, the app will
    display `Helpers namespace` in the `HelloWorld namespace`. This is because we
    have not added a reference to the library from the macOS head yet. For any platform
    where you plan to use the library, you will need to add a reference in the platform's
    head. The procedure also applies to libraries being referenced as a NuGet package;
    you will need to add a reference to the NuGet package in every platform head that
    you want to use the library in. Unlike the Uno Platform app project, where most
    of the source code is inside a shared project, the **Cross-Platform Library**
    project type is a multi-targeted project.
  prefs: []
  type: TYPE_NORMAL
- en: Other project types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the Cross-Platform Library project type, there are other Uno
    Platform project templates. We will cover them broadly in this section. To be
    able to create them from Visual Studio, enable displaying `dotnet` new templates
    in Visual Studio as shown in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with app development using XAML and the MVVM pattern,
    you might already know Prism ([https://prismlibrary.com/](https://prismlibrary.com/)),
    a framework *"for building XAML applications that are loosely coupled, maintainable,
    and testable."* Among the Uno Platform templates is also the **Cross-Platform
    App (Prism) (Uno Platform)** template, which will create a Prism Uno Platform
    app. Creating a Prism Uno Platform app is the same as creating a "normal" multi-platform
    Uno app.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the Uno Platform Prism app template, there is also an Uno Platform
    template for building apps for **WinUI 3**. However, you can create an Uno Platform
    app that uses a preview version of WinUI 3 for Windows 10\. To create an Uno Platform
    app using WinUI 3, in the new project dialog, choose the **Cross-Platform App
    (WinUI) (Uno Platform)** template.
  prefs: []
  type: TYPE_NORMAL
- en: Another project type that will be useful, especially when developing libraries
    that will be shipped using NuGet, is the **Cross-Runtime Library (Uno Platform)**
    project type, which will create a Cross-Runtime Library. In contrast to the Cross-Platform
    Library, where Skia and WASM versions are not built separately and cannot be distinguished,
    the Cross-Runtime Library will compile the project separately for WASM and Skia,
    allowing the writing of WASM- and Skia-specific code using XAML prefixes and compiler
    symbols.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, we also have the **Cross-Platform UI Tests Library**. The
    Cross- Platform UI Tests Library allows you to write UI tests that can be run
    on multiple platforms using a single code base. Since we will cover testing more
    thoroughly in [*Chapter 7*](B17132_07_Final_VK_ePub.xhtml#_idTextAnchor119), *Testing
    Your Apps*, we will cover that project type there.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we have the `Xamarin.Forms` apps to the web using WebAssembly
    and Uno Platform, which will be covered in [*Chapter 8*](B17132_08_Final_VK_ePub.xhtml#_idTextAnchor132),
    *Deploying Your Apps and Going Further*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create, build, and run your first Uno Platform
    app, and learned about the general solution structure and how platform heads work.
    We also covered building, running, and debugging your app on different platforms
    using Visual Studio and Visual Studio Code. In addition to that, you also learned
    about using XAML Hot Reload and C# Edit and Continue to make development easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will write apps for UnoBookRail, the company operating
    public transport in UnoBookCity. We will start off [*Chapter 3*](B17132_03_Final_VK_ePub.xhtml#_idTextAnchor052),
    *Working with Forms and Data*, by writing a task management app for UnoBookRail
    that allows entering, filtering, and editing data on the desktop and the web.
  prefs: []
  type: TYPE_NORMAL
