- en: Consensus Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to build a consensus algorithm for the blockchain
    network. A consensus algorithm is a way for all of the nodes inside of the network
    to agree upon which data is correct and should be retained inside the blockchain.
    In order to build the consensus algorithm, we are first going to build a new method,
    called `chainIsValid`. This method will simply validate a blockchain by comparing
    all of the hashes of all of the blocks inside of the chain. After that, we are
    going to build a `/consensus` endpoint that we will hit whenever we want to use
    the consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What the consensus algorithm is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and testing the `chainIsValid` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and testing the `/consesnsus` endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started with the consensus algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: What is the consensus algorithm ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a blockchain is built, it is running across hundreds or thousands of nodes,
    and every transaction and every block that's being created is broadcast to the
    entire blockchain network. There's a possibility that during these broadcasts
    a hiccup could occur, or maybe a certain node doesn't receive a piece of information
    or a transaction that took place.
  prefs: []
  type: TYPE_NORMAL
- en: There could even be a bad actor inside of the blockchain network, who is sending
    out false information or creating fraudulent transactions on their copy of a blockchain,
    and trying to broadcast them to the whole network to convince everybody that they
    are legitimate transactions. So, how do we solve this problem so that there are
    only legitimate blocks in the blockchain network?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the consensus algorithm is going to help us out. The consensus
    algorithm will provide us with a way to compare one node to all the other nodes
    inside of the network to confirm that we have the correct data on that specific
    node. There are currently many different consensus algorithms out there being
    used for different blockchain networks. For our blockchain network, we're going
    to create a consensus algorithm that implements the *longest chain rule*.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the *longest chain rule* takes a look at a single node and the copy
    of the blockchain on that node, comparing the length of the chains on one node
    with the length of the chains on all the other nodes. During this comparison,
    if there is a chain found that has a longer length than the chain that's present
    on the chosen node, the algorithm is going to replace the chain that's on the
    chosen node with the longest chain in the network.
  prefs: []
  type: TYPE_NORMAL
- en: The theory behind using this is that we should be able to trust the longest
    chain to hold the correct data, because the most work was put into creating that
    chain. The longest chain has the most blocks in it and each of those blocks was
    mined by using a proof of work. Consequently, we can assume that the whole network
    contributed to the longest chain because of how much work went into that chain.
    For this reason, we're going to use a consensus algorithm that implements the
    longest chain rule. The Bitcoin blockchain network itself actually implements
    this longest chain rule in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Building the chainIsValid method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start building the consensus algorithm by creating a new method called
    `chainIsValid`. This method will validate whether or not a chain is legitimate.
    Let''s get started with building this method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `blockchain.js` file, after the `proofOfWork` method, let''s define
    the method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this method will take in a `blockchain` as an argument, and will return
    to us whether the `blockchain` is valid or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We're going to use this `chainIsValid` method to validate the other chains inside
    of the network when we are comparing them to the chain that is hosted on the current
    node. In order to validate that the blockchain is legitimate, we're simply going
    to iterate through every block inside of the blockchain and verify whether or
    not all of the hashes align correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might recall from [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml), *Building
    a Blockchain*  that when the `createNewBlock` method was defined, that method
    consisted of the `previousBlockHash` and `hash` property. This `hash` property
    is the hash of the current block . To build the `chainIsValid` method, let''s
    iterate through every block inside of the blockchain and make sure that the `previousBlockHash`
    property of a given block is exactly the same as the hash property in the previous
    block. Let''s define this condition inside of the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to iterate through every block inside of the blockchain, we''ll use
    a `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of this `for` loop, let''s compare the current block to the previous
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we iterate through the entire chain on every iteration, the `currentBlock`
    will be the value of `i`, and the `prevBlock` will be the value of `i - 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, all we want to do is compare the `previousBlockHash` property on the
    `currentBlock` with the hash property on the previous block. In order to do this,
    define the following condition in the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to the preceding condition that we mentioned, if it is not satisfied,
    then we know that the chain is not valid, because the hashes are not lining up
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To satisfy the verification condition, the `previousBlockHash` on the current
    block should be equal to the hash of the previous block. We''re going to signify
    the aforementioned condition with the help of a flag inside of the method, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we have the `validChain` variable reading equal to `true`. As we
    go through the blockchain and see that the hashes don't align properly, then we
    would want to set the `validChain` variable to `false` to signify that the chain
    is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s get back to the `if` statement. Add the aforementioned condition
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the loop, we can simply return a `validChain` variable and we''ll
    get the value returned as `true` if the chain is valid, and `false` if it is not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is one more thing that we want to do, and that is to validate that every
    single block inside of the chain has the correct data. We can do this by rehashing
    the `currentBlock` by using the `hashBlock` method. If the generated hash starts
    with four zeros as we saw in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml),
    *Building a Blockchain*, then we know that all of the data is valid. However,
    if it does not start with the four zeros then we know the data inside of the block
    is definitely not valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All we''re going to do is iterate through every block in the chain is to rehash
    every block and make sure that each hash starts with four zeros. So inside of
    the `for` loop let''s mention this condition by first defining a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hashblock()` method accepts parameters such as: `previousBlockhash`, `currentBlockData`
    and the `nonce`. Let''s pass these parameters now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to pass `currentBlockData` as parameter, which, as you might
    remember from the previous chapter, consists of the transactions in the `currentBlock`
    and the index of the `currentBlock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last parameter that we have to pass is `nonce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining these parameters, we should have the hash of `currentBlock`
    stored in the `blockHash` variable. Next, we just want to validate that the hash
    starts with the four zeros. So, inside of the `for` loop, we''ll mention the following
    condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re basically iterating through the entire blockchain and simply checking
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: One check that we do is making sure that all of the hashes align properly. If
    they do not align properly, we indicate that the chain is not valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other check that we are doing is hashing every block, and making sure that
    the `blockHash` string starts with four zeros. If it does not start with the four
    zeros, then we indicate that the chain is not valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now the `chainIsValid` method is just about done here. However, one important
    thing that you might have noticed is that we haven''t checked the genesis block
    for any of the methods yet. In the loop that we defined in the preceding block
    of code, we''re starting at position 1, and totally skipping position 0, which
    is the genesis block. The genesis block is a kind of special block, because we
    made it ourselves without doing a proof of work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, in order to validate the genesis block, we just want to make
    sure that it has the properties that we initially put onto it. So, outside of
    the `for` loop, we''ll mention this condition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just want to check and verify that all of the properties on the genesis
    block are correct. If you remember in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml), *Building
    a Blockchain* where we defined the genesis block, we assigned to it values such
    as `nonce`, with a value of `100`, `previousBlockHash`, with a value `0`, and
    the `hash` of the string 0 as well. So, let''s check for these properties now
    to make sure that they''re correct. In the following snippet, we add the preceding
    line of code to the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to verify that the genesis block should have no transactions
    in it. So, to check this, we''ll mention the following condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we do have a legitimate genesis block, then all of these variables
    that we defined should be the value true. If any of these variables are not valid,
    then we want to change the `validChain` variable to `false` so that we know the
    blockchain is not valid. Let''s mention this condition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Mentioning this last condition completes the `chainIsValid` method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the chainIsValid method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s test the `chainIsValid` method by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `test.js` file, let''s import the blockchain data structure and create
    a new instance of the blockchain, called `bitcoin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's generate a blockchain for us to test. We'll do this by starting
    at one of the servers. So go to the terminal, type `npn run node_1` and press
    *Enter*. Then you'll receive the response, Listening on port 3001.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On node `3001`, now let's create a blockchain and add some data to it so that
    we can test the new blockchain. Currently, the blockchain on node `3001` only
    has the genesis block in it. So, let's add a couple more blocks to the chain by
    hitting the `/mine` endpoint. Therefore, in the browser, go to `localhost:3001/mine`
    to create a new block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you go to `localhost:3001/blockchain`, you should be able to observe
    the new block as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a3128e28-2ca5-4d4c-9230-3a2d60f02ac4.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, at node `3001`, we now have two blocks in the chain and one pending transaction,
    which is the mining reward transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create some transactions to add to the blockchain. To add the
    transaction, go to Postman and just add a couple of transactions there, as seen
    in the following screenshot. Let''s send these transactions to `localhost:3001`,
    and also hit the `/transaction/broadcast` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c5f1ba3a-78e6-4c7f-92ea-2250f6e4c496.png)'
  prefs: []
  type: TYPE_IMG
- en: You can similarly add many other transactions to the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the transactions have been added, let''s mine a new block by going to `localhost:3001/mine`.
    Once the new block has been mined, visit `localhost:3001/blockchain` in order
    to verify that the block has been added to the network. You should observe an
    output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c071524a-1a7e-4d61-a52c-2c8e8b13735a.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll see that node `3001` consists of the third block with all the transaction
    data that we passed inside the block. We also have one pending transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a couple more transactions to the node `3001` and then mine
    a new block on that node. You''ll get to observe the similar output as seen in
    the previous case. The new transactions data that we added is now present inside
    the fourth block that we mined. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09d6460c-e4dd-4817-8c48-4bb9e0a44ff5.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's mine two more blocks without any data in them. So now, we have a
    blockchain with six blocks in it. Out of these six blocks, two blocks don't have
    any transaction data present in them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the entire blockchain present on `localhost:3001` and paste it in the
    `test.js` file. Then, after pasting the data in the `test.js` file, let''s save
    that pasted text as a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `chainIsValid` method to validate the chain. To do this, in
    the `test.js` file, let''s mention the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's save the `test.js` file and run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the output of the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, when we run this file, we should receive verification of a valid blockchain,
    because we didn''t tamper with it and created it legitimately, using all of the
    correct methods. Let''s verify whether or not the `chainIsValid` method works
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the Terminal and cancel the previous processes that were running
    by typing `^C` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the processes are cancelled, then in the Terminal, let''s type `node dev/test.js`
    and press *Enter*. As we haven''t tampered with the blockchain, we''ll get the
    `Valid: true` response, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f4f5aaf-f460-4123-8ab2-0208c1b89d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s tamper with the blockchain a little bit and see if we can get a
    false value returned:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the blockchain data that we pasted into the `test.js` file, let's
    change one of the hashes on any one of the blocks to see if it invalidates the
    blockchain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have changed the hash of any block, save the file and run the test
    again. Since the data is tampered now, you''ll get the `false` response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fcd7a8f5-208d-46ad-aa38-386e4ee16451.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's mess with some of the transaction data in one of the blocks. If
    we change any of the transaction data inside of one of the blocks, the chain should
    not be valid and we should receive a false response for the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s test the genesis block, which is the first block in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4a37b58-6b30-4c1e-b29b-ce2e15128b60.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `test.js` file in the blockchain data that we pasted, let's change the
    `nonce` value to 10 from 100\. After saving the file and running the test again
    in the Terminal, we should get the output returned as `false`. Since we tampered
    with the data in the blockchain in the `test.js` file, when we ran the test we
    got the response of `false`. This signifies that the blockchain is not valid or
    legitimate anymore, as the data inside it has been tampered with. So, from this
    test we can conclude that the `chainIsValid` method works perfectly, just as we
    expected it to.
  prefs: []
  type: TYPE_NORMAL
- en: A tiny modification to verify the results properly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, one tiny thing that we need to do to help us understand how the `chainIsValid`
    method works is to log out the `previousBlockHash` and the `currentBlock` hash
    of every single block so that we can compare them ourselves. Consequently, in
    the `chainIsValid` method inside of the `for` loop, let''s add the following lines
    of code before the loop ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save this modification and run the test again. This time, when we run
    the test, we should see all of the hashes logged out so that we can compare them
    for ourselves and see what''s really happening inside of this method. After running
    the test, you should see the `previousBlockHash` and `currentBlockHash` values,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c112ba0-73d8-4f9a-8e30-06a80fb3a2fb.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can observe that for every iteration, the
    `previousBlockHash` value matches the `currentBlockHash` value of the previous block.
    If you look at all of the hashes, you can see them logged out in pairs. From the
    screenshot, we can observe that we have many pairs of identical hashes, which
    is what makes the blockchain valid.
  prefs: []
  type: TYPE_NORMAL
- en: Building the /consensus endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s build the `/consensus` endpoint, which will use the `chainIsValid` method
    that we built in the previous section. Carry out the following steps to build
    the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to `networkNode.js` file and, after the `/register-node-bulk` endpoint,
    define the `/consensus` endpoint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside of the `/consensus` endpoint, let''s make a request to every other
    node inside of the blockchain network to get their copies of the blockchain and
    compare them to the copy of the blockchain that''s hosted on the current node
    that we''re currently on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of this `forEach` loop, let''s do the same things that we''ve done countless
    times while defining the other endpoints in the previous chapters. So, the first
    thing we have to do for the requests is define some options as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the options, we need to `request-promise` the `requestOptions`
    and push all of these requests into a promise array because each of these requests
    returns a promise to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `forEach` loop has ran, we''ll have an array that''s filled up with
    all of the requests. Next, let''s run the requests as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s use the data that we receive from all of these promises. This
    data that we''re receiving is going to be an array of blockchains from every node
    inside of the network. So, after the preceding line of code, let''s define the
    code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s iterate through all of these `blockchains` that came from the other
    nodes inside of the network, and see if there is a blockchain inside of the other
    node that is longer than the copy of the blockchain hosted on the current node.
    We''ll start by cycling through all of the blockchains that we got in the responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, all we want to do inside of the `forEach` loop is identify whether
    one of the blockchains from the other nodes in the network is longer than the
    blockchain hosted on the current node. In order to do this, let''s define a couple
    of variables to keep track of all of the data, as follows. The first variable
    that we want to define is the length of the blockchain hosted on the current node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define a variable that will change if we come across a longer
    blockchain in the `blockchains` array. The first thing we want to define is the
    `maxChainLength` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to define a variable called `newLongestChain`. Initially we''re
    going to set it as equal to null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the last variable that we''ll define will be called `newPendingTransactions`.
    Let''s set this as equal to `null` initially, as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `forEach` loop, we''re looking to see if there is a longer
    chain inside of the blockchain network than is currently on the node that we are
    on. If there is a longer chain inside the network, then change these aforementioned
    variables to reflect that. Consequently, inside of the `forEach` loop, define
    the `this` condition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after the `forEach` loop has ran, we''ll have all of the data required
    to determine if we need to replace the chain that is hosted on this current node.
    Next, after the loop, let''s define the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Basically, what we're stating in this `if` statement is that if there is no
    `newLongestChain` meaning, then the current chain is the longest. Alternatively,
    if there is a new longest chain but that new chain is not valid, then in these
    two cases we don't want to replace the blockchain that's hosted on the current
    node. So we're going to send back the note that says 'Current chain has not been
    replaced'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if there is a `newLongestChain` and that chain is valid, now is when
    we want to replace the blockchain that''s hosted on the current node with the
    longest chain in the network. We''ll define all this inside of the else block
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Quick review of the build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we did in this endpoint is made requests to all of the
    other nodes in the network so that we could access the blockchain that is hosted
    on each of them. After we ran all of these requests, we then had access to all
    of the blockchains that are hosted on all of the other nodes inside of the network.
    We then iterate through all of the other blockchains inside of the network with
    the help of the `forEach` loop. And as we iterated through the other blockchains,
    and if we find a longer chain we then update the `maxChainLength`, `newLongestChain`,
    and `newPendingTransactions` variables to reflect that. Then, when the `forEach`
    loop is complete, we'll know if there is a chain on the network longer than the
    blockchain hosted on the current node. If there is a longer chain found inside
    of the network, we'll have access to the `pendingTransactions` of that blockchain.
    So, after the `forEach` loop has ran, we'll then have access to all of the data
    necessary to replace the erroneous blockchain that's hosted on the current node.
  prefs: []
  type: TYPE_NORMAL
- en: We then state whether there is no new longer chain or if there is no chain longer
    than the blockchain hosted on the current node. If there is a longer chain inside
    of the network, but that chain is not valid, then in both of these cases we do
    not want to replace the blockchain that's hosted on the current node, so we simply
    send back a response that says the current chain has not been replaced.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if there is a longer chain inside of the network and that
    chain is valid, then we'll want to replace the blockchain that's hosted on the
    current node. We simply send back a response saying that this chain has been replaced,
    as well as sending back the new blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the consensus algorithm and the `/consensus` endpoint will work.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the /consensus endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test the consensus endpoint that we just built. So, what should this
    `/consensus` endpoint do? When we call the `/consensus` endpoint on a specific
    node, it should confirm for us that that particular node has the correct blockchain
    data in it, and the node is in sync with the rest of the network. Let''s get started
    with building the test:'
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to make a network that consists of the first four nodes. So
    let's go to Postman and hit the register-and-broadcast-node endpoint on the node
    that's hosted on `3001`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add the second node to the network, as seen in the following screenshot.
    We''ll then click on the Send button, receiving the response, New node registered
    with network successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b368c45a-4c9b-49aa-ace6-1b2a3e3f4dd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, you can register the remaining nodes, `3003` and `3004`, to the network.
    Now, if you go to the browser and check all the nodes, you will observe that all
    the nodes from `3001` to `3004` are connected to each other, but node 3005 is
    not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, what we want to do is mine a couple of blocks on the blockchain network,
    except for the fifth node. So in the browser, let''s hit `localhost: 3001/mine`.
    This will mine one block for us on node `3001`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, let's mine two blocks on `localhost:3003` and one block on `localhost:3004`.
    Now, all of these nodes should have five blocks in them. You verify this by hitting
    `localhost:3001/blockchain` in the browser. You will get to observe all five of
    the blocks that we just added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we want to connect the fifth node to the blockchain network.
    So, let''s go to Postman and send the request for 3005, as seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a0f7b07-9868-4e2f-92c0-8b6130b79835.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So now, node `3005` should be connected to the network. You can verify this
    in the browser as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4deb4518-9e54-48d6-9a9e-43308078d02b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that `3005` is part of the network, this is where the problem arises: node
    `3005` does not have the correct blockchain data inside of the blockchain. It
    should have all of the five blocks that the other nodes have. This is where the
    `/consensus` endpoint comes into play. We should be able to hit the `/consensus`
    endpoint and resolve this issue. After we do this, we should expect the blockchain
    on node `3005` to have the same data as all the other nodes inside of the network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this now. Open another tab in the browser, and in the address bar,
    type `localhost:3005/consensus` and then run it by pressing *Enter*. You should
    observe similar output to that seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8383833-ebe7-4d79-be6e-8b982678c0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we get the response, This chain has been replaced,
    and the new blockchain data then replaces the old data on this node. Let's verify
    this node by going to another tab in the browser and hitting `localhost:3005/blockchain`.
    You'll see that all the blocks that were present in the network are added to the
    node on `3005`. Thus the node on `3005` now has the correct blockchain data. We
    achieved this by hitting the `/consensus` endpoint on node `3005`. Now, all of
    the nodes inside of the blockchain network should have exactly the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you again try to hit the `/consensus` endpoint on the node on `3005`,
    we would get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bab9a994-3b0a-4dd0-82dc-7ad083b82423.png)'
  prefs: []
  type: TYPE_IMG
- en: We received such a response because all the blocks that were present in the
    network were already added to node `3005` when we previously ran the consensus
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: From this test, we can conclude that the `/consensus` works perfectly and as
    expected. The `/consensus` endpoint has the ability to correct a node inside of
    the blockchain if it has the wrong data.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you mess around with the `/consensus` endpoint and test
    it in different ways. Add some transactions to the data and make sure that it correctly resolves
    nodes that hold the wrong data. By testing this endpoint a little bit more, you
    will become more familiar with how it is works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All blockchains have a consensus algorithm, and in this chapter, we built our
    own consensus algorithm that implements the longest chain rule. We started by
    building the `chainIsValid` method. In this method, we simply iterated through
    every single block inside of the blockchain, and compared hashes on every block
    to make sure that they are correct. Then we moved on to test the method. In addition
    to this, we built the `/consensus` endpoint with the help of the `chainIsValid`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to build a block explorer that we'll be able
    to access on the browser. This block explorer will allow us to interact with the
    blockchain through a user interface.
  prefs: []
  type: TYPE_NORMAL
