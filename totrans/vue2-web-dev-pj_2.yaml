- en: Project 1 - Markdown Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first app we will create is a markdown notebook, using several Vue features
    in a step-by-step manner. We will reuse what we saw in [Chapter 1](00860a76-5dac-4df9-825a-549899184959.xhtml),
    *Getting Started with Vue*, and add more elements on top of it, such as useful
    directives, events for user interaction, more instance options, and filters to
    process values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing the code, let''s talk about the app and review our
    objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: The notebook app will allow the user to write notes in markdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The markdown will be previewed in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users will be able to add as many notes as they want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notes will be restored the next time the user visits the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do that, we will divide the user interface into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: A main section in the middle with the note editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A right pane, which previews the markdown of the current node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A left pane, with the list of notes and a button to add a new one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what it will look like at the end of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26d6cfab-5fd8-4e60-a85b-6116232af19c.png)'
  prefs: []
  type: TYPE_IMG
- en: A basic note editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start small with a very simple markdown note app that only displays
    a text editor on the left and a markdown preview on the right. Then, we will turn
    it into a full notebook with multiple note support.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we will have a few files ready to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download *simple-notebook* project files and extract them in the same
    folder. Open the `index.html` file and add a `div` element with the `notebook`
    ID and a nested `section` element with the `main` class. You should have the following
    content inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `script.js` file to add some JavaScript. Just like you did in
    [Chapter 1](00860a76-5dac-4df9-825a-549899184959.xhtml), *Getting Started with
    Vue*, create a Vue instance mounted on the `#notebook` element with a Vue constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a data property called `content` that will hold the content of your
    note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to create your first real Vue app.
  prefs: []
  type: TYPE_NORMAL
- en: The note editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our app running, let's add the text editor. We will use a simple
    `textarea` element and the `v-model` directive we saw in [Chapter 1](00860a76-5dac-4df9-825a-549899184959.xhtml),
    *Getting Started with Vue*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `section` element and put the `textarea` inside, then add the `v-model`
    directive bound to our `content` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you change the text ;inside the note editor, the value of `content`
    should automatically chance in the devtools.
  prefs: []
  type: TYPE_NORMAL
- en: The `v-model` directive is not limited to text inputs. You can also use it in
    other form elements, such as checkboxes, radio buttons, or even custom components,
    as we will see later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The preview pane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile the note markdown into valid HTML, we will need an additional library
    called Marked ([https://www.npmjs.com/package/marked](https://www.npmjs.com/package/marked)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the library in the page just after the `script` tag referencing Vue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`marked` is very easy to use--just call it with the markdown text, and it will
    return the corresponding HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the library with some markdown text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have the following output in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Computed property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very powerful feature of Vue is the **computed property**. It allows us to
    define new properties that combine any amount of properties and use transformations,
    such as converting a markdown string into HTML--that''s why its value is defined
    by a function. A computed property has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The value is cached so that the function doesn't rerun if it's not necessary,
    preventing useless computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is automatically updated as needed when a property used inside the function
    has changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computed property can be used exactly like any property (and you can use computed
    properties inside other computed properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not computed until it is really used somewhere in the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will help us automatically convert the note markdown into valid HTML,
    so we can display a preview in real time. We just need to declare our computed
    property in the `computed` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Text interpolation escaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to display our note in a new pane using a text interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `<aside>` element with the `preview` class, which displays our `notePreview`
    computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We should now have the preview pane displaying our note on the right side of
    the app. If you type some text in the note editor, you should see the preview
    updating automatically. However, there is an issue with our app, which arises
    when you use markdown formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try making your text bold by surrounding it with `**`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our computed property should return this in valid HTML, and we should have
    some bold text rendered in our preview pane. Instead, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have just discovered that the text interpolation automatically escapes the
    HTML tags. This is to prevent injection attacks and improve the security of our
    app. Fortunately, there is a way to display some HTML, as we will see in a moment.
    However, this forces you to think about using it to include potentially harmful
    dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you create a comment system, where any user can write some text
    to comment on your app pages. What if someone writes some HTML in their comment,
    which is then displayed in the page as valid HTML? They could add some malicious
    JavaScript code, and all the visitors of your app would be vulnerable. It's called
    a cross-site scripting attack, or an XSS attack. That's why text interpolation
    always escapes HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: It is not recommended to use `v-html` on content created by the users of the
    application. They could write malicious JavaScript code inside a `<script>` tag
    that would be executed. However, with normal text interpolation, you would be
    safe because the HTML would not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know that text interpolations can''t render HTML for security reasons,
    we will need another way to render dynamic HTML--the `v-html` directive. Like
    the `v-model` directive we saw in [Chapter 1](00860a76-5dac-4df9-825a-549899184959.xhtml),
    *Getting Started with Vue*, this is a special attribute that adds a new feature
    to our template. This one is able to render any valid HTML string into our app.
    Just pass the string as the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the markdown preview should work correctly, and the HTML is dynamically
    inserted in our page.
  prefs: []
  type: TYPE_NORMAL
- en: Any content inside our `aside` element will be replaced by the value of the
    `v-html` directive. You can use this to put placeholder contents inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result you should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a68e9943-826c-4926-823e-c780269c4f51.png)There is an equivalent
    directive for text interpolation, `v-text`, which behaves like `v-html`, but escapes
    the HTML tags just like classic text interpolations.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving the note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, if you close or refresh the app, your note will be lost. It would be
    a good idea to save and load it the next time we open the app. To achieve this,
    we will use the standard `localStorage` API provided by most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Watching changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would like to save our note as soon as its content changes. That's why we
    need something that is called when our `content` data property changes, such as
    **watchers**. Let's add some watchers to our application!
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `watch` option to the Vue instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This option is a dictionary with the keys being the name of the watched properties
    and the value being a watching option object. This object has to have a `handler`
    property, which is either a function or the name of a method. The handler will
    receive two arguments--the new value and the old value of the property being watched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example with a simple handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you type in the note editor, you should get the following message
    in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will be very helpful in saving the note whenever it changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other options you can use alongside `handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deep` is a Boolean that tells Vue to watch for changes recursively inside
    nested objects. This is not useful here, as we only watch a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`immediate` is also a Boolean that forces the handler to be called immediately
    instead of waiting for the first change. In our case, this will not have a meaningful
    impact, but we can try it to note its effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value of these options is `false`, so if you don't need them, you
    can skip them entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the immediate option to the watcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you refresh the app, you should see the following message pop up
    in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, the old value of the note was `undefined`, because the watcher
    handler was called when the instance was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t really need this option here, so go ahead and delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are not using any option, we can use a shorter syntax by skipping
    the object containing the `handler` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common syntax for watchers when you don't need other options,
    such as `deep` or `immediate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save our note. Use the `localStorage.setItem()` API to store the note
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether this worked, edit the note and open the browser devtools in
    the Application or Storage tab (depending on your browser) you should find a new
    entry under the Local Storage section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a0f073bb-c9be-4778-b02f-7b2e1378d589.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a good coding principle that says *Don''t Repeat Yourself*, and we
    really should follow it. That''s why we can write some logic in reusable functions
    called **methods**. Let''s move our saving logic into one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `methods` option to the Vue instance and use the `localStorage` API
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the method name in the `handler` option of our watcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use it with the shorter syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the Vue instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the methods, we can access the Vue instance with the `this` keyword.
    For example, we could call another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `saveNote` method will be called from the `contentChanged` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also access the other properties and special functions of our Vue instance
    through `this`. We could remove the `saveNote` argument and access the `content`
    data property directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works in the watcher handler we created in the *Watching changes*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, you can access the Vue instance with `this` in any function bound
    to it: methods, handlers, and other hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading the saved note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we save the note content each time it changes, we will need to restore
    it when the app is reopened. We will use the `localStorage.getItem()` API for
    that. Add the following line at the end of your JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you refresh your app, you should see the saved note content printed in
    the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first way that comes to mind to restore our note content into the Vue instance
    is to set the content data property when the instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: Each Vue instance follows a precise lifecycle with several steps--it will be
    created, mounted on the page, updated, and finally, destroyed. For example, during
    the creating step, Vue will make the instance data reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are a specific set of functions that are automatically called at some
    point in time. They allow us to customize the logic of the framework. For example,
    we can call a method when a Vue instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have multiple hooks at our disposal to execute logic when, or just before,
    each of these steps occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeCreate`: This is called when the Vue instance object is created (for
    example, with `new Vue({})`), but before Vue has done anything with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: This is called after the instance is ready and fully operating.
    Note that, at this point, the instance is not in the DOM yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeMount`: This is called just before the instance is added (or mounted)
    on the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mounted`: This is called when the instance is on the page and visible in the
    DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeUpdate`: This is called when the instance needs to be updated (generally,
    when a data or computed property has changed).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated`: This is called after the data changes are applied to the template.
    Note that the DOM may not be up to date yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeDestroy`: This is called just before the instance is torn down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroyed`: This is called when the instance is fully removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we will only use the `created` hook to restore the note content. To
    add a lifecycle hook, just add a function with the corresponding name into the
    Vue instance options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you refresh the app, the ;`created` hook will be automatically called
    when the instance is created. This will set the `content` data property value
    to the result of the restoration or to `'You can write in **markdown**'` if the
    result was falsy, in case we didn't have anything saved before.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, a value is falsy when equal to `false`, `0`, an empty string,
    `null`, `undefined`, or `NaN` (not a number). Here, the `localStorage.getItem()`
    function will return `null` if the corresponding key doesn't exist in the browser
    local storage data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The watcher we set up is also called, so the note is saved, and you should
    see something similar to this in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when the created hook is called, Vue has already set the data
    properties and their initial values (here, *This is a note*).
  prefs: []
  type: TYPE_NORMAL
- en: Initializing directly in the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other way is to initialize the `content` data property with the restored
    value directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, the watcher handler will not be called because we initialize
    the `content` value instead of changing it.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A notebook with only one note is not that useful, so let's turn it into a multiple
    note one. We will add a new side panel on the left with the list of notes, plus
    a few extra elements, such as a text field to rename the notes and a favorite
    toggle button.
  prefs: []
  type: TYPE_NORMAL
- en: The note list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now lay the groundwork for the side pane containing the list of notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `aside` element with the `side-bar` class before the main section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new data property called `notes`--it will be the array containing all
    of our notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A method to create a new note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of our notes will be an object with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This will be the note unique identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This ;will contain the name of the note displayed in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: This ;will be the note markdown content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: This ;will be the date the note was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`favorite`: This ;will be a Boolean that allows for marking a note that will
    be displayed at the top of the list as favorite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add a method that will create a new note and call it `addNote`, which
    will create a new note object with a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We take the current time (which means the number of milliseconds elapsed since
    1 January 1970 00:00:00 UTC), which will be a perfect way to have a unique identifier
    on each note. We also set default values, such as a title and some content, plus
    the `created` date and the `favorite` ;Boolean. Finally, we add the note to the
    notes array property.
  prefs: []
  type: TYPE_NORMAL
- en: Button and click events with v-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will need a button to call this method. Create a new button element
    inside a `div` element with the toolbar class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the `addNote` method when the user clicks on the button, we will need
    a new directive--`v-on`. The value will be the function called when the event
    is caught, but it also expects an argument to know which event to listen to. However,
    how do we pass the argument to the directive, you might ask? It''s quite simple!
    Add a `:` character after the directive name, followed by the argument. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we are using the `v-on` directive with the event name as the argument,
    and more specifically, the `click` event. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our button should call the `addNote` method when it is clicked on, so go ahead
    and modify the button we added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an optional special shortcut for the `v-on` directive--the `@` character
    that allows you to rewrite the preceding ;code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our button is ready, try adding a few notes. We don''t see them in
    the app yet, but you can open the devtools and note the note list change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7a2f1ea-e8f8-436b-8699-5ec0629dcb6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Binding attributes with v-bind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be helpful if a tooltip showed the number of notes we already had on
    the "Add note" button, wouldn't it? At least we can introduce another useful directive!
  prefs: []
  type: TYPE_NORMAL
- en: 'The tooltips are added with the title HTML attribute. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is only a static text, though, and we would like to make it dynamic.
    Thankfully, there is a directive that allows us to bind a JavaScript expression
    to an attribute--`v-bind`. Like the `v-on` directive, it expects an argument,
    which is the name of the target attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding example with a JavaScript expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you leave the mouse cursor over the button, you will get the number
    of notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1629233d-8be8-4523-9296-3080cf6680f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like the `v-on` directive, `v-bind` has a special shortcut syntax (both are
    the most used directives)--you can just skip the `v-bind` part and only put the
    `:` character with the attribute name. The example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript expressions bound with `v-bind` will re-evaluate automatically when
    needed and update the value of the corresponding attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also move the expression to a computed property and use it instead.
    The computed property could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we would rewrite the bound attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a list with v-for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now display the list of notes below the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the toolbar, add a new `div` element with the ;notes class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to display a list of multiple div elements, one for each note.
    To achieve this, we need the `v-for` directive. It takes a special expression
    as the value, in the form of `item of items`, that will iterate over the `items`
    array or object and expose an `item` value for this part of the template. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `in` keyword instead of `of`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The final rendered DOM will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the element on which you put the `v-for` directive is repeated
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our notebook and display the notes in the side pane. We store
    them in the notes data property, so we need to iterate over it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have the notes list displayed below the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee4871d5-a8b1-4345-8f7e-1b0d0acb7ba0.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a few more notes using the button, and you should see that the list is updating
    automatically!
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a note is selected, it becomes the context of the middle and right panes
    of the app--the text editor modifies its content, and the preview pane displays
    its formatted markdown. Let's implement this behavior!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new data property called `selectedId` that will hold the ID of the selected
    note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We could have created a `selectedNote` property instead, holding the note object,
    but it would have made the saving logic more complex, with no benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a new method that will be called when we click on a note in the list
    to select ID. Let''s call it `selectNote`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did for the add note button, we will listen for the `click` event with
    the `v-on` directive on each note item in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see the ;updated `selectedId` data property when you click on
    a note.
  prefs: []
  type: TYPE_NORMAL
- en: The current note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know which note is currently selected, we can replace the old `content`
    data property we created at the beginning. It would be very useful to have a computed
    property to easily access the selected note, so we will create one now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new computed property called `selectedNote` that returns the note with
    an ID that matches our `selectedId` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`note => note.id === this.selectedId` is an arrow function from the ES2015
    JavaScript version. Here, it takes a `note` argument and returns the result of
    the `note.id === this.selectedId` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to replace the old `content` data property with `selectedNote.content`
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by modifying the editor in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the `notePreview` computed property to now use `selectedNote`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, the text editor and the preview pane will display the selected note when
    you click on it in the list.
  prefs: []
  type: TYPE_NORMAL
- en: You can safely remove the `content` data property, its watcher, and the `saveNote`
    method, which are no longer used in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic CSS classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be nice to add a `selected` CSS class when a note is the selected
    one in the note list (for example, to display a different background color). Thankfully,
    Vue has a very useful trick to help us achieve this--the `v-bind` directive (the
    `:` character being its shorthand) has some magic to make the manipulation of
    CSS classes easier. Instead of passing a string, you can pass an array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the most interesting feature is that you can pass an object whose
    keys are the class names and whose values are Booleans that determine whether
    or not each class should be applied. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This object notation will produce the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we want to apply the selected class only if the note is the selected
    one. So, we will simply write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The note list should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can combine a static `class` attribute with a dynamic one. It is recommended
    that you put the nondynamic classes into the static attribute because Vue will
    optimize the static values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you click on a note in the list to select it, its background will
    change color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d0218a83-4367-4dad-9aa3-2973bbe607bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Conditional templates with v-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need one last thing before testing our change; the main and preview panes
    shouldn't be displayed if no note is selected--it would not make sense for the
    user to have an empty editor and preview pane pointing to nothing, and it would
    make our code crash since `selectedNote` would be `null`. Thankfully, the `v-if`
    directive can dynamically take parts out of the template when we want. It works
    just like the JavaScript `if` keyword, with a condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `div` element will not be in the DOM at all while the
    `loading` property is falsy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also two other useful directives, `v-else` and `v-else-if`, that
    will work as you might have expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in our app, add the `v-if="selectedNote"` condition to both the main and
    preview panes so that they are not added to the DOM until a note is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The repetition here is a bit unfortunate, but Vue has us covered. You can surround
    both elements with a special `<template>` tag that acts like braces in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the app should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7ba0db17-d712-407b-b3fd-5064e0d86990.png)The `<template>` tag will
    not be present in the DOM; it is more like a ghost element that is useful to regroup
    real elements together.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving the notes with the deep option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we would like to save and restore the notes between sessions, just like
    we did for the note content:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `saveNotes` method. Since we can''t save an array of objects
    directly into the `localStorage` API (it only accepts strings), we need to convert
    it to JSON first with `JSON.stringify`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Like we did for the previous `content` property, we will watch the `notes` data
    property for changes to trigger the `saveNotes` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a watcher in the watch option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to add a few tasks, you should see something like this in your
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the initialization of the `notes` property in the `data` hook to load
    the stored list from `localStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly added notes should be restored when you refresh the page. However,
    if you try to change the content of one note, you will notice that it doesn''t
    trigger the `notes` watcher, and thus, the notes are not saved. This is because,
    by default, the watchers are only watching the direct changes to the target object--assignment
    of a simple value, adding, removing, or moving an item in an array. For example,
    the following operations will be detected by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'However, all the other operations, like these, will not trigger the watcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you will need to add the `deep` option to the watcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: That way, Vue will also watch the objects and attributes recursively inside
    our `notes` array. Now, if you type into the text editor, the notes list should
    be saved--the `v-model` directive will modify the `content` property of the selected
    note, and with the `deep` option, the watcher will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be very handy if our app could select the note that was selected last
    time. We just need to store and load the `selectedId` data property used to store
    the ID of the selected note. That''s right! Once more, we will use a watcher to
    trigger the save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will restore the value when the property is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It's ready! Now, when you refresh the app, it should look exactly how you left
    it, with the same note selected.
  prefs: []
  type: TYPE_NORMAL
- en: The note toolbar with extras inside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some features are still missing from our app, such as deleting or renaming
    the selected note. We will add these in a new toolbar, just above the note text
    editor. Go ahead and create a new `div` element with the `toolbar` class ;inside
    the main section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add three new features in this toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking the note as favorite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming the note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This first toolbar feature is also the easiest. It only consists of a text input
    bound to the `title` property of the selected note with the `v-model` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the toolbar `div` element we just created, add this `input` element with
    the `v-model` directive and a `placeholder` to inform the user of its function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a functional rename field above the text editor and see the
    note name change automatically in the note list as you type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0942004-709f-461e-bdec-e67bede061fe.png)Since we set the `deep`
    option on the `notes` watcher, the note list will be saved whenever you change
    the name of the selected note.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This second feature is a bit more complicated because we need a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `button` element after the rename text input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we listen to the `click` event with the `v-on` shorthand (the
    `@` character) that calls the `removeNote` method that we will create very soon.
    Also, we put an appropriate icon as the button content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `removeNote` method that asks the user for confirmation and then
    removes the currently selected note from the `notes` array using the `splice`
    standard array method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try deleting the current note, you should note that the following
    three things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The note is removed from the note list on the left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text editor and the preview pane are hidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The note list has been saved according to the browser console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favorite notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last toolbar feature is the most complex. We want to reorder the note list
    with the favorite notes first. To do that, each note has a `favorite` Boolean
    property that will be toggled with a button. In addition to that, a star icon
    will be displayed in the note list to make it obvious which notes are favorite
    and which ones are not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding another button to the toolbar before the Remove note ;button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we use the `v-on` shorthand to call the `favoriteNote` method we
    will create next. We will also display an icon, depending on the value of the
    `favorite` property of the selected note--a full star if it is `true`, or an outlined
    one if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4496b4b-718c-4f8b-a564-4bdc0e7441a2.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left, there is a button for when the note is not favorite, and on the
    right, for when it is, after clicking on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a very simple `favoriteNote` method that only invert the value
    of the `favorite` ;Boolean property on the selected note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this with the XOR operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be nicely shortened, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should be able to toggle the favorite button, but it doesn't have any
    real effect yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to sort the note list in two ways--first, we sort all the notes by
    their creation date, then we sort them so that the favorite ones are put at the
    start. Thankfully, we have a very convenient standard array method for that--`sort`.
    It takes one argument, which is a function with two parameters--two items to be
    compared. The result is a number, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`, if the two items are in an equivalent position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1`, if the first item should be before the second one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`, if the first item should be after the second one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are not limited to the `1` number, since you can return any arbitrary number,
    positive or negative. For example, if you return `-42`, it will be the same as
    `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first sorting operation will be achieved with this simple subtracting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Here, we compare two notes on their creation date that we stored as a number
    of milliseconds, thanks to `Date.now()`. We just subtract them so that we get
    a negative number if `b` was created after `a`, or a positive number if `a` was
    created after `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second sort is done with two ternary operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If both notes are favorite, we don't change their position. If `a` is favorite,
    we return a negative number to put it before `b`. In the other case, we return
    a positive number, so `b` is put before `a` in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The best way is to create a computed property called `sortedNotes`, which will
    get updated and cached automatically by Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new `sortedNotes` computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Since `sort` modifies the source array directly, we should create a copy of
    it with the `slice` method. This will prevent unwanted triggers of the `notes`
    watcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can simply swap `notes` with `sortedNotes` in the `v-for` directive
    used to display the list--it will now sort the notes automatically as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `v-if` directive we introduced earlier to display a star
    icon only if the note is favorite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the note list with the preceding changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The app should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30ce8ce9-6cf9-45de-9ca1-4c05c0b7af68.png)'
  prefs: []
  type: TYPE_IMG
- en: The status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section we will add to our app is a status bar, displayed at the bottom
    of the text editor, with some useful info--the date the note was created, with
    the lines, words, and characters count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `div` element with the `toolbar` and `status-bar` classes and
    place it after the `textarea` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Created date with a filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now display the creation date of the selected note in the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the status bar `div` element, create a new `span` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you look at the result displayed in your browser, you should see the
    number of milliseconds representing the date the note was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/58a60c05-cdb9-4c97-951b-aa0a0b4aa28e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not user-friendly at all!
  prefs: []
  type: TYPE_NORMAL
- en: We need a new library to help us format the date into a more readable result--`momentjs`,
    which is a very popular time and date manipulation library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include it in the page like we did for the `marked` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To format a date, we will first create a `moment` object, and then we will
    use the `format` method like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now is the time to introduce one last feature of Vue for this chapter--the **filters**.
    These are functions that are used inside templates to easily process data before
    it is displayed or passed to an attribute. For example, we could have an uppercase
    filter to transform a string into uppercase letters or a currency filter to convert
    currencies on the fly in a template. The function takes one argument--the value
    to be processed by the filter. It returns the processed value.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will create a new `date` filter that will take a date time and will format
    it to a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register this filter with the `Vue.filter` global method (outside of the Vue
    instance creation code, for example, at the beginning of the file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this `date` filter in our template to display dates. The syntax
    is the JavaScript expression like we used before, followed by a pipe operator
    and the name of the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If `someDate` contains a date, it will output something like this in the DOM,
    respecting the `DD/MM/YY, HH:mm` format we defined before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the stat template into this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We should have the date nicely formatted and displayed in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5766d56-229f-4660-b907-65a8adcff067.png)'
  prefs: []
  type: TYPE_IMG
- en: Text stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last stats we can display are more "writer-oriented"--the lines, words,
    and characters count:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create three new computed properties for each counter, with some Regular
    Expressions to get the job done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added some conditions to prevent the code from running if no note is
    currently selected. This will avoid crashes if you use the Vue devtools to inspect
    the app in this case, because it will try to compute all the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now add three new stat `span` elements with the corresponding computed
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The final status bar should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54df01f4-25c9-4868-aac9-ad1edc8658d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first real Vue app, with several useful functions,
    like a real-time markdown preview, a note list, and the local persistence of the
    notes. We introduced different Vue features, such as the computed properties that
    are automatically updated and cached as needed, the methods to reuse logic inside
    functions, the watchers to trigger code when properties change, lifecycle hooks
    to execute code when the Vue instance is created, and the filters to easily process
    expressions in our template. We also used a lot of Vue directives inside our template,
    such as ;`v-model` to bind form inputs, `v-html` to display dynamic HTML from
    our JavaScript properties, `v-for` to repeat elements and display lists, `v-on`
    (or `@`) to listen to events, `v-bind` (or `:`) to dynamically bind HTML attributes
    to JavaScript expressions or to apply CSS classes dynamically, and `v-if` to include
    or not template parts, depending on JavaScript expressions. We saw all of these
    features come together to build a fully functional web application, with Vue superpower
    helping us to get the work done without getting in the way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start a new project--a card-based browser game.
    We will introduce some new Vue features and will keep reusing all we know to continue
    building better and prettier web apps.
  prefs: []
  type: TYPE_NORMAL
