- en: Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common myths and questions around TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it takes more efforts for a developer to write unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether code coverage metrics is good or bad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether TDD would work for complex legacy projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether TDD is even applicable for embedded products or products that involve
    hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test frameworks for C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Google test framework on Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process to build a Google test and mock together as one single static library
    without installing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first test case using Google test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google test framework in Visual Studio IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing legacy code that has dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's deep dive into these TDD topics.
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is an extreme programming practice. In
    TDD, we start with a test case and incrementally write the production code that
    is required to make the test case succeed. The idea is that one should focus on
    one test case or scenario at a time and once the test case passes, they can then
    move on to the next scenario. In this process, if the new test case passes, we
    shouldn''t modify the production code. In other words, in the process of developing
    a new feature or while fixing a bug, we can modify the production code only for
    two reasons: either to ensure the test case passes or to refactor the code. The
    primary focus of TDD is unit testing; however, it can be extended to integration
    and interaction testing to some extent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the TDD process visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d95cc185-e449-42cf-ac2d-4bb5cfd65492.png)'
  prefs: []
  type: TYPE_IMG
- en: When TDD is followed religiously, one can achieve both functional and structural
    quality of the code. It is very crucial that you write the test case first before
    writing the production code as opposed to writing test cases at the end of the
    development phase. This makes quite a lot of difference. For instance, when a
    developer writes unit test cases at the end of development, it is very unlikely
    that the test cases will find any defect in the code. The reason is that the developers
    will unconsciously be inclined to prove their code is doing the right thing when
    the test case is written at the end of development. Whereas, when developers write
    test cases upfront, as no code is written yet, they start thinking from the end
    user's point of view, which would encourage them to come up with numerous scenarios
    from the requirement specification point of view.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, test cases written against code that is already written will
    generally not find any bug as it tends to prove the code written is correct, instead
    of testing it against the requirement. As developers think of various scenarios
    before writing code, it helps them write better code incrementally, ensuring that
    the code does take care of those scenarios. However, when the code has loopholes,
    it is the test case that helps them find issues, as test cases will fail if they
    don't meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is not just about using some unit test framework. It requires cultural and
    mindset change while developing or fixing defects in the code. Developers' focus
    should be to make the code functionally correct. Once the code is developed in
    this fashion, it is highly recommended that the developers should also focus on
    removing any code smells by refactoring the code; this will ensure the structural
    quality of the code would be good as well. In the long run, it is the structural
    quality of the code that would make the team deliver features faster.
  prefs: []
  type: TYPE_NORMAL
- en: Common myths and questions around TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of myths and common doubts about TDD that crosses everyone's mind
    when they are about to start their TDD journey. Let me clarify most of them that
    I came across, for while I consulted many product giants around the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Does it take more efforts for a developer to write a unit test?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common doubts that arises in the minds of most developers is, "How
    am I supposed to estimate my effort when we adapt to TDD?" As developers are supposed
    to write unit and integration test cases as part of TDD, it is no wonder you are
    concerned about how to negotiate with the customer or management for the additional
    effort required to write test cases in addition to writing code. No worries, you
    aren't alone; as a freelance software consultant myself, many developers have
    asked me this question.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you test your code manually; instead, write automated test cases
    now. The good news is that it is a one-time effort that is guaranteed to help
    you in the long run. While a developer requires repeated manual effort to test
    their code, every time they change the code, the already existing automated test
    cases will help the developer by giving them immediate feedback when they integrate
    a new piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that it requires some additional effort, but in the long
    run, it helps reduce the effort required.
  prefs: []
  type: TYPE_NORMAL
- en: Is code coverage metrics good or bad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage tools help developers identify gaps in their automated test cases.
    No doubt, many times it will give a clue about missing test scenarios, which would
    eventually further strengthen the automated test cases. But when an organization
    starts enforcing code coverage as a measure to check the effectiveness of test
    coverage, it sometimes drives the developers in the wrong direction. From my practical
    consulting experience, what I have learned is that many developers start writing
    test cases for constructors and private and protected functions to show higher
    code coverage. In this process, developers start chasing numbers and lose the
    ultimate goal of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: In a particular source with a class that has 20 methods, it is possible that
    only 10 methods qualify for unit testing while the other methods are complex functionality.
    In such a case, the code coverage tools will show only 50 percent code coverage,
    which is absolutely fine as per the TDD philosophy. However, if the organization
    policy enforces a minimum 75 percent code coverage, then the developers will have
    no choice other than testing the constructor, destructor, private, protected,
    and complex functions for the sake of showing good code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The trouble with testing private and protected methods is that they tend to
    change more often as they are marked as implementation details. When private and
    protected methods change badly, that calls for modifying test cases, which makes
    the developer's life harder in terms of maintaining the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, code coverage tools are very good developer tools to find test scenario
    gaps, but it should be left to a developer to make a wise choice of whether to
    write a test case or ignore writing test cases for certain methods, depending
    on the complexity of the methods. However, if code coverage is used as project
    metrics, it more often tends to drive developers to find wrong ways to show better
    coverage, leading to bad test case practices.
  prefs: []
  type: TYPE_NORMAL
- en: Does TDD work for complex legacy projects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certainly! TDD works for any type of software project or products. TDD isn't
    meant just for new products or projects; it is also proven to be more effective
    with complex legacy projects or products. In a maintenance project, the vast majority
    of the time one has to fix defects and very rarely one has to support a new feature.
    Even in such legacy code, one can follow TDD while fixing defects.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you would readily agree with me that once you are able to reproduce
    the issue, almost half of the problem can be considered fixed from the developer's
    point of view. Hence, you can start with a test case that reproduces the issue
    and then debug and fix the issue. When you fix the issue, the test case will start
    passing; now it's time to think of another possible test case that may reproduce
    the same defect and repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: Is TDD even applicable for embedded or products that involve hardware?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like application software can benefit from TDD, embedded projects or projects
    that involve hardware interactions can also benefit from the TDD approach. Interestingly,
    embedded projects or products that involve hardware benefit more from TDD as they
    can test most part of their code without the hardware by isolating the hardware
    dependency. TDD helps reduce time to market as most part of the software can be
    tested by the team without waiting for the hardware. As most part of the code
    is already tested thoroughly without hardware, it helps avoid last-minute surprises
    or firefighting when the board bring-up happens. This is because most of the scenarios
    would have been tested thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: As per software engineering best practices, a good design is loosely coupled
    and strongly cohesive in nature. Though we all strive to write code that is loosely
    coupled, it isn't possible to write code that is absolutely independent all the
    time. Most times, the code has some type of dependency. In the case of application
    software, the dependency could be a database or a web server; in the case of embedded
    products, the dependency could be a piece of hardware. But using dependency inversion,
    **code under test** (**CUT**) can be isolated from its dependency, enabling us
    to test the code without its dependency, which is a powerful technique. So as
    long as we are open to refactoring the code to make it more modular and atomic,
    any type of code and project or product will benefit from the TDD approach.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing frameworks for C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a C++ developer, you have quite a lot of options when choosing between unit
    testing frameworks. While there are many more frameworks, these are some of the
    popular ones: CppUnit, CppUnitLite, Boost, MSTest, Visual Studio unit test, and
    Google test framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Though older articles, I recommend you to take a look at [http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle](http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle)
    and [https://accu.org/index.php/journals/](https://accu.org/index.php/journals/).
    They might give you some insight into this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Without any second thought, Google test framework is one of the most popular
    testing frameworks for C++ as it is supported on a wide variety of platforms,
    actively developed, and above all, backed by Google.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will use the Google test and Google mock frameworks.
    However, the concepts discussed in this chapter are applicable to all unit test
    frameworks. We'll deep dive into Google test framework and its installation procedure
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Google test framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google test framework is an open source testing framework that works on quite
    a lot of platforms. TDD only focuses on unit testing and to some extent integration
    testing, but the Google test framework can be used for a wide variety of testing.
    It classifies test cases as small, medium, large, fidelity, resilience, precision,
    and other types of test cases. Unit test cases fall in small, integration test
    cases fall in medium, and complex functionalities and acceptance test cases fall
    in the large category.
  prefs: []
  type: TYPE_NORMAL
- en: It also bundles the Google mock framework as part of it. As they are technically
    from the same team, they play with each other seamlessly. However, the Google
    mock framework can be used with other testing frameworks, such as CppUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Google test framework on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the Google test framework from [https://github.com/google/googletest](https://github.com/google/googletest)
    as source code. However, the best way to download it is via the Git clone from
    the terminal command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Git is an open source **distributed version control system** (**DVCS**). If
    you haven't installed it on your system, you will find more information on why
    you should, at [https://git-scm.com/](https://git-scm.com/). However, in Ubuntu,
    it can be easily installed with the `sudo apt-get install git` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code is downloaded as shown in *Figure 7.1*,you''ll be able to locate
    the Google test framework source code in the `googletest` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43ea535a-e0d9-44b8-b18c-2c82d511f092.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The `googletest` folder has both the `googletest` and `googlemock` frameworks
    in separate folders. Now we can invoke the `cmake` utility to configure our build
    and autogenerate `Makefile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a469ad65-a7fe-4efa-9849-eb9d38f8484b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `cmake` utility is invoked, it detects the C/C++ header''s files and
    its path that are necessary to build the Google test framework from the source
    code. Also, it will try to locate the tools required to build the source code.
    Once all the necessary headers and tools are located, it will autogenerate the
    `Makefile`. Once you have `Makefile` in place, you can use it to compile and install
    Google test and Google mock on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates how you can install google test on your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/068d26e0-a29d-4c43-9721-331927b1cabe.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the make install command has compiled and installed
    `libgmock.a` and `libgtest.a` static library files in the `/usr/local/lib` folder.
    Since the `/usr/local/lib` folder path is generally in the system's PATH environment
    variable, it can be accessed from any project within the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to build google test and mock together as one single static library without
    installing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case you don't prefer installing the `libgmock.a` and `libgtest.a` static
    library files and the respective header files on common system folders, then there
    is yet another way to build the Google test framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will create three object files, as shown in *Figure 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7b46440b-d9e3-48d7-8604-9d1291689366.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to combine all the object files into a single static library
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, your folder should have the brand new `libgtest.a` static
    library, as shown in *Figure 7.5*. Let''s understand the following command instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will help us create three object files: **gtest-all.o**, **gmock-all.o**,
    and **gmock_main.o**. The `googletest` framework makes use of some C++11 features,
    and I have purposefully used c++14 to be on the safer side. The `gmock_main.cc`
    source file has a main function that will initialize the Google mock framework,
    which in turn will internally initialize the Google test framework. The best part
    about this approach is that we don''t have to supply the main function for our
    unit test application. Please note the compilation command includes the following
    `include` paths to help the g++ compiler locate the necessary header files in
    the Google test and Google mock frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the next step is to create our `libgtest.a` static library that will bundle
    both gtest and gmock frameworks into one single static library. As the Google
    test framework makes use of multiple threads, it is mandatory to link the `pthread`
    library as part of our static library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ar` archive command helps combine all the object files into a single static
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image demonstrates the discussed procedure practically in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23ae3d8d-2856-41dd-8e85-0bac6528f156.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test case using the Google test framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learning the Google test framework is pretty easy. Let''s create two folders:
    one for production code and the other for test code. The idea is to separate the
    production code from the test code. Once you have created both the folders, start
    with the `Math.h` header, as shown in *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e2b47e-6cf2-4f3b-a03f-1ca002f7fe06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6
  prefs: []
  type: TYPE_NORMAL
- en: The `Math` class has just one function to demonstrate the usage of the unit
    test framework. To begin with, our `Math` class has a simple add function that
    is good enough to understand the basic usage of the Google test framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the place of the Google test framework, you could use CppUnit as well and
    integrate mocking frameworks such as the Google mock framework, mockpp, or opmock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement our simple `Math` class in the following `Math.cpp` source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/663dba83-afac-496d-9099-216be0d78ddc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7
  prefs: []
  type: TYPE_NORMAL
- en: The preceding two files are supposed to be in the `src` folder, as shown in
    *Figure 7.8*. All of the production code gets into the `src` folder, and any number
    of files can be part of the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b5b3f21-af90-42df-a626-47a2aca9f1df.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8
  prefs: []
  type: TYPE_NORMAL
- en: As we have written some production code, let's see how to write some basic test
    cases for the preceding production code. As a general best practice, it is recommended
    to name the test case file as either `MobileTest` or `TestMobile` so that it is
    easy for anyone to predict the purpose of the file. In C++ or in the Google test
    framework, it isn't mandatory to maintain the filename and class name as the same,
    but it is generally considered a best practice as it helps anyone locate a particular
    class just by looking at the filenames.
  prefs: []
  type: TYPE_NORMAL
- en: Both the Google test framework and Google mock framework go hand in hand as
    they are from the same team, hence this combination works pretty well in the majority
    of the platforms, including embedded platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already compiled our Google test framework as a static library,
    let''s begin with the `MathTest.cpp` source file straight away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18006d24-fd2d-4063-87c6-eced0305f9a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.9***,** at line number 18,we included the gtest header file from
    the Google test framework. In the Google test framework, test cases are written
    using a `TEST` macro that takes two parameters. The first parameter, namely `MathTest`,
    represents the test module name and the second parameter is the name of the test
    case. Test modules help us group a bunch of related test cases under a module.
    Hence, it is very important to name the test module and test case aptly to improve
    the readability of the test report.
  prefs: []
  type: TYPE_NORMAL
- en: As you are aware, `Math` is the class we are intending to test; we have instantiated
    an object of the `Math` object at *line 22*. In *line 25*, we invoked the add
    function on the math object, which is supposed to return the actual result. Finally,
    at *line 27*, we checked whether the expected result matches the actual result.
    The Google test macro `EXPECT_EQ` will mark the test case as passed if the expected
    and actual result match; otherwise, the framework will mark the test case outcome
    as failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, we are all set now. Let''s see how to compile and run our test case now.
    The following command should help you compile the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the compilation command includes the following include path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, it is important to note that we also linked our Google test static library
    `libgtest.a` and the POSIX pthreads library as the Google test framework makes
    use of multiple .
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a036f74-590c-4bc1-877f-b13b846c4538.png)**Figure 7.10**'
  prefs: []
  type: TYPE_NORMAL
- en: Congrats! We have compiled and executed our first test case successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google test framework in Visual Studio IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to download the Google test framework `.zip` file from [https://github.com/google/googletest/archive/master.zip](https://github.com/google/googletest/archive/master.zip).
    The next step is to extract the `.zip` file in some directory. In my case, I have
    extracted it into the `googletest` folder and copied all the contents of `googletest
    googletest-master\googletest-master` to the `googletest` folder, as shown in *Figure
    7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dfd0ab3-e8a1-434b-bc0b-72badd7486e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11
  prefs: []
  type: TYPE_NORMAL
- en: It is time to create a simple project in Visual Studio. I have used Microsoft
    Visual Studio Community 2015\. However, the procedure followed here should pretty
    much remain the same for other versions of Visual Studio, except that the options
    might be available in different menus.
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a new project named `MathApp` by navigating to New Project
    | Visual Studio | Windows | Win32 | Win32 Console Application, as shown in *Figure
    7.12*. This project is going to be the production code to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b707e56c-2110-4992-b811-eb1877d09571.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the `MyMath` class to the `MathApp` project. The `MyMath` class is
    the production code that will be declared in `MyMath.h` and defined in `MyMath.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `MyMath.h` header file shown in *Figure 7.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c55972d8-0721-4b52-bf6c-cb4d28c0b94f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `MyMath` class looks as shown in *Figure 7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cca9e18a-37ce-42ac-889e-7b7fb40943f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is a console application, it is mandatory to supply the main function,
    as shown in *Figure 7.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fb3b3f4-2f2e-49ab-95d4-d23925575a26.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add a static library project named `GoogleTestLib` to
    the same `MathApp` project solution, as shown in *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02e32c32-faaa-473f-8b74-3e394f782223.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the following source files from the Google test framework
    to our static library project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to compile the static library, we need to include the following header
    file paths in `GoogleTestLib/Properties/VC++ Directories/Include` directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may have to customize the paths based on where you have copied/installed
    the Google test framework in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to add the `MathTestApp` Win32 console application to the `MathApp`
    solution. We need to make `MathTestApp` as a `StartUp` project so that we can
    directly execute this application. Let's ensure there are no source files in the
    `MathTestApp` project before we add a new source file named `MathTest.cpp` to
    the `MathTestApp` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to configure the same set of Google test framework include paths we
    added to the `GoogleTestLib` static library. In addition to this, we must also
    add the `MathApp` project directory as the test project will refer to the header
    file in the `MathApp` project, as follows. However, customize the paths as per
    the directory structure you follow for this project in your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `MathAppTest` project, make sure you have added references to `MathApp`
    and `GoogleTestLib` so that the `MathAppTest` project will compile the other two
    projects when it senses changes in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! We are almost done. Now let''s implement `MathTest.cpp`, as shown in
    *Figure 7.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/426f9b27-1907-472a-b0a3-c28e496f1112.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is ready now; let''s run the test cases and check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d100a0ee-81f9-41f7-91a3-0c7de0c1908d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18
  prefs: []
  type: TYPE_NORMAL
- en: TDD in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how to develop an **Reverse Polish Notation** (**RPN**) calculator
    application that follows the TDD approach. RPN is also known as the postfix notation.
    The expectation from the RPN Calculator application is to accept a postfix math
    expression as an input and return the evaluated result as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step by step, I would like to demonstrate how one can follow the TDD approach
    while developing an application. As the first step, I would like to explain the
    project directory structure, then we''ll move forward. Let''s create a folder
    named `Ex2` with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a15c754-3b1f-428e-813f-4f2a87fe7258.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19
  prefs: []
  type: TYPE_NORMAL
- en: The `googletest` folder is the gtest test library that has the necessary `gtest`
    and `gmock` header files. Now `libgtest.a` is the Google test static library that
    we created in the previous exercise. We are going to use the `make` utility to
    build our project, hence I have placed a `Makefile` in the project `home` directory.
    The `src` directory will hold the production code, while the test directory will
    hold all the test cases that we are going to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start writing test cases, let''s take a postfix math *"2  5  *  4
     +  3  3  *  1  +  /"* and understand the standard postfix algorithm that we are
    going to apply to evaluate the RPN math expression. As per the postfix algorithm,
    we are going to parse the RPN math expression one token at a time. Whenever we
    encounter an operand (number), we are going to push that into the stack. Whenever
    we encounter an operator, we are going to pop out two values from the stack, apply
    the math operation, push back the intermediate result into the stack, and repeat
    the procedure until all the tokens are evaluated in the RPN expression. At the
    end, when no more tokens are left in the input string, we will pop out the value
    and print it as the result. The procedure is demonstrated step by step in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/057ac184-3b3e-4fcf-9617-9c3ddf84c354.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s take a simple postfix math expression and translate the
    scenario into a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding test case as a Google test in the test folder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to compile the preceding test case, let''s write the minimal production
    code that is required in the `src` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As the RPN math expression will be supplied as a space-separated string, the
    evaluate method will take a string input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `Makefile` class helps run the test cases every time we compile
    the production code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f46e005-c5c5-40d0-bded-77c7d0005b7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s build and run the test case and check the test case''s outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc5b5ecf-28fb-423d-abdc-f98ba1516cce.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, we always start with a failing test case. The root cause of the failure
    is that the expected result is 25, while the actual result is 0\. The reason is
    that we haven't implemented the evaluate method, hence we have hardcoded to return
    0, irrespective of any input. So let's implement the evaluate method in order
    to make the test case pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify `src/RPNCalculator.h` and `src/RPNCalculator.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df9a2b2e-f7b8-44f0-a857-5f608e71284c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23
  prefs: []
  type: TYPE_NORMAL
- en: 'In the RPNCalculator.h header file, observe the new header files that are included
    to handle string tokenizing and string double conversion and copy the RPN tokens
    to the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d6680ea-c84b-4cec-9970-a8f634e11907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24
  prefs: []
  type: TYPE_NORMAL
- en: As per the standard postfix algorithm, we are using a stack to hold all the
    numbers that we find in the RPN expression. Anytime we encounter the `+` math
    operator, we pop out two values from the stack and add them and push back the
    results into the stack. If the token isn't a `+` operator, we can safely assume
    that it would be a number, so we just push the value to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding implementation in place, let''s try the test case and check
    whether the test case passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecb11d2d-abab-4ed2-b958-26dd5f060d72.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, our first test case has passed as expected. It''s time to think of another
    test case. This time, let''s add a test case for subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding test case as a Google test in the test folder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding test case added to `test/RPNCalculatorTest`, it should now
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fff5058-d457-471b-802c-a5f8ff001a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the test cases and check whether our new test case passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a6c83e3-7724-40f5-bb08-847a7e1baea0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, the new test fails as we haven''t added support for subtraction
    in our application yet. This is very evident, based on the C++ exception, as the
    code attempts to convert the subtraction `-` operator into a number. Let''s add
    support for subtraction logic in our evaluate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/619fc762-2234-42e5-bfc5-30d0134c4691.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to test. Let''s execute the test case and check whether things are
    working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/919d804c-5617-4f91-8c5a-1fc00f59d9a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29
  prefs: []
  type: TYPE_NORMAL
- en: Cool! Did you notice that our test case failed in this instance? Wait a minute.
    Why are we excited if the test case failed? The reason we should be happy is that
    our test case found a bug; after all, that is the main intent of TDD, isn't?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f356de93-2fab-434b-acf8-cacf1af1f182.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.30
  prefs: []
  type: TYPE_NORMAL
- en: The root cause of the failure is that the Stack operates on the basis of **Last
    In First Out** (**LIFO**) whereas our code assumes FIFO. Did you notice that our
    code assumes that it will pop out the first number first while the reality is
    that it is supposed to pop out the second number first? Interesting, this bug
    was there in the addition operation too; however, since addition is associative,
    the bug was kind of suppressed but the subtraction test case detected it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd7edd0-6555-4706-8943-673796f00748.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.31
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix the bug as shown in the preceding screenshot and check whether the
    test cases will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5f684c5-bd45-4f42-b96a-083351d8f5ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.32
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! We fixed the bug and our test case seems to certify they are fixed.
    Let''s add more test cases. This time, let''s add a test case to verify multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We know this time the test case is going to fail, so let''s fast forward and
    take a look at the division test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s skip the test result and move forward with a final complex expression
    test case that involves many operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding test case as a google test in the test folder,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether our RPNCalculator application is able to evaluate a complex
    RPN expression that involves addition, subtraction, multiplication, and division
    in a single expression with the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test case, we are checking whether the expected result matches
    the actual result to the approximation of up to four decimal places. If the values
    are different beyond this approximation, then the test case is supposed to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the test case output now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35093b62-507c-4bf7-a875-a9d88c32fb1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.33
  prefs: []
  type: TYPE_NORMAL
- en: Great! All the test cases are green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at our production code and check whether there is any
    room for improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15296ad3-a773-4988-a0e3-dee2bc67b4cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.34
  prefs: []
  type: TYPE_NORMAL
- en: The code is functionally good but has many code smells. It is a long method
    with the nested `if-else` condition and duplicate code. TDD is not just about
    test automation; it is also about writing good code without code smells. Hence,
    we must refactor code and make it more modular and reduce the code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply polymorphism or the strategy design pattern here instead of the
    nested `if-else` conditions. Also, we can use the factory method design pattern
    to create various subtypes. There is also scope to use the Null Object Design
    Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is we don't have to worry about the risk of breaking our code
    in the process of refactoring as we have a sufficient number of test cases to
    give us feedback in case we break our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s understand how we could refactor the RPNCalculator design shown
    in *Figure 7.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/637663f8-f8fd-4341-9d18-370b9aa67b57.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.35
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding design refactoring approach, we can refactor RPNCalculator
    as shown in *Figure 7.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a294fac9-1525-4ee7-8d24-5d4783067e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.36
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the `RPNCalculator` code before and after refactoring, you'll
    find that code complexity has reduced to a decent amount after refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MathFactory` class can be implemented as shown in *Figure 7.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e3ef9c1-c5bf-4cab-b5da-08654b08f7b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.37
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible, we must strive to avoid `if-else` conditions, or in general,
    we must try to avoid code branching when possible. Hence, STL map is used to avoid
    if-else conditions. This also promotes the reuse of the same Math objects, irrespective
    of the complexity of the RPN expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get an idea of how the `MathOperator Add` class is implemented if
    you refer to *Figure 7.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1833a0f-7900-4459-b0da-3de4d0e80a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.38
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Add` class definition looks as shown in *Figure 7.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ece59b7-4372-4c3e-b0be-cdd4c1653775.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.39
  prefs: []
  type: TYPE_NORMAL
- en: The subtract, multiplication, and division classes can be implemented in the
    similar fashion, as an `Add` class. The bottom line is that after refactoring,
    we can refactor a single `RPNCalculator` class into smaller and maintainable classes
    that can be tested individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the refactored `Makefile` class in *Figure 7.40* and
    test our code after the refactoring process is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c0b43af-ea8c-4227-aa23-028c1974a486.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.40
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, we should see all the test cases pass after refactoring if
    no functionalities are broken, as shown in *Figure 7.41*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e22788c8-417b-48aa-9d8a-6bc44f7c0682.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.41
  prefs: []
  type: TYPE_NORMAL
- en: Cool! All the test cases have passed, hence it is guaranteed that we haven't
    broken the functionality in the process of refactoring. The main intent of TDD
    is to write testable code that is both functionally and structurally clean.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a piece of legacy code that has dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, the CUT was independent with no dependency, hence
    the way it tested the code was straightforward. However, let''s discuss how we
    can unit test the CUT that has dependencies. For this, refer to the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da8d052b-b313-4595-bb57-c348f0ea2b2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.42
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7.42*, it is apparent that **Mobile** has a dependency on **Camera**
    and the association between **Mobile** and **Camera** is *composition*. Let''s
    see how the `Camera.h` header file is implemented in a legacy application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/389f8f60-fd8d-4d57-bc86-4ec5f5d8bb10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.43
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, let''s take this simple `Camera` class that has
    `ON()` and `OFF()` functionalities. Let''s assume that the ON/OFF functionality
    will interact with the camera hardware internally. Check out the `Camera.cpp`
    source file in *Figure 7.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7dfb6d6-4c79-4c8f-ad10-84eca6e307c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.44
  prefs: []
  type: TYPE_NORMAL
- en: 'For debugging purposes, I have added some print statements that will come in
    handy when we test the `powerOn()` and `powerOff()` functionalities of mobile.
    Now let''s check the `Mobile` class header file in *Figure 7.45*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/015a0d92-6d60-4517-bc9e-e894070568e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.45
  prefs: []
  type: TYPE_NORMAL
- en: 'We move on to the mobile implementation, as illustrated in *Figure 7.46*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f737e0c-f513-4c71-b6ed-8863bf39e57d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.46
  prefs: []
  type: TYPE_NORMAL
- en: From the `Mobile` constructor implementation, it is evident that mobile has
    a camera or to be precise composition relationship. In other words, the `Mobile`
    class is the one that constructs the `Camera` object, as shown in *Figure 7.46*,*line
    21*, in the constructor. Let's try to see the complexity involved in testing the
    `powerOn()` functionality of Mobile; the dependency has a composition relationship
    with the CUT of Mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `powerOn()` test case assuming camera On has succeeded, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try to run the `Mobile` test case and check the test outcome, as
    illustrated in *Figure 7.47*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60469fae-b843-4209-80bc-bfe82d8a56f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.47
  prefs: []
  type: TYPE_NORMAL
- en: From *Figure 7.47*, we can understand that the `powerOn()` test case of `Mobile` has
    passed. However, we also understand that the real `ON()` method of the `Camera`
    class also got invoked. This, in turn, will interact with the camera hardware.
    At the end of the day, it is not a unit test as the test outcome isn't completely
    dependent on the CUT. If the test case had failed, we wouldn't have been able
    to pinpoint whether the failure was due to the code in the `powerOn()` logic of
    mobile or the code in the `ON()` logic of camera, which would have defeated the
    purpose of our test case. An ideal unit test should isolate the CUT from its dependencies
    using dependency injection and test the code. This approach will help us identify
    the behavior of the CUT in normal or abnormal scenarios. Ideally, when a unit
    test case fails, we should be able to guess the root cause of the failure without
    debugging the code; this is only possible when we manage to isolate the dependencies
    of our CUT.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of this approach is that the CUT can be tested even before the
    dependency is implemented, which helps test 60~70 percent of the code without
    the dependencies. This naturally reduces the time to market the software product.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the Google mock or gmock comes in handy. Let''s check how we
    can refactor our code to enable dependency injection. Though it sounds very complex,
    the effort required to refactor code isn''t that complex. In reality, the effort
    required to refactor your production code could be more complex, but it is worth
    the effort. Let''s take a look at the refactored `Mobile` class shown in *Figure
    7.48*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21ef199b-01fe-4269-a5d5-7cfdfddeac7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.48
  prefs: []
  type: TYPE_NORMAL
- en: In the `Mobile` class, I have added an overloaded constructor that takes camera
    as an argument. This technique is called **constructor dependency injection**.
    Let's see how this simple yet powerful technique could help us isolate the camera
    dependency while testing the `powerOn()` functionality of Mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we must refactor the `Camera.h` header file and declare the `ON()` and
    `OFF()` methods as virtual in order for the gmock framework to help us stub these
    methods, as shown in *Figure 7.49*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a26e55-9c5b-4460-8b24-719aa14ddc46.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.49
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s refactor our test case as shown in *Figure 7.50*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5a68754-6e5b-438f-b371-d436b14839ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.50
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all set to build and execute the test cases. The test outcome is expected
    as shown in *Figure 7.51*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891b46ea-a0ee-4c8d-aa74-61e529188708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.51
  prefs: []
  type: TYPE_NORMAL
- en: Cool! Not only has our test case passed, but we have also isolated our CUT from
    its camera dependency, which is evident as we don't see the print statements from
    the `ON()` method of camera. The bottom line is you have now learned how to unit
    test code by isolating its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Happy TDD!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned quite a lot about TDD, and the following is the
    summary of the key takeaway points:'
  prefs: []
  type: TYPE_NORMAL
- en: TDD is an Extreme Programming (XP) practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD is a bottom-up approach that encourages us to start with a test case, hence
    it is commonly referred to as LowercaseTest-First Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to write test cases using Google Test and Google Mock Frameworks
    in Linux and Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also learned how to write an application that follows TDD in Linux and Visual
    Studio on the Windows platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned about the Dependency Inversion technique and how to unit test a
    code by isolating its dependency using the Google Mock Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google Test Framework supports Unit Testing, Integration Testing, Regression
    Testing, Performance Testing, Functional Testing, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD mainly insists on Unit Testing, Integration Testing, and Interaction Testing
    while complex functional testing must be done with Behavior-Driven Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to refactor code smells into clean code while the unit test
    cases that you wrote give continuous feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have learned TDD and how to automate Unit Test Cases, Integration Test Cases,
    and Interaction Test cases in a bottom-up approach. With BDD, you will learn the
    top-down development approach, writing end-to-end functionalities and test cases
    and other complex test scenarios that we did not cover while discussing TDD.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about Behavior-Driven Development.
  prefs: []
  type: TYPE_NORMAL
