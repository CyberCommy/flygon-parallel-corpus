- en: Improving Cohesion Using Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've previously discussed how we can use functions and operations on functions
    to organize our code. We can't ignore, however, the prevalent paradigm for software
    design of the past few decades—**object-oriented programming** (**OOP**). Can
    OOP work with functional programming? Is there any compatibility between the two,
    or are they completely disjointed?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that we can easily convert between classes and functions. I learned
    through my friend and mentor, J.B. Rainsberger, that classes are nothing more
    than a set of partially applied, cohesive pure functions. In other words, we can
    use classes as a convenient location to group cohesive functions together. But,
    in order to do so, we need to understand the high cohesion principle and how to
    transform functions into classes and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the connection between functional programming and OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how classes are equivalent with sets of cohesive, partially-applied
    pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the need for high cohesion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to group pure functions into classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to split a class into pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter08` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it in its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Improving cohesion using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a young software engineering student, I spent an inordinate amount of time
    reading about OOP. I was trying to understand how OOP works and why it's so important
    for modern software development. At that time, most books were mentioning that
    OOP is about organizing code into classes that have three important properties—encapsulation,
    inheritance, and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Almost 20 years later, I realized that this vision of OOP was quite limited.
    OOP was largely developed at Xerox PARC, the laboratory known for generating an
    amazing number of high-quality ideas, such as graphical user interfaces, point
    and click, the mouse, and the spreadsheet, to mention just a few. Alan Kay, one
    of the OOP originators, drew from his knowledge as a biology major while facing
    the problem of organizing large code bases in ways that supported the new GUI
    paradigm. He came up with the idea of objects and classes, but he stated years
    later that the main idea of this style of code organization is messaging. His
    view on objects was that they should communicate in a similar way to cells, with
    a simulation of their chemical messages in code. That's why a method call in an
    OOP language, from his view, should instead be a message that's passed from a
    cell or object to another cell or object.
  prefs: []
  type: TYPE_NORMAL
- en: Once we forget about ideas of encapsulation, inheritance, and polymorphism,
    and place more importance on objects instead of classes, the friction between
    the functional paradigm and OOP disappears. Let's see where this fundamental view
    of OOP takes us.
  prefs: []
  type: TYPE_NORMAL
- en: Classes from a functional perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to look at classes. In terms of knowledge management,
    I conceptualize a *class* as a classification—it's a way of grouping instances
    (or objects) that have similar properties. If we think about classes in this way,
    then inheritance comes as a natural property—there are classes of objects that
    have similar properties, but they also differ in various ways; saying that they
    inherit from one another is a quick way to explain them.
  prefs: []
  type: TYPE_NORMAL
- en: However, this conception of classes works in domains where our knowledge is
    quasi-complete. In the software development sphere, we often work with limited
    knowledge of the application domain, and the domain keeps expanding over time.
    Therefore, we need to focus on code structures that have weak links between concepts,
    allowing us to change or replace them as we learn more about the domain. What
    should we do about classes then?
  prefs: []
  type: TYPE_NORMAL
- en: Even without their strong relationships, classes are a powerful construct in
    software design. They provide a neat way of grouping methods, and of combining
    methods with data. They can help us navigate larger domains better than functions,
    since we can end up with thousands of functions (if not more). So, how can we
    use classes with functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: First, as you may have noticed from our previous examples, functional programming
    places complexity inside data structures. Classes are often a neat way of defining
    the data structures that we need, especially in a language such as C++, which
    allows us to override common operators. Common examples include imaginary numbers,
    measurable units (temperature, length, velocity, and so on), and currency data
    structures. Each of them requires data to be grouped with specific operators and
    conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the immutable functions we write tend to naturally group themselves
    into logical classifications. In our Tic-Tac-Toe example, we have a number of
    functions that work with a data structure that we call a **line**; our natural
    tendency is to group these functions together. While nothing stops us from grouping
    them in a header file, classes provide a natural place to combine functions so
    that we can find them later. This leads to another type of class—an immutable
    object that is initialized once, and whose every operation returns a value instead
    of mutating its state.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look in more detail at the equivalence between an OOP design and a functional
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalence OOP – functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we go back to our Tic-Tac-Toe result solution, you''ll notice that there
    are a number of functions that receive `board` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a board as follows, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we pass it into the functions, it''s like we''re binding the board
    to the parameter of the functions. Now, let''s do that for our `allLinesColumnsAndDiagonals`
    lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lambda and many other examples we have looked at in earlier chapters
    call other lambdas, yet they don't capture them. For example, how does the `bindAllToBoard`
    lambda know about the `allLinesColumnsAndDiagonal` lambda? The only reason this
    works is because the lambdas are in a global scope. Moreover, with my compiler,
    when trying to capture `allLinesColumnsAndDiagonals`, I get the following error
    message: `<lambda>` *cannot be captured because it does not have automatic storage
    duration*, so it actually will not compile if I try to capture the lambda I use.
  prefs: []
  type: TYPE_NORMAL
- en: I hope what I am about to say is self-explanatory, but I will say it anyway—for
    production code, avoid having lambdas (and anything else, really) in the global
    scope. This will also force you to capture the variables, which is a good thing
    because it makes dependencies explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this remind you of something? Let''s look at how we would write this in
    a class. I will name it `BoardResult` for now, since I can''t come up with a better
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recap what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: We saw more functions taking `board` as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We decided to bind the `board` parameter to a value using a separate function,
    thereby obtaining a map between a string denoting the function name and the lambda
    bound to the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To call it, we needed to first call the initializing function and then we could
    call the partially-applied lambda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*This looks extremely similar to a class*—use the constructor to pass in the
    value that''s shared between the class methods, and then call the methods without
    passing in the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, *a class is just a set of partially applied lambdas*. But how do
    we group them?
  prefs: []
  type: TYPE_NORMAL
- en: The principle of high cohesion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous example, we grouped the functions together in a class based
    on the fact that they took the same parameter, `board`. I have found this to be
    a good rule of thumb. However, we can encounter more complex situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why, let''s look into another set of functions (the implementation
    has been ignored for the purpose of this discussion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Should these functions be part of the `BoardResult` class defined previously?
    Or should they be part of another class, `Coordinate`? Or should we split them,
    with some of them going to the `BoardResult` class, and others going to the `Coordinate`
    class?
  prefs: []
  type: TYPE_NORMAL
- en: Our previous method doesn't work for all the functions. If we look solely at
    their parameters, all of the preceding functions take `board`. However, some of
    them also take `coordinate / coordinates` as a parameter. Should `projectCoordinates`
    be part of the `BoardResult` class, or part of the `Coordinate` class?
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, what's the base principle we can follow to group these functions
    into classes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there''s no clear answer regarding the static structure of the code,
    we need to think about the code evolution instead. The questions we need to ask
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the functions do we expect to change together? Which of the functions
    do we expect to change separately?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line of reasoning leads us to the high cohesion principle. But, let's unpack
    it first. What do we mean by cohesion?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an engineer and a science geek, I met cohesion in the physical world. When
    we talk about water, for example, the molecules composing the liquid tend to stick
    together. I also met cohesion as a social force. As a change agent working with
    customers who try to adopt modern software development practices, I've often had
    to deal with group cohesion—the tendency of people to cluster together around
    a point of view.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about cohesion for functions, there is no physical force that pushes
    them together, and they definitely don't stick to points of view. So, what are
    we talking about? We're talking about a neurological force, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: The human brain has a huge capacity for finding patterns and grouping related
    items in categories, combined with an uncannily fast way of navigating them. The
    force that binds functions together is in our brains—it's the finding of a unifying
    purpose that emerges from the combination of seemingly unrelated functions.
  prefs: []
  type: TYPE_NORMAL
- en: High cohesion is useful because it allows us to understand and navigate a few
    big concepts (such as board, line, and token) rather than tens or hundreds of
    small functions. Moreover, when (not if) we need to add a new behavior or change
    an existing one, high cohesion will allow us to find the place for a new behavior
    fast, and to add it with minimal changes to the remainder of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Cohesion is a metric of software design, introduced by Larry Constantine in
    the 1960s as part of his *Structured Design* approach. Through experience, we
    have noticed that high cohesion correlates with a low cost of change.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to apply this principle in order to group our functions in to
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping cohesive functions into classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously discussed, we can look at cohesion in terms of a unifying purpose
    or concept of the class. However, I usually find it more thorough to look at the
    evolution of code and decide on the function groups based on what might change
    in the future, and what other changes it might trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not expect to learn many things from our Tic-Tac-Toe result problem.
    It is fairly simple, and seems quite contained. However, a quick search on the
    web leads us to a number of Tic-Tac-Toe variations, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *m x n* board, with the winner decided by *k* items in a row. An interesting
    variant is Gomoku, played on a *15 x 15* board, where the winner has to get 5
    in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3D version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using numbers as tokens, and the sum of the numbers as the win condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using words as tokens, and the winner has to place 3 words in a row with 1 common
    letter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using 9 boards of *3 x 3* to play, where the winner must win 3 boards in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are not even the most weird variants, and, if you're interested, you can
    check the Wikipedia article on the topic at [https://en.wikipedia.org/wiki/Tic-tac-toe_variants](https://en.wikipedia.org/wiki/Tic-tac-toe_variants).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what could change in our implementation? Here are a few suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Board size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Winning rules (still in a row, but with different conditions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Board topology—rectangular, hexagonal, triangular, or 3D instead of square
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, if we just change the board size, nothing should really change
    in our code. In fact, we can pass in a larger board and everything will still
    work. Very small changes are required for changing the number of players; we will
    assume they have different tokens and we just need to bind the `tokenWins` function
    to different token values.
  prefs: []
  type: TYPE_NORMAL
- en: How about the winning rules? We will assume that the rules still take into account
    the lines, columns, and diagonals, since this is a basic requirement for Tic-Tac-Toe
    and all the variants use them. However, we might not take into account a full
    line, column, or diagonal; in Gomoku, for example, we need to look for 5 tokens
    in a row on a line, column, or diagonal that has the size 15\. Looking at our
    code, this is merely a matter of selecting other groups of coordinates; instead
    of searching for a full line to be filled with token `X`, we need to select all
    possible sets of five-in-a-row coordinates. This means a change in our functions
    related to coordinates—`lineCoordinates`, `mainDiagonalCoordinates`, `columnCoordinates`,
    and `secondaryDiagonalCoordinates`. They will return a vector of five-in-a-row
    coordinates, which will result in changes in `allLines`, `allColumns`, and `allDiagonals`,
    and in the way we concatenate them.
  prefs: []
  type: TYPE_NORMAL
- en: What if the token is a word and the winning condition is about finding a common
    letter between the words? Well, the coordinates are the same, and the way we get
    the lines, columns, and diagonals stays the same. The only change is in the `fill`
    condition, so this is relatively easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the final possible change—the board topology. Changing the
    board topology will require changing the board data structure, and all the coordinates
    and the corresponding functions. But will it require changes in the lines, columns,
    and diagonals rules? If we switch to 3D, then we have more lines, more columns,
    and a different way of addressing diagonals—all changes in coordinates. A rectangular
    board doesn't have a diagonal *per se*; we'll need to use partial diagonals such
    as in the Gomoku case. As for hexagonal or triangular boards, there is no clear
    variant, so we can ignore them for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows us that if we want to prepare for change, our functions should be
    grouped around the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: Rules (also known as the **fill condition**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinates and projections—and prepare the code for multiple sets of lines,
    columns, and diagonals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic board structure allowing access based on coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That settles it—we need to separate the coordinates from the board itself. While
    the coordinate data type will change at the same time as the board data type,
    the functions providing the line, column, and diagonal coordinates might change
    due to the game rules. Thus, we need to separate the board from its topology.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of **object-oriented design** (**OOD**), we need to separate the responsibilities
    of the program between at least three cohesive classes—`Rules`, `Topology`, and
    `Board`. The `Rules` class contains the rules of the game—basically, how we compute
    the winning conditions, when we know it's a draw, or that the game has ended.
    The `Topology` class is about coordinates and the structure of the board. The
    `Board` class should be the structure we pass in to the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how should our functions be structured? Let''s make a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rules**: `xWins`, `oWins`, `tokenWins`, `draw`, and `inProgress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topology**: `lineCoordinates`, `columnCoordinates`, `mainDiagonalCoordinates`,
    and `secondaryDiagonalCoordinates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Board**: `accessAtCoordinates` and `allLinesColumnsAndDiagonals`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undecided**: `allLines`, `allColumns`, `allDiagonals`, `mainDiagonal`, and `secondaryDiagonal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's always a list of functions that could be part of more structures. In
    our case, should `allLines` be part of the `Topology` class or the `Board` class?
    I can find equally good arguments for both. Therefore, the solution is left to
    the intuition of the programmer who writes the code.
  prefs: []
  type: TYPE_NORMAL
- en: This shows, however, the method you can use to group these functions into classes—think
    about what might change, and group them based on which functions will change together.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a caveat for practicing this method—avoid the trap of over-analysis.
    Code is relatively easy to change; when you have little information about what
    might change, make it work and wait until a new requirement comes up in the same
    area of the code. Then, you'll have a better idea of the relationships between
    functions. This analysis shouldn't take you longer than 15 minutes; anything extra
    is most likely over-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a class into pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to group functions into a class. But how do we transform
    the code from a class to pure functions? It transpires that this is fairly straightforward—we
    just need to make the functions pure, move them out of the class, and then add
    an initializer that binds them to the data they need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another example, a class that performs mathematical operations
    with two integer operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it more interesting, let''s add another function that reverts the first
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we split this class into functions? Fortunately, the functions are
    already pure. It''s obvious that we can extract the functions as lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really need to, let''s add the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a check can be carried out to determine that everything works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This leaves us with only one open question—how can we turn impure functions
    into pure functions? We will discuss this question at length in [Chapter 12](3b3ccc61-d5b6-4e3c-b142-cf32355f6229.xhtml),
    *Refactoring to and through Pure Functions*. For now, let's remember the important
    conclusion of this chapter—*a class is nothing more than a set of cohesive, partially
    applied functions.*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had such an interesting journey in this chapter! We managed to link two styles
    of design that seem disjointed—OOP and functional programming, in a very elegant
    manner. Pure functions can be grouped into classes based on the principle of cohesion.
    We just need to exercise our imagination and think of scenarios in which functions
    might change, and decide which functions to group together. Reversely, we can
    always move functions from a class into multiple lambdas by making them pure and
    reversing the partial application.
  prefs: []
  type: TYPE_NORMAL
- en: There is no friction between OOP and functional programming; they are just two
    different ways of structuring the code that implements features.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey into software design using functions has not finished yet. In the
    next chapter, we will discuss how to design functions using **test-driven development**
    (**TDD**).
  prefs: []
  type: TYPE_NORMAL
