- en: Chapter 8. Working with Date/Time and International Aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using emoticons or emoji in a view script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting complex characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the locale from browser data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting numbers by locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling currency by locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting date/time by locale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML international calendar generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a recurring events generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling translation without gettext
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this chapter with two recipes that take advantage of a new **Unicode**
    escape syntax introduced with **PHP 7**. After that, we will cover how to determine
    a web visitor's **locale** from browser data. The next few recipes will cover
    the creation of a locale class, which will allow you to represent numbers, currency,
    dates, and time in a format specific to a locale. Finally, we will cover recipes
    that demonstrate how to generate an internationalized calendar, handle recurring
    events, and perform translation without having to use `gettext`.
  prefs: []
  type: TYPE_NORMAL
- en: Using emoticons or emoji in a view script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word **emoticons** is a composite of *emotion* and *icon*. **Emoji**, originating
    from Japan, is another, larger, widely used set of icons. These icons are the
    little smiley faces, tiny ninjas, and rolling-on-the-floor-laughing icons that
    are so popular on any website that has a social networking aspect. Prior to PHP
    7, however, producing these little beasties was an exercise in frustration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First and foremost, you need to know the Unicode for the icon you wish to present.
    A quick search on the Internet will direct you to any one of several excellent
    charts. Here are the codes for the three *hear-no-evil*, *see-no-evil*, and *speak-no-evil*
    monkey icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`U+1F648`, `U+1F649`, and `U+1F64A`'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/B05314_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Any Unicode output to the browser must be properly identified. This is most
    often done by way of a `meta` tag. You should set the character set to UTF-8\.
    Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The traditional approach was to simply use HTML to display the icons. Thus,
    you could do something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As of PHP 7, you can now construct full Unicode characters using this syntax:
    `"\u{xxx}"`. Here is an example with the same three icons as in the preceding
    bullet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your operating system and browser must both support Unicode and must also have
    the right set of fonts. In Ubuntu Linux, for example, you would need to install
    the `ttf-ancient-fonts` package to see emoji in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP 7, a new syntax was introduced that lets you render any Unicode character.
    Unlike other languages, the new PHP syntax allows for a variable number of hex
    digits. The basic format is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The entire construct must be double quoted (or use **heredoc**). `xxxx` could
    be any combination of hex digits, 2, 4, 6, and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `chap_08_emoji_using_html.php`. Be sure to include the
    `meta` tag that signals the browser that UTF-8 character encoding is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set up a basic HTML table, and display a row of emoticons/emoji:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a row using PHP to emit emoticons/emoji:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output seen from Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a list of emoji codes, see [http://unicode.org/emoji/charts/full-emoji-list.html](http://unicode.org/emoji/charts/full-emoji-list.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting complex characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to access the entire Unicode character set opens up many new possibilities
    for rendering complex characters, especially characters in alphabets other than
    Latin-1.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some languages are read right-to-left instead of left-to-right. Examples include
    Hebrew and Arabic. In this example, we show you how to present *reverse* text
    using the `U+202E` Unicode character for right-to-left override. The following
    line of code prints `txet desreveR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to invoke the left-to-right override character, `U+202D`, when
    finished!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another consideration is the use of composed characters. One such example is
    `ñ` (the letter `n` with a tilde `~` floating above). This is used in words such
    as *mañana* (the Spanish word for morning or tomorrow, depending on the context).
    There is a *composed character* available, represented by Unicode code `U+00F1`.
    Here is an example of its use, which echoes `mañana`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This could potentially impact search possibilities, however. Imagine that your
    customers do not have a keyboard with this composed character. If they start to
    type `man` in an attempt to search for `mañana`, they will be unsuccessful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having access to the *full* Unicode set offers other possibilities. Instead
    of using the *composed* character, you can use a combination of the original letter
    `n` along with the Unicode *combining* code, which places a floating tilde on
    top of the letter. In this `echo` command, the output is the same as previously.
    Only the way the word is formed differs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar application could be made for accents. Consider the French word `élève`
    (student). You could render it using composed characters, or by using combining
    codes to float the accents above the letter. Consider the two following examples.
    Both examples produce the same output, but are rendered differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called `chap_08_control_and_combining_unicode.php`. Be sure to
    include the `meta` tag that signals the browser that UTF-8 character encoding
    is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set up basic PHP and HTML to display the examples discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting the locale from browser data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to improve the user experience on a website, it's important to display
    information in a format that is acceptable in the user's locale. **Locale** is
    a generic term used to indicate an area of the world. An effort in the I.T. community
    has been made to codify locales using a two-part designation consisting of codes
    for both language and country. But when a person visits your website, how do you
    know their locale? Probably the most useful technique involves examining the HTTP
    language header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to encapsulate locale functionality, we will assume a class, `Application\I18n\Locale`.
    We will have this class extend an existing class, `Locale`, which is part of the
    PHP `Intl` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**I18n** is a common abbreviation for **Internationalization**. (Count the
    number of letters!)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an idea of what an incoming request looks like, use `phpinfo(INFO_VARIABLES)`.
    Be sure to disable this function immediately after testing as it gives away too
    much information to potential attackers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Locale information is stored in `$_SERVER[''HTTP_ACCEPT_LANGUAGE'']`. The value
    will take this general form: `ll-CC,rl;q=0.n, ll-CC,rl;q=0.n`, as defined in this
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Abbreviation | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ll` | Two-character lowercase code representing the language. |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Separates language from country in the locale code `ll-CC`. |'
  prefs: []
  type: TYPE_TB
- en: '| `CC` | Two-character uppercase code representing the country. |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Separates locale code from fallback **root locale** code (usually the
    same as the language code). |'
  prefs: []
  type: TYPE_TB
- en: '| `rl` | Two-character lowercase code representing the suggested root locale.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `;` | Separates locale information from quality. If quality is missing, default
    is `q=1` (100%) probability; this is preferred. |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | Quality. |'
  prefs: []
  type: TYPE_TB
- en: '| `0.n` | Some value between 0.00 and 1.0\. Multiply this value by 100 to get
    the percentage of probability that this is the actual language preferred by this
    visitor. |'
  prefs: []
  type: TYPE_TB
- en: 'There can easily be more than one locale listed. For example, the website visitor
    could have multiple languages installed on their computer. It so happens that
    the PHP `Locale` class has a method, `acceptFromHttp()`, which reads the `Accept-language`
    header string and gives us the desired setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define the appropriate getters. The `get AcceptLanguage()` method
    returns the value from `$_SERVER[''HTTP_ACCEPT_LANGUAGE'']`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a constructor that allows us to "manually" set the locale. Otherwise,
    the locale information is drawn from the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the big decision: what to do with this information! This is covered
    in the next few recipes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though a visitor appears to accept one or more languages, that visitor
    does not necessarily want contents in the language/locale indicated by their browser.
    Accordingly, although you can certainly set the locale given this information,
    you should also provide them with a static list of alternative languages.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this illustration, let''s take three examples:'
  prefs: []
  type: TYPE_NORMAL
- en: information derived from the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a preset locale `fr-FR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a string taken from RFC 2616: `da, en-gb;q=0.8, en;q=0.7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place the code from steps 1 to 6 into a file, `Locale.php`, which is in the
    `Application\I18n` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file, `chap_08_getting_locale_from_browser.php`, which sets
    up autoloading and uses the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can define an array with the three test locale strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, loop through the three locale strings, creating instances of the new
    class. Echo the value returned from `getLocaleCode()` to see what choice was made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result (with a little bit of styling):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For information on the PHP `Locale` class, see [http://php.net/manual/en/class.locale.php](http://php.net/manual/en/class.locale.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on the `Accept-Language` header, see section 14.4 of RFC
    2616: [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting numbers by locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numeric representations can vary by locale. As a simple example, in the UK
    one would see the number three million, eighty thousand, five hundred and twelve,
    and ninety-two one hundredths as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In France, however, the same number might appear like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can represent a number in a locale-specific manner, you need to determine
    the locale. This can be accomplished using the `Application\I18n\Locale` class
    discussed in the previous recipe. The locale can be set manually or from header
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will make use of the `format()` method of the `NumberFormatter` class,
    to both output and parse numbers in a locale-specific format. First we add a property
    that will contain an instance of the `NumberFormatter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our initial thought would be to consider using the PHP function `setlocale()`
    to produce numbers formatted according to locale. The problem with this legacy
    approach, however, is that *everything* will be considered based on this locale.
    This could introduce problems dealing with data that is stored according to database
    specifications. Another issue with `setlocale()` is that it is based on outdated
    standards, including RFC 1766 and ISO 639\. Finally, `setlocale()` is highly dependent
    on operating system locale support, which will make our code non-portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the next step would be to set `$numberFormatter` in the constructor.
    The problem with this approach, in the case of our `Application\I18n\Locale` class,
    is that we would end up with a top-heavy class, as we will also need to perform
    currency and date formatting as well. Accordingly, we add a `getter` that first
    checks to see whether an instance of `NumberFormatter` has already been created.
    If not, an instance is created and returned. The first argument in the new `NumberFormatter`
    is the locale code. The second argument, `NumberFormatter::DECIMAL`, represents
    what type of formatting we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a method that, given any number, will produce a string that represents
    that number formatted according to the locale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add a method that can be used to parse numbers according to the locale,
    producing a native PHP numeric value. Please note that the result might not return
    `FALSE` on parse failure depending on the server''s ICU version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make the additions to the `Application\I18n\Locale` class as discussed in the
    preceding bullet points. You can then create a `chap_08_formatting_numbers.php`
    file, which sets up autoloading and uses this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For this illustration, create two `Locale` instances, one for the UK, the other
    for France. You can also designate a large number to be used for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can wrap the `formatNumber()` and `parseNumber()` methods in the
    appropriate HTML display logic and view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result as seen from a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if the locale is set to `fr_FR`, a UK formatted number, when parsed,
    does not return the correct value. Likewise, when the locale is set to `en_GB`,
    a French formatted number does not return the correct value upon parsing. Accordingly,
    you might want to consider adding a validation check before attempting to parse
    the number.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on the use and abuse of `setlocale()` please refer to
    this page: [http://php.net/manual/en/function.setlocale.php](http://php.net/manual/en/function.setlocale.php).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a brief note on why number formatting will produce an error on some servers,
    but not others, check the **ICU** (**International Components for Unicode**) version.
    See the comments on this page: [http://php.net/manual/en/numberformatter.parse.php](http://php.net/manual/en/numberformatter.parse.php).
    For more info on ICU formatting, see [http://userguide.icu-project.org/formatparse](http://userguide.icu-project.org/formatparse).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling currency by locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technique for handling currency is similar to that for numbers. We will
    even use the same `NumberFormatter` class! There is one major difference, however,
    and it is a *show stopper*: in order to properly format currency, you will need
    to have on hand the currency code.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first order of business is to have the currency codes available in some
    format. One possibility is to simply add the currency code as an `Application\I18n\Locale`
    class constructor argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach, although obviously solid and workable, tends to fall into the
    category called *halfway measures* or *the easy way out*! This approach would
    also tend to eliminate full automation as the currency code is not available from
    the HTTP header. As you have probably gathered from other recipes in this book,
    we do not shy away from a more complex solution so, as the saying goes, *strap
    on your seat belts*!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first need to establish some sort of lookup mechanism, where, given
    a country code, we can obtain its predominant currency code. For this illustration,
    we will use the Adapter software design pattern. According to this pattern, we
    should be able to create different classes, which could potentially operate in
    entirely different ways, but which produce the same result. Accordingly, we need
    to define the desired result. For this purpose, we introduce a class, `Application\I18n\IsoCodes`.
    As you can see, this class has all the pertinent properties, along with a sort-of
    universal constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define an interface that has the method we require to perform the *country-code-to-currency-code*
    lookup. In this case, we introduce `Application\I18n\IsoCodesInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to build a lookup adapter class, which we will call `Application\I18n\IsoCodesDb`.
    It implements the abovementioned interface, and accepts an `Application\Database\Connection`
    instance (see [Chapter 1](ch01.html "Chapter 1. Building a Foundation"), *Building
    a Foundation*), which is used to perform the lookup. The constructor sets up the
    required information, including the connection, the lookup table name, and the
    column that represents the ISO2 code. The lookup method required by the interface
    then issues an SQL statement and returns an array, which is then used to build
    an `IsoCodes` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we turn our attention back to the `Application\I18n\Locale` class. We first
    add a couple of new properties and class constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We add new method that retrieves the country code from the locale string. We
    can leverage the `getRegion()` method, which comes from the PHP `Locale` class
    (which we extend). Just in case it''s needed, we also add a method, `getCurrencyCode()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As with formatting numbers, we define a `getCurrencyFormatter(I)`, much as
    we did `getNumberFormatter()` (shown previously). Notice that `$currencyFormatter`
    is defined using `NumberFormatter`, but with a different second parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a currency code lookup to the class constructor if the lookup class
    has been defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the appropriate currency format and parse methods. Note that parsing
    currency, unlike parsing numbers, will return `FALSE` if the parsing operation
    is not successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following classes, as covered in the first several bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Bullet point discussed |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\I18n\IsoCodes` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\I18n\IsoCodesInterface` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Application\I18n\IsoCodesDb` | 5 |'
  prefs: []
  type: TYPE_TB
- en: 'We will assume, for the purposes of this illustration, that we have a populated
    MySQL database table, `iso_country_codes`, which has this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the additions to the `Application\I18n\Locale` class, as discussed in
    bullet points 6 to 9 previously. You can then create a `chap_08_formatting_currency.php`
    file, which sets up autoloading and uses the appropriate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create instances of the `Connection` and `IsoCodesDb` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For this illustration, create two `Locale` instances, one for the UK, the other
    for France. You can also designate a large number to be used for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can wrap the `formatCurrency()` and `parseCurrency()` methods
    in the appropriate HTML display logic and view the results. Base your view logic
    on that presented in the *How it works...* section of the previous recipe (not
    repeated here to save trees!). Here is the final output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most up-to-date list of currency codes is maintained by **ISO** (**International
    Standards Organization**). You can obtain this list in either **XML** or **XLS**
    (that is, **Microsoft Excel** spreadsheet format). Here is the page where these
    lists can be found: [http://www.currency-iso.org/en/home/tables/table-a1.html](http://www.currency-iso.org/en/home/tables/table-a1.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting date/time by locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The formatting of date and time varies region to region. As a classic example,
    consider the year 2016, month April, day 15 and a time in the evening. The format
    preferred by denizens of the United States would be 7:23 PM, 4/15/2016, whereas
    in China you would most likely see 2016-04-15 19:23\. As mentioned with number
    and currency formatting, it would also be important to display (and parse) dates
    in a format acceptable to your web visitors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to modify `Application\I18n\Locale`, adding statements
    to use date formatting classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a property to represent an `IntlDateFormatter` instance, as well
    as a series of predefined constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we are in a position to define a method, `getDateFormatter()`,
    which returns an `IntlDateFormatter` instance. The value of `$type` matches one
    of the `DATE_TYPE_*` constants defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a method that produces a locale formatted date. Defining the
    format of the incoming `$date` is a bit tricky. It cannot be locale-specific,
    otherwise we will need to parse it according to locale rules, with unpredictable
    results. A better strategy would be to accept an array of values that represent
    year, month, day, and so on as integers. As a fallback, we will accept a string
    but only in this format: `YYYY-mm-dd HH:ii:ss`. Time zone is optional, and can
    be set separately. First we initialize variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we produce a breakdown of values that represent year, month, day,
    and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we create an `IntlCalendar` instance, which will serve as an argument
    when running `format()`. We set the date using the discreet integer values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we obtain the date formatter instance, and produce the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseDate()` method is actually simpler than formatting. The only complication
    is what to do if the type is not specified (which will be the most likely case).
    All we need to do is to loop through all possible types (of which there are only
    four) until a result is produced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code the changes to `Application\I18n\Locale`, discussed previously. You can
    then create a test file, `chap_08_formatting_date.php`, which sets up autoloading,
    and creates two instances of the `Locale` class, one for the USA, the other for
    France:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, with suitable styling, run a test of `formatDate()` and `parseDate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ISO 8601 gives precise definitions for all aspects of date and time. There is
    also an RFC that discusses the impact of ISO 8601 on the Internet. For reference,
    see [https://tools.ietf.org/html/rfc3339](https://tools.ietf.org/html/rfc3339).
    For a good overview of date formats by country, see [https://en.wikipedia.org/wiki/Date_format_by_country](https://en.wikipedia.org/wiki/Date_format_by_country).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML international calendar generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a program to display a calendar is something you would most likely
    do as a student at secondary school. A nested `for()` loop, where the inside loop
    generates a list of seven days, will generally suffice. Even the problem of how
    many days there are in the month is easily solved in the form of a simple array.
    Where it starts to get tricky is when you need to figure out, for any given year,
    on what day of the week does the 1st of January fall. Also, what if you want to
    represent the months and days of the week in a language and format acceptable
    to a specific locale? As you have probably guessed, we will build a solution using
    the previously discussed `Application\I18n\Locale` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to create a generic class that will hold information for a single
    day. Initially it will only hold an integer value, `$dayOfMonth`. Later, in the
    next recipe, we''ll expand it to include events. As the primary purpose of this
    class will be to yield `$dayOfMonth`, we''ll incorporate this value into its constructor,
    and define `__invoke()` to return this value as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class that will hold the appropriate calendar-generation methods.
    It will accept an instance of `Application\I18n\Locale`, and will define a couple
    of class constants and properties. The format codes, such as `EEEEE` and `MMMM`,
    are drawn from ICU date formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define a method that returns an `IntlDateFormatter` instance from our
    `locale` class. This is stored in a class property, as it will be used frequently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a core method, `buildMonthArray()`, which creates a multi-dimensional
    array where the outer key is the week of the year, and the inner array is seven
    elements representing the days of the week. We accept the year, month, and optional
    time zone as arguments. Note, as part of variable initialization, we subtract
    1 from the month. This is because the `IntlCalendar::set()` method expects a 0-based
    value for the month, where 0 represents January, 1 is February, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create an `IntlCalendar` instance, and use it to determine how many
    days are in this month:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After that we use our `IntlDateFormatter` instance to determine what day of
    the week equates to the 1st of this month. After that, we set the pattern to `w`,
    which will subsequently give us the week number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to loop through all days in the month with nested loops. An
    outer `while()` loop ensures we don''t go past the end of the month. The inner
    loop represents the days of the week. You will note that we take advantage of
    `IntlCalendar::get()`, which allows us to retrieve values from a wide range of
    predefined fields. We also adjust the week of the year value to 0 if it exceeds
    52:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We then check to see whether `$first` is still set `TRUE`. If so, we start adding
    day numbers to the array. Otherwise, the array value is set to `NULL`. We then
    close all open statements and return the array. Note that we also need to make
    sure the inner loop doesn't go past the number of days in the month, hence the
    extra `if()` statement in the outer `else` clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that instead of just storing the value for the day of the month, we use
    the newly defined `Application\I18n\Day` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Refining internationalized output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, a series of small methods, starting with one that extracts the internationally
    formatted day based on type. The type determines whether we deliver the full name
    of the day, an abbreviation, or just a single letter, all appropriate for that
    locale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a method that returns an HTML row of day names, calling the newly
    defined `getDay()` method. As mentioned previous, the type dictates the appearance
    of the days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we define a very simple method to return a row of week dates. Note
    that we take advantage of `Day::__invoke()` using: `$day()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, a method that puts the smaller methods together to generate a
    calendar for a single month. First we build the month array, but only if `$yearArray`
    is not already available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The month needs to be decremented by `1` as `IntlCalendar` months are 0-based:
    Jan = 0, Feb = 1, and so on. We then build an `IntlCalendar` instance using the
    time zone (if any), and the locale. We next create a `IntlDateFormatter` instance
    to retrieve the month name and other information according to locale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We then loop through the month array, and call the smaller methods just mentioned
    to build the final output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to generate a calendar for the entire year, it''s a simple matter
    of looping through months 1 to 12\. To facilitate outside access, we first define
    a method that builds a year array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a calendar for a year, we define a method, `calendarForYear()`.
    If the year array has not been build, we call `buildYearArray()`. We take into
    account how many monthly calendars we wish to display across and then call `calendarForMonth()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, make sure you build the `Application\I18n\Locale` class as defined
    in the previous recipe. After that, create a new file, `Calendar.php`, in the
    `Application\I18n` folder, with all the methods described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define a calling program, `chap_08_html_calendar.php`, which sets up
    autoloading and creates `Locale` and `Calendar` instances. Also be sure to define
    the year and month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then develop appropriate view logic to display the different calendars.
    For example, you can include parameters to display the full month and day names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](graphics/B05314_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With a couple of modifications, you can also display a calendar for the entire
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the browser output showing a full year calendar in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on codes used by `IntlDateFormatter::setPattern()`, see
    this article: [http://userguide.icu-project.org/formatparse/datetime](http://userguide.icu-project.org/formatparse/datetime)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a recurring events generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common need related to generating a calendar is the scheduling of events.
    Events can be in the form of *one-off* events, which take place on one day, or
    on a weekend. There is a much greater need, however, to track events that are
    *recurring*. We need to account for the start date, the recurring interval (daily,
    weekly, monthly), and the number of occurrences or a specific end date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before anything else, it would be an excellent idea to create a class that
    represents an event. Ultimately you''ll probably end up storing the data in such
    a class in a database. For this illustration, however, we will simply define the
    class, and leave the database aspect to your imagination. You will notice that
    we will use a number of classes included in the `DateTime` extension admirably
    suited to event generation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a series of useful class constants and properties. You will
    notice that we defined most of the properties `public` in order to economize on
    the number of getters and setters needed. The intervals are defined as `sprintf()`
    format strings; `%d` will be substituted for a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Next we turn our attention to the constructor. We need to collect and set all
    information pertinent to an event. The variable names are self-explanatory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`$value` is not quite so clear. This parameter will ultimately be substituted
    for the value in the interval format string. So, for example, if the user selects
    `$interval` as `INTERVAL_DAY`, and `$value` as `2`, the resulting interval string
    will be `P2D`, which means every other day (or every 2nd day).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We then initialize variables. Note that the ID is pseudo-randomly generated,
    but might ultimately end up being the primary key in a database `events` table.
    Here we use `md5()` not for security purposes, but rather to quickly generate
    a hash so that IDs have a consistent appearance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, the interval parameter is a `sprintf()` pattern used
    to construct a proper `DateInterval` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize `$startDate`, we call `stringOrDate()`. We then attempt to generate
    a value for `$endDate` by calling either `stringOrDate()` or `calcEndDateFromOccurrences()`.
    If we have neither an end date nor a number of occurrences, an exception is thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stringOrDate()` method consists of a few lines of code that check the
    data type of the date variable, and return a `DateTime` instance or `NULL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `calcEndDateFromOccurrences()` method from the constructor if `$occurrences`
    is set so that we''ll know the end date for this event. We take advantage of the
    `DatePeriod` class, which provides an iteration based on a start date, `DateInterval`,
    and number of occurrences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we throw in a `__toString()` magic method, which simple echoes the title
    of the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method we need to define for our `Event` class is `getNextDate()`,
    which is used when generating a calendar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we turn our attention to the `Application\I18n\Calendar` class described
    in the previous recipe. With a bit of minor surgery, we are ready to tie our newly
    defined `Event` class into the calendar. First we add a new property, `$events`,
    and a method to add events in the form of an array. We use the `Event::$id` property
    to make sure events are merged and not overwritten:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add a method, `processEvents()`, which adds an `Event` instance to
    a `Day` object when building the year calendar. First we check to see whether
    there are any events, and whether or not the `Day` object is `NULL`. As you may
    recall, it''s likely that the first day of the month doesn''t fall on the first
    day of the week, and thus the need to set the value of a `Day` object to `NULL`.
    We certainly do not want to add events to a non-operative day! We then call `Event::getNextDate()`
    and see whether the dates match. If so, we store the `Event` into `Day::$events[]`
    and set the next date on the `Event` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that we do not do a direct comparison of the two objects. Two reasons
    for this: first of all, one is a `DateTime` instance, the other is an `IntlCalendar`
    instance. The other, more compelling reason, is that it''s possible that hours:minutes:seconds
    were included when the `DateTime` instance was obtained, resulting in actual value
    differences between the two objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add a call to `processEvents()` in the `buildMonthArray()` method
    so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to modify `getWeekDaysRow()`, adding the necessary code to
    output event information inside the box along with the date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To tie events to the calendar, first code the `Application\I18n\Event` class
    described in steps 1 to 10\. Next, modify `Application\I18n\Calendar` as described
    in steps 11 to 14\. You can then create a test script, `chap_08_recurring_events.php`,
    which sets up autoloading and creates `Locale` and `Calendar` instances. For the
    purposes of illustration, go ahead and use ''`es_ES`'' as a locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start defining and adding events to the calendar. The first example
    adds an event that lasts 3 days and starts on 8 January 2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example, an event that occurs on the first of every month until
    September 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add sample weekly, bi-weekly, monthly, and so on events as desired.
    You can then close the `try...catch` block, and produce suitable display logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output showing the first few months of the year:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on `IntlCalendar` field constants that can be used with
    `get()`, please refer to this page: [http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants](http://php.net/manual/en/class.intlcalendar.php#intlcalendar.constants)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling translation without gettext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Translation is an important part of making your website accessible to an international
    customer base. One way this is accomplished it to use the PHP `gettext` functions,
    which are based on the **GNU** `gettext` operating system tools installed on the
    local server. `gettext` is well documented and well supported, but uses a legacy
    approach and has distinct disadvantages. Accordingly, in this recipe, we present
    an alternative approach to translation where you can build your own *adapter*.
  prefs: []
  type: TYPE_NORMAL
- en: Something important to recognize is that the programmatic translation tools
    available to PHP are primarily designed to provide limited translation of a word
    or phrase, referred to as the **msgid** (**message ID**). The translated equivalent
    is referred to as the **msgstr** (**message string**). Accordingly, incorporating
    translation typically only involves relatively unchanging items such as menus,
    forms, error or success messages, and so on. For the purposes of this recipe,
    we will assume that you have the actual web page translations stored as blocks
    of text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to translate entire pages of content, you might consider using the
    *Google Translate API*. This is, however, a paid service. Alternatively, you could
    outsource the translation to individuals with multi-lingual skills cheaply using
    *Amazon Mechanical Turk*. See the *See Also* section at the end of this recipe
    for the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will once again use the Adapter software design pattern, in this case to
    provide alternatives to the translation source. In this recipe, we will demonstrate
    adapters for `.ini` files, `.csv` files, and databases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To begin, we will define an interface that will later be used to identify a
    translation adapter. The requirements for a translation adapter are quite simple,
    we only need to return a message string for a given message ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a trait that matches the interface. The trait will contain the
    actual code required. Note that if we fail to find the message string, we simply
    return the message ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to define our first adapter. In this recipe, we''ll start
    with an adapter that uses an `.ini` file as the source of translations. The first
    thing you''ll notice is that we use the trait defined previously. The constructor
    method will vary between adapters. In this case, we use `parse_ini_file()` to
    produce an array of key/value pairs where the key is the message ID. Notice that
    we use the `$filePattern` parameter to substitute the locale, which then allows
    us to load the appropriate translation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The next adapter, `Application\I18n\Translate\Adapter\Csv`, is identical, except
    that we open the translation file and loop through using `fgetcsv()` to retrieve
    the message ID / message string key pairs. Here we show only the difference in
    the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The big disadvantage of both of these adapters is that we need to preload the
    entire translation set, which puts a strain on memory if there is a large number
    of translations. Also, the translation file needs to be opened and parsed, which
    drags down performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now present the third adapter, which performs a database lookup and avoids
    the problems of the other two adapters. We use a `PDO` prepared statement which
    is sent to the database in the beginning, and only one time. We then execute as
    many times as needed, supplying the message ID as an argument. You will also notice
    that we needed to override the `translate()` method defined in the trait. Finally,
    you might have noticed the use of `PDOStatement::fetchColumn()` as we only need
    the one value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to define the core `Translation` class, which is tied to one
    (or more) adapters. We assign a class constant to represent the default locale,
    and properties for the locale, adapter, and text file pattern (explained later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we determine the locale, and set the initial adapter to
    this locale. In this manner, we are able to host multiple adapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define a series of setters, which gives us more flexibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the PHP magic method `__invoke()`, which lets us make a direct
    call to the translator instance, returning the message string given the message
    ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we also add a method that can return translated blocks of text from
    text files. Bear in mind that this could be modified to use a database instead.
    We did not include this functionality in the adapter, as its purpose is completely
    different; we just want to return large blocks of code given a key, which could
    conceivably be the filename of the translated text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First you will need to define a directory structure to house the translation
    files. For the purposes of this illustration, you can make a directory ,`/path/to/project/files/data/languages`.
    Under this directory structure, create sub-directories that represent different
    locales. For this illustration, you could use these: `de_DE`, `fr_FR`, `en_GB`,
    and `es_ES`, representing German, French, English, and Spanish.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next you will need to create the different translation files. As an example,
    here is a representative `data/languages/es_ES/translation.ini` file in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, to demonstrate the CSV adapter, create the same thing as a CSV file,
    `data/languages/es_ES/translation.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a database table, `translation`, and populate it with the same
    data. The main difference is that the database table will have three fields: `msgid`,
    `msgstr`, and `locale_code`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the classes mentioned previously, using the code shown in this
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Adapter\TranslateAdapterInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Adapter\TranslateAdapterTrait`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Adapter\Ini`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Adapter\Csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Adapter\Database`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\I18n\Translate\Translation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can create a test file, `chap_08_translation_database.php`, to test
    the database translation adapter. It should implement autoloading, use the appropriate
    classes, and create a `Locale` and `Connection` instance. Note that the `TEXT_FILE_PATTERN`
    constant is a `sprintf()` pattern in which the locale code and filename are substituted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a translation adapter instance and use that to create a `Translation`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create display logic that uses the `$translate` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then perform additional similar tests, substituting a new locale to
    get a different language, or using another adapter to test a different data source.
    Here is an example of output using a locale of `fr_FR` and the database translation
    adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the Google Translation API, see [https://cloud.google.com/translate/v2/translating-text-with-rest](https://cloud.google.com/translate/v2/translating-text-with-rest).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Amazon Mechanical Turk, see [https://www.mturk.com/mturk/welcome](https://www.mturk.com/mturk/welcome).
    For more information on `gettext`, see [http://www.gnu.org/software/gettext/manual/gettext.html](http://www.gnu.org/software/gettext/manual/gettext.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
