- en: Chapter 2. States and Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Property animation in Qt
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using easing curves to control property animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the animation group
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the nested animation group
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State machine in Qt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: States, transitions, and animations in QML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation widget properties using animators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite animation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides an easy way to animate widgets or any other objects that inherit
    the `QObject` class, through its powerful animation framework. The animation can
    be used either on its own or used together with the state machine framework, which
    allows different animations to be played based on the current active state of
    the widget. Qt's animation framework also supports grouped animation, which allows
    you to move more than one graphics item simultaneously, or move them in sequence
    one after the other.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Property animation in Qt
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to animate our **Graphical User Interface**
    (**GUI**) elements using Qt's property animation class, part of its powerful animation
    framework, which allows us to create fluid looking animation with minimal effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's create a new Qt Widgets Application project. After that, open up
    `mainwindow.ui` with Qt Designer and place a button on the main window, as shown
    here:![How to do it…](img/B02820_02_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open up `mainwindow.cpp` and add the following line of code at the beginning
    of the source code:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, open up `mainwindow.cpp` and add the following code to the constructor:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the more common methods to animate a GUI element is through the property
    animation class provided by Qt, known as the `QPropertyAnimation` class. This
    class is part of the animation framework and it makes use of the timer system
    in Qt to change the properties of a GUI element over a given duration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to accomplish here is to animate the button from one position
    to another, while at the same time we also enlarge the button size along the way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: By including the `QPropertyAnimation` header in our source code in Step 2, we
    will be able to access the `QPropertyAnimation` class provided by Qt and make
    use of its functionalities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The code in Step 3 basically creates a new property animation and applies it
    to the push button we just created in Qt Designer. We specifically request the
    property animation class changes the `geometry` properties of the push button
    and sets its duration to 3,000 milliseconds (3 seconds).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the start value of the animation is set to the initial geometry of the
    push button, because obviously we want it to start from where we initially place
    the button in Qt Designer. The end value is then set to what we want it to become;
    in this case we will move the button to a new position at x: `200`, y: `200` while
    changing its size to width: `100`, height: `50` along the way.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: After that, `call animation->start()` to start the animation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the project and now you should see the button start to move
    slowly across the main window while expanding in size a bit at a time, until it
    reaches its destination. You can change the animation duration and the target
    position and scale by altering the values in the preceding code. It's really that
    simple to animate a GUI element using Qt's property animation system!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt provides us with several different sub-systems to create animations for
    our GUI, including timer, timeline, animation framework, state machine framework,
    and graphics view framework:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**Timer**: Qt provides us with repetitive and single-shot timers. When the
    timeout value is reached, an event callback function will be triggered through
    Qt''s signal-and-slot mechanism. You can make use of a timer to change the properties
    (color, position, scale, and so on) of your GUI element within a given interval,
    in order to create an animation.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: Timeline calls a slot periodically to animate a GUI element.
    It is quite similar to a repetitive timer, but instead of doing the same thing
    all the time when the slot is triggered, timeline provides a value to the slot
    to indicate its current frame index, so that you can do different things (such
    as offset to a different space of the sprite sheet) based on the given value.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation framework**: The animation framework makes animating a GUI element
    easy by allowing its properties to be animated. The animations are controlled
    by using easing curves. Easing curves describe a function that controls what the
    speed of the animation should be, resulting in different acceleration and deceleration
    patterns. The types of easing curve supported by Qt include: linear, quadratic,
    cubic, quartic, sine, exponential, circular, and elastic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State machine framework**: Qt provides us with classes for creating and executing
    state graphs, which allow each GUI element to move from one state to another when
    triggered by signals. The state graph in the state machine framework is hierarchical,
    which means every state can also be nested inside of other states.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics view framework**: The graphics view framework is a powerful graphics
    engine for visualizing and interacting with a large number of custom-made 2D graphical
    items. You can use the graphics view framework to draw your GUI and have them
    animated in a totally manual way if you are an experienced programmer.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By making use of all the powerful features mentioned here, we're able to create
    an intuitive and modern GUI with ease. In this chapter, we will look into the
    practical approaches to animating GUI elements using Qt.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using easing curves to control property animation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to make our animation more interesting by
    utilizing easing curves. We will still use the previous source code, which uses
    the property animation to animate a push button.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define an easing curve and add it to the property animation before calling
    the `start()` function:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Call the `setLoopCount()` function to set how many loops you want it to repeat
    for:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Call `setAmplitude()`, `setOvershoot()`, and `setPeriod()` before applying
    the easing curve to the animation:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to let an easing curve control the animation, all you need to do is
    to define an easing curve and add it to the property animation before calling
    the `start()` function. You can also try several other types of easing curve and
    see which one suits you best. Here is an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want the animation to loop after it has finished playing, you can call
    the `setLoopCount()` function to set how many loops you want it to repeat for,
    or set the value to `-1` for an infinite loop:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several parameters that you can set to refine the easing curve before
    applying it to the property animation. These parameters include amplitude, overshoot,
    and period:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Amplitude**: The higher the amplitude, the higher the bounce or elastic spring
    effect that will be applied to the animation.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overshoot**: Some curve functions will produce an overshoot (exceeding its
    final value) curve due to damping effect. By adjusting the overshoot value, we
    are able to increase or decrease this effect.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Period**: Setting a small period value will give a high frequency to the
    curve. A large period will give it a small frequency.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters, however, are not applicable to all curve types. Please refer
    to the Qt documentation to see which parameter is applicable to which curve type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the property animation works perfectly fine, sometimes it feels a little
    boring to look at a GUI element animated at a constant speed. We can make the
    animation look more interesting by adding an easing curve to control the motion.
    There are many types of easing curve that you can use in Qt, and here are some
    of them:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B02820_02_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, each easing curve produces a different
    ease-in and ease-out effect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the full list of easing curves available in Qt, please refer to the Qt documentation
    at [http://doc.qt.io/qt-5/qeasingcurve.html#Type-enum](http://doc.qt.io/qt-5/qeasingcurve.html#Type-enum).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animation group
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to use an animation group to manage the states
    of the animations contained in the group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the previous example, but this time, we add two more push buttons
    to the main window, like so:![How to do it…](img/B02820_02_03.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, define the animation for each of the push buttons in the main window''s
    constructor:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, create an easing curve and apply the same curve to all three animations:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you have applied the easing curve to all three animations, we will then
    create an animation group and add all three animations to the group:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the `start()` function from the animation group we just created:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using an animation group now, we no longer call the `start()` function
    from the individual animation, but instead we will be calling the `start()` function
    from the animation group we just created.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compile and run the example now, you will see all three buttons being
    played at the same time. This is because we are using the parallel animation group.
    You can replace it with a sequential animation group and run the example again:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, only a single button will play its animation at a time, while the
    other buttons will wait patiently for their turn to come.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The priority is set based on which animation is added to the animation group
    first. You can change the animation sequence by simply rearranging the sequence
    of an animation being added to the group. For example, if we want button 3 to
    start the animation first, followed by button 2, and then button 1, the code will
    look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since property animations and animation groups are both inherited from the `QAbstractAnimator`
    class, it means that you can also add an animation group to another animation
    group to form a more complex, nested animation group.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt allows us to create multiple animations and group them into an animation
    group. A group is usually responsible for managing the state of its animations
    (that is, it decides when to start, stop, resume, and pause them). Currently,
    Qt provides two types of class for animation groups, `QParallelAnimationGroup`
    and `QSequentialAnimationGroup`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`QParallelAnimationGroup`: As its name implies, a parallel animation group
    runs all the animations in its group at the same time. The group is deemed finished
    when the longest-lasting animation has finished running.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSequentialAnimationGroup`: A sequential animation group runs its animations
    in sequence, meaning it will only run a single animation at a time, and only play
    the next animation when the current one has finished.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a nested animation group
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One good example of using a nested animation group is when you have several
    parallel animation groups and you want to play the groups in a sequential order.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the UI from the previous example and add a few more buttons to the
    main window, like so:![How to do it…](img/B02820_02_04.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create all the animations for the buttons, then create an easing curve
    and apply it to all the animations:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create two animation groups, one for the buttons in the upper column and another
    one for the lower column:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will create yet another animation group, which will be used to store the
    two animation groups we created previously:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we're trying to do here is to play the animation of the buttons in the
    upper column first, followed by the buttons in the lower column.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Since both of the animation groups are parallel animation groups, the buttons
    belonging to the respective groups will be animated at the same time when the
    `start()` function is called.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This time, however, the group is a sequential animation group, which means only
    a single parallel animation group will be played at a time, followed by the other
    when the first one is finished.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Animation groups are a very handy system that allows us to create very complex
    GUI animations with simple coding. Qt will handle the difficult part for us so
    we don't have to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: State machines in Qt
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State machines can be used for many purposes, but in this chapter we will only
    cover topics related to animation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will set up a new user interface for our example program, which looks
    like this:![How to do it…](img/B02820_02_06.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will include some headers in our source code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, in our main window''s constructor, add the following code to create
    a new state machine and two states, which we will be using later:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will define what we should do within each state, which in this case
    will be to change the label''s text, as well as the button''s position and size:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you are done with that, let''s proceed by adding event transition classes
    to our source code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add all the states we have just created to the state machine and define
    state 1 as the initial state. Then, call `machine->start()` to start running the
    state machine:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you run the example program now, you will notice everything works fine, except
    the button is not going through a smooth transition and it simply jumps instantly
    to the position and size we set previously. This is because we have not used a
    property animation to create a smooth transition.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the event transition step and add the following lines of code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also add an easing curve to the animation to make it look more interesting:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two push buttons and a label on the main window layout. The button
    at the top-left corner will trigger the state change when pressed, while the label
    at the top-right corner will change its text to show which state we are currently
    in, and the button below will animate according to the current state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The `QEventTransition` classes define what will trigger the transition between
    one state and another.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we want the state to change from state 1 to state 2 when the `ui->changeState`
    button (the one at the upper left) is clicked. After that, we also want to change
    from state 2 back to state 1 when the same button is pressed again. This can be
    achieved by creating another event transition class and setting the target state
    back to state 1\. Then, add these transitions to their respective states.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just assigning the properties directly to the widgets, we tell Qt
    to use the property animation class to smoothly interpolate the properties toward
    the target values. It is that simple!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to set the start value and end value, because we have already
    called the `assignProperty()` function, which has automatically assigned the end
    value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state machine framework in Qt provides classes for creating and executing
    state graphs. Qt's event system is used to drive the state machines, where transitions
    between states can be triggered by using signals, then the slots on the other
    end will be invoked by the signals to perform an action, such as playing an animation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand the basics of state machines, you can use them to do other
    things as well. The state graph in the state machine framework is hierarchical.
    Just like the animation group in the previous section, states can also be nested
    inside of other states:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B02820_02_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: States, transitions, and animations in QML
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you prefer to work with QML instead of C++, Qt also provides similar features
    in Qt Quick that allow you to easily animate a GUI element with the minimum lines
    of code. In this example, we will learn how to achieve this with QML.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we will create a new **Qt Quick Application** project and set up our user
    interface like so:![How to do it…](img/B02820_02_07.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what my `main.qml` file looks like:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the color animation to the `Rectangle` object:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add a number animation to the text object:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add another number animation to it:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define two states, one called the `PRESSED` state and another called the `RELEASED`
    state. Then, set the default state to `RELEASED`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, create a mouse area within the `Rectangle` object so that we can
    click on it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add some transitions to the `Rectangle` object:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main window consists of a blue rectangle and static text that says `Hello
    World`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We want the background color to change from blue to yellow, then to red, and
    back to blue in a loop. This can be easily achieved using the color animation
    type in QML.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: What we're doing at Step 3 is basically creating a sequential animation group
    within the `Rectangle` object, then creating three different color animations
    within the group, which will change the color of the object every 1,000 milliseconds
    (1 second). We also set the animations to loop infinitely.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In Step 4, we want to use the number animation to animate the alpha value of
    the static text. We created another sequential animation group within the `Text`
    object and created two number animations to animate the alpha value from 0 to
    1 and back. Then, we set the animations to loop infinitely.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Then in Step 5, we rotate the `Hello World` text by adding another number animation
    to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In Step 6, we wanted to make the `Rectangle` object change from one color to
    another when we click on it. When the mouse is released, the `Rectangle` object
    will change back to its initial color. To achieve that, first we need to define
    the two states, one called the `PRESSED` state and another called the `RELEASED`
    state. Then, we set the default state to `RELEASED`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you compile and run the example, the background will instantly change
    color to blue when pressed and change back to red when the mouse is released.
    That works great and we can further enhance it by giving it a little transition
    when switching color. This can be easily achieved by adding transitions to the
    `Rectangle` object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In QML, there are eight different types of property animation you can use:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Anchor animation**: Animates changes in anchor values'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color animation**: Animates changes in color values'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number animation**: Animates changes in qreal-type values'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent animation**: Animates changes in parent values'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path animation**: Animates an item along a path'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property animation**: Animates changes in property values'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation animation**: Animates changes in rotation values'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector3d animation**: Animates changes in QVector3d values'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the C++ version, these animations can also be grouped together in
    an animation group to play the animations in sequence or in parallel. You can
    also control the animations using easing curves and determine when to play these
    animations using state machines, just like what we have done in the previous section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Animating widget properties using animators
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to animate the properties of our GUI widgets
    using the animator feature provided by QML.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a rectangle object and add a scale animator to it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a rotation animator and set the running value in the parallel animation
    group, but not in any of the individual animators:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add an easing curve to the scale animator:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The animator type can be used just like any other animation type. We want to
    scale a rectangle from a size of `5` to a size of `1` within 2,000 milliseconds
    (2 seconds).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We created a blue `Rectangle` object and added a scale animator to it. We set
    the initial value to `5` and the final value to `1`. Then, we set the animation
    duration to `2000` and set the running value to `true` so that it will be played
    when the program starts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Just like the animation types, animators can also be put into groups (that is,
    parallel animation groups or sequential animation groups). An animation group
    will also be treated as an animator by QtQuick and be run on the scene graph's
    rendering thread whenever possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In Step 2, we want to group two different animators into a parallel animation
    group so that they run together at the same time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: We will keep the scale animator we have created previously and add another rotation
    animator to rotate the `Rectangle` object. This time, set the running value in
    the parallel animation group, but not in any of the individual animators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Just like the C++ version, QML also supports easing curves and they can be easily
    applied to any of the animations or animator types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: There is something called animator in QML, which is similar but different from
    the ordinary animation type. Animator types are a special type of animation that
    operate directly on Qt Quick's scene graph, rather than the QML objects and their
    properties like regular animation types do.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The value of the QML property will be updated after the animation has finished.
    However, the property is not updated while the animation is running. The benefits
    of using the animator type is that the performance is slightly better because
    it doesn't run on the UI thread, but operates directly on the scene graph's rendering
    thread.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Sprite animation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to create sprite animation in QML.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we'll need to add our sprite sheet to Qt's resource system so
    that it can be used in the program. Open up `qml.qrc` and click the **Add** |
    **Add Files** buttons. Select your sprite sheet image and save the resource file
    by pressing *Ctrl* + *S*.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, create a new empty window in `main.qml`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you''re done with that, we will start creating an `AnimatedSprite` object
    in QML:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a mouse area to the window and check for the `onClicked` event:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you compile and run the example program now, you will see a little pony running
    in the middle of the window. How fun!![How to do it…](img/B02820_02_08.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we want to try and do something cool. We will make the horse run across
    the window and loop infinitely while playing its running animation!
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to remove the `anchors.centerIn:` parent from QML and replace
    it with `x` and `y` values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, add a number animation to the sprite object and set its properties
    like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Compile and run the example program now and you will see the pony go crazy and
    start running across the window!
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we placed the animated sprite object in the middle of the window
    and set its image source to the sprite sheet that we had just added to the project
    resource.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Then, we counted how many frames there are in the sprite sheet that belong to
    the running animation, which in this case was 11 frames. We also told Qt about
    the dimension of each frame of the animation, which in this case was 128 x 128\.
    After that, we set the frame rate to `25` to get a decent speed and then set it
    to loop infinitely. We then set the running value to `true` so that the animation
    will be played by default when the program starts running.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Then in Step 4, we wanted to be able to pause the animation and resume it by
    clicking on the window. We simply check whether the sprite is current paused when
    clicking on the mouse area. If the sprite animation has been paused, then resume
    the animation; otherwise, pause the animation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In Step 6, we replaced `anchors.centerIn` with `x` and `y` values so that the
    animated sprite object is not anchored to the center of the window, which would
    have made it impossible to move around.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created a number animation within the animated sprite to animate its
    `x` property. We set the start value to somewhere outside the window on the left
    side, and set the end value to somewhere outside the window on the right side.
    After that, we set the duration to 3,000 milliseconds (3 seconds) and made it
    loop infinitely.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在动画精灵中创建了一个数字动画，以动画化其`x`属性。我们将起始值设置为窗口左侧的某个位置，将结束值设置为窗口右侧的某个位置。之后，我们将持续时间设置为3,000毫秒（3秒），并使其无限循环。
- en: Lastly, we also set the running value to `true` so that it will play the animation
    by default when the program starts running.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将运行值设置为`true`，这样当程序开始运行时，它将默认播放动画。
- en: There's more…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sprite animation is used extensively, especially in game development. Sprites
    are used for character animation, particle animation, and even GUI animation.
    A sprite sheet consists of many images combined into one, which can then be chopped
    down and displayed on the screen one at a time. The transitions between different
    images (or sprites) from the sprite sheet creates the illusion of animation, which
    we usually refer to as sprite animation. Sprite animation can be easily achieved
    in QML using the `AnimatedSprite` type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵动画被广泛应用，尤其在游戏开发中。精灵用于角色动画、粒子动画，甚至GUI动画。精灵表包含许多图像组合成一个，然后可以被切割并逐一显示在屏幕上。从精灵表中不同图像（或精灵）之间的过渡创造了动画的错觉，我们通常称之为精灵动画。在QML中，可以很容易地使用`AnimatedSprite`类型实现精灵动画。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example program, I'm using a free and open source image created by bluecarrot16
    under the CC-BY 3.0 / GPL 3.0 / GPL 2.0 / OGA-BY 3.0 license. The image can be
    obtained legally at [http://opengameart.org/content/lpc-horse](http://opengameart.org/content/lpc-horse).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例程序中，我使用了由bluecarrot16在CC-BY 3.0 / GPL 3.0 / GPL 2.0 / OGA-BY 3.0许可下创建的免费开源图像。该图像可以在[http://opengameart.org/content/lpc-horse](http://opengameart.org/content/lpc-horse)上合法获取。
