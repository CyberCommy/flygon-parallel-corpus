- en: Chapter 10. Releasing an App into the Wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The Internet is a wild land with its own games, languages, and gestures through
    which we are starting to share common feelings."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: – Ai Weiwei
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this chapter we will learn how to prepare a web application for release.
    First we will discuss how to compress and combine JavaScript files for faster
    download times. Then we will look at how to use the HTML5 Application Cache interface
    to make your applications available offline.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to combine and compress JavaScript files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a command-line script to prepare an application for release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the HTML5 Application Cache API to make a page and its resources
    available offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a cache manifest file to determine what resources get cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to determine when an application's cache has been updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining and compressing JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, the conventional wisdom among JavaScript developers was that you
    should write all of your code in one file, because downloading multiple script
    files causes a lot of unnecessary network traffic and slows down the load time.
    While reducing the number of files to download is indeed better, writing all of
    your code in one file is difficult to read and maintain. We don't write code like
    that in other languages, so why should we do it in JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately there is a solution to this problem: the JavaScript compressor.
    A compressor takes all of the JavaScript source files for an application, combines
    them into one file, and compresses them by renaming local variables to the smallest
    name possible, removing white space and comments. We get all of the benefits of
    using multiple source code files for development, plus all of the benefits of
    a single JavaScript file when releasing an application. You can think of it as
    compiling your source code into a compact executable package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of JavaScript compressors available out there. You can find
    many of them online. The problem with those is that you have to copy your source
    code and paste it into a web form, then copy it back out into a file. That doesn''t
    work too well for large applications. I suggest you use one of the compression
    applications that can be run from a command prompt, such as Yahoo''s YUI Compressor
    or Google''s Closure Compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/closure/](https://developers.google.com/closure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://yui.github.io/yuicompressor/](http://yui.github.io/yuicompressor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YUI and Closure are both easy to use and work extremely well. They both provide
    warnings about bad code (but not the same warnings). Both are written in Java
    and therefore require that you have the Java Runtime installed. I can't say one
    is better than the other. The only reason I would choose YUI would be if I also
    want to compress CSS, as Closure doesn't support it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a release script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to prepare your JavaScript for release is to create a script
    that can be run from the command line. In this example we will use the YUI Compressor,
    but it works almost identically for Closure. The only difference is the command-line
    parameters. In this example we create a command-line script that can be run from
    the Windows command line, that will take the Piano Hero application we wrote in
    [Chapter 7](ch07.html "Chapter 7. Piano Hero"), *Piano Hero*, and package it up
    for release. You can find the code for this section in `Chapter 10/example10.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we need to define a folder structure for the application.
    I like to create a base folder for the application that contains a `src` folder
    and a `release` folder. The base folder contains the command-line batch script.
    The `src` folder contains all of the source code and resources. The `release`
    folder will contain the compressed JavaScript file and all other resources necessary
    to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a release script](img/5947OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's create our batch script file and name it `release.bat`. The first
    thing we need to tell YUI is what files to compress. There are a couple of ways
    to do this. We can either concatenate all of our JavaScript files into one file
    and then reference that one file, or pass in a list of all the individual files.
    The method you use depends on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need the files to be processed in a certain order, or you don''t have
    a lot of files, then you can specify them individually as parameters. If you have
    a lot of files in your application and you''re not worried about order, then it''s
    probably easiest to just concatenate them into one file. For this example, we
    will use the `type` command to concatenate all JavaScript files into one file
    named `pianoHero.collated.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `type` command to find all `.js` files in the `src` folder and write
    them out to a file named `pianoHero.collated.js`. Note this does not include the
    files in the `lib` folder. I like to keep them separate, but you can certainly
    include any external libraries if you prefer (and if their license permits it).
    Now we will execute the compressor passing in the collated JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start the Java runtime telling it where to find the YUI Compressor's JAR
    file. We pass in a file type parameter of `js` since we are compressing JavaScript
    (YUI can also compress CSS). The `-o` parameter tells it where to write the output
    to. The last is the JavaScript file (or files if more than one) we want to compress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a `pianoHero.min.js` file in the `release` folder. We still need
    to copy all of the other resources to the `release` folder including the HTML
    and CSS files, the jQuery library, and the audio files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the `xcopy` command to copy `pianoHero.html`, `pianoHero.css`, everything
    in the `lib` folder, and everything in the `audio` folder to the `release` folder.
    At this point we have everything we need in the `release` folder to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one last thing to do. We need to remove the obsolete `<script>` elements
    in the HTML file and replace them with one that points to our compressed JavaScript
    file. This part isn''t easy to automate, so we need to crack the file open and
    do this manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now open the application in your browser and do a smoke test to make
    sure everything still works the way you expect it and then ship it!
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a Windows command-line script to combine all of our JavaScript source
    files into one and compress it using the YUI Compressor. We also copied all of
    the resources necessary to run the application to the `release` folder. Lastly,
    we changed the script reference to the compressed JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The YUI Compressor also minifies CSS. Add code to the release script to compress
    the CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 Application Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML5 Application Cache API provides a mechanism for caching the files and
    resources used by a web page. Once cached, it's as if the user downloaded and
    installed your application on their device. This allows the application to be
    used offline when the user is not connected to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Browsers may limit the amount of data that can be cached. Some browsers limit
    it to 5 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to getting your application cached is the cache manifest file. This
    file is a simple text file that contains information about what resources should
    be cached. It is referenced by the `manifest` attribute on the `<html>` element
    of your web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the manifest file, you can specify the resources to cache or not cache.
    The file can have three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CACHE`: This is the default section and lists the files to be cached. Declaring
    this section header is optional. Wildcards are not allowed in URIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NETWORK`: This section lists the files that require a network connection.
    Requests for these files bypass the cache. Wildcards are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FALLBACK`: This section lists fallback files if a resource is not available
    offline. Each entry contains the URI of the original file and the URI of the fallback
    file. Wildcards are allowed. Both URIs must be relative and from the same domain
    as the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cache manifest file can have any file extension, but it must be delivered
    with a MIME type of text/cache-manifest. You may need to associate the extension
    you use with this MIME type in your web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to note is that once the files for an application are cached
    only those versions of the files will be used, even if they change on the server.
    There are only two ways that the resources in the application cache can be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: When the manifest file changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clears the browser's data storage for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend keeping the cache manifest file out of the same folder as your HTML
    file while developing your application. You don't want files cached while you
    are writing code. Put it in the base folder of your application along with your
    release script and copy it to the `release` folder in your script.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you cache your application or not depends on the nature of your application.
    If it heavily depends upon Ajax calls to the server to work then making it available
    offline would be pointless. However, if you can write your application so that
    it stores data locally while offline, then it might be worthwhile. You should
    determine if the overhead of maintaining a cache manifest provides a benefit to
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a cache manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a simple application from our template to demonstrate how to use
    the cache manifest. It has HTML, CSS, and JavaScript files, and a couple of images
    in an `image` folder. You can find the source code for this example in `Chapter
    10/example10.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a cache manifest file named `app.appcache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The manifest file must always begin with `CACHE MANIFEST` on the first line.
    On the second line we have a comment. Lines that start with a hash mark (`#`)
    are comments. It's recommended that you have some type of version identifier or
    the release date in the comments of your manifest file. As noted previously, the
    only way to cause your application to be reloaded into the cache is to change
    the manifest file. Each time you release a new version you will need to update
    this version identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the files that we want cached. You can add the `CACHE` section
    header if you like, but it''s not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately wildcards are not allowed in this section, so you will need to
    explicitly list each file. For some applications, like Piano Hero with all of
    its audio files, that could be a lot of typing!
  prefs: []
  type: TYPE_NORMAL
- en: Next let's define the `NETWORK` section. Right about now you may be thinking,
    what's the point of this section? We already listed all of the files we want to
    be cached. So why the need to list files that you don't want to be cached? The
    reason is that once cached, your application will only get files from the cache,
    even when online. If you want to use non-cached resources in your application
    you will need to include them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that we have a site tracking image on our page to keep
    track of page hits. If we don''t add it to the `NETWORK` section, the request
    for it will never get to the server, even when the user is online. For the sake
    of this example we will use a static image file. In practice this would be PHP
    or some other server-side request handler that returns an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the `FALLBACK` section. Say we want to display an image in
    our application that lets the user know if they are online or offline. This is
    where we specify a fallback from an online to an offline image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's it for our manifest file. Now open the application in the browser so
    it gets cached. Then go into the JavaScript file and change the value of the `version`
    variable in the application object. Now refresh the page; nothing should change.
    Next go into the manifest file and change the version and refresh again. It still
    didn't change. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Remember how I said earlier that when the manifest file changes, it causes the
    application to be reloaded? While this is true, the manifest file does not get
    checked for changes until after the page has been loaded from the cache. Therefore
    the user would need to reload the page twice to get the updated version. Fortunately
    there is a way we can detect in JavaScript when the manifest file has changed
    and give the user a message that a newer version is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a JavaScript method called `checkIfUpdateAvailable()` to check when
    the cache has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First we add an `updateready` event listener to the `applicationCache` object.
    This gets fired after the browser finds that the manifest file has changed and
    has downloaded the updated resources. When we receive a notification that the
    cache has been updated, we display a message telling the user to reload the page.
    Now all we have to do is add a call to this method in the `start()` method of
    our application and we are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go update the version number in the application and the manifest file and
    refresh the page. You should see the update message displayed. Refresh the page
    again and you will see that the version has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a cache manifest](img/5947OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, let''s check our fallback. Disconnect your Internet connection and
    reload the page. You should see that the offline image is shown instead of online.
    Also notice that it couldn''t load the tracking image because we marked it as
    a non-cached resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a cache manifest](img/5947OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to use the HTML Application Cache to cache a web application.
    We used a manifest file to define resources that should be cached, a resource
    that was not cached, and another with a fallback when the application is offline.
    We also learned how to programmatically check when the cache has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What does a JavaScript compressor *not* do?
  prefs: []
  type: TYPE_NORMAL
- en: Zip your code up into a compressed file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine your JavaScript files into one file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all white space and comments from JavaScript files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename local variables to the smallest name possible
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. When are resources updated in the application cache?
  prefs: []
  type: TYPE_NORMAL
- en: When a file changes on the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the manifest file changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources are never updated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time the user starts the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how to take our finished applications and prepare
    them for release to the world. We used a JavaScript compressor to combine and
    compress all of our JavaScript files into one compact file. Then we used the Application
    Cache API to make an application available offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to combine and compress JavaScript files using the YUI Compressor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a command-line script that packages up our applications and gets
    them ready for release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Application Cache API to cache an application and make it available
    offline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a cache manifest file and define cached, non-cached, and fallback
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to programmatically check when the manifest file has changed and alert the
    user that an update is available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There you have it. We have covered HTML5 web application development from creating
    a starting template to preparing your application for release. Now go out there
    and start writing your own HTML5 web applications. I look forward to seeing how
    you use HTML5 to create the next big thing.
  prefs: []
  type: TYPE_NORMAL
