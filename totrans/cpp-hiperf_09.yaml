- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Essential Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce some essential classes from the C++ **Utility library**.
    Some of the metaprogramming techniques presented in the previous chapter will
    be used in order to work effectively with collections that contain elements of
    different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ containers are homogenous, meaning that they can only store elements of
    one single type. A `std::vector<int>` stores a collection of integers and all
    objects stored in a `std::list<Boat>` are of type `Boat`. But sometimes, we need
    to keep track of a collection of elements of different types. I will refer to
    these collections as **heterogenous collections**. In a heterogeneous collection,
    the elements may have different types. The following figure shows an example of
    a homogenous collection of `int`s and a heterogenous collection with elements
    of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Homogenous and heterogenous collections'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover a set of useful templates from the C++ Utility library
    that can be used to store multiple values of various types. The chapter is divided
    into four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing optional values with `std::optional`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed size collections using `std::pair`, `std::tuple`, and `std::tie()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically sized collections using the standard containers with elements of
    type `std::any` and `std::variant`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-world examples that demonstrate the usefulness of `std::tuple` and
    `std::tie()`, together with the metaprogramming concepts we covered in *Chapter
    8*, *Compile-Time Programming*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by exploring `std::optional` and some of its important use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Representing optional values with std::optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although quite a minor feature from C++17, `std::optional` is a nice addition
    to the standard library. It simplifies a common case that couldn't be expressed
    in a clean and straightforward way prior to `std::optional`. In a nutshell, it
    is a small wrapper for any type where the wrapped type can be either initialized or
    uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: To put it in C++ lingo, `std::optional` is a* stack-allocated container with
    a max size of one*.
  prefs: []
  type: TYPE_NORMAL
- en: Optional return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before the introduction of `std::optional`, there was no clear way to define
    functions that may not return a defined value, such as the intersection point
    of two line segments. With the introduction of `std::optional`, such optional
    return values can be clearly expressed. What follows is an implementation of a
    function that returns an optional intersection between two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of `std::optional` resembles that of a pointer; the value is accessed
    by `operator*()` or `operator->()`. Trying to access the value of an empty optional
    using `operator*()` or `operator->()` is undefined behavior. It''s also possible
    to access the value using the `value()` member function, which instead will throw
    an `std::bad_optional_access` exception if the optional contains no value. What
    follows is a simple example of a returned `std::optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The object held by a `std::optional`  is always stack allocated, and the memory
    overhead for wrapping a type into a `std::optional`  is the size of a bool (usually
    one byte), plus possible padding.
  prefs: []
  type: TYPE_NORMAL
- en: Optional member variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have a class that represents a human head. The head can have
    a hat of some sort, or no hat at all. By using `std::optional` to represent the
    hat member variable, the implementation is as expressive as it can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Without `std::optional`, representing an optional member variable would rely
    on, for example, a pointer or an extra `bool` member variable. Both have disadvantages
    such as allocating on the heap, or accidentally accessing an optional considered
    empty without a warning.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding empty states in enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pattern that can be seen in old C++ code bases is *empty states* or *null
    states* in `enum`s. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `enum`, `none` is a so-called null state. The reason for adding
    the `none` value in the `Color` `enum` is to make it possible to represent an
    optional color, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, with this design, there is no way to represent a non-optional color,
    which makes it necessary for *all* code to handle the extra null state `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better alternative is to avoid the extra null state, and instead represent
    an optional color with the type `std::optional<Color>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This clearly indicates that we might not get a color back. But we also know
    that once we have a `Color` object, there is no way it can be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When implementing `set_color()`, we know that the client has passed a valid
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and comparing std::optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::optional` is equally comparable and sortable using the rules shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Two *empty* optional values are considered equal. | An empty optional is
    considered *less* than a non-empty. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if you sort a container of `std::optional<T>`, the empty optional
    values will end up at the beginning of the container, whereas the non-empty optionals
    will be sorted as usual, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you are in the habit of representing optional values using pointers, designing
    APIs using out parameters, or adding special null states in enums, it's time to
    add `std::optional` to your toolbox, as it provides an efficient and safe alternative
    to these anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by exploring collections of a fixed size that can hold elements
    of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed size heterogenous collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ Utility library includes two class templates that can be used for storing
    multiple values of different types: `std::pair` and `std::tuple`. They are both
    collections with a fixed size. Just like `std::array`, it''s not possible to add
    more values dynamically at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between `std::pair` and `std::tuple` is that `std::pair`
    can only hold two values, whereas `std::tuple` can be instantiated with an arbitrary
    size at compile time. We will begin with a brief introduction to `std::pair` before
    moving on to `std::tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: Using std::pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class template `std::pair` lives in the `<utility>` header and has been
    available in C++ since the introduction of the standard template library. It is
    used in the standard library where algorithms need to return two values, such
    as `std::minmax()`, which can return both the smallest and the greatest value
    of an initializer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows that the elements of a `std::pair` can be accessed
    through the members `first` and `second`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `std::pair` holds values of the same type, so, it would have been
    possible to return an array here as well. But what makes `std::pair` even more
    interesting is that it can hold values of *different* types. This is the reason
    why we consider this a heterogeneous collection, despite the fact that it can
    only hold two values.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example from the standard library where `std::pair` holds different values
    is the associative container `std::map`. The value type of `std::map` is a pair
    that consists of the key and the element that the key is associated with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The requirement to explicitly name the `std::pair` type has decreased, and
    in modern C++, it''s common to use initializer lists and structured bindings to
    hide the fact that we are dealing with values of `std::pair`. The following example
    expresses the same thing but without mentioning the underlying `std::pair` explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will talk more about structured binding later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, `std::pair` can only hold two values. C++11 introduced
    a new utility class called `std::tuple`, which is a generalization of `std::pair`
    that can hold an arbitrary number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The std::tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::tuple` can be used as a fixed-size heterogeneous collection that can
    be declared to be of any size. In contrast to `std::vector`, for example, its
    size cannot change at runtime; you cannot add or remove elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple can be constructed with its member types explicitly specified like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can initialize it using class template argument deduction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the compiler generate a class, which can roughly be viewed like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As with many other classes in the C++ standard library, `std::tuple` also has
    a corresponding `std::make_tuple()` function, which deduces the types automatically
    from the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But as stated earlier, from C++17 and onward, many of these `std::make_` functions
    are superfluous, since C++17 classes can deduce these types from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the members of a tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The individual elements of `std::tuple` can be accessed using the free function
    template `std::get<Index>()`. You may wonder why the members can''t be accessed
    like a regular container with the `at(size_t index)` member function. The reason
    is that a member function such as `at()` is only allowed to return one type, whereas
    a tuple consists of different types at different indices. Instead, the function
    template `std::get()` is used with the index as a template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can imagine the `std::get()` function being implemented something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that when we create and access a tuple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler roughly generates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that this example can merely be thought of as a simplistic way to imagine
    what the compiler generates when constructing `std::tuple`; the interior of `std::tuple`
    is very complex. Still, it is important to understand that a `std::tuple` class
    is basically a simple struct whose members can be accessed by a compile-time index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::get()` function template can also use the typename as a parameter.
    It is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is only possible if the specified type is contained once in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating std::tuple members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From a programmer''s perspective, it may seem that `std::tuple` can be iterated
    with a regular range-based `for`-loop, just like any other container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The reason this is not possible is that the type of `const auto& v` is only
    evaluated once, and since `std::tuple` contains elements of different types, this
    code simply does not compile.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for regular algorithms, as iterators don't mutate the type pointed
    to; therefore, `std::tuple` does not provide a `begin()` or `end()` member function,
    nor does it provide a subscript operator, `[]`, for accessing the values. So,
    we need to come up with some other way to unroll the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Unrolling the tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As tuples cannot be iterated as usual, what we need to do is use metaprogramming
    to unroll the loop. From the previous example, we want the compiler to generate
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we iterate every index of the tuple, which means we need the
    number of types/values contained in the tuple. Then, since the tuple contains
    different types, we need to write a meta-function that generates a new function
    for every type in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start with a function that generates the call for a specific index, it
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can then combine it with a generic lambda, as you learned in *Chapter 2,*
    *Essential C++ Techniques**:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the function `tuple_at()` in place, we can then move on to the actual
    iteration. The first thing we need is the number of values in the tuple as a compile-time
    constant. Fortunately, this value can be obtained by the type trait `std::tuple_size_v<Tuple>`.
    Using `if constexpr`, we can then unfold the iteration by creating a similar function,
    which takes different actions, depending on the index:'
  prefs: []
  type: TYPE_NORMAL
- en: If the index is equal to the tuple size, it generates an empty function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it executes the lambda at the passed index and generates a new function
    with 1 added to the index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how the code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the default index is set to zero so that we don''t have to
    specify it when iterating. This `tuple_for_each()` function can then be called
    like this, with the lambda directly in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Quite nice; syntactically, it looks pretty similar to the `std::for_each()`
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing other algorithms for tuples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Expanding upon `tuple_for_each()`, different algorithms iterating a tuple can
    be implemented in a similar manner. Here is an example of how `std::any_of()`
    for tuples is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The function template `tuple_any_of()` iterates through every type in the tuple
    and generates a lambda function for the element at the current index, which it
    then compares with `44`. In this case, `has_44` will evaluate to `true`, as the
    last element, a `double` value, is `44`. If we add an element of a type that is
    not comparable with `44`, such as `std::string`, we will get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing tuple elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to C++17, there were two standard ways of accessing elements of a `std::tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: For accessing single elements, the function `std::get<N>(tuple)` was used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For accessing multiple elements, the function `std::tie()` was used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although they both worked, the syntax for performing such a simple task was
    very verbose, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In order to be able to perform this common task elegantly, structured bindings
    were introduced in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Structured bindings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using structured bindings, multiple variables can be initialized at once using
    `auto` and a bracket declaration list. As with the `auto` keyword in general,
    you can apply control over whether the variables should be mutable references,
    forward references, const references, or values by using the corresponding modifier.
    In the following example, a structured binding of `const` references is being
    constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured bindings can also be used to extract the individual members of a
    tuple in a `for`-loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a quick tip. If you want to return multiple arguments with named variables
    instead of tuple indices, it is possible to return a struct defined inside a function
    and use automatic return type deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured bindings also work with structs, so, we might capture the individual
    data members directly as follows, even if it is a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can choose arbitrary names for our identifiers since it's the
    order of the data members of `Planet` that is relevant, just like when returning
    a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at another use case for `std::tuple` and `std::tie()` when
    handling an arbitrary number of function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The variadic template parameter pack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **variadic** **template parameter pack** enables programmers to create template
    functions that can accept any number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a function with a variadic number of arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we were to create a function that makes a string out of any number of arguments
    without variadic template parameter packs, we would need to use C-style variadic
    arguments (just like `printf()` does) or create a separate function for every
    number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the intended use of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we require a large number of arguments, this becomes tedious, but with a
    parameter pack, we can implement this as a function that accepts an arbitrary
    number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to construct a variadic parameter pack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The parameter pack is identified by putting three dots in front of the typename
    and three dots after the variadic argument expands the pack, with a comma in-between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the syntactic explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ts` is a list of types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<typename ...Ts>` indicates that the function deals with a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values...` expands the pack such that a comma is added between every value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put it into code, consider this `expand_pack()` function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the preceding function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the compiler will generate a function similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the individual parameter pack parts expand to:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression: | Expands to: |'
  prefs: []
  type: TYPE_TB
- en: '| `template <typename... Ts>` | `template <typename T0, typename T1>` |'
  prefs: []
  type: TYPE_TB
- en: '| `expand_pack(const Ts& ...values)` | `expand_pack(const T0& v0, const T1&
    v1)` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::tie(values...)` | `std::tie(v0, v1)` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Expanding expressions'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can create a `make_string()` function with a variadic
    parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further with the initial `make_string()` function, in order to create
    a string out of every parameter, we need to iterate the pack. There is no way
    to directly iterate a parameter pack, but a simple workaround would be to make
    a tuple out of it and then iterate it with the `tuple_for_each()` function template,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter pack is converted into a `std::tuple` with `std::tie()` and then
    iterated using `tuple_for_each()`. To recap, the reason we need to use `std::tuple`
    to handle the parameters are because we want to support an arbitrary number of
    parameters of various types. If we only had to support parameters of one specific
    type, we could instead have used a `std::array` with a range-based `for`-loop,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you have seen, `std::tuple` is a heterogenous collection with a fixed size
    and fixed element positions—more or less like a regular struct but without named
    member variables.
  prefs: []
  type: TYPE_NORMAL
- en: How can we expand upon this to create a dynamically sized collection (such as
    `std::vector` and `std::list`) but with the ability to store elements of mixed
    types? We'll look at a solution to this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically sized heterogenous collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by noting that the dynamically sized containers offered
    by C++ are homogenous, meaning that we can only store elements of one single type.
    But sometimes, we need to keep track of a collection that's dynamic in size that
    contains elements of different types. To be able to do that, we will use containers
    that contain elements of type `std::any` or `std::variant`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest solution is to use `std::any` as the base type. The `std::any`
    object can store any type of value in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It has some drawbacks, though. First, every time a value in it is accessed,
    the type must be tested for at runtime. In other words, we completely lose the
    type information of the stored value at compile time. Rather, we have to rely
    on runtime type checks for the information. Secondly, it allocates the object
    on the heap rather than the stack, which can have significant performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to iterate our container, we need to explicitly say this to every
    `std::any` object: *if you are an int, do this, and if you are a char pointer,
    do that*. This is not desirable as it requires repeated source code, and it is
    also less efficient than using other alternatives, which we will cover later in
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example compiles; the type is explicitly tested for and casted
    upon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply cannot print it with a regular stream operator since the `std::any`
    object has no idea of how to access its stored value. Therefore, the following
    code does not compile; the compiler does not know what''s stored in `std::any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We usually don't need the full flexibility of types that `std::any` offers,
    and in many cases, we are better off using the `std::variant`, which we will cover
    next.
  prefs: []
  type: TYPE_NORMAL
- en: The std::variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we don't need the ability to store *any* type in the container, but instead
    we want to concentrate on a fixed set of types declared at container initialization,
    then `std::variant` is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::variant` has two main advantages over `std::any`:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not store its contained type on the heap (unlike `std::any`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be invoked with a generic lambda, meaning you don't explicitly have to
    know its currently contained type (more about this in the later sections of this
    chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::variant` works in a somewhat similar manner to a tuple, except that
    it only stores one object at a time. The contained type and value are the type
    and value we assigned it last. The following image illustrates the difference
    between a `std::tuple` and a `std::variant` when they''ve been instantiated with
    the same types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Tuple of types versus variant of types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using a `std::variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We are using `std::holds_alternative<T>()` to check whether the variant currently
    holds a given type. You can see that the type changes when we assign the variant
    new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from storing the actual value, a `std::variant` also keeps track of the
    currently held alternative by using an index that''s usually of size `std::size_t`.
    This means that the total size of a `std::variant` is typically the size of the
    biggest alternative, plus the size of the index. We can verify this by using the
    `sizeof` operator for our types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running this code using Clang 10.0 with libc++ generates the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the size of the `VariantType` is the sum of `std::string` and
    `std::size_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Exception safety of std::variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a new value is assigned to a `std::variant` object, it is placed in the
    same location as the currently held value of the variant. If, for some reason,
    the construction or assignment of the new value fails and throws an exception,
    the old value may not be restored. Instead, the variant can become **valueless**.
    You can check whether a variant object is valueless by using the member function
    `valueless_by_exception()`. This can be demonstrated when trying to construct
    an object using the `emplace()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The initial `double` value 1.0 may or may not be gone after the exception has
    been thrown and caught. The operation is not guaranteed to be rolled back, which
    we usually can expect from standard library containers. In other words, `std::variant`
    doesn't provide a strong exception safety guarantee, and the reason for this is
    performance overhead since it would require `std::variant` to use heap allocations.
    This behavior of `std::variant` is a useful feature rather than a shortcoming,
    because it means that you can safely use `std::variant` in code with real-time
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If you instead want a heap allocating version but with a strong exception safety
    guarantee and a "never-empty" guarantee, `boost::variant` offers this functionality.
    If you are interested in the challenges of implementing such a type, [https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html](https://www.boost.org/doc/libs/1_74_0/doc/html/variant/design.html)
    offers an interesting read.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When accessing variables in the `std::variant`, we use the global function
    `std::visit()`. As you might have guessed, we have to use our main companion when
    dealing with heterogeneous types: the generic lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When invoking `std::visit()` with the generic lambda and the variant `var`
    in the example, the compiler will conceptually transform the lambda into a regular
    class with `operator()` overloads for every type in the variant. This will look
    something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `std::visit()` function is then expanded to an `if...else` chain using `std::holds_alternative<T>()`,
    or a jump table using the index of the `std::variant`, to generate the correct
    call to `std::get<T>()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we passed the value in our generic lambda directly
    to `std::cout`, regardless of the currently held alternative. But what if we want
    to do different things, depending on what type we are visiting? A pattern that
    may be used for this situation is to define a variadic class template that will
    inherit from a set of lambdas. We then need to define this for each type that
    we are visiting. Sounds complicated, doesn't it? This may seem a bit magic at
    first and also puts our metaprogramming skills to the test, but once we have the
    variadic class template in place, it's easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the variadic class template. Here is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are on a C++17 compiler you also need to add an explicit deduction guide,
    but it''s not needed as of C++20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. The template class `Overloaded` will inherit from all lambdas that
    we will instantiate the template with, and the function call operator, `operator()()`,
    will be overloaded once by each lambda. It''s now possible to create a stateless
    object that only contains multiple overloads of the call operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it using different arguments and verify that the correct overload
    is being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this with `std::visit()` and without the need of having the
    `Overloaded` object stored in an lvalue. Here is how it finally looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: So, once we have the `Overloaded` template in place, we can use this convenient
    way of specifying a set of lambdas for different types of arguments. In the next
    section, we will start using `std::variant` together with standard containers.
  prefs: []
  type: TYPE_NORMAL
- en: Heterogenous collections using variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a variant that can store any type of a provided list, we can
    expand upon this to a heterogeneous collection. We do this by simply creating
    a `std::vector` of our variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now push elements of different types to our vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The vector will now look like this in memory, where every element in the vector
    contains the size of the variant, which in this case is `sizeof(std::size_t) +
    sizeof(std::string)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15619_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Vector of variants'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can also `pop_back()` or modify the container in any other way
    the container allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the values in our variant container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the boilerplate for a heterogeneous collection that''s dynamic
    in size, let''s see how we can use it like a regular `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construct a heterogeneous container of variants**: Here, we construct a `std::vector`
    with different types. Note that the initializer list contains different types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Print the content by iterating with a regular for-loop**: To iterate the
    container with a regular `for`-loop, we utilize `std::visit()` and a generic lambda.
    The global function `std::visit()` takes care of the type conversion. The example
    prints each value to `std::cout`, independent of the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Inspect what types are in the container**: Here, we inspect each element
    of the container by type. This is achieved by using the global function `std::holds_alternative<type>`,
    which returns `true` if the variant currently holds the type asked for. The following
    example counts the number of Booleans currently contained in the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Find content by both contained type and value**: In this example, we''re
    inspecting the container both for type and value by combining `std::holds_alternative()`
    and `std::get()`. This example checks whether the container contains a `std::string`
    with the value `"needle"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Global function std::get()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The global function template `std::get()` can be used for `std::tuple`, `std::pair`,
    `std::variant`, and `std::array`. There are two ways to instantiate `std::get()`,
    with an index or with a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::get<Index>()`: When `std::get()` is used with an index, as in `std::get<1>(v)`,
    it returns the value at the corresponding index in a `std::tuple`, `std::pair`,
    or `std::array`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::get<Type>()`: When `std::get()` is used with a type, as in `std::get<int>(v)`,
    the corresponding value in a `std::tuple`, `std::pair` or `std::variant` is returned.
    In the case of `std::variant`, a `std::bad_variant_access` exception is thrown
    if the variant doesn''t currently hold that type. Note that if `v` is a `std::tuple`
    and `Type` is contained more than once, you have to use the index to access the
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having discussed the essential templates from the Utility library, let's look
    at some real-world applications of what we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Some real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will end this chapter by examining two examples where `std::tuple`, `std::tie()`,
    and some template metaprogramming can help us to write clean and efficient code
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: projections and comparison operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The need to implement comparison operators for classes dramatically decreased
    with C++20, but there are still cases where we need to provide a custom comparison
    function when we want to sort objects in some custom order for a specific scenario.
    Consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Say that we want to sort the players by their attributes: the primary sort
    order `level_` and the secondary sort order `score_`. It''s not uncommon to see
    code like this when implementing comparison and sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Writing comparison operators in this style using nested `if-else` blocks quickly
    becomes error-prone when the number of attributes increases. What we really want
    to express is that we are comparing a *projection* of `Player` attributes (in
    this case, a strict subset). The `std::tuple` can help us rewrite this code in
    a cleaner way without the need for `if-else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `std::tie()`, which creates a `std::tuple` holding references to
    the lvalues we pass to it. The following code creates two projections, `p1` and
    `p2`, and compares them using the `<` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is very clean and easy to read compared to the initial version using `if-else`
    statements. But is this really efficient? It seems like we need to create temporary
    objects just to compare two players. When running this in a microbenchmark and
    also inspecting the generated code, there is really no overhead at all to using
    `std::tie()`; in fact, the version using `std::tie()` was, in this example, slightly
    faster than the version using `if-else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the ranges algorithms, we can do the sorting by providing the projection
    as an argument to `std::ranges::sort()`, which makes the code even cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of how `std::tuple` can be used in contexts where a full
    struct with named members is not needed, without sacrificing any clarity in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: reflection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **reflection** refers to the ability to inspect a class without knowing
    anything about its contents. In contrast to many other programming languages,
    C++ does not have built-in reflection, which means we have to write the reflection
    functionality ourselves. Reflection is planned to be included in future versions
    of the C++ standard; hopefully, we will see this feature in C++23.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to limit the reflection to give classes the ability
    to iterate their members, just like we can iterate the members of a tuple. By
    using reflection, we can create generic functions for serialization or logging
    that automatically work with any class. This reduces large amounts of boilerplate
    code, which is traditionally required for classes in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Making a class reflect its members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we need to implement all the reflection functionality ourselves, we will
    start by exposing the member variables via a function called `reflect()`. We will
    continue to use the `Player` class that was introduced in the previous section.
    Here is how it looks when we add the `reflect()` member function and a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `reflect()` member function returns a tuple of references to the member
    variables by invoking `std::tie()`. We can now start using the `reflect()` function,
    but first, a note about alternatives to using handcrafted reflection.
  prefs: []
  type: TYPE_NORMAL
- en: C++ libraries that simplify reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There have been quite a few attempts in the C++ library world to simplify the
    creation of reflection. One example is the metaprogramming library *Boost Hana*
    by Louis Dionne, which gives classes reflection capabilities via a simple macro.
    Recently, *Boost* has also added *Precise and Flat Reflection* by Anthony Polukhin,
    which *automatically* reflects public content of classes, as long as all members
    are simple types.
  prefs: []
  type: TYPE_NORMAL
- en: However, for clarity, in this example, we will only use our own `reflect()`
    member function.
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the `Player` class has the ability to reflect its member variables,
    we can automate the creation of bulk functionality, which would otherwise require
    us to retype every member variable. As you may already know, C++ automatically
    can generate constructors, destructors, and comparison operators, but other operators
    must be implemented by the programmer. One such function is the `operator<<()`,
    which outputs its contents to a stream in order to store them in a file, or more
    commonly, log them in an application log.
  prefs: []
  type: TYPE_NORMAL
- en: 'By overloading `operator<<()` and using the `tuple_for_each()` function template
    we implemented earlier in this chapter, we can simplify the creation of `std::ostream`
    output for a class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the class can be used with any `std::ostream` type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: By reflecting our class members via a tuple, we only have to update our reflect
    function when members are added/removed from our class, instead of updating every
    function and iterating all member variables.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally overloading global functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a mechanism to write bulk functions using reflection rather
    than manually typing each variable, we still need to type the simplified bulk
    functions for every type. What if we wanted these functions to be generated for
    every type that can be reflected?
  prefs: []
  type: TYPE_NORMAL
- en: We can conditionally enable `operator<<()` for all classes that have a `reflect()`
    member function by using a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new concept that refers to the `reflect()` member
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this concept only checks whether a class has a member function named
    `reflect()`; it doesn''t always return a tuple. In general, we should be skeptical
    about weak concepts that only use a single member function like this, but it serves
    the purpose of the example. Anyway, we can now overload `operator<<()` in the
    global namespace, giving all reflectable classes the ability to be compared and
    printed to a `std::ostream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function template will only be instantiated for types that contain
    the `reflect()` member function, and will therefore not collide with any other
    overload.
  prefs: []
  type: TYPE_NORMAL
- en: Testing reflection capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we have everything in place:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` class we will test has a `reflect()` member function returning
    a tuple of references to its members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global `std::ostream& operator<<()` is overloaded for reflectable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple test that verifies this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: These examples have demonstrated the usefulness of small but essential utilities
    such as `std::tie()` and `std::tuple` when combined with a little bit of metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you have learned how to use `std::optional` to represent optional
    values in your code. You have also seen how to combine `std::pair`, `std::tuple`,
    `std::any`, and `std::variant` together with standard containers and metaprogramming
    to store and iterate over elements of different types. You also learned that `std::tie()`
    is a conceptually simple yet powerful tool that can be used for projection and
    reflection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will find out how to further expand your C++ toolbox
    to create libraries by learning how to construct hidden proxy objects.
  prefs: []
  type: TYPE_NORMAL
