- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-Functional Requirements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have gathered the system requirements, it is time to think about the
    impact they have on the architectural design. Scalability, availability, resiliency,
    performance, multithreading, interoperability, security, and other subjects need
    to be analyzed so that we can meet user needs. We refer to these aspects as non-functional
    requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How do .NET 5 and Azure enable scalability, availability, and resiliency?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance issues that need to be considered when programming in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software usability, that is, how to design effective user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 5 and interoperability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving security by design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book use case – understanding the main types of .NET Core projects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples provided in this chapter will require Visual Studio 2019 Community
    Edition with .NET 5 SDK installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Enabling scalability, availability, and resiliency with Azure and .NET 5
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A short search on scalability returns a definition such as *the ability of a
    system to keep working well when there is an increase in demand*. Once developers
    read this, many of them incorrectly conclude *that scalability only means adding
    more hardware to keep things working without stopping the app*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Scalability relies on technologies involving hardware solutions. However, as
    a software architect, you must be aware that good software will keep scalability
    in a sustainable model, which means that a well-architected software can save
    a lot of money. Hence, it is not just a matter of hardware but also a matter of
    overall software design. The point here is that the running cost of a system should
    also be a factor in the architectural decisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Understanding the Importance of Software Architecture*, while
    discussing software performance, we proposed some good tips to overcome bad performance
    issues. The same tips will help you with scalability too. The fewer resources
    we spend on each process, the more users the application can handle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Although scalability is important, cloud computing applications must be designed
    to work with system failures. Every time you guarantee that your application recovers
    from a failure without exposing this failure to the end user, you are creating
    a resilient application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: You may find cloud architecture resiliency patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The reason why resiliency is especially important in cloud scenarios is because
    the infrastructure provided to you may need a small amount of time to manage updates,
    resets, and even hardware upgrades. You are also more likely to be working with
    multiple systems, and transient errors are likely to occur in communicating with
    them. That is why this non-functional requirement started to be spread in recent
    years.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of having scalable and resilient solutions gets more exciting
    when you can enable high availability in the system. All the approaches presented
    in this book will guide you to design solutions with good availability, but in
    some cases, you will need to design specific alternatives to achieve the goal
    you have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: You may find cloud architecture availability patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: It is worth knowing that Azure and .NET 5 web apps can be configured to achieve
    these non-functional requirements. Let us check this out in the following subsections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app in Azure
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is simple to create a web app in Azure, ready for scaling. The reason why
    you must do so is to be able to maintain different numbers of users during different
    seasons. The more users you have, the more hardware you will need. Let us show
    you how to create a scalable web application in Azure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you log in to your Azure account, you will be able to create a new
    resource (web app, database, virtual machine, and so on), as you can see in the
    following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Microsoft Azure – Create a resource'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can select **Web App** in the **Popular Options**, or even
    type it into the **Search the Marketplace** textbox. This action will take you
    to the following screen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Microsoft Azure – Creating a web app'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The required **Project Details** are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription**: This is the account that will be charged for all application
    costs.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Group**: This is the collection of resources you can define to organize
    policies and permissions. You may specify a new resource group name or add the
    web app to a group specified during the definition of other resources.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these, the **Instance Details** are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: As you can see, the web app name is the URL that your solution will
    assume after its creation. The name is checked to ensure it is available.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish**: This parameter indicates whether the web app will be delivered
    directly or whether it is going to use Docker technology to publish content. Docker
    will be discussed in more detail in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*. If you opt for the Docker Container publication,
    you will be able to configure the **Image Source**, **Access Type**, and **Image**
    and tag information to have it deployed to the web app.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime stack**: This option is obviously only available when you decide
    to deliver code directly. At the time this chapter was written, you could define
    stacks for .NET Core, ASP.NET, Java 11, Java 8, Node, PHP, Python, and Ruby.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating System**: This is the option for defining the OS that will host
    the web app. Both Windows and Linux may be used for ASP.NET Core projects.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region**: You may consider where you want to deploy your application, considering
    Azure has many different data centers all over the world.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Service Plan**: This is where you define the hardware plan that is used
    to handle the web app and the region of the servers. This choice defines application
    scalability, performance, and costs.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: This is a useful Azure toolset for monitoring and troubleshooting
    web apps. In this section, you will be able to enable Application Insights. It
    is always recommended that you keep the same regions for different components
    of your solution, since this will save costs in terms of traffic exchange from
    one data center to another.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have created your web app, this application may be scaled in two conceptually
    different ways: Vertically **(Scale up)** and Horizontally **(Scale out)**. Both
    are available in the web app settings, as you can see in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Scaling options of web apps'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Let us check out the two types of scaling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling (Scaling up)
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scaling up means changing the specification of hardware that will host your
    application. In Azure, you have the opportunity of starting with free, shared
    hardware and moving to an isolated machine in a few clicks. The following screenshot
    shows the user interface for scaling up a web app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Vertical scaling options'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: By choosing one of the options provided, you can select more powerful hardware
    (machines with more CPUs, storage, and RAM). Monitoring your application and its
    App Service plan will guide you on how to decide the best infrastructure for running
    the solution you are proving. It will also offer key insights, such as possible
    CPU, memory, and I/O bottlenecks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling (Scaling out)
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scaling out means splitting all requests among more servers with the same capacity
    instead of using more powerful machines. The load on all the servers is automatically
    balanced by the Azure infrastructure. This solution is advised when the overall
    load may change considerably in the future since horizontal scaling can be automatically
    adapted to the current load. The following screenshot shows an automatic **Scale
    out** strategy defined by two simple rules, which is triggered by CPU usage:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Horizontal scaling sample'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: It is worth highlighting that you can choose to have a hardcoded instance count
    or implement rules for automatic scale in/out.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of all the available auto-scale rules is beyond the purpose
    of this book. However, they are quite self-explanatory, and the *Further reading*
    section contains links to the full documentation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The *Scale out* feature is only available in paid service plans.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In general, horizontal scaling is a way to guarantee availability in the application
    even with a number of simultaneous accesses. For sure, its use is not the only
    way to keep a system available, but it will definitely help.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scalable web app with .NET 5
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among all the available frameworks for implementing web apps, running it with
    ASP.NET Core 5 ensures good performance, together with low production and maintenance
    costs. The union of C#, a strongly typed and advanced general-purpose language,
    and continuous performance improvements achieved in the framework, mark this option
    out in recent years as one of the best for enterprise development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The steps that follow will guide you through the creation of an ASP.NET Core
    Runtime 5-based web app. All the steps are quite simple, but some details require
    attention.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that .NET 5 brings the opportunity to develop to any
    platform – Desktops (WPF, Windows Forms, and UWP), Web (ASP.NET), Cloud (Azure),
    Mobile (Xamarin), Gaming (Unity), IoT (ARM32 and ARM64), and AI (ML.NET and .NET
    for Apache Spark). So, the recommendation from now on is to only use .NET 5\.
    In this scenario, you can run your web app on both Windows and cheaper Linux servers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Microsoft recommends classic .NET, just in case the features you
    need are not available in .NET Core, or even when you deploy your web app in an
    environment that does not support .NET Core. In any other case, you should prefer
    .NET Core Framework because it allows you to do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Run your web app in Windows, Linux, macOS, or Docker containers
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your solution with microservices
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have high performance and scalable systems
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and microservices will be covered in *Chapter 5*, *Applying a Microservice
    Architecture to Your Enterprise Application*. There, you will get a better understanding
    of the advantages of these technologies. For now, it is enough to say that .NET
    5 and microservices were designed for performance and scalability, which is why
    you should prefer .NET 5 in all your new projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The following procedure will show you how to create an ASP.NET Core web app
    in Visual Studio 2019 with .NET 5:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you start VS 2019, you will be able to click on **Create a new project**.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you select **ASP.NET Core Web Application**, you will be directed to a
    screen where you will be asked to set up the **Project name**, **Location**, and
    **Solution name**:![](img/B16756_02_06.png)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 2.6: Creating an ASP.NET Core web application'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will be able to select the .NET version to use. Select **ASP.NET
    Core 5.0** to get the most advanced and brand-new platform. For this demo, you
    can select the **Web Application** template.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，您将能够选择要使用的 .NET 版本。选择**ASP.NET Core 5.0**以获得最先进和全新的平台。对于此演示，您可以选择**Web 应用程序**模板。
- en: Now that we are done with adding the basic details, you can connect your web
    app project to your Azure account and have it published.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了基本细节，您可以将您的 Web 应用项目连接到您的 Azure 帐户并将其发布。
- en: If you right-click the project you created, in **Solution Explorer**, you have
    the option to **Publish**:![](img/B16756_02_07.png)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您右键单击您创建的项目，在**解决方案资源管理器**中，您将有**发布**选项：![](img/B16756_02_07.png)
- en: 'Figure 2.7: Publishing the ASP.NET Core web application'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：发布 ASP.NET Core Web 应用程序
- en: You will find different targets to publish your web app. Select **Azure** as
    the target.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将找到不同的目标来发布您的 Web 应用。选择**Azure**作为目标。
- en: Then, you will be able to decide the **Specific target** to publish. Select
    **Azure App Service (Windows)** for this demo.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，您将能够决定要发布的**具体目标**。为此演示选择**Azure App Service (Windows)**。
- en: You may be required to define your Microsoft Account credentials at this time.
    This is because there is full integration between Visual Studio and Azure. This
    gives you the opportunity to view all the resources you created in the Azure portal
    in your development environment:![](img/B16756_02_08.png)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时可能需要定义您的 Microsoft 帐户凭据。这是因为 Visual Studio 与 Azure 之间有完全集成。这使您有机会在开发环境中查看您在
    Azure 门户中创建的所有资源！[](img/B16756_02_08.png)
- en: 'Figure 2.8: Integration between Visual Studio and Azure'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：Visual Studio 与 Azure 的集成
- en: Once you have decided on your **Publish** settings, that is, the publish profile,
    the web app will be automatically published when you click **Publish**. Pay attention
    here to select the F1 tier of pricing so that this process does not incur any
    costs:![](img/B16756_02_09.png)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您决定了您的**发布**设置，也就是发布配置文件，当您点击**发布**时，Web 应用将会自动发布。请注意在这里选择 F1 定价层，以便此过程不会产生任何费用：![](img/B16756_02_09.png)
- en: 'Figure 2.9: Publish profile options'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：发布配置文件选项
- en: You have currently two modes for deployment. The first, Framework-dependent,
    will require a web app configured with the target framework. The second, self-contained,
    will no longer need this feature since the binaries of the framework will be published
    together with the application.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您目前有两种部署模式。第一种是 Framework-dependent，将需要配置目标框架的 Web 应用。第二种是 self-contained，将不再需要此功能，因为框架的二进制文件将与应用程序一起发布。
- en: It is worth mentioning that in order to publish ASP.NET Preview versions in
    Framework-dependent mode, you must add an extension in the web app setup panel
    in Azure Portal, as shown in the following screenshot. However, consider using
    the self-contained mode, especially when you are under preview versions:![](img/B16756_02_10.png)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一提的是，为了以 Framework-dependent 模式发布 ASP.NET 预览版本，您必须在 Azure 门户中的 Web 应用设置面板中添加一个扩展，如下截图所示。但是，在预览版本下，考虑使用自包含模式！[](img/B16756_02_10.png)
- en: 'Figure 2.10: Adding extensions in Azure Web App Service'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：在 Azure Web 应用服务中添加扩展
- en: 'For more information on deploying ASP.NET Core 5.0 to Azure App Service, please
    refer to the following link: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=vi).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将 ASP.NET Core 5.0 部署到 Azure App Service 的更多信息，请参阅以下链接：[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/?view=aspnetcore-5.0&tabs=vi)。
- en: Here, we described the simplest way to deploy a web app. In *Chapter 20*, *Understanding
    DevOps Principles* and *Chapter 21*, *Challenges of Applying CI Scenarios*, we
    will introduce you to the Azure DevOps **Continuous Integration/Continuous Delivery**
    (**CI/CD**) pipeline. This pipeline is a further Azure toolset that automates
    all the required steps to get the application in production, that is, building,
    testing, deployment in staging, and deployment in production.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们描述了部署 Web 应用的最简单方法。在*第 20 章*，*理解 DevOps 原则*和*第 21 章*，*应用 CI 场景的挑战*中，我们将向您介绍
    Azure DevOps **持续集成/持续交付**（**CI/CD**）管道。这个管道是一个进一步的 Azure 工具集，它自动化了将应用程序投入生产所需的所有步骤，即构建、测试、部署到暂存区和部署到生产环境。
- en: Performance issues that need to be considered when programming in C#
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 编程中需要考虑的性能问题
- en: Nowadays, C# is one of the most commonly used programming languages all over
    the world, so good tips about C# programming are fundamental for the design of
    good architectures that satisfy the most common non-functional requirements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，C# 是全球最常用的编程语言之一，因此关于 C# 编程的良好建议对于设计满足最常见非功能性需求的良好架构至关重要。
- en: The following sections mention a few simple but effective tips – the associated
    code samples are available in the GitHub repository of this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提到了一些简单但有效的提示-相关的代码示例可在本书的 GitHub 存储库中找到。
- en: String concatenation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: This is a classic one! A naive concatenation of strings with the `+` string
    operator may cause serious performance issues since each time two strings are
    concatenated, their contents are copied into a new string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的例子！使用`+`字符串运算符天真地连接字符串可能会导致严重的性能问题，因为每次连接两个字符串时，它们的内容都会被复制到一个新的字符串中。
- en: So, if we concatenate, for instance, 10 strings that have an average length
    of 100, the first operation has a cost of 200, the second one has a cost of *200+100=300*,
    the third one has a cost of *300+100=400*, and so on. It is not difficult to convince
    yourself that the overall cost grows like *m***n*², where *n* is the number of
    strings and *m* is their average length. *n*² is not too big for small *n* (say,
    *n* < 10), but it becomes quite big when *n* reaches the magnitude of 100-1,000,
    and unacceptable for magnitudes of 10,000-100,000.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们连接，例如，平均长度为100的10个字符串，第一个操作的成本为200，第二个操作的成本为*200+100=300*，第三个操作的成本为*300+100=400*，依此类推。很容易让你相信总体成本增长像*m***n*²，其中*n*是字符串的数量，*m*是它们的平均长度。*n*²对于小*n*（比如，*n*
    < 10）来说并不算太大，但当*n*达到100-1,000数量级时，它就变得相当大，当*n*达到10,000-100,000数量级时就变得不可接受。
- en: 'Let us look at this with some test code, which compares naive concatenation
    with the same operation that is performed with the help of the `StringBuilder`
    class (the code is available in this book''s GitHub repository):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些测试代码来看看这个问题，比较天真的连接和使用`StringBuilder`类执行相同操作的代码（该代码可在本书的GitHub存储库中找到）：
- en: '![](img/B16756_02_11.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_11.png)'
- en: 'Figure 2.11: Concatenation test code result'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：连接测试代码结果
- en: If you create a `StringBuilder` class with something like `var sb =new System.Text.StringBuilder()`,
    and then you add each string to it with `sb.Append(currString)`, the strings are
    not copied; instead, their pointers are queued in a list. They are copied in the
    final string just once, when you call `sb.ToString()` to get the final result.
    Accordingly, the cost of `StringBuilder-`based concatenation grows simply as *m*n*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个类似`var sb =new System.Text.StringBuilder()`的`StringBuilder`类，然后用`sb.Append(currString)`将每个字符串添加到其中，那么字符串不会被复制；相反，它们的指针会排队在一个列表中。它们只在你调用`sb.ToString()`获取最终结果时被复制到最终字符串中。因此，基于`StringBuilder`的连接成本简单地增长为*m*n*。
- en: Of course, you will probably never find a piece of software with a function
    like the preceding one that concatenates 100,000 strings. However, you need to
    recognize pieces of code similar to these ones where the concatenation of some
    20-100 strings, say, in a web server that handles several requests simultaneously,
    might cause bottlenecks that damage your non-functional requirements for performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能永远不会找到一个像前面那个连接100,000个字符串的函数的软件片段。然而，你需要识别类似这些的代码片段，比如在同时处理多个请求的Web服务器中连接20-100个字符串可能会导致损害性能的瓶颈。
- en: Exceptions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Always remember that exceptions are much slower than normal code flow! So, the
    usage of `try-catch` needs to be concise and essential, otherwise, you will create
    big performance issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 永远记住，异常比正常代码流慢得多！因此，使用`try-catch`需要简洁和必要，否则，你将会创建大的性能问题。
- en: 'The following two samples compare the usage of `try-catch` and `Int32.TryParse`
    to check whether a string can be converted into an integer, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例比较了使用`try-catch`和`Int32.TryParse`来检查字符串是否可以转换为整数：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second function does not look dangerous, but it is thousands of times slower
    than the first one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数看起来并不危险，但比第一个函数慢上千倍：
- en: '![](img/B16756_02_12.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_02_12.png)'
- en: 'Figure 2.12: Exception test code result'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：异常测试代码结果
- en: To sum this up, exceptions must be used to deal with exceptional cases that
    break the normal flow of control, for instance, situations when operations must
    be aborted for some unexpected reasons, and control must be returned several levels
    up in the call stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，异常必须用于处理打破正常控制流的异常情况，例如，操作必须因某些意外原因而中止，控制必须返回调用堆栈中的几个级别。
- en: Multithreading environments for better results – dos and don'ts
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的多线程环境-做和不做
- en: If you want to take advantage of all the hardware that the system you are building
    provides, you must use multithreading. This way, when a thread is waiting for
    an operation to complete, the application can leave the CPU to other threads,
    instead of wasting CPU time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想充分利用正在构建的系统提供的所有硬件，你必须使用多线程。这样，当一个线程在等待操作完成时，应用程序可以将CPU留给其他线程，而不是浪费CPU时间。
- en: 'On the other hand, no matter how hard Microsoft is working to help with this,
    parallel code is not as simple as eating a piece of cake: it is error-prone and
    difficult to test and debug. The most important thing to remember as a software
    architect when you start considering using threads is *does your system require
    them?* Non-functional and some functional requirements will answer this question
    for you.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无论微软如何努力帮助解决这个问题，并行代码都不像吃蛋糕那样简单：它容易出错，难以测试和调试。当你开始考虑使用线程时，作为软件架构师最重要的事情是*你的系统是否需要它们？*非功能性和一些功能性需求会为你解答这个问题。
- en: 'As soon as you are sure that you need a multithreading system, you should decide
    on which technology is more adequate. There are a few options here, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定需要一个多线程系统，你应该决定哪种技术更合适。这里有几个选项，如下：
- en: '**Creating an instance of** `System.Threading.Thread`: This is a classic way
    of creating threads in C#. The entire thread life cycle will be in your hands.
    This is good when you are sure about what you are going to do, but you need to
    worry about every single detail of the implementation. The resulting code is hard
    to conceive and debug/test/maintain. So, to keep development costs acceptable,
    this approach should be confined to a few fundamental, performance critical modules.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建** `System.Threading.Thread`的实例：这是在C#中创建线程的经典方式。整个线程生命周期将由你掌控。当你确定自己要做什么时，这是很好的，但你需要担心实现的每一个细节。结果代码很难构思和调试/测试/维护。因此，为了保持开发成本可接受，这种方法应该局限于一些基本的、性能关键的模块。'
- en: '**Programming using** `System.Threading.Tasks.Parallel` **classes**: Since
    .NET Framework 4.0, you can use parallel classes to enable threads in a simpler
    way. This is good because you do not need to worry about the life cycle of the
    threads you create, but it will give you less control about what is happening
    in each thread.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `System.Threading.Tasks.Parallel` **类进行编程**：自.NET Framework 4.0以来，您可以使用并行类以更简单的方式启用线程。这很好，因为您不需要担心创建的线程的生命周期，但这将使您对每个线程中发生的事情控制更少。'
- en: '**Develop using asynchronous programming**: This is, for sure, the easiest
    way to develop multithreaded applications since the compiler takes on most of
    the work. Depending on the way you call an asynchronous method, you may have the
    `Task` created running in parallel with the `Thread` that was used to call it
    or even have this `Thread` waiting without suspending for the task created to
    conclude. This way, asynchronous code mimics the behavior of classical synchronous
    code while keeping most of the performance advantages of general parallel programming:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用异步编程进行开发**：这无疑是开发多线程应用程序的最简单方式，因为编译器承担了大部分工作。根据您调用异步方法的方式，您可能会创建的`Task`与用于调用它的`Thread`并行运行，甚至可能会有这个`Thread`等待而不挂起，直到创建的任务结束。这样，异步代码模仿了经典同步代码的行为，同时保留了一般并行编程的大部分性能优势：'
- en: The overall behavior is deterministic and does not depend on the time taken
    by each task to complete, so non-reproducible bugs are more difficult to happen,
    and the resulting code is easy to test/debug/maintain. Defining a method as an
    asynchronous task or not is the only choice left to the programmer; everything
    else is automatically handled by the runtime. The only thing you should be concerned
    about is which methods should have asynchronous behavior. It is worth mentioning
    that defining a method as `async` does not mean it will execute on a separate
    thread. You may find useful information in a great sample at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体行为是确定性的，不取决于每个任务完成所花费的时间，因此不可重现的错误更难发生，生成的代码易于测试/调试/维护。将方法定义为异步任务与否是程序员留下的唯一选择；其他一切都由运行时自动处理。您唯一需要关注的是哪些方法应该具有异步行为。值得一提的是，将方法定义为`async`并不意味着它将在单独的线程上执行。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)上找到有用的信息。
- en: Later in this book, we will provide some simple examples of asynchronous programming.
    For more information about asynchronous programming and its related patterns,
    please check *Task-Based Asynchronous Patterns* in the Microsoft documentation
    ([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynch)).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将提供一些异步编程的简单示例。有关异步编程及其相关模式的更多信息，请查看Microsoft文档中的*基于任务的异步模式*([https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynch))。
- en: 'No matter the option you choose, there are some dos and don''ts that, as a
    software architect, you must pay attention to. These are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个选项，作为软件架构师，您都必须注意一些要点和禁忌。具体如下：
- en: '**Do use concurrent collections** (`System.Collections.Concurrent`): As soon
    as you start a multithreading application, you have to use these collections.
    The reason for this is that your program will probably manage the same list, dictionary,
    and so on from different threads. The use of concurrent collections is the most
    convenient option for developing thread-safe programs.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并发集合**(`System.Collections.Concurrent`)：一旦启动多线程应用程序，您就必须使用这些集合。原因是您的程序可能会从不同的线程管理相同的列表、字典等。使用并发集合是开发线程安全程序的最方便选项。'
- en: '**Do worry about static variables**: It is not possible to say that static
    variables are prohibited in multithreading development, but you should pay attention
    to them. Again, multiple threads taking care of the same variable can cause a
    lot of trouble. If you decorate a static variable with the `[ThreadStatic]` attribute,
    each thread will see a different copy of that variable, hence solving the problem
    of several threads competing on the same value. However, `ThreadStatic` variables
    cannot be used for extra-thread communications since values written by a thread
    cannot be read by other threads. In asynchronous programming, `AsyncLocal<T>`
    is the option for doing something like that.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**担心静态变量**：无法说静态变量在多线程开发中是被禁止的，但您应该注意它们。同样，多个线程处理相同的变量可能会引起很多麻烦。如果您使用`[ThreadStatic]`属性修饰静态变量，每个线程将看到该变量的不同副本，从而解决了多个线程竞争相同值的问题。然而，`ThreadStatic`变量不能用于额外的线程通信，因为一个线程写入的值不能被其他线程读取。在异步编程中，`AsyncLocal<T>`是执行类似操作的选项。'
- en: '**Do test system performance after multithreading implementations**: Threads
    give you the ability to take full advantage of your hardware, but in some cases,
    badly written threads can waste CPU time just doing nothing! Similar situations
    may result in almost 100% CPU usage and unacceptable system slowdowns. In some
    cases, the problem can be mitigated or solved by adding a simple `Thread.Sleep(1)`
    call in the main loop of some threads to prevent them from wasting too much CPU
    time, but you need to test this. A use case for this implementation is a Windows
    Service with many threads running in its background.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程实现后测试系统性能：线程使您能够充分利用硬件，但在某些情况下，编写不良的线程可能会浪费CPU时间，什么也不做！类似的情况可能导致几乎100%的CPU使用率和不可接受的系统减速。在某些情况下，可以通过在一些线程的主循环中添加简单的`Thread.Sleep(1)`调用来减轻或解决问题，以防止它们浪费太多CPU时间，但您需要测试这一点。这种实现的一个用例是在其后台运行许多线程的Windows服务。
- en: '**Do not consider multithreading easy**: Multithreading is not as simple as
    it seems in some syntax implementations. While writing a multithreading application,
    you should consider things such as the synchronization of the user interface,
    threading termination, and coordination. In many cases, programs just stop working
    well due to a bad implementation of multithreading.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要认为多线程很容易：多线程并不像在某些语法实现中看起来那么简单。在编写多线程应用程序时，你应该考虑诸如用户界面同步、线程终止和协调等问题。在许多情况下，由于多线程的糟糕实现，程序会停止正常工作。
- en: '**Do not forget to plan the number of threads your system should have**: This
    is important especially for 32-bit programs. There is a limitation regarding how
    many threads you can have in any environment. You should consider this when you
    are designing your system.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记规划系统应该有多少线程：这对于32位程序尤其重要。在任何环境中，你可以拥有多少线程都有限制。在设计系统时，你应该考虑这一点。
- en: '**Do not forget to end your threads**: If you do not have the correct termination
    procedure for each thread, you will probably have trouble with memory and handling
    leaks.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记结束你的线程：如果你没有为每个线程正确的终止程序，你可能会在内存和处理泄漏方面遇到麻烦。
- en: Usability – why inserting data takes too much time
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性-为什么插入数据需要太长时间
- en: Scalability, performance tips, and multithreading are the main tools we can
    use to tune machine performance. However, the effectiveness of the system you
    design depends on the overall performance of the whole processing pipeline, which
    includes both humans and machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性、性能提示和多线程是我们可以用来调整机器性能的主要工具。然而，你设计的系统的有效性取决于整个处理流水线的整体性能，其中包括人和机器。
- en: 'As a software architect, you cannot improve the performance of humans, but
    you can improve the performance of man-machine interaction by designing an effective
    **user interface** (**UI**), that is, a user interface that ensures fast interaction
    with humans, which, in turn, means the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你无法提高人类的表现，但你可以通过设计一个有效的用户界面（UI）来提高人机交互的表现，这意味着以下内容：
- en: The UI must be easy to learn in order to reduce the time that is needed for
    learning and time wasting before the target users learn to operate it quickly.
    This constraint is fundamental if UI changes are frequent, and for public websites
    that need to attract the greatest possible number of users.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI必须易于学习，以减少学习所需的时间和目标用户快速操作之前的时间浪费。如果UI更改频繁，并且需要吸引尽可能多的用户的公共网站，这一约束是基本的。
- en: The UI must not cause any kind of slowdown in data insertion; data entry speed
    must be limited only by the user's ability to type, not by system delays or by
    additional gestures that could be avoided.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI不得在数据插入中引起任何类型的减速；数据输入速度必须仅受用户输入能力的限制，而不受系统延迟或可以避免的额外手势的限制。
- en: 'It is worth mentioning that we have UX experts in the market. As a software
    architect, you must decide when they are essential to the success of the project.
    The following are a few simple tips when it comes to designing *easy to learn*
    user interfaces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，市场上有UX专家。作为软件架构师，你必须决定他们对项目成功至关重要的时候。以下是在设计易于学习的用户界面时的一些建议：
- en: Each input screen must state its purpose clearly.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个输入屏幕必须清楚地说明其目的。
- en: Use the language of the user, not the language of developers.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户的语言，而不是开发者的语言。
- en: Avoid complications. Design the UI with the average case in mind; more complicated
    cases can be handled with extra inputs that appear only when needed. Split complex
    screens into more input steps.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂化。设计UI时要考虑一般情况；更复杂的情况可以通过只在需要时出现的额外输入来处理。将复杂的屏幕分割成更多的输入步骤。
- en: Use past inputs to understand user intentions and to put users on the right
    paths with messages and automatic UI changes; for instance, cascading drop-down
    menus.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过去的输入来理解用户意图，并通过消息和自动UI更改将用户引导到正确的路径；例如，级联下拉菜单。
- en: Error messages are not bad notes the system gives to the user, but they must
    explain how to insert correct input.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息不是系统给用户的坏笔记，而是必须解释如何插入正确输入的消息。
- en: 'Fast user interfaces result from efficacious solutions to the following three
    requirements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的用户界面是通过对以下三个要求的有效解决方案实现的：
- en: Input fields must be placed in the order they are usually filled, and it should
    be possible to move to the next input with the Tab or Enter key. Moreover, fields
    that often remain empty should be placed at the bottom of the form. Simply put,
    the usage of the mouse while filling a form should be minimized. This way, the
    number of user gestures is kept to a minimum. In a web application, once the optimal
    placement of input fields has been decided, it is enough to use the `tabindex`
    attribute to define the right way users move from one input field to the next
    with the Tab key.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段必须按照通常填写的顺序放置，并且应该可以使用Tab键或Enter键移动到下一个输入。此外，通常保持为空的字段应该放在表单的底部。简而言之，在填写表单时应尽量减少使用鼠标。这样，用户手势的数量就会被最小化。在Web应用程序中，一旦确定了输入字段的最佳放置位置，只需使用`tabindex`属性即可定义用户使用Tab键从一个输入字段移动到下一个输入字段的正确方式。
- en: System reactions to user inputs must be as fast as possible. Error messages
    (or information ones) must appear as soon as the user leaves the input field.
    The simplest way to achieve this is to move most of the help and input validation
    logic to the client side so that system reactions do not need to pass through
    both communication lines and servers.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统对用户输入的反应必须尽可能快。错误消息（或信息消息）必须在用户离开输入字段后立即出现。实现这一点的最简单方法是将大部分帮助和输入验证逻辑移至客户端，以便系统反应不需要通过通信线路和服务器。
- en: Efficacious selection logic. Selecting an existing item should be as easy as
    possible; for example, selecting one out of some thousands of products in an offer
    must be possible with a few gestures and with no need to remember the exact product
    name or its barcode. The next subsection analyzes techniques we can use to decrease
    complexity to achieve fast selection.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 16*, *Blazor WebAssembly*, we will discuss how this Microsoft technology
    can help us with the challenges of building web-based applications with C# code
    in the front-end.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Designing fast selection logic
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When all the possible choices are in the order of magnitude of 1-50, the usual
    drop-down menu is enough. For instance, this currency selection drop-down menu:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_13.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Simple drop-down menu'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'When the order of magnitude is higher but less than a few thousand, an autocomplete
    that shows the names of all the items that start with the characters typed by
    the user is usually a good choice:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_14.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Complex drop-down menu'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: A similar solution can be implemented with a low computational cost since all
    the main databases can efficiently select strings that start with a given substring.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: When names are quite complex, when searching for the characters that were typed
    in by the user, they should be extended inside each item string. This operation
    cannot be performed efficiently with usual databases and requires ad hoc data
    structures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we are searching inside descriptions composed of several words,
    more complex search patterns are needed. This is the case, for instance, with
    product descriptions. If the chosen database supports full-text search, the system
    can search for the occurrence of several words that have been typed by the user
    inside all the descriptions efficiently.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: However, when descriptions are made up of names instead of common words, it
    might be difficult for the user to remember a few exact names contained in the
    target description. This happens, for instance, with multi-country company names.
    In these cases, we need algorithms that find the best match for the character
    that was typed by the user. Substrings of the string that was typed by the user
    must be searched in different places of each description. In general, similar
    algorithms can't be implemented efficiently with databases based on indexes, but
    require all the descriptions to be loaded in memory and ranked somehow against
    the string that was typed by the user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The most famous algorithm in this class is probably the **Levenshtein** algorithm,
    which is used by most spell checkers to find a word that best fits the mistyped
    one by the user. This algorithm minimizes the Levenshtein distance between the
    description and the string typed by the user, that is, the minimum number of character
    removals and additions needed to transform one string into another.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The Levenshtein algorithm works great, but has a very high computational cost.
    Here, we give a faster algorithm that works well for searching character occurrences
    in descriptions. Characters typed by the user don''t need to occur consecutively
    in the description but must occur in the same order. Some characters may miss.
    Each description is given a penalty that depends on the missing characters and
    on how far the occurrences of the characters typed by the user are from the others.
    More specifically, the algorithm ranks each description with two numbers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of characters typed by the user that occurs in the description:
    the more characters contained in the description, the higher its rank.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each description is given a penalty equal to the total distance among the occurrences
    of the characters typed by the user in the description.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the word **Ireland** is ranked against the
    string **ilad**, which was typed by the user:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_15.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Sample of Levenshtein usage'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The number of occurrences is four (4), while the total distance between character
    occurrences is three (3).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the descriptions have been rated, they are sorted according to the
    number of occurrences. Descriptions with the same number of occurrences are sorted
    according to the lowest penalties. The following is an autocomplete that implements
    the preceding algorithm:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_16.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Levenshtein algorithm user interface experience'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The full class code, along with a test console project, is available in this
    book's GitHub repository.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from a huge number of items
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, *huge* does not refer to the amount of space needed to store the data,
    but to the difficulty the user has in remembering the features of each item. When
    an item must be selected from among more than 10,000-100,000 items, there is no
    hope of finding it by searching for character occurrences inside a description.
    Here, the user must be driven toward the right item through a hierarchy of categories.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In this case, several user gestures are needed to perform a single selection.
    In other words, each selection requires interaction with several input fields.
    Once it's decided that the selection can't be done with a single input field,
    the simplest option is cascading drop-down menus, that is, a chain of drop-down
    menus whose selection list depends on the values that were selected in the previous
    drop-down menus.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the user needs to select a town located anywhere in the world,
    we may use the first drop-down menu to select the country, and once the country
    has been chosen, we may use this choice to populate a second one with all the
    towns in the selected country. A simple example is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_17.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Cascading drop-down menu example'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, each drop-down menu can be replaced by an autocomplete when required
    due to having a high number of options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'If making the right selection can be done by intersecting several different
    hierarchies, cascading drop-down menus become inefficient too, and we need a filter
    form, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_18.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Filter form sample'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us understand interoperability with .NET Core.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The fantastic world of interoperability with .NET Core
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core brought Windows developers the ability to deliver their software into
    various platforms. And you, as a software architect, need to pay attention to
    this. Linux and macOS are no longer a problem for a C# lover – it is much better
    than that – they are great opportunities to deliver to new customers. Therefore,
    we need to ensure performance and multi-platform support, two common non-functional
    requirements in several systems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Both console applications and web apps designed with .NET Core in Windows are
    almost completely compatible with Linux and macOS, too. This means you do not
    have to build the app again to run it on these platforms. Also, very platform-specific
    behaviors now have multi-platform support, as shown, for instance, by the `System.IO.Ports.SerialPort`
    class, which, starting from .NET Core 3.0, is on Linux.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft offers scripts to help you install .NET Core on Linux and macOS. You
    can find them at [https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script](https://docs.microsoft.com/dotnet/core/tools/dotnet-install-script).
    Once you have the SDK installed, you just need to call **dotnet** the same way
    you do in Windows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: However, you must be aware of some features that are not fully compatible with
    Linux and macOS systems. For instance, no equivalent to the Windows Registry exists
    in these OSes and you must develop an alternative yourself. If needed, an encrypted
    JSON config file can be a good option.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that Linux is case-sensitive, while Windows is not.
    Please, remember this when you work with files. Another important thing is that
    the Linux path separator is different from the Windows separator. You can use
    the `Path.PathSeparator` field and all the other `Path` class members to ensure
    your code is multi-platform.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, you can also adapt your code to the underlying OS by using the runtime
    checks provided by .NET Core, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a service in Linux
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script can be used to encapsulate a command-line .NET Core app
    in Linux. The idea is that this service works like a Windows service. This can
    be useful, considering that most Linux installations are command-line only and
    run without a user logged in:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a file that will run the command-line app. The
    name of the app is `app.dll` and it is installed in `appfolder`. The application
    will be checked every 5,000 milliseconds. This service was created on a CentOS
    7 system. Using a Linux terminal, you can type this:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the file has been created, you must copy the service file to a system
    location. After that, you must reload `system` and enable the service so that
    it will restart on reboots:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Done! Now, you can start, stop, and check the service using the following commands.
    The whole input that you need to provide in your command-line app is as follows:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have learned about a few concepts, let us learn how to implement
    them in our use case.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Achieving security by design
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen up to here in the book, the opportunities and techniques we
    have for developing software are incredible. If you add all the information you
    will read about in relation to cloud computing in the next chapters, you will
    see that the opportunities just increase, as does the complexity to maintain all
    of this computing environment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must understand that these opportunities come with
    many responsibilities. The world has changed a lot in the last years. The second
    decade of the 21^(st) century has required lots of technology. Apps, social media,
    Industry 4.0, Big Data, and artificial intelligence are no longer future objectives,
    but mainly current projects that you will lead and deal with in your routine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Considering this scenario, security must have a different approach. The world
    has moved to regulate companies that manage personal data. For instance, GDPR
    – the General Data Protection Regulation – is not only mandatory for European
    territory, since it has changed the way software is developed not only in Europe
    but all over the globe. There are many initiatives comparable to GDPR that must
    be enlisted to our belt of techniques and regulations, considering the software
    you design will be impacted by them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Security by design must be one of your areas of focus for designing new applications.
    This subject is huge, and it is not going to be completely covered in this book,
    but as a software architect, you have to understand the necessity of having a
    specialist in the information security area in your team to guarantee the policies
    and the practices needed to avoid cyber attacks and maintain confidentiality,
    privacy, integrity, authenticity, and availability of the services you architect.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to protecting your ASP.NET Core application, it is worth mentioning
    that the framework has many features to help us out with that. For instance, it
    includes authentication and authorization patterns. In the OWASP Cheat Sheet Series,
    you'll be able to read about many other .NET practices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The Open Web Application Security Project® (OWASP) is a nonprofit foundation
    that works to improve the security of software. Check out its information at [https://owasp.org/](https://owasp.org/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET also provides features to help us out with GDPR. Basically, there are
    APIs and templates to guide you in the implementation of policy declaration and
    cookie usage consent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: List of practices for achieving a safe architecture
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following list of practices related to security certainly does not cover
    the entirety of the subject. However, these practices will certainly help you,
    as a software architect, to explore some solutions related to this topic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Define an authentication method for your web app. There are many authentication
    options available nowadays, from ASP.NET Core Identity to external provider authentication
    methods, such as Facebook or Google. As a software architect, you must consider
    who the target audience of the application is. It would also be worth considering
    using Azure Active Directory as a starting point if you choose to go down this
    route.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You may find it useful to design authentication associated with Azure AD, a
    component for managing the Active Directory of the company you are working for.
    This alternative is pretty good in some scenarios, especially for internal usage.
    Azure currently offers Active Directory for usage as **B2B** – **Business to Business**,
    or **B2C** – **Business to Consumer**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the scenario of the solution you are building, you will need to
    implement **MFA** – **Multi Factor Authentication**. The idea of this pattern
    is to ask for at least two forms of proof of identity before allowing the solution
    usage. It is worth mentioning that Azure AD facilitates this for you.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that you must determine an authentication method for the APIs
    you provide. JSON Web Token is a pretty good pattern, and its usage is totally
    cross-platform.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'You must determine the authorization model you will use in your web app. There
    are four model options:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple**, where you just use the `[Authorize]` attribute in the class or
    method;'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Role-based**, in which you may declare `Roles` for accessing the `Controller`
    you are developing;'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Claims-based**, where you can define values that must be received during
    the authentication to indicate that the user is authorized;'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Policy-based**, in which there is a policy established to define the access
    in that `Controller`.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may also define a controller or method in a class as being fully accessible
    to any user, by defining the attribute `[AllowAnonymous]`. Be sure this kind of
    implementation will not cause any vulnerabilities in the system you are designing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The model you decide to use will define exactly what each user will be able
    to do in the application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While designing, you, as a software architect, will have to decide which part
    of the data you store is sensitive, and it will need to be protected. By connecting
    to Azure, your web app will be able to store protected data in components such
    as Azure Storage and Azure Key Vault. Storage in Azure will be discussed in *Chapter
    9*, *How to Choose Your Data Storage in the Cloud*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that Azure Key Vault is used to protect secrets your
    app may have. Consider using this solution when you have this kind of requirement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Web security
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is totally unacceptable to have a production solution deployed without the
    HTTPS protocol enabled. Azure Web Apps and ASP.NET Core solutions have various
    possibilities to not only use but enforce the usage of this security protocol.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Thera are many known attacks and malicious patterns, such as cross-site request
    forgery, Open Redirect, and cross-site scripting. ASP.NET Core guarantees and
    presents APIs to solve them. You need to detect the ones that are useful for your
    solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Good programming practices, such as avoiding SQL injections by using parameters
    in your queries, is another important goal to achieve.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You may find cloud architecture security patterns at [https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/security).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: To finish, it is worth mentioning that security needs to be treated using the
    onion approach, which means that there are many layers of security to be implemented.
    You must have a policy determined to guarantee a process to access the data, including
    physical access to people who use the system you are developing. In addition,
    you will also have to develop a disaster recovery solution in case the system
    is attacked. The disaster recovery solution will depend on your cloud solution.
    We will discuss this later in*Chapter 4*, *Deciding the Best Cloud-Based Solution*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Book use case – understanding the main types of .NET Core projects
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development of this book's use case will be based on various kinds of .NET
    Core Visual Studio projects. This section describes all of them. Let us select
    **New project** in the Visual Studio **File** menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter **.NET Core** project types by typing in the search engine,
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_02_19.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: Searching types of .NET Core projects in Visual Studio'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'There, you will find common C# projects (console, a class library, Windows
    Form, WPF), and various types of test projects, each based on a different test
    framework: xUnit, NUnit, and MSTest. Choosing among the various testing frameworks
    is just a matter of preference since all of them offer comparable features. Adding
    tests to each piece of software that composes a solution is a common practice
    and allows software to be modified frequently without jeopardizing its reliability.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to define your class library projects under the **.NET Standard,
    which will be** discussed in *Chapter 13*, *Implementing Code Reusability in C#
    9*. These class libraries are based on standards that make them compatible with
    several .NET versions. For instance, libraries based on 2.0 standards are compatible
    with all .NET Core versions greater than or equal to 2.0, and with all .NET Framework
    versions greater than 4.6\. This compatibility advantage comes at the price of
    having fewer available features.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides filtering **Project Types** to **Cloud**, we have several more project
    types. Some of them will enable us to define microservices. Microservice-based
    architectures allow an application to be split into several independent microservices.
    Several instances of the same microservice can be created and distributed across
    several machines to fine-tune the performance of each application part. Microservices
    will be described in:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 6*, *Azure Service Fabric*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7*, *Azure Kubernetes Service*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, testing will be discussed in detail in *Chapter 18*, *Testing Your
    Code with Unit Test Cases and TDD*, and *Chapter 22*, *Automation for Functional
    Tests*. Finally, we have the ASP.NET Core application we already described in
    the *Creating a scalable web app with .NET 5* subsection. There, we defined an
    ASP.NET Core application, but Visual Studio also contains project templates for
    projects based on RESTful APIs and the most important single-page application
    frameworks, such as Angular, React, Vue.js, and the Blazor framework based on
    WebAssembly, which will be discussed in *Chapter 16*, *Blazor WebAssembly*. Some
    of them are available with the standard Visual Studio installation, while others
    require the installation of an SPA package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional requirements that describe system behavior must be completed with
    non-functional requirements that constrain system performance, scalability, availability,
    resilience, interoperability, usability, and security.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Performance requirements come from response time and system load requirements.
    As a software architect, you should ensure you have the required performance at
    the minimum cost, building efficient algorithms and taking full advantage of the
    available hardware resources with multithreading.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Scalability is the ability of a system to be adapted to an increasing load.
    Systems can be scaled vertically by providing more powerful hardware, or horizontally
    by replicating and load balancing the same hardware, which increases the availability.
    The cloud, in general, and Azure can help us implement strategies dynamically,
    with no need to stop your application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as .NET Core that run on several platforms can ensure interoperability,
    that is, the capability of your software to run on different target machines and
    with different operating systems (Windows, Linux, macOS, Android, and so on).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Usability is ensured by taking care of the input field's order, the effectiveness
    of the item selection logic, and how easy your system is to learn.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Besides, the more complex your solution is, the better resilience it should
    have. The idea of resilience is not to guarantee that the solution does not fail.
    Instead, the idea is to guarantee that the solution has an action defined when
    each part of the software fails.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must consider security from the very beginning
    of the design. Following the guidelines to determine the correct patterns and
    having a security specialist in your team would be a great option to achieve all
    the current regulations we have.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how Azure DevOps tools can help us when
    it comes to collecting, defining, and documenting our requirements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which are the two conceptual ways to scale a system?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you deploy your web app automatically from Visual Studio to Azure?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is multithreading useful for?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main advantages of the asynchronous pattern over other multithreading
    techniques?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the order of input fields so important?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the .NET Core `Path` class so important for interoperability?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of a .NET standard class library over a .NET Core class
    library?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the various types of .NET Core Visual Studio projects.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and links you may consider reading in order to
    gather more information in relation to this chapter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling](https://docs.microsoft.com/en-us/azure/architecture/best-practices/auto-scaling)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/azure-apps/)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency](https://docs.microsoft.com/en-us/dotnet/standard/parallel-processing-and-concurrency)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://owasp.org/](https://owasp.org/)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/gdpr](https://docs.microsoft.com/en-us/aspnet/core/security/gdpr)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/availability)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
