- en: Window Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Grouping widgets with frames
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Pack geometry manager
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Grid geometry manager
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Place geometry manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping inputs with the FrameLabel widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically laying out widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating horizontal and vertical scrollbars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widgets determine the actions that users can perform with our GUI application;
    however, we should pay attention to their placement and the relationships we establish
    with that arrangement. Effective layouts help users to identify the meaning and
    priority of each graphical element so that they can quickly understand how to
    interact with our program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Layout also determines the visual appearance that users expect to find consistently
    across the whole application, such as always placing confirmation buttons at the
    bottom-right corner of the screen. Although this information might be obvious
    to us as developers, end users may feel overwhelmed if we do not guide them through
    the application by following a natural order.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will dive into the different mechanisms that Tkinter offers to
    lay out and group widgets and control other attributes, such as their size or
    spacing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Grouping widgets with frames
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A frame represents a rectangular region of a window, typically used in complex
    layouts to contain other widgets. Since they have their own padding, border, and
    background, you can remark that the group of widgets is related logically.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Another common pattern for frames is to encapsulate part of the application's
    functionality so that you can create an abstraction that hides the implementation
    details of child widgets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We will see an example that covers both scenarios by creating a component that
    inherits from the `Frame` class and exposes certain information on the containing
    widgets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build an application that contains two lists, where the first one has
    a list of items and the second one is initially empty. Both lists are scrollable,
    and you can move items between them with two central buttons that transfer the
    current selection:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/4c30ba49-f25a-48ca-85ed-5533ffb88ce7.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will define a `Frame` subclass to represent a scrollable list, and then
    create two instances of this class. The two buttons will also be directly added
    to the main window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `ListFrame` class has only two methods to interact with the inner list:
    `pop_selection()` and `insert_item()`. The first one returns and deletes the current
    selection, or none if there is no item selected, whereas the second one inserts
    a new item at the end of the list.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are used in the parent class to transfer an item from one list
    to the other one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also took advantage of the parent frame containers to correctly pack them
    with the appropriate padding:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thanks to these frames, our calls to the geometry manager are more isolated
    and organized in our global layout.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another benefit of this approach is that it allows us to use different geometry
    managers in each container widget, such as using `grid()` for the widgets within
    a frame and `pack()` to lay out the frame in the main window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that mixing these geometry managers within the same container
    is not allowed in Tkinter and will make your application crash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the Pack geometry manager* recipe
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Pack geometry manager
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous recipes, we have seen that creating a widget does not automatically
    display it on the screen. We have called the `pack()` method on each widget to
    do so, which means that we used the Pack geometry manager.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the three available geometry managers in Tkinter, and it is well
    suited for simple layouts, such as when you want to place all the widgets on top
    of each other or side by side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we want to achieve the following layout in our application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/fce828e9-1f75-4590-a50e-bb8adbc1d8eb.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: It consists of three rows, where the last one has three widgets placed side
    by side. In this scenario, the Pack geometry manager can easily add the widgets
    as expected, without the need for additional frames.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use five `Label` widgets with different texts and background colors
    to help us identify each rectangular region:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also added some options with the `opts` dictionary to make the size of each
    region clear:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/1a0e72a4-090a-4af8-af83-c8574e730056.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have a better understanding of the Pack geometry manager, we will explain
    step by step how it adds widgets to the parent container. Here, we pay special
    attention to the values of the `side` option, which indicates, the relative position
    of the widget with respect to the next one that will be packed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we pack the two labels at the top of the screen. While the `tk.TOP`
    constant is the default value of the `side` option, we set it explicitly to clearly
    differentiate it from the calls where we used the `tk.LEFT` value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/77b7063f-2c0b-4a2b-ab75-c1704861201d.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Then, we pack the next three labels with the `side` option set to `tk.LEFT`,
    which causes them to be placed side by side:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/0f54aec2-5957-4da5-9e32-d63acc06903f.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Specifying the side on `label_e` does not really matter, as long as it is the
    last widget we add to the container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this is the reason why order is so important when working
    with the Pack geometry manager. To prevent unexpected results in complex layouts,
    it is common to group widgets with frames so that when you pack all the widgets
    within a frame, you do not interfere with the arrangement of the other ones.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we strongly recommend that you use the Grid geometry manager
    since it allows you to directly set the position of each widget with one call
    to the geometry manager and avoids the need for additional frames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from `tk.TOP` and `tk.LEFT`, you can pass the `tk.BOTTOM` and `tk.RIGHT`
    constants to the `side` option. They perform the opposite stacking, as their names
    suggest; however, it may be counterintuitive since the natural order we follow
    is from top to bottom and from left to right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we replace the `tk.LEFT` value with `tk.RIGHT` in our three
    last widgets, their order from left to right would be `label_e`, `label_d`, and
    `label_c`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the Grid geometry manager* recipe
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the Place geometry manager* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Grid geometry manager
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Grid geometry manager is considered the more versatile of the three geometry
    managers. It directly reassembles the *grid* concept that is commonly used in
    user interface design—a two-dimensional table divided into rows and columns, where
    each cell represents the space available for a widget.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will demonstrate how to use the Grid geometry manager to achieve the following
    layout:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/2f7823b8-c9f3-4408-8b62-eccfb7ab446d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: This can be represented as a 3 x 3 table, where the widgets in the second and
    third columns span two rows and the widget at the bottom row spans three columns.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in the preceding recipe, we will use five labels with different backgrounds
    to illustrate the distribution of the cells:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also passed a dictionary of options to add some internal padding and expand
    the widgets to all the available space in the cells.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The placement of `label_a` and `label_b` is almost self-explanatory: they occupy
    the first and second rows of the first column, respectively—remember that grid
    positions are zero-indexed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/956d78d6-3cda-41e4-949e-45489d30fdda.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: To expand `label_c` and `label_d` through multiple cells, we will set the `rowspan`
    option to `2`, so they will span two cells, starting from the position indicated
    with the `row` and `column` options. Finally, we will place `label_e` with the
    `columnspan` option to set it to `3`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remark that in contrast with the Pack geometry manager, it
    is possible to change the order of the calls to `grid()` on each widget without
    modifying the final layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sticky` option indicates the borders where the widget should stick, expressed
    in cardinal directions: north, south, west and east. These values are represented
    by the Tkinter constants  `tk.N`, `tk.S`, `tk.W`, and  `tk.E`, as well as the
    combined versions `tk.NW`, `tk.NE`, `tk.SW`, and `tk.SE`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: For example, `sticky=tk.N` aligns the widget to the top border of the cell (north),
    whereas `sticky=tk.SE` positions the widget in the bottom-right corner of the
    cell (south-east).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Since these constants represent their corresponding lowercase letters, we shorthanded
    the `tk.N + tk.S + tk.W + tk.E` expression with the `"nswe"` string. This means
    that the widget should expand both horizontally and vertically—similar to the
    `fill=tk.BOTH` option of the Pack geometry manager.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: If no value is passed to the `sticky` option, the widget is centered within
    the cell.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the Pack geometry manager* recipe
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the Place geometry manager* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Place geometry manager
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Place geometry manager allows you to set the position and size of a widget
    in absolute terms, or in relative terms to another one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Of the three geometry managers, it is the least commonly used one. On the other
    hand, it can fit some complex scenarios where you want to freely position a widget
    or overlap a previously placed one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate how to work with the Place geometry manager, we will replicate
    the following layout by mixing absolute and relative positions and sizes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/78190289-c61d-422c-8422-84a24b8a0d78.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The labels that we will display have different backgrounds and are defined
    in the order they are placed from left to right and top to bottom:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run the preceding program, you can see the overlapping between `label_c`
    and `label_d` in the center of the screen, something that we have not achieved
    with other geometry managers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first label is placed with the `relwidth` and `relheight` options set to
    `0.25`, which means that its width and height are 25% of its parent container.
    By default, widgets are placed at the `x=0` and `y=0` positions and aligned to
    north-west, that is, the top-left corner of the screen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The second label is placed at the absolute position—`x=100`—and aligned to the
    top border with the `anchor` option set to the `tk.N` (north) constant. Here,
    we also specified an absolute size with `width` and `height`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The third label is centered on the window using the relative positioning and
    setting the `anchor` to `tk.CENTER`. Remember that a value of `0.5` for `relx`
    and `relwidth` means half of the parent's width and a value of `0.5` for `rely`,
    and `relheight` means half of the parent's height.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The fourth label is placed on top of `label_c` by passing it as the `in_` argument
    (note that Tkinter suffixes it with an underscore because `in` is a reserved keyword).
    When using `in_`, you might notice that the alignment is not geometrically exact. In
    our example, we had to add an offset of `2` pixels in each direction to perfectly
    overlap the right-bottom corner of `label_c`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fifth label uses absolute positioning and relative size. As you
    may have already noticed, these dimensions can be easily switched since we assume
    a parent container of 200 x 200 pixels; however, only relative weights will work
    as expected if the main window is resized. You can test this behavior by resizing
    the window.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important advantage of the Place geometry manager is that it may be
    used in conjunction with Pack or Grid.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, imagine that you want to dynamically display a caption over a
    widget when you right-click on it. You can represent this caption with a Label
    widget, which gets placed in the relative position where you clicked on the widget:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As general advice, we recommend that you use any of the other geometry managers
    as much as possible in your Tkinter applications and leave this only for those
    specialized cases where you need a custom positioning.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the Pack geometry manager* recipe
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using the Grid geometry manager* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping inputs with the LabelFrame widget
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LabelFrame` class can be used to group multiple input widgets, indicating the
    logical entity with a label they represent. It is typically used in forms and
    is very similar to the `Frame` widget.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a form with a couple of `LabelFrame` instances, each one with
    their corresponding child input widgets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/e9759bcf-5dd1-41ce-9de4-bdb6de6a32e9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the purpose of this example is to show the final layout, we will add
    some widgets, without keeping their references as attributes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LabelFrame` widget takes the `labelwidget` option to set the widget used
    as a label. If it is not present, it displays the string passed as the `text`
    option. For instance, instead of creating an instance with `tk.LabelFrame(master,
    text="Info")`, you can replace it with the following statements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would allow you to do any kind of customization, such as adding an image.
    Note that we did not use any geometry manager for the label since it is managed
    when you place the frame.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically laying out widgets
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Grid geometry manager is easy to use both in simple and advanced layouts,
    and it is also a powerful mechanism to combine with a list of widgets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at how we can reduce the number of lines and call the geometry
    manager methods with just a few lines, thanks to list comprehensions and the `zip`
    and `enumerate` built-in functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application we will build contains four `Entry` widgets, each one with
    its corresponding label that indicates the meaning of the input. We will also
    add a button to print all the entries'' values:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/a4586bd3-a7cf-4f0d-9ce6-a538e7114f37.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Instead of creating and assigning each widget to a separate attribute, we will
    work with lists of widgets. Since we will track the index while iterating over
    these lists, we can easily invoke the `grid()` method with the appropriate `column`
    option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will aggregate the lists of labels and entries with the `zip` function.
    The button will be created and displayed individually, as it does not share any
    option with the rest of the widgets:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can enter different text on each input and click on the Print info button
    to verify that each tuple contains the corresponding label and entry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each list comprehension iterates over the strings of the fields list. While
    labels use each item as the displayed text, entries only need the reference to
    the parent container—the underscore is a common idiom that means the variable
    value is ignored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from Python 3, `zip` returns an iterator instead of a list, so we
    consume the aggregation with the list function. As a result, the `widgets` attribute
    contains a list of tuples that can be safely iterated multiple times:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have to call the geometry manager on each tuple of widgets. With the
    `enumerate` function, we can track the index of each iteration and pass it as
    the *row* number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we used the `for i, (label, entry) in ...` syntax because we must
    unpack the tuple generated with `enumerate`, and then unpack each tuple of the
    `widgets` attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Within the `print_info()` callback, we iterate over widgets to print each label
    text with its corresponding entry value. To retrieve the labels' `text`, we used
    the `cget()` method, which allows you to get the value of a widget option by its
    name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Creating horizontal and vertical scrollbars
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Tkinter, geometry managers take all the necessary space to fit all the widgets
    in their parent container. However, if the container has a fixed size or exceeds
    the screen's size, there will be a region that will not be visible to users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Scroll bar widgets are not automatically added in Tkinter, so you must create
    and lay them out as any other type of widget. Another consideration is that only
    a few widget classes have the configuration options that make it possible to connect
    them to a scrollbar.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: To work around this, you will learn to take advantage of the flexibility of
    the **Canvas** widget to make any container scrollable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the combination of the `Canvas` and `Scrollbar` classes to create
    a resizable and scrollable frame, we will build an application that dynamically
    changes its size by loading an image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Load image button is clicked, it removes itself and loads an image into
    the `Canvas` that is larger than the scrollable region—for this example, we used
    a predefined image, but you can modify this program to select any other GIF image
    with a file dialog:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/5ed14b60-2769-43a6-9204-75d6a42f8198.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'This enables the horizontal and vertical scrollbars, which automatically adjust
    themselves if the main window is resized:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/1c73a705-07ce-497d-a353-1cc76c01b56e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we will dive into the functionality of the Canvas widget in a separate
    chapter, this application will introduce its standard scroll interface and the
    `create_window()` method. Note that this script requires the file `python.gif`
    to be placed in the same directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first lines of our application create the scroll bars and connect them to
    the `Canvas` object with the `xscrollcommand` and `yscrollcommand` options, which
    take a reference to the `set()` method of `scroll_x` and `scroll_y`, respectively—this
    is the method in charge of moving the scroll bar slider.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also necessary to configure the `command` option of each scroll bar once
    the `Canvas` is defined:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is also possible to create the `Canvas` first and configure its options later,
    when the scroll bars are instantiated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add the frame to our scrollable `Canvas` with the `create_window()`
    method. The first argument it takes is the position to place the widget passed
    with the `window` option. Since the *x* and *y* axes of the `Canvas` widget start
    in the top-left corner, we placed the frame at the `(0, 0)` position and also
    aligned it to that corner with `anchor=tk.NW` (north-west):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we will make the first row and column resizable with the `rowconfigure()`
    and `columnconfigure()` methods. The `weight` option indicates the relative weight
    to distribute the extra space, but in our case, there are no more rows or columns
    to resize.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding to the `<Configure>` event will help us to properly reconfigure
    the `canvas` when the main window gets resized. Handling this type of event follows
    the same principles that we saw in the previous chapter to process mouse and keyboard
    events:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we will set the minimum size of the main window with the current width
    and height, which can be retrieved with the `winfo_width()` and `winfo_height()`
    methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the real size of a container, we have to force the geometry
    manager to draw all the child widgets first by calling `update_idletasks()`. This
    method is available in all widget classes, and forces Tkinter to process all pending
    idle events, such as redrawings and geometry recalculations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `resize` method handles the window resize event and updates the `scrollregion`
    option, which defines the area of the `canvas` that can be scrolled. To easily
    recalculate it, you can use the `bbox()` method with the `ALL` constant. This
    returns the bounding box of the whole Canvas widget:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tkinter will automatically trigger several `<Configure>`­ events when we start
    our application, so there is no need to call `self.resize()` at the end of the
    `__init__` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动应用程序时，Tkinter将自动触发多个`<Configure>`事件，因此无需在`__init__`方法的末尾调用`self.resize()`。
- en: There's more…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Only a few widget classes support the standard scroll options: `Listbox`, `Text`,
    and `Canvas` allow `xscrollcommand` and `yscrollcommand`, whereas the Entry widget
    only allows the `xscrollcommand`. We have seen how to apply this pattern to a
    `canvas` since it can be used as a generic solution, but you can follow a similar
    structure to make any of these widgets scrollable and resizable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只有少数小部件类支持标准滚动选项：`Listbox`、`Text`和`Canvas`允许`xscrollcommand`和`yscrollcommand`，而输入小部件只允许`xscrollcommand`。我们已经看到如何将此模式应用于`canvas`，因为它可以用作通用解决方案，但您可以遵循类似的结构使这些小部件中的任何一个可滚动和可调整大小。
- en: Another detail to point out is that we did not call any geometry manager to
    draw the frame because the `create_window()` method does this for us. To better
    organize our application class, we could move all the functionalities that belong
    to the frame and its inner widgets to a dedicated `Frame` subclass.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要指出的是，我们没有调用任何几何管理器来绘制框架，因为`create_window()`方法会为我们完成这项工作。为了更好地组织我们的应用程序类，我们可以将属于框架及其内部小部件的所有功能移动到专用的`Frame`子类中。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Handling mouse and keyboard events* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理鼠标和键盘事件的方法
- en: The *Grouping widgets with frames* recipe
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框架对小部件进行分组的方法
