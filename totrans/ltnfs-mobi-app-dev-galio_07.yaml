- en: '*Chapter 7*: Exploring the State of Our App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through so many different ideas about how to build an app, it's
    time to get to set one of the final stones for our house's foundation. In this
    chapter, we'll understand what state is, and most importantly, how state works
    inside a React application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go through a basic definition of what exactly state is and how it was
    traditionally used in React applications. We'll also learn about some new modern
    ways of using state and how exactly they work. We'll have to decide on our own
    which one is the best fit to be used in our specific case, but of course, I'm
    going to give you my recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then apply all our new information to a practical exercise, which is going
    to help us reinforce these new concepts in our brain so we can properly understand
    everything we cover.
  prefs: []
  type: TYPE_NORMAL
- en: After the practical exercise, it'll be time to look at some different hooks
    and what exactly they are. We'll learn about the differences about using state
    in a class component and how hooks can help us write less code. We'll also learn
    about another hook, which deals with lifecycle functions. All this will help us
    move forward with our studying and is imperative for us to know before creating
    more complex applications with React Native and Galio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveling up our screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other hooks and why they're relevant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 07`, which contains all the code we've written
    for this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: What is state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got to this point, it's imperative for us moving forward to understand
    what state is and how it works inside a React component. Once we learn this, we'll
    be fully capable of using React to the best of our abilities. This unlocks the
    missing link we've had until now, more exactly, it will unlock the key to making
    our mobile apps more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about *props* in [*Chapter 3*](B17074_03_epub_Final_SB.xhtml#_idTextAnchor063),
    *The Correct Mindset*. It's the technique we use to pass data from one component
    to another. Think of props as the first level of a component. We need to level
    up our component creation skills so the most logical step now before going into
    any practical challenges is to learn about state.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, in order to be able to use state inside our components, we had
    to use *class components*. Later versions of React, we got introduced to being
    able to use state even in functional components with something called *hooks*.
    We'll discuss hooks more right after we learn the basics of state, and for that,
    we have to start with class components.
  prefs: []
  type: TYPE_NORMAL
- en: What is a class, though? A class is a template for creating an object. Objects
    are usually used in **OOP** – **Object-Oriented Programming**. Although JavaScript
    is not a class-based object-oriented language, it still has ways of using OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how a class is created in JavaScript and what exactly it requires
    to function properly inside a React/React Native project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Code for a class component in React'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.1_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Code for a class component in React
  prefs: []
  type: TYPE_NORMAL
- en: This is really similar to a function but it does not have any *parameters* and
    also, we can see that `extends` word there. The keyword `extends` is basically
    used to let the class know it should *inherit* properties from another class;
    in this case, the other class is `React.Component`. All classes need to inherit
    from `React.Component` so the class can get used as a React component.
  prefs: []
  type: TYPE_NORMAL
- en: We also see the `render()` function. This function is required by a React component.
    It's the place where we write all our JSX. Now, there's another function we're
    supposed to use. It's the function that gets called when a new object is created
    using the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve been through how to create a class, it''s time to finally go
    into state. Let''s see how we can add *state* to our `App` class component. For
    that, we need to create another function inside our `App` class called `constructor()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The constructor function added to our class'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.2_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The constructor function added to our class
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In class-based OOP, a constructor is a special type of function that is called
    whenever we're creating an object. It often accepts arguments to custom-initialize
    a new object in any way we want to.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this function accepts one argument, `props`, which enables us
    to use the props this component might receive. The `super()` function inside the
    constructor is a keyword used to access and call functions on an object's parent.
    This function must be used before the `this` keyword is used.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, our state variable has a `this` keyword in front of it. This
    keyword refers to the object it belongs to. It basically refers to the fact that
    the `state` variable is linked to *this* object only so you can't really access
    it directly from another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can use it inside our `render` function. This is the
    exact same way we''d use `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – State used in the render function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.3_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – State used in the render function
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we still use the `this` keyword in order to make sure that the
    `state` variable refers to this specific object when it is rendered. Now the message
    that should appear onscreen is **Hi everybody! I'm 24 years old!**.
  prefs: []
  type: TYPE_NORMAL
- en: This is really similar to the `props` we've been using, but what exactly is
    different?
  prefs: []
  type: TYPE_NORMAL
- en: The actual difference is that `state` is local while `props` is something we
    transfer from one component to another. Another difference is that because `state`
    is a local variable, we can change it inside our component and the only thing
    that has to render is that specific component. The thing with `props` is that
    once we update a prop, all the children that are using that prop need to be re-rendered
    and that puts some **stress** on our app.
  prefs: []
  type: TYPE_NORMAL
- en: What is state?
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, a system is called stateful as long as it is designed to
    remember previous information. The remembered information is called the state
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: This is **not** to say that `state` is better than `props`. They all have their
    purpose and you'll use all of these concepts when building an app. Sometimes,
    you need state and we'll look at some examples using both so we can better understand
    how exactly they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we change this variable? Some of you might naturally think "Hey,
    this is easy – just change the variable as you''d normally do" and you''re going
    to try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But this won't really work. You could try doing it inside your component but
    you won't see any differences. The state will remain `24` on your screen and the
    component will not re-render. React state should be treated as immutable. In the
    programming world, an immutable object is an object that cannot be modified after
    it has been created.
  prefs: []
  type: TYPE_NORMAL
- en: We actually have a React function implemented for us called `setState()`. This
    helps us replace the state with another state so we don't really modify the main
    variable; we actually replace the variable with another variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to change the age, we would need to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, this seems fairly easy, but where exactly do we change the state? Well,
    there are lots of places where we can change the state but that depends on your
    app and how exactly you want it to work. Let's say we want to change the age right
    when the component is getting rendered on the screen. React gives us certain functions
    for our class component called *lifecycle functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are called at specific moments in a component''s life. We''ll
    discuss two of them: `componentDidMount()` and `componentWillUnmount()`.'
  prefs: []
  type: TYPE_NORMAL
- en: These represent exactly what the names suggest. The first one gets called once
    our component has already mounted (rendered) to the screen. The second one is
    called once the component has to be removed from the screen. So, we have these
    moments in a component's life where we can insert code to make sure the components
    behave as we expect them to behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, if we wanted to change the age once the component gets rendered,
    we''d have to use the `componentDidMount()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Using componentDidMount inside our class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.4_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Using componentDidMount inside our class component
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we open up our app, we''ll see **Hi everybody! I''m 54 years old!**.
    But the state actually was `24` at the start of rendering, and once it rendered,
    the state changed to `54`. So, this is really cool, we have so many different
    new functions and properties. I''d totally recommend you read more about how a
    class works inside JavaScript if there''s anything you feel you don''t really
    understand. You can do that by visiting Mozilla''s website, which is full of interesting
    information about JavaScript: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
    Just so you know, a lot of people have problems or feel confused about how the
    `this` keyword works and how exactly state works. I feel like this confusion always
    clears once you learn a lot more about how JavaScript actually works.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use what we've learned so far and apply it to a cool little practical
    exercise. We'll now begin using state in order to make our screens look more dynamic
    instead of just our usual static screens.
  prefs: []
  type: TYPE_NORMAL
- en: Leveling up our screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see what kind of app we''re going to create. I was thinking we could
    have a screen where it shows our current age down to months, days, hours, and
    minutes. I mean, that''s pretty cool, right? Whenever someone asks you your age,
    you''ll be able to just take your phone out of your pocket and show them the screen
    you''ve created. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our terminal and create a new `expo` managed project just like
    we always do, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let's open up our project and start writing some code!
  prefs: []
  type: TYPE_NORMAL
- en: Let's go straight to the `App.js` file and delete everything in there besides
    the imports and StyleSheet. I always leave the StyleSheet because I'm a fan of
    centered text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's rewrite the `App` component as a `class` component.![Figure 7.5 –
    App.js rewritten as a class component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](Images/Figure_7.5_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – App.js rewritten as a class component
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s open up our Expo app by using the following command inside our terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I always use this command as it clears out the cache. So, this way, I make sure
    the cache will never interfere with my changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Expo server is open, just as we learned, open up the simulator
    of your choice. You should be able to see the text `My real age is:` on the screen
    once your app opens up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's integrate our age as a state inside the `App` class component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just as we''ve seen before, we need to write our `constructor()` function above
    everything else inside our class component. *Don''t forget* about the `super(props)`
    line – that one''s important! We''ll then create our state inside our `constructor`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – constructor function with our newly created state'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.6_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – constructor function with our newly created state
  prefs: []
  type: TYPE_NORMAL
- en: I've already mentioned we're going to display our age in terms of years, months,
    and days, all the way to seconds, so I've put an object filled with zeros in there
    just as a placeholder. It could've really been anything in there as we're going
    to change it after some quick math.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's dive right into how we're going to calculate the age. For this little
    trick, we're going to use the `Date()` object inside JavaScript. Even though this
    object might seem a little bit confusing for some people, after you learn more
    about time zones, it really becomes just another object to play with. Don't sweat
    it, we're not going to go that deep into dates with JavaScript as we have better
    stuff to learn about.
  prefs: []
  type: TYPE_NORMAL
- en: So, we're going to create a new function called `getAge()`, which is going to
    receive your birthday date. This function will take the current time and will
    subtract from it the date of your birth. All of this will be done in milliseconds.
    After that, we're going to take the result and create a new `Date` object with
    it. From that new object, we're going to extract all the information about how
    old we are.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of it, we''re going to use `setState` to create a new state with
    all the information we''ve calculated from our `Date` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Our function to calculate our current age'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.7_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Our function to calculate our current age
  prefs: []
  type: TYPE_NORMAL
- en: Now, you're probably wondering why we subtracted `1970` for years and `1` for
    days. Oh well, as I was saying, the `Date` object is a little bit weird. We had
    to subtract `1970` because UTC time starts at 1970, so in order to be sure we're
    getting our correct year value, that had to disappear from our equation. As for
    the value for days, this might have something to do with the fact that I really
    wanted to make sure that time zones would be taken into consideration and my time
    zone needed that `-1`. The thing is, even if we get 1 day off, the important thing
    is to see this thing really work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the function, and we're using the `setState` function to correctly
    change the state, it's time to call this function from somewhere. As you know,
    a normal function won't just call itself (even though there are functions out
    there that can do that).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s do the same thing we did before – let''s call our function in `componentDidMount()`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I've used the keyword `this` to make sure our object knows we're
    referring to its function `getAge`. I've also used my own birthday inside the
    function but you may use your own birthday to make this even more personal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our job is not done! Let''s get to our `render` function and make some modifications
    so we can display everything properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Our render function after we''ve implemented our state'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.8_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Our render function after we've implemented our state
  prefs: []
  type: TYPE_NORMAL
- en: The first line inside our `render` function might seem a little bit weird to
    some of you. It's called **object destructuring**. This is what we've already
    been doing with our imports. This is a really useful JavaScript feature used to
    extract properties from objects and even bind them to variables.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we're now able to just say `years` whenever we're referring to
    `this.state.age.years`. It saves us writing time and it also looks a lot clearer.
    You'll see people destructuring variables like this all the time – it's a really
    cool feature!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've made sure that we're going to use all the variables inside our
    `state`, our `componentDidMount` is calling our `getAge` function and the `state`
    is set inside that function, everything is ready. Run your app and check out the
    result. You should be able to look at the screen and see how old you really are,
    down to the smallest detail.
  prefs: []
  type: TYPE_NORMAL
- en: But there's something wrong – the seconds don't refresh, so everything stays
    the same. You're probably thinking that I could've lied to you, but trust me I
    didn't. Right now, your real age is not updating because our `getAge` function
    is only getting called once. As we said, `componentDidMount` calls the function
    when the component first renders on the screen. Our component rendered, the function
    got called, and that's the end of the story.
  prefs: []
  type: TYPE_NORMAL
- en: We somehow have got to make that function call multiple times; I'm thinking
    at least once a second so we make sure our seconds are in sync with the real time.
    Let's do that now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `componentDidMount` function, we''ll call a cool little function
    called `setInterval()`. The first parameter it accepts is a function. This will
    be called at an interval of time. The second parameter it accepts is actually
    the time in milliseconds for how often to execute the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – componentDidMount with our setInterval function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.9_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – componentDidMount with our setInterval function
  prefs: []
  type: TYPE_NORMAL
- en: Now we've created this interval at which our `getAge()` function is called.
    It's a good practice to stop the interval when we don't really need it to work
    anymore. The question popping right now in your mind is probably "When don't we
    need it run?". Well… That's usually subjective but in our specific case, the answer
    is at the end of our component's life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember we said there''s another lifecycle function called `componentWillUnmount()`?
    Well, that''s exactly where we''re going to stop this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The componentWillUnmount function used in our class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.10_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – The componentWillUnmount function used in our class component
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done this, our app should be ready to display our current age
    correctly. Save everything, refresh the simulator, and check it out! Your real
    age is now displaying right on the screen. Don't let those numbers ruin the day
    for you though – we're all as young as we feel!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how state behaves in a `class` component, which is a bit
    more of a traditional use of state, it's time to see other ways of using state.
    In the recent past, React blessed us with some cool little things called **hooks**.
    Let's learn more about them, how exactly they differ from our traditional state,
    and what new features they bring to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Other hooks and why they're relevant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem with state is the fact that the only way we can use it is in
    a `class` component. Class components are generally seen as a bit ugly and hard
    to learn for some beginners, so the React team tried creating something new that
    promised to solve the problems beginners and advanced users could have gotten
    into while using a class component with the traditional use of state. This is
    how **hooks** were born.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks were introduced in React v16.8 and React Native v0.59\. They basically
    let you use state and other React features without writing a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what exactly does that mean for us? Let''s look at an example of how state
    is written with our new hooks feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Example of using hooks'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.11_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Example of using hooks
  prefs: []
  type: TYPE_NORMAL
- en: Woah! So, what do we have here? Is this really the same state feature we've
    been using so far? Yes, it is. If you were to copy this code into a fresh new
    project, you'd see that once you started up your app, every time you pressed that
    button, the number would keep updating from 0 to however many times you pressed
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what exactly we wrote here.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we've created a function called `Example`. The name doesn't
    really matter as long as it's not your main function, which should always be called
    `App`. A function looks much cleaner than a class and it's obviously a lot easier
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: Then we've defined two variables inside our function using the hook `useState()`.
    How exactly does that work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `useState` is a hook. We call this method inside a function
    component in order to add local state to our component. This function returns
    a pair: the *current* state value – `count`, and a function that lets you update
    that value - `setCount`. The `setCount` function is pretty similar to the `this.setState`
    function in a class, except it doesn''t merge the old and new state together.'
  prefs: []
  type: TYPE_NORMAL
- en: The only argument `useState` accepts is the initial state given to our `count`
    variable. Remember that our `this.state` variable had to be an object and everything
    was inside that object. `count` doesn't have to be an object even though it could
    be if you want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see a straight comparison between using `this.state` and the `useState`
    hook. We'll see the same state written with both of these features so we can have
    a clear way of comparing the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll take a look at `this.state`. We''ll imagine having an app that
    needs to have some information regarding a user, some comments that their friends
    have left on the user''s profile, but also the number of likes this profile has:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – State object as written in a class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.12_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – State object as written in a class component
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty easy to understand, right? Our `state` has the following values:
    `userInfo` – an object, `comments` – an array of strings, and `likes` – a number.
    Let''s see how the same thing would look using *hooks*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Our state written in a functional component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.13_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Our state written in a functional component
  prefs: []
  type: TYPE_NORMAL
- en: This is the exact same thing but we've been using the `useState` hook. Everything
    has the exact same values as the previous example but the difference is in the
    fact that our state is not living in a single object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say, for example, we want to change the number of likes. Maybe
    someone clicked the like button and we want to update the number displayed on
    the screen. Let''s see how we would change it in a class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Changing the state in a class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.14_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Changing the state in a class component
  prefs: []
  type: TYPE_NORMAL
- en: This looks complicated, right? On top of that, there's a bunch of new things
    compared to the usual `setState()` function we've been using until now. The thing
    is, because we need to update the state just for the likes value, we used something
    called *previous state*. That's where `prevState` comes from. Once you need to
    change the state based on the previous state, as we need to do here because we
    need to increment the number of likes, it's imperative to pass to `this.setState`
    a function as an argument. This provides us with a snapshot (`prevState`) of the
    previous state. We've been using the short version until now because we didn't
    need to update it based on the previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how the same thing would look if we''d been using hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Changing the state in a functional component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_7.15_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Changing the state in a functional component
  prefs: []
  type: TYPE_NORMAL
- en: This is obviously a lot cleaner and easier. We know we want to change only the
    likes, so we're using `setLikes`. Here, we can take the `likes` state and just
    increment it by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, hooks make our life a lot easier. They're really simple to use
    and require a lot less writing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the thing is, if we were to take the app we created before going into **hooks**,
    the one that displays our real age, how exactly would we be able to call the `setInterval`
    function because the lifecycle functions – `componentDidMount` or `componentWillUnmount`
    – are only available in a class component.
  prefs: []
  type: TYPE_NORMAL
- en: We're in luck because the React team provides us with a lot more hooks for us
    to use besides `setState`. First, let's see what exactly a hook is.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, React is all about code reusability. Right now, we can write simple
    functions and call them whenever we need to calculate something or even write
    components in order to reuse them in any part of our application, but the problem
    with components is the fact that they have to render some UI. This makes components
    kind of inconvenient. The React team got the hooks idea because they wanted to
    be able to share complex logic without having to render some sort of UI. Hooks
    let you use React features from a function with just a simple function call. The
    hooks we''ve been provided with cover the most important parts of React: state,
    lifecycle, and context.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's see what type of hook we could use instead of the `componentDidMount`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: useEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useEffect` hook enables us to use side effects from a function component.
    What are *side effects*? For example, *data fetching* or *subscriptions* are side
    effects. They're called that because they can affect other components and can't
    be done during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, those operations are performed with lifecycle functions in a class
    component. You can think of `useEffect` like all those lifecycle functions all
    combined in a single function. Just like `useState`, `useEffect` may be used multiple
    times inside the same functional component.
  prefs: []
  type: TYPE_NORMAL
- en: By using this hook, you'll basically tell React that your component needs to
    do something after rendering. React will remember the function you passed and
    call it later after performing all the updates. `useEffect` runs after every render.
    So basically, it runs after the first render and after every update your component
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so what about `componentWillUnmount`? How can we make sure that our function
    will only work when it's time to remove the component? `useEffect` is enough for
    this and we don't need another hook. If we do return a function from our effect,
    React will make sure to call that function once our component is unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are a really big part of React and they require lots of explaining, and
    I feel you'd get the most out of just reading the documentation. There are other
    hooks out there, for example, `useMemo`, `useRef`, and `useReducer`. So, reading
    the documentation is a lifesaver for all programmers, especially because you'll
    find in there lots of really cool information that I can guarantee you won't find
    in any book. When learning a new technology, your first step should be the documentation
    and then researching other ways that are more specific and more to the point about
    what you're really trying to study. Just like this book, we're here to learn how
    to build some React Native cross-platform applications, so let's move on and we'll
    explain more about hooks when we get to the point of using them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has gone over most of the information about state required for
    us to move forward. By now, we should be able to understand how state works both
    in a class component and a functional component.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about state and what exactly state is, we learned about some
    lifecycle functions and how exactly they work. Learning about this is really important
    because we've now understood that a component lives through different stages and
    at different points, we're able to interfere with some JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: This whole adventure gave us an idea, the real age app. We're now able to create
    an app with dynamic numbers that change over time. We've learned how to implement
    everything we've learned so far about state and create an awesome idea displaying
    our age.
  prefs: []
  type: TYPE_NORMAL
- en: Because class components look a bit like there's too much code to write, we
    started learning about hooks. After a careful analysis of how exactly they're
    different, we learned about a hook called `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning all this will be really beneficial in the long run, especially in the
    following chapters when it's all about practical challenges, where we'll learn
    lots of tricks and create many different types of React Native applications.
  prefs: []
  type: TYPE_NORMAL
