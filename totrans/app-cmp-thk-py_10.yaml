- en: '*Chapter 8*: Introduction to Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be learning about the Python commands and functionalities
    while applying them to problems. As we delve into the first chapter of *Section
    2*, *Applying Python and Computational Thinking*, we will be using more complex
    Python programming. In this chapter, we will focus more on language, while the
    remaining chapters will focus on application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dictionaries and lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about files, data, and iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we dig deeper into the Python programming language, remember that some of
    the content has been covered in previous chapters as we looked at the computational
    thinking process, such as the use of dictionaries and functions. This chapter
    will allow you to find critical information more easily when looking for Python
    commands to meet your computational thinking problem needs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is one of the fastest-growing programming languages due to its ease of
    use. One of the draws of Python is that we can write the same programs we do with
    languages such as C, C++, and Java, but with fewer lines of code and simpler language
    and syntax. Another big draw of Python is that it is **extensible**, which means
    we can add capabilities and functionalities to it.
  prefs: []
  type: TYPE_NORMAL
- en: While not all functionalities are inherently built in, we can use libraries
    to add what we need. Those libraries are available to download and use. For example,
    if we wanted to work with data and data science, there are a few libraries we
    can download, such as **Pandas**, **NumPy**, **Matplotlib**, **SciPy**, **Scikit
    Learn**, and more. But before we get into those libraries, let's look at how the
    Python language works and learn its basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has some built-in reference functions. The following table shows the
    functions in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – Python built-in functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 – Python built-in functions
  prefs: []
  type: TYPE_NORMAL
- en: While we won't go over all the functions in this book, we will use some of them
    as we look at Python and its algorithms. Let's start with some of the mathematical
    functions listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical built-in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, some of the mathematical functions are already built in, such as
    the `abs()`, `eval()`, `max()`, `min()`, and `sum()` functions. These are not
    the only mathematical functions built in, but we'll take a closer look at these
    particular ones in order to understand how Python deals with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `abs()` function will help us find the absolute value of a number, either
    an integer or a float. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_absFunction.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we''ll get the absolute value of `–3.89`. Remember
    that the absolute value of a number is its distance from 0\. Take a look at the
    output when we run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the absolute value is always positive, when we run `abs(–3.89)`, we get
    `3.89`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helpful mathematical function is the `eval()` function. We can define
    a variable in this function and then call for Python to evaluate an algebraic
    expression using that value. In the Python shell, we can first define the variable
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the variable is defined, we can call the `eval()` function with any
    expression. For example, take a look at the following input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Python used the previously defined `p` value of `2`, and substituted
    then evaluated the expression to produce this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python program also works as a calculator, so you can perform mathematical
    operations as you normally would. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Python knows to read the dash as a subtraction and produces
    the result of the mathematical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next case, Python interpreted `+` as a mathematical symbol and provided
    the result of the sum expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the last expression, `10**5`. In Python, we can use two stars (`**`)
    to denote exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the `max()` function. This function can be used
    on an iterable list, but we can test it with just two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can clearly see what the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, the function always chooses the largest item.
    You can add a third item and the function will still choose the maximum value.
    These built-in functions are smart in a way that they are coded to work with what
    is provided – two or three items, for example – without having to tell Python
    explicitly how many items we''ll be introducing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output obtained is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we did not have to add anything to the built-in function to
    find the maximum of three values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `min()` function is the opposite; it chooses the minimum value. Take a
    look at the following minimum function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function used the same list we used for the maximum function,
    but this time the output is `109`, which is the minimum value of that group of
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There are other mathematical functions, such as `sum()`. If you're a Python
    beginner, it's recommended that you play around with those functions to learn
    how they work. These functions will be key to your algorithms as you design solutions
    for computational thinking problems. We will also use some of these functions
    as we look at other Python functionalities, such as dictionaries and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dictionaries and lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get too deep into dictionaries and lists, it's important to note that
    Python does not contain arrays in the built-in functions. We can use lists and
    perform a lot of the traditional functions on lists that we'd use for arrays.
    However, for more robust functionalities with arrays, a library is needed, such
    as NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has four collection data types, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lists**: Ordered and changeable; can have duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: Ordered and unchangeable; can have duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: Unordered and unindexed; cannot have duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionaries**: Unordered, changeable, and indexed; cannot have duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As noted, we won't be going into NumPy libraries or other data libraries just
    yet. For now, we're going to focus on dictionaries and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may recall that we used dictionaries in [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding Algorithms and Algorithmic Thinking*, when we created a menu of
    items. Dictionaries in Python are collections that have the following three characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: They are unordered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are changeable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are indexed by keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dictionaries are organized as value pairs. For example, we can have a dictionary
    with value pairs of states and their capitals. Take a look at the following dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_dictionary1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to print this dictionary without any conditions to the `print` statement,
    we would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each value pair is printed at once. Just like we built the
    dictionary in this way, Python also has a built-in `dict()` function. The same
    dictionary can be built using that function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_dictionary2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the dictionary is constructed very similarly in both examples,
    with some changes in syntax, such as the use of colons in the first instance,
    versus parentheses and commas in the second one. However, the `print` statement
    produces the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are said to be key-value pairs because the first item is the key
    and the second, paired item is the value. So, for `Ohio` and `Columbus`, `Ohio`
    is the *key* while `Columbus` is the *value*. We can use the key to call any value.
    For example, I can call `states[''Ohio'']` and it should return `''Columbus''`.
    Take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do that for any key-value pair in the dictionary. But if we try to call
    a key that''s not in the dictionary, such as `Alabama`, then we get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to the following error being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this gives a `KeyError`, mentioned in the list of errors in [*Chapter
    7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100), *Identifying Challenges within
    Solutions*, in the *Errors in logic* section. But let''s say we do want to add
    `Alabama` and the capital, which is `Montgomery`. We can use the following code
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the dictionary again after entering the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the dictionary added the `'Alabama':'Montgomery'` key-value pair
    at the end of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also delete key-value pairs using the `del` code, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we go ahead and print the `states` dictionary, `Delaware` is no longer
    on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output after deleting the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can continue to add items or delete them without having to go into
    the main algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'With dictionaries, you can also add multiple values to one key. Let''s say
    I play three sports (I don''t). I could list those in a dictionary and match them
    to one key value. Take a look at the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_dictionary3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the full dictionary using `print(miscellaneous)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we get the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the printed dictionary includes all the values. If I want to
    print only the sports, then I can use the `miscellaneous[''sports'']` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we did not use the `print()` function at all. We used the dictionary,
    which we called `miscellaneous`, and called the `'sports'` key. Note that we were
    able to get this result because we called the dictionary in the **IDLE** command
    window in Python. If you want to include this in your algorithm, you'll still
    need to use the `print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: While we won't go into all the functionalities of dictionaries here, you can
    see how they can be helpful in creating algorithms that contain key-value pairs.
    Python allows us to add and alter the dictionary, call values, and more with the
    use of simple code without having to access the entire dictionary to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at lists.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists in Python are ordered and changeable. We can create lists for anything,
    such as types of animals, colors, fruit, numbers, or really whatever we want.
    Since we can have duplicate values, we could have a list for three apples that
    just says `apple, apple, apple`. For example, take a look at the list shown:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_list1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print this list, all the items are included. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have the same value three times. We would not be able to
    do that with a dictionary, which does not allow duplicate members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at what we can do with lists. Let''s start with the
    following list of animals:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_list2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first item in the list is `''dog''`. Lists have indexes, starting at 0\.
    So, if we printed `animals[0]`, we''d get `dog`. We can check it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output with index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are six items on the list, but the last index is `[5]`. So, to print
    `elephant`, we''d need to print using that index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use negative numbers for indexes in lists. The `[–1]` index refers
    to the last index, so it represents `elephant`, the same as index `[5]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `[–2]` index refers to the second-to-last index, so `tiger`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also print multiple items from a list by specifying a range of indexes.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we printed the second item on the list, which corresponds to
    index `[1]`, and the next two items.
  prefs: []
  type: TYPE_NORMAL
- en: 'With lists, we can also add items, replace items, delete items, check for the
    length, and more. To add an item, we need to use the `append()` method. Let''s
    add the `duck` item to our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the added item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our list now has `duck` at the end of the list. But let''s say
    we want to remove `bird` and substitute it with `butterfly`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to identify the index for `bird`. That index is `2`, as it is
    the third item on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output, with `bird` replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The list now contains `butterfly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an item is fairly straightforward, as we just use the `remove()` method
    and the item we want to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `lion` has been removed from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also remove an item by index using the `pop()` method. Using index `1`
    removes the second item on the list. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that Python identifies the item at index `1` that was *popped* out of
    the list. When we print the list again, the item is no longer there. If we want
    to remove the last item, we do not have to specify an index. Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, when no index is specified, the last item on the list is *popped*
    and removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is yet another way to remove an item from the list, by using the `del`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list lost the second item on the list. We can also use the `del` keyword
    to delete the list entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is the output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I can no longer print the list because it is not defined. Notice
    we received a `NameError` description of `name 'animals' is not defined`. This
    is one of the other errors mentioned in [*Chapter 7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100),
    *Identifying Challenges within Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: For the next few code examples, I ran my original code from the `ch8_list2.py`
    file again to get my original list.
  prefs: []
  type: TYPE_NORMAL
- en: We can clear an entire list without eliminating the actual list by using the
    `clear()` method, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the list now prints as an empty list without giving an error message.
    That's because the list is still there and defined, it's just empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say I wanted the length of my list. We can find the length of the
    list by using `len()`. Again, I went back to the original list to run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Our original list contained six elements – that is, six animals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define another list that contains colors:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_list3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output for this algorithm is two lists. Now, if we wanted to combine the
    two lists, we could do so using the `extend()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can append `colors` to the `animals` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the appended list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list now includes all our animals and all our colors. We could have also
    used the following method to extend `colors` with `animals`. The difference is
    that the colors would appear first on our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the list now appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also sort lists, which is helpful when we want to have an alphabetical
    list or if we want to sort a list of numbers. Take a look at the two lists in
    the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_list4.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how they appear unsorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s sort both lists and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the numbers were sorted from smallest to largest, while the
    animals were sorted in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk for a second about why this is so helpful. Imagine that you have
    a list of items displayed on your website that come from a Python list. They are
    all sorted and perfectly displayed. But let's now say you want to add more items.
    It's easier to add them in any order to your list using the methods we have discussed,
    then we can sort them so that they continue to be in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these are not the only things we can do with lists. Python allows
    us to work with lists in many ways that are user-friendly and function similar
    to what arrays do in other programming languages. When we need to use them in
    other ways, we can search for libraries that contain those functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Both lists and dictionaries are important in the Python programming language.
    In this section, you saw that dictionaries use key-value pairs, while lists include
    values. Both can be edited using methods and functions built into the Python programming
    language. You'll see them again when we apply Python to more complex computational
    thinking problems in *Section 3*, *Data Processing, Analysis, and Applications
    Using Computational Thinking and Python*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll take a look at how we use variables and functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, we use variables to store a value. We can then use the value to perform
    operations, evaluate expressions, or use them in functions. Functions give sets
    of instructions for the algorithm to follow when they are called in an algorithm.
    Many functions include variables within them. So, let's first look at how we define
    and use variables, then take a look at Python functions.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python does not have a command for declaring variables. We can create variables
    by naming them and setting them equal to whatever value we''d like. Let''s take
    a look at an algorithm that contains multiple variables:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_variables.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can use a letter, a longer name, and even include underscores
    in naming our variables. We cannot, however, start a variable name with a number.
    When we run this program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Each variable was printed without any problems. If we had used a number to begin
    any variable name, we would have gotten an error. However, if I had named the
    `country_1` variable as `_country`, that would be an acceptable variable name
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at what we can do with variables.
  prefs: []
  type: TYPE_NORMAL
- en: Combining variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing variables allow us to do is combine them in a `print` statement.
    For example, I can create a `print` statement that prints `Marcus Greece`. To
    do so, I can use the `+` character, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that between the two `+` characters, there''s `'' ''`. This is done
    to add a space so that our `print` statement won''t look like `MarcusGreece`.
    Now, let''s combine `b` and `name` in a `print` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the error states `TypeError: unsupported operand types for +`.
    It also states that we have `''int''` and `''str''`, which means we are combining
    two different data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to combine those two data types in a `print` statement, we can just
    convert `int`, which is our `b` variable, to `str`. Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This easily gives us the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've made them both strings, we can combine them in the `print` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we''ll want to create many variables at once. Python allows us to
    do that with one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_variables2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this algorithm, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we print the `a` variable, the first value to the right
    of the equals sign is printed. The first line of the algorithm assigned four different
    values to four different variables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at functions, as we'll need them to further our variables conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100), *Identifying
    Challenges within Solutions*, we wrote an algorithm that printed even numbers
    for any given range of numbers. We''re going to revisit that by defining a function
    to do that work for us. Let''s take a look at an algorithm for the even numbers
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_evenNumbers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If we run this program in Python, there is no output; however, we can now run
    the function for any range of numbers. Notice that we have added an `a` and `b`
    variable within this function. That's so that the endpoints are included when
    the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we run the program for the ranges `(2, 10)` and
    `(12, 25)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, instead of having to go inside the algorithm to call the function,
    once we''ve run the function, we can just call it for any range in the Python
    shell. As before, if our range is too large, the shell will show a really long
    list of numbers. So, we can define another variable, this time a list, and append
    the values to that list within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_evenNumbers2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we defined the list outside of the function. We can do it either
    way. It can live within the function or outside. The difference is that the list
    exists even if the function is not called; that is, once I run the algorithm,
    I can call the list, which will be empty, or call the function, which will use
    the list. If outside the function, it's a global variable. If inside, it only
    exists when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to run that now for the range `(10, 50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the even numbers between and including `10` and `50` are now
    included in the list and printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example of a function that takes a `(name)` string argument:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_nameFunction.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run this algorithm, we can call the function for any name. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s input another name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once a function is defined in an algorithm and the algorithm
    is run, we can call that function, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we did use an iteration in the previous example with even numbers, so it's
    time we started looking more closely at files, data, and iteration, so let's pause
    and take a look at that. As we get to iteration, we'll run into a few more function
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about files, data, and iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at how to handle files, data, and
    iteration with Python. This will give us information on how to use an algorithm
    to open, edit, and run already-existing Python files or new files. With iteration,
    we'll learn how to repeat lines of code based on some conditions, limiting how
    many times or under what conditions a section of the algorithm will run for. We'll
    start with files first.
  prefs: []
  type: TYPE_NORMAL
- en: Handling files in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, the main function associated with files is the `open()` function.
    If you are opening a file in the same directory, you can use the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file is in another location, you need to find the path for the file
    and include that in the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more things we can tell the program to do in addition to opening
    the file. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: Used to open the file for reading (this is the default, so it does not
    need to be included); creates a new file if the file does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Used to open the file for writing; creates a new file if the file does
    not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: Used to open a file to append; creates a new file if the file does not
    exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: Used to create a specified file; if the file already exists, returns an
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two more things that can be used in addition to the methods listed.
    When used, they identify how a file needs to be handled – that is, as binary or
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t`: Text (this is the default, so if not specified, it defaults to text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: Binary (used for binary mode – for example, images)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code. Since this code is a single line and specific
    to each path, it is not included in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the same as the previous code, `fOpen = open('filename.txt')`.
    Since `r` and `t` are the defaults, not including them results in the same execution
    of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to open a file for writing, we could use the `fOpen = open('filename.txt',
    'w')` code. To close files in Python, we use the `close()` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional methods for text files are included in the following list.
    This is not an exhaustive list, but contains some of the most commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read()`: Can be used to read lines of a file; using `read(3`) reads the first
    3 data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tell()`: Used to find the current position as a number of bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seek()`: Moves the cursor to the original/initial position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readline()`: Reads each individual line of a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detach()`: Used to separate the underlying binary buffer from `TextIOBase`
    and return it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readable()`: This will return `True` if it can read the file stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileno()`: Used to return an integer number for the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, you can use Python to manipulate and get information from text
    files. This can come in handy when adding lines of code to an existing text file,
    for example. Now, let's look at data in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Data in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into data, let's clarify that we're not talking about data types,
    which we discussed in [*Chapter 1*](B15413_01_Final_SK_ePub.xhtml#_idTextAnchor017),
    *Fundamentals of Computer Science*. For this chapter, we're looking at data and
    ways to interact with it, mostly as lists.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the things we can do with data.
  prefs: []
  type: TYPE_NORMAL
- en: First, grab the `ch8_survey.txt` file from the repository. You'll need it for
    the next algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you asked your friends to choose between the colors blue, red, and yellow
    for a group logo. The `ch8_survey.txt` file contains the results of those votes.
    Python allows us to manipulate that data. For example, the first line of the file
    says `Payton – Blue`. We can make that line print out `Payton voted for Blue`
    instead. Let''s look at the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_surveyData.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our code to understand what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line opens the survey file and keeps it open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line, `for line in file`, will iterate through each line in the file
    to perform the following commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm then takes the information and splits it at the dash. The first
    part is defined as the name (`name = divide[0]`) and the second is defined as
    the color (`color = divide[1]`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the code prints out the line with the `voted for` text added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you now have each line adjusted to remove the dashes and include
    the `voted for` phrase. But what if you wanted to count the votes? We can write
    an algorithm for that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_surveyData2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are counting the votes by verifying each line and using
    the `if color == "Blue"` code. When we run this algorithm, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the algorithm prints out the initial `print()` command, then
    prints the counted votes for `Blue`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also work with data to find things such as the mean, median, and mode,
    but we won't go over those now. If we need them in the future for one of our applied
    problems, we'll go ahead and use them. However, most of those data-specific problems
    will use libraries to simplify some of the algorithms and computations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk a bit more about iteration, which we've been using but will
    need to define further to better understand its use.
  prefs: []
  type: TYPE_NORMAL
- en: Using iteration in algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go into iteration, let's define the term. **Iteration** means repetition.
    When we use iteration in algorithms, we are repeating steps. Think of a `for`
    loop , which we've used in problems before, such as the even numbers problem—the
    algorithm iterated through a range of numbers. It repeated for all the numbers
    in our range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_colorLoop.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The iteration in this algorithm is that it will repeat the `print` process for
    each of the colors in the original colors list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each of the colors was printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get input from a user, then iterate to perform some operation.
    For example, take a look at the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_whileAlgorithm.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we defined `ask` as the input variable. Then, we printed double
    the number and reduced the number by `1` as long as `ask` was greater than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the list created by doubling the initial number, which is *8*
    x *2 = 16*, then continues until the `ask` variable is no longer greater than
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at how we can iterate through multiple lists. The
    algorithm uses two lists and then prints a single statement using information
    from both:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_Iterations.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the algorithm, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the `print` statement: `print("Type of jewelry:` `%s` `in` `%s`
    `color."` `%(j,` `c))`. The `%s` symbols will be replaced by the `(j,` `c)` values,
    respectively. So, the first `%s` symbol gets the items from `j` and the second
    `%s` symbol gets the items from `c`, where `j` is the item from the jewelry list
    and `c` is the color from the colors list.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can iterate through lists in multiple ways. These are only
    a few examples to get comfortable with loops and how to use information in our
    algorithms. As we dive deeper into more complex problems, the algorithms will
    get more sophisticated, so we'll revisit many of the topics in this chapter and
    earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, we need to look at **Object-Oriented Programming**
    (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: Using object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OOP is a way to structure data into objects. The Python program is an object-oriented
    program in that it structures algorithms as objects in order to bundle them based
    on properties and behaviors. To learn about OOP, we will need to know how to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use classes to create objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use class inheritance to model systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Python, we use classes to bundle data. To understand classes, let''s create
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call the `Books()` class and get the location where the class is
    saved on our computer. Notice that my output will not match yours, as the class
    will be saved in different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This is my output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve created the class, we can add book objects to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Each of these instances is a distinct object in `Books()`. If we were to compare
    them, since they are distinct, `a == b` would return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a class that creates an address book. By creating
    the class, we can add entries as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_addressBook.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In this algorithm, we''ve created an `Entry` class that stands for items in
    an address book. Once we run the algorithm, we can add entries to the address
    book and call information on them. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This code enters `Johnny` into the address book. Now, we can call Johnny''s
    first name, last name, and phone number separately, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'This is my output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the obtained output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also call for phone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add as many entries as we''d like, then call them as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the entries, we can call a last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added two new entries, then called Emma's phone number and
    Max's last name.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have classes, we can have one class that inherits methods and attributes
    for other classes. Because the classes are inheriting the attributes and methods,
    the original class is called the **parent class**, while the new class is called
    a **child class**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our address book, we can create a child class by passing the
    class to the new one. I know, it sounds confusing, but take a look at the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add more items using that child class as well. See the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We can do more with classes, but let's try to pull this chapter together by
    solving a problem and designing an algorithm that uses at least some of the components
    learned about.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 - Creating a book library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you have a lot of books and want to create an algorithm that stores
    information about the books. You want to record each book's title, author, publication
    date, and number of pages. Create an algorithm for this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s think about the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of books I own changes constantly, so I'd want to create something
    that I can add information to, as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also want to be able to remove books that I no longer own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we could use a library, the best solution for this particular problem
    would be a class. Let''s start by creating a class called `Books`:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_BookLibrary.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have our class defined. The class has four arguments: `title`,
    `author`, `pubDate`, and `pages`. After the definition, two books have been added.
    When we run this program, nothing happens, really, but we can then call information
    on either book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the publishing date of `book2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I can now call any of the elements saved for each of the books
    after I've run the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at how a third book can be added within the Python shell,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the book has been added, we can call information about this book as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the total pages of `book3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can add books to our class from within the algorithm, or
    after running the algorithm in the Python shell. Now, let's take a look at another
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2 - Organizing information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve been asked to create an algorithm that takes three numbers as input
    and provides the sum of the numbers. There are multiple ways we can do this, but
    let''s look at using the `eval()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_Sums.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we defined each of the input variables as an `int` type. This is
    defined so that the evaluation is done correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: If we had forgotten to add the type for each of the numbers, the function would
    have evaluated that as `123` instead because it just adds each string to the next
    one. So, if our input had been `John`, `Mary`, `Jack`, our output would have been
    `JohnMaryJack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously didn''t go into the `sum()` function. Let''s take a look at using
    that function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_Sums2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `sum` in this case requires that we add our inputs to a list, as `sum()`
    works with iterables, such as lists. Although this solution has more code, the
    output is exactly the same as our `eval()` function, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get the same answer as before using a different Python function.
    Let's look at one more problem before we move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3 - Loops and math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this problem, we have to create an algorithm that prints out the squares
    of all the numbers given a range of two numbers. Remember, we can print each individually,
    but if the range is large, it's best we have a list instead. We'll also need to
    iterate in the range, and we have to add 1 to the maximum if we want to include
    the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_SquareLoops.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we added a `j` variable to our algorithm. We didn''t use `i = i**2`
    because that would change the value of `i`, which would affect our iteration in
    the algorithm. By using `j`, we can then use `i` to iterate through the range
    given. Let''s look at our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm prints out our list of squares for the range provided. It also
    has an initial `print` statement that explains what the code will do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at a few examples, let's look at parent classes and child
    classes and how inheritance works.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, we can pass methods and properties from one class to another using
    inheritance. The parent class has the methods and properties that will be inherited.
    The child class inherits from the parent class. The parent class is an object
    and the child class is an object, so we are defining the properties of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how that works using a science example. We''re going to create a
    class called `mammals`. Not all mammals are viviparous. A mammal is viviparous
    when it gives birth to live young. A mammal that is not viviparous is the platypus.
    The platypus lays eggs instead of giving birth to live young. If we were writing
    an algorithm for this, we would want the animals to inherit the characteristics
    of the parent – in this case, `mammals`. Let''s take a look at the following snippet
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch8_mammals.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, notice that the `mammals()` class uses a description
    and then information about mammals and viviparity. `monkey` is defined using the
    same description as the `mammals` class, but then includes a different statement
    for viviparity. The same thing happens with `platypus`. The `monkey` and `platypus`
    classes are child classes of the `mammals` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three classes, the parent and the two children, are then simplified into
    a variable so that they can be used by calling that variable. Finally, the algorithm
    prints the description and viviparity statements for the parent and the two children.
    Let''s take a look at that output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all three classes used the same description. That's because
    we didn't make any changes to the description for the children. When we defined
    the classes, we only changed the parts we wanted to be different from the parent
    class. Everything else is inherited from the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Parent classes and children are widely used in Python for multiple purposes.
    For example, in gaming, you may have enemies that all have some of the same characteristics.
    Rather than defining each enemy with all the characteristics separately, we can
    create a parent class that includes all the common characteristics, then change
    the individual characteristics of all the enemies as child classes. This is just
    one of the ways in which inheritance can be used. There are many other uses and
    it helps us save time and avoid errors by only defining them with the parent classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had some experience with classes and learned about OOP, let's
    wrap up the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of Python programming. We looked at
    some of the built-in functions, worked with dictionaries and lists, used variables
    and functions, learned about files, data, and iteration, and learned about classes
    and OOP.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in this chapter and when solving previous problems, Python provides
    multiple ways for us to solve the same problems. One example of that is provided
    in the *Problem 2 - Organizing information* section of this chapter, where we
    used the `eval()` and `sum()` functions in two different algorithms to produce
    the same result. As we continue to learn about Python and how to write our algorithms,
    choosing which functions, variables, arguments, and more to use will start to
    become second nature. Some of the more challenging concepts and content in this
    chapter have to do with data analysis, such as the survey we used when introducing
    data in Python in the *Data in Python* section of this chapter, and classes. It's
    important to get some practice in those areas so that you can get a better understanding
    of those topics.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you can now work with built-in functions, distinguish between
    lists, dictionaries, and classes, and solve problems that combine multiple different
    concepts, such as variables, iterations, and lists. In the next chapter, we will
    be looking at input and output in more depth to help us when designing algorithms.
  prefs: []
  type: TYPE_NORMAL
