- en: Chapter 5. Proxy Operations with OWASP ZAP and Burp Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web servers and applications are exposed to the internet more than most other
    enterprise applications: they have to be available andÂ serveÂ their end customers.
    Because of this, defenders have been taught to view user traffic (surfing the
    site, interacting with the dynamic content, and so on) as normal, so long as it
    follows behavioral norms. Their defenses will focus on broad-based interactions
    while letting the slow trickle of *normal* user activity slide. Effective pen
    testers will mimic this behavior whenever possible to learn as much as they can
    about their target before launching later, more intrusive stages of the Kill Chain.'
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in [Chapter 4](000.html#), *Scanning for Vulnerabilities with Arachni*,
    specialized scanning tools can be a double-edged sword. For one thing, most scanners,
    Arachni included, specialize in looking for vulnerabilities by both passive and
    active means. Both are helpful, but as you are probably well aware, they come
    at the expense of cost in time and stealth in the case of active scans. In addition
    to the resource needs and timing required, we must also consider our own workflows
    versus the level of stealth required. Significant intelligence can be gleaned,
    but if the tailoring of the profiles isn't precise, you risk alerting your target's
    operators and being detected. Too often, early-in-career pen testers will unleash
    an Nmap scan or some other active recon tool only to discover that their noise
    has ruined their chances of going further.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning-focused tools also require some conversion of findings into later-phase
    operations, and they also have holes in their ability to detect. Most scanning
    tools will not take action on your behalf. These caveats may be okay in a white-box
    testing scenario where you are handed carte blanche to test a web application
    without the fear of being caught. In black-box scenarios, where the pen test is
    more likely to be conducted by a Red Team (acting as an outside attacker), more
    surgical precision is warranted. Many of you may have noticed that most scanning
    or *spidering* tools have blind spots, especially around new content delivery
    paradigms such as those encountered with JavaScript or Ajax,which Â dynamically
    create the content rather than relying on stored HTML. For these cases and many
    others, it makes sense for us all to to have an alternative toolset or two in
    your arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: The Proxy-based tools offers us a complimentary tool that cannot only conduct
    scans but also pivot into exploits and access within the same tool. These products
    act as a proxy between the client-side (browser) and server-side (the web tier)
    elements . By sitting in the middle of this critical link, we're able to scour
    the message traffic between the two sides and observe or even modify and attack.
    Proxy tools have the added benefit of allowing us to modify requests after they
    have passed some validation, so we can evade some of the basic JavaScript and
    HTML restrictions the application may have in place.
  prefs: []
  type: TYPE_NORMAL
- en: You may already be using some of these tools in your arsenal; there is no doubt
    that the market is saturated with both open source and commercial alternatives.
    Our goal in this chapter will be to go a little further with two of the most popular
    alternatives included with Kali Linux â�� **Burp Suite** by [https://portswigger.net/](https://portswigger.net/)Â and
    OWASPs own **Zed Attack Proxy** (**ZAP**). Both tools are free to use with the
    included binaries, but we'll also see just how much the Burp Suite Professional
    version can add to the mix. It is my hope that we'll cover some more advanced
    techniques for leveraging these proxy-based tools that you can then use to improve
    your own process, deliver better results, and help secure your customers more
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping these high-level goals in mind, in this chapter we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting the differences between the two leading proxy tools, Burp Suite,
    and OWASP ZAP (formerly zaproxy) with Paros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into using Burp's Proxy and Scanner and ZAP to scope and detect vulnerabilities
    in the OWASP Top 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to leverage Burp's Active tools to enumerate information and exploit
    vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing access control and session management through fuzzing and Burp Repeater
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncovering and exploiting injection flaws, input validation, and applicationÂ logicÂ vulnerabilities
    using Burp Suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling back the curtain withÂ ZAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP's suite of tools are well worth learning â�� their platform-agnostic approach
    means you can use these tools anytime, anywhere without worrying about which operating
    system you are on. Luckily for us, Kali bundles it by default. Even more helpful
    to us as testers is OWASP's leadership in the Web Application Security arena.
    Their insights and guidance make it into each iteration of the ZAP ([https://www.owasp.org/index.php/ZAP](https://www.owasp.org/index.php/ZAP))
    tool, so we can be certain that we're getting leading edge vulnerability and exploit
    information incorporatedÂ into the tool as it is discovered.
  prefs: []
  type: TYPE_NORMAL
- en: As with any tool in Kali, you've likely already used ZAP in your studies or
    work, but there are some advanced techniques that can be employed to improve the
    reach and efficacy of ZAP in your toolset. ZAP can either actively scan the target
    (which is the approach used by their **`Quick Start`** tab) or can be used as
    a proxy tool to capture, iterate, and fuzz sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'ZAP''s proxy functionality scan can be extended through its **`Tools`** menu
    to scan, spider, or fuzz applications as well. ZAP is acting as a web proxy, typically
    on the same host as the tester''s browser. Â  The following screenshot shows how
    ZAP fits into the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: OWASP's ZAP is our MITM that can slow down and replay server-client interactions.
  prefs: []
  type: TYPE_NORMAL
- en: While most web application black-box scenarios can be tackled by deploying our
    proxy MITM on the same host, it should be noted that with the advent of the internet
    of Things and a move toward using web applications to serve these devices, we
    may use ZAP or Burp in proxy mode, where the client is actually an embedded web
    client on a smart device (for example, television, camera, thermostat, SCADA sensor,
    pump or motor, and so on). Some companies are predicting that the internet will
    seeÂ 50 billion devices connected by the year 2020, and while that was initially
    dismissed as overzealous, it may actually be quite understated. Given just how
    many manufacturers seem to be having mixed luck in securing them (see the **Mirai
    Botnet**, for instance), it is worth considering this use case for when the opportunity
    arises. Hackers are nothing if not entrepreneurial!
  prefs: []
  type: TYPE_NORMAL
- en: Quick refresher on launching ZAP scans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can get into the more advanced functions of ZAP, let's quickly get
    a baseline project up-and-running with a persistent project (which saves data
    between sessions). Assuming you have already configured your browser to point
    to ZAP as the proxy (mine is configured for `localhost:8080`), we'll target the
    **Mutillidae**Â application, which is similar to the **DVWA** but offers some
    greater depth, located at `http://172.16.30.129/mutillidae/`. I have also configured
    my client to trust certificates from ZAP by importing its Root certificate to
    ensure that I do not run into issues with **SSL/TLS**, although this is not likely
    in this test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: There are a host of training and archived applications available on the **OWASP
    Broken Web Application** VM, including **DVWA**, **WebGoat**, **Multillidae**,
    and so on.Â  If you can only run one on your next trip alongside your Kali VM,
    then it would be the best one to have. For more focused testing, I recommend finding
    the latest vulnerable VMs at [http://www.vulnhub.com/](http://www.vulnhub.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Going active with ZAP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we want to run an active scan, we can simply enter the DVWA's address in
    the URL to attack the application and click **`Attack`**. Many use this feature,
    but understanding the scans can help you better use the tool and pick the correct
    combination of functions to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: A quick scan reveals tons of vectors, but one of the most pressing is those
    pesky passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The Sites panel maps the site, showing files and the directory structure, as
    seen in the previous screenshot. In the lower window, we'll notice that **`Alerts`**
    are grouped according to their type, and ZAP makes pivoting into follow-up actions
    pretty easy. We can see differently colored flags for each URL corresponding to
    the concern level of the associated vulnerability and a spider symbol denoting
    it was learned via the automated **`Spider`** function. As we visit these locations
    through our browser, the spider will disappear as we get greater fidelity while
    interacting with the site. Scanning can save time, but the automated spidering,
    as with any active technique, tends to be a blunt tool rather than a fine-tuned
    instrument. If you already have some ideas as to what you are after, focusing
    these scans on smaller portions of the target will pay dividends in stealth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In either case, we see more web-based security issues in Mutillidae than the
    other applications on the BWA image, and one of the most egregious is the **path
    traversal** issue that seems to allow us to expose the `/etc/passwd/` contents.
    We can use the contextual menu to highlight and readÂ about the vulnerability
    or even launch the flagged URL in our browser, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Oh boy, we need to have a talk with the customer about some passwords â�� after
    we finish the test.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this treasure trove of password information came with minimal
    effort, not always the case (once can hope),Â but every alert provided by ZAP
    offers a thread we should pursue in our penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Passive ZAP scanning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Passive scanning** is a non-obtrusive means by which we can map out and learn
    about the structure of the site and the code that results in interacting with
    it. Passive scanning does not allow for an in-line modification of the HTTP messages,
    but a full inspection of the unmodified headers and content allows ZAP to provide
    insights. And it will build alerts and tags just as if they were generated through
    active scanning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have only two areas for configuration with Passive scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one focuses on the sensitivity of the scanning engine. We can visit
    theÂ options, the**Â ****`Passive Scan Rules`** screen****`,`**** as seen in the
    following screenshot and select **`Off`**, **`Low`**, **`Medium`**, or **`High`**Â to
    alter the threshold for alerting on each type of vulnerability. **`Off`** disables
    scanning and alerting entirely, **`Low`** provides the highest level of sensitivity,
    while **`High`** focuses only on the most definiteÂ vulnerabilities to flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Passive scanning can omit or scrutinize a myriad of test types, depending on
    our need.
  prefs: []
  type: TYPE_NORMAL
- en: The second area of configuration for passive scanning is our ability to tag
    according to specific regex expressions or header information, seen in the following
    screenshot. Why is this useful to us?Â  When we have some idea as to what we are
    looking for in a particular page, we can create custom tags that allow ZAP to
    identify patterns we are after. The default tag pattern for passwords in ZAP,
    as shown in the following screenshot, may work just fine for passwords, but what
    about when we discover that our target changed things up by replacing the field
    name with *passphrase*Â or *secret*? This tagging customization can be used to
    glean other interesting information as well, and it gives us all a good reason
    to brush up on our regular expressions or **regex**Â syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Tags can be added or modified to help us uncover our target's own secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting fuzzy with ZAP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ZAP has the ability to modify or **fuzz**Â requests on their way to the web
    application, and this can be a great tool for testing input validation, application
    logic, a multitude of injection vulnerabilities, and error handling. Fuzzing attacks
    add some automation to otherwise tedious, laborious, and iterative tests, focusing
    on bugs applying toÂ how requests are processed. The built-in Fuzzing payloads
    are reasonably straightforward but can be extended through the use of add-ons
    or even custom scripts. A great resource for advancing your fuzzing skills on
    ZAP is the **OWASP's OTG Appendix C** located atÂ [https://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors](https://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors).
    We can launch the fuzz action from almost anywhere within ZAP, simply by right
    clicking on **`Alert`**, **`History`**, or **`Request`** entry for the link you
    plan to fuzz, as seen in the followingÂ screenshotÂ when we hit the Mutillidae
    site again (the application is taking some serious abuse!). Your objective should
    be to look for any spider results or browsing operations that result in requests
    or responses where variables are passed between a client and a server and look
    for opportunities to test the limits of what is accepted. In this case, we think
    we might have some opportunities to tackle the login application and test for
    some SQL injection/input validation vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Kicking off a fuzz attack can be done from almost anywhere in ZAP.
  prefs: []
  type: TYPE_NORMAL
- en: We can then pick a field to fuzz and add a location for the payload we want
    to deploy (Mutillidae points out several test vectors in their *practice* mode,
    so I would encourage trying others as well).
  prefs: []
  type: TYPE_NORMAL
- en: To read on the multitude of vulnerabilities that OWASP's Mutillidae web application
    provides, you can read the SANS guide that explains the origins, purpose, and
    inner workings of the applicationÂ atÂ [https://www.sans.org/reading-room/whitepapers/application/introduction-owasp-mutillidae-ii-web-pen-test-training-environment-34380](https://www.sans.org/reading-room/whitepapers/application/introduction-owasp-mutillidae-ii-web-pen-test-training-environment-34380).
  prefs: []
  type: TYPE_NORMAL
- en: To start, we're going to use the **JBroFuzz** add-on to provide a file fuzzer,
    meaning that JBroFuzz will bring a bunch of lists in various categories to try.Â 
    Password, directory, and username lists are common, but so are handy strings for
    various SQL queries that might be useful to try. These steps are shown in the
    followingÂ screenshot.Â When testing robust web applications, it is also useful
    to test against common browser URIs and HTTP versions to see if there is a point
    where you can force a downgrade in posture so that the application can accommodate
    your *out-of-date* browser or operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the fuzzing payload is a simple process.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what boxes you check and fields you highlight, you will see that
    ZAP begins to exhaustively test these vectors against the page or field. In the
    **`Fuzzer`** tab, you'll notice all of the results. If you see one that is of
    interest, by all means, right-click on it and attempt to launch it in your browser.
    What we are looking for here are differences. Why did entry **`41`** in the followingÂ screenshotÂ result
    in a **`302`** response and a larger byte count? It would seem that the fuzzing
    process resulted in a different result for that test string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzing Results quickly focus our attention on a small set of strings.
  prefs: []
  type: TYPE_NORMAL
- en: In the top right-hand side panel, you can review both the header and the body
    code or information, and as we see in following figure,Â we have some interesting
    differences that we can record for future testing and analysis. We can see a seemingly
    harmless payload `1 exec sp_ (or exec xp_)` result on the left, and the result
    of passing the payload `â�� or username is not NULL or username = â��` on the
    right.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzing Results quickly focus our attention on a small set of strings.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see now, this would seem to indicate that something about the right-hand
    side's payload found a different response--these cracks in the application's armor
    can be all thatÂ we need to get a foothold and compromise our target. Once you
    have fuzzed any field of interest, it is common to fuzz combinations of fields
    as well to conduct a brute force attack for simple credential-based authentication.
    OWASP's ZAP can certainly help with these follow-up tests as well. Similar capabilities
    can be found in other Kali-bundled testing toolsets such asÂ **w3af,****WebScarab**,
    and the venerable classic, **Paros**. It is worth our time as practicing penetration
    testers to have at least a couple of these well understood.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it to a new level with Burp Suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP is a great open source introduction to proxy-based scanning and fuzzing.
    That being said, most testers have already found that additional tools are necessary
    to carry out a complete test, for reasons like having the ability to cover more
    input vectors, cover additional content types like Flash and Webservice vulnerabilities,
    and automate more report and audit processes.Â More can be learned about the many
    toolsets at **SecToolMarket.com** ([http://www.sectoolmarket.com/price-and-feature-comparison-of-web-application-scanners-unified-list.html](http://www.sectoolmarket.com/price-and-feature-comparison-of-web-application-scanners-unified-list.html)
    ).Â The effort to coordinate with outside toolsets to complete anything more than
    a small penetration test is more trouble that is worth. A large number of newer
    proxy-based **Dynamic Application Security Testing** (**DAST**) frameworks have
    sprung up to answer the call. These solutions range from free to extremely costly,
    likely to be used by large enterprises or those pen testers that they hire. Many
    of these platforms run on Linux, Windows, and even Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux conveniently bundles the free version of one of the leading tools
    in the Linux realm;Â **Burp Suite** ([https://portswigger.net/burp/](https://portswigger.net/burp/))
    was created by *Daffyd Studdard* and maintained by his company called **PortSwigger**.
    Burp Suite's architecture includes the proxy and fuzzing capabilities of the other
    toolsets, but extends those functions through built-in tools that more completely
    scan, fuzz, and otherwise interact with the target environment. Burp Suite can
    compare site maps and automate many other tasks that are manual for ZAP, w3af,
    and other Kali-bundled tools, and it covers almost the entire OWASP OTG. Some
    of these tools, which we'll discuss at length, are either disabled or limited
    in the free version, as seen in the following screenshot**.**Â I would highly
    recommend obtaining a subscription to Burp Suite Pro ($349 per user per year as
    of the time of this writing) as at this price, you receive frequent updates, outstanding
    support, and one of the most cost-effective web pen test tools on the market,
    and you can use it on Kali (or other forms of Linux), Windows, and Mac OS as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: A comparison of Burp Suite Free and Professional Editions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the user-driven workflow that Burp Suite is geared to support
    helps testers understand theÂ differences between editions and decide how Burp
    Suite will support their own tailored processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is adapted from the figure located atÂ  [https://portswigger.net/burp/help/suite_usingburp.html](https://portswigger.net/burp/help/suite_usingburp.html)
    but presented here to more clearly outline the portions the **Professional Edition**
    adds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite's architecture supports a full pen test workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about the pieces preceding, we'll quickly review the setup and configuration
    of the Proxy and Spider, and then quickly move into the more advanced capabilities
    that Burp offers that provide automation across the entire pen test process.
  prefs: []
  type: TYPE_NORMAL
- en: Recon with Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with any proxy tool, we'll need to configure our browser's settings to use
    the appropriate IP address and port number (typically using IP address `127.0.0.1`
    and port `8080`). Luckily for us, the same configuration works for both ZAP and
    Burp, unless you are planning to chain the proxies. This might be necessary if
    you have the need to pass traffic through multiple tools or use an external proxy,
    and details of how you can do this with Burp in the picture are discussed atÂ [https://portswigger.net/burp/help/options_connections.html](https://portswigger.net/burp/help/options_connections.html).Â The
    OWASP **Broken Web Application Virtual Machine** (**BWA VM**)Â includes multiple
    applications for testing and training, and we want to focus on just the OWASP
    Mutillidae application, which provides plenty of fodder for our practice.Â
  prefs: []
  type: TYPE_NORMAL
- en: Stay on target!
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you are already probably aware, the recommended approach to beginning recon
    is to manually map the target with the Proxy's Intercept function turned off to
    begin with.Â  As we click through various pages and submit gibberish in forms,
    we'll populate the **`Target`** tab's **`Site map`** subtab. Right-clicking on
    any domains or IP addresses of interest here allows us to add the host to the
    scope of our analysis. We can also add targets manually toÂ **`Target Scope`**
    (have a look at the following screenshot), but both methods give us the opportunity
    to focus the analysis on just that application, as shown in the green box--anything
    that is defined within the scope, you need to understand Burp will be attacking
    for you! You can also omit certain types of content from the scope (inside the
    red box), but in this case, we'll just leave the defaults in.
  prefs: []
  type: TYPE_NORMAL
- en: These defaults will ensure we aren't wasting our time looking into the logout
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: Target Scopes are a huge productivity enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we going through this trouble? Automated tools need some help.Â  If
    you turn them lose without constraints, you run the risk of breaking your target
    with unnecessary traffic or inflicting collateral damage to sites outside of your
    charter--both are bad for business! Manual mapping is akin to a walk through,
    and it allows you and your team to better understand what technologies might be
    in play and how the site's workflow impacts the user interaction. We need to do
    a better job answering some questions up front that can ensure more relevant results
    later on. Where is the site trying to funnel users? What services are offered?
    What forms can we flag as interesting for deeper analysis? You get the idea and
    probably gain an understanding of this in your own work. It is important that
    Burp Suite also understands this to be more effective on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you come to the close of your passive and manual mapping, you can certainly
    gain some assistance from Burp in finishing the exploration. Gray sites in the
    **`Target`** tab and theÂ **`Site map`**Â subtab are the links that have been
    learned but not visited, so if there is anything you believe to be gained by visiting
    them, by all means go for it!Â  You can also activate **`Content discovery`**
    to allow Burp to try to discover directories, templates, or other latent hidden
    files and folders that may have gone unlinked or are no longer active but are
    still stored on the server. This is done simply by right-clicking on the host,
    selecting **`Engagement Tools`**, and then **`Discover Content`**, as seenÂ here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Content Discovery can help find the hidden or forgotten content.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have kicked off **`Content Discovery`**, you have the opportunity to
    select the built-in or custom word lists that are used for the automated discovery
    action (look at the following screenshot). Content discovery is really a special
    spidering function, which is in effect looking for pages and folders that aren't
    linked, whereas a Spider session is focused on following all links until the site
    is fully mapped. Here weÂ can decide whether case sensitivity is observed (which
    increases the number of operations to fully enumerate all possibilities. We can
    also specify the file types and extensions of interest, the number of threads
    and connections to be used, and even whether we want Burp's content discovery
    to Spider out from those hidden artifacts and dive into anything those links may
    point to.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend using the **annotating** features in Burp. The left-most
    field of any finding in a content window can be color coded using a dropdown,
    and you can also double-click to add comments. When working a complex target or
    as part of a team, these tools can keep you organized and prevent unnecessary
    rework.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Tailoring Content Discovery's options.
  prefs: []
  type: TYPE_NORMAL
- en: The **`Content discovery`** tool will then exhaustively test for all potentially
    untapped or hidden content meeting the criteria you've established (look at the
    figure following), and you can view this in the **`Site map`** subtab of the **`Content
    discovery`** dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using the filters at any chance you can get. Site maps, in particular,
    are a fantastic tool for reducing your information into only that which is of
    interest to you. Simply click on the ****`Filter:`**** dialog and adjust settings
    to ensure you are filtering all of the non-essential information out.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Content Discovery helps complete the Site map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting particular with proxy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, we are ready to begin to use the more automated tools.Â  You may have a
    preference as to whether you activate the Proxy Intercept or pivot into the **Burp
    Spider** first, but I tend toward using **Burp Proxy** and avoiding *spider* unless
    it is a white-box test and the customer is expecting us. With the passive and
    manual mapping in the target phase, proxy should be able to help us now focus
    on those areas of the application that we've flagged as potential soft spots in
    the target's armor. Proxy can be activated by simply toggling to *Intercept is
    on*Â in the **`Proxy`** tab's **`Intercept`** subtab.
  prefs: []
  type: TYPE_NORMAL
- en: As you surf your sites,Â **`Proxy`** will intercept these requests and allow
    you to change any of the fields for your own use. This can be pretty labor intensive,
    so be sure to limit this hands-on process to only those portions of the application
    that you believe need a human's touch or as a means by which to familiarize yourself.Â 
    As soon as you believe the further analysis or investigation, right-click on the
    Proxy's **`HTTP history`** tab (look at the following screenshot) and hand the
    form or URL over the task to another tool in the Burp Suite to make better use
    of your time. If, for example, you needed to attempt multiple iterations of a
    form modification, **Burp Repeater** can offer that and track multiple such requests
    all at once. If you would prefer to launch automated attacks, Burp Intruder can
    tackle those on your behalf. **`Sequencer`** and **`Comparer`** can also be launched
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_16.png)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite makes pivoting from Proxy analysis easy.
  prefs: []
  type: TYPE_NORMAL
- en: Going active with Spider
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Burp Spider** is a quick and convenient tool, but I recommend caution. Spidering
    can help speed up any pen testing processes, but the tool''s own author recommends
    using it only for portions of very large applications or where time is of the
    essence and the risk is outweighed by schedule.Â  That said, it is well worth
    understanding and having in your repertoire in case it is needed.Â  The good news
    is that all of us have plenty of time to master it.Â'
  prefs: []
  type: TYPE_NORMAL
- en: Spider's configuration is located on a single tab (look at the following screenshot),
    and gives us access to settings that can help us limit the impact of this noisy
    tool on our targets, automatically generate form filling data, attempt login,
    and pass special browser request headers.Â  The one setting I would avoid altering
    is the **`Passive Spidering`** settings. Unchecking the **`Passively spider as
    you browse`**Â box prevents Burp from automatically identifying links and content,
    as you use other tools in the suite like proxy or target. Assuming you have all
    of your settings how you like them, you can kick off the active spidering session
    in the **`Control`** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: Spidering Settings are useful, but leave Passive alone unless you are certain!
  prefs: []
  type: TYPE_NORMAL
- en: Burp's **`Target`**, **`Spide`****`r`**, and **`Proxy`** tools all provide fantastic
    reconnaissance of the target and contribute to a consolidated site-map and catalog
    of potential vulnerabilities for us to investigate. Though site maps and organized
    lists of issues can assist in the latter phases of our testing, you can't test
    what you can't see or don't know exists! Now that you've gathered all of this
    information, you probably want to do something with it.
  prefs: []
  type: TYPE_NORMAL
- en: Activating Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What makes Burp Suite so valuable to us as a primary tool is that we can quickly
    move from the recon phase and into the exploitation phase of the testing, allowing
    us to validate our findings without having to manually coordinate with an outside
    tool. In this section, we'll see how Burp's **`Scanner`**, **`Intruder`**, **`Repeater`**,
    and **`Sequencer`** can help dig into the working list of vulnerabilities and
    help us scope the damage (or potential damage) to our targets. The problem with
    some pen testing methodologies is that those developing them are under the impression
    that more tools indicate better results. Peers of mine who have years of experience
    in smaller firms or teams, however, find that they see greater coverage, more
    coherent reports, and much fewer errors and heartache when using fully integrated
    tool suites. Your mileage may vary, but the integration and operation of a collection
    of tools where a consolidated toolset already exists is probably a task best suited
    for larger pen test teams.
  prefs: []
  type: TYPE_NORMAL
- en: All four of the tools in this section can be initiated from almost any site
    map or menu in Burp, and it is likely you have used Intruder and Repeater in the
    past. We'll review them here with some recommendations for the best way to deploy
    them for your testing. Keep in mind though â�� some of the fun specifics of going
    after a specific attack vector (**SQL Injection**, **Cross-site Scripting** and
    **Request Forgeries**, and so on) will be covered later in focused chapters on
    each subject, with Burp Suite as one of the tools we'll use to pursue them.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for life (or vulnerabilities)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**`Proxy`** and **`Spider`** help build the site map, but what about testing
    pages, forms, and the like for whether they are vulnerable?Â  The most broad-brush
    tool we can employ is **Burp****Scanner**.Â  Make no mistake--scanner can take
    a very active role and initiates what amounts to an attack on the targets in its
    active modes. For these reasons, please ensure you have narrowed your scopes and
    are cognizant of exactly what hosts you are unleashing Burp Scanner to do, especially
    when engaging the active scanning capability. I am convinced that it is for these
    far-reaching implications that Scanner was reserved for the professional license.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using Burp Suite Professional Edition, I still recommend understanding
    the capabilities and value Scanner offers to possibly help justify its expense;
    but at the very least, provide a bar with which you can measure your chosen scanning
    alternative, whether it be Accunetix, w3af, ZAP, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: For what it is worth, it is impossible to cover all of the alternatives in a
    single tome and still make a useful book. Pen testing, much like any other technical
    field, sees multiple solutions to the same problem; and as with those other fields,
    the tools selected and methods used will vary based on the backgrounds and proficiencies
    of the users and requirements of the job. I encourage you to practice with the
    tools discussed in depth here and entertain alternatives as your own needs dictate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick survey of colleagues conducting regular pen tests showed that while
    many use Burp Suite and Scanner, in particular, most had not stopped to think
    about what each tool was doing in the grand scheme of things. A quick review:
    Scanner works by taking cached requests that have been observed in the recon phase
    and modifying them to test for disclosed vulnerabilities that may exist in the
    underlying code. Through expressed behavior, scanner can verify the absence or
    presence of a vulnerability. In the process of these many operations, it is likely
    that the target will be compromised, so it is imperative that we have permission,
    understand the implications, and have taken steps to both warn the customer and
    secure the server should any testing prove detrimental to their posture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp''s Scanner tool is also different from others in the market, in that,
    while those scanners often crawl and scan at the same time, Burp Scanner offers
    two distinct modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive mode**: Scanner is typically working behind the scenes in passive
    mode, observing the traffic we are generating, and evaluating the requests and
    responses in real time. Why is this a good thing? First, it allows us to drive
    the scanning and interact with the application when a dialog (credentials, form
    entry, and so on.) is required, and thus goes further into the application''s
    inner reaches.Â  Second, it requires no work on our part--simply interacting via
    the browser engages the passive scanning mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active mode**: In an active mode, a scanner can both conduct live active
    scans as you surf the website and can be initiated manually through the context
    menu to pursue vulnerabilities on a page or fork of the application after some
    configuration via the wizard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should also note that a scanner is capable of testing against known vulnerabilities
    of both the server and client-side code; and this is very useful, in that, it
    allows us to prove a comprehensive report to our customers that helps them see
    the application's performance holistically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanner''s capabilities help set Burp apart from other DAST tools for three
    key reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side vulnerabilities can be much less accurate with other tools because
    many of these errors stay local to the server-side environment and are never reflected
    in the client, thereby avoiding detection by testers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanner also focuse on testing for vulnerabilities that it has a good shot of
    actually testing with authority, such that those vulnerabilities that are, at
    best, inaccurately discovered here are omitted to ensure Burp's output can be
    trusted and free of false positives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanners can quickly allow pivots into the other tools in the suite (without
    a need to configure or transfer data) such that there is always another path available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now that we understand scanner's strengths and our responsibilities, let's
    take a look at using it more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Passive scans are a no brainer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Chances are you have all been using this aspect of scanner in your own work,
    but just in case it was turned off or misconfigured, we can first check to see
    if the Passive scanning is turned on by visiting the **`Scanner`** tab''s **`Live
    scanning`** subtab, as seen inÂ here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_18.png)'
  prefs: []
  type: TYPE_IMG
- en: Passive Scanning configured to scan all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: To select which aspects of that traffic are scanned by the passive mode **`Scanner`**,
    you visit the **`Options`** subtab and turn on or off eleven categories as shown
    inÂ the following screenshot. I recommend leaving all of them checked unless a
    category is outside of the scope. Passive scanning is only implemented on pages
    you are visiting and interacting with, and there is minimal risk that the scan
    will result in collateral damage.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_19.png)'
  prefs: []
  type: TYPE_IMG
- en: Passive Scanning can observe most areas of the interesting traffic.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following screenshot, passive scanning captures several
    potential vulnerabilities and provides both an explanation of the issue and potential
    remediation steps as well as the original request and corresponding response information,
    including the headers, any associated HTML or XML, and so on.Â Not too shabby
    for what amounts to a free scan that poses no additional time requirements or
    resources!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_20.png)'
  prefs: []
  type: TYPE_IMG
- en: Scanner's results are descriptive and complete and offer remediation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Active scanning â�� Use with care!
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned earlier, active scanning is an attack on the target.Â  Please be
    certain of your target, the permission to actively scan and compromise it, and
    of your ethical and legal responsibilities should you find something unexpected
    or serious enough to warrant immediate disclosure to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like Passive scanning, you can first check to see if the Active scanning
    is turned on by visiting the **`Scanner`** tab''s **`Live Scanning`** subtab.Â You
    can choose to deactivate it, run it using the target scope, or even a custom scope.
    You can then configure the many potential vulnerability types and engine tweaks
    on the **`Options`** subtab as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_21.png)'
  prefs: []
  type: TYPE_IMG
- en: Active scanning options cover the engine, optimization, and vulnerability areas.
  prefs: []
  type: TYPE_NORMAL
- en: The ****`Active Scanning Areas`**** section allows you to deselect vulnerability
    types in the event you have already covered them in another toolset. You can also
    select subsets of events to concentrate on a specific set (common in white-box
    testing) or to conduct an incremental test.
  prefs: []
  type: TYPE_NORMAL
- en: Manual active scans can follow the same path, but are initiated by us rather
    than automatically engaged, as in the following screenshot. This might be the
    best middle ground--all of the power of an active scan, but only aimed at explicit
    paths or pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_22.png)'
  prefs: []
  type: TYPE_IMG
- en: Manual Active scans can be explicitly focused on any host, page, or folder.
  prefs: []
  type: TYPE_NORMAL
- en: In both the active scanning techniques, the scans will be added to the **`Scan
    Queue`** subtab; and when you are satisfied that you have queued enough active
    actions, you can select as many scans as you desire, right-click, and resume the
    scanning.Â  The **`Scan Queue`** subtab will report all the progress (look at
    the following screenshot), and you will see considerable resource demands as your
    **`Scanner`** processes iterations against all selected pages to fully qualify
    any vulnerabilities on those pages.Â
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_23.png)'
  prefs: []
  type: TYPE_IMG
- en: Active Scan progress against all queued actions.
  prefs: []
  type: TYPE_NORMAL
- en: The results ofÂ **`Scanner`** are what we came for (as shown in the following
    screenshot). Burp provides us with the listing, and each one is available with
    a description and follow-up actions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_24.png)'
  prefs: []
  type: TYPE_IMG
- en: Active Scanner results are shown with all relevant information at our fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: The flight of the intruder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Burp Suite also includes some more focused tools and the Intruder is one that
    allows for some serious automation of field manipulation, which is really useful
    for things like injection attempts and brute-force attacks. **Intruder** is a
    fuzzer on steroids. When we find an HTTP request that looks like a good candidate
    for any of these sorts of attacks, we can identify the fields (Burp calls them
    **positions**) we think can be tweaked and then ask Intruder to apply what Burp
    calls **payloads** to each of them, which are either from prebuilt lists or generated
    through some tried-and-true algorithms. Because intruder can do this across multiple
    positions, it is a huge time saver for us and provides exhaustive test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Intruder's versatility is a huge help. It can assist us in revealing account
    names (usually by running potential lists and observing varied responses). Intruder
    can also apply these techniques to iterate for a wide variety of fields on each
    account such as address, phone number, social security numbers, banking information,
    and so on, which they may associate with the user's account or profile. Lastly,
    just to be sure we're getting all we can out of the tool, Intruder is also a fully-featured
    fuzzer for vulnerability hunting, such as injection attacks or input validation
    issues. Mastering intruder's capabilities can be a huge force multiplier for us
    in our own testing, and luckily for us, it is a pretty straightforward tool.
  prefs: []
  type: TYPE_NORMAL
- en: Stop, enumerate, and listen!
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we're using intruder to enumerate single fields, most commonly, usernames
    or account IDs, the process is pretty straightforward. I'll try and hit Mutillidae's
    login page (shown in thefollowing screenshot) and see if we can figure out what
    sorts of usernames we can unearth. I'll slap in some gibberish, just to trigger
    a request/response pair in Burp Proxy (the intercept is on), and unless I am really
    lucky, get an *Account does not exist*Â message.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_25.png)'
  prefs: []
  type: TYPE_IMG
- en: Anything will do in these fields to start, we just need to see the request!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **`Proxy`** tab and theÂ **`HTTP History`** subtab, I can see my **`Request,`**
    complete with the gibberish that I filled in before clicking send. I can right-click
    on this request as shown in following figureÂ andÂ clickÂ **`Send to Intruder`**
    for some serious enumeration kung-fu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_26.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's Send this request to Intruder for Enumeration awesomeness.
  prefs: []
  type: TYPE_NORMAL
- en: We should see the **`Intruder`** tab's name turn a shade of orange-â��this means
    a new intruder request is queued up and ready for action! In the first tab (not
    shown) we can see that the IP address and port of the server are pre-filled.Â 
    Moving to the **`Positions`** subtab, you'll select the **`Sniper Mode`**; and
    you'll want to clear all fields (intruder, asÂ helpful as it maybe, wants to volunteer
    to guess all of the Positions),Â and then just select the username gibberish and
    click **`Add,`** as seen in in the following screenshot.Â You'll notice that any
    field you add will now add `Â§` to the beginning and end of each position (`asdf`
    now reads `Â§asdfÂ§`) and highlight it in orange. If we were going to try and
    fuzz a field for vulnerability scans, we'd instead select a suitable position
    for that (similar to the cookie information, the POST page name, and so on). This
    will give us a position with which we canÂ align a payload. If we were looking
    to brute force guess the credentials, we could add a second field (password) and
    thus have two positions to apply payloads to. Pretty slick, eh?
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does the mode mean, anyways? Well, here is a quick synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniper**:**Â **Using a single set of payloads, intruder just inserts each
    in the position in turn, and reports back. This is great for a simple guessing
    game or single-field focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battering ram**:**Â **This uses a single set of payloads, but applies the
    same payload to multiple fields at the same time. This is our preferred mode for
    when we''re working with certain header positions like cookies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitchfork**:**Â **Later fuzzing attacks may see us armed with correlated
    information, but needing to apply matching sets to multiple fields at the same
    time. Pitchfork allows us to send those matched sets (such as credential pairs,
    username and ID number, and so on)Â to their respective fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster bomb**:**Â **Unlike Pitchfork, cluster bomb iterates multiple payload
    sets in every combination across their associated field. So, if you need to try
    a username with a list of IDs and another with all those same IDs, then this is
    the mode for you!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_05_27.png)'
  prefs: []
  type: TYPE_IMG
- en: Payload positions identify the areas we want Intruder to fuzz
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can push on into the **`Payloads`** subtab as shown in the following
    screenshot,Â which allows us to decide how we'll alter each of the positions with
    each request. From the picklist of field types, we'll wantÂ **`Simple list`**,
    and we can then pick usernames from the **`Add from list â�¦`** dropdown menu.
    More info on these is available in the outstanding Burp Suite documentation at
    [https://portswigger.net/burp/help/intruder_payloads_types.html](https://portswigger.net/burp/help/intruder_payloads_types.html).
  prefs: []
  type: TYPE_NORMAL
- en: In lieu of a wordlist in password or username fuzzing, social engineering and
    OSINT can save serious time for you here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_28.png)'
  prefs: []
  type: TYPE_IMG
- en: Payloads can be generated, pulled from files, or manually inputted.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll get to see what the results of all of this are. The **`Results`**
    tab will show you how every iteration went, and this can be sorted on the payload
    itself, but what is most useful is to sort based on the **status** type (standard
    web status) or the **length** of the response, both of which can help identify
    any strange behavior that we should take a closer look at. The example in the
    following screenshotÂ shows that the user list was pretty uneventful, which means
    we'll need to look for non-standard usernames or create more elaborate or tailored
    lists to enumerate users.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_29.png)'
  prefs: []
  type: TYPE_IMG
- en: In this Intruder run, only one event stands out â�� a great place to start exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Select, attack, highlight, and repeat!
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last tool we'll discuss in this chapter is the Burp Suite's **`Repeater`**
    tool, whereÂ Intruder allows you to focus on one or more fields and apply specific
    payload sets.Â Repeater focuses more on applying field modification for input
    validation checking and can even reply requests in different orders to test business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Repeater is a great utility to augment other tools in the suite, and just like
    the other tools, it can be called by right-clicking and selecting theÂ **`Send
    to Repeater`** option, which will automatically spawn a **`Repeater`** task tab
    (look at the following screenshot) and preconfigure all of the basics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_30.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeater allows us to take a request we've captured and play with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve got our message, we can then decide how to modify any or all fields
    in each iteration, and then modify the order with which these are deployed, as
    seen in the following screenshot.:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_05_31.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeater gives us fine control to queue any combination of variables in any
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Repeater is pretty simple, really.Â  But the power to craft our own replay of
    events is something that will be very helpful in later business-logic based attacks,
    and we'll discuss these in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: OWASP's ZAP tool and Burp Suite form the bulk of many web application security
    test methodologies, and for good reason. Proxy-based tools are able to observe
    the transactions between the client and server without worrying about losing the
    context of session information. Proxies can thus do what outside analysis cannot,
    which is *see* the application working end to end. When we are looking at how
    attackers commonly disrupt or exploit modern applications, they are using these
    same techniques to either capture the data back and forth or insert their own
    malicious intent. ZAP and Burp give us a means toÂ preempt that MITM approach
    and fully test applications against these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the more general toolsÂ used forÂ both of
    these packages. My hope is that this investment in a foundation will help us actually
    accomplish many of the more advanced tasks in later chapters without rehashing
    the basics covered here. The best approach for practicing pen testers is to practice.
    Using the many available vulnerable target VMs in the space, you can work out
    the kinks and determine which tools fit your style and process best.Â
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll actually get into the nitty gritty details of our
    first focused attack-â��**Cross Site Scripting** (or **XSS**). Â We will also
    discuss the various forms of XSS**,** what they target, and where they are most
    applicable. We'll also see how to execute these attacks using Burp and some complimentary
    tools such asÂ **BeEF**, **XSSer**, **Webslpoit**, and **Metasploit**. It is fair
    to assume we'll be doing some fun things, so hold on tight!
  prefs: []
  type: TYPE_NORMAL
