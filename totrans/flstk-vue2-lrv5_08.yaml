- en: Managing Your Application State with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned how Vue Router can be used to add virtual pages
    to a Vue.js single-page app. We will now add components to Vuebnb that share data
    across pages and therefore can't rely on transient local state. To do this, we
    will utilize Vuex, a Flux-inspired library for Vue.js that offers a robust means
    of managing global application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Flux application architecture and why it is useful for
    building user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Vuex and its key features, including state and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install Vuex and set up a global store that can be accessed by Vue.js
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Vuex allows for superior debugging with Vue Devtools via mutation logging
    and time-travel debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation of a save feature for Vuebnb listings and a saved listings page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving page state into Vuex to minimize unnecessary data retrieval from the
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you've developed a multi-user chat app. The interface has a user list,
    private chat windows, an inbox with chat history and a notification bar to inform
    users of unread messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Millions of users are chatting through your app on a daily basis. However,
    there are complaints about an annoying problem: the notification bar of the app
    will occasionally give false notifications; that is, a user will be notified of
    a new unread message, but when they check to see what it is, it''s just a message
    they''ve already seen.'
  prefs: []
  type: TYPE_NORMAL
- en: What I've described is a real scenario that Facebook developers had with their
    chat system a few years ago. The process of solving this inspired their developers
    to create an application architecture they named *Flux*. Flux forms the basis
    of Vuex, Redux and other similar libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook developers struggled with this *zombie notification* bug for some time.
    They eventually realized that its persistent nature was more than a simple bug;
    it pointed to an underlying flaw in the architecture of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flaw is most easily understood in the abstract: when you have multiple
    components in an application that share data, the complexity of their interconnections
    will increase to a point where the state of the data is no longer predictable
    or understandable. When bugs like the one described inevitably arise, the complexity
    of the app data makes them near impossible to resolve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3af18a5-6ef2-4e3d-bbc3-421235671ed0.png)Figure 8.1\. The complexity
    of communication between components increases with every extra component'
  prefs: []
  type: TYPE_NORMAL
- en: Flux is not a library. You can't go to GitHub and download it. Flux is a set
    of guiding principles that describe a scalable frontend architecture that sufficiently
    mitigates this flaw. It is not just for a chat app, but for any complex UI with
    components which share state, like Vuebnb.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore the guiding principles of Flux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #1 – Single source of truth'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components may have *local data* that only they need to know about. For example,
    the position of the scroll bar in the user list component is probably of no interest
    to other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But any data that is to be shared between components, for example *application
    data*, needs to be kept in a single place, separate from the components that use
    it. This location is referred to as the *store*. Components must read application
    data from this location and not keep their own copy to prevent conflict or disagreement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3929a216-de2f-4ce7-b175-6399ecd98b4d.png)Figure 8.2\. Centralized
    data simplifies application state'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #2 – Data is read-only'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components can freely read data from the store. But they cannot change data
    in the store, at least not directly.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, they must inform the store of their intent to change the data and the
    store will be responsible for making those changes via a set of defined functions
    called *mutator methods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why this approach? If we centralize the data-altering logic then we don''t
    have to look far if there are inconsistencies in the state. We''re minimizing
    the possibility that some random component (possibly in a third party module)
    has changed the data in an unexpected fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5913f05b-dd85-4450-8021-ed3d0ca3e211.png)Figure 8.3\. State is read-only.
    Mutator methods are used to write to the store'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle #3 – Mutations are synchronous'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's much easier to debug state inconsistencies in an app that implements the
    above two principles in its architecture. You could log commits and observe how
    the state changes in response (which automatically happens with Vue Devtools,
    as we'll see).
  prefs: []
  type: TYPE_NORMAL
- en: But this ability would be undermined if our mutations were applied *asynchronously*.
    We'd know the order our commits came in, but we would not know the order in which
    our components committed them. Synchronous mutations ensure state is not dependent
    on the sequence and timing of unpredictable events.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Vuex* (usually pronounced *veweks*) is the official Vue.js implementation
    of the Flux architecture. By enforcing the principles described previously, Vuex
    keeps your application data in a transparent and predictable state even when that
    data is being shared across many components.'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex includes a store with state and mutator methods, and will reactively update
    any components that are reading data from the store. It also allows for handy
    development features like hot module reloading (updating modules in a running
    application) and time-travel debugging (stepping back through mutations to trace
    bugs).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will add a *save* feature to our Vuebnb listings so that
    a user can keep track of the listings that they like best. Unlike other data in
    our app so far, the saved state must persist across pages; for example, when a
    user changes from one page to another, the app must remember which items the user
    has already saved. We will use Vuex to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/66e49fec-a7b3-422b-9015-ce5b934d5950.png)Figure 8.4\. Saved state
    is available to all page components'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vuex is an NPM package that can be installed from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will put our Vuex configuration into a new module file `store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We need to import Vuex in this file and, like Vue Router, install it with `Vue.use`.
    This gives special properties to Vue that make it compatible with Vuex, such as
    allowing components to access the store via `this.$store`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will then import the store module in our main app file, and add it to our
    Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, we''ll be adding a *save* feature to our Vuebnb listings. The
    UI of this feature is a small, clickable icon that is overlaid on the top right
    of a listing summary''s thumbnail image. It acts similarly to a checkbox, allowing
    the user to toggle the saved status of any particular listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/08d86e82-fae4-4b85-a5e4-275876a2c3e8.png)Figure 8.5\. The save feature
    shown on listing summaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The save feature will also be added as a button in the header image on the
    listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8afceda7-510a-4be1-8a12-499eb511c473.png)Figure 8.6\. The save feature
    shown on the listing page'
  prefs: []
  type: TYPE_NORMAL
- en: ListingSave component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by creating the new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The template of this component will include a Font Awesome *heart*icon. It will
    also include a click handler which will be used to toggle the saved state. Since
    this component will always be a child of a listing or listing summary, it will
    receive a listing ID as a prop. This prop will be used shortly to save the state
    in Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the click handler has a `stop` modifier. This modifier prevents the
    click event from bubbling up to ancestor elements, especially any anchor tags
    which might trigger a page change!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now add `ListingSave` to the `ListingSummary` component. Remember to
    pass the listing''s ID as a prop. While we''re at it, let''s add a `position:
    relative` to the `.listing-summary` class rules so that `ListingSave` can be positioned
    absolutely against it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSummary.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we will now see the `ListingSave` heart icon rendered on each
    summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b38719f-3f5c-4447-bc74-2cfc395ce643.png)Figure 8.7\. The ListingSave component
    within ListingSummary components'
  prefs: []
  type: TYPE_NORMAL
- en: Saved state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListingSave` component does not have any local data; we will instead keep
    any saved listings in our Vuex store. To do this, we will create an array in the
    store called `saved`. Each time the user toggles the saved state of a listing
    its ID will be either added or removed from this array.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let's add a `state` property to our Vuex store. This object will hold
    any data we want to be globally available to the components of our app. We will
    add the `saved` property to this object and assign it an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Mutator method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the stub for a `toggleSaved` method in our `ListingSave` component.
    This method should add or remove the listing's ID from the `saved` state in the
    store. Components can access the store as `this.$store`. More specifically, the `saved` array
    can be accessed at `this.$store.state.saved`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that in the Flux architecture state is read-only. That means we cannot
    directly modify `saved` from a component. Instead, we must create a mutator method
    in the store which does the modification for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `mutations` property in our store configuration, and add a
    function property `toggleSaved`. Vuex mutator methods receive two arguments: the
    store state and a payload. This payload can be anything you want to pass from
    the component to the mutator. For the current case, we will send the listing ID.'
  prefs: []
  type: TYPE_NORMAL
- en: The logic for `toggleSaved` is to check if the listing ID is already in the `saved` array
    and if so, remove it, or if not, add it.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We now need to commit this mutation from `ListingSave`. *Commit*is Flux jargon
    that is synonymous with *call* or *trigger*. A commit looks like a custom event
    with the first argument being the name of the mutator method and the second being
    the payload.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The main point of using mutator methods in the store architecture is that state
    is changed consistently. But there is an additional benefit: we can easily log
    these changes for debugging. If you check the Vuex tab in Vue Devtools after clicking
    one of the save buttons, you will see an entry for that mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f23bdf4-ebe3-4723-8e3f-3a3dfbf6160d.png)Figure 8.8: Mutation log'
  prefs: []
  type: TYPE_NORMAL
- en: Each entry in the log can tell you the state after the change was committed,
    as well as the particulars of the mutation.
  prefs: []
  type: TYPE_NORMAL
- en: If you double-click a logged mutation, Vue Devtools will revert the state of
    the app to what it was directly after that change. This is called *time-travel
    debugging* and can be useful for fine-grained debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the icon to reflect the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `ListingSave` component's icon will appear differently, depending on whether
    or not the listing is saved; it will be opaque if the listing is saved, and transparent
    if it is not. Since the component doesn't store its state locally, we need to
    retrieve state from the store to implement this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex store state should generally be retrieved via a computed property. This
    ensures that the component is not keeping its own copy, which would violate the
    *single source of truth* principle, and that the component is re-rendered when
    the state is mutated by this component or another. Reactivity works with Vuex
    state, too!
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a computed property `isListingSaved`, which will return a Boolean
    value reflecting whether or not this particular listing has been saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can now use this computed property to change the icon. Currently we're using
    the Font Awesome icon `fa-heart-o`. This should represent the *unsaved* state.
    When the listing is saved we should instead use the icon `fa-heart`. We can implement
    this with a dynamic class binding.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the user can visually identify which listings have been saved and which
    haven''t. Thanks to reactive Vuex data, the icon will instantly be updated when
    a change to the `saved` state is made from anywhere in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d161bd9-3d66-4d56-9fe3-101a47565018.png)Figure 8.9\. The ListingSave icon
    will change depending on the state'
  prefs: []
  type: TYPE_NORMAL
- en: Adding to ListingPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also want the save feature to appear on the listing page. It will go inside
    the `HeaderImage` component alongside the View Photos button so that, like with
    the listing summaries, the button is overlaid on the listing's main image.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HeaderImage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that `HeaderImage` does not have the listing ID in its scope, so we'll
    have to pass this down as a prop from `ListingPage`. `id` is not currently a data
    property of `ListingPage` either, but, if we declare it, it will simply work.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the ID is already a property of the initial state/AJAX data
    the component receives, therefore `id` will automatically be populated by the `Object.assign` when
    the component is loaded by the router.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, the save feature will now appear on the listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26551ab4-8d6c-4bc1-97a5-c618aa9afd2f.png)Figure 8.10\. The listing
    save feature on the listing pageIf you save a listing via the listing page, then
    return to the home page, the equivalent listing summary will be saved. This is
    because our Vuex state is global and will persist across page changes (though
    not page refreshes...yet).'
  prefs: []
  type: TYPE_NORMAL
- en: Making ListingSave a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it is, the `ListingSave` feature appears too small in the listing page header
    and will be easily overlooked by a user. Let's make it a proper button, similar
    to the View Photos button in the bottom left of the header.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll modify `ListingSave` to allow parent components to send a
    prop `button`. This Boolean prop will indicate if the component should include
    a `button` element wrapped around the icon or not.
  prefs: []
  type: TYPE_NORMAL
- en: The text for this button will be a computed property `message` which will change
    from Save to Saved depending on the value of `isListingSaved`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingSave.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will now set the `button` prop to `true` within `HeaderImage`. Even though
    the value is not dynamic, we use a `v-bind` to ensure the value is interpreted
    as a JavaScript value, not a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HeaderImage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the `ListingSave` will appear as a button on our listing pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2f04270b-3b6f-4b66-988d-c523580b11d1.png)Figure 8.11\. The listing
    save feature appears as a button on the listing page'
  prefs: []
  type: TYPE_NORMAL
- en: Moving page state into the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the user can save any listings that they like, we will need a *saved*
    page where they can view those saved listings together. We will build this new
    page shortly, and it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e48bd76-0d44-4746-8cb8-26041676e739.png)Figure 8.12: Saved page'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the saved page will require an enhancement to our app architecture,
    however. Let's do a quick recap of how data is retrieved from the server to understand
    why.
  prefs: []
  type: TYPE_NORMAL
- en: All the pages in our app require a route on the server to return a view. This
    view includes the data for the relevant page component inlined in the document
    head. Or, if we navigate to that page via in-app links, an API endpoint will instead
    supply that same data. We set up this mechanism in [Chapter 7](08354437-8373-40d1-b1d5-c63219c85c95.xhtml), *Building
    A Multi-Page App With Vue Router*.
  prefs: []
  type: TYPE_NORMAL
- en: The saved page will require the same data as the home page (the listing summary
    data), as the saved page is really just a slight variation on the home page. It
    makes sense, then, to share data between the home page and saved page. In other
    words, if a user loads Vuebnb from the home page, then navigates to the saved
    page, or vice versa, it would be a waste to load the listing summary data more
    than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s decouple our page state from our page components and move it into Vuex.
    That way it can be used by whichever page needs and it and avoid unnecessary reloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cac3b0f4-d27d-47d1-aedc-bba44181e368.png)Figure 8.13\. Page state
    in store'
  prefs: []
  type: TYPE_NORMAL
- en: State and mutator methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add two new state properties to our Vuex store: `listings` and `listing_summaries`.
    These will be arrays that store our listings and listing summaries respectively.
    When the page first loads, or when the route changes and the API is called, the
    loaded data will be put into these arrays rather than being assigned directly
    to the page components. The page components will instead retrieve this data from
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add a mutator method, `addData`, for populating these arrays. It
    will accept a payload object with two properties: `route` and `data`. `route` is
    the name of the route, for example, *listing*, *home*,and so on. `data` is the
    listing or listing summary data retrieved from the document head or the API.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logic for retrieving page state is in the mixin file  `route-mixin.js`.
    This mixin adds a `beforeRouteEnter` hook to a page component which applies the
    page state to the component instance when it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're storing page state in Vuex we will utilize a different approach.
    Firstly, we won't need a mixin anymore; we'll put this logic into `router.js` now.
    Secondly, we'll use a different navigation guard, `beforeEach`. This is not a
    component hook, but a hook that can be applied to the router itself, and it is
    triggered before every navigation.
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the following code block how I've implemented this in `router.js`.
    Note that before `next()` is called we commit the page state to the store.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, we can now delete the route mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving page state from Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve moved page state into Vuex we''ll need to modify our page components
    to retrieve it. Starting with `ListingPage`, the changes we must make are:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove local data properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a computed property `listing`. This will find the right listing data from
    the store based on the route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the mixin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change template variables so they''re properties of `listing`: an example is  `{{
    title }}` , which will become `{{ listing.title }}`. Unfortunately, all variables
    are now properties of `listing` which makes our template slightly more verbose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Changes to `HomePage` are much simpler; just remove the mixin and the local
    state, and replace it with a computed property, `listing_groups`, which will retrieve
    all the listing summaries from the store.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/HomePage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After making these changes, reload the app and you should see no obvious change
    in behavior. However, inspecting the Vuex tab of Vue Devtools, you will see that
    page data is now in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc5a618d-c18a-4ec3-8b43-229e5021393f.png)Figure 8.14\. Page state
    is now in the Vuex store'
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes what we want to get from the store is not a direct value, but a derived
    value. For example, say we wanted to get only those listing summaries that were
    saved by the user. To do this, we can define a *getter,* which is like a computed
    property for the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any component that needs the getter data can retrieve it from the store
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you define a getter when several components need the same derived
    value, to save repeating code. Let's create a getter which retrieves a specific
    listing. We've already created this functionality in `ListingPage`, but since
    we're going to need it in our router as well, we'll refactor it as a getter.
  prefs: []
  type: TYPE_NORMAL
- en: One thing about getters is that they don't accept a payload argument like mutations
    do. If you want to pass a value to a getter, you need to return a function where
    the payload is an argument of that function.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's now use this getter in our `ListingPage` to replace the previous logic.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/ListingPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Checking if page state is in the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve successfully moved page state into the store. Now in the navigation
    guard, we will check to see if the data a page needs is already stored to avoid
    retrieving the same data twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f45f9b1b-793f-4022-8f0f-25675a8d8b5c.png)Figure 8.15\. Decision
    logic for getting page data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this logic in the `beforeEach` hook in `router.js`. We''ll
    add an `if` block at the start that will instantly resolve the hook if the data
    is already present. The `if` uses a ternary function with the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: If the route name is *listing*, use the `getListing` getter to see if that particular
    listing is available (this getter returns `undefined` if it is not)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the route name is *not* *listing*, check to see if the store has listing
    summaries available. Listing summaries are always retrieved all at once, so if
    there's at least one, you can assume they're all there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With that done, if the in-app navigation is used to navigate from the home page
    to listing 1, then back to the home page, then back to listing 1, the app will
    retrieve listing 1 from the API just the once. It would have done it twice under
    the previous architecture!
  prefs: []
  type: TYPE_NORMAL
- en: Saved page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add the saved page to Vuebnb. Let''s begin by creating the component
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create a new route with this component at the path `/saved`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's also add some server-side routes to the Laravel project. As discussed
    above, the saved page uses exactly the same data as the home page. This means
    that we can just call the same controller methods used for the home page.
  prefs: []
  type: TYPE_NORMAL
- en: '`routes/web.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`routes/api.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we will define the `SavedPage` component. Beginning with the `script` tag,
    we will import the `ListingSummary` component we created back in [Chapter 6](c3b31042-0e33-40d8-ad31-d048ccf7082d.xhtml), *Composing
    Widgets with Vue.js Components*. We'll also create a computed property, `listings`, that
    will return the listing summaries from the store, filtered by whether or not they're
    saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/SavedPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add to the `template` tag of `SavedPage`. The main content includes
    a check for the length of the array returned by the `listings` computed property.
    If it is 0, no items have been saved yet. In this case, we display a message to
    inform the user. If there are listings saved, however, we'll iterate through them
    and display them with the `ListingSummary` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/SavedPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we''ll add to the `style` tag. The main thing to note here is that
    we''re utilizing the `flex-wrap: wrap` rule and justifying to the left. This ensures
    that our listing summaries will organize themselves in rows without gaps.'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/SavedPage.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's also add the `.saved-container` CSS rules in our global CSS file. This
    ensures that our custom footer has access to these rules as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/css/style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The final task is to add some default saved listings to the store. I've chosen
    1 and 15 at random, but you can add any you want. We'll remove these again in
    the next chapter when we use Laravel to persist saved listings to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/js/store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, here''s what our saved page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd5572ee-80c1-420e-b176-df3860c92fe3.png)Figure 8.16\. Saved page'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we remove all our saved listings, this is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/023a07de-c00d-4eb1-8f8c-26588e1c171e.png)Figure 8.17\. Saved page
    without listings'
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we'll do in this chapter is to add a link to the saved page in
    the toolbar so that the saved page is accessible from any other page. To do this,
    we'll add an inline `ul` where links are enclosed within a child `li`(we'll add
    more links to the toolbar in [Chapter 9](046ff094-aa7d-43d0-9f9b-444652bcaf1d.xhtml),
    *Adding a User Login and API Authentication with Passport*).
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To display this correctly, we'll have to add some extra CSS. Firstly, we'll
    modify the `#toolbar` declaration so that the toolbar uses flex for display. We'll
    also add some new rules below that for displaying the links.
  prefs: []
  type: TYPE_NORMAL
- en: '`resources/assets/components/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a link to the saved page in the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/861e4bd0-2979-4ae1-8831-7b51702ed106.png)Figure 8.18: Saved link
    in toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Vuex, Vue's official state management library,
    which is based on the Flux architecture. We installed Vuex in Vuebnb and set up
    a store where global state could be written and retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned the main features of Vuex including state, mutator methods and
    getters, and how we can debug Vuex using Vue Devtools. We used this knowledge
    to implement a listing save component, which we then added to our main pages.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we married Vuex and Vue Router to allow page state to be more efficiently
    stored and retrieved when the route changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover one of the trickiest topics of full-stack apps
    - authentication. We'll add a user profile to Vuebnb so a user can persist their
    saved items to the database. We'll also continue to add to our knowledge of Vuex
    by utilizing some of its more advanced features.
  prefs: []
  type: TYPE_NORMAL
