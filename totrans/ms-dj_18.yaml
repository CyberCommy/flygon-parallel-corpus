- en: Chapter 18. Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating message files from JavaScript source codeDjango was originally
    developed right in the middle of the United States-quite literally, as Lawrence,
    Kansas, is less than 40 miles from the geographic center of the continental United
    States. Like most open source projects, though, Django's community grew to include
    people from all over the globe. As Django's community became increasingly diverse,
    *internationalization* and *localization* became increasingly important.
  prefs: []
  type: TYPE_NORMAL
- en: Django itself is fully internationalized; all strings are marked for translation,
    and settings control the display of locale-dependent values like dates and times.
    Django also ships with more than 50 different localization files. If you're not
    a native English speaker, there's a good chance that Django is already translated
    into your primary language.
  prefs: []
  type: TYPE_NORMAL
- en: The same internationalization framework used for these localizations is available
    for you to use in your own code and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Because many developers have at best a fuzzy understanding of what internationalization
    and localization actually mean, we will begin with a few definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refers to the process of designing programs for the potential use of any locale.
    This process is usually done by software developers. Internationalization includes
    marking text (such as UI elements and error messages) for future translation,
    abstracting the display of dates and times so that different local standards may
    be observed, providing support for differing time zones, and generally making
    sure that the code contains no assumptions about the location of its users. You'll
    often see internationalization abbreviated *I18N*. (The 18 refers to the number
    of letters omitted between the initial I and the terminal N.)
  prefs: []
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refers to the process of actually translating an internationalized program for
    use in a particular locale. This work is usually done by translators. You'll sometimes
    see localization abbreviated as *L10N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other terms that will help us to handle a common language:'
  prefs: []
  type: TYPE_NORMAL
- en: locale name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A locale name, either a language specification of the form `ll` or a combined
    language and country specification of the form `ll_CC`. Examples: `it`, `de_AT`,
    `es`, `pt_BR`. The language part is always in lower case and the country part
    in upper case. The separator is an underscore.'
  prefs: []
  type: TYPE_NORMAL
- en: language code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Represents the name of a language. Browsers send the names of the languages
    they accept in the `Accept-Language` HTTP header using this format. Examples:
    `it`, `de-at`, `es`, `pt-br`. Language codes are generally represented in lower-case,
    but the HTTP `Accept-Language` header is case-insensitive. The separator is a
    dash.'
  prefs: []
  type: TYPE_NORMAL
- en: message file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A message file is a plain-text file, representing a single language, that contains
    all available translation strings and how they should be represented in the given
    language. Message files have a `.po` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: translation string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A literal that can be translated.
  prefs: []
  type: TYPE_NORMAL
- en: format file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A format file is a Python module that defines the data formats for a given locale.
  prefs: []
  type: TYPE_NORMAL
- en: Translation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make a Django project translatable, you have to add a minimal number
    of hooks to your Python code and templates. These hooks are called translation
    strings. They tell Django: This text should be translated into the end user''s
    language, if a translation for this text is available in that language. It''s
    your responsibility to mark translatable strings; the system can only translate
    strings it knows about.'
  prefs: []
  type: TYPE_NORMAL
- en: Django then provides utilities to extract the translation strings into a message
    file. This file is a convenient way for translators to provide the equivalent
    of the translation strings in the target language. Once the translators have filled
    in the message file, it must be compiled. This process relies on the GNU `gettext`
    toolset.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, Django takes care of translating web apps on the fly in each
    available language, according to users' language preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, Django does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It lets developers and template authors specify which parts of their applications
    should be translatable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses that information to translate web applications for particular users
    according to their language preferences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django's internationalization hooks are on by default, and that means there's
    a bit of i18n-related overhead in certain places of the framework. If you don't
    use internationalization, you should take the two seconds to set `USE_I18N = False`
    in your settings file. Then Django will make some optimizations so as not to load
    the internationalization machinery, which will save you some overhead. There is
    also an independent but related `USE_L10N` setting that controls if Django should
    implement format localization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internationalization: in Python code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard translation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Specify a translation string by using the function `ugettext()`. It's convention
    to import this as a shorter alias, `_`, to save typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s standard library `gettext` module installs `_()` into the global
    namespace, as an alias for `gettext()`. In Django, we have chosen not to follow
    this practice, for a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: For international character set (Unicode) support, `ugettext()` is more useful
    than `gettext()`. Sometimes, you should be using `ugettext_lazy()` as the default
    translation method for a particular file. Without `_()` in the global namespace,
    the developer has to think about which is the most appropriate translation function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The underscore character (`_`) is used to represent the previous result in Python's
    interactive shell and doctest tests. Installing a global `_()` function causes
    interference. Explicitly importing `ugettext()` as `_()` avoids this problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, the text `"Welcome to my site."` is marked as a translation
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, you could code this without using the alias. This example is identical
    to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Translation also works on computed values. This example is identical to the
    previous two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '... and on variables. Again, here''s an identical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (The caveat with using variables or computed values, as in the previous two
    examples, is that Django's translation-string-detecting utility, `django-admin
    makemessages`, won't be able to find these strings. More on `makemessages` later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The strings you pass to `_()` or `ugettext()` can take placeholders, specified
    with Python''s standard named-string interpolation syntax. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This technique lets language-specific translations reorder the placeholder text.
    For example, an English translation may be *"Today is November 26."*, while a
    Spanish translation may be *"Hoy es 26 de Noviembre."*-with the month and the
    day placeholders swapped.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you should use named-string interpolation (for example, `%(day)s`)
    instead of positional interpolation (for example, `%s` or `%d`) whenever you have
    more than a single parameter. If you used positional interpolation, translations
    wouldn't be able to reorder placeholder text.
  prefs: []
  type: TYPE_NORMAL
- en: Comments for Translators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to give translators hints about a translatable string, you
    can add a comment prefixed with the `Translators` keyword on the line preceding
    the string, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The comment will then appear in the resulting `.po` file associated with the
    translatable construct located below it and should also be displayed by most translation
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for completeness, this is the corresponding fragment of the resulting
    `.po` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This also works in templates. See translator-comments-in-templates for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Marking strings as No-Op
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the function `django.utils.translation.ugettext_noop()` to mark a string
    as a translation string without translating it. The string is later translated
    from a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Use this if you have constant strings that should be stored in the source language
    because they are exchanged over systems or users-such as strings in a database-but
    should be translated at the last possible point in time, such as when the string
    is presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Pluralization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the function `django.utils.translation.ungettext()` to specify pluralized
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`ungettext` takes three arguments: the singular translation string, the plural
    translation string and the number of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful when you need your Django application to be localizable
    to languages where the number and complexity of plural forms is greater than the
    two forms used in English ('object' for the singular and 'objects' for all the
    cases where `count` is different from one, irrespective of its value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example the number of objects is passed to the translation languages
    as the `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that pluralization is complicated and works differently in each language.
    Comparing `count` to 1 isn''t always the correct rule. This code looks sophisticated,
    but will produce incorrect results for some languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t try to implement your own singular-or-plural logic, it won''t be correct.
    In a case like this, consider something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `ungettext()`, make sure you use a single name for every extrapolated
    variable included in the literal. In the examples above, note how we used the
    `name` Python variable in both translation strings. This example, besides being
    incorrect in some languages as noted above, would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get an error when running `django-admin compilemessages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Contextual markers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes words have several meanings, such as *May* in English, which refers
    to a month name and to a verb. To enable translators to translate these words
    correctly in different contexts, you can use the `django.utils.translation.pgettext()`
    function, or the `django.utils.translation.npgettext()` function if the string
    needs pluralization. Both take a context string as the first variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the resulting `.po` file, the string will then appear as often as there are
    different contextual markers for the same string (the context will appear on the
    `msgctxt` line), allowing the translator to give a different translation for each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'will appear in the `.po` file as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Contextual markers are also supported by the `trans` and `blocktrans` template
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy translation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the lazy versions of translation functions in `django.utils.translation`
    (easily recognizable by the `lazy` suffix in their names) to translate strings
    lazily-when the value is accessed rather than when they're called.
  prefs: []
  type: TYPE_NORMAL
- en: These functions store a lazy reference to the string-not the actual translation.
    The translation itself will be done when the string is used in a string context,
    such as in template rendering.
  prefs: []
  type: TYPE_NORMAL
- en: This is essential when calls to these functions are located in code paths that
    are executed at module load time.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that can easily happen when defining models, forms and model
    forms, because Django implements these such that their fields are actually class-level
    attributes. For that reason, make sure to use lazy translations in the following
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Model fields and relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, to translate the help text of the *name* field in the following
    model, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can mark names of `ForeignKey`, `ManyToManyField` or `OneToOneField` relationship
    as translatable by using their `verbose_name` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Just like you would do in `verbose_name` you should provide a lowercase verbose
    name text for the relation as Django will automatically title case it when required.
  prefs: []
  type: TYPE_NORMAL
- en: Model verbose names values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is recommended to always provide explicit `verbose_name` and `verbose_name_plural`
    options rather than relying on the fall-back English-centric and somewhat naïve
    determination of verbose names Django performs by looking at the model''s class
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Model methods short_description attribute values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For model methods, you can provide translations to Django and the admin site
    with the `short_description` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Working with lazy translation objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result of a `ugettext_lazy()` call can be used wherever you would use a
    Unicode string (an object with type `unicode`) in Python. If you try to use it
    where a bytestring (a `str` object) is expected, things will not work as expected,
    since a `ugettext_lazy()` object doesn''t know how to convert itself to a bytestring.
    You can''t use a Unicode string inside a bytestring, either, so this is consistent
    with normal Python behavior. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you ever see output that looks like `"hello <django.utils.functional...>"`,
    you have tried to insert the result of `ugettext_lazy()` into a bytestring. That's
    a bug in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t like the long `ugettext_lazy` name, you can just alias it as
    `_` (underscore), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using `ugettext_lazy()` and `ungettext_lazy()` to mark strings in models and
    utility functions is a common operation. When you're working with these objects
    elsewhere in your code, you should ensure that you don't accidentally convert
    them to strings, because they should be converted as late as possible (so that
    the correct locale is in effect). This necessitates the use of the helper function
    described next.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy translations and plural
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using lazy translation for a plural string (`[u]n[p]gettext_lazy`), you
    generally don''t know the `number` argument at the time of the string definition.
    Therefore, you are authorized to pass a key name instead of an integer as the
    `number` argument. Then `number` will be looked up in the dictionary under that
    key during string interpolation. Here''s example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the string contains exactly one unnamed placeholder, you can interpolate
    directly with the `number` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Joining strings: string_concat()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Standard Python string joins (`''''.join([...])`) will not work on lists containing
    lazy translation objects. Instead, you can use `django.utils.translation.string_concat()`,
    which creates a lazy object that concatenates its contents and converts them to
    strings only when the result is included in a string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the lazy translations in `result` will only be converted to strings
    when `result` itself is used in a string (usually at template rendering time).
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of lazy in delayed translations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For any other case where you would like to delay the translation, but have
    to pass the translatable string as an argument to another function, you can wrap
    this function inside a lazy call yourself. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Localized names of languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `get_language_info()` function provides detailed information about languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `name` and `name_local` attributes of the dictionary contain the name of
    the language in English and in the language itself, respectively. The `bidi` attribute
    is True only for bi-directional languages.
  prefs: []
  type: TYPE_NORMAL
- en: The source of the language information is the `django.conf.locale` module. Similar
    access to this information is available for template code. See below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internationalization: In template code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Translations in Django templates uses two template tags and a slightly different
    syntax than in Python code. To give your template access to these tags, put
  prefs: []
  type: TYPE_NORMAL
- en: '`{% load i18n %}` toward the top of your template. As with all template tags,
    this tag needs to be loaded in all templates which use translations, even those
    templates that extend from other templates which have already loaded the `i18n`
    tag.'
  prefs: []
  type: TYPE_NORMAL
- en: trans template tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `{% trans %}` template tag translates either a constant string (enclosed
    in single or double quotes) or variable content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `noop` option is present, variable lookup still takes place but the
    translation is skipped. This is useful when stubbing out content that will require
    translation in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Internally, inline translations use an `ugettext()` call.
  prefs: []
  type: TYPE_NORMAL
- en: In case a template variable (`myvar` above) is passed to the tag, the tag will
    first resolve such variable to a string at run-time and then look up that string
    in the message catalogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not possible to mix a template variable inside a string within `{% trans
    %}`. If your translations require strings with variables (placeholders), use `{%
    blocktrans %}` instead. If you''d like to retrieve a translated string without
    displaying it, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice you''ll use this to get strings that are used in multiple places
    or should be used as arguments for other template tags or filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`{% trans %}` also supports contextual markers using the `context` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: blocktrans template tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `blocktrans` tag allows you to mark complex sentences consisting of literals
    and variable content for translation by making use of placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To translate a template expression-say, accessing object attributes or using
    template filters-you need to bind the expression to a local variable for use within
    the translation block. Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use multiple expressions inside a single `blocktrans` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous more verbose format is still supported: `{% blocktrans with book|title
    as book_t and author|title as author_t %}`'
  prefs: []
  type: TYPE_NORMAL
- en: Other block tags (for example `{% for %}` or `{% if %}`) are not allowed inside
    a `blocktrans` tag.
  prefs: []
  type: TYPE_NORMAL
- en: If resolving one of the block arguments fails, `blocktrans` will fall back to
    the default language by deactivating the currently active language temporarily
    with the `deactivate_all()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tag also provides for pluralization. To use it:'
  prefs: []
  type: TYPE_NORMAL
- en: Designate and bind a counter value with the name `count`. This value will be
    the one used to select the right plural form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify both the singular and plural forms separating them with the
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% plural %}` tag within the `{% blocktrans %}` and `{% endblocktrans %}`
    tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you use both the pluralization feature and bind values to local variables
    in addition to the counter value, keep in mind that the `blocktrans` construct
    is internally converted to an `ungettext` call. This means the same notes regarding
    `ungettext` variables apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse URL lookups cannot be carried out within the `blocktrans` and should
    be retrieved (and stored) beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`{% blocktrans %}` also supports contextual using the `context` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Another feature `{% blocktrans %}` supports is the `trimmed` option. This option
    will remove newline characters from the beginning and the end of the content of
    the `{% blocktrans %}` tag, replace any whitespace at the beginning and end of
    a line and merge all lines into one using a space character to separate them.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite useful for indenting the content of a `{% blocktrans %}` tag without
    having the indentation characters end up in the corresponding entry in the PO
    file, which makes the translation process easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following `{% blocktrans %}` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: will result in the entry `"First sentence. Second paragraph."` in the PO file,
    compared to `"\n First sentence.\n Second sentence.\n"`, if the `trimmed` option
    had not been specified.
  prefs: []
  type: TYPE_NORMAL
- en: String literals passed to tags and filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can translate string literals passed as arguments to tags and filters by
    using the familiar `_()` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, both the tag and the filter will see the translated string, so
    they don't need to be aware of translations.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the translation infrastructure will be passed the string "`yes,no`",
    not the individual strings "`yes`" and "`no`". The translated string will need
    to contain the comma so that the filter parsing code knows how to split up the
    arguments. For example, a German translator might translate the string "`yes,no`"
    as "`ja,nein`" (keeping the comma intact).
  prefs: []
  type: TYPE_NORMAL
- en: Comments for translators in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like with Python code, these notes for translators can be specified using
    comments, either with the `comment` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'or with the `{#` ... `#}` one-line comment constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for completeness, these are the corresponding fragments of the resulting
    `.po` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Switching language in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to select a language within a template, you can use the `language`
    template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: While the first occurrence of Welcome to our page uses the current language,
    the second will always be in English.
  prefs: []
  type: TYPE_NORMAL
- en: Other tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These tags also require a `{% load i18n %}`.
  prefs: []
  type: TYPE_NORMAL
- en: '`{% get_available_languages as LANGUAGES %}` returns a list of tuples in which
    the first element is the language code and the second is the language name (translated
    into the currently active locale).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% get_current_language as LANGUAGE_CODE %}` returns the current user''s preferred
    language, as a string. Example: `en-us`. (See *How django discovers language preference* later
    in this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% get_current_language_bidi as LANGUAGE_BIDI %}` returns the current locale''s
    direction. If True, it''s a right-to-left language, for example, Hebrew, Arabic.
    If False it''s a left-to-right language, for example, English, French, German
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you enable the `django.template.context_processors.i18n` context processor
    then each `RequestContext` will have access to `LANGUAGES`, `LANGUAGE_CODE`, and
    `LANGUAGE_BIDI` as defined above.
  prefs: []
  type: TYPE_NORMAL
- en: The `i18n` context processor is not enabled by default for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also retrieve information about any of the available languages using
    provided template tags and filters. To get information about a single language,
    use the `{% get_language_info %}` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then access the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `{% get_language_info_list %}` template tag to retrieve
    information for a list of languages (for example active languages as specified
    in `LANGUAGES`). See the section about the `set_language` redirect view for an
    example of how to display a language selector using `{% get_language_info_list
    %}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `LANGUAGES` style list of tuples, `{% get_language_info_list
    %}` supports simple lists of language codes. If you do this in your view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'you can iterate over those languages in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also simple filters available for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ LANGUAGE_CODE|language_name }}` (German)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ LANGUAGE_CODE|language_name_local }}` (Deutsch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ LANGUAGE_CODE|language_bidi }}` (False)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internationalization: In Javascript code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding translations to JavaScript poses some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript code doesn't have access to a `gettext` implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript code doesn't have access to `.po` or `.mo` files; they need to be
    delivered by the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The translation catalogs for JavaScript should be kept as small as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django provides an integrated solution for these problems: It passes the translations
    into JavaScript, so you can call `gettext`, and so on, from within JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: The javascript_catalog view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main solution to these problems is the `django.views.i18n.javascript_catalog()`
    view, which sends out a JavaScript code library with functions that mimic the
    `gettext` interface, plus an array of translation strings.
  prefs: []
  type: TYPE_NORMAL
- en: Those translation strings are taken from applications or Django core, according
    to what you specify in either the `info_dict` or the URL. Paths listed in `LOCALE_PATHS`
    are also included.
  prefs: []
  type: TYPE_NORMAL
- en: 'You hook it up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Each string in `packages` should be in Python dotted-package syntax (the same
    format as the strings in `INSTALLED_APPS`) and should refer to a package that
    contains a `locale` directory. If you specify multiple packages, all those catalogs
    are merged into one catalog. This is useful if you have JavaScript that uses strings
    from different applications.
  prefs: []
  type: TYPE_NORMAL
- en: The precedence of translations is such that the packages appearing later in
    the `packages` argument have higher precedence than the ones appearing at the
    beginning, this is important in the case of clashing translations for the same
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the view uses the `djangojs` `gettext` domain. This can be changed
    by altering the `domain` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make the view dynamic by putting the packages into the URL pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With this, you specify the packages as a list of package names delimited by
    '+' signs in the URL. This is especially useful if your pages use code from different
    apps and this changes often and you don't want to pull in one big catalog file.
    As a security measure, these values can only be either `django.conf` or any package
    from the `INSTALLED_APPS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript translations found in the paths listed in the `LOCALE_PATHS`
    setting are also always included. To keep consistency with the translations lookup
    order algorithm used for Python and templates, the directories listed in `LOCALE_PATHS`
    have the highest precedence with the ones appearing first having higher precedence
    than the ones appearing later.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JavaScript translation catalog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the catalog, just pull in the dynamically generated script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses reverse URL lookup to find the URL of the JavaScript catalog view.
    When the catalog is loaded, your JavaScript code can use the standard `gettext`
    interface to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an `ngettext` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'and even a string interpolation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpolation syntax is borrowed from Python, so the `interpolate` function
    supports both positional and named interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional interpolation: `obj` contains a JavaScript array object whose elements
    values are then sequentially interpolated in their corresponding `fmt` placeholders
    in the same order they appear. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Named interpolation: This mode is selected by passing the optional boolean
    named parameter as true. `obj` contains a JavaScript object or associative array.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You shouldn''t go over the top with string interpolation, though: this is still
    JavaScript, so the code has to make repeated regular-expression substitutions.
    This isn''t as fast as string interpolation in Python, so keep it to those cases
    where you really need it (for example, in conjunction with `ngettext` to produce
    proper pluralization).'
  prefs: []
  type: TYPE_NORMAL
- en: Note on performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `javascript_catalog()` view generates the catalog from `.mo` files on every
    request. Since its output is constant-at least for a given version of a site-it's
    a good candidate for caching.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side caching will reduce CPU load. It's easily implemented with the `cache_page()`
    decorator. To trigger cache invalidation when your translations change, provide
    a version-dependent key prefix, as shown in the example below, or map the view
    at a version-dependent URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Client-side caching will save bandwidth and make your site load faster. If you're
    using ETags (`USE_ETAGS = True`), you're already covered. Otherwise, you can apply
    conditional decorators. In the following example, the cache is invalidated whenever
    you restart your application server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can even pre-generate the JavaScript catalog as part of your deployment
    procedure and serve it as a static file ([http://django-statici18n.readthedocs.org/en/latest/](http://django-statici18n.readthedocs.org/en/latest/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Internationalization: In URL patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django provides two mechanisms to internationalize URL patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the language prefix to the root of the URL patterns to make it possible
    for `LocaleMiddleware` to detect the language to activate from the requested URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making URL patterns themselves translatable via the `django.utils.translation.ugettext_lazy()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using either one of these features requires that an active language be set for
    each request; in other words, you need to have `django.middleware.locale.LocaleMiddleware`
    in your `MIDDLEWARE_CLASSES` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Language prefix in URL patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function can be used in your root URLconf and Django will automatically
    prepend the current active language code to all URL patterns defined within `i18n_patterns()`.
    Example URL patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining these URL patterns, Django will automatically add the language
    prefix to the URL patterns that were added by the `i18n_patterns` function. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`i18n_patterns()` is only allowed in your root URLconf. Using it within an
    included URLconf will throw an `ImproperlyConfigured` exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Translating URL patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'URL patterns can also be marked translatable using the `ugettext_lazy()` function.
    Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''ve created the translations, the `reverse()` function will return
    the URL in the active language. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, it's best to use translated URLs only within a language-code-prefixed
    block of patterns (using `i18n_patterns()`), to avoid the possibility that a carelessly
    translated URL causes a collision with a non-translated URL pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If localized URLs get reversed in templates, they always use the current language.
    To link to a URL in another language use the `language` template tag. It enables
    the given language in the enclosed template section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `language` tag expects the language code as the only argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Localization: How to create language files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the string literals of an application have been tagged for later translation,
    the translation themselves need to be written (or obtained). Here's how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Message files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to create a message file for a new language. A message file
    is a plain-text file, representing a single language, that contains all available
    translation strings and how they should be represented in the given language.
    Message files have a `.po` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with a tool, `django-admin makemessages`, that automates the creation
    and upkeep of these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `makemessages` command (and `compilemessages` discussed later) use commands
    from the GNU `gettext` toolset: `xgettext`, `msgfmt`, `msgmerge` and `msguniq`.'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum version of the `gettext` utilities supported is 0.15.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create or update a message file, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '... where `de` is the locale name for the message file you want to create.
    For example, `pt_BR` for Brazilian Portuguese, `de_AT` for Austrian German or
    `id` for Indonesian.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script should be run from one of two places:'
  prefs: []
  type: TYPE_NORMAL
- en: The root directory of your Django project (the one that contains `manage.py`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root directory of one of your Django apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script runs over your project source tree or your application source tree
    and pulls out all strings marked for translation (see how-django-discovers-translations
    and be sure `LOCALE_PATHS` is configured correctly). It creates (or updates) a
    message file in the directory `locale/LANG/LC_MESSAGES`. In the `de` example,
    the file will be `locale/de/LC_MESSAGES/django.po`.
  prefs: []
  type: TYPE_NORMAL
- en: When you run `makemessages` from the root directory of your project, the extracted
    strings will be automatically distributed to the proper message files. That is,
    a string extracted from a file of an app containing a `locale` directory will
    go in a message file under that directory. A string extracted from a file of an
    app without any `locale` directory will either go in a message file under the
    directory listed first in `LOCALE_PATHS` or will generate an error if `LOCALE_PATHS`
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `django-admin makemessages` examines every file that has the `.html`
    or `.txt` file extension. In case you want to override that default, use the `-extension`
    or `-e` option to specify the file extensions to examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Separate multiple extensions with commas and/or use `-e` or `-extension` multiple
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating message files from JavaScript source code you need to use the
    special 'djangojs' domain, not `e js`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have the `gettext` utilities installed, `makemessages` will create
    empty files. If that's the case, either install the `gettext` utilities or just
    copy the English message file (`locale/en/LC_MESSAGES/django.po`) if available
    and use it as a starting point; it's just an empty translation file.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Windows and need to install the GNU `gettext` utilities so `makemessages`
    works, see *gettext on windows* a little later in the chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The format of `.po` files is straightforward. Each `.po` file contains a small
    bit of metadata, such as the translation maintainer's contact information, but
    the bulk of the file is a list of *messages*-simple mappings between translation
    strings and the actual translated text for the particular language.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your Django app contained a translation string for the text
    `"Welcome to my site."`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '... then `django-admin makemessages` will have created a `.po` file containing
    the following snippet-a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msgid` is the translation string, which appears in the source. Don''t change
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msgstr` is where you put the language-specific translation. It starts out
    empty, so it''s your responsibility to change it. Make sure you keep the quotes
    around your translation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a convenience, each message includes, in the form of a comment line prefixed
    with `#` and located above the `msgid` line, the filename and line number from
    which the translation string was gleaned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long messages are a special case. There, the first string directly after the
    `msgstr` (or `msgid`) is an empty string. Then the content itself will be written
    over the next few lines as one string per line. Those strings are directly concatenated.
    Don't forget trailing spaces within the strings; otherwise, they'll be tacked
    together without whitespace!
  prefs: []
  type: TYPE_NORMAL
- en: Due to the way the `gettext` tools work internally and because we want to allow
    non-ASCII source strings in Django's core and your applications, you must use
    UTF-8 as the encoding for your PO files (the default when PO files are created).
    This means that everybody will be using the same encoding, which is important
    when Django processes the PO files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To re-examine all source code and templates for new translation strings and
    update all message files for all languages, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Compiling message files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you create your message file-and each time you make changes to it-you'll
    need to compile it into a more efficient form, for use by `gettext`. Do this with
    the `django-admin compilemessages` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool runs over all available `.po` files and creates `.mo` files, which
    are binary files optimized for use by `gettext`. In the same directory from which
    you ran `django-admin makemessages`, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Your translations are ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Windows and need to install the GNU `gettext` utilities so `django-admin
    compilemessages` works, see `gettext` on Windows below for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Django only supports `.po` files encoded in UTF-8 and without any BOM (Byte
    Order Mark) so if your text editor adds such marks to the beginning of files by
    default then you will need to reconfigure it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating message files from JavaScript source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You create and update the message files the same way as the other Django message
    files-with the `django-admin makemessages` tool. The only difference is you need
    to explicitly specify what in `gettext` parlance is known as a domain in this
    case the `djangojs` domain, by providing a `-d djangojs` parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This would create or update the message file for JavaScript for German. After
    updating message files, just run `django-admin compilemessages` the same way as
    you do with normal Django message files.
  prefs: []
  type: TYPE_NORMAL
- en: gettext on windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is only needed for people who either want to extract message IDs or compile
    message files (`.po`). Translation work itself just involves editing existing
    files of this type, but if you want to create your own message files, or want
    to test or compile a changed message file, you will need the `gettext` utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the following zip files from the GNOME servers ([https://download.gnome.org/binaries/win32/dependencies/](https://download.gnome.org/binaries/win32/dependencies/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gettext-runtime-X.zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gettext-tools-X.zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X` is the version number; version `0.15` or higher is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the contents of the `bin\` directories in both files to the same folder
    on your system (that is `C:\Program Files\gettext-utils`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update the system PATH:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control Panel > System > Advanced > Environment Variables`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `System variables` list, click `Path`, click `Edit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `;C:\Program Files\gettext-utils\bin` at the end of the `Variable value`
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also use `gettext` binaries you have obtained elsewhere, so long as
    the `xgettext -version` command works properly. Do not attempt to use Django translation
    utilities with a `gettext` package if the command `xgettext -version` entered
    at a Windows command prompt causes a popup window saying xgettext.exe has generated
    errors and will be closed by Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the makemessages command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to pass additional parameters to `xgettext`, you need to create
    a custom `makemessages` command and override its `xgettext_options` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need more flexibility, you could also add a new argument to your custom
    `makemessages` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly setting the active language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may want to set the active language for the current session explicitly.
    Perhaps a user''s language preference is retrieved from another system, for example.
    You''ve already been introduced to `django.utils.translation.activate()`. That
    applies to the current thread only. To persist the language for the entire session,
    also modify `LANGUAGE_SESSION_KEY` in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You would typically want to use both: `django.utils.translation.activate()`
    will change the language for this thread, and modifying the session makes this
    preference persist in future requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not using sessions, the language will persist in a cookie, whose
    name is configured in `LANGUAGE_COOKIE_NAME`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Using translations outside views and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Django provides a rich set of internationalization tools for use in views
    and templates, it does not restrict the usage to Django-specific code. The Django
    translation mechanisms can be used to translate arbitrary texts to any language
    that is supported by Django (as long as an appropriate translation catalog exists,
    of course).
  prefs: []
  type: TYPE_NORMAL
- en: You can load a translation catalog, activate it and translate text to language
    of your choice, but remember to switch back to original language, as activating
    a translation catalog is done on per-thread basis and such change will affect
    code running in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Calling this function with the value 'de' will give you "`Willkommen`", regardless
    of `LANGUAGE_CODE` and language set by middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Functions of particular interest are `django.utils.translation.get_language()`
    which returns the language used in the current thread, `django.utils.translation.activate()`
    which activates a translation catalog for the current thread, and `django.utils.translation.check_for_language()`
    which checks if the given language is supported by Django.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specialties of Django translation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django''s translation machinery uses the standard `gettext` module that comes
    with Python. If you know `gettext`, you might note these specialties in the way
    Django does translation:'
  prefs: []
  type: TYPE_NORMAL
- en: The string domain is `django` or `djangojs`. This string domain is used to differentiate
    between different programs that store their data in a common message-file library
    (usually `/usr/share/locale/`). The `django` domain is used for python and template
    translation strings and is loaded into the global translation catalogs. The `djangojs`
    domain is only used for JavaScript translation catalogs to make sure that those
    are as small as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django doesn't use `xgettext` alone. It uses Python wrappers around `xgettext`
    and `msgfmt`. This is mostly for convenience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Django discovers language preference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you've prepared your translations-or, if you just want to use the translations
    that come with Django-you'll need to activate translation for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, Django has a very flexible model of deciding which language
    should be used-installation-wide, for a particular user, or both.
  prefs: []
  type: TYPE_NORMAL
- en: To set an installation-wide language preference, set `LANGUAGE_CODE`. Django
    uses this language as the default translation-the final attempt if no better matching
    translation is found through one of the methods employed by the locale middleware
    (see below).
  prefs: []
  type: TYPE_NORMAL
- en: If all you want is to run Django with your native language all you need to do
    is set `LANGUAGE_CODE` and make sure the corresponding message files and their
    compiled versions (`.mo`) exist.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to let each individual user specify which language they prefer,
    then you also need to use the `LocaleMiddleware`. `LocaleMiddleware` enables language
    selection based on data from the request. It customizes content for each user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `LocaleMiddleware`, add `''django.middleware.locale.LocaleMiddleware''`
    to your `MIDDLEWARE_CLASSES` setting. Because middleware order matters, you should
    follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure it's one of the first middlewares installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should come after `SessionMiddleware`, because `LocaleMiddleware` makes use
    of session data. And it should come before `CommonMiddleware` because `CommonMiddleware`
    needs an activated language in order to resolve the requested URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use `CacheMiddleware`, put `LocaleMiddleware` after it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, your `MIDDLEWARE_CLASSES` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: For more on middleware, see [Chapter 17](ch17.xhtml "Chapter 17. Django Middleware"),
    *Django Middleware*.
  prefs: []
  type: TYPE_NORMAL
- en: '`LocaleMiddleware` tries to determine the user''s language preference by following
    this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it looks for the language prefix in the requested URL. This is only performed
    when you are using the `i18n_patterns` function in your root URLconf. See *internationalization*
    for more information about the language prefix and how to internationalize URL
    patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing that, it looks for the `LANGUAGE_SESSION_KEY` key in the current user's
    session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing that, it looks for a cookie. The name of the cookie used is set by the
    `LANGUAGE_COOKIE_NAME` setting. (The default name is `django_language`.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing that, it looks at the `Accept-Language` HTTP header. This header is
    sent by your browser and tells the server which language(s) you prefer, in order
    by priority. Django tries each language in the header until it finds one with
    available translations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***** Failing that, it uses the global `LANGUAGE_CODE` setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notes:**'
  prefs: []
  type: TYPE_NORMAL
- en: In each of these places, the language preference is expected to be in the standard
    language format, as a string. For example, Brazilian Portuguese is `pt-br`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a base language is available but the sublanguage specified is not, Django
    uses the base language. For example, if a user specifies `de-at` (Austrian German)
    but Django only has `de` available, Django uses `de`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only languages listed in the `LANGUAGES` setting can be selected. If you want
    to restrict the language selection to a subset of provided languages (because
    your application doesn''t provide all those languages), set `LANGUAGES` to a list
    of languages. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This example restricts languages that are available for automatic selection
    to German and English (and any sublanguage, like `de-ch` or `en-us`).
  prefs: []
  type: TYPE_NORMAL
- en: If you define a custom `LANGUAGES` setting, as explained in the previous bullet,
    you can mark the language names as translation strings-but use `ugettext_lazy()`
    instead of `ugettext()` to avoid a circular import.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a sample settings file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `LocaleMiddleware` determines the user''s preference, it makes this preference
    available as `request.LANGUAGE_CODE` for each `HttpRequest`. Feel free to read
    this value in your view code. Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that, with static (middleware-less) translation, the language is in `settings.LANGUAGE_CODE`,
    while with dynamic (middleware) translation, it's in `request.LANGUAGE_CODE`.
  prefs: []
  type: TYPE_NORMAL
- en: How Django discovers translations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At runtime, Django builds an in-memory unified catalog of literal translations.
    To achieve this, it looks for translations by following this algorithm regarding
    the order in which it examines the different file paths to load the compiled message
    files (`.mo`) and the precedence of multiple translations for the same literal:'
  prefs: []
  type: TYPE_NORMAL
- en: The directories listed in `LOCALE_PATHS` have the highest precedence, with the
    ones appearing first having higher precedence than the ones appearing later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it looks for and uses if it exists a `locale` directory in each of the
    installed apps listed in `INSTALLED_APPS`. The ones appearing first have higher
    precedence than the ones appearing later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the Django-provided base translation in `django/conf/locale` is used
    as a fallback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, the name of the directory containing the translation is expected
    to be named using locale name notation. For example, `de`, `pt_BR`, `es_AR`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can write applications that include their own translations, and
    you can override base translations in your project. Or, you can just build a big
    project out of several apps and put all translations into one big common message
    file specific to the project you are composing. The choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'All message file repositories are structured the same way. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: All paths listed in `LOCALE_PATHS` in your settings file are searched for `<language>/LC_MESSAGES/django.(po|mo)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$APPPATH/locale/<language>/LC_MESSAGES/django.(po|mo)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$PYTHONPATH/django/conf/locale/<language>/LC_MESSAGES/django.(po|mo).`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create message files, you use the `django-admin makemessages` tool. And you
    use `django-admin compilemessages` to produce the binary `.mo` files that are
    used by `gettext`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run `django-admin compilemessages` to make the compiler process
    all the directories in your `LOCALE_PATHS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at security in Django.
  prefs: []
  type: TYPE_NORMAL
