- en: Building Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of modern applications use **HTTP** (**Hypertext Transfer Protocol**)
    nowadays. This stateless, application-layer protocol allows us to exchange messages
    between distributed systems. The message exchange process can be observed through
    a client-server computing model as it happens in the form of the request-response
    type of messages. This allows us to easily write a service, or web service to
    be more specific, that triggers various operations on server and feedback data
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a closer look at this client-server relationship
    through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client-server relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with SOAP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WSDL file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with REST:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with Apache Thrift (RPC):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Apache Thrift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the client-server relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To easily visualize the client-server relationship and the request-response
    type of messaging, we can think of a mobile currency application acting as a client
    and some remote website, such as `http://api.fixer.io/`, being the server. The
    server exposes one or more URL endpoints, allowing communication exchange, such
    as `http://api.fixer.io/latest?symbols=USD,GBP`. The mobile application can easily
    issue a HTTP `GET http://api.fixer.io/latest?symbols=GBP,HRK,USD` request, which then
    results in a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP `GET` keyword is used to denote the type of operation we want to perform
    on the receiver located on the remote (server) system that we contact via URL.
    The response contains JSON-formatted data, which our mobile currency application
    can easily digest and make use of. This specific message exchange example is what
    we flag as **representational state transfer** (**REST**) or RESTful service.
  prefs: []
  type: TYPE_NORMAL
- en: The REST service itself is not a protocol; it is an architectural style on top
    of HTTP's stateless protocol and standard operations (GET, POST, PUT, DELETE,
    and so on). There is much more to it, than showcased in this simple example, as
    we will get to see later on in the *Working with REST* section.
  prefs: []
  type: TYPE_NORMAL
- en: There are other forms of services that go beyond being just an architectural
    style, such as the SOAP service and Apache Thrift service. While they come with
    their own sets of protocols, they also play nicely with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SOAP** (**Simple Object Access Protocol**) is an XML-based message exchange protocol
    that relies on application layer protocols such as HTTP for message negotiation
    and transmission. The **World Wide Web Consortium** (**W3C**) maintains SOAP specification.'
  prefs: []
  type: TYPE_NORMAL
- en: The SOAP specifications document is available at [https://www.w3.org/TR/soap/](https://www.w3.org/TR/soap/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The SOAP message is an XML document comprised of `Envelope`, `Header`, `Body`,
    and `Fault` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Envelope` is a required element of each SOAP request, as it envelops an entire
    SOAP message. Similarly, the `Body` element is also required as it contains request
    and response information.  `Header` and `Fault`, on the other hand, are optional
    elements. Using merely XML-based request-response messages, we can establish client-server
    communication over HTTP. While trading XML messages may look simple, it can become
    cumbersome when one has to deal with a large number of method calls and data types.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where WSDL comes in play. WSDL is an interface definition language that
    can be used to define a web service's data types and operations. The W3C maintains
    WSDL specification.
  prefs: []
  type: TYPE_NORMAL
- en: The WSDL specification document is available at [https://www.w3.org/TR/wsdl](https://www.w3.org/TR/wsdl).
  prefs: []
  type: TYPE_NORMAL
- en: 'A total of six major elements are used to describe the service, as per the
    following partial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While WSDL is not required for our service to be operational, it certainly comes
    in handy for clients consuming our SOAP service. Sadly, PHP lacks any official
    tooling for easy generation of WSDL files based on the PHP classes that our SOAP
    service uses. This makes it tedious and time consuming for PHP developers to write
    WSDL files manually, which is why some developers tend to overlook the WSDL completely.
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily putting the WSDL file generation aside, it's safe to say that the only
    really challenging part of the SOAP service is writing and reading XML messages.
    This is where PHP extensions come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: XML extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to read and write XML documents in PHP, including regular
    expressions and specialized classes and methods. The regex approach is error-prone,
    especially with complex XML documents, which is why the use of extensions is advised.
    PHP provides several extensions for this purpose, the most common ones being as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XMLWriter**: This allows us to generate streams or files of XML data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XMLReader**: This allows to read the XML data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SimpleXML**: This converts XML to an object and allows for an object to be
    processed with normal property selectors and array iterators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM**: This allows us to operate on XML documents through the DOM API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basics of dealing with an XML document are about proper reading and writing
    of its elements and attributes. Let''s assume the following `simple.xml` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `XMLWriter`, we can create the identical document by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that writing down the necessary XML was a relatively straightforward
    operation with `XMLWriter`. The `XMLWriter` extension makes our code a bit hard
    to read at first. All those `startElement()` and `endElement()` methods make it
    a bit tedious to figure out where each element in XML resides. It takes a bit
    of getting used to it. However, it does allow us to easily generate simple XML
    documents. Using `XMLReader`, we can now output the `Customer John, at age 34,
    living at The Address #1`string based on data from the given XML document using
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although the code itself looks pretty simple, the `while` loop reveals an interesting nature
    of `XMLReader`. The `XMLReader` reads the XML document top to bottom. While this approach
    is a great choice for efficiently parsing large and complex XML documents in a stream-based manner,
    it seems a bit of an overkill for simpler XML documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `SimpleXML` handles writing of the same `simple.xml` file. The
    following code generates nearly the same XML content as `XMLWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference here is that we cannot specifically pass `<![CDATA[...]]>` to
    our elements. There are workarounds using the `dom_import_simplexml()` function,
    but that''s a function from the `DOM` extension. Not that there is anything bad
    about it, but let''s keep our examples nicely separated. Now that we know we can
    write XML documents with `SimpleXML`, let''s see about reading from them. Using
    `SimpleXML`, we can now output the same `Customer John, at age 34, living at The
    Address #1` string using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The XML reading process seems somewhat shorter with `SimpleXML` than it is with `XMLReader`,
    although none of the examples have any error handling in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at using the `DOMDocument` class to write down an XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see how `DOMDocument` handles the reading of XML documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `DOM` and `SimpleXMLElement` extensions make it quite easy to read the values
    from the XML document, as long as we are confident about the integrity of its
    structure. When dealing with XML documents, we should evaluate our use case based
    on factors such as document size. While the `XMLReader` and `XMLWriter` classes
    are more verbose to deal with, they tend to be more performance efficient when
    used properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gained a basic insight into dealing with XML documents in PHP,
    let's create our first SOAP server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP `soap` extension provides `SoapClient` and `SoapServer` classes. We
    can use the `SoapServer` class to set up a SOAP service server with or without
    a WSDL service description file.
  prefs: []
  type: TYPE_NORMAL
- en: When used without WSDL (non-WSDL mode), `SoapClient` and `SoapServer` use a common
    exchange format, which removes the need for a WSDL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving forward, we should make sure we have the `soap` extension installed.
    We can do so by observing the output of the `php -m` console command or taking
    a look at the `phpinfo()` function output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/00c54baf-529e-4228-8d4d-cf18b4a4aefe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the soap extension available and loaded, we can prepare our `soap-service`
    project directory as per the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2b3e4f3-786f-49c3-9a32-a6643d21490a.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving forward, we will assume that the web server is configured to serve content
    from the `soap-service/server` directory to [http://soap-service.server](http://soap-service.server) requests,
    and content from the `soap-service/client` directory to [http://soap-service.client](http://soap-service.client) requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small SOAP service with two different classes, each with the
    same `welcome()` method. We can start off by creating the `soap-service/server/services/Foggyline/Customer.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `soap-service/server/services/Foggyline/User.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the two classes in place, let''s create a proxy class to wrap around them.
    We do so by creating the `soap-service/server/ServiceProxy.php` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our proxy class, we can create the actual `SoapServer` instance.
    We do so by creating the `soap-service/server/index.php` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are instantiating the `SoapServer` instance, passing it null for the `$wsdl`
    parameter and only a `'uri'` option under the `$options` parameter. The URI must
    be specified in a non-wsdl mode. We then use the `setClass()` instance method
    to set the class that will handle incoming SOAP requests. Unfortunately, we cannot
    pass an array of classes or call the `setClass()` method multiple times to add
    several different handling classes at once, which is why we created the `ServiceProxy`
    class to wrap around both `Customer` and `User` classes. Finally, we called the
    `handle()` method of the `$server` instance, which handles a SOAP request. At
    this point, our SOAP service server should be fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: Creating WSDL file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, before we move onto the client, let''s take a quick look at WSDL.
    The `@soap` tag used on the `ServiceProxy` class methods has nothing to do with
    the functioning of `SoapServer` as it is now. We used it merely because of the php2wsdl
    library that enables us to auto-generate a WSDL file based on the provided class. The php2wsdl
    library is provided as a composer package, which means we can install it by simply
    running the following command within the `soap-service/server` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we can create the `soap-service\server\wsdl-auto-gen.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we execute `wsdl-auto-gen.php`, either in the console or in the browser,
    it will generate the `soap-service/server/wsdl.xml` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a long file to write manually. The benefit of it is that various
    third-party tools and other language libraries can easily consume our service
    once we set the WSDL file. As an example, this is a screenshot of the Wizdler
    extension for the Chrome browser, interpreting the WSDL file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb1e49d7-b0ef-4cba-9ae6-26abab4a028d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With WSDL in place, we can now easily modify the `soap-service/server/index.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the SOAP server bits sorted out, let's create a client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a SOAP client in PHP is a relatively simple task when we are using
    the `SoapClient` class. Let''s create the `soap-service/client/index.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the client code should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2a8a419-c30a-48d6-bf7f-00e5fab1e73d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happens under the hood when the SOAP request is issued can be observed
    with networking tools such as Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/35adede7-01e3-4081-8bb7-24e7b29c231a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This shows us the exact content of an individual SOAP request, such as that
    for `$client->customerWelcome(''John'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the structure and content of the SOAP request makes it possible
    to even use the `cURL` functions to handle request-response communication, although
    that would be much more cumbersome and error-prone than dealing with the `SoapClient`
    and `SoapServer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we have touched upon some of the key points of SOAP
    services. While there is much more to be said about the SOAP specification, the examples
    presented here are a nice starting point to writing SOAP services.
  prefs: []
  type: TYPE_NORMAL
- en: A somewhat simpler variant of a web service would be REST.
  prefs: []
  type: TYPE_NORMAL
- en: Working with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike SOAP, REST is an architectural style. It has no protocols or standards
    of its own. It relies on URLs and HTTP verbs, such as POST, GET, PUT, and DELETE,
    in order to establish a message exchange process. The lack of standard makes it somewhat
    challenging to talk about, as various REST service implementations may present
    a client with different ways to consume services. When it comes to juggling data
    back and forth, we are free to choose over JSON, XML, or any other format we prefer.
    The simplicity and lightweightness of JSON made it a popular choice among many
    users and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely speaking, the very act of opening a web page in the browser can be interpreted
    as a REST call, where the browser acts as a client and server acts as a REST service.
    Unlike browser pages that may involve cookies and sessions, REST relies on stateless
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will assume that our web server is configured to serve content
    of the `rest-service/server` directory for [http://rest-service.server](http://rest-service.server) requests,
    and content of the `rest-service/client` directory for [http://rest-service.client](http://rest-service.client) requests.
  prefs: []
  type: TYPE_NORMAL
- en: JSON extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, the JSON data format has become somewhat of a default data exchange format
    for REST. The simplicity of JSON made it quite popular with PHP developers. Out
    of the box, the PHP language provides the `json_encode()` and `json_decode()`
    functions. Using these functions, we can easily encode PHP arrays and objects
    as well as decode various JSON structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the simplicity of using the `json_encode()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates the simplicity of using the `json_decode()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is where limitations kick in. Notice how the JSON object was converted
    to a `stdClass` type object in PHP. There is no direct way to pour this into a
    `User` type of object. We could, of course, write a custom functionality that
    tries to convert a `stdClass` object to an instance of `User` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Put simply, REST servers send HTTP responses based on a given URL and HTTP
    verb. Keeping that in mind, let''s start with the following chunk of code added
    to the `rest-service/server/customer/index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Funny as it looks, this, here, is already a simple REST service example--one
    that handles four different operations for a single resource. Using a tool such
    as Postman, we can trigger the `DELETE` operation on the [http://rest-service.server/customer/index.php](http://rest-service.server/customer/index.php)
    resource
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7536b609-156c-4f4e-8799-304d281eabe8.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, this simplified implementation does not deal with any of the things
    you would normally find in REST services, such as versioning, normalization, validation,
    **Cross-Origin Resource Sharing** (**CORS**), authentication, and others. Implementing
    all of these REST features from scratch is a time-consuming task, which is why
    we might want to take a look at solutions provided by existing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Silex micro-frameworks is a neat solution for quickly getting started with
    REST services. We can add Silex to our project simply by running the following
    command on console, within the `rest-service/server` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get it installed, we can dump the following code into the `rest-service/server/index.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This too is a relatively simple example of the REST service, but one that does
    much more than our initial example. The Silex framework, in this case, introduces
    several key concepts that we can use to our advantage as we build our REST server.
    The `before`, `after`, and `error` middleware enable us to hook into three distinctive
    stages of the request handling process. Using the `before` middleware, we are
    able to inject an authentication code for example, as well as various checks for
    the validity of incoming data. REST services usually build their authentication
    around tokens, which are then passed along individual requests. The general idea
    is to have an endpoint such as `POST user/login`, where the user logs in with
    their username and password, and is then given an authentication token for use
    with the rest of the REST service calls. This token then usually gets passed around
    as a part of the request header. Now, every time the user tries to access a protected
    resource, a token is extracted from the header and looked into the database (or
    any other storage where it might be stored), to find out the user behind the token.
    The system then either allows the user to continue with the original request or
    blocks it out. This is where middleware comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The web service authentication is an enormous topic by itself--one that won't
    be covered in this book. OAuth is the industry-standard protocol for authorization
    that is quite often used with REST style services. For more information about
    OAuth, check out [https://oauth.net](https://oauth.net).
  prefs: []
  type: TYPE_NORMAL
- en: The way we wrap our responses is entirely up to us. Unlike with the SOAP, there
    is no long-established standard that defines the data structure of the REST service
    response. However, there are several initiatives in the last few years that try
    to tackle that challenge.
  prefs: []
  type: TYPE_NORMAL
- en: JSON API is an attempt to formalize client-server interfaces that use exchange
    JSON data; check out [http://jsonapi.org/format/](http://jsonapi.org/format/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the server working properly, we also need to add the `rest-service\server\.htaccess`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Silex conveniently supports several key HTTP verbs (GET, POST, PUT, DELETE,
    PATCH, and OPTIONS), for which, we can easily implement logic in a *resource path
    + callback function* syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy to quickly draft a REST service, with merely a few lines
    of code. Our server example does little to nothing in terms of server security.
    Its purpose is to merely emphasize the usefulness of middleware when building
    REST services. Security aspects, such as authentication, authorization, CORS,
    HTTPS, and others should be given utmost attention.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as [http://silex.sensiolabs.org](http://silex.sensiolabs.org)
    and [https://apigility.org](https://apigility.org/) provide a great solution to write
    high-quality feature-rich REST services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that REST services rely on HTTP, it''s safe to assume that writing clients
    with PHP CURL should be quite a straightforward process. Let''s create a `rest-service/client/index.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The Wireshark network tool tells us that this code generates the following
    HTTP request to a REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While the CURL approach works just fine, it can quickly become cumbersome and
    error-prone. This implies the challenges of having to deal with various types
    of error responses, SSL certificates, and so on. A more elegant solution would
    be to use the HTTP client library, such as Guzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Guzzle is an MIT-licensed HTTP client written in PHP. It can easily be installed
    through composer, by running the `composer require guzzlehttp/guzzle` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chances are that our REST services will be contacted more often by non-PHP
    clients than by PHP clients. With that in mind, let''s see how a simple HTML/jQuery
    client can talk to our REST service. We do so by adding the following code to `rest-service/client/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The jQuery `ajax()` method acts as an HTTP client. Passing it the proper parameter
    values, it was able to successfully establish request-response communication with
    the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we have touched upon some of the key points of REST
    services. Although we have barely scratched the surface of the overall REST architecture,
    the examples presented here should be enough to get us started. The ease of implementation
    and simplicity of JSON and HTTP make REST quite an appealing choice for modern
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Apache Thrift (RPC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Thrift is an open source framework to build scalable cross-language services.
    It was originally developed by Facebook, then entered the Apache Incubator around
    May 2008. Simplicity, transparency, consistency, and performance are the four
    key values behind the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the REST and SOAP type of services, Thrift services use a binary form
    of communication. Luckily for us, Thrift provides a code generation engine to get
    us started. The code generation engine can pick up any **interface definition
    language** (**IDL**) file and generate PHP or other language bindings from it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing our first service definition, we need to install Apache
    Thrift.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apache Thrift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apache Thrift can be installed from source files. Assuming that we have a fresh
    Ubuntu 16.10 installation, we can kick off the Apache Thrift installation steps
    using the following set of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These two commands should get us the necessary tooling to compile our Apache
    Thrift source files. Once this is done, we can pull the actual source files on
    our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the source files unpacked, we can trigger the `configure` and `make` commands,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to make sure we have the `/usr/local/lib/` directory on our
    `LD_LIBRARY_PATH` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now log out of the shell and then log back in. Using the following
    command, we confirm that the Apache Thrift is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bae82a87-22da-447b-b7a8-d6a90ab6c31e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the `thrift` tool installed and available through the console, we can
    prepare our `thrift-service` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Moving forward, we will assume that the web server is configured to serve content
    of the `thrift-service/client` directory to [http://thrift-service.client](http://thrift-service.client)
    requests, and content of the `thrift-service/server` directory to [http://thrift-service.server](http://thrift-service.server) requests.
  prefs: []
  type: TYPE_NORMAL
- en: Defining service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with Apache Thrift in PHP can be described through the following few
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the services through the IDL file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autogenerating language bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing PHP implementation of defined interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing provided service implementation through the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming exposed services via client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thrift services begin their life as `.thrift` files, that is, files described
    by IDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IDL files support definition of several data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`: This is a Boolean value (true or false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`: This is an 8-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i16`: This is a 16-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i32`: This is a 32-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i64`: This is a 64-bit signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: This is a 64-bit floating point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: This is a UTF-8 encoded text string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary`: This is a sequence of unencoded bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`: This is essentially equivalent to classes in OOP languages, but without
    inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container (`list`, `set`, `map`): This maps to common container types in most
    programming languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To keep things simple, we will focus our use on the `string` type. Let''s create
    our first Apache Thrift service. We do so by creating a `Greeting.thrift` file
    within the `thrift-service/` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Thrift file is a pure interface--there is no implementation
    here. The `namespace php user` syntax translates to *when code generation engine
    runs, generate GreetingService within user namespace for PHP type of generated
    code*. If we were using another language alongside PHP, let's say Java, we could
    easily add another line saying `namespace java customer`. This would then generate
    PHP bindings in one namespace, and Java in another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the `service` keyword is being used to specify the `GreetingService`
    interface. Within the interface, we then have two method definitions. The `hello(1:
    string name)` string receives a single name parameter, whereas `goodbye()` receives
    no parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: See [https://thrift.apache.org/docs/idl](https://thrift.apache.org/docs/idl) for
    more details about IDL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Greeting.thrift` file in place, we can trigger code generation to
    get us the necessary PHP bindings. We can do so by executing the following code
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we should have our folder structure similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1041c9b3-049f-4abd-aefe-340e33ca8799.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the `thrift` command generated two files for us under the `gen-php/user`
    directory. The `GreetingService.php` is file quite a large one; with nearly 500
    lines of code, it defines various helper functions and structures needed to work
    with our Thrift service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f7da8de-b524-41ac-8719-a9f24a34aff5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Whereas, the `Types.php` file defines several different types for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40a4fc71-9e31-4be4-b5e7-5b89fc8134ed.png)'
  prefs: []
  type: TYPE_IMG
- en: All of these types reside in `thrift-service/vendor/thrift/lib/php/lib/Thrift`,
    which is why we did the `git clone https://github.com/apache/thrift.git` command
    earlier. Up to this point, our `thrift-service/gen-php/user/GreetingService.php`
    service still does not really do anything in terms of the `hello()` and `goodbye()`
    method logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `thrift-service/server/` directory is where we will implement our project''s
    server bits. Let''s create a single all-in-one `thrift-service/server/index.php`
    file that implements the  `hello()` and `goodbye()` methods and exposes them through
    the [http://thrift-service.server/index.php](http://thrift-service.server/index.php) for
    any thrift request that may come in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We started off by including the `ThriftClassLoader` class. This loader class
    then enabled us to set the auto-loading for the entire `Thrift` and `user` namespaces.
    We then moved onto the `hello()` and `goodbye()` method implementations through
    the `GreetingServiceImpl` class. Finally, we instantiated the appropriate *handler*,
    *processor*, *transport*, and *protocol* in order to be able to process incoming
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `thrift-service/client/` directory is where we will implement our project''s
    client. Let''s create a single *all-in-one* `thrift-service/client/index.php`
    file that calls the `hello()` and `goodbye()` methods from the Thrift service
    exposed on [http://thrift-service.server/index.php](http://thrift-service.server/index.php):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Much like with the server example, here, we also started by including the `ThriftClassLoader`
    class, which in turn enabled us to set the auto-loading for the entire `Thrift`
    and `user` namespaces. We then instantiated the socket, transport, protocol, and
    client, thus making a connection with the Thrift service. Both client and server
    are using the same `thrift-service/gen-php/user/GreetingService.php` file. Given
    that `GreetingServiceClient` resides within the auto-generated `GreetingService.php` file,
    this makes it easy for the client to instantly be aware of any method `GreetingService` may
    expose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our client, all we need to do is open [http://thrift-service.client/index.php](http://thrift-service.client/index.php) in
    the browser. This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/237508b6-9a68-44b0-bcdb-259fd4979808.png)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this section, we touched upon some of the key points of Apache Thrift
    services. Although there is plenty more to be said about the Thrift's IDL and
    type system, the examples presented here are a step in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term microservices denotes an architectural style of building applications
    taking the form of loosely coupled services. These independently deployable services
    are tiny applications most often built via a web service technology. While one
    service can communicate via SOAP, the other can be do so via REST, Apache Thrift,
    or something else. There is no standard to specify the firm requirements here.
    The general idea is to take a large monolithic application and slice it down into
    several smaller applications, that is, services, but doing so in a manner that
    serves a business goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram tries to visualize this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3779faf8-7bb6-459d-86f0-e4a652e50c7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Popularized by the likes of Netflix and Amazon, the microservices style sets
    out to solve a few key challenges of modern application development, some of which
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development team size**: This is a single microservice that can be developed
    by a relatively small team'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diversity of development skills**: These are different services that can
    be written in different programming languages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change/upgrade**: These smaller pieces of code are easier to change or update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and deployment**: These smaller pieces of code are easier to
    deploy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier for newcomers**: These smaller pieces of code are easier to catch
    up with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business capabilities focus**: This individual service code is organized
    around specific business capability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Not everything scales equally; smaller chunks of code can
    be scaled more easily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault handling**: This single faulty service does not bring an entire application
    down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology stack**: This is less dependency on fast-chaining technology stacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the same time, they induce several new challenges, some of which include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service communication**: This is an extra effort involved around service
    communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed transactions**: These are challenges caused by business requirements
    spanning across several services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing and monitoring**: These are somewhat more challenging than with monolith
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network latency**: Every microservice introduces an extra bit of network
    latency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: These are microservices that have to be designed for failure
    from the ground up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That being said, building microservices is all but an easy task. Going *monolith
    first*, with a carefully decoupled and modular structure, may be a better starting
    point for most of the applications. Once a monolithic grows to the point where
    its complexities begin to affect the way we manage it, then it's time to consider
    slicing it into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we took a look at two of the most common and well-established
    web services: SOAP and REST. We also looked into a rising new star called Apache
    Thrift. Once we pass the barrier of initial Apache Thrift installation and setup,
    features such as simplicity, scalability, speed, and portability certainly come
    into focus. As we saw in our client example, the RPC calls can easily be implemented
    with a central code repository--the `thrift-service/gen-php/` directory in our
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: While Apache Thrift has yet to catch up in terms of popularity, the fact that
    it is being used by the likes of Facebook, Evernote, Pinterest, Quora, Uber, and
    other well-known names, certainly speaks for itself. This is not to say that future-wise
    SOAP or REST are less important. Choosing the right type of service is a matter of
    *careful planning* and *forward thinking*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we glossed over some of the key points of an emerging a new architectural
    style called microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we will take a closer look at working with some of the most
    commonly used databases in PHP applications: MySQL, Mongo, Elasticsearch, and
    Redis.'
  prefs: []
  type: TYPE_NORMAL
