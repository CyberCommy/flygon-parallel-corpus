- en: Chapter 2. Information Gathering and Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Passive information gathering 1.0 - the traditional way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive information gathering 2.0 - the next level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning - the Nmap way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring auxiliary modules for scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target service scanning with auxiliary modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability scanning with Nessus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning with NeXpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing information with the Dradis framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information gathering is the first basic step towards penetration testing. This
    step is carried out to find out as much information about the target machine as
    possible. The more information we have, the better will be our chances of exploiting
    the target. During the information gathering phase, our main focus is to collect
    facts about the target machine, such as the IP address, available services, open
    ports. This information plays a vital role in the process of penetration testing.
    There are basically three types of techniques used in information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Passive information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us take a quick look at these processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive information gathering:** This technique is used to gain information
    about the target without having any physical connectivity or access to it. This
    means that we use other sources to gain information about the target like using
    the `whois` query, `Nslookup`, and so on. Suppose our target is an online web
    application then a simple `whois` lookup can provide us a lot of information about
    the web application, like its IP address, its domains, and sub-domains, location
    of server, hosting server, and so on. This information can be very useful during
    penetration testing as it can widen our track of exploiting the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active information gathering:** In this technique, a logical connection is
    set up with the target in order to gain information. This technique provides us
    with the next level of information which can directly supplement us in understanding
    the target security. Port scanning; the target is the most widely used active
    scanning technique in which we focus on the open ports and available services
    running on the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social engineering:** This type of information gathering is similar to passive
    information gathering, but relies on human error and the information leaked out
    in the form of printouts, telephone conversations, or incorrect e-mail Ids, and
    so on. The techniques for utilizing this method are numerous and the ethos of
    information gathering is very different, hence, social engineering is a category
    in-itself. For example, hackers register domain-names that sound similar with
    spelling mistakes, and set up a mail server to receive such erroneous e-mails.
    Such domains are known as Doppelganger Domains, that is, the evil twin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will analyze the various passive and active techniques of
    information gathering in detail. In the starting two recipes, we will analyze
    the most commonly used and most commonly neglected techniques of passive information
    gathering, and then in later recipes we will focus on gaining information through
    port scanning. Metasploit has several built in scanning capabilities, as well
    as some third-party tools integrated with it to further enhance the process of
    port scanning. We will analyze both the inbuilt scanners, as well as some of the
    popular third-party scanners which work over the Metasploit framework. Let us
    move on to the recipes and start our process of gaining information about our
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Passive information gathering 1.0 - the traditional way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us deal with some of the most commonly used techniques for information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`whois, Dig`, and `Nslookup` are the three most basic and simplest steps for
    gaining initial information about our target. As both are passive techniques of
    gaining information, hence no connectivity with the target is required. These
    commands can be executed directly from the terminal of `BackTrack`. So, launch
    the terminal window and proceed further.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our information gathering with a simple `whois` lookup. `whois`
    is an in-built command in `BackTrack` so we can directly invoke it from our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Let us quickly perform a `whois` lookup on [www.packtpub.com](http://www.packtpub.com)
    and analyze the output. The output can be big, so here we will only focus on relevant
    points of the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that a simple `whois` lookup has revealed some information
    about the target website. The information includes the DNS server, creation date,
    expiration date, and so on. As this information has been gathered from a source
    other than the target, it is called a passive information gathering technique.
  prefs: []
  type: TYPE_NORMAL
- en: The other way of gaining information passively can be by querying the DNS records.
    The most common technique is using the `dig` command, which comes by default in
    Unix machines. Let us analyze a `dig` query on [www.packtpub.com.](http://www.packtpub.com.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Querying the DNS records has revealed some more information about the target.
    `dig` can be used to resolve the names of hosts into IP addresses, and in reverse,
    resolve IP addresses into names. In addition, `dig` can also be used to gather
    version information from name servers which may be used to aid in exploitation
    of the host. As we can see in the output, it is difficult to identify the primary
    DNS, or in some cases primary mail server or file hosting server, and so on. This
    is where `Nslookup` comes into the picture. `Nslookup` is almost as flexible as
    dig, but provides a simpler default method of identifying primary hosts, such
    as Mail and DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Nslookup` has revealed further information about the target, such as its IP
    address, server IP, and so on. These passive techniques can reveal some interesting
    information about the target and can ease our way for penetration testing.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dig` can be used to find the **SPF** (Sender Policy Framework) records. SPF
    records are those records which define the domain''s mail sending policy, that
    is, which servers are responsible for sending mails on its behalf. Incorrect SPF
    records will always result in phishing / spam mails.'
  prefs: []
  type: TYPE_NORMAL
- en: SPF records are published as text format. SPF records are responsible for ensuring
    that the registered users of a particular domain or partners, of a particular
    domain, cannot be attacked by phishing mails. Information collected from the `dig`
    query can help us in determining such issues in our target.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us cover more stuff about passive information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party websites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have used the in-built command to query about our target and gain information.
    There is an equally good technique of performing similar operations using websites,
    especially dedicated for such lookups. These websites can also provide information
    about the geographical location, contact number, admin e-mails, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful links are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://who.is](http://who.is)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.kloth.net](http://www.kloth.net)'
  prefs: []
  type: TYPE_NORMAL
- en: Passive information gathering 2.0 - the next level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every security professional is aware of the information gathering techniques
    discussed in the previous recipe. But there are some techniques which analysts
    neglect because of their reduced popularity and awareness, but they can produce
    results as good as the previous techniques. The techniques we will discuss here
    will involve a deeper analysis of our target, though we will still be using a
    passive technique. These techniques do not require the use of Metasploit, but
    since information gathering is an important field for penetration testing, we
    will discuss it here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will understand three techniques here in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zone transfer:** This can be performed using the terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMTP header:** For this technique, we will require an e-mail that is sent
    by the target to the penetration tester.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google dork:** This is a simple, yet useful, technique of gaining information
    through a search engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start with zone transfer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Zone Transfer** is a special method used by the DNS server to exchange authoritative
    records for a domain between multiple servers. This method is responsible for
    transferring bulk lists of domain information between primary and secondary servers.
    A misconfigured DNS server can respond to client query and provide information
    about the queried domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example in which a query `dig @ns1.example.com example.com
    axfr` returns a list of IP addresses and their corresponding host names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7423_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This query has identified ten host names, out of which eight unique hosts belong
    to `example.com`. We can see that the host names are descriptive enough to give
    a clear understanding about the type of service that is running.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the SMTP header can be another potential source of collecting information
    about the target. It can provide us with information about the mail server, its
    IP address, version, and so on. The only drawback of this method is that we need
    an e-mail that is sent from the target location to analyze it. The following screenshot
    shows the part of the header of a mail sent from the target.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7423_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Careful analysis of the header shows that the IP address of the mail server
    is 83.166.169.248\. The mail server uses the ESMTP service and the user uses the
    IMAP service. This additional information can be very useful in further exploring
    the target.
  prefs: []
  type: TYPE_NORMAL
- en: The last technique is using **Google dorks.** This method can work only in some
    cases but it is worth giving it a try as you never know what secret information
    it can reveal. Many times Google crawlers reach certain files or documents that
    are stored on the target server for internal use, but due to internet access;
    the crawler indexes the document in the search results. In that case, we can look
    for such files by using some Google search tricks. The combination of **site**
    and **filetype** in search results can reveal some exciting stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, perform the following search queries in Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '`www.target .com filetype:xls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`www.target.com filetype:pdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site:www.target.com filetype:db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we can try several different combinations to dig out results from
    Google search.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dig` query basically returns the data that is provided by the IP or domain
    owner while it is being registered. The zone transfer information is particularly
    provided to the DNS servers in order to build a proper mapping of registered domains.
    The `dig` query can help in fetching this information. The SMTP header is the
    original data body of an e-mail. Since it is the main data representation of e-mails,
    it contains lots of information about the sender of the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Google dorks are nothing but the search results of various files that the Google
    crawler indexes. Once the file has been indexed in a Google search, it can be
    viewed by using some specific search types.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fun with dorks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[www.jhony.ihackstuff.com](http://www.jhony.ihackstuff.com) is the most comprehensive
    guide for Google dorks where you can find a complete list of dorks that can reveal
    lots of hidden information about your target.'
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning - the Nmap way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Port scanning is an active information gathering technique in which we will
    now start dealing with our target directly. Port scanning is an interesting process
    of information gathering. It involves a deeper search of the target machine. `Nmap`
    is the most powerful and preferred scanner for security professionals. The usage
    of `Nmap` varies from novice to an advanced level. We will analyze the various
    scan techniques in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting `nmap` from `Metasploit` is easy. Launch the `msf` console and type
    in `nmap` to display the list of scan options that Nmap provides.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will analyse four different types of `Nmap` scans which can be very helpful
    during penetration testing. `Nmap` provides lots of different modes for scanning
    the target machine. Here, we will focus on four scan types namely **TCP connect
    scan, SYN stealth scan, UDP scan**, and **ACK scan**. The different scan options
    of `Nmap` can also be combined in a single scan in order to perform a more advanced
    and sophisticated scan over the target. Let us move ahead and start the scanning
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP connect [-sT]** scan is the most basic and default scan type in `Nmap`.
    It follows the three way handshake process to detect the open ports on the target
    machine. Let us perform this scan on our target.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have passed the `-sT` parameter which denotes that we want
    to perform a TCP connect scan. The `-p` parameter shows the range of port numbers
    that we want to scan. TCP connect scan is based on a three way handshake process,
    hence the results of this scan returned are considered accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**SYN scan [-sS]** is considered as a stealth scanning technique, as it never
    forms a complete connection between the target and the scanner. Hence, it is also
    called half open scanning. Let us analyze a SYN scan on the target.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-sS` parameter will instruct `Nmap` to perform a SYN scan on the target
    machine. The output of both TCP connect and the SYN scan are similar in most of
    the cases, but the only difference lies in the fact that SYN scans are difficult
    to detect by firewalls and Intrusion Detection Systems (IDS). However, modern
    firewalls are capable enough to catch SYN scans as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP scan [-sU]** is the scanning technique to identify open UDP ports on
    the target. 0-byte UDP packets are sent to the target machine and the recipient
    of an ICMP port unreachable message shows that the port is closed, otherwise it
    is considered open. It can be used in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The following command will check whether the UDP port on 192.168.56.102 is open
    or not. Similarly, we can perform a UDP scan on a complete range of ports by modifying
    the `-p` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**ACK scan [-sA]** is a special scan type which tells which ports are filtered
    or unfiltered by a firewall. It operates by sending TCP ACK frames to a remote
    port. If there is no response, then it is considered to be a filtered port. If
    the target returns an RST packet (connection reset), then the port is considered
    to be an unfiltered port.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows the result of an ACK scan performed on the target.
    The output shows that all the ports on the target are filtered, except port number
    9001 which is unfiltered. This will help us to find out weak points in our target,
    as attacking an unfiltered port will have a better success rate of exploiting
    the target.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, penetration testers don't stress too much on the scanning process,
    but a good scan can provide lots of useful results. Since the information collected
    here will form the basis of penetration testing, hence proper knowledge of scan
    types is highly recommended. Let us now take a deeper look into each of these
    scan techniques we just learnt.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP connect scan is the most basic scanning technique in which a full connection
    is established with the port under test. It uses the operating system's network
    functions to establish connections. The scanner sends a SYN packet to the target
    machine. If the port is open then it returns an ACK message back to the scanner.
    The scanner then sends an ACK packet back to the target showing the successful
    establishment of a connection. This is called a three-way handshake process. The
    connection is terminated as soon as it is opened. This technique has its benefits,
    but it is easily traceable by firewalls and IDS.
  prefs: []
  type: TYPE_NORMAL
- en: A SYN scan is another type of TCP scan, but it never forms a complete connection
    with the target. It doesn't use the operating system's network functions, instead
    it generates raw IP packets and monitors for responses. If the port is open, then
    the target will respond with an ACK message. The scanner then sends an RST (reset
    connection) message and ends the connection. Hence, it is also called **half-open
    scanning**. This is considered as a stealth scanning technique as it can avoid
    raising a flag in some misconfigured firewalls and IDS.
  prefs: []
  type: TYPE_NORMAL
- en: UDP scanning is a connectionless scanning technique, hence no notification is
    sent back to the scanner whether the packet has been received by the target or
    not. If the port is closed, then an ICMP port unreachable message is sent back
    to the scanner. If no message is received then the port is reported as open. This
    method can return false results as firewalls can block the data packets and, hence,
    no response message will be generated and the scanner will report the port as
    open.
  prefs: []
  type: TYPE_NORMAL
- en: An ACK scan has the sole purpose of identifying filtered and unfiltered ports.
    It is a unique and handy scanning technique which can be helpful in finding weak
    points in the target system as unfiltered ports can be easy targets. But a major
    disadvantage with an ACK scan is that since it never connects with the target,
    it cannot identify the open ports. The outputs of an ACK scan will only list whether
    the port is filtered or unfiltered. Combining an ACK scan with other scan types
    can make a very stealthy scanning process.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us cover more about nmap scans and see how we can club different scan types
    into one.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system and version detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some advanced options provided by `Nmap`, apart from port scanning.
    These options can help us to gain more information about our target. One of the
    most widely used options is **operating system identification [-O]**. This can
    help us in identifying the operating system running on the target machine. An
    operating system detection scan output is shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `Nmap` has successfully detected the operating system of the
    target machine. This can ease our task of finding the right exploits according
    to the operating system of the target.
  prefs: []
  type: TYPE_NORMAL
- en: The other widely used `Nmap` option is **version detection [-sV]** of different
    open ports on the target. It can be mixed with any of the scan types that we saw
    previously to add an extra bit of information of what version of services are
    running on the open ports of the target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, an extra column of `Versions` has been added in our scan output
    which reports about the different versions of services running on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing anonymity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very essential to perform scans in an anonymous manner. The firewall and
    IDS logs can reveal your IP address if you perform a scan without using security
    measures. One such feature is provided in `Nmap` which is called **Decoy [-D].**
  prefs: []
  type: TYPE_NORMAL
- en: The decoy option does not prevent your IP address from getting recorded in the
    log file of firewalls and IDS, but it does make the scan look scary. It adds other
    torrents in the log files, thus creating an impression that there are several
    other attackers scanning the machine simultaneously. So, if you add two decoy
    IP addresses then the log file will show that the request packets were sent from
    three different IP addresses, one will be yours and the other two will be the
    fake addresses added by you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The following scan example shows the use of decoy parameter. The IP addresses
    after the `-D` operator are the fake IP addresses which will also appear in the
    network log files of the target machine, along with the original IP address. This
    process can confuse the network administrators and create suspicion in their mind
    that all three IP addresses are fake or spoofed. But adding too many decoy addresses
    can affect the scan results, hence one should use a limited number of decoy addresses
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring auxiliary modules for scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auxiliary modules are the in-built modules of a Metasploit that can help us
    perform a variety of tasks. They are different from exploits as they run on the
    pen-tester's machine and also it does not provide any shell. There are more than
    350 different auxiliary modules present in the Metasploit framework, each having
    specific tasks. Here we will discuss the scanner auxiliary modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use any auxiliary modules, we will have to follow three simple steps in order
    to make our module ready to launch. Let us go through the three-step process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activating the module:** The `use` command is used to set the particular
    module active and ready to take commands.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Setting specifications:** The `set` command is used to set up the various
    parameters that the module requires to execute.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Running the module:** After completing the first two steps, the `run` command
    is used to finally execute the module and generate the result.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To view the available scanning modules in the Metasploit framework, we can
    browse to the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To start using the modules we will have to launch our `msfconsole` session.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now practically implement these steps to run a port scanning auxiliary
    module.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let us search for the port scanning modules available for us
    in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see the list of available scanners. It contains some of the basic scan
    types that we have discussed in the previous recipes. Let us start with a simple
    SYN scan to start with.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will follow our three step process to start using the module. Let us
    start with the first step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the module, we will execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will find that the prompt has changed to the module we want to use. This
    indicates that the module is now active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us see what parameters are required by the module. This will be done
    by using the `show options` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first column lists all the required parameters. The column named `Required`
    tells us which parameters are necessary to pass. It is necessary for all those
    parameters which are marked `yes` to contain a value. As we can see, all columns
    contain default values. `RHOSTS` contains the IP address range we want to scan.
    So let us set the `RHOSTS` parameter with our target IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our module is ready to perform a SYN scan on our target IP address. Using
    the `set` command, we can also change the other values as well. For example, if
    we want to change the range of port numbers, then the following command can solve
    our purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our last step will be to execute the module to perform its respective
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On successful execution of the `run` command, the module will perform a SYN
    scanning and produce results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us understand the use of threads in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting and managing the number of threads in auxiliary modules can greatly
    enhance the performance of auxiliary modules. In case you have to scan an entire
    network or a range of IP addresses, then increasing the number of threads will
    make the scanning process faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Target service scanning with auxiliary modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now try out some targeted scanning for specific services running on a
    range of IP addresses, or on a single target host. Various service-based scans
    are available; VNC, FTP, SMB, and so on. Auxiliary modules can be really handy
    in such situations when we are looking for specific types of services on our target.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us find out what service-based scanning auxiliary modules are available
    to us. We can navigate through the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are lots of options for service scan modules which can
    be very handy during penetration testing. Let us quickly work some of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of these service scanning modules is similar to using any other
    module. We will follow the same three step process that we learned in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Let us work on the NetBIOS module. Scanning for NetBIOS can be beneficial in
    identifying the Windows operating system. We will scan a range of networks this
    time to find out which machine is running a NetBIOS service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`RHOSTS` is now set to scan the entire range of IP addresses and the number
    of threads is also set to ten. Let us now run this module and analyze the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The network has three machines running on the scanned network that are using
    NetBIOS. The scan has also reported their respective MAC addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Let us perform another service scan. This time we will try to locate which machines
    are running the MySQL database server. Also, we will try to find out the version
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The scanning process has detected that the IP address 192.168.56.102 is running
    a MySQL server, but unfortunately, it couldn't connect with the server. This is
    another demonstration of how easy and handy auxiliary modules are, and they can
    provide us with lots of useful information as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that one should try out all the auxiliary scanner modules
    available as they can help you in better understanding your target.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auxiliary modules are special purpose modules that are built to perform a particular
    task. There can be situations when you have to perform only a particular type
    of scan to discover services. For example, the MySQL auxiliary scanner detects
    the presence of the database by pinging the default port number (3306). It further
    checks if the default login is enabled on the database or not. You can analyze
    the script at `/modules/auxiliary/scanner`. You can extend the code according
    to your need, or even re-use the script to build your own specific auxiliary scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability scanning with Nessus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned the basics of port scanning, along with the practical
    implementation with Nmap. Port scanning has been extended to several other tools
    which further enhance the process of scanning and information gathering. In the
    next few recipes, we will cover those tools which scan the target for available
    services and open ports and then tries to determine the type of vulnerability
    that may exist for that particular service or port. Let us begin our journey to
    vulnerability scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Nessus is one of the most widely used vulnerability scanners. It scans the target
    for a range of vulnerabilities and produces a detailed report for it. Nessus is
    a very helpful tool during penetration testing. Either you can use the GUI version
    of Nessus, or you can also use it from the Metasploit console. In this book, we
    will primarily focus on using Nessus with `msfconsole`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start working with Nessus in `msfconsole`, we will have to load Nessus and
    then connect it with the server to start our penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will connect our database with Metasploit so as to store the interim
    results. The process of starting and connecting the database in Metasploit has
    been explained in the previous chapter. After connecting the database, our next
    task is to load the Nessus plugin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect the database and load Nessus in Metasploit, we will execute the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully loading it, we will have to connect it with the server.
    The following command is used to connect it with the server manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command `ok` is an extra parameter that is passed to ensure
    the Nessus server is running on a trusted network.
  prefs: []
  type: TYPE_NORMAL
- en: We can check for the list of available users in Nessus by using the `nessus_user_list`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: A new user can also be added by using the command `nessus_user_add`. By using
    the command `nessus_policy_list`, we can view the list of available policies on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once Nessus is connected with the server, it can be used for scanning target
    machines. The process of scanning is simple and quick. Let us perform a quick
    scan on a target to see how Nessus scanning operates. To start the scan, we will
    have to pass the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the scanning process is complete, our next target will be to import the
    list generated by Nessus. Let us check out the available list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The ID column represents the report that has been generated as a result of our
    scan. Let us import this report now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the report has been imported, it can now be operated by using the console
    commands and can be analyzed to find out the weaknesses in the target. To view
    the vulnerabilities in the target, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us look through a quick guide to working with Nessus in GUI mode.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Nessus in the web browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nessus can also be used from its GUI mode which is also as powerful and easy
    to use as the console mode. If you are using Nessus for the first time, then first
    you will have to register yourself and get a registration code from the Nessus
    website. Registration can be done at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.nessus.org/register/](http://www.nessus.org/register/)'
  prefs: []
  type: TYPE_NORMAL
- en: Once the registration is complete, we will have to start Nessus and add the
    registration code. Go to **Applications** | **BackTrack | Vulnerability Assessment
    | Network Assessment | Vulnerability Scanner | nessus start**.
  prefs: []
  type: TYPE_NORMAL
- en: 'On starting Nessus, you might be prompted with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The error is because Nessus is not yet registered. In order to register, we
    will have to use the registration code that we received through an e-mail from
    Nessus. The following command will help us complete the registration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the browser and type the following address:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://localhost:8834`'
  prefs: []
  type: TYPE_NORMAL
- en: If you are launching Nessus in the browser for the first time, then it will
    take some time to load. So be patient.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with NeXpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we discussed Nessus as a potential vulnerability scanner.
    In this recipe, we will cover another important vulnerability scanner NeXpose.
  prefs: []
  type: TYPE_NORMAL
- en: NeXpose is a popular tool by Rapid7 which performs the task of vulnerability
    scanning and importing results to the Metasploit database. The usage of NeXpose
    is similar to Nessus which we learned in the previous recipe, but let's have a
    quick overlook of how to get started with NeXpose. I will leave the task of exploring
    it deeper as an assignment for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start the NeXpose from the `msf` console, we will first have to connect the
    database to Metasploit, and then load the plugin to connect it with the NeXpose
    server to start the process of target scanning. Let us execute these steps in
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are connected with our server, we can scan our target and generate
    reports. There are two scan commands supported by NeXpose. One is `nexpose_scan`
    and the other is `nexpose_discover`. The former will scan a range of IP addresses
    and import the results, whereas the latter will scan only to discover hosts and
    services running on them. Let us perform a quick scan on our target using NeXpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the scan is complete, we can view its results by using the default database
    commands of the `msf` console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what scan results have been produced by NeXpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the information has been collected, the final step will be importing the
    results. Let us see how it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the scan results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can skip this information if you have used Nessus and NeXpose from `msfconsole`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are using the GUI version of either Nessus or NeXpose, you will have
    to manually import the scan results to the database. The reason why I am laying
    stress on importing and storing results is that in our next chapter we will see
    how we can use the `autopwn` command to automatically run exploits on hosts present
    in our database. So, in order to import the scan results, we will use the `db_import`
    command as follows: `db_import filename`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sharing information with the Dradis framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous recipes, we learned several techniques for gaining information
    about our target. While performing penetration tests, we may need to share information
    with other pen-testers which may be located at other physical locations. In that
    case, sharing the penetration testing information can be made easier by using
    the Dradis framework. It is an open source framework for sharing information during
    security assessments. It has several features which makes it an excellent information-sharing
    tool. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating over SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attachment of files and notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import scan results from Nessus, NeXpose, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be extended to connect with external systems like a vulnerability database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it will not help us in gaining any information about the target, the
    tool is important for all security professionals in sharing pen-test results and
    findings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To launch the Dradis framework in BackTrack, we will have to execute the following
    command at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the command is executed successfully, we can launch the framework from
    our browser by passing the following address:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://127.0.0.1:3004`'
  prefs: []
  type: TYPE_NORMAL
- en: We will be prompted to set up a password and account for the framework.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7423_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start our experiment with Dradis. The framework enables us to build up
    a tree like structure for the domain and sub-domain addresses. This gives us a
    clear view of the target structure and helps us in storing information logically.
    It also provides features to generate a complete report of the information in
    a systematic manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7423_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are five important options that the framework provides us with. They are
    **add branch, import from file, export, add note**, and **note categories**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have logged in with your credentials, then you will be presented with
    a screen similar to the one shown in the preceding screenshot. You can locate
    the five options on the left corner of the framework. Let us see what these options
    do for us.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with creating a new report. The process is simple and starts with
    adding hosts and sub-hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The **add branch** option enables us to add a new IP or domain name. Once a
    top-level domain is added, we can further add its child to include sub-domains
    as well. Now the next task is to add information about them.
  prefs: []
  type: TYPE_NORMAL
- en: The **add note** option enables us to add information that we have collected
    from various scan results. For example, we can add scan results from Nmap, Nessus,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The **note categories** option helps us in selecting the medium we used for
    obtaining the information. The various options include Brup scan, Nessus scan,
    NeXpose, Nmap, and so on. You can choose the appropriate option that you used
    to generate the scan results.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows information about the Nmap scan performed on
    a range of IP addresses 192.168.56.1/24\. The left-side tree structure contains
    information about the targets available and the right column provides reports
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7423_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next thing that we can do with the Dradis framework is to import an existing
    report or export a created report.
  prefs: []
  type: TYPE_NORMAL
- en: The **Import from file** option provides us with the flexibility to import previously
    scanned results from different scanners. This further increases the power of this
    framework, as different testers can import the results into the framework and
    combine them to produce a single report.
  prefs: []
  type: TYPE_NORMAL
- en: The **export** option provides professional penetration testers an option to
    generate a complete report of various domains and sub-domains into a single file.
    The report can be exported either in an XML or in an HTML format. It can also
    be exported in the form of a project or custom template.
  prefs: []
  type: TYPE_NORMAL
