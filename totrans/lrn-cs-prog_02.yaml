- en: '*Chapter 2*: Data Types and Operators'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about .NET Framework and understood the
    basic structure of a C# program. In this chapter, we will learn about data types
    and objects in C#. Alongside control statements, which we will explore in the
    next chapter, these are the building blocks of every program. We will discuss
    built-in data types, explain the difference between value types and reference
    types, and learn how to convert between types. We will also discuss the operators
    defined by the language as we move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic built-in data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types and value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to write a simple C# program using
    the aforementioned language features.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore the basic data types. The `System` namespace.
    All of them, however, have a *C# alias*. These aliases are keywords in the C#
    language, which means they can only be used in the context of their designated
    purpose and not elsewhere, such as variable, class, or method names. The C# name
    and the .NET name, along with a short description of each type, are listed in
    the following table (listed alphabetically by the C# name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The types listed in this table are called **simple types** or **primitive types**.
    Apart from these, there are two more built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's explore all of the primitive types in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The integral types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# supports eight integer types that represent various ranges of integral numbers.
    The bits and range of each of them are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding table, C# defines both signed and unsigned integer
    types. The major difference between signed and unsigned integers is the way in
    which the high order bit is read. In the case of a signed integer, the high order
    bit is considered the sign flag. If the sign flag is 0, then the number is positive
    but if the sign flag is 1, then the number is negative.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of all integral types is 0\. All of these types define two
    constants called `MinValue` and `MaxValue`, which provide the minimum and maximum
    value of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integral literals, which are numbers that appear directly in code (such as
    0, -42, and so on), can be specified as decimal, hexadecimal, or binary literals.
    Decimal literals do not require any suffix. Hexadecimal literals are prefixed
    with `0x` or `0X`, and binary literals are prefixed with `0b` or `0B`. An underscore
    (`_`) can be used as a digit separator with all numeric literals. Examples of
    such literals are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An integral value without any suffix is inferred by the compiler as `int`. To
    indicate a long integer, use `l` or `L` for a signed 64-bit integer and `ul` or
    `UL` for an unsigned 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: The floating-point types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The floating-point types are used to represent numbers having fractional components.
    C# defines two floating-point types, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `float` type represents a 32-bit, single-precision floating-point number,
    whereas `double` represents a 64-bit, double-precision floating-point number.
    These types are implementations of the **IEEE Standard for Floating-Point Arithmetic
    (IEEE 754),** which is a standard established by the **Institute of Electrical
    and Electronics Engineers (IEEE)** in 1985 for floating-point arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for floating-point types is 0\. These types also define two
    constants called `MinValue` and `MaxValue` that provide the minimum and maximum
    value of the type. However, these types also provide constants that represent
    not-a-number (`System.Double.NaN`) and infinity (`System.Double.NegativeInfinity`
    and `System.Double.PositiveInfinity`). The following code listing shows several
    variables initialized with floating-point values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, a non-integer number such as `42.99` is considered a double. If
    you want to specify this as a float type, then you need to suffix the value with
    the `f` or `F` character, such as in `42.99f` or `42.99F`. Alternatively, you
    can also explicitly indicate a double literal with the `d` or `D` suffix, such
    as in `42.99d` or `42.99D`.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types store fractional parts as inverse powers of two. For this
    reason, they can only represent exact values such as `10`, `10.25`, `10.5`, and
    so on. Other numbers, such as `1.23` or `19.99`, cannot be represented exactly
    and are only an approximation. Even if `double` has 15 decimal digits of precision,
    as compared to only 7 for `float`, precision loss starts to accumulate when performing
    repeated calculations.
  prefs: []
  type: TYPE_NORMAL
- en: This makes `double` and `float` difficult or even inappropriate to use in certain
    types of applications, such as financial applications, where precision is key.
    For this purpose, the `decimal` type is provided.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `decimal` type can represent up to 28 decimal places. The details for the
    decimal type are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The default value for the decimal type is 0\. `MinValue` and `MaxValue` constants
    that define the minimum and maximum value of the type are also available. A `decimal`
    literal can be specified using the `m` or `M` suffix as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the `decimal` type minimizes errors during rounding
    but does not eliminate the need for rounding. For instance, the result of the
    operation `1m / 3 * 3` is not 1 but `0.9999999999999999999999999999`. On the other
    hand, `Math.Round(1m / 3 * 3)` yields the value 1`.`
  prefs: []
  type: TYPE_NORMAL
- en: The `decimal` type is designed for use in applications where precision is key.
    Floats and doubles are much faster types (because they use binary math, which
    is faster to compute), while the `decimal` type is slower (as the name implies,
    it uses decimal math, which is slower to compute). The `decimal` type can be an
    order of magnitude slower than the `double` type. Financial applications, where
    small inaccuracies can accumulate to important values over repeated computations,
    are a typical use case for the `decimal` type. In such applications, speed is
    not important, but precision is.
  prefs: []
  type: TYPE_NORMAL
- en: The char type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The character type is used to represent a 16-bit Unicode character. Unicode
    defines a character set that is intended to represent the characters of most languages
    in the world. Characters are represented by enclosing them in single quotation
    marks (`''''`). Examples of this include `''A''`, `''B''`, `''c''` and `''\u0058''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Character values can be literals, hexadecimal escape sequences that have the
    form `''\xdddd''`, or Unicode representations that have the form `''\udddd''`
    (where `dddd` is a 16 hexadecimal value). The following listing shows several
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default value for the `char` type is decimal 0, or its equivalents, `'\0'`,
    `'\x0000'`, or `'\u0000'`.
  prefs: []
  type: TYPE_NORMAL
- en: The bool type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# uses the `bool` keyword to represent the Boolean type. It can have two values,
    `true` or `false`, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The default value for the bool type is `false`. Unlike other languages (such
    as C++), integer values or any other values do not implicitly convert into the
    `bool` type. A Boolean variable can be either assigned a Boolean literal (`true`
    or `false`) or an expression that evaluates to `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: The string type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is an array of characters. In C#, the type for representing a string
    is called `string` and is an alias for the .NET `System.String`. You can use any
    of these two types interchangeably. Internally, a string contains a read-only
    collection of `char` objects. This makes strings immutable, which means that you
    cannot change a string but need to create a new one every time you want to modify
    the content of an existing string. Strings are not *null-terminated* (unlike other
    languages such as C++) and can contain any number of null characters (`'\0'`).
    The string length will contain the total number of the `char` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be declared and initialized in a variety of ways, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the only situation when you use the `new` operator
    to create a string object is when you initialize it from an array of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, strings are immutable. Although you have access to the
    characters of the string, you can read them, but you cannot change them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the methods that seem to be modifying a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Remove()`: This removes a part of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToUpper()`/`ToLower()`: This converts all of the characters into uppercase
    or lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither of these methods modifies the existing string, but instead returns a
    new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `s6` is the string defined earlier, `s8` will contain
    `hello`, `s9` will contain `HELLO WORLD`, and `s6` will continue to contain `hello
    world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert any built-in type, such as integer or floating-point numbers,
    into a string using the `ToString()` method. This is actually a virtual method
    of the `System.Object` type, that is, the base class for any .NET type. By overriding
    this method, any type can provide a way to serialize an object to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can be composed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be done using the concatenating operator, `+`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `Format()` method: The first argument of this method is the format,
    in which each parameter is indicated positionally with the index specified in
    curly braces, such as `{0}`, `{1}`, `{2}`and so on. Specifying an index beyond
    the number of arguments results in a runtime exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using string interpolation, which is practically a syntactic shortcut for using
    the `String.Format()` method: The string must be prefixed with `$` and the arguments
    are specified directly in curly braces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of all of these methods is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Some characters have a special meaning and are prefixed with a backslash (`\`).
    These are called escaped sequences. The following table lists all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Escape sequences are necessary in certain cases, such as when you specify a
    Windows file path or when you need a text that spawns multiple lines. The following
    code shows several examples where escape sequences are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, however, avoid using escape sequences by using verbatim strings. These
    are prefixed with the `@` symbol. When the compiler encounters such a string,
    it does not interpret escape sequences. If you want to use quotation marks in
    a string when using verbatim strings, you must double them. The following sample
    shows the preceding examples rewritten with verbatim strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Prior to C# 8, if you wanted to use string interpolation with verbatim strings,
    you had to first specify the `$` symbol for string interpolation and then `@`
    for verbatim strings. In C# 8, you can specify these two symbols in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The object type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `object` type is the base type for all other types in C#, even though you
    do not specify this explicitly, as we will see in the following chapters. The
    `object` keyword in C# is an alias for the .NET `System.Object` type. You can
    use these two interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `object` type provides some basic functionalities to all other classes
    in the form of several virtual methods that any derived class can override, if
    necessary. These methods are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Apart from these, the `object` class contains several other methods. An important
    one to note is the `GetType()` method, which is not virtual and which returns
    a `System.Type` object with information about the type of the current instance.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to notice is the way the `Equals()` method works because
    its behavior is different for reference and value types. We have not covered these
    concepts yet but will do so later in this chapter. For the time being, keep in
    mind that, for reference types, this method performs reference equality; this
    means it checks whether the two variables point to the same object on the heap.
    For value types, it performs value equality; this means that the two variables
    are of the same type and that the public and private fields of the two objects
    are equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `object` type is a reference type. The default value of a variable of the
    `object` type is `null`. However, a variable of the `object` type can be assigned
    any value of any type. When you assign a value type value to `object`, the operation
    is called `object` into a value type is called **unboxing**. This will be detailed
    in a later section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about the `object` type and its methods throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are defined as a named memory location that can be assigned to a
    value. There are several types of variables, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variables**: These are variables that are defined within a method and
    their scope is local to that method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method parameters**: These are variables that hold the arguments passed to
    a method during a function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class fields**: These are variables that are defined in the scope of the
    class and are accessible to all of the class methods and depending on the accessibility
    of the field to other classes too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array elements**: These are variables that refer to elements in an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will refer to local variables, which are variables declared
    in the body of a function. Such variables are declared using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this statement, `datatype` is the data type of the variable and `variable_name`
    is the name of the variable. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `f` is an uninitialized `bool` variable. Uninitialized variables
    cannot be used in any expression. An attempt to do so will result in a compiler
    error. All variables must be initialized before they are used. A variable can
    be initialized when declared, such as with `ch`, `b`, and `c` in the preceding
    example, or at any later time, such as with `a` and `f`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple variables of the same type can be declared and initialized in a single
    statement, separated by a comma. This is exemplified in the preceding code snippet
    with the `int` variables `a`, `b`, and `c`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several rules that must be followed for naming a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names can consist of letters, digits, and underscore characters (`_`)
    only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use any special character other than underscore (`_`) when naming
    a variable. Consequently, *@sample*, *#tag*, *name%*, and so on are illegal variable
    names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name must begin with a letter or an underscore character (`_`).
    The name of the variable cannot start with a digit. Therefore, `2small` as a variable
    name will throw a compile-time error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names are case-sensitive. Therefore, `person` and `PERSON` are considered
    two different variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable name cannot be any reserved keyword of C#. Hence `true`, `false`,
    `double`, `float`, `var`, and so on are illegal variable names. However, prefixing
    a keyword with `@` enables the compiler to treat them as identifiers, rather than
    keywords. Therefore, variables names such as `@true`, `@return`, `@var` are allowed.
    These are called **verbatim identifiers**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the language rules that you must follow when naming variables, you
    should also make sure the names you choose are descriptive and easy to understand.
    You should always prefer that over short, abbreviated names that are hard to comprehend.
    There are various coding standards and naming conventions and you should adhere
    to one. These promote consistency and make the code easier to read, understand,
    and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to naming conventions, you should do the following when programming
    in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *pascal case* for classes, structures, enums, delegates, constructors, methods,
    properties, and constants. In Pascal case, each word in a name is capitalized;
    examples include `ConnectionString`, `UserGroup`, and `XmlReader`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *camel case* for fields, local variables, and method parameters. In camel
    case, the first word of a name is not capitalized, but all of the others are;
    examples include `userId`, `xmlDocument`, and `uiControl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use *underscore* in identifiers unless to prefix private fields, such
    as in `_firstName`, and`_lastName`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer *descriptive name* over abbreviations. For example, prefer `labelText`
    over `lbltxt` or `employeeId` over `eid`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about coding standards and naming conventions in C# by consulting
    additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: Implicity-typed variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in previous examples, we need to specify the type of a variable
    when we are declaring it. However, C# provides us with another way to declare
    variables that allows the compiler to infer the variable type based on the value
    assigned to it during initialization. These are known as **implicitly typed variables**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an implicitly typed variable using the `var` keyword. Such variables
    must always be initialized on the declaration because the compiler infers the
    type of the variable from the value that it is initialized with. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the `a` variable is initialized with an integer literal, `a` is considered
    as an `int` variable by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring variables with `var`, you must keep in mind the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An implicitly typed variable must be initialized to a value at the time of declaration,
    otherwise, the compiler has no reference to infer the variable type and it results
    in a compile-time error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot initialize it to null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable type cannot be changed once it is declared and initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword is not a datatype but a placeholder for an actual type. Using
    `var` to declare variables is useful when the type name is long and you want to
    avoid typing a lot (for example, `Dictionary<string, KeyValuePair<int, string>>`)
    or you do not care about the actual type, only the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you learned how you can declare variables, let''s look at a key concept:
    the scope of variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the scope and lifetime of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **scope** in C# is defined as a block between an opening curly brace and its
    corresponding closing curly brace. The scope defines the visibility and lifetime
    of a variable. A variable can be accessed only within the scope in which it is
    defined. A variable that is defined in a particular scope is not visible to the
    code outside that scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this with the help of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `i` variable is defined inside the `for` loop, hence it
    cannot be accessed outside the `for` loop as it goes out of scope once the control
    exits the loop. You will learn more about the `for` loop in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have nested scopes. This means a variable defined in a scope can
    be accessed in another scope that is enclosed in that scope. However, the variables
    from the outer scope are visible to the inner scope but the inner scope variables
    are not accessible in the outer scope. The C# compiler won't allow you to create
    two variables with the same name within a scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the code in the previous example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the integer variable `a` is defined outside the `for` loop but within
    the scope of `Main`. Hence, it can be accessed within the `for` loop as it is
    in the scope of this. However, the `i` variable, which is defined inside the `for`
    loop, cannot be accessed inside the scope of `Main`.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to declare another variable with the same name in the scope, we will
    get a compile-time error. Consequently, we cannot declare a character variable
    `a` inside the `for` loop as we already have an integer variable with the same
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some scenarios in which we do not want to change the value of a variable
    after it is initialized. Examples can include mathematical constants (pi, Euler's
    number, and so on), physical constants (Avogadro's number, the Boltzmann constant,
    and so on), or any application-specific constants (the maximum allowed number
    of logins, the maximum number of retries for a failed operation, status codes,
    and many others). C# provides us with constant variables for this purpose. Once
    defined, the value of a constant variable cannot be changed during its scope.
    If you try to change the value of a constant variable after it is initialized,
    the compiler will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a variable constant, we need to prefix it with the `const` keyword.
    The constant variables must be initialized at the time of declaration. Here is
    an example of an integer constant initialized with the value `42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that only the built-in types can be used to declare
    constants. User-defined types cannot be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types and value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data types in C# are divided into value types and reference types. There
    are several important differences between these two, such as **copy semantics**.
    We will look at these in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable of a value type contains the value directly. When a value type variable
    is assigned from another, the stored value is copied. The primitive data types
    we have seen earlier are all value types. All user-defined types declared as structures
    (with the `struct` keyword) are value types. Although all types are implicitly
    derived from the `object`, type value types do not support explicit inheritance,
    which is a topic discussed in [*Chapter 4*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083),
    *Understanding the Various User-Defined Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Value types are typically stored on the stack in memory, although this is an
    implementation detail and not a characteristic of value types. If you assign the
    value of a value type to another variable, then the value is copied to the new
    variable and changing one variable will not affect the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the value of `a` is initialized to `20` and then
    assigned to the variable `b`. At this point, both variables contain the same value.
    However, after assigning the value `42` to the `a` variable, the value of `b`
    remains unchanged. This is shown, conceptually, in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A conceptual representation of the changes in the stack during
    the execution of the previous code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – A conceptual representation of the changes in the stack during
    the execution of the previous code
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that, initially, a storage location corresponding to the `a`
    integer was allocated on the stack and had the value 20\. Then, a second storage
    location was allocated and the value from the first was copied to it. Then, we
    changed the value of the `a` variable and therefore, the value available in the
    first storage location. The second one was left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable of a reference type does not contain the value directly but a reference
    to a memory location where the actual value is stored. The built-in data types
    `object` and `string` are reference types. Arrays, interfaces, delegates, and
    any user-defined type defined as a class are also called **reference types**.
    The following example shows several variables of different reference types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Reference types are stored on the heap. Variables of a reference type can be
    assigned the `null` value that indicates that the variable does not store a reference
    to an instance of an object. When trying to use a variable assigned the `null`
    value the result is a runtime exception. When a variable of a reference type is
    assigned a value, the reference to the actual memory location of the object is
    copied and not the value of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `a1` is an array of two integers. The reference to
    the array is copied to the `a2` variable. When the content of the array changes,
    the changes are visible both through `a1` and `a2`, since both these variables
    refer to the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is explained conceptually in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The conceptual representation of the stack and the heap during
    the execution of the preceding snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – The conceptual representation of the stack and the heap during
    the execution of the preceding snippet
  prefs: []
  type: TYPE_NORMAL
- en: You can see in this diagram that `a1` and `a2` are variables on the stack pointing
    to the same array of integers allocated on the heap. When the first element of
    the array is changed through the `a1` variable, the changes are automatically
    visible to the `a2` variable because `a1` and `a2` refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `string` type is a reference type, it appears to behave differently.
    Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` is initialized with the `"help"` literal and then the reference to
    the actual array heap object is copied to the `s2` variable. At this point, they
    both refer to the `"help"` string. However, `s1` is later assigned a new string,
    `"demo"`. At this point, `s2` will continue to refer to the `"help"` string. The
    reason for this is that strings are immutable. That means when you modify a string
    object, a new string is created, and the variable will receive the reference to
    the new string object. Any other variables referring to the old string will continue
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly mentioned boxing and unboxing earlier in this chapter when we talked
    about the `object` type. Boxing is the process of storing a value type inside
    an `object`, and unboxing is the opposite operation of converting the value of
    an `object` to a value type. Let''s understand this with the help of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `a` is a variable of the type integer that is initialized
    with the value `42`. Being a value type, the integer value `42` is stored on the
    stack. On the other hand, `o` is a variable of type `object`. This is a reference
    type. That means it only contains a reference to a heap memory location where
    the actual object is stored. So, when `a` is assigned to `o`, the process called
    **boxing** occurs.
  prefs: []
  type: TYPE_NORMAL
- en: During the boxing process an object is allocated on the heap, the value of `a`
    (which is `42`) is copied to it, and then a reference to this object is assigned
    to the `o` variable. When we later assigned the value `43` to `o`, only the boxed
    object changes and not `a`. Lastly, we copy the value of the object referred by
    `o` to a new variable called `b`. This will have the value `43` and, being an
    `int,` is also stored on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process described here is shown graphically in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Conceptual representation of the stack showing the boxing and
    unboxing process described previously'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Conceptual representation of the stack showing the boxing and unboxing
    process described previously
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the difference between value and reference types, let's
    look at the topic of nullable types.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reference types have the default value `null`, which indicates that a variable
    is not assigned to the instance of any object. Value types do not have such an
    option. However, there are cases when no value is a valid value for a value type
    too. To represent such cases, you can use a nullable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `System.Nullable<T>`, a generic value type that can represent the values
    of an underlying `T` type, which can only be a value type, as well as an additional
    `null` value. The following sample shows a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the shorthand syntax, `T?`, instead of `Nullable<T>`; these two
    are *interchangeable*. The following examples are alternatives for the preceding
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `HasValue` property to check whether a nullable type object
    has a value, and `Value` to access the underlying value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a list of some of the characteristics of nullable types:'
  prefs: []
  type: TYPE_NORMAL
- en: You assign values to a nullable type object the same way you would assign to
    the underlying type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `GetValueOrDefault()` method to get either the assigned value
    or the default value of the underlying type if no value is assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing is performed on the underlying type. If the nullable type object has
    not assigned any value, the result of boxing is a `null` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the null-coalescing operator, `??`, to access the value of the object
    of a nullable type (for example, `int d = c ?? -1;`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C# 8, nullable reference types and non-nullable reference types have been
    introduced. That is a feature that you must opt for in the project properties.
    It allows you to make sure that only objects of reference types that are declared
    nullable, using the `T?` syntax can be assigned the `null` value. Attempts to
    do so on non-nullable reference types will result in a compiler warning (not an
    error, because that has the potential to affect large portions of existing code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You will learn more about nullable reference types in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a data structure that holds multiple values (including zero or a
    single one) of the same data type. It is a fixed-size sequence of homogeneous
    elements that are stored in contiguous memory locations. Arrays in C# are zero-indexed,
    meaning that the position of the first element of an array is zero and the position
    of the last element of the array is a total number of elements minus one.
  prefs: []
  type: TYPE_NORMAL
- en: The array type is a reference type and therefore arrays are allocated on the
    heap. The default value for the elements of numeric arrays is zero and for arrays
    of reference types, the default value is `null`. The type of the elements of an
    array can be of any type, including another array type.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays in C# can be one-dimensional, multi-dimensional, or jagged. Let's explore
    these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: One-dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A one-dimensional array can be defined using the syntax `datatype[] variable_name`.
    Arrays can be initialized when they are declared. If an array variable is not
    initialized, its value is `null`. You can specify the number of elements of the
    array when you initialize it, or you can skip this and let the compiler infer
    it from the initialization expression. The following sample shows various ways
    of declaring and initializing arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `arr1` and `arr2` have the value `null`. `arr3` is an array
    of six integer elements all set to `0` because no initialization was provided.
    `arr4`, `arr5`, and `arr6` are arrays of six integers, all containing the same
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Once initialized, the size of the array cannot be changed. If you need to do
    so, you must either create a new array object or instead use a variable-size container,
    such as `List<T>`, which we will look at in [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the elements of the array using the indexer, or with an enumerator.
    The following snippets are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Although the effect of these two loops is the same, there is a subtle difference—using
    an enumerator does not make it possible to modify the elements of the array. Accessing
    the elements by their index using the index operator does provide write access
    to the elements. Using an enumerator is possible because array types derive implicitly
    from the base type, `System.Array`, which implements `IEnumerable` and `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the first loop, we access the elements of the array by their index and can
    modify them. However, in the second loop, an iterator is used, and this provides
    read-only access to the elements. Trying to modify them produces a compile-time
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multi-dimensional array is an array with more than one dimension. It is also
    called a **rectangular array**. This can be, for instance, a two-dimensional array
    (a matrix) or a three-dimensional array (a cube). The maximum number of dimensions
    is **32**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-dimensional array can be defined using the following syntax: `datatype[,]
    variable_name;`. Multi-dimensional arrays are declared and initialized in a similar
    fashion with single-dimensional arrays. You can specify the rank (which is the
    number of elements) of each dimension or you can leave it to the compiler to infer
    it from an initialization expression. The following snippet shows different ways
    of declaring and initializing two-dimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `arr1` is initially `null` and then assigned a reference to
    an array of two rows and three columns. Similarly, `arr2` is also `null`. On the
    other hand, `arr3`, `arr4`, `arr5`, and `arr6` are arrays of two rows and three
    columns; `arr3` has all of the elements set to zero, while the others are initialized
    with the specified values. The arrays in this example have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the number of elements of each dimension using the `GetLength()`
    or `GetLongLength()` methods (the first returns a 32-bit integer, the second a
    64-bit integer). The following example prints the content of the `arr6` array
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays with more than two dimensions are created and handled in a similar way.
    The following example shows how to declare and initialize a three-dimensional
    array of *4 x 3 x 2* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another form of multi-dimensional arrays is the so-called **jagged array**.
    We will learn about this next.
  prefs: []
  type: TYPE_NORMAL
- en: Jagged arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jagged arrays are arrays of arrays. These consist of other arrays, and each
    array inside a jagged array can be of a different size. We can declare a two-dimensional
    jagged array, for instance, using the syntax `datatype [][] variable_name;`. The
    following snippet shows various examples of declaring and initializing jagged
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `arr1` and `arr2` are both set to `null`. On the other hand,
    `arr3` is an array of two arrays. Its first element is set to an array of three
    elements that are initialized with zero; its second element is set to an array
    of six elements initialized from the provided values.
  prefs: []
  type: TYPE_NORMAL
- en: The `arr4` and `arr5` arrays are equivalent, but `arr5` uses the shorthand syntax
    for array initialization. `arr6` mixes jagged arrays with multi-dimensional arrays.
    It is an array of two arrays, the first one being a two-dimensional array of *2x2*,
    and the second a two-dimensional array of *2x3* elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a jagged array can be accessed using the `arr[i][j]` syntax
    (this example is for two-dimensional arrays). The following snippet shows how
    to print the content of the `arr5` array shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have looked at the type of arrays we can use in C#, let's move to
    another important topic, which is conversion between various data types.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to convert one data type into another, and that is where
    **type conversion** comes in picture. Type conversion can be classified into several
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversions with helper classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit type conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For built-in numeric types, when we assign the value of a variable to one of
    another data type, implicit type conversion occurs if both types are compatible
    and the range of destination type is more than that of the source type. For example,
    `int` and `float` are compatible types. Therefore, we can assign an integer variable
    to a variable of the `float` type. Similarly, the `double` type is large enough
    to hold values from any other numerical type, including `long` and `float`, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the implicit type conversion between numeric types
    in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note about implicit numeric conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: You can convert any integral type to any floating-point type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no implicit conversion to the `char`, `byte`, and `sbyte` types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no implicit conversion from `double` and `decimal`; this includes no
    implicit conversion from `decimal` to `double` or `float`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For reference types, the implicit conversion is always possible between a class
    and one of its direct or indirect base classes or interfaces. Here is an example
    with an implicit conversion from `string` to `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `object` type (which is an alias for `System.Object`) is the base class
    for all .NET types, including `string` (which is an alias for `System.String`).
    Therefore, an implicit conversion from `string` into `object` exists.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit type conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an implicit conversion between two types is not possible because there
    is a risk of losing information (such as while assigning the value of a 32-bit
    integer to a 16-bit integer), explicit type conversion is necessary. **Explicit
    type** conversion is also called a **cast**. To perform casting, we need to specify
    the target data type in parentheses in front of the source variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `double` and `int` are *incompatible types*. Consequently, we
    need to do an explicit type conversion between them. In the following example,
    we assign a `double` value (`d`) to an integer using explicit type conversion.
    However, while doing this conversion, the fractional part of the `double` variable
    will be truncated. Hence, the value of `i` will be `12`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the list of predefined explicit conversions between
    numeric types in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several things to note about explicit numeric conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: An explicit conversion may result in precision loss or in throwing an exception,
    such as `OverflowException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When converting from an integral type to another integral type, the result depends
    on the so-called **checked context** and may result either in a successful conversion,
    which may discard extra most-significant bytes, or in an overflow exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you convert a floating-point type to an integral type, the value is rounded
    toward zero to the nearest integral value. The operation may, however, also result
    in an overflow exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# statements can execute either in a *checked* or *unchecked* context, which
    is control either with the `check` and `unchecked` keywords or with the compiler
    option, `-checked`. When none of these are specified, the context is considered
    unchecked for non-constant expressions. For constant expressions, which can be
    evaluated at compile time, the default context is always checked. In a checked
    context, overflow checking is enabled for integral-type arithmetic operations
    and conversions. In an unchecked context, these checks are suppressed. When overflow
    checking is enabled and overflow occurs, the runtime throws a `System.OverflowException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference types, an explicit cast is required when you want to convert
    from a base class or interface into a derived class. The following example shows
    a cast from an `object` to a `string` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The conversion from `string` into `object` is performed implicitly. However,
    the opposite requires an explicit conversion in the `(string)o` form, as shown
    in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined type conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A user-defined conversion can define an implicit or explicit conversion or
    both from one type into another. The type that defines these conversions must
    be either the *source* or the *target type*. To do so, you must use the `operator`
    keyword followed by `implicit` or `explicit`. The following example shows a type
    called `fancyint`, which defines implicit and explicit conversions from and to
    `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `a` is an object of the `fancyint` type. The value of `a` can
    be implicitly converted into `int`, because an implicit conversion operator is
    defined. However, the conversion from `int` to `fancyint` is defined as explicit,
    therefore a cast is necessary, as in `(fancyint)i`.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions with helper classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conversion with a helper class or method is useful to convert between incompatible
    types, such as between a string and an integer or a `System.DateTime` object.
    There are various helper classes provided by the framework, such as the `System.BitConverter`
    class, the `System.Convert` class, and the `Parse()` and `TryParse()` methods
    of the built-in numeric types. However, you can provide your own classes and methods
    to convert between any types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows several examples of conversion using helper classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note the key difference between `Parse()` and `TryParse()`.
    The former tries to perform parsing and if that succeeds, it returns the parsed
    value; but if it fails, it throws an exception. The latter does not throw an exception,
    but returns `bool`, indicating the success or failure, and sets the second `out`
    parameter to the parsed value if successful or to the default value if it fails.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# provides an extensive set of operators for built-in types. Operators are
    broadly classified in the following categories: arithmetic, relational, logical,
    bitwise, assignment, and other operators. Some operators can be overloaded for
    user-defined types. This topic will be further discussed in [*Chapter 5*](B12346_05_Final_JC_ePub.xhtml#_idTextAnchor103),
    *Object-Oriented Programming in C#*.'
  prefs: []
  type: TYPE_NORMAL
- en: When evaluating an expression, operator precedence and associativity determine
    the order in which the operations are performed. You can change this order by
    using *parentheses*, just like you would do with a mathematical expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the order of the operators with the highest precedence
    at the top and the lowest at the bottom. Operators that are listed together, on
    the same row, have equal precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For operators with the same precedence, associativity determines which one
    is evaluated first. There are two types of associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Left-associativity**: This determines operators to be evaluated from *left
    to right*. All of the binary operators are left-associative except for the assignment
    operators and the null coalescing operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right-associativity**: This determines operators to be evaluated from *right
    to left*. The assignment operator, the null-coalescing operator, and the conditional
    operator are right-associative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will take a closer look at each category of operators.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Arithmetic operators** perform arithmetic operations on the numerical type
    and can be unary or binary operators. A unary operator has a single operand, and
    a binary operator has two operands. The following set of arithmetic operators
    are defined in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_13.png)'
  prefs: []
  type: TYPE_IMG
- en: '`+`, `-`, and `*` will work as per the mathematical rules of addition, subtraction,
    and multiplication respectively. However, the `/` operator behaves a bit differently.
    When applied to an integer, it will truncate the remainder of the division. For
    example, 20/3 will return 6\. To get the remainder, we need to use the modulus
    operator. For example, 20%3 will return 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among these, the increment and decrement operators require special attention.
    These operators have two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: A postfix form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prefix form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The increment operator will increase the value of its operand by `1`, whereas
    the decrement operator will decrease the value of its operand by `1`. In the following
    example, the `a` variable is initially `10`, but after applying the increment
    operator, its value will be `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The prefix and the postfix variants differ in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The prefix operator first performs the operation and then returns the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The postfix operator first retains the value, then increments it, and then returns
    the original value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand this with the help of the following code snippet. In the
    following example, `a` is `10`. When `a++` is assigned to `b`, `b` takes the value
    `10` and `a` is incremented to `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change this so that we assign `++a` to `b`, then `a` will be
    incremented to `11`, and that value will be assigned to `b`, so both `a` and `b`
    will have the value `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The next category of operators that we will learn about is the relational operator.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Relational operators, also called **comparison operators**, perform a comparison
    on their operands. C# defines the following sets of relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result of a relational operator is a `bool` value. These operators support
    all of the built-in numerical and floating-point types. However, enumerations
    also support these operators. For operands of the same enumeration type, the corresponding
    values of the underlying integral types are compared. Enumerations will be later
    discussed in [*Chapter 4*](B12346_04_Final_JC_ePub.xhtml#_idTextAnchor083), *Understanding
    the Various User-Defined Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code listing shows several relational operators being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `<`, `>`, `<=`, and `>=` operators can be overloaded for user-defined types.
    However, if a type overloads `<` or `>`, it must overload both of them. Similarly,
    if a type overloads `<=` or `>=`, it must overload both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators perform a logical operation on `bool` operands. The following
    set of logical operators are defined in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example shows these operands in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, since `a` is `true` and `b` is `false`, `c` will be `false`
    and `d` will be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise and shift operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bitwise operator will work directly on the bits of their operands. A bitwise
    operator can only be used with integer operands. The following table lists all
    of the bitwise and shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, `a` is `10`, which in binary is `1010`, and `b` is
    `5`, which in binary is `0101`. The result of the bitwise AND is `0000`, so `c`
    will have the value `0`, and the result of bitwise OR is `1111`, so `d` will have
    the value `15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The left-shift operator shifts the left-hand operand to the left by the number
    of bits defined by the right-hand operand. Similarly, the right-shift operator
    shifts the left-hand operand to the right by the number of bits defined by the
    right-hand operand. The left-shift operator discards the higher-order bits that
    are outside the range of the result type and sets the lower-order bits to zero.
    The right-shift operator discards the lower-order bits and the higher-order bits
    are set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value that is shifted is `int` or `long`, an arithmetic shift is performed.
    That means the sign bit is propagated to the right on the higher-order empty bits.
    As a result, for a positive number, the higher-order bits are set to zero (because
    the sign bit is *0*) and for a negative number, the higher-order bits are set
    to one (because the sign bit is *1*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value that is shifted is `uint` or `ulong`, a logical shift is performed.
    In this case, the higher-order bits are always set to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shift operations are only defined for `int`, `uint`, `long`, and `ulong`.
    If the left-hand operand is of another integral type, it is converted to `int`
    before the operation is applied. The result of a shift operation will always contain
    at least 32 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows examples of shifting operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we initialized the `x` and `y` variables with binary literals
    to make it easier to understand how shifting works. The value of the variables
    after shifting is also shown in binary in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An assignment operator assigns a value to its left operand based on the value
    of its right operand. The following assignment operators are available in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_2_Table_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this table, we have the simple assignment operator (`=`) that assigns the
    right-hand value to the left operand, and then we have compound assignment operators,
    that first perform an operation (arithmetical, shifting, or bitwise) and then
    assign the result of the operation to the left operand. Therefore, operations
    such as `a = a + 2` and `a += 2` are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Other operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the operators discussed so far, there are other useful operators
    in C# that work both on built-in types and user-defined types. These include the
    conditional operator, the null-conditional operators, the null-coalescing operator,
    and the null-coalescing assignment operator. We will look at these operators in
    the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary conditional operator
  prefs: []
  type: TYPE_NORMAL
- en: The `?:` and often simply referred to as the *conditional operator*. It allows
    you to return a value from two available options based on whether a Boolean condition
    evaluates to `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the ternary operator is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If the Boolean condition evaluates to `true`, the `consequent` expression will
    be evaluated, and its result returned. Otherwise, the `alternative` expression
    will be evaluated, and its result returned. The ternary conditional operator can
    also be perceived as a shorthand for an `if-else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the function called `max()` returns the maximum of
    two integers. The conditional operator is used to check whether `a` is greater
    or equal to `b`, in which case the value of `a` is returned; otherwise, the result
    is the value of `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another form of this operator called **conditional ref expression**
    (available since C# 7.2) that allows returning the reference to the result of
    one of the two expressions. The syntax, in this case, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The result reference can be assigned to a `ref` local or `ref` read-only local
    variable and uses it as a reference return value or as a ref method parameter.
    The conditional `ref` expression requires the type of `consequent` and `alternative`
    to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the conditional `ref` expression is used to select
    between two alternatives based on user input. If an even number is introduced,
    the `v` variable will hold a reference to `a`; otherwise, it will hold a reference
    to `b`. The value of `v` is incremented and then `a` and `b` are printed to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: While the conditional operator checks whether a condition is true or not, the
    null-conditional operator checks whether an operand is null or not. We will look
    at this operator in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The null-conditional operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `?.` (also known as the `?[]` to apply element access for an array. These
    operators apply the operation to their operand if and only if that operand is
    not `null`. Otherwise, the result of applying the operator is also `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use the null-conditional operator to invoke
    a method called `run()` from an instance of a class called `foo`, through an object
    that might be `null`. Notice that the result is a nullable type (`int?`) because
    if the operand of `?.` is `null`, then the result of its evaluation is also `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The null-conditional operators can be *chained* together. However, if one operator
    in the chain is evaluated to `null`, the rest of the chain is *short-circuited*
    and does not evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `bar` class has a property of the `foo` type.
    An array of `bar` objects is created and we try to retrieve the value from the
    execution of the `run()` method from the `f` property of the first `bar` element
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can avoid the use of a nullable type if we combine the null-conditional
    operator with the null-coalescing operator and provide a default value in case
    the null-conditional operator returns `null`. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The null-coalescing operator is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The null-coalescing and null-coalescing assignment operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `??`, will return the left-hand operand if it is not `null`; otherwise,
    it will evaluate the right-hand operand and return its result. The left-hand operand
    cannot be a non-nullable value type. The right-hand operand is only evaluated
    if the left-hand operand is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The `??=`, is a new operator added in C# 8\. It assigns the value of its right-hand
    operand to its left-hand operand, if and only if the left-hand operand evaluates
    to `null`. If the left-hand operand is not `null`, then the right-hand operand
    is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Both `??` and `??=` are *right-associative*. That means, the expression `a ??
    b ?? c` is evaluated as `a ?? (b ?? c)`. Similarly, the expression `a ??= b ??=
    c` is evaluated as `a ??= (b ??= c)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a nullable variable, `n1`, and initialized it to `null`. The
    value of `n2` will be set to `2` as `n1` is `null`. After assigning `n1` a non-null
    value, we will apply the conditional operator on `n1` and integer `2`. In this
    case, since `n1` is not `null`, the value of `n3` will be the same as that of
    `n1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The null-coalescing operator can be used multiple times in an expression. In
    the following example, the `GetDisplayName()` function returns the value of `name`
    if this is not `null`; otherwise, it returns the value of `email` if it is not
    `null`; if `email` is also `null`, then it returns `"unknown"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The null-coalescing operator can also be used in argument checking. If a parameter
    is expected to be non-null, but it is in fact `null`, you can throw an exception
    from the right-hand operand. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The null-coalescing assignment operator is useful in replacing code that checks
    whether a variable is `null` before assigning it with a simpler, more succinct
    form. Basically, the `??=` operator is syntactic sugar for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This can be replaced with `a ??= b`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about built-in data types in C#, which are the numerical
    types, floating-point types, Boolean and character types, string, and object.
    Moreover, we also covered nullable types and array types. We learned about variables
    and constants and looked at the differences between value types and reference
    types. In addition to this, we covered the concepts of type conversion and casting.
    At the end of this chapter, we learned about the various types of operators available
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore control statements and exceptions in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the integral built-in types in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between the floating-point types and the `decimal`
    type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you concatenate strings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are escape sequences and how are they related to verbatim strings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an implicitly typed variable? Can these variables be initialized with
    `null`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are value types? What are reference types? What are the main differences
    between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are boxing and unboxing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a nullable type and how do you declare a nullable integer variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many types of arrays exist and what is the difference between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the available type conversions and how do you provide user-defined
    type conversion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
