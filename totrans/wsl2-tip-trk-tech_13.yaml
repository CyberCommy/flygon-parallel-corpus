- en: '*Chapter 10*: Visual Studio Code and Containers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111), *Visual Studio
    Code and WSL*, we saw how the Visual Studio Code editor allows the user interface
    to be separated from other functionality that interacts with our code and runs
    it. With WSL, this allows us to keep the familiar Windows-based user interface
    while running all the key parts of our project in Linux. In addition to allowing
    the code interactions to run in a server component in WSL, Visual Studio Code
    also allows us to connect to the code server via SSH or to run it in a container.
    The ability to run in a container is provided by the **Remote-Containers** extension,
    and this chapter will focus on how we can use this functionality. We will see
    how we can use these development containers (or **dev container**) to encapsulate
    our project dependencies. By doing this, we make it easier to onboard people to
    our projects and gain an elegant way to isolate potentially conflicting toolsets
    between projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Visual Studio Code Remote-Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Remote-Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dev container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a containerized app in dev containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Kubernetes in dev containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for working with dev containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this chapter, you will need to have Visual Studio Code installed – see [*Chapter
    9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111), *Visual Studio Code and WSL*,
    the *Introducing Visual Studio Code* section for more details. We'll start the
    chapter by introducing the Remote-Containers extension for Visual Studio Code
    and getting it installed.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Visual Studio Code Remote-Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Remote-Containers extension for Visual Studio Code sits as part of the Remote-Development
    extension pack alongside **Remote-WSL** and **Remote-SSH**. All of these extensions
    allow you to separate the user interface aspects from the code interactions, such
    as loading, running, and debugging your code. With Remote-Containers, we instruct
    Visual Studio Code to run these code interactions inside a container that we define
    in a **Dockerfile** (see [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Introducing Dockerfiles* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'When Visual Studio Code loads our project in a dev container, it goes through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the container image from the Dockerfile
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runs a container using the resulting image, mounting the source code in the
    container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs the VS code server in the container for the user interface to connect
    to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through these steps, we get a container image that contains the dependencies
    described by our Dockerfile. By mounting the code inside the container, it is
    made available inside the container, but there is only a single copy of the code.
  prefs: []
  type: TYPE_NORMAL
- en: On development projects, it is common to have a list of tools or prerequisites
    that need to be installed to prepare your environment for working with the project
    in the project documentation. If you're really lucky, the list will even be up
    to date! By using *dev containers*, we can replace the list of tools in the documentation
    with a set of steps in a Dockerfile that perform the steps for us. Because these
    images can be rebuilt, the standard way to install a tool now becomes the Dockerfile.
    Since this is part of source control, these changes in required tools will be
    shared with other developers who can simply rebuild their dev container image
    from the Dockerfile to update their set of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of dev containers is that the dependencies are installed in
    containers and so are isolated. This allows us to create containers for different
    projects with different versions of the same tools (for example, Python or Java)
    without conflicts. This isolation also allows us to update the versions of tools
    independently between projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at getting the Remote-Containers extension installed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Remote-Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the Remote-Containers extension, you will need it installed, and you
    will also need to have Docker installed and accessible in WSL. See [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Installing and using Docker with WSL* section
    for how to configure this. If you already have Docker Desktop installed, ensure
    that it is configured to use the **WSL 2-based engine**. The WSL 2 engine uses
    a Docker daemon running in WSL 2, so your code files (from WSL 2) can be mounted
    directly in your containers, without going through the Linux-to-Windows file share.
    This direct mounting gives you better performance, ensures that file events are
    handled correctly, and uses the same file cache (see this blog post for more details:
    [https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)](https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Docker configured, the next step is to install the Remote-Containers
    extension. You can do this by searching for `Remote-Containers` in the **EXTENSIONS**
    view in Visual Studio Code, or from [https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers).
  prefs: []
  type: TYPE_NORMAL
- en: With the extension installed, let's look at how to create a dev container.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dev container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a dev container to a project, we need to create a `.devcontainer` folder
    with two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile` to describe the container image to build and run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devcontainer.json` to add additional configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This combination of files will give us a single-container configuration. Remote-Containers
    also supports a multi-container configuration using **Docker Compose** (see [https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose](https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose))
    but we will focus on the single-container scenario for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The accompanying code for the book contains a sample project that we will use
    to explore dev containers. Ensure that you clone the code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)
    in a Linux distribution. Once the code is cloned, open the `chapter-10/01-web-app`
    folder in Visual Studio Code (there is also a `chapter-10/02-web-app-completed`
    folder with all of the steps from this section applied as a reference). This sample
    code doesn't yet have a dev container definition, so let's look at how to add
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and opening a dev container definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step for dev containers is to create the **dev container definition**,
    and the Remote-Containers extension gives us some assistance here. With the sample
    project open in Visual Studio Code, select **Remote-Containers: Add Development
    Container Configuration Files…** from the command palette and you will be prompted
    to choose a configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A screenshot showing the list of dev container configurations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – A screenshot showing the list of dev container configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in this screenshot, there is a range of predefined dev container configurations
    that we can start from. For the sample project, choose `.devcontainer` folder
    with `devcontainer.json` and `Dockerfile` configured for working with Python 3\.
    Once these files have been added, you should see the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A screenshot showing the Reopen in Container prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – A screenshot showing the Reopen in Container prompt
  prefs: []
  type: TYPE_NORMAL
- en: 'This prompt appears when Visual Studio Code detects that you have a folder
    open with a dev container definition. Click on **Reopen in Container** to open
    the folder in a dev container. If you miss the prompt, you can use the **Remote-Containers:
    Reopen in Container** command from the command palette to achieve the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After choosing to reopen the folder in a container, Visual Studio Code will
    restart and begin building the container image to run the code server in. You
    will see a notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – A screenshot showing the Starting with Dev Container notification'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – A screenshot showing the Starting with Dev Container notification
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the notification that the dev container is starting. If
    you click on the notification, you will be taken to the **Dev Containers** pane
    in the **TERMINAL** view. showing the commands and output from building and running
    the container. As you start customizing your dev container definitions, this window
    is useful for debugging scenarios such as when your container image fails to build.
    Now that we have the project open in a dev container, let's start exploring it.
  prefs: []
  type: TYPE_NORMAL
- en: Working in the dev container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the dev container has been built and started, you will see the contents
    of the sample code in the `name` property in `devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet from `devcontainer.json`, the dev container name has been changed
    to `chapter-10-01-web-app`. This change will take effect the next time the dev
    container is built and loaded. Setting the name to be meaningful is particularly
    helpful if you sometimes have more than one dev container loaded at any time as
    it shows in the Window title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s open the `app.py` file, which contains the application code for
    the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A screenshot showing an import error in app.py'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – A screenshot showing an import error in app.py
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see the red underline beneath the line importing
    the Flask package, which shows once the Python extension has loaded and processed
    the file. This error indicates that Python cannot find the Flask package. Hopefully,
    this makes sense – all the tooling runs in a container that has Python installed,
    but nothing else. Let's quickly fix this. Open the integrated terminal using *Ctrl*
    + *`* (backtick) or `pip3 install -r requirements.txt` to install the requirements
    listed in `requirements.txt` (which includes Flask). With the requirements installed,
    the Python language server will eventually update to remove the red underline
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we will look at how to automatically install the requirements
    when the container is built to give a smoother experience; but now that we have
    everything in place, let's run the code.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample code includes a `.vscode/launch.json` file describing how to launch
    our code. This file allows us to configure things such as the command-line arguments
    passed to the process and the environment variables that should be set. For an
    introduction to `launch.json` and creating one from scratch, see [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, the *Debugging our app* section.
  prefs: []
  type: TYPE_NORMAL
- en: With `launch.json`, we can simply press *F5* to launch our application under
    the debugger. If you want to see the interactive debugger in action, use *F9*
    to place a breakpoint (the `return` statement in the `get_os_info` function is
    a good place).
  prefs: []
  type: TYPE_NORMAL
- en: 'After launching, you will see the debugger commands executed in the **TERMINAL**
    view and the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this output, you can see the app starting up and showing the address and
    port that it is listening on (`http://127.0.0.1:5000`). As you hover over this
    address with the mouse, you will see a popup showing that you can use *Ctrl* +
    Click to open the link. Doing this will launch your default Windows browser at
    that address, and if you set a breakpoint, you will find that the code has paused
    at that point for you to inspect the variables and so on. Once you''ve finished
    exploring the debugger, press *F5* to continue execution and you will see the
    rendered response in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – A screenshot showing the web page from the Python app in the
    Windows browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – A screenshot showing the web page from the Python app in the Windows
    browser
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the browser with the web page loaded from our Python app.
    Notice the hostname (`831c04e3574c` in the screenshot, but you will see a different
    ID as it changes for each container), which is the short container ID that is
    set as the hostname in the instance of the container where the app is running.
    We are able to load the web page from Windows because the Remote-Containers extension
    automatically set up port forwarding for us. This port forwarding listens on port
    `5000` on Windows and forwards the traffic to port `5000` in the container where
    our Python app is listening and responding.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a container running in Docker in WSL with all of our
    developer tooling running (including Python and the Visual Studio Code server)
    and we are able to work with the code in the rich, interactive way that we have
    come to expect. We can easily launch the code in a debugger to step through the
    code and inspect the variables, and then interact with our web app from Windows.
    All of this runs as smoothly as if the code was running on the host, but we have
    all the advantages of isolation and automation of our development environment
    that dev containers bring us.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll explore how to customize the dev container definition as we explore
    packaging and working with our application as a container in the dev container.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a containerized app in dev containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how to use a dev container to develop an application, but
    what if we want to develop an application that will itself be packaged and run
    in a container, possibly in Kubernetes? In this section, we will focus on that
    scenario, looking at how to both build and run a container image for our application
    from inside the dev container.
  prefs: []
  type: TYPE_NORMAL
- en: We will again use the accompanying code for the book as a starting point for
    this section. Ensure that you clone the code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)
    in a Linux distro. Once the code is cloned, open the `chapter-10/03-web-app-kind`
    folder in Visual Studio Code (there is also a `chapter-10/04-web-app-kind-completed`
    folder with all of the steps from this section applied as a reference). The `03-web-app-kind`
    folder contains a web app very similar to the one we've just been working with,
    but with a few extra files added to help us integrate the application into Kubernetes
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable us to work with the app in Docker, we need to go through a few steps
    similar to those we went through in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, in the *Building and running a web application
    in Docker* section except that this time, we will be working within our dev container:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up Docker in the dev container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the application Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by looking at how to set up the dev container to allow us to build
    our application container image.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Docker in the dev container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step we will take to enable building Docker images is to install
    the `docker` `.devcontainer/Dockerfile` in Visual Studio Code and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, notice the lines between `# Install docker` and `# Install
    docker (END)`. These lines have been added to follow the steps from the Docker
    documentation to add the `apt` repository, and then use that repository to `apt-get
    install` the `docker-ce-cli` package. At this point, rebuilding and opening the
    dev container would give you an environment with the `docker` CLI, but no daemon
    for it to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have set up Docker on the host machine, and Visual Studio Code uses the
    Docker daemon this provides to build and run the dev container that we use for
    development. To build and run Docker images inside your container, you may consider
    installing Docker inside the dev container. This is possible but can get quite
    complex and add performance issues. Instead, we will reuse the Docker daemon from
    the host within the dev container. On Linux, the default communication with Docker
    is via the `/var/run/docker.sock` socket. When running containers using the `docker`
    CLI, you can mount sockets using the `--mounts` switch ([https://docs.docker.com/storage/bind-mounts/](https://docs.docker.com/storage/bind-mounts/)).
    For the dev container, we can specify this using the `mounts` property in `.devcontainer/devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows the `mounts` property in `devcontainer.json`, which specifies
    the mounts that Visual Studio Code will use when it runs our dev container. This
    property is an array of mount strings, and here we have specified that we want
    a `bind` mount (that is, a mount from the host) that mounts `/var/run/docker.sock`
    on the host to the same value inside the dev container. The effect of this is
    to make the socket for the Docker daemon on the host available inside the dev
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, using the `docker` CLI installed ready for you to use in the
    terminal. Any `docker` commands that you run will be executed against the Docker
    Desktop daemon; so, for example, running `docker ps` to list containers will include
    the dev container in its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This output from `docker ps` executed in the terminal in the dev container includes
    the dev container itself, confirming that the Docker commands are connecting to
    the host Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had already opened the dev container before updating the Dockerfile
    and `devcontainer.json` (or any time you modify these files), you can run the
    **Remote-Containers: Rebuild and reopen in Container** command. This command will
    rerun the build process for the dev container and then reopen it, applying your
    changes to the dev container.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Docker installed and configured, let's build the container
    image for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build the Docker image for our application, we can run the `docker build`
    command. Since the Docker CLI is configured to talk to the host Docker daemon,
    any images we build from within the dev container are actually built on the host.
    This removes some of the isolation that you might expect from dev containers,
    but we can work around this by ensuring that the image names we use are unique
    to avoid name collisions with other projects.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code already has a Dockerfile in the root folder that we will use
    to build the application's Docker image (not to be confused with `.devcontainer/Dockerfile`,
    which is used to build the dev container). The Dockerfile builds on a `python`
    base image before copying in our source code and configuring the startup command.
    For more details on the Dockerfile, refer [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Introducing Dockerfiles* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application image, open the integrated terminal as we did earlier
    in the chapter and run the following command to build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will pull the Python image (if not present) and run each of the
    steps in the Dockerfile before outputting `Successfully tagged simple-python-app-2:v1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built the application image, let's run it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our image, we will use the `docker run` command. From the integrated
    terminal in Visual Studio Code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this output, you can see that we are running a container named `chapter-10-example`
    using the `simple-python-app-2:v1` image we built previously. We have specified
    --`network=container:$HOSTNAME`, which puts the newly created container on the
    same Docker network as the dev container. Note that we''re using `$HOSTNAME` to
    specify the ID of the dev container since the container ID is used as the machine
    name in running container (as we saw in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*,
    Working with Containers in WSL, in the Building and running* *a web application
    in Docker* section). For more information on the `--network` switch see [https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings).
    We can confirm that we are able to access the web app in the running container
    by running `curl` from the integrated terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this output, you can see the HTML response from the web app in response to
    the `curl` command. This confirms that we can access the application from inside
    the dev container.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to access the web application from a browser in Windows, it won't
    be able to connect. This is because the container port from the web application
    has been mapped into the Docker network for the dev container. Fortunately, Remote-Containers
    provides a `5000`, we enable the web browser in Windows to also access the web
    app running in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dev container ports that you regularly want to access on the host in this
    way, it is convenient to update `devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, you can see the `forwardPorts` property. This is an array of
    ports that you can configure to be automatically forwarded when running your dev
    container to save the manual step of forwarding them each time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to running the web application container using the `--network`
    switch, we can instead configure the dev container to use host networking (using
    `--network=host` as shown in the next section). With this approach, the dev contaienr
    re-uses the same network stack as the host, so we can run our web application
    container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run -d -p 5000:5000 --name chapter-10-example simple-python-app-2:v1`'
  prefs: []
  type: TYPE_NORMAL
- en: In this command,we have used `-p 5000:5000` to expose the web application port
    5000 to the host as we saw in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*,
    Working with Containers in WSL,* in the Building and running a web application
    in Docker section.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have set up our dev container to connect to Docker on our
    host and reuse it for building and running images using the Docker CLI we installed
    in the dev container. Now that we have tested building a container image for our
    web app and checked that it runs correctly, let's look at running it in Kubernetes
    while working from our dev container.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes in dev containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a container image for our web app that we can build from inside
    our dev container, we will look at the steps needed to be able to run our app
    in Kubernetes. This section is fairly advanced (especially if you're not familiar
    with Kubernetes), so feel free to skip ahead to the *Tips for working with dev
    containers* section and come back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at how to set up the dev container for working with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Options for Kubernetes with dev containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many options for working with Kubernetes in WSL. The common options
    are outlined in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, in the *Setting up Kubernetes in WSL* section.
    In that chapter, we used the Kubernetes integration in Docker Desktop, which is
    a low-friction way to set up Kubernetes. This approach can also be used with dev
    containers with a couple of steps (assuming you have enabled the Docker Desktop
    integration):'
  prefs: []
  type: TYPE_NORMAL
- en: Mount a volume to map the `~/.kube` folder from WSL into the dev container as
    `/root/.kube` to share the configuration for connecting to the Kubernetes API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `kubectl` CLI for working with Kubernetes as a step in the dev container
    Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step uses the mounts in `devcontainer.json`, as we saw in the previous
    section (the standard practice to refer to your user home folder is to use environment
    variables – for example, `${env:HOME}${env:USERPROFILE}/.kube`). We will cover
    the second step of installing `kubectl` in a moment. We will be exploring a different
    approach for Kubernetes in this chapter, but there is a `chapter10/05-web-app-desktop-k8s`
    folder in the code accompanying the book that has a dev container with both of
    these steps completed.
  prefs: []
  type: TYPE_NORMAL
- en: While the Docker Desktop Kubernetes integration is convenient, it adds an extra
    requirement to the host configuration. By default, a dev container only requires
    that you have Visual Studio Code with Remote-Containers installed and a Docker
    daemon running, with the rest of the project requirements satisfied by the contents
    of the dev container. Requiring the Kubernetes integration in Docker Desktop reduces
    the dev container portability slightly. Another consideration is that using the
    Docker Desktop integration means that you are using a *Kubernetes cluster* that
    is shared across your machine. This loss of isolation can be particularly relevant
    when your project involves creating Kubernetes integrations such as operators
    or other components that might apply policies. The `kind` project ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    offers an alternative approach, allowing us to easily create and manage Kubernetes
    clusters from within the dev container using *Docker* (in fact, *kind* stands
    for *K*ubernetes *in* *D*ocker). This approach also works well if you plan to
    reuse your dev container in `kind` in the dev container.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up kind in a dev container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will walk through the steps to install `kind` (and `kubectl`)
    in a dev container. This will allow us to create Kubernetes clusters with the
    `kind` CLI from within the dev container, and then access them using `kubectl`.
    To do this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add steps to install `kind` and `kubectl` in the dev container Dockerfile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `devcontainer.json` to enable connecting to the `kind` clusters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install `kind`, open the `.devcontainer/Dockerfile` and add the following
    `RUN` command (after the `RUN` command that starts with `apt-get update`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `RUN` command in this snippet follows the documentation for installing `kind`
    ([https://kind.sigs.k8s.io/docs/user/quick-start/#installation](https://kind.sigs.k8s.io/docs/user/quick-start/#installation))
    and uses `curl` to download the release binary for `kind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the following `RUN` command after the previous one to install `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `RUN` step installs `kubectl` based on the documentation ([https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)).
    The first of these commands uses `curl` to download the release binary (version
    `1.19.0` in this case). The second command makes the downloaded binary executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the installation configured for `kind` and `kubectl`, we need
    to make some changes to `.devcontainer/devcontainer.json`. The first of these
    is to add a volume for the `.kube` folder in the dev container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows the `mounts` property that we previously used to bind the
    host's Docker socket with a new mount configured to create a volume that targets
    the `/root/.kube` folder in the dev container. When we run `kind` to create a
    Kubernetes cluster, it will save the configuration for communicating with the
    cluster in this folder. By adding a volume, we ensure that the contents of that
    folder persist across instances (and rebuilds) of the dev container so that we
    can still connect to the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, `kind` generates lists the Kubernetes API endpoint as
    `127.0.0.1` (local IP address). This refers to the host, but the dev container
    is on an isolated Docker network by default. To enable the dev container to access
    the Kubernetes API using the configuration that `kind` generates, we can put the
    dev container into host networking mode by updating `.devcontainer/devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, you can see the `runArgs` property. This allows us to configure
    additional arguments that Remote-Containers passes to the `docker run` command
    when it starts our dev container. Here, we set the `--network=host` option, which
    runs the container in the same network space as the host (see [https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, we can rebuild and reopen the dev container and we're ready
    to create a Kubernetes cluster and run our app in it!
  prefs: []
  type: TYPE_NORMAL
- en: Running our app in a Kubernetes cluster with kind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have all the pieces in place to create a Kubernetes cluster from within
    our dev container. To create a cluster, we will use the `kind` CLI from the integrated
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A screenshot showing kind cluster creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – A screenshot showing kind cluster creation
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the output from running `kind create cluster --name chapter-10-03`.
    The `kind` CLI takes care of pulling the container image for the nodes if not
    already present, and then updates the output as it progresses through the steps
    to set up a cluster. By default, `kind` creates a single-node cluster, but there
    is a range of configuration options that include setting up multi-node clusters
    (see [https://kind.sigs.k8s.io/docs/user/configuration/](https://kind.sigs.k8s.io/docs/user/configuration/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use this cluster to run our application (assuming you have built
    the container image in the previous section; if not, run `docker build -t simple-python-app-2:v1
    -f Dockerfile.`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the container image for our application available in the `kind` cluster,
    we need to run `kind load` (see [https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `kind load` command to load the `simple-python-app-2:v1`
    image into the `chapter-10-03` cluster we created. This loads the image onto all
    the nodes in the cluster so that it is available for us to use when creating deployments
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `manifests` folder in the sample app contains the definitions for configuring
    the app in Kubernetes. Refer to [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Running a web application in Kubernetes*
    section, which has a walkthrough and explanation of the deployment files for a
    very similar application. We can deploy the application to Kubernetes with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `kubectl apply` with the `-f` switch to pass it a path to load
    the manifests from. In this case, we specify the `manifests` folder so that `kubectl`
    will apply all the files in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our web app is now running on a node in the `kind` cluster and the configuration
    we just applied created a Kubernetes service in front to expose port `5000`. This
    service is only available within the `kind` cluster, so we need to run `kubectl
    port-forward` to forward a local port to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the output, you can see the `kubectl port-forward` command used to specify
    the `service/chapter-10-03-example` service as the target, and `5000` as the port
    we want to forward. This sets up port forwarding from the local port `5000` in
    the dev container to port `5000` on the service for our application running in
    `kind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a new integrated terminal (by clicking on the plus sign at the
    top right of the integrated terminal), you can use it to run a `curl` command
    to verify that the service is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This output shows `curl localhost:5000` run from inside the dev container and
    accessing the web app deployed in the `kind` cluster using the `kubectl` port
    forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we were working with the app using Docker earlier in the chapter, we configured
    the `forwardPorts` property in `devcontainer.json` to forward port `5000`. This
    means that Visual Studio Code is already set up to forward port `5000` on Windows
    to port `5000` in our dev container. Any traffic sent to port `5000` in the dev
    container will be handled by the `kubectl` port-forwarding command we just ran
    and will be forwarded to port `5000` on the Kubernetes service. This means that
    we can open up `http://localhost:5000` in a browser in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – A screenshot with the Windows browser showing the app in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – A screenshot with the Windows browser showing the app in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, we can see the Windows browser accessing our app in Kubernetes
    via `http://localhost:5000`. This works because Visual Studio Code forwards the
    Windows port `5000` to port `5000` inside the dev container, which is handled
    by `kubectl port-forward` and forwarded to the Kubernetes service we deployed
    for our app.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used *Visual Studio Code*, *Remote-Containers*, and *Docker*
    to create a containerized development environment for working with a web app.
    We saw how we can use this to build and run container images for our web app,
    and then create a Kubernetes cluster and deploy and test our app in the cluster,
    including how to access the web application running in Kubernetes from a browser
    on the host Windows machine. We achieved all of this without adding any further
    requirements to the host machine, making this a portable solution that is quick
    for anyone with Visual Studio Code and Docker to get up and running on their machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will cover a few productivity tips
    for working with dev containers.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for working with dev containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a few tips that we can use to fine-tune the
    experience of working with dev containers. Let's start by looking at how we can
    automate steps inside the dev container after it has been built.
  prefs: []
  type: TYPE_NORMAL
- en: postCreateCommand and automating pip install
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the early examples in this chapter examples earlier in the chapter, we had
    to run `pip install` after building the dev container, and this is required each
    time you rebuild the dev container after making changes to its configuration.
    To avoid this, it might be tempting to add a `RUN` step to the dev container Dockerfile
    to perform `pip install`, but I prefer not to put application packages into the
    dev container image. Application package dependencies tend to evolve over time,
    and building them into the image (and rebuilding the image to install) feels a
    little heavyweight. Over time, when working with dev containers, my rule of thumb
    has become to install tools in the dev container image and install application
    packages inside the dev container once running. Fortunately, dev containers provide
    us with a `postCreateCommand` option to configure in `devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows `postCreateCommand` configured to run the `pip install` step.
    Visual Studio Code will automatically run `postCreateCommand` when it starts up
    the dev container after rebuilding the image.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run multiple commands, you can combine them as `command1 && command2`,
    or put them in a script file and run the script from `postCreateCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: While we're looking at settings that automate dev container tasks, let's take
    another look at port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we made use of the port forwarding in Visual Studio
    Code to forward selected traffic from the Windows host into the dev container
    – for example, to allow the Windows browser to connect to the web app running
    in the dev container. One way to set up port forwarding is to use the `devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we have specified ports `5000` and `5001` in the `forwardPorts`
    property. Visual Studio Code will automatically start forwarding these ports for
    us when it launches the dev container, helping to smooth out our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what ports are being forwarded, switch to the **REMOTE EXPLORER** view
    (for example, by running the **Remote Explorer: Focus on Forwarded Ports View**
    command):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – A screenshot showing the forwarded ports view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – A screenshot showing the forwarded ports view
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see the list of forwarded ports currently configured.
    Hovering over a port will bring up the globe and cross icons you can see in the
    screenshot. Clicking the globe will open that port in the default Windows browser
    and clicking the cross will stop sharing that port.
  prefs: []
  type: TYPE_NORMAL
- en: '`forwardPorts` configuration boosts productivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll revisit the topic of volume mounting and look at some more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting volumes and Bash history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen several examples of configuring mounts in this chapter and they
    fall into two different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a folder or file from the host into the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a volume into the container to persist data between container instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first of these categories, mounting a host volume into the container, is
    what we used to mount the host Docker socket (`/var/run/docker.sock`) into the
    dev container. This can also be used to mount folders such as `~/.azure` from
    the host to bring your Azure CLI authentication data into the dev container to
    avoid having to sign in again inside the dev container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second category of mount creates a Docker volume that is mounted each time
    the dev container runs. This provides a folder inside the dev container whose
    contents are preserved across container rebuilds. This can be useful, for example,
    with package cache folders if you have large files that you want to avoid repeatedly
    downloading. Another really useful example of this is to preserve your Bash history
    in the dev container. To do this, we can configure the `bash history` location
    in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This snippet adds configuration to the `.bashrc` file (which is run when Bash
    starts) to configure the location of the `.bash_history` file to be in the `/commandhistory`
    folder. By itself, this doesn't achieve much, but if you combine it with making
    the `/commandhistory` folder a mounted volume, the result is to preserve your
    Bash history across instances of your dev container. In fact, this configuration
    has an added bonus. Without dev containers, all projects share the same Bash history
    on the host, so if you don't work with a project for a few days, it can mean that
    the commands related to that project have been pushed out of your history. With
    this configuration for dev containers, the Bash history is specific to the container,
    so loading up the dev container brings back your Bash history regardless of what
    commands you have run on the host in the meantime (make sure you put a project-specific
    name for the volume).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a configuration illustrating the examples discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet shows various mounts that we discussed in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the host `/var/run/docker.sock` to expose the host Docker socket in
    the dev container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting the `.azure` folder from the host to bring cached Azure CLI authentication
    into the dev container. Note the environment variable substitution used to locate
    the user folder in the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a volume to persist the Bash history across dev container instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume mounting** is a useful tool when working with dev containers and can
    boost productivity considerably by allowing us to bring across host folders to
    reuse Azure CLI authentication. It can also provide a durable file store across
    dev container instances – for example, to preserve Bash history or to enable a
    package cache.'
  prefs: []
  type: TYPE_NORMAL
- en: The final tip we will look at is ensuring the repeatability of building the
    dev container image.
  prefs: []
  type: TYPE_NORMAL
- en: Using pinned versions for tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When configuring a dev container, it is easy (and tempting) to use commands
    that install the latest version of tools. The starting dev container definitions
    that are used when running the **Remote-Containers: Add Development Container
    Configuration Files…** command often use commands that install the latest versions
    of tools, and lots of installation documentation for tools guide you to commands
    that do the same.'
  prefs: []
  type: TYPE_NORMAL
- en: If the commands in your dev container Dockerfile install the latest version
    of tools, then different people on your team might have different versions of
    tools in their dev container depending on when they built the dev container and
    what the latest versions of the tools were at that time. Additionally, you might
    add a new tool and rebuild your dev container and pick up newer versions of other
    tools. Generally, tools keep a reasonable level of compatibility between versions,
    but occasionally, their behavior changes between versions. This can lead to strange
    scenarios where the dev container tools seem to work for one developer but not
    for another, or the tools worked fine until you rebuilt the dev container (for
    example, to add a new tool), but then inadvertently picked up new versions of
    other tools. This can be disruptive to your workflow, and I generally prefer to
    pin the tools to specific versions (such as for `kind` and `kubectl` in this chapter),
    and then explicitly update their versions at a convenient time or when the need
    arises.
  prefs: []
  type: TYPE_NORMAL
- en: Always Installed Extensions and dotfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting up a dev container, you can specify extensions to install when
    the dev container is created. To do this, you can add the following to `devcontainer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the `extensions` property in the JSON, which specifies an
    array of extension IDs. To find the ID of an extension, search for the extension
    in the **EXTENSIONS** view in Visual Studio Code and open it. You will see the
    following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – A screenshot showing extension information in Visual Studio
    Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – A screenshot showing extension information in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see the information for an extension with the extension
    ID (`ms-vsliveshare.vsliveshare`) highlighted. By adding extensions here, you
    can ensure that anyone who uses the dev container will have the relevant extensions
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remote-Containers extension also has a feature called **Always Installed
    Extensions** (or **Default Extensions**). This feature allows you to configure
    a list of extensions that you always want to be installed in a dev container.
    To enable this, open the settings JSON by choosing **Preferences: Open user settings
    (JSON)** from the command palette and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet of the settings file, you can see the `remote.containers.defaultExtensions`
    property. This is an array of extension IDs just like the `extensions` property
    in `devcontainer.json`, but the extensions listed here will always be installed
    in the dev containers you build on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: A related feature that the Remote-Containers extension supports is `.bash_rc`
    and `.gitconfig`). To find out more about dotfiles, [https://dotfiles.github.io/](https://dotfiles.github.io/)
    is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dotfile support in Remote-Containers allows you to specify the URL for
    a Git repository containing your dotfiles, the location they should be cloned
    to in the dev container, and the command to run after cloning the repository.
    These can be configured in the settings JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the three JSON properties corresponding to the settings we
    just described. Note that the `remote.containers.dotfiles.repository` value can
    be a full URL, such as [https://github.com/stuartleeks/dotfiles.git](https://github.com/stuartleeks/dotfiles.git)
    or simply `stuartleeks/dotfiles`.
  prefs: []
  type: TYPE_NORMAL
- en: One thing I like to use this dotfiles feature to set up is Bash aliases. A lot
    of my early time with computers was spent with MS-DOS, and I still find that I
    type commands such as `cls` and `md` more readily than their equivalents, `clear`
    and `mkdir`. Using dotfiles for this configuration helps boost my productivity
    across dev containers, but this configuration isn't something that other users
    of the dev containers are likely to need or want.
  prefs: []
  type: TYPE_NORMAL
- en: 'With dotfiles and the **Always Installed Extensions** features, there is now
    a decision to make: should configuration and extensions be set in the dev container
    definition, or using dotfiles and **Always Installed Extensions**? To answer this,
    we can ask ourselves whether the extension or setting is something that is central
    to the functioning of the dev container or personal preference. If the answer
    is personal preference, then I put it in dotfiles or **Always Installed Extensions**.
    For functionality that is directly related to the purpose of the dev container,
    I include it in the dev container definition.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if I'm working with a dev container for Python development, then
    I would include the Python extension in the dev container definition. Similarly,
    for a project using Kubernetes, I would include `kubectl` in the Dockerfile for
    the dev container and configure Bash completion for it. I would also include the
    RedHat YAML extension to get completion assistance for Kubernetes YAML files (see
    [https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml)).
  prefs: []
  type: TYPE_NORMAL
- en: Both dotfiles and **Always Installed Extensions** can be a great way to ensure
    that your environments and your dev container experience are familiar and productive.
  prefs: []
  type: TYPE_NORMAL
- en: This section has looked at tips to help increase your productivity with dev
    containers, such as removing repeated tasks by automatically running commands
    after the dev container has been rebuilt and automatically forwarding ports when
    the dev container starts up.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about options for configuring dev containers, see [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've seen how the Visual Studio Code Remote-Containers extension
    allows us to use the standard Dockerfile to define a container to do our development
    work while keeping the rich, interactive environment of Visual Studio Code. These
    dev containers allow us to build isolated development environments to package
    tools and dependencies specific to a project, removing the need to coordinate
    the update of tools across projects at the same time that is often seen in teams.
    Additionally, by including the dev container definition in source control, it
    is easy for team members to easily create (and update) a development environment.
    When working with web applications, you saw how to forward ports to the application
    running in the container to allow you to browse a web app in your Windows browser
    while interactively debugging it in the container.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw how we can build and work with a containerized application inside
    the dev container by sharing the host Docker daemon. The chapter considered different
    options for working with Kubernetes from a dev container, and you saw how to configure
    `kind` in a dev container to provide a Kubernetes environment with minimal requirements
    on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the chapter finished with a handful of tips for working with dev containers.
    You saw how to automate steps after dev container creation and how to automatically
    forward ports when the dev container starts up. You also saw how to mount folders
    or files from the host, and how to create volumes that persist files across dev
    container instances (for example, to persist Bash history or other generated data).
    All of these approaches provide ways to streamline your development flow with
    dev containers to help you stay focused on the code you want to write.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Remote-Containers can require a little extra thought about setting
    up the development environment for a project, but it offers some compelling advantages
    for isolation and repeatable development environments, both for an individual
    and across a team.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to WSL and look at a variety of tips for
    working with command-line tools in WSL.
  prefs: []
  type: TYPE_NORMAL
