- en: Flexbox, Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flexbox is a module for laying out portions of a page, and it currently has
    great browser support, starting with Internet Explorer 10\. Technically, it's
    not designed for full-page layout; it's more for layout of portions of your page,
    or a given component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following three columns (The Octopus, The Crab, and The Whale)
    were laid out using floats, but we''re going to use flexbox to do the exact same
    thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Flexbox is a big topic, so we''re going to be covering it across two chapters.
    This chapter will cover the basics, we''ll tackle implementing flexbox, switching
    from floats to flexbox, and go through all the flexbox properties and shorthands.
    In the next chapter we''ll build a new section—the following product listing—to
    demonstrate how we can build different things with flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I'm going to code in the latest version of Chrome, which as of now supports
    the non-prefixed versions of all flexbox properties. This is going to un-complicate
    the learning experience. But, before we're done we'll need to add vendor prefixes
    for maximum browser compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the flexible box layout module of CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching from floats to flexbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexbox properties and shorthands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the flexible box layout module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is flexbox? Commonly referred to as flexbox, it's real name is *flexible
    box layout module*. It provides a more efficient way to lay out, align, and distribute
    space among child elements of a parent element, even when their size and quantity
    is unknown or dynamic. Flexbox defines a whole new layout mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, there is *block mode*, which was designed for document layout.
    There is *inline mode*, which was designed for text; *table mode*, which was designed
    for tabular data (tables); and *positioned mode*, which was designed for explicit
    positioning without much regard for other elements around it. Now there is *flexbox
    mode*. So what does flexbox do? It can do a lot of really useful things. At the
    core, flexbox is for layout and alignment. The following list illustrates its
    more common use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Layout of elements vertically or horizontally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alignment of elements to the left or right, like you can with floats but without
    all the extra baggage that comes along with floats. You can also center elements,
    horizontally or vertically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, you have control over the display direction. For instance, you can have
    the elements displayed in the source order by default or in reverse direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, you can take explicit control of elements and change their display
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thing it does easily is it gives you equal height columns, which could
    only be achieved previously using hacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its real delight is how it can distribute elements in a parent in regards to
    the available space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geared towards responsive design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flex terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So this is all exciting stuff and I'm sure you want to start seeing it in action,
    but before we jump in, we need to do some homework and learn the flex terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Flex container and flex items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, there is something called a *flex container*, which is essentially
    an element that contains all the *flex items*. In other words, it's the parent
    of a collection of elements; flex items are child elements of their parent, or
    flex container.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Main size and cross size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s something called the *main size* and *cross size*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, the main size is the width and cross size is the height, but this
    can change if you modify the `flex-direction`, something we'll learn about in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Main axis and cross axis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Furthermore, there is something called the *main axis*, which runs horizontally
    by default, and *cross axis*, which runs vertically by default, as shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Justify-content and align-items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a property you''ll learn about later in this chapter called `justify-content`,
    which controls alignment along the main axis; the `align-items` property controls
    alignment along the cross axis. Here''s an important concept. The main axis and
    cross axis can be toggled based on the `flex-direction` being set to either a
    `column` or `row`. So the main axis is always the horizontal axis by default,
    unless you use `flex-direction: column` and the vertical axis becomes the main
    axis!'
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first taste of flexbox your probably saying, "Hey, slow down!"
    Not to worry, this is just an introduction to the terminology and a few of the
    properties and concepts; don't expect to have all this sink in right away. We'll
    refer more to the preceding diagrams as we start using different properties throughout
    the next sections, and we'll cover every single property in depth in the upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: From floats to flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll get to work and change our columns module from a float-based
    layout to a flexbox-based layout (I'm excited!).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll remove all the float-related properties from the columns and
    break them down to square one; then, we''ll use `display: flex` to transform the
    float layout into our flexbox-based layout to see immediate results. Finally,
    we''ll explore how `flex-direction` will be useful in a responsive design; we''ll
    discuss this when we get down to smaller screen sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing float-related properties from the columns section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, here''s our three-column layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s recall how it moves to a one-column tube at smaller widths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alright, let's go to the CSS file. Now we'll remove all the float-based properties
    from our columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s basically remove everything to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, there let''s rip out the float-based code in the responsive media query.
    So starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And inside one more media query for very small widths, let''s remove the last
    reference to the column. So, starting with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove the `.column {}` rule set, so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, if we refresh the browser and widen it, we will be back to a stacked
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We've successfully remove our float-based layout from this section as our three
    columns are gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning on flexbox using display: flex'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''ll rebuild the columns using flexbox. We''ll take a look at our index.html
    file. Here''s are markup for this area we are calling columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these `<div class="column"></div>` will be our flex items; `<div class="wrapper">`
    will be our flex container. For ease of understanding, I''m going to simplify
    our markup down to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new class to the flex container called "columns" that we''ll use
    to target the flex container with our flexbox code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new rule set targeting our would-be flex container. To convert
    something into a flex container, simply add `display: flex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The children of a flex container will automatically become flex items.
  prefs: []
  type: TYPE_NORMAL
- en: Note the grandchildren and great-grandchildren elements will not be considered
    flex items, only the immediate children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00386.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve basically achieved our float layout with one simple property: `display:
    flex`. The spacing is a little tight, but we have a horizontal layout nonetheless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flex overrides floats. Let''s say we have many floats, namely `float: left`,
    `float: right`, and `float: none`; whatever it might be, flex items ignore floats,
    that is, they have zero impact. So once a container element gets `display: flex`,
    making the children elements flex items, floats are now ignored on those flex
    items. I can float to my heart''s delight, but it will have zero impact on flex
    items. .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, another thing to keep in mind is that each column are now of equal height.
    But let''s just do one thing. Let''s add a border around the flex items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Equal-height columns right? Well, each column has the exact same amount of
    content. So even if we were using floats for layout, we''d have equal-height columns.
    The unequal height comes when the amount of content varies in each column. I''ll
    remove some of the paragraph text in the crab column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00388.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After doing this, you can see that even though it has a lot less content, it
    still has the same height. Albeit, a few other things happened here, namely the
    crab column is a different width than the other 2 columns. We'll talk about this
    later in the chapter, but we do get equal height by default, which is a quick
    win that is difficult to accomplish using a float-based layout.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the flex-direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how easy it is to change the layout direction by adding the `flex-direction`
    property with a value of `column`. This property applies to the `.columns` flex
    container. I've also removed the pink `border` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save this and boom! We went from horizontal to vertical:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Some of our center alignment, which we probably wanted, has gone; however, the
    layout is vertical nonetheless. So that's interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we can is set the `flex-direction` to be `column-reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, our octopus appeared first; now if we refresh the browser, our whale
    comes first and the octopus comes last:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at our DevTools, though, we will see that the octopus is still first
    in the source order but the last one to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So the source order hasn't changed, only the display order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good time to talk about our flexbox diagram. When `flex-direction`
    is set to `row`, this diagram applies—flex items are laid out horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, when `flex-direction` is changed to a `column`, the diagram changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The cross axis now runs from left to right and the main axis runs from top to
    bottom, and the flex items are now stacked on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of `flex-direction` is `row`; `flex-direction: row`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set `flex-direction` to `row-reverse`, which does what you think
    it does: it lines the flex items horizontally but in reverse order. Let''s take
    a look at the following image; we have the whale, crab, and octopus in reverse
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s remove the `flex-direction` property from the `.column` flex container,
    and it will default to row, which is what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Browser shrinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s think about smaller devices by shrinking our browser. It gets a
    little tight down near tablet dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our media query, where we had originally removed all of the `float` stuff.
    Let''s change the `flex-direction` to `column`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re back to a one-column-stacked layout for narrower browser widths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are still some issues with spacing and alignment, which
    we'll address with flexbox in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we removed all our float-based layout CSS from our column section,
    and we added a flexbox layout using `display: flex`. We also changed `flex-direction`,
    which as we saw determines the direction of the main axis and cross axis.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding flex-grow, flex-basis, flex-shrink, and flex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a crack at understanding flexbox's sizing properties. In this section,
    we'll look at sizing flex items with `flex-grow`, `flex-shrink`, `flex-basis`,
    and the shorthand for them all; `flex`. All of these properties apply to flex
    items, not to flex containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using flex-grow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll look at a new page—`flexbox.html`. As you might have guessed,
    there''s a `<section>` that will be the flex container, and 5 `<div>`''s which
    will be the flex items. :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the CSS we''ll start with before adding flexbox properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it looks like in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s switch on flexbox by adding `display: flex` to the flex container in
    our CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, if we refresh our browser, this creates a horizontal row for us, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first flexbox sizing property we''ll look at is `flex-grow`, which is a
    factor. It determines how to distribute "leftover space" along the main axis of
    the flex container. Let''s be clear on what I mean when I say, "leftover space".
    That is the unfilled space inside of the flex container that the flex items don''t
    occupy. In our case, that is this empty space on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, `flex-grow` determines how to distribute that leftover space to the
    flex items. Let''s apply it to our flex items using a value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`flex-grow: 1` will force the leftover space to be evenly distributed to all
    the flex items. Each flex item gets an equal amount of the space that was previously
    unoccupied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00400.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As I shrink the browser, we can see that we achieved a perfectly fluid grid
    without using the `width` property and calculating the exact percentage of how
    100 divides equally into 5!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a new ruleset for just the second flex item (each flex item has
    a unique class, the second one being `flex-item2`). And we''ll add a `flex-grow`
    property with a value of `2`, and this will distribute twice as much of the leftover
    space to that second flex-item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the browser, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00402.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that `flex-item2` isn''t necessarily twice the width of the others;
    it''s just getting twice the leftover space as the others. That''s a notable distinction.
    And, if we shrink the browser window, we can see how it gets narrower as the browser
    window shrinks until we get down to a certain width, then they''re all roughly
    the same. When there is extra space, it tries to distribute more to `flex-item2`
    since it has a higher `flex-grow` factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00403.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We could also set `flex-grow` of `flex-item2` to `0`, which is the default
    value for `flex-grow`. This basically says don''t distribute any of the leftover
    space to this flex item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second flex item doesn''t grow to take up any of the extra space; the remaining
    four items take the extra space available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00404.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using flex-basis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check out another property for flex items: `flex-basis`. Note that `flex-basis`
    is the initial main size of the flex item, before leftover space is distributed
    according to the flex factors, which are `flex-grow` and `flex-shrink`; we''ll
    talk about the latter shortly. For now, let''s think of `flex-basis` as just a
    width. So, for `flex-item2`, let''s give it `flex-basis` of `400px` and remove
    its `flex-grow` factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refresh the browser, it will size the second flex item to `400px`. But
    if we really look at this, it''s sizing it to a little more than 400 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00405.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, I''m still applying `flex-grow` as `1` to all flex items including
    this one. Let''s change this to make it so our second flex item has the default
    value `flex-grow: 0;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you refresh your browser, you can see it''s exactly 400 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00406.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''ll be exactly 400 pixels until we start shrinking the browser; at some
    point, it''s going to start giving way. Once space starts to get very limited,
    it decides to make it less than 400 pixels; this is where the *initial main size*
    part of the `flex-basis` definition comes into play. We''re telling flexbox we
    want a width of 400 pixels for the second flex item, and flexbox will obey that
    until the flex container runs out of space to accommodate that. Then, it starts
    to reduce the width of the second flex item to less than the `flex-basis: 400px`
    to entertain the best layout that it can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove `flex-grow` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `flex-basis` is not just a width: it''s the width when `flex-direction`
    is set to `row`, which is the default, and it''s the height when `flex-direction`
    is set to `column`. And technically speaking, since it''s not width or height,
    it''s the main size.'
  prefs: []
  type: TYPE_NORMAL
- en: Are you starting to understand why we spent all that time going over flex terminology?
    If any of this is not making sense to you, I recommend going back to the start
    of this chapter to review flex terminology.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s change `flex-direction` to `column`. We''ll do this on the flex container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A `flex-basis` of `400px` is now the height of the second flex item, now that
    the main axis is running vertically. You can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00407.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So `flex-basis` overrides any heights that are set. Let''s take an example
    and enter a `height` of `800px` for the second flex item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the height is still 400 pixels. Really, I should say the main size
    is 400 pixels, and it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00408.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, `flex-basis` also accepts two keywords: `auto` and `content`. The `auto`
    keyword means, "go look at the `width` or `height` property". Since `flex-direction`
    is currently `column`, when we change `flex-basis` to `auto`, the `height` of
    `800px` should no longer be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the height is now 800 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00409.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, again, `auto` is the default value of `flex-basis`. There's also another
    keyword available called `content`; this means the size of the flex item is based
    on the size of the flex item's content. This is currently not supported by the
    most recent version of Chrome, so I won't demo it; however, it sounds like it
    could be useful in future once browsers start implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, I''ll remove the `height` and `flex-basis`. I''ll also remove the
    `flex-direction` ending up with our CSS in this state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00410.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using flex-shrink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `flex-shrink` can be thought of as the opposite of `flex-grow`. While `flex-grow`
    determines how much of the extra space a flex item should consume, proportionate
    to others when there is leftover space, `flex-shrink` determines how much the
    flex item itself should shrink proportionately to others when there isn't any
    leftover space. So, let's see this in action and step this out.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add `flex-basis` of `200px` to each flex item and temporarily
    remove `flex-grow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So if `flex-basis` is set to 200 pixels, each flex item will be 200 pixels
    wide and any extra space is not allowed in any of the flex items because `flex-grow`
    was removed. Here''s how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00411.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add `flex-grow` of `1` back to our `flex-item` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the extra space is distributed to each flex item. The `flex-basis` property
    was just a starting point for the initial main size (notice I didn''t said "initial
    main size" and not "width"). But each flex item got wider to eat up the extra
    space that was allocated evenly to each item. This is how your page should look
    at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00412.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s throw a `flex-shrink` property on the second flex item. We''ll use a
    factor of `2`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we decrease the browser size, all the items shrink. Except for the second
    flex item, which shrinks twice as much as other flex items, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00413.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If not specified for a flex item, `flex-shrink` defaults to `1`. So let''s
    add `flex-shrink: 1` to all the flex items except for the second flex item, which
    has `flex-shrink` set to `2`, just to demonstrate that nothing will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that when we make the browser smaller, there really is no change;
    the second flex item is still shrinking more than the others, as shown in the
    following samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00414.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another neat thing you can do is set `flex-shrink` to `0` to ensure that an
    item does not shrink. Let''s do this for the second flex item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh the browser now. All the other flex items shrink when space is limited,
    except for item 2; it maintains its `flex-basis: 200px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00415.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the flex shorthand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s also a shorthand property, called `flex`, that we can substitute for
    using `flex-grow`, `flex-shrink`, and `flex-basis`. Let''s swap out `flex-basis`,
    `flex-grow`, and `flex-shrink` for just `flex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the order of the values in `flex` is as follows: `flex-grow`, `flex-shrink`,
    and `flex-basis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the browser, it will do exactly the same thing it was doing when
    we used the non-shorthand properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the second flex item, all it has is `flex-shrink`, so we can use a shorthand
    of `flex: 1 0`. The `flex-basis` will be intelligently set to its default of `auto`
    and can be omitted. We need to make the value `1 0` though because the default
    value for `flex-grow` is `1`, so even though we didn''t have a `flex-grow` set
    explicitly we need to add it''s value to our shorthand. We''ll also delete the
    existing `flex-shrink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we see no change in the browser, which is what we wanted from our little
    refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So `flex: 1 0` means `flex-grow = 1` and `flex-shrink = 0`. As mentioned, `flex-basis`
    defaults to `auto`, so we don''t need to add that here. There''s also a keyword
    of `none`, which basically says don''t grow, don''t shrink, and look at my width
    or height for the main size, in other words, don''t flex. The shorthand is nice
    and compact, but when getting started with flexbox I recommend using each property
    on its own, until you gain a full understanding of what each one is doing.'
  prefs: []
  type: TYPE_NORMAL
- en: More layout, more positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is on more layout and more positioning with flexbox. Here, we'll
    check out a new property, `justify-content`, as well as how to nest flexboxes
    within each other, and finally using automatic margins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s reset some of our `flex` properties by getting
    rid of our flex shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By removing the flex shorthand, each flex item stops worrying about growing,
    shrinking, or what their initial main size should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the justify-content property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First up is `justify-content`, which is a flex container property that determines
    whether the content is justified - or positioned - at the start of the main axis,
    the end of the main axis, or somewhere in between. Let''s add `justify-content`
    and set it to `flex-start`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`flex-start` is the default value for `justify-content`, so nothing changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`flex-start` positions the flex items at the start of the main axis. Remember,
    when `flex-direction` is not specified, or specified as `row`, the main axis runs
    from left to right horizontally. So `flex-start` would be the left edge and `flex-end`
    would be the right edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s change the value to `flex-end`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The content is now positioned to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00421.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a lot like using `float:right`, except without all the extra baggage
    and issues that come along with floats: no clearing, no collapsing, and no reshuffling
    of the floated items. Essentially, we just position the flex items to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s pretty useful and all, but the real magic happens when we use `justify-content:
    center`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Oh my gosh, we've just centered the flex items!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There was never a `float: center`. Admittedly, we could center things by setting
    the left and right margins to `auto` on the container. But the problem with that
    was we always had to specify the `width` of the container when we do this; therefore,
    if the number of items in the container changed, we would have to change the `width`
    property as well. There are other tricks to centering things, but none this easy
    and flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flexbox is inherently more prepared for dynamic content and doesn''t need any
    `width` defined; let''s add another flex item to the HTML to prove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have six items and all of them are still centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But wait, there''s more! There''s a keyword called `space-between` that we
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This keyword, `space-between`, redistributes the extra space evenly between
    each item. So there''s "space between" each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00424.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the first and last elements are hugging the edge; the first flex
    item hugs the left-most edge of its container; and the last flex item hugs the
    right-most edge of its container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another value, though, `space-around` that does something slightly
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that `space-around` redistributes the extra space of the container around
    all the flex items, even the first and the last, whereas `space-between` inserts
    extra space only between each item.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s revisit the Home page and implement this in a more practical example,
    that is, our three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our three columns are set to `display: flex` but no other flex properties are
    applied. The flex items are kind of centered already because the flex container
    is centered. However, we want some space between each flex item. So in our area
    of the CSS for our columns, let''s say `justify-content: space-between`. Unrelated
    to what we''re currently doing. I am also setting `max-width: 50%` on our sea
    creatures so they are not so big. But more important is the `justify-content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Nothing changes!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is because of the text in each column. The content is pushing each flex
    item to fill out the space available. So we need to add a `width` to these items
    or `flex-basis` to explicitly define how wide we prefer each column to be. This
    is because since there's no extra space, there's no way for flexbox to redistribute
    the flex items to put extra space between each flex item. We need some extra space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this by adding `flex-basis: 30%` to each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh the page and this is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00428.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the space is evenly distributed between each item. Lovely! We still
    have a little cleaning to do, though. The button at the bottom is not consistently
    at the bottom of each column; this is not so noticeable now because the content
    within each column is relatively the same; however, it will become more apparent
    if we make the amount of content in each column a lot different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00429.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How do we fix this? Well, remember, in our case, the flex container is the columns,
    and each column is a flex item. The button is not a flex item because it is within
    the column. This is where nested flexboxes come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Flexboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s convert the column into a nested flex container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the flex items of a container are set as `flex-direction:row` by
    default, so they all sit next to each other horizontally, which totally destroyed
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s not what we want it to look like, obviously, but we can easily remedy
    this. Let''s change `flex-direction` to `column`, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, we''re back in business. Looks identical to what it did before we made
    the columns a flex container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'How does this help us? Well, we could start using `justify-content` and maybe
    we could say `justify-content`, `space-between`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the button sit nicely at the bottom but now in the middle of the
    content. The space between each flex item is spaced out evenly, which ends up
    being different for each column, and thus not looking great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s revert back to the default value for `justify-content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This moves everything back to the top because `flex-direction` is `column`,
    and the main axis now runs up and down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00433.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using automatic margins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something notable about flexbox is that it does a fresh take of the `auto`
    keyword for `margin`. Automatic margins are now working very closely with flexbox.
    I can now target my button as the selector and give it `margin-top` of `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Boom! The space above the button is now automatically calculated, and the button
    is positioned at the bottom of each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This also works when flex-direction is row; you can use `margin-left: auto;`
    or `margin-right: auto` to hug flex items to the outer edges of their flex container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate an example of this, let''s go back to our flexbox demo sample,
    and we can change `justify-content` of the flex container to `flex-start` and
    then add another rule set that pushes the final flex item to hug the right edge
    using `margin-left: auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the flex-items are lined up on the left -at their `flex-start` - except
    for the last flex item, which is hugging the right -or at the `flex-end` - because
    we''re calculating it''s left margin automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00435.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go back to the Home page and look at our columns. One last thing about
    these columns: the red headline is not aligned at the same vertical position for
    each one because each of our sea creature SVG''s are of a slightly different height:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s give each sea creature a `flex-basis` of `150px`. Since, `flex-direction`
    is `column`, `flex-basis` can be thought of as the height; therefore, we''re basically
    giving each figure the same height of `150px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now those red headlines will all sit neatly together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In summary, `justify-content` positions and redistributes extra space along
    the main axis. You can nest flexboxes all day long, and automatic margins are
    pretty sweet and allow you to position content to hug the opposite edge of a flex
    container, which is an enormously common UI pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a ton of ground with flexbox in this chapter including all of
    the basic flexbox properties. We'll carry that on in the next chapter when we
    look at how to align and flow flexbox content, and the properties that are required
    to do that. We'll also create a new UI pattern—a product listing—and see how flexbox
    can help there.
  prefs: []
  type: TYPE_NORMAL
