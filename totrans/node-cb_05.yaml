- en: 'Chapter 5. Transcending AJAX: Using WebSockets'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless fallbacking with `socket.io`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks over `socket.io` transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a real-time widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP was not made for the kind of real-time web applications that many developers
    are creating today. As a result, all sorts of workarounds have been discovered
    to mimic the idea of bi-directional, uninterrupted communication between servers
    and clients.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets don't mimic this behavior, they provide it. A WebSocket works by
    stripping down an HTTP connection so it becomes a persistent TCP-like exchange,
    thus removing all the overhead and restrictions HTTP introduces.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP connection is stripped (or rather upgraded) when both the browser and
    server support WebSockets. The browser discovers this by communicating with the
    server via GET headers. Only newer browsers (IE10+, Google Chrome 14, Safari 5,
    Firefox 6) support WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets is a new protocol. JavaScript combined with the Node framework is
    often versatile and low level enough to implement protocols from scratch, or failing
    that C/C++ modules can be written to handle more obscure or revolutionary logic.
    Thankfully, there's no need to write our own protocol implementation, the open
    source community has already provided.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be using some third-party modules to explore some of
    the potential of the powerful combination of Node and WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this task, we will use the non-core `websocket` module to create a pure
    WebSocket server that will receive and respond to WebSocket requests from the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create a new folder for our project which will hold two files: `server.js`
    and `client.html. server.js`. They provide the server-side websocket functionality
    and serve up the `client.html` file. For the server-side WebSocket functionality,
    we also need to install the `websocket` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the `websocket` module, see [https://www.github.com/Worlize/WebSocket-Node](https://www.github.com/Worlize/WebSocket-Node).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A WebSocket is an HTTP upgrade. As such, WebSocket servers run on top of HTTP
    servers. So we''ll require the `http` and `websocket` servers, plus we''ll also
    load our `client.html` file (which we''ll be creating soon) and the `url` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the HTTP server, and supply it to a new WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We bind our HTTP server to port 8080 because binding to ports lower than 1000
    takes root access. This means our script would have to be executed with root privileges
    which is a bad idea. See[Chapter 10](ch10.html "Chapter 10. Taking It Live"),
    *Taking It Live*, for more information and how to bind to the HTTP port (80) safely.
  prefs: []
  type: TYPE_NORMAL
- en: We've also created a new array, called `accept`. We use this inside the WebSocket
    server to restrict which originating sites can connect. For our example, we only
    allow connections from localhost or 127.0.0.1\. If we were hosting live we would
    include any domains pointing to our server in the `accept` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `webSocketServer` instance, we can listen to its `request`
    event and respond accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our `request` event callback, we conditionally accept the request, then listen
    for the `message` and `close` events, responding with **WebSockets!** if the message
    from the client is `Hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the client, we''ll place the following HTML structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And the content of our `script` tags should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we initialize our server with `node server.js`, then direct our (WebSocket-compliant)
    browser to `http://localhost:8080`, type `Hello` in the textbox, and click on
    **Send**. The terminal console will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And our browser will show that **Hello** was sent and **WebSockets!** was received,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could use our textbox to send any string we like to our server, but only
    **Hello** will gain a response.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `server.js`, when we require the `websocket` module's `server` method, we
    load a constructor function into `WSServer`, (which is why we capitalized the
    first letter). We initialize `WSServer` using `new` and pass in our `plainHttpServer`
    which transforms it into a WebSocket-enabled server.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server will still serve normal HTTP requests, but when it receives
    a WebSocket connection handshake the `webSocketServer` kicks into action to establish
    a persistent connection to the client.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the `client.html` file is loaded in the browser (served by the HTTP
    server in `server.js)` and the inline script is executed, the WebSocket upgrade
    request is made to the server.
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives this WebSocket upgrade request, `webSocketServer` emits
    a `request` event, which we scrutinize with our `accept` array before deciding
    whether we will respond.
  prefs: []
  type: TYPE_NORMAL
- en: Our `accept` array holds a whitelist of hosts we'll allow to interface with
    our WebSocket server. We gain some security by only allowing known sources to
    use our WebSocket server.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `webSocketServer request` event, `request.origin` is parsed with
    `url.parse` to retrieve the host name section of the `origin` URL. If the host
    name isn't found in our `accept` whitelist we call `request.reject`.
  prefs: []
  type: TYPE_NORMAL
- en: If our originating host passes, we create a `websocket` variable from `request.accept`.
    The first parameter of `request.accept` allows us to define a custom sub-protocol.
    We could create an array of websockets using multiple `request.accepts` with different
    sub-protocols which represent different behaviors. When initiating our client,
    we would pass an additional argument containing that sub-protocol (for example,
    `new WebSocket("ws://localhost:8080", 'myCustomProtocol'))`. However, we pass
    in `null`, such functionality isn't required for our purposes. The second parameter
    allows us to inform `request.accept` of the host we wish to allow (there is also
    a third that can be used for passing cookies).
  prefs: []
  type: TYPE_NORMAL
- en: For each message received from the client, `WebSocket` emits a `message` event.
    This is where we log the received data to the `console` and check whether the
    incoming message is `Hello`. If it is, we use the `WebSocket.send` method to respond
    to the client with **WebSockets!**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we listen for the `close` event, to inform `console` that the connection
    has been terminated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets have so much potential for efficient, low latency real-time web apps,
    but compatibility can be a challenge. Let's look at some other uses for WebSockets,
    plus a tip on getting WebSockets to work in Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting older Firefox browsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firefox versions 6 to 11 do support WebSockets. However, they use a vendor prefix
    so our `client.html` will not work on these Firefox versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we simply prepend the following to the script in our `client.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the `WebSocket` API does not exist, we try `MozWebSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a node-based WebSocket client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `websocket` module also allows us to create a WebSocket client. We may wish
    to interface Node with a pre-existing WebSocket server, which is primarily for
    browser clients (if not, we are better off creating a simple TCP server. See [Chapter
    8](ch08.html "Chapter 8. Integrating Network Paradigms"), *Integrating Network
    Paradigms).*
  prefs: []
  type: TYPE_NORMAL
- en: So let's implement the same functionality in `client.html` using Node. We'll
    create a new file in the same directory, calling it `client.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we've simply hardcoded our `msg` variable, though we could have
    used `process.stdin` or `process.argv` to input a custom message. We initialize
    a new client with the `websocket` module's `client` method. Then we immediately
    begin to listen for the `connect` and `connectFailed` events.
  prefs: []
  type: TYPE_NORMAL
- en: After the two `on` methods, we chain the `connect` method. The first parameter
    is our WebSocket server, the second is the protocol (remember, we have a `null`
    protocol for `request.accept` in our recipe), and the third defines the `request.origin`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Origin protection is designed to prevent an attack that only works from browsers.
    So although we can manufacture origins outside of the browser, it doesn't pose
    the same threat. The biggest threat is from a JavaScript injection attack into
    a high traffic site, that could cause a large amount of unauthorized connections
    from an unintended origin resulting in **Denial of Service**. See [Chapter 7](ch07.html
    "Chapter 7. Implementing Security, Encryption, and Authentication"), *Implementing
    Security, Encryption, and Authentication.*
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serving static files* [Chapter 1](ch01.html "Chapter 1. Making a Web Server"),
    Making a Web Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless fallbacking with socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Older browsers don't support WebSockets. So in order to provide a similar experience,
    we need to fall back to various browser/plugin-specific techniques to emulate
    WebSocket functionality to the best of the deprecated browser's ability.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, this is a mine field, requiring hours of browser testing and in some
    cases highly specific knowledge of proprietary protocols (for example, IE's `Active
    X htmlfile` object).
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.io` provides a WebSocket-like API to the server and client to create
    the best-case real-time experience across a wide variety of browsers, including
    old (IE 5.5+) and mobile (iOS Safari, Android) browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, it also provides convenience features, such as disconnection
    discovery allowing for auto reconnects, custom events, namespacing, calling callbacks
    across the wire (see the next recipe *Callbacks over socket.io transport)*, as
    well as others.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will re-implement the previous task for a high compatibility
    WebSocket-type application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create a new folder with new `client.html` and `server.js` files. We''ll
    also install the `socket.io` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the `websocket` module, `socket.io` can attach to an HTTP server (though
    it isn''t a necessity with `socket.io)`. Let''s create the `http` server and load
    `client.html`. In `server.js` we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now for the `socket.io` part (still in `server.js):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the server, so let''s make our `client.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The final product is essentially the same as the previous recipe, except it
    will also work seamlessly in older browsers that aren't WebSocket compatible.
    We type `Hello`, press the **Send** button, and the server says **socket.io!**
    back.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of passing the HTTP server in a options object, we simply pass it to
    a `listen` method.
  prefs: []
  type: TYPE_NORMAL
- en: We use `io.set` to define our origins whitelist and `socket.io` does the grunt
    work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we listen for the `connection` event on `io.sockets`, which provides us
    with a `socket` to the client (much like `request.accept` generates our `WebSocket`
    connection in the previous recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Inside `connection`, we listen for the `message` event on `socket`, checking
    that the incoming `msg` is `Hello`. If it is we respond with `socket.io!`.
  prefs: []
  type: TYPE_NORMAL
- en: When `socket.io` is initialized, it begins to serve the client-side code over
    HTTP. So in our `client.html` file we load the `socket.io.js` client script from
    `/socket.io/socket.io.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The client-side `socket.io.js` provides a global `io` object. By calling its
    `connect` method with our server's address, we acquire the relevant `socket`.
  prefs: []
  type: TYPE_NORMAL
- en: We send our `Hello msg` to the server, and say we have done so via the `#output
    div` element.
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives `Hello` it replies `socket.io!`, which triggers our
    `message` event callback on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the `msg` parameter (different to our `msg Hello` variable) containing
    the message from the server, so we output it to our `#output div` element.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`socket.io` builds upon the standard WebSocket API. Let''s explore some of
    the additional functionality of `socket.io`.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`socket.io` allows us to define our own events, other than `message, connect`,
    and `disconnect`. We listen to custom events after the same fashion (using `on)`,
    but initiate them using the `emit` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's `emit` a custom event from the server to the client, then respond to the
    client by emitting another custom event back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the same code as in our recipe, the only parts we'll change are the
    contents of the `connection` event listener callback in `server.js` (which we'll
    copy as `custom_events_server.js)` and the `connect` event handler in `client.html`
    (which we'll copy as `custom_events_client.html)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for our server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our server emits a `hello` event saying `socket.io!` to the newly connected
    client and listens out for a `helloback` event from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we modify the JavaScript in `custom_events_client.html` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a `hello` event, we log to our `#output div` (which will say
    `Hello socket.io!)` and `emit` a `helloback` event to the server, passing the
    client as the intended `from` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `socket.io`, we can describe namespaces, or routes, and then access them
    as a URL through `io.connect` on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A **namespace** allows us to create different scopes while sharing the same
    context. In `socket.io`, namespaces are used as a way to share a single WebSocket
    (or other transport) connection for multiple purposes. See [http://en.wikipedia.org/wiki/Namespace](http://en.wikipedia.org/wiki/Namespace)
    and [http://en.wikipedia.org/wiki/Namespace_(computer_science)](http://en.wikipedia.org/wiki/Namespace_(computer_science)).
  prefs: []
  type: TYPE_NORMAL
- en: Using a series of `io.connect`, calls we are able to define multiple WebSocket
    routes. However, this won't create multiple connections to our server. `socket.io`
    multiplexes (or combines) them as one connection and manages the namespacing logic
    internally on the server, which is far less expensive.
  prefs: []
  type: TYPE_NORMAL
- en: We'll demonstrate namespacing by upgrading the code from the recipe *Transferring
    data between browser and server via AJAX* discussed In [Chapter 3](ch03.html "Chapter 3. Working
    with Data Serialization"), *Working with Data Serialization*, to a `socket.io-based`
    app.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a folder, call it `namespacing`, and copy the original `index.html,
    server.js, buildXml.js`, and `profiles.js` files into it. `Profiles.js` and `buildXml.js`
    are support files, so we can leave those alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can strip down our `server.js` file, taking out everything to do with `routes`
    and `mimes` and reducing the `http.createServer` callback to it''s last `response.end`
    line. We no longer need the path module, so we''ll remove that, and finally wrap
    our server in the `socket.io listen` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare our namespaces with their connection handlers we use `of` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `index.html` file we include `socket.io.js`, and connect to the namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once connected, the server emits a `profiles` event with an array of `profile_names`,
    our client picks it up and processes it. Our client emits custom `profile` events
    to the relevant namespace, and each namespace socket listens for a `profile` event
    from the server, handling it according to its format (which is determined by namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces allow us to separate our concerns, without having to use multiple
    `socket.io` clients (thanks to multiplexing). In similar fashion to the sub-protocol
    concept in WebSockets, we can restrict certain behaviors to certain namespaces
    giving us more readable code, and easing the mental complexity involved in a multifaceted
    real-time web app.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a WebSocket server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Callbacks over socket.io transport* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a real-time widget* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks over socket.io transport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `socket.io` we can execute a callback function over WebSockets (or a relevant
    fallback). The function is defined client side, yet called server side (and vice
    versa). This can be a very powerful way to share processing resources and functionality
    between clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a way for the server to call a client-side function
    that squares a number, and for the client to call a server-side function that
    sends Base64 encoding ([http://en.wikipedia.org/wiki/Base64](http://en.wikipedia.org/wiki/Base64))
    of a sentence back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We simply need to create a new folder with new `client.html` and `server.js`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On our server, as before, we load our `http` module and the `client.html` file,
    create our HTTP server, attach `socket.io`, and set the `origins` policy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, in our `connection` event handler, we listen for the custom event `give
    me a number` from the client, and `emit` a custom event `give me a sentence` from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `client.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immediately upon connection, both the server and client `emit` a custom `socket.io`
    event to each other.
  prefs: []
  type: TYPE_NORMAL
- en: For custom `socket.io` events, see the *There's more..*. section of the previous
    recipe *Seamless fallbacking with socket.io*.
  prefs: []
  type: TYPE_NORMAL
- en: For both the client and server, when we pass a function as the second parameter
    of `emit, socket.io` creates a special parameter (`cb`) in the corresponding event
    listener's callback. `cb` is not, in this case, the actual function (if it was,
    it would simply run in the context from which it was called), but an internal
    `socket.io` function which passes the arguments back to the `emit` method on the
    other side of the wire. `emit` then passes these arguments into its callback,
    thus executing the function in local context.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the functions run in their own context. If the server-side `give
    me a sentence` callback was executed on the client, it would fail because there
    is no `Buffer` object in browsers. If the `give me a number` ran on the server,
    it would fail since there is no DOM (Document Object Model) in Node (that is,
    there is no HTML, hence no `document` object and no `document.getElementById`
    method).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`socket.io` can be a great basis for even higher-level specializing frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Shared functions with Nowjs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nowjs extrapolates the `socket.io` callback feature into an even simpler API,
    allowing us to share functions via a global `now` object on the client and the
    `everyone.now` object on the server. Let''s get the `now` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up Nowjs is eerily familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `clientHtml` file loads `now_client.html` instead, in place of `io` we have
    `everyone`, and rather than calling `listen` we call `initialize`. Everything
    else so far is the same (except, of course, requiring `now` instead of `socket.io)`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll re-implement our recipe using `now`, to finish off the server we put.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save our server as `now_server.js`, and in `now_client.html` we write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: NowJS makes function sharing trivial. On the server, we simply set up our `base64`
    method on `everyone.now`, which makes `base64` available to all clients.
  prefs: []
  type: TYPE_NORMAL
- en: Then we listen for the `connect` event, when it occurs we call `this.now.square`.
    In this context `this` is the socket to our client, so `this.now.square` calls
    the `now.square` method contained in `now_client.html`.
  prefs: []
  type: TYPE_NORMAL
- en: In our client, instead of loading `socket.io.js`, we include `now.js` whose
    route is exposed at server initialization. This provides us with the global `now`
    object, on which we set our `square` function method.
  prefs: []
  type: TYPE_NORMAL
- en: Once a connection is established (detected using `now.ready)`, we call `now.base64`
    using a callback to pull the data from the server to the client.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a real time widget* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Browser-server transmission via AJAX discussed in* [Chapter 3](ch03.html "Chapter 3. Working
    with Data Serialization"), *Working with Data Serialization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a real-time widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration options and well thought out methods of socket.io make for
    a highly versatile library. Let's explore the dexterity of `socket.io` by making
    a real-time widget that can be placed on any website and instantly interface with
    a remote `socket.io` server to begin providing a constantly updated total of all
    users currently on site. We'll name it the `Live Online Counter (loc` for short).
  prefs: []
  type: TYPE_NORMAL
- en: Our widget is for easy user consumption and should require very little knowledge
    to get working, so we want a very simple interface. Loading our widget through
    a `script` tag, and then initializing the widget with a prefabricated `init` method
    would be ideal (this allows us to pre-define properties before initialization
    if necessary).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need to create a new folder with some new files: `widget_server.js,
    widget_client.js, server.js`, and `index.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start let's also get the `socket.io-client` module from `npm`. We'll
    be using this to build our custom `socket.io` client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create `index.html` to define the kind of interface we want as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We want to expose a route to `/loc/widget_server.js` which contains our loc
    widget. Behind the scenes, our widget will be held in `widget_client.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s make it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We need to test our widget from multiple domains, so we'll just implement a
    quick HTTP server (`server.js`) to serve `index.html` so we can access it by `http://127.0.0.1:8080`
    and `http://localhost:8080`, this gives us our multiple domains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the server for our widget, in `widget_server.js` we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To test we need two terminals, in one we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the other we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we point our browser to `http://localhost:8080`, open a new tab or window
    and navigate to `http://localhost:8080`. Again we will see the counter rise by
    one. If we close either window, it will drop by one. We can also navigate to `http://127.0.0.1:8080`
    to emulate a separate origin. The counter at this address is independent from
    the counter at `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`widget_server.js` is the powerhouse of this recipe. We start by requiring
    `socket.io` and calling the `listen` method. Instead of passing it as an `httpServer`
    instance as in the prior tasks, we pass it the port number `8081`. It helps if
    we think of `ws://localhost:8081` as a remote server that many client widgets
    connect to.'
  prefs: []
  type: TYPE_NORMAL
- en: The next requirement is `socket.io-client`, which we load into our `sioclient`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Through `sioclient` we can access the `sioclient.builder` method to generate
    a `socket.io.js` file. This concatenated to `widgetScript` to effectively create
    a single JavaScript file containing `socket.io.js` and `widget_client.js`. We
    name the HTTP route to this file `widget.js`. When joining the `socket.io.js`
    file to our `widgetScript`, we place a semicolon in between to ensure the scripts
    don't interfere with each other.
  prefs: []
  type: TYPE_NORMAL
- en: We pass two arguments to the `builder` method, the first is an array of transports.
    These are the various methods for creating the real-time effect (for example WebSockets,
    AJAX (xhr) polling). The earlier a transport appears in the array the more preferred
    it is. The array is generated with the `transports` method. Since we haven't set
    any transports during configuration, the default transports array is supplied.
    The second argument is a callback. Here we can grab the generated `socket.io.js`
    file via the `siojs` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Our widget is purely a JavaScript affair, for plugging in to any HTML page on
    any site. `socket.io` has an internal HTTP server used for supplying JavaScript
    client-side files. Instead of creating an HTTP server to provide our client widget
    code, we use `io.static.add` (once we have our generated `socket.io.js)` to push
    a new route onto the internal HTTP server of `socket.io`. The second argument
    of `io.static.add` is a callback function, which in turn has a function passed
    to it named `callback`.
  prefs: []
  type: TYPE_NORMAL
- en: '`callback` is part of `socket.io`, it adds the content to the newly defined
    route. The first argument can point to a literal file, but we are dynamically
    generating the code, so we pass `null`. To the second parameter we pass `siojs`
    with `widgetScript` into a `Buffer` and our route is created.'
  prefs: []
  type: TYPE_NORMAL
- en: By altering the `resource` property to change the route to the internal HTTP
    server routes of `socket.io, io.set` helps us to brand our widget. As a result,
    our combined `widget.js` route won't appear at `/socket.io/widget.js` anymore,
    instead it will be at `/loc/widget.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to connect to our configured static resource route from the client,
    we have to pass in an `options` object to `io.connect` in `widget_client.js`.
    Notice the absence of a slash prefix. A slash prefix is mandatory server side
    but for the client it is mandatorily omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Now the stage is set for the actual socket action. We wait for a connection
    by listening for the `connection` event on `io.sockets`. Inside the event handler
    we use a few as yet undiscussed `socket.io` qualities.
  prefs: []
  type: TYPE_NORMAL
- en: A WebSocket is formed when a client initiates a handshake request over HTTP
    and the server responds affirmatively. `socket.handshake` contains the properties
    of the handshake.
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.handshake.xdomain` tells us whether the handshake was initiated from
    the same server. We will check for a cross-server handshake before retrieving
    the `hostname` of `socket.handshake.headers.origin`.'
  prefs: []
  type: TYPE_NORMAL
- en: The origin of a same domain handshake is either `null` or `undefined` (depending
    on whether it's a local file handshake or localhost handshake). The latter causes
    `url.parse` to choke and the former isn't ideal. So for same domain handshakes
    we simply set our `origin` variable to `local`.
  prefs: []
  type: TYPE_NORMAL
- en: We extract (and simplify) the `origin` because it allows us to distinguish between
    websites that use widget, enabling site-specific counts.
  prefs: []
  type: TYPE_NORMAL
- en: To keep count, we use our `totals` object and add a property for every new `origin`
    with an initial value of `0`. On each connection, we add `1` to `totals[origin]`
    listening to our `socket` for the `disconnect` event where we minus one from `totals[origin]`.
  prefs: []
  type: TYPE_NORMAL
- en: If these values were exclusively for server use, our solution would be complete.
    However, we need a way to communicate total connections to the client, but only
    for the site they are on.
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.io` has a handy new feature since `socket.io` version 7, which allows
    us to group sockets into rooms by using the `socket.join` method. We cause each
    socket to join a room named after its `origin`, then we use the `io.sockets.to(origin).emit`
    method to instruct `socket.io` to only `emit` to sockets belonging to the originating
    `sites` room.'
  prefs: []
  type: TYPE_NORMAL
- en: In both the `io.sockets connection` event and the `socket disconnect` event,
    we `emit` our specific `totals` to corresponding sockets to update each client
    with the total amount of connections to the site the user is on.
  prefs: []
  type: TYPE_NORMAL
- en: '`widget_client.js` simply creates a `div` called `#_loc` and updates it with
    any new `totals` it receives from `widget_server.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at how our app could be made more scalable as well as another use
    for WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we were to serve thousands of websites, we would need scalable memory storage,
    and Redis would be a perfect fit. It operates in memory but also allows us to
    scale across multiple servers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll need Redis installed, along with the `redis` module. For more information
    see [Chapter 4](ch04.html "Chapter 4. Interfacing with Databases"),Interfacing
    with Databases
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll alter our `totals` variable so it contains a Redis client instead of
    a JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we modify our `connection` event handler like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Instead of adding one to `totals[origin]`, we use the Redis `INCR` command to
    increment a Redis key named after `origin`. Redis automatically creates the key
    if it doesn't exist. When a client disconnects, we do the reverse and readjust
    `totals` using `DECR.`
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets as a development tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing a website, we often change something small in our editor, upload
    our file (if necessary), refresh the browser, and wait to see the results. What
    if the browser would refresh automatically whenever we saved any file relevant
    to our site? We can achieve this with `fs.watch` and WebSockets. `fs.watch` monitors
    a directory, executing a callback whenever a change to any files in the folder
    occurs (but it doesn't monitor sub-folders).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`fs.watch` is operating system dependent. To date, `fs.watch` has also been
    historically buggy (mostly under Mac OS X). Therefore until further advancements,
    `fs.watch` is suited purely to development environments rather than production
    (you can monitor how `fs.watch` is doing by viewing the open and closed issues
    here: [https://github.com/joyent/node/issues/search?q=fs.watch)](https://github.com/joyent/node/issues/search?q=fs.watch)).'
  prefs: []
  type: TYPE_NORMAL
- en: Our development tool could be used alongside any framework, from PHP to static
    files. For a general server, let's take the recipe *Serving static files* from[Chapter
    1](ch01.html "Chapter 1. Making a Web Server"), *Making a Web Server*, to test
    our tool out on. We'll copy the files (including the `content` folder) from that
    recipe into a new folder, which we can name `watcher`.
  prefs: []
  type: TYPE_NORMAL
- en: For the server counterpart of our tool, we'll make `watcher.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is familiar. We make a `socket.io` server (on a different
    port to avoid clashing), generate a concatenated `socket.io.js` plus client-side
    `watcher` code file, and add it to the static resources of `socket.io`. Since
    this is a quick tool for our own development uses, our client-side code is written
    as a string to the `watcher` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of code calls the `fs.watch` method, where the callback receives
    the event name (`e`) and the filename (`f`).
  prefs: []
  type: TYPE_NORMAL
- en: We check that the filename isn't a hidden dotfile. During a save event some
    file systems or editors will change hidden files in the directory, thus triggering
    multiple callbacks sending several messages at high speed, which can cause issues
    for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, we simply place it as a script within every page served (probably
    using server-side templating). However, for demonstration purposes, we simply
    place the following code into `content/index.html:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once we fire up `server.js` and `watcher.js`, we can point our browser to `http://localhost:8080`
    and see the familiar excited **Yay!** from[Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"), *Making a Web Server*. Any changes we make and save (either to
    `index.html, styles.css, script.js`, or the addition of new files) will be almost
    instantly reflected in the browser. The first change we can make is to rid ourselves
    of the alert box in `script.js` so changes can be seen fluidly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a WebSocket server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Seamless fallbacking with socket.io* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed In [Chapter 4](ch04.html
    "Chapter 4. Interfacing with Databases"),Interfacing with Databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
