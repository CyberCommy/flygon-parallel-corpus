- en: Working with Go and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building your first Go Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first Go Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing your Docker image to the Docker Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first user-defined bridge network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a MySQL Docker image on a user-defined bridge network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Go web application Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a web application Docker container linked with a MySQL Docker container
    on a user-defined bridge network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With organizations moving towards DevOps, Docker has started to gain popularity
    as well. Docker allows for packaging an application with all of its dependencies
    into a standardized unit for software development. And if that unit runs on your
    local machine, we can guarantee that it will run exactly the same way, anywhere
    from QA, to staging, and to production environments. With the knowledge of the
    concepts covered in this chapter, we will be able to write Docker images and deploy
    Docker containers with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create a Docker image and Docker containers
    to deploy a simple Go web application, following which we will be looking at how
    we can save the container to an image and push it to the Docker registry, along
    with some basic concepts of Docker networking.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to work with Docker, I assume it's installed and running on
    your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first Go Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Docker image is the filesystem and configuration of our application and is
    further used to create Docker containers. There are two ways by which a Docker
    image can be created, which is either from scratch or from a parent image. In
    this recipe, we will learn how to create a Docker image from a parent image. This
    means an image created basically refers to the contents of its parent and subsequent
    declarations in the `Dockerfile` modify the parent image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `Docker` and `Docker Machine` are installed by executing the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `http-server.go`, where we will create a simple HTTP server that will
    render Hello World! browsing  `http://docker-machine-ip:8080` or executing `curl
    -X GET http://docker-machine-ip:8080` from the command line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DockerFile`, which is a text file that contains all the commands
    needed to build an image. We will use `golang:1.9.2` as the base, or the parent
    image, which we have specified using the `FROM` directive in the `Dockerfile`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b05638b8-f7e8-4def-a9ad-9d7bd0942ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build a Docker image from the `Dockerfile` executing the `docker build` command
    with the image name as `golang-image` using the `-t` flag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command has executed successfully, it will render the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cad5fe0a-9f6d-4cb3-971c-2acb0b1f758a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are building an image behind a corporate proxy, you will probably have
    to provide the proxy settings. You can do this by adding environment variables
    using the `ENV` statement in the `Dockerfile`, which we often call as a runtime
    customization, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass the proxy settings at build time to the builder using the
    `--build-arg <varname>=<value>` flag, which is called as a build time customization,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether the Docker image has been created successfully by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all the top-level images, their repositories, tags, and their
    size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6f1c2f-31f0-42c1-98a7-ee42c510de4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the `Dockerfile` we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM golang:1.9.2`: The `FROM` instruction specifies the base image, which
    is, for us `golang:1.9.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV SRC_DIR=/go/src/github.com/arpitaggarwal/`: Here, we are setting the Go
    source code directory as an environment variable using the `ENV` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV GOBIN=/go/bin`: Here, we are setting the `GOBIN` or a directory to generate
    executable binaries as an environment variable using the `ENV` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR $GOBIN`: The `WORKDIR` instruction sets the working directory for
    any `RUN`, `CMD`, `ENTRYPOINT`, `COPY` and `ADD` statements, which is `/go/bin`
    for our image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD . $SRC_DIR`: Here, we copy`http-server.go` from the current directory
    on our host machine to the `/go/src/github.com/arpitaggarwal/` directory of `golang-image`
    using the `ADD` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN cd /go/src/`: Here, we change the current directory to`/go/src/` in a
    `golang-image` using the `RUN` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN go install github.com/arpitaggarwal/`: Here, we compile `/go/src/github.com/arpitaggarwal/http-server.go`
    and generate an executable binary file of it in the `/go/bin` directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT ["./arpitaggarwal"]`: Here, we are specifying the executable binary
    generated to run as an executable when running a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 8080`: The `EXPOSE` instruction informs Docker that the container that
    we will create from an image will listen on the network port `8080` at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first Go Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Docker container includes an application and all of its dependencies. It shares
    the kernel with other containers and runs as an isolated process in the user space
    on the host operating system. To run the actual application, we have to create
    and run the containers from an image, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the `docker run` command to create and run a Docker container from
    the `golang-image`, assigning the container name as `golang-container` using the
    `-name` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` flag specified in the `docker run` command starts the container in
    a daemon mode and the hash string at the end represents the ID of the `golang-container`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether the Docker container has been created and is running successfully
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command has executed successfully, it will give us the running
    Docker container details, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a846dfe-dc9b-4426-ac8f-f9d8d08c6ebd.png)'
  prefs: []
  type: TYPE_IMG
- en: To list all the Docker containers, whether they are running or not, we have
    to pass an additional flag, `-a`, as `docker ps -a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse `http://localhost:8080/` or execute a `GET` call from the command line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will give us Hello World! as a response, which means the HTTP server is
    listening inside a Docker container at port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing your Docker image to the Docker Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a Docker image has been created, it's always best practice to store or
    save the image so that the next time you have to boot up the containers from your
    custom image, you don't have to bother about or remember the steps you performed
    earlier while creating it.
  prefs: []
  type: TYPE_NORMAL
- en: You can save an image either on a local machine or in an artifactory or to any
    of the public or private Docker Registries, such as Docker Hub, Quay, Google Container
    Registry, AWS Container Registry, and so on. In this recipe, we will learn how
    to save or push an image which we have created in one of our previous recipes
    to the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Building your first Go Docker image* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create your account on the Docker Hub (`https://hub.docker.com/`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Login into the Docker Hub from the command line by executing the `docker login`
    command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag the `golang-image`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify whether the image has been tagged successfully by executing the `docker
    images` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding command will list all the Docker images, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40e5fcf6-d25b-4998-b6fc-5b91f72ca170.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Push the tagged image to the Docker Hub by executing the `docker push` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify whether an image has been pushed successfully to the Docker Hub,
    browse `https://hub.docker.com/`, sign in using your credentials, and, once logged
    in, you will see the tagged image, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee77a49d-e970-41bc-8a31-abdc1640fb86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you performed any changes to the Docker container and want to persist them
    as well as part of an image, then first you have to commit the changes to a new
    image or to the same image using the `docker commit` command before tagging and
    pushing it to the Docker Hub, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ docker commit <container-id> golang-image-new`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ docker tag golang-image-new arpitaggarwal/golang-image`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ docker push arpitaggarwal/golang-image`**'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first user-defined bridge network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to connect one Docker container to another Docker container
    by the container name, then first we have to create a user-defined network. This
    is because Docker does not support automatic service discovery on the default
    bridge network. In this recipe, we will learn how to create our own bridge network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the `docker network` command to create a bridge network with the name
    as `my-bridge-network`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `my-bridge-network` has been created successfully by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see detailed information about `my-bridge-network`, run the `docker network
    inspect` command followed by the network name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running a MySQL Docker image on a user-defined bridge network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we run a Docker image to create and boot up a container, it uses the
    default bridge network, which Docker creates during installation. To run an image
    on a specific network, which may be either user-defined or one of the other two
    networks that Docker creates automatically, host or none, we have to provide the
    additional `--net` flag with the value as the network name as part of the `docker
    run` command.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will run a MySQL image on the user-defined bridge network
    that we created in the previous recipe, passing the `--net` flag value as `my-bridge-network`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the `docker run` command to create and run a MySQL Docker container
    from the `mysql:latest` image, assigning the container name as `mysql-container`
    using the `--name` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `--net` flag specified in the `docker run` command connects `mysql-container`
    to `my-bridge-network`. The `-p` flag specified in the `docker run` command publishes
    the container's `3306` port to the host `3306` port. The `-e` flag specified in
    the `docker run` command sets the `MYSQL_ROOT_PASSWORD` value as `my-pass`, which
    is an environment variable of the `mysql:latest` image. The `-d` flag specified
    in the `docker run` command starts the container in a daemon mode, and the hash
    string at the end represents the ID of the `mysql-container`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether the Docker container has been created and is running successfully
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the `my-bridge-network` again will show us the `mysql-container`
    details in the `Containers` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Building a Go web application Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will build a Docker image that connects to the MySQL database
    instance running in a separate Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `http-server.go`, where we will create a simple HTTP server and a handler
    which will give us the current database details, such as machine IP, hostname,
    port, and selected database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DockerFile`, which is a text file that contains all the commands
    needed to build an image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f165d975-c3c5-4163-b580-0f4266b4ded8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Build a Docker image from the `Dockerfile` executing the `docker build` command
    with the image name as `web-application-image` using the `-t` flag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command has executed successfully, it will render the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/884a7e97-83a5-47dc-beeb-3dbcf5eb767f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether the Docker image has been created successfully by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all the top-level images, their repositories, tags, and their
    size, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a91e907-a6a4-4095-afa9-ad6fb5853bc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Dockerfile` we created in this recipe is exactly the same as the one we
    created in one of our previous recipes, except for the two additional commands
    that install the Go MySQL Driver and the Gorilla Mux URL router while building
    the image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See the *Building your first Go Docker image* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Running a web application Docker container linked with a MySQL Docker container
    on a user-defined bridge network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to run a Go web application Docker image to
    create a container which will communicate with the MYSQL database instance running
    in a separate Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: As we know Docker does not support automatic service discovery on the default
    bridge network, we will be using the user-defined network that we created in one
    of our previous recipes to run a Go web application Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the `docker run` command to create a web application Docker container
    from the `web-application-image`, assigning the container name as `web-application-container`
    using the `--name` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `--net` flag specified in the `docker run` command connects the `mysql-container`
    to the `my-bridge-network`. The `-p` flag specified in the `docker run` command
    publishes the container's `8080` port to the host `8080` port. The `-d` flag specified
    in the `docker run` command starts the container in a daemon mode and the hash
    string at the end represents the ID of the `web-application-container`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether the Docker container has been created and is running successfully
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2028534-abca-4878-b2fc-192464b36bb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Browsing `http://localhost:8090/` as will give us the machine IP, hostname,
    port, and current database details as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96c2854b-5a25-492a-8c25-c9fb8b438d93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, inspecting `my-bridge-network` again will show us the `mysql-container`
    and `web-application-container` details in the `Containers` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
