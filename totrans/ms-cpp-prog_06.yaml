- en: Multithreaded Programming and Inter-Process Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to POSIX pthreads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating threads with the pthreads library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread creation and self-identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C++ thread support library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data racing and thread synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining and detaching threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending signals from threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlocks and solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future, promise, `packaged_task`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency with the thread support library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in concurrent applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn these topics with a few interesting, easy-to-understand examples
    discussed throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to POSIX pthreads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix, Linux, and macOS are largely compliant with the POSIX standard. **Portable
    Operating System Interface for Unix** (**POSIX**) is an IEEE standard that helps
    all Unix and Unix-like operating systems, that is Linux and macOS, communicate
    with a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, POSIX is also supported by POSIX-compliant tools--Cygwin, MinGW,
    and Windows subsystem for Linux--that provide a pseudo-Unix-like runtime and development
    environment on Windows platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pthread is a POSIX-compliant C library used in Unix, Linux, and macOS.
    Starting from C++11, C++ natively supports threads via the C++ thread support
    library and concurrent library. In this chapter, we will understand how to use
    pthreads, thread support, and concurrency library in an object-oriented fashion.
    Also, we will discuss the merits of using native C++ thread support and concurrency
    library as opposed to using POSIX pthreads or other third-party threading frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating threads with the pthreads library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get straight to business. You need to understand the pthread APIs we''ll
    discuss to get your hands dirty. To start with, this function is used to create
    a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table briefly explains the arguments used in the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API arguments** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| `pthread_t *thread` | Thread handle pointer |'
  prefs: []
  type: TYPE_TB
- en: '| `pthread_attr_t *attr` | Thread attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `void *(*start_routine)(void*)` | Thread function pointer |'
  prefs: []
  type: TYPE_TB
- en: '| `void * arg` | Thread argument |'
  prefs: []
  type: TYPE_TB
- en: 'This function blocks the caller thread until the thread passed in the first
    argument exits, as shown in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table briefly describes the arguments in the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API arguments** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| `pthread_t thread` | Thread handle |'
  prefs: []
  type: TYPE_TB
- en: '| `void **retval` | Output parameter that indicates the exit code of the thread
    procedure |'
  prefs: []
  type: TYPE_TB
- en: 'The ensuing function should be used within the thread context. Here, `retval` is
    the exit code of the thread that indicates the exit code of the thread that invoked
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the argument used in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API argument** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| `void *retval` | The exit code of the thread procedure |'
  prefs: []
  type: TYPE_TB
- en: 'The following function returns the thread ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write our first multithreaded application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program can be compiled with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need to link the POSIX `pthread` library dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following screenshot and visualize the output of the multithreaded
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a98ad57-5892-4cb5-bfaf-fe5e9a44fb81.png)'
  prefs: []
  type: TYPE_IMG
- en: The code that is written in ThreadProc runs within the thread context. The preceding
    program has a total of four threads, including the main thread. I had blocked
    the main thread with `pthread_join` to force it to wait for the other three threads
    to complete their tasks first, failing which the main thread would have exited before
    them. When the main thread exits, the application exits too, which ends up prematurely
    destroying newly created threads.
  prefs: []
  type: TYPE_NORMAL
- en: Though we created `thread1`, `thread2`, and `thread3` in the respective sequence,
    there is no guarantee that they will be started in the exact same sequence they
    were created in.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system scheduler decides the sequence in which the threads must
    be started, based on the algorithm used by the operating system scheduler. Interestingly,
    the sequence in which the threads get started might vary at different runs in
    the same system.
  prefs: []
  type: TYPE_NORMAL
- en: Does C++ support threads natively?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from C++11, C++ does support threads natively, and it is generally
    referred to as the C++ thread support library. The C++ thread support library
    provides an abstraction over the POSIX pthreads C library. Over time, C++ native
    thread support has improved to a greater extent.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend you make use of the C++ native thread over pthreads. The
    C++ thread support library is supported on all platforms as it is officially part
    of standard C++ as opposed to the POSIX `pthread` library, which is only supported
    on Unix, Linux, and macOS but not directly on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is thread support has matured to a new level in C++17, and it
    is poised to reach the next level in C++20\. Hence, it is a good idea to consider
    using the C++ thread support library in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: How to write a multithreaded application using the native C++ thread feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interestingly, it is pretty simple to write a multithreaded application using
    the C++ thread support library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `thread` class was introduced in C++11\. This function can be used to create
    a thread. The equivalent of this function is `pthread_create` in the POSIX `pthread`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Argument** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| `thread_procedure` | Thread function pointer |'
  prefs: []
  type: TYPE_TB
- en: 'Now a bit about the argument that returns the thread ID in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is equivalent to the `pthread_self()` function in the POSIX `pthread`
    library. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `join()` function is used to block the caller thread or the main thread
    so it will wait until the thread that has joined completes its task. This is a
    non-static function, so it has to be invoked on a thread object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use the preceding functions to write a simple multithreaded
    program based on C++. Refer to the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The C++ version of the multithreaded program looks a lot simpler and cleaner
    than the C version.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command helps you compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, `-std=c++17` instructs the C++ compiler to enable the
    C++17 features; however, the program will compile on any C++ compiler that supports
    C++11, and you just need to replace `c++17` with `c++11`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d2d2907-bab3-470d-aa7d-ba7e3398a604.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All the numbers starting with `140` in the preceding screenshot are thread
    IDs. Since we created three threads, three unique thread IDs are assigned respectively
    by the `pthread` library. If you are really keen on finding the thread IDs assigned
    by the operating system, you will have to issue the following command in Linux
    while the application is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably to your surprise, the thread ID assigned by the `pthread` library
    will be different from the one assigned by the operating systems. Hence, technically
    the thread ID assigned by the `pthread` library is just a thread handle ID that
    is different from the thread ID assigned by the OS. The other interesting tool
    that you may want to consider is the `top` command to explore the threads that
    are part of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the commands require the process ID of your multithreaded application.
    The following command will help you find this ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You may also explore the `htop` utility in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get the thread ID assigned by the OS programmatically, you can
    use the following function in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, this isn't recommended if you want to write a portable application,
    as this is supported only in Unix and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Using std::thread in an object-oriented fashion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been looking for the C++ thread class that looks similar to the
    `Thread` classes in Java or Qt threads, I''m sure you will find this interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a wrapper class that works as a convenience class for the C++ thread
    support library in this book. The `Thread::run()` method is our user-defined thread
    procedure. As I don't want the client code to invoke the `Thread::run()` method
    directly, I have declared the run method `private`. In order to start the thread,
    the client code has to invoke the start method on the `thread` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding `Thread.cpp` source file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the previous `Thread.cpp` source file, you will have understood that the
    thread can be stopped when required by invoking the `stop` method. It is a simple
    yet decent implementation; however, there are many other corner cases that need
    to be handled before it can be used in production. Nevertheless, this implementation
    is good enough to understand the thread concepts in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, let''s see how our `Thread` class can be used in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I have created three threads, and the way the `Thread` class is designed, the
    thread will only start when the `start` function is invoked. The detached threads
    run in the background; usually, you need to detach a thread if you would like
    to make the threads daemons. However, these threads are stopped safely before
    the application quits.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command helps compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18ee2225-4dde-48d5-b3de-6cd417e6424a.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! We could start and stop the thread as designed and that too in an object-oriented
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: What did you learn?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to recollect what we have discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to write a multithreaded application using the POSIX `pthread`
    C library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ compilers support threads natively, starting from C++11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned the basic C++ thread support library APIs that are commonly used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to write a multithreaded application using the C++ thread support
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You now know why you should consider using the C++ thread support library over
    the `pthread` C library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ thread support library is cross-platform, unlike the POSIX `pthread`
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know how to use the C++ thread support library in an object-oriented fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know how to write simple multithreaded applications that don't require synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, threads would provide better application performance. But,
    at times, it isn't uncommon to notice that application performance degrades due
    to multiple threads. This performance issue may not be really tied to multiple
    threads; the real culprit could be the design. Too much use of synchronization
    leads to many thread-related issues that also lead to application performance
    degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Lock-free thread designs not only avoid thread-related issues, but also improve
    the overall application performance. However, in a practical world, more than
    one thread may have to share one or more common resources. Hence, there arises
    a need to synchronize the critical section of code that accesses or modifies the
    shared resources. There are a variety of synchronization mechanisms that can be
    used in specific scenarios. In the following sections, we will explore them one
    by one with some interesting and practical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if threads weren't synchronized?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When there are multiple threads that share a common resource within the process
    boundary, the critical section of the code can be synchronized with a mutex lock.
    A mutex is a mutually exclusive lock that allows only one thread to access the
    critical block of code that is secured by a mutex. Let's take a simple example
    to understand the need for the mutex lock application practically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a `Bank Savings Account` class that allows three simple operations,
    that is, `getBalance`, `withdraw`, and `deposit`. The `Account` class can be implemented
    as shown in the following code. For demonstration purposes, the `Account` class
    is designed in a simple fashion neglecting corner cases and validations that are
    required in the real world. It is simplified to the extent that the `Account`
    class doesn''t even bother to capture the account number. I''m sure there are
    many such requirements that are quietly ignored for simplicity. No worries! Our
    focus is to learn mutex here with the shown example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Account.cpp` source file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create two threads, namely `DEPOSITOR` and `WITHDRAWER`. The `DEPOSITOR`
    thread is going to deposit INR 2000.00 while the `WITHDRAWER` thread is going
    to withdraw INR 1000.00 every alternate second. As per our design, the `main.cpp`
    source file can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the `main` function, the thread constructor takes two arguments.
    The first argument is the thread procedure that you would be familiar with by
    now. The second argument is an optional argument that can be supplied if you would
    like to pass some arguments to the thread function.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program can be compiled with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you have followed all the steps as instructed, your code should compile successfully.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to execute and observe how our program works!
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that the `WITHDRAWER` thread always withdraws INR 1000.00, while
    the `DEPOSITOR` thread always deposits INR 2000.00\. The following output conveys
    this at first. The `WITHDRAWER` thread started withdrawing, followed by the `DEPOSITOR`
    thread that seems to have deposited the money.
  prefs: []
  type: TYPE_NORMAL
- en: Though we started the `DEPOSITOR` thread first and the `WITHDRAWER` thread next,
    it looks like the OS scheduler seems to have scheduled the `WITHDRAWER` thread
    first. There is no guarantee that this will always happen this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going by the output, by chance, the `WITHDRAWER` thread and the `DEPOSITOR`
    thread seem to do their work alternately. They would continue like this for some
    time. At some point, both the threads would seem to work simultaneously, and that''s
    when things would fall apart, as shown in the output ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92ea367f-1295-4dd9-bc8c-589659755cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: It is very interesting to observe the last four lines of the output. It looks
    like both the `WITHDRAWER` and `DEPOSITOR` threads were checking the balance,
    and it was INR 9000.00\. You may notice that there is an inconsistency in the
    `DEPOSITOR` thread's print statements; as per the `DEPOSITOR` thread, the current
    balance is INR 9000.00\. Therefore, when it deposits INR 2000.00, the balance
    should total up to INR 11000.00\. But in reality, the balance after the deposit
    is INR 10000.00\. The reason for this inconsistency is that the `WITHDRAWER` thread
    withdrew INR 1000.00 before the `DEPOSITOR` thread could deposit money. Though
    technically the balance seems to total out correctly, things can go wrong shortly;
    this is when the need for thread synchronization arises.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's refactor the `threadProc` function and synchronize the critical section
    that modifies and accesses the balance. We need a locking mechanism that will
    only allow one thread to either read or write the balance. The C++ thread support
    library offers an apt lock called `mutex`. The `mutex` lock is an exclusive lock
    that will only allow one thread to operate the critical section code within the
    same process boundary. Until the thread that has acquired the lock releases the
    `mutex` lock, all other threads will have to wait for their turn. Once a thread
    acquires the `mutex` lock, the thread can safely access the shared resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` file can be refactored as follows; the changes are highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the mutex is declared in the global scope. Ideally,
    we could have declared the mutex inside a class as a static member as opposed
    to a global variable. As all the threads are supposed to be synchronized by the
    same mutex, ensure that you use either a global `mutex` lock or a static `mutex`
    lock as a class member.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactored `threadProc` in `main.cpp` source file looks as follows; the
    changes are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code that is wrapped between `lock()` and `unlock()` is the critical section
    that is synchronized by the mutex lock.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are two critical section blocks in the `threadProc` function,
    so it is important to understand that only one thread can enter the critical section.
    For instance, if the depositor thread has entered its critical section, then the
    withdrawal thread has to wait until the depositor thread releases the lock and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, we could replace all the raw `lock()` and `unlock()` mutex methods
    with `lock_guard` as this ensures the mutex is always unlocked even if the critical
    section block of the code throws an exception. This will avoid starving and deadlock
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to check the output of our refactored program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/072965fe-4845-4e62-981a-5fdb53dc2b4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Great, did you check the balance reported by `DEPOSITOR` and `WITHDRAWER` threads?
    Yep, they are always consistent, aren't they? Yes, the output confirms that the
    code is synchronized and it is thread-safe now.
  prefs: []
  type: TYPE_NORMAL
- en: Though our code is functionally correct, there is room for improvement. Let's
    refactor the code to make it object-oriented and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reuse the `Thread` class and abstract all the thread-related stuff inside
    the `Thread` class and get rid of the global variables and `threadProc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s observe the refactored `Account.h` header, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Account.h` header hasn't changed as it already looks clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The respective `Account.cpp` source file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is better if the `Account` class is separated from the thread-related functionalities
    to keep things neat. Also, let''s understand how the `Thread` class that we wrote
    could be refactored to use the mutex synchronization mechanism as shown ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the `Thread.h` header file shown previously, a couple of changes are done
    as part of refactoring. As we would like to synchronize the threads using a mutex,
    the `Thread` class includes the mutex header of the C++ thread support library.
    As all the threads are supposed to use the same `mutex` lock, the `mutex` instance
    is declared static. Since all the threads are going to share the same `Account`
    object, the `Thread` class has a pointer to the `Account` object as opposed to
    a stack object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread::run()` method is the `Thread` function that we are going to supply
    to the `Thread` class constructor of the C++ thread support library. As no one
    is expected to invoke the `run` method directly, the `run` method is declared
    private. As per our `Thread` class design, which is similar to Java and Qt, the
    client code would just invoke the `start` method; when the OS scheduler gives
    a green signal to `run`, the `run` thread procedure will be called automatically.
    Actually, there is no magic here since the `run` method address is registered
    as a `Thread` function at the time of creating the thread.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, I prefer to include all the dependent headers in the user-defined
    header file, and the user-defined source file includes only its own header. This
    helps organize the headers in one place, and this discipline helps maintain the
    code cleaner and also improves the overall readability and code maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Thread.cpp` source can be refactored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `threadProc` function that was there in `main.cpp` has moved inside the `Thread`
    class's `run` method. After all, the `main` function or the `main.cpp` source
    file isn't supposed to have any kind of business logic, hence they are refactored
    to improve the code quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how clean is the `main.cpp` source file after refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previously shown `main()` function and the overall `main.cpp` source file
    looks short and simple without any nasty complex business logic hanging around.
  prefs: []
  type: TYPE_NORMAL
- en: C++ supports five types of mutexes, namely `mutex`, `timed_mutex`, `recursive_mutex`,
    `recursive_timed_mutex`, and `shared_timed_mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command helps you compile the refactored program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Brilliant! If all goes well, the program should compile smoothly without making
    any noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just take a quick look at the output shown here before we move on to the next
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d415cdd7-497d-413e-93ec-853e66f7c162.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! It works fine. The `DEPOSITOR` and `WITHDRAWER` threads seem to work
    cooperatively without messing up the balance and print statements. After all,
    we have refactored the code to make the code cleaner without modifying the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What is a deadlock?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a multithreaded application, everything looks cool and interesting until
    we get struck with a deadlock. Assume there are two threads, namely `READER` and
    `WRITER`. Deadlocks might happen when the `READER` thread waits for a lock that
    is already acquired by `WRITER` and the `WRITER` thread waits for the reader to
    release a lock that is owned by `READER` and vice versa. Typically, in a deadlock
    scenario, both the threads will wait for each other endlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, deadlocks are design issues. At times, deadlocks could be detected
    quickly, but sometimes it might get very tricky to find the root cause. Hence,
    the bottom line is synchronization mechanisms must be used in the right sense
    thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the concept of a deadlock with a simple yet practical example.
    I'm going to reuse our `Thread` class with some slight modifications to create
    a deadlock scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `Thread.h` header looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `ThreadType` enumeration helps assign a particular task to a thread. The
    `Thread` class has two new methods: `Thread::getCount()` and `Thread::updateCount()`.
    Both the methods will be synchronized with a common `mutex` lock in such a way
    that it creates a deadlock scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s move on and review the `Thread.cpp` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By now, you will be quite familiar with the `Thread` class. Hence, let's focus
    our discussion on the `Thread::getCount()` and `Thread::updateCount()` methods.
    The `std::lock_guard<std::mutex>` is a template class that frees us from calling
    `mutex::unlock()`. During the stack unwinding process, the `lock_guard` destructor
    will be invoked; this will invoke `mutex::unlock()`.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that from the point the `std::lock_guard<std::mutex>` instance
    is created, all the statements that appear until the end of the method are secured
    by the mutex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s plunge into the `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function is pretty self-explanatory. We have created two threads,
    namely `reader` and `writer`, and they are started after the respective threads
    are created. The main thread is forced to wait until the reader and writer threads exit.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the following command to compile this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the output of the program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dd5ba71-5a2a-49d6-9f59-d33ddc10bd0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Refer to the code snippets of the `Thread::getCount()` and `Thread::updateCount()`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From the previous output screenshot image, we can understand the `WRITER` thread seems
    to have started first. As per our design, the `WRITER` thread will invoke the
    `Thread::updateCount()` method, which in turn will invoke the `Thread::getCount()` method.
  prefs: []
  type: TYPE_NORMAL
- en: From the output's screenshot, it is evident from the print statements that the
    `Thread::updateCount()` method has acquired the lock first and has then invoked
    the `Thread::getCount()` method. But since the `Thread::updateCount()` method
    hasn't released the mutex lock, there is no way for the `Thread::getCount()` method
    invoked by the `WRITER` thread to proceed. Meanwhile, the OS scheduler has started
    the `READER` thread, which seems to wait for the `mutex` lock acquired by the
    `WRITER` thread. Hence, for the `READER` thread to complete its task, it has to
    acquire the lock on the `Thread::getCount()` method; however, this isn't possible
    until the `WRITER` thread releases the lock. To make things even worse, the `WRITER`
    thread can't complete its task until its own `Thread::getCount()` method call
    completes its task. This is what is called a **deadlock**.
  prefs: []
  type: TYPE_NORMAL
- en: This is either a design or logical issue. In Unix or Linux, we can make use
    of the Helgrind tool to find deadlocks by racing similar synchronization issues.
    The Helgrind tool comes along with the Valgrind tool. The best part is that both
    Valgrind and Helgrind are open source tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the source line number that leads to a deadlock or race issue,
    we need to compile our code in debug mode, as shown now with `-g` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The Helgrind tool can be used to detect deadlock and similar issues, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a short extract of the Valgrind output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa1738f1-583f-40eb-a110-f6f5500e0adb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One simple fix to resolve the issue is to refactor the `Thread::updateCount()`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the refactored program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a47ef09-189e-4b82-8091-5f9f3b558951.png)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, for most complex issues, the solution will be generally very
    simple. In other words, silly mistakes sometimes may lead to serious critical
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should strive to prevent the deadlock issue during the design phase
    so that we wouldn't have to break our head doing complex debugging. The C++ thread
    support library mutex class offers `mutex::try_lock()` (since C++11 ), `std::timed_mutex`
    (since C++11), and `std::scoped_lock` ( since C++17 ) to avoid deadlocks and similar
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: What did you learn?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s summarize the takeaway points:'
  prefs: []
  type: TYPE_NORMAL
- en: We should design lock-free threads when possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock-free threads tend to perform better compared to heavily synchronized/sequential
    threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex is a mutually exclusive synchronization primitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex helps synchronize the access of shared resources, one thread at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlocks occur due to bad use of mutex, or in general, due to bad use of any
    synchronization primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlocks are the outcome of logical or design issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deadlocks can be detected with the Helgrind/Valgrind open source tools in Unix
    and Linux OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shared mutex synchronization primitive supports two modes, namely shared
    and exclusive. In the shared mode, the shared mutex will allow many threads to
    share the resource at the same time, without any data race issues. And in the
    exclusive mode, it works just like regular mutex, that is, it will allow only
    one thread to access the resource. This is a suitable lock primitive if you have
    multiple readers that can access the resource safely and you allow only one thread
    to modify the shared resource. Refer to the chapter on C++17 for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The conditional variable synchronization primitive is used when two or more
    threads need to communicate with each other and proceed only when they receive
    a particular signal or event. The thread that waits for a particular signal or
    event has to acquire a mutex before it starts waiting for the signal or event.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the use case of a conditional variable with a producer/consumer
    problem. I'm going to create two threads, namely `PRODUCER` and `CONSUMER`. The
    `PRODUCER` thread will add a value to the queue and notify the `CONSUMER` thread.
    The `CONSUMER` thread will wait for the notification from `PRODUCER`. On receipt
    of the notification from the `PRODUCER` thread, the `CONSUMER` thread will remove
    the entry from the queue and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand how the `Thread.h` header shown here makes use of the conditional
    variable and mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As `PRODUCER` and `CONSUMER` threads are supposed to use the same mutex and
    `conditional_variable`, they are declared static. The conditional variable synchronization
    primitive expects a predicate function that is going to make use of the ready
    boolean flag. Hence, I have declared the ready flag as well in the static scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the `Thread.cpp` source file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `Thread` class, I used `unique_lock<std::mutex>`. The `conditional_variable::wait()` method
    expects `unique_lock`, hence I'm using `unique_lock` here. Now, `unique_lock<std::mutex>` supports
    ownership transfer, recursive locking, deferred locking, manual locking, and unlocking
    without deleting `unique_lock`, unlike `lock_guard<std::mutex>`. The `lock_guard<std::mutex>` instance
    immediately locks the mutex, and the mutex gets unlocked automatically when the
    `lock_guard<std::mutex>` instance goes out of the scope. However, `lock_guard`
    doesn't support manual unlocking.
  prefs: []
  type: TYPE_NORMAL
- en: Because we haven't created the `unique_lock` instance with the deferred locking
    option, `unique_lock` will lock the mutex immediately, just like `lock_guard`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread::run()` method is our thread function. Depending on `ThreadType`
    supplied to the `Thread` constructor, the thread instance will behave either as
    the `PRODUCER` or `CONSUMER` thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `PRODUCER` thread first locks the mutex and appends an integer to the queue,
    which is shared among `PRODUCER` and `CONSUMER` threads. Once the queue is updated,
    `PRODUCER` will unlock the mutex before notifying `CONSUMER`; otherwise, `CONSUMER`
    will not be able to acquire the mutex and receive the conditional variable signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `CONSUMER` thread first acquires the mutex and then waits for the conditional
    variable signal. On receipt of the conditional signal, the `CONSUMER` thread retrieves
    the value from the queue and prints the value and resets the ready flag so that
    the process can be repeated until the application is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to make use of `unique_lock<std::mutex>`, `lock_guard<std::mutex>`,
    or `scoped_lock<std::mutex>` to avoid deadlocks. At times, it is possible we may
    not unlock the mutex that leads to deadlocks; hence, the use of mutex directly isn't recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now lets look at the code in the `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snapshot demonstrates the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f945fc83-17c2-4831-95c6-21c0888fa75f.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Our condition variable demo works as expected. The producer and consumer
    threads are working together cooperatively with the help of a conditional variable.
  prefs: []
  type: TYPE_NORMAL
- en: What did you learn?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me summarize the takeaway points that you learned in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threads can work together by signaling each other using a conditional
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A conditional variable requires the waiting thread to acquire a mutex before
    it can wait for a conditional signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every conditional variable requires `unique_lock` that accepts a mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unique_lock<std::mutex>` method works exactly as `lock_guard<std::mutex>`
    with some additional useful functionalities, such as deferred locking, manual
    lock/unlock, ownership transfer, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unique_lock` helps avoid deadlocks just like `lock_guard`, as the mutex wrapped
    by `unique_lock` gets unlocked automatically when the `unique_lock` instance goes
    out of scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned how to write a multithreaded application that involves threads that
    signal each other for synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semaphore is yet another useful thread synchronization mechanism. But unlike
    mutex, semaphore allows more than one thread to access similar shared resources
    at the same time. Its synchronization primitive supports two types, that is, binary
    semaphore and counting semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: Binary semaphore works just like a mutex, that is, only one thread can access
    the shared resource at any point of time. However, the difference is that a mutex
    lock can only be released by the same thread that owns it; however, a semaphore
    lock can be released by any thread. The other notable difference is that generally,
    a mutex works within the process boundary whereas semaphores are used across the process
    boundary. This is because it is a heavyweight lock, unlike the mutex. However,
    a mutex can also be used across the process if created in the shared memory region.
  prefs: []
  type: TYPE_NORMAL
- en: Counting semaphores let multiple threads share a limited number of shared resources.
    While mutex lets one thread access the shared resource at a time, counting semaphores
    allow multiple threads to share a limited number of resources, which is generally
    at least two or more. If a shared resource has to be accessed one thread at a
    time but the threads are across the process boundary, then a binary semaphore
    can be used. Though the use of a binary semaphore within the same process is a
    possibility as a binary semaphore is heavy, it isn't efficient, but it works within
    the same process as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the C++ thread support library doesn't support semaphores and
    shared memory natively until C++17\. C++17 supports lock-free programming using
    atomic operations, which must ensure atomic operations are thread-safe. Semaphores
    and shared memory let threads from other processes modify the shared resources,
    which is quite challenging for the concurrency module to assure thread safety
    of atomic operations across the process boundary. C++20 seems to bet big on concurrency,
    hence we need to wait and watch the move.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it doesn''t stop you from implementing your own semaphore using the
    mutex and conditional variable offered by the thread support library. Developing
    a custom semaphore class that shares common resources within the process boundary
    is comparatively easy, but semaphores come in two flavors: named and unnamed.
    Named semaphore is used to synchronize common resources across the boundary, which
    is tricky.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could write a wrapper class around the POSIX pthreads semaphore
    primitive, which supports both named and unnamed semaphores. If you are developing
    a cross-platform application, writing portable code that works across all platforms
    is a requirement. If you go down this road, you may end up writing platform-specific
    code for each platform--yes, I heard it; sounds weird, right?
  prefs: []
  type: TYPE_NORMAL
- en: The Qt application framework supports semaphores natively. The use of the Qt
    Framework is a good choice as it is cross-platform. The downside is that the Qt
    Framework is a third-party framework.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is you may have to choose between pthreads and the Qt Framework
    or refactor your design and try to solve things with native C++ features. Restricting
    your application development using only C++ native features is difficult but guarantees
    portability across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every modern programming language supports concurrency, offering high-level
    APIs that allow the execution of many tasks simultaneously. C++ supports concurrency
    starting from C++11 and more sophisticated APIs got added further in C++14 and
    C++17\. Though the C++ thread support library allows multithreading, it requires
    writing lengthy code using complex synchronizations; however, concurrency lets
    us execute independent tasks--even loop iterations can run concurrently without
    writing complex code. The bottom line is parallelization is made more easy with
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency support library complements the C++ thread support library.
    The combined use of these two powerful libraries makes concurrent programming
    more easy in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple `Hello World` program using C++ concurrency in the following
    file named `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand the `main()` function. Future is an object of the concurrency
    module that helps the caller function retrieve the message passed by the thread
    in an asynchronous fashion. The void in `future<void>` represents the `sayHello()` thread
    function that is not expected to pass any message to the caller, that is, the
    `main` thread function. The `async` class lets us execute a function in two modes,
    namely `launch::async` or `launch::deferred` mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `launch::async` mode lets the `async` object launch the `sayHello()` method
    in a separate thread, whereas the `launch::deferred` mode lets the `async` object
    invoke the `sayHello()` function without creating a separate thread. In `launch::deferred` mode,
    the `sayHello()` method invocation will be different until the caller thread invokes
    the `future::get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `futureObj.wait()` voice is used to block the main thread to let the `sayHello()`
    function complete its task. The `future::wait()` function is similar to `thread::join()` in
    the thread support library.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s launch `concurrency.exe`, as shown ahead, and understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8078a31d-2876-4248-87e8-4ff59fe0aa1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous message passing using the concurrency support library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s slightly modify `main.cpp`, the Hello World program we wrote in the previous
    section. Let''s understand how we could pass a message from a `Thread` function
    to the caller function asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program, `promiseObj` is used by the `sayHello()` thread function
    to pass the message to the main thread asynchronously. Note that `promise<string>` implies
    that the `sayHello()` function is expected to pass a string message, hence the
    main thread retrieves `future<string>`. The `future::get()` function call will
    be blocked until the `sayHello()` thread function calls the `promise::set_value()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to understand that `future::get()` must only be called
    once as the corresponding `promise` object will be destructed after the call to
    the `future::get()` method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice the use of the `std::move()` function? The `std::move()` function
    basically transfers the ownership of `promiseObj` to the `sayHello()` thread function,
    hence `promiseObj` must not be accessed from the `main` thread after `std::move()`
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how the `concurrency.exe` application works by launching `concurrency.exe`
    as shown ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b7570b5-d92a-42c8-813d-02b2a66eb9f7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may have guessed, the output of this program is exactly the same as our
    previous version. But this version of our program makes use of promise and future
    objects, unlike the previous version that doesn't support message passing.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concurrency support module supports a concept called **task**. A task is
    work that happens concurrently across threads. A concurrent task can be created
    using the `packaged_task` class. The `packaged_task` class conveniently connects
    the `thread` function, the corresponding promise, and feature objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the use of `packaged_task` with a simple example. The following
    program gives us an opportunity to taste a bit of functional programming with
    lambda expressions and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previously shown program, I created a `packaged_task` instance called
    `addTask`. The `packaged_task< int (int,int)>` instance implies that the add task
    will return an integer and take two integer arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet indicates it is a lambda function that is defined
    anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that the `addTask( )` call in `main.cpp` appears like
    a regular function call. The `future<int>` object is extracted from the `packaged_task`
    instance `addTask`, which is then used to retrieve the output of the `addTask`
    via the future object instance, that is, the `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly launch `concurrency.exe` and observe the output shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e6a6e22-2c5d-40c4-a47c-c1749a91adb3.png)'
  prefs: []
  type: TYPE_IMG
- en: Cool! You learned how to use lambda functions with the concurrency support library.
  prefs: []
  type: TYPE_NORMAL
- en: Using tasks with a thread support library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how `packaged_task` can be used in an
    elegant way. I love lambda functions a lot. They look a lot like mathematics.
    But not everyone likes lambda functions as they degrade readability to some extent.
    Hence, it isn''t mandatory to use lambda functions with a concurrent task if you
    don''t prefer lambdas. In this section, you''ll understand how to use a concurrent
    task with the thread support library, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s launch `concurrency.exe`, as shown in the following screenshot, and
    understand the difference between the previous program and the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad1187b-ffbf-418d-9529-b0d791603f2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, the output is the same as the previous section because we just refactored
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! You just learned how to integrate the C++ thread support library
    with concurrent components.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the thread procedure and its input to packaged_task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how you can bind the `thread` function and its
    respective arguments with `packaged_task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the code from the previous section and modify it to understand
    the bind feature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `std::bind( )` function binds the `thread` function and its arguments with
    the respective task. Since the arguments are bound upfront, there is no need to
    supply the input arguments 15 or 10 once again. These are some of the convenient
    ways in which `packaged_task` can be used in C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s launch `concurrency.exe`, as shown in the following screenshot, and
    understand the difference between the previous program and the current version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c26e03-b1b4-4f6a-af4e-bab2578450e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Congrats! You have learned a lot about concurrency in C++ so far.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling with the concurrency library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concurrency support library also supports passing exceptions via a future
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the exception concurrency handling mechanism with a simple
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Just like the way we passed the output messages to the caller function/thread,
    the concurrency support library also allows you to set the exception that occurred
    within the task or asynchronous function. When the caller thread invokes the `future::get()`
    method, the same exception will be thrown, hence communicating exceptions is made
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to compile and run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and compile the program with the following command. Uncle fruits
    and yodas malte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/da2651ed-df82-434f-a8df-5ec946ac0a03.png)'
  prefs: []
  type: TYPE_IMG
- en: What did you learn?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me summarize the takeaway points:'
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency support library offers high-level components that enable the
    execution of several tasks concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future objects let the caller thread retrieve the output of the asynchronous
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The promise object is used by the asynchronous function to set the output or
    exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of `FUTURE` and `PROMISE` object must be the same as the type of the
    value set by the asynchronous function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent components can be used in combination with the C++ thread support
    library seamlessly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda function and expression can be used with the concurrency support
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the differences between the C++ thread support
    library and the pthread C library, Mutex synchronization mechanism, deadlocks
    and strategies of preventing a deadlock. You further learned how to write synchronous
    functions using the concurrency library, and further studied lambda function and
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about test-driven development as an extreme
    programming approach.
  prefs: []
  type: TYPE_NORMAL
