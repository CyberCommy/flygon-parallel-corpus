- en: Chapter 8. Advanced Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the lifecycle of components and the methods that can
    be used at different stages of the lifecycle. In this chapter, we will analyze
    each stage of this cycle and we will learn how to make the most of the hook methods
    that are triggered when a component moves from one stage to another. This chapter
    also discusses how to create a multi-component application. Readers will be able
    to add more features to the app using Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Component lifecycle hooks interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle hook methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing hook interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The directive is the fundamental building block of Angular 2 and allows you
    to connect behavior to an element in the DOM. There are three kinds of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directive is a class with an assigned `@Directive` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attribute directive usually changes the appearance or behavior of an element.
    We can change several styles or use it to render text bold or italic by binding
    to a property.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structural directive changes the DOM layout by adding and removing other
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The component is a directive with a template. Every component is made up of
    two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The class, where we define the application logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view controlled by the component which interacts with it through an API
    of properties and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component is a class with an assigned `@Component` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The directive lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop custom directives for any project, you should understand the basics
    of the Angular 2 directive lifecycle. A directive goes through a number of distinct
    stages between when it is created and when it is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change detection and rendering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Content projection (only for components)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After view (only for components)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destruction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Angular lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular offers directive lifecycle hooks that give us the ability to act when
    these key moments occur. We can implement one or more of the lifecycle hook interfaces
    in the Angular `core` library. Each interface has a single method whose name is
    the interface name prefixed with `ng` . Interfaces are optional for TypeScript
    and Angular calls the hook methods if they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend implementing the lifecycle hook interfaces to directive classes
    to benefit from strong typing and editor tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Injector creates the directive instance with the `new`  keyword. Each directive
    may contain, at most, one constructor declaration. If a class contains no constructor
    declaration, an automatic constructor is provided. The primary purpose of the
    constructor is to create a new instance of an object and to set initial properties
    for it. Angular 2 uses constructor for dependency injection, so we can save references
    to dependent instances for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the class, `CategoryListComponent` , has a constructor
    with two parameters referencing on `Router` and `CategoryService` .
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are data-bound input properties in every directive, and Angular saves
    the values of bounded properties at the initialization stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class `CategorySlideComponent` has a category-bounded to the property with
    the same name in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement `OnInit` and `OnChanges` interfaces to respond accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular calls the `ngOnChanges` method when data-bound input property values
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular calls the `ngOnInit` method after the first `ngOnChanges` and signals
    to us that the component has initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we implement the `OnInit` interface to create the form
    controls and start listening to its value changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Mostly we relying on the `ngOnInit` method for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to perform an initialization after the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finalize the component setup after Angular sets the input properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is a perfect location for the heavy initialization logic to fetch
    data from the server or to update the internal state depending on input properties.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection and rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This stage intentionally combines two important techniques that Angular 2 uses
    to bring life to the application. From one side, the change detection module of
    the framework looks after changes to the internal state of a program. It can detect
    changes in any data structure, from primitive to an array of objects. From the
    other side, the rendering part of Angular makes these changes visible in the DOM.
    Angular combines these two techniques in one stage to minimize the workload because
    rebuilding DOM trees is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: NgZone service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time the application state changes because the following asynchronous
    tasks happen in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: An event triggered by a user or application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directive and pipe properties change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback functions calling from AJAX responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback functions calling from timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular uses `NgZone` , an execution context from the Zone library, to hook
    into those asynchronous tasks to detect changes, error handling, and profiling.
    Zone can perform several significant operations whenever code enters or exits
    a zone such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting or stopping a timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a stack trace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding methods of execution code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association of data with individual zones, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every Angular application has a global zone object wrapping the executable code,
    but we can use the `NgZone` service for executing work inside or outside of the
    Angular zone as well. `NgZone` is a forked zone that extends the standard zone
    API and adds some additional functionality to the execution context. Angular uses
    `NgZone` to monkey-patch the global asynchronous operations such as `setTimeout`
    and `addEventListener` to update the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each directive in the Angular framework has a change detector, so we can define
    how change detection is performed. The hierarchical structure of directives brings
    change to the detector tree on the stage, so Angular always uses unidirectional
    data flow as a tool to deliver data from parents to children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, Angular''s change detection occurs on properties and updates
    the view accordingly, independent of the structure of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Property binding is used to supply data to a `product` , and event binding
    is used to inform other components of any updates, which it delegates to the store.
    The `product` is a reference to a real object with many fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though any field can be changed, the `product` reference itself stays the
    same. Angular will perform lots of check changes for properties of directives
    every time without performance degradation because the framework change detection
    system can execute hundreds and thousands of them within just a few milliseconds.
    Sometimes this massive change detection can be quite expensive so we can select
    a change detection strategy on a per-directive basis.
  prefs: []
  type: TYPE_NORMAL
- en: The internal state of a directive only depends on its input properties, so if
    these properties have not changed from one check to the next, then the directive
    doesn't need to be re-rendered. Bear in mind that all JavaScript objects are mutable,
    so change detection should check all input property fields to re-render a directive
    when necessary. If we use immutable structures, then change detection can be much
    faster. Let's have a look how that might happen.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An immutable object can't change. It always has only one internal state, and
    if we want to make a change to such an object, we'll always get a new reference
    to that change.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular supports the following change detection strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Default` strategy means that the change detector will check the properties
    deeply per dirty check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnPush` strategy means that the change detector will check the changes
    of references on properties per dirty check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can instruct Angular as to which change detection strategy it can use for
    specific directives via the `changeDetection` property of the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `OnPush` strategy will only work properly if all the values supplied to
    a directive via input properties are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use mutable values with the `OnPush` check detection strategy because
    it can take the Angular application into an inconsistent or unpredictable state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular automatically triggers the change detector to check the directive in
    `OnPush` mode if any of the followings happen:'
  prefs: []
  type: TYPE_NORMAL
- en: When any directive input property changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a directive fires an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any observable belonging to this directive fires an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering change detection programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, every directive has a change detector that works automatically.
    In cases when we need to trigger the change detection programmatically we can
    use the `ChangeDetectionRef` class. We can call the `markForCheck` method of this
    class in the place where changes happen, so it marks the path from this directive
    to the root, to be checked for the next change detection run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we triggered change detection because the string value
    came from `searchControl` which is always immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, we can implement `OnChanges` interfaces to detect changes
    to input the properties of a directive to respond accordingly on:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular calls the `ngOnChanges` method when a data-bound input property value
    changes. Most of the time, we do not use this method, but if you need to change
    the internal state dependence on the input properties, that's the right place
    to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we use the `OnChanges` interface to look after changes
    that happen to the `category` input property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value assigns to the `category` the `ngOnChanges` method prints the
    following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleChanges` class keeps the current and previous values of each changed
    property name, so we can iterate through and log them.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the `DoCheck` interface in our directive to detect and act
    upon changes that Angular doesn't catch on its own. Angular calls the `ngDoCheck`
    method during every change detection cycle. Please use this method with caution,
    because Angular calls it with enormous frequency, so an implementation must be
    very lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: Content projection (only for components)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, the component is an HTML element and may have content such as text
    or markup. Angular 2 uses specific entry points marked with a `ng-content` tag
    to inject the content into the component template. This technique is known as
    a **content projection** and Angular uses Shadow DOM to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular 2 takes advantages of web component standards and uses a set of the
    following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates for structural DOM changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM for styles and DOM encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used templates in our project, so now it's time to talk about how Angular
    uses Shadow DOM in different encapsulation types.
  prefs: []
  type: TYPE_NORMAL
- en: The Shadow DOM allows us to hide DOM logic behind other elements and apply styles
    in the scope of it. Everything inside the Shadow DOM is unavailable to other components,
    so we call it encapsulation. In fact, the Shadow DOM is a new technique, and not
    all web browsers support it, so Angular uses emulation to mimic how Shadow DOM
    behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three encapsulation types in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.None` : Angular doesn''t use Shadow DOM and style encapsulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.Emulated` : Angular doesn''t use Shadow DOM but emulates
    the style encapsulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewEncapsulation.Native` : Angular uses Native Shadow DOM with all the benefits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `encapsulation` property of the `@Component` decorator to instruct
    Angular what encapsulation type to use.
  prefs: []
  type: TYPE_NORMAL
- en: Component styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Angular 2, we can apply styles for the whole document and for specific components.
    That change brings another level of granularity and helps organize more modular
    designs than regular style sheets. The component styles are different to any global
    styles. Any selector inside a component style is applied within the scope of this
    component and its children. The component styles bring the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use any name of CSS classes or selectors within the context of the component
    without fear of getting name conflicts with classes and selectors used in other
    parts of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The styles encapsulated in the component are invisible to the rest of the application
    and cannot be changed elsewhere. We can change or remove the component styles
    without affecting the styles of the whole application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component styles can be taken to separate files and can co-locate with TypeScript
    and HTML codes, which makes the project code more structured and organized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The component styles may include several special selectors. All of these came
    from the Shadow DOM world.
  prefs: []
  type: TYPE_NORMAL
- en: The :host pseudo-class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any element that hosts the component calls the host. The only one way to target
    the styles of the host element from the hosted component is to use the `:host`
    pseudo-class selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we changed the display and border styles in
    the parent''s component template. In cases when we need to apply the host styles
    conditionally, use another selector as a parameter of the styles function form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding styles will apply to the host only when it has an `active` class.
  prefs: []
  type: TYPE_NORMAL
- en: The :host-context pseudo-class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just imagine a situation where you are creating a theme for your web application
    and you would like to apply specific styles to your component, dependent on the
    presence or absence of other selectors. You could easily implement it with the
    help of the `:host-context` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The logic behind the preeding code is looking for a `theme-dark` CSS class in
    any ancestor from the component host element up to the document root and applying
    `gray` to the `background-color` style to all the paragraph elements inside the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The /deep/ selector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The styles of the component apply only to its template. If we need to apply
    them to all child elements then we need to use the `/deep/` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `/deep/` selector from the preceding code snippet will apply the `bold`
    to the `font-weight` style of all `h4` header elements from the component through
    the child components tree down to all the child component views.
  prefs: []
  type: TYPE_NORMAL
- en: The `/deep/` selector has an alias `>>>` we can use interchangeably for an emulated
    view encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Non-view encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular doesn''t use Shadow DOM and style encapsulation for this type. Let''s
    imagine we have a `ParentComponent` in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code of an `AppComponent` , we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ParentComponent` has its own style and it could override it with another
    component because it will be applied to the document head later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular generates the following HTML code which runs in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is no Shadow DOM involvement, and the application applied styles to the
    entire document. Angular replaced `ng-content` with the contents of the child
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Non-view encapsulation](Image00132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Emulated view encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The emulated view is the default view encapsulation which Angular uses to create
    components. Angular doesn''t use Shadow DOM but emulates the style encapsulation.
    Let''s change the value of the `encapsulation` property to see the difference.
    Here is the style Angular generates for the emulated view encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The style of the parent component looks different and belongs to a specific
    element. This is how Angular emulates the style encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The markup part of the page looks very similar to the non-view encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Native view encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The native view is one of the simplest encapsulations. It uses the native Shadow
    DOM to encapsulate content and style. Angular doesn''t need to generate any styles
    for the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the styles for the parent component are unavailable for other applications
    as well as the markup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to project more than one child content, we can use `ng-content`
    with a dedicated `select` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Bear in mind that the `select` attribute expects string values that Angular
    can use in the `document.querySelector` . In the application component, we have
    something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting markup generated by Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Native view encapsulation](Image00133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_8/1.view-encapsulation` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know that content projection is the way Angular imports HTML content
    from outside of the component and inserts it into the designed part of the template.
    When Angular projects the external content into a component it calls the hook
    methods of the `AfterContentInit` and `AfterContentChecked` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: After Angular projects the external content into its view and the content has
    been initialized, it calls the `ngAfterContentInit` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After Angular checks the bindings of the external content that it has projected
    into its view, it calls the `ngAfterContentChecked` hook method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use any of those to manipulate properties of the content''s elements.
    To organize access to one or many content elements, we must take the parent component''s
    property and decorate it with `@ContentChild` or `@ContentChildren` . Angular
    uses parameters passing into the decorator to select the content''s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter is a type, Angular will find an element bounded to a directive
    or a component with the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the parameter is a string, Angular will interpret it as a selector to find
    corresponding elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular sets the value of the decorated property before calling the `ngAfterContentInit`
    method so that we can access it within the method. Later, when Angular checks
    and updates the content elements, it calls `ngAfterContentChecked` to inform us
    that the containing elements were updated. Let''s have a look at how can we use
    it. Here is the child component we will use as a content of the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will look at the `status` property of the child component and print out
    the values on the console from the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s combine them together inside the application component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application and we will get the following login console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_8/2.after-content` .
  prefs: []
  type: TYPE_NORMAL
- en: After view (only for components)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Angular finishes the initialization of the component''s view and its children''s
    views, it calls the methods of the two hook interfaces, `AfterViewInit` and `AfterViewChecked`
    . We can use the moment of initialization to update or manipulate view elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular calls the `ngAfterViewInit` method when it finishes initialization of
    the component's view and its children's view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular calls the `ngAfterViewChecked` method after every check on the bindings
    of the component's view and the view of its children's view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use either of these to manipulate view elements. To organize access
    to one or many view elements, we must have the property in the parent component
    and decorate it with `@ViewChild` or `@ViewChildren` . Angular uses parameters
    passing into the decorator to select view elements:'
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter is a type, Angular will find an element bounded to a directive
    or a component with the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the parameter is a string, Angular will interpret it as a selector to find
    corresponding elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular sets the value of the decorated property before calling the `ngAfterViewInit`
    method. Later, after every check and update of the view elements, it calls `ngAfterViewChecked`
    to inform us that the viewing elements were updated. Let''s have a look at how
    we can use it. Here is the child component we will use in the template of the
    parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are watching the `status` property of the child component and will print
    out the values on the console from parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Bear in mind that we use `OnPush` change detection in this code to prevent
    cycling invocation of the `ngAfterViewChecked` method. Here is the application
    component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run application and we will get the following login console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at the `chapter_8/3.after-view` .
  prefs: []
  type: TYPE_NORMAL
- en: Parent to child communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing the communication between parent and child components is not trivial,
    so let's talk about different techniques we can use to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Parent to child communication via input binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every directive may have one or more input properties. We can bind any property
    of a child component with static string or the parent component variables to organize
    communication between them. Here is the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It has three input properties marked with `@Input` decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: The property `desc` is decorated by its natural name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property `parent` is decorated with an alias name so that the parent component
    will see it by name `owner`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property `emoji` is a combination of getter/setter methods so that we can
    add some logic to assign values to a private variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has one output property `status` to communicate from child to parent. I
    intentionally added an `OnInit` hook interface so that we can send a message back
    to the parent after the creation of a child. Here is the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The parent component sets all the input properties of the child and listens
    to the `status` event in the `onStatus` method. After creation, the child component
    emits the status event and the parent component prints that information close
    to the title.
  prefs: []
  type: TYPE_NORMAL
- en: '![Parent to child communication via input binding](Image00134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_8/4.parent-child-input-binding`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Parent to child communication via a local variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent element has no access to properties or methods of the child component.
    We can create a template reference variable within the parent template to organize
    access to child component class members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding parent component, we created the `child` local template variable
    and used it within the `NgInit` directive to call the `setDesc` method of the
    child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `NgInit` directive we used to initialize the `desc` property of
    the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_8/5.parent-child-local-variable`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child communication via a call to ViewChild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we need to have access to the child component from the parent we can use
    `AfterViewInit` and `AfterViewChecked` hooks. Angular calls them after it creates
    the child views of a component. Here is the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent component imports the necessary classes and implements the `AfterViewInit`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are injecting the child component into the parent with the help of the `@ViewChild`
    decorator introduced previously. The `AfterViewInit` interface is very important
    in this scenario because the `child` component is unavailable until the Angular
    displays the parent view and calls the `ngAfterViewInit` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_8/6.parent-child-viewchild`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child communication via a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another possible way to organize parent-child communication is via a common
    service. We assign the service to a parent component and lock the scope of the
    service instance between this parent component and its children. No single component
    outside of this subtree will have access to the service or their communications.
    Here, the child component has access to the service injectable via the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We run a subscription on messages coming from the parent component in the constructor.
    Please be careful of the `OnDestroy` interface at implementation. The code in
    the `ngOnDestroy` method is a memory-leak guard step. The parent component has
    a `CommonService` registered as a provider and injected through the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We don't need the memory-leak guard step here because the parent component controls
    the lifetime of the registered provider.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code for this at `chapter_8/7.parent-child-service`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Destroying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This stage is the last one whilst a directive still exists. We can implement
    the `OnDestroy` interface to catch this moment:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular calls the `ngOnDestroy` method before destroying the directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular adds cleanup logic to this method to unsubscribe observables and detach
    event handlers to avoid memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can notify another component (parent or sibling) about the fact that the
    directive will disappear soon. We must free allocated resources, unsubscribe from
    observables and DOM event listeners, and unregister all callbacks from services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the lifecycle of components and the methods that
    can be used at different stages of them. We learned that Angular has interfaces
    with hook methods and how to make the most of the hook methods that are triggered
    when a component moves from one stage to another.
  prefs: []
  type: TYPE_NORMAL
- en: We unveiled how Angular change detection works and how we can manage it. We
    discussed how to organize communication between components.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00085.html#page "Chapter 9. Communication and Data Persistence")
    , *Communication and Data Persistence* , we will work at HTTP requests and store
    data on the Firebase platform. We will learn how to use the built-in HTTP library
    to work with endpoints. Also, we will learn how to use observables to work with
    data. At the end of the chapter, we will learn how to work with Firebase as the
    persistence layer of the app. As usual, we will continue to build the project
    that we started to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
