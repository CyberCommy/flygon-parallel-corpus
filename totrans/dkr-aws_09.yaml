- en: Managing Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets management is a critical security and operational requirement for modern
    applications and systems. Credentials such as usernames and passwords are commonly
    used to authenticate access to resources that may contain private and sensitive
    data, and it is very important that you can implement a secrets management solution
    that is able to provide these credentials to your applications in a secure manner
    that does not expose them to unauthorized parties.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets management for container-based applications is challenging, in part
    due to the ephemeral nature of containers and the fundamental requirement to run
    your containers on disposable and repeatable infrastructure. Gone are the days
    of long-lived servers where you could store secrets in a local file – now your
    servers are ECS container instances that can come and go, and you need to have
    some mechanism to be able to dynamically inject secrets into your application
    at runtime. A naive solution that we have used to date in this book is to use
    environment variables to inject your secrets directly into your application; however,
    this approach is considered insecure as it often exposes your secrets in plain
    text via various operational data sources. A more robust solution is to implement
    a secure credential store where your applications can dynamically retrieve their
    secrets in a secure manner – however, setting up your own credential store can
    be costly, time consuming, and introduce significant operational overheads.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement a simple yet effective secrets management
    solution powered by two key AWS services—the  AWS Secrets Manager, and the Key
    Management Service or KMS. These services will provide you with a cloud-based
    secure credential store that is easy to manage, cost effective and is fully integrated
    with standard AWS security controls such as IAM policies and roles. You will learn
    how to integrate any application that supports configuration via environment variables
    with your secrets management solution, by creating an entry point script in your
    Docker images that uses the AWS CLI to dynamically retrieve and inject secrets
    securely into your internal container environments, and also learn how you can
    expose secrets to other resources in your CloudFormation stacks, when you are
    using CloudFormation to deploy your environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating KMS keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating secrets using the AWS Secrets Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting secrets at container startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning secrets using CloudFormation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying secrets to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lists technical requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local AWS profile configured as per instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI version 1.15.71 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 8 needs to be completed along with a successfully deployed sample application
    to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples used in this chapter – [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2LzpEY2](http://bit.ly/2LzpEY2)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating KMS keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key building block of any secrets management solution is the ability to encrypt
    your credentials using encryption keys, which ensures the privacy and confidentiality
    of your credentials. The AWS Key Management Service (KMS) is a managed service
    that allows you to create and control encryption keys, and provides a simple,
    low-cost solution that takes away many of the operational challenges of managing
    your encryption keys. Key features of KMS include centralized key management,
    compliance with a number of industry standards, built-in auditing and integration
    with other AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: When building a secrets management solution that uses AWS Secrets Manager, you
    should create, at a minimum, at least one KMS key in your local AWS account and
    region that is used to encrypt your secrets. AWS does provide a default KMS key
    that you can use with AWS Secrets Manager, so this is not a strict requirement,
    however, in general, you should be comfortable with creating your own KMS keys
    based upon your security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily create KMS keys using the AWS console and CLI, however in keeping
    with the general theme of adopting infrastructure as code, we will create a new
    KMS key using CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates creating a KMS key and KMS alias in a new
    CloudFormation template file that you can place at the root of the todobackend-aws
    repository, which we will call `kms.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating KMS resources using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you create two resources—an `AWS::KMS::Key` resource
    called `KmsKey` that creates a new KMS key, and an `AWS::KMS::Alias` resource
    called `KmsKeyAlias`, which creates an alias or friendly name for the key.
  prefs: []
  type: TYPE_NORMAL
- en: The `KmsKey` resource includes a `KeyPolicy` property, which defines a resource
    policy that grants root account access to the key. This is a requirement for any
    KMS key that you create, in order to ensure you always have at least some means
    to access the key, which you may have used to encrypt valuable data that would
    cause considerable cost to the business if the key was inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a KMS key via the AWS console or CLI, the root account access
    policy will be automatically created for you.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting feature of the CloudFormation template in the preceding example
    is the creation of a CloudFormation export, which is created whenever you add
    the `Export` property to a CloudFormation output. In the preceding example, the
    `KmsKey` output exports the ARN of the `KmsKey` resource as specified by the `Value`
    property, and the `Export` property creates a CloudFormation export that you can
    reference in other CloudFormation stacks to inject the value of the export, rather
    than having to explicitly specify the value of the export. You will see how to
    leverage this CloudFormation export later on in this chapter, so don't worry if
    this doesn't quite make sense right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configuration of the preceding example in place, assuming you have
    placed this template in a file called `kms.yml`, you can now deploy the new stack,
    which will result in the creation of a new KMS key and KMS resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Deploying KMS Keys using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, after the CloudFormation stack is created, notice
    that the `aws cloudformation list-exports` command now lists a single export with
    a name of `secrets-key`. The value of this export is the ARN of the KMS Key resource
    in your stack, and you can now use the `Fn::ImportValue` intrinsic function in
    other CloudFormation stacks to import this value by simply referencing the export
    name of `secrets-key` (for example, `Fn::ImportValue: secrets-key`).'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with your use of CloudFormation exports. These exports are intended
    for referencing resources that are static in nature whose value that you are exporting
    will never change in the future. Once a CloudFormation export is referenced by
    another stack you cannot change the value of that export, nor delete the resource
    or stack that the export belongs to. CloudFormation exports are useful for resources
    such as IAM roles, KMS keys and network infrastructure (for example, VPCs and
    subnets), which often are very static in nature and do not change once implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and decrypting data using KMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have created a KMS key, you can use this key to encrypt and decrypt
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates encrypting a simple plain text value using
    the AWS CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting Data Using a KMS Key
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, note that you must specify the KMS key ID or alias
    using the `--key-id` flag, and whenever you use a KMS key alias, you always prefix
    the alias with `alias/<alias-name>`. The encrypted data is returned as a Base64-encoded
    binary blob in the `CiphertextBlob` property, which conveniently also encodes
    the key ID of the encrypted KMS key into the encrypted data, meaning the KMS service
    can decrypt the ciphertext blob without requiring you to explicitly specific the
    encrypting KMS key ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Decrypting Data Using a KMS Key
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you encrypt some data, this time using the AWS CLI
    query and text output options to capture the `CiphertextBlob` property value in
    a bash variable called `ciphertext`. You then use the `aws kms decrypt` command
    to pass in the cipher text as a blob file using bash process substitution to feed
    the Base64 decoded value of the cipher text into the binary file URI indicator
    (`fileb://`). Notice that the returned `Plaintext` value is not the `Hello World`
    value that you originally encrypted—this is because the `Plaintext` value is in
    a Base64 encoded format, and the following example takes the `aws kms decrypt`
    command a step further to return the original plaintext value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Decrypting Data Using a KMS Key and Returning the Plaintext ValueThe `base64
    --decode` command in the previous two examples are used to decode Base64 values
    on MacOS and most Linux platforms. On some Linux platforms such as Alpine Linux,
    the `--decode` flag is not recognized and you instead must use the `base64 -d`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets using the AWS Secrets Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have established a KMS key that can be used to encrypt and decrypt data,
    and you can now integrate this key with the AWS Secrets Manager service, which
    is a managed service launched in March 2018 that enables you to easily and cost
    effectively incorporate secrets management into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets using the AWS console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have focused on creating AWS resources via CloudFormation in the
    past few chapters, unfortunately at the time of writing, CloudFormation does not
    support AWS Secrets Manager resources, so if you are using AWS tools you need
    to provision your secrets via the AWS console or AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new secret via the AWS console, select AWS Secrets Manager from
    the services list and click on the **Store a new secret** button. Select a secret
    type of **Other type of secrets**, specify a secret key and value, and select
    the `secrets-key` KMS key you created earlier in this chapter as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/770663ce-e078-403a-ad44-11ed6bd3815f.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a New Secret using AWS Secrets Manager
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier example, notice that AWS Secrets Manager allows you to store
    multiple key/value pairs in a single secret. This is important as you often want
    to inject secrets as environment variables, so storing secrets in a key/value
    format allows you to specify the environment variable name as the key, and secret
    as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking Next, you can configure a secret name and optional description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3000a2a3-9520-40df-b976-da5096b821c8.png)Configuring Secret Name
    and Description'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you configure the secret to be called `todobackend/credentials`,
    which we will use later on in this chapter for the todobackend application. Once
    you have configured a secret name and description, you can click **Next**, skip
    the **Configure automatic rotation** section and finally click the **Store** button
    to complete creation of the secret.
  prefs: []
  type: TYPE_NORMAL
- en: Creating secrets using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create secrets via the AWS CLI by using the `aws secretsmanager
    create-secret` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Secret Using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that you specify the secret string as a JSON
    object, which provides the key/value format you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving secrets using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can retrieve secrets via the AWS CLI by using the `aws secretsmanager get-secret-value`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Obtain a Secret Value Using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, you will create a custom entrypoint script for the
    sample application container, which will use the command in the preceding example
    to inject secrets into the application container environment on startup.
  prefs: []
  type: TYPE_NORMAL
- en: Updating secrets using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall from Chapter 8, that the Django framework that powers the todobackend
    application requires an environment variable called `SECRET_KEY` to be configured,
    which is used for various cryptographic operations. Earlier in this chapter, when
    you created the **todobackend/credentials** secret, you only created a single
    key/value pair for the `MYSQL_PASSWORD` variable that is used for the database
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can now update the **todobackend/credentials** secret to
    add in a value for the `SECRET_KEY` variable. You can update secrets by running
    the `aws secretsmanager update-secret` command, referencing the ID of the secret
    and specifying the new secret value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Updating a Secret Value Using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that you can use the `aws secretsmanager get-random-password`
    command to generate a random password for you, which is ideal for the `SECRET_KEY`
    variable. It is important that you exclude quote and quotation characters using
    the `--exclude-characters` from this secret, as these characters will generally
    cause problems with bash scripts that process these values.
  prefs: []
  type: TYPE_NORMAL
- en: You then run the `aws secretsmanager update-secret` command, specifying the
    correct KMS key ID and providing an updated JSON object that includes both the
    `MYSQL_PASSWORD` and `SECRET_KEY` key/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting and restoring secrets using the AWS CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting secrets can be achieved by running the `aws secretsmanager delete-secret`
    command, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Secret Value Using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that AWS Secrets Manager does not immediately delete your secret, and
    instead schedules the secret for deletion in 30 days. During this time the secret
    is inaccessible, however it can be restored before the schedule deletion date
    as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Restoring a Secret Value Using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: You can see that after deleting the secret you are unable to access the secret,
    however once you restore the secret using the `aws secretsmanager restore-secret`
    command, you are once again able to access your secret.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting secrets at container startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One challenge with secrets management in Docker is passing secrets to your containers
    in a secure fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a somewhat naive but understandable approach
    that uses environment variables to inject your secrets directly as plaintext values,
    which is the approach we took in Chapter 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8598acf-a39f-4589-a201-c349a97e31bd.png)Injecting passwords via
    environment variables'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is simple to configure and understand, however it is not considered
    best practice from a security perspective. When you take such an approach, you
    can view your credentials in plaintext by inspecting the ECS task definition,
    and if you run `docker inspect` commands on your ECS container instances, you
    can also view your credentials in plaintext. You may also inadvertently end up
    logging your secrets using this approach, which could be shared inadvertently
    with unauthorized third parties, so clearly this approach is not considered good
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach that is considered much more secure is to store your
    secrets in a secure credential store, and have your application retrieve the secret
    when it starts up or whenever it requires the secret. AWS Secrets Manager is an
    example of a secure credential store that provides such a capability, and obviously
    this is the solution we will focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you store your secrets in a secure credential store such as AWS Secrets
    Manager, you have two general approaches to obtain your secrets as illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application injects secrets:** With this approach, your applications include
    support for directly interfacing with your credential store.  Here, your application
    may look for a secret with a static name, or may have the secret name injecting
    via an environment variable. In the example of AWS Secrets Manager, this means
    your application code would use the AWS SDK to make the appropriate API calls
    to the AWS Secrets Manager to retrieve secret values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entrypoint script injects secrets:** With this approach, you configure the
    name of the secret(s) that your application requires as a standard environment
    variable, with an entrypoint script that runs before your application, retrieving
    the secret(s) from AWS Secrets Manager and injecting them into the internal container
    environment as environment variables. Although this might sound like a similar
    approach to configuring environment variables at an ECS task definition level,
    the difference is that this happens inside the container after externally configured
    environment variables are applied, meaning they are not exposed to the ECS console
    or `docker inspect` commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/1f2b0532-b097-4637-861e-d3492194ff46.png)Using a Credential Store
    to Store and Retrieve Passwords'
  prefs: []
  type: TYPE_NORMAL
- en: The approach where your application injects secrets is generally considered
    the best approach from a security perspective, however it does require the application
    to explicitly support interacting with the credential store that you use, meaning
    additional development and cost is required to support such an approach.
  prefs: []
  type: TYPE_NORMAL
- en: The entrypoint script approach is considered less secure because you are exposing
    a secret outside the application, however the visibility of the secret is only
    within the container itself and is not visible externally. Using an entrypoint
    script does provide the benefit of not requiring applications to specifically
    support interacting with a credential store, making it a much more universal solution
    for providing secrets at runtime in a manner that is secure enough for most organizations,
    and this is the approach we will now focus on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entrypoint script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker `ENTRYPOINT` directive configures the very first command or script
    that is executed by the container. When configured in conjunction with the `CMD`
    directive, the `ENTRYPOINT` command or script is executed, with the `CMD` commands
    passed as arguments to the entrypoint script. This establishes a very common pattern
    of an entrypoint performing initialization tasks such as injecting secrets into
    the environment, which then invokes the application based on the command arguments
    passed to the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates creating an entrypoint script for the todobackend
    sample application, that you should place in the root of the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Entrypoint Script in the Todobackend Repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the content of the entrypoint script, which injects
    secrets from AWS Secrets Manager into the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Defining an Entrypoint Script that Injects Secrets into the Environment
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, an array called `secrets` is created from the `SECRETS`
    environment variable, which is expected to include the names of one or more secrets
    in a space delimited format that should be processed.  For example, you could
    process two secrets called `db/credentials` and `app/credentials` by setting the
    `SECRETS` environment variable as demonstrated in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Defining Multiple Secrets
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to the preceding example, the script then loops through each
    secret in the array, using the `aws secretsmanager get-secret-value` command to
    obtain the `SecretString` value of each secret, and then passes each value to
    the `jq` utility to parse the `SecretString` value as a JSON object and generate
    a shell expression that will export each secret key and value as an environment
    variable. Note that the `jq` expression has a lot of escaping involved to ensure
    special characters are interpreted literally, but the essence of this expression
    is to output `export *key*='*value*'` for each key/value pair in the credential.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this further, you can run the same command at the command line
    using the `todobackend/credentials` secret you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Generating a Shell Expression to Export Secrets into the Environment
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that the output is the individual `export`
    commands you would execute to inject the secret key/value pairs into the environment.
    Each environment variable value is also single quoted, to ensure bash treats all
    special characters as literal values.
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to the previous example, the `eval $vars` statement in the for
    loop simply evaluates the generated export statements as shell commands, which
    results in each key/value pair being injected into the local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the output of the `aws secretsmanager ...` command substitution in
    a separate variable ensures any errors that occur in this command substitution
    will be relayed back to your entrypoint script. You might be tempted to just run
    a single `eval $(aws secretsmanager ..)` statement in the for loop, however taking
    such an approach would mean if the `aws secretsmanager ...` command substitution
    exits with an error, your entrypoint script will not be aware of this error and
    will continue executing, which may lead to strange behavior for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop is complete, the final `exec "$@"` statement hands off control
    to the arguments passed to the entrypoint script—these arguments are represented
    by the special `$@` shell variable. For example, if your entrypoint script was
    invoked as `entrypoint python3 manage.py migrate --noinput`, then the `$@` shell
    variable would hold the arguments `python3 manage.py migrate --noinput` and the
    final `exec` command would launch and hand off control to the `python3 manage.py
    migrate --noinput` command.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to use the `exec "$@"` approach in your container entrypoint
    scripts, as `exec` ensures that the parent process of your container becomes whatever
    the command arguments that were passed to the entrypoint. If you didn't use `exec`
    and just ran the commands, the parent bash process that is running the script
    would remain the parent process of your container, and the bash process (rather
    than your application) would received subsequent signals to terminate the container
    when the container is stopped. You typically want your application to receive
    these signals, so that your application can gracefully clean up before terminating.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an entrypoint script to a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have established an entrypoint script in your todobackend repository,
    you need to add this script to the existing Dockerfile and ensure the script is
    specified as the entrypoint using the `ENTRYPOINT` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add an Entrypoint Script to a Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, notice that you modify the first `RUN` directive to
    ensure the AWS CLI is installed, by adding the highlighted `pip3 --no-cache install
    awscli` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you copy the entrypoint script to `/usr/bin/entrypoint`, ensure the
    script has the executable flag set, and specify the script as the entrypoint for
    the image. Note that you must configure the `ENTRYPOINT` directive in the exec
    style format, to ensure the command that you run in your container is passed as
    arguments to the entrypoint script (see first note at [https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd)).
  prefs: []
  type: TYPE_NORMAL
- en: 'With your Dockerfile now updated, you need to commit your changes, rebuild
    and publish your Docker image changes as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Publishing the Updated Docker Image
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when the Docker image is published, take note of the
    Docker tag for the app service (this is `5fdbe62` in my example, the actual hash
    will vary for you), which you recall from Chapter 1, specifies the Git commit
    hash of your source code repository. You will need this tag later on in this chapter
    to ensure you can deploy your changes to your todobackend application running
    in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning secrets using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have created a secret in AWS Secrets Manager and have added support for
    injecting secrets securely into your containers using an entrypoint script. Recall
    that the entrypoint script looks for an environment variable called `SECRETS`,
    and the `ApplicationTaskDefinition` and `MigrateTaskDefinition` resources in your
    CloudFormation template for the todobackend stack are currently injecting the
    application database directly. In order to support using secrets in your stack,
    you need to configure your ECS task definitions to include the `SECRETS` environment
    variable, configured with the name(s) of your secrets, and you also need to ensure
    your container have appropriate IAM permissions to retrieve and decrypt your secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is how the password for your `ApplicationDatabase` resource
    is configured—this is currently configured to use a password input via stack parameters;
    however, your database now needs to be able to somehow obtain its password from
    your newly created secret.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ECS task definitions to use secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first deal with reconfiguring the ECS task definitions to use your newly
    created secret.  Your containers now include an entrypoint script that will retrieve
    secrets from AWS Secrets Manager, and before you update the various ECS task definitions
    to import the names of your secrets as an environment variable, you need to ensure
    your containers have the correct permissions to do this.  Although you could add
    such permissions to the ECS container instance role that is applied at an EC2
    instance level, a more secure approach is to create specific IAM roles that you
    can assign to your containers, given you might be sharing your ECS clusters with
    multiple applications and don't want to grant access to your secrets from any
    container that runs on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECS includes a feature called IAM roles for tasks ([https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html)),
    which allows you to grant IAM permissions at an ECS task definition level, and
    is useful in our scenario of wanting to only grant access to the todobackend secret
    to the todobackend application. The following example demonstrates creating an
    IAM role that grants these privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating an IAM Task Role
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you create a new resource called `ApplicationTaskRole`,
    which includes an `AssumeRolePolicyDocument` property that defines the trusted
    entities that can assume the role.  Notice that the principal here is the `ecs-tasks.amazonaws.com`
    service, which is the service context that your containers assume when they attempt
    to access AWS resources using permissions granted by the IAM role. The role includes
    a policy that grants the permission `secretsmanager:GetSecretValue`, which as
    you might expect allows you to retrieve secret values, and this permission is
    constrained to the ARN of all secrets that are named with a prefix of `todobackend/`.
    If you refer back to the previous example when you created a test secret via the
    AWS CLI, you can see that the ARN of the secret includes a random value at the
    end of the ARN, hence you need to use wildcards in your ARN to ensure you have
    permissions regardless of this random suffix.  Note that the role also includes
    the `Decrypt` permission on the `secrets-key` KMS key, and you use the `!ImportValue`
    or `Fn::ImportValue` intrinsic function to import the ARN of the KMS key you exported
    back in the very first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `ApplicationTaskRole` resource in place, the following example demonstrates
    reconfiguring the `ApplicationTaskDefinition` and `MigrateTaskDefinition` resources
    in the `stack.yml` file located in the todobackend-aws repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ECS Task Definitions to use Secrets
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you configure each task definition to use an IAM task
    role via the `TaskRoleArn` property, which references the `ApplicationTaskRole`
    resource you created in the previous example. You next add the `SECRETS` environment
    variable that the new entrypoint script in your Docker image expects, and remove
    the previous `MYSQL_PASSWORD` and `SECRET_KEY` variables that are now retrieved
    from the AWS Secrets Manager service. Notice that you need to include an environment
    variable called `AWS_DEFAULT_REGION`, as this is required by the AWS CLI to determine
    which region you are located in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you are no longer injecting a database password into your stack as
    a parameter, you need to also update the `dev.cfg` file in the todobackend-aws
    repository, and also specify the updated Docker image tag that you published back
    in the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Updating input parameters
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `DatabasePassword=my-super-secret-password` line
    has been removed, and the value of the `ApplicationImageTag` parameter has been
    updated, referencing the commit hash that is tagged on your newly updated Docker
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing secrets to other resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have updated your ECS task definitions such that your application containers
    will now pull secrets from AWS Secrets Manager and inject them as environment
    variables. This works fine for your Docker images, as you have full control over
    how your images behave and can add features such as entrypoint scripts to inject
    secrets appropriately. For other resources that depend on these secrets, you don't
    have such a capability—for example, the `ApplicationDatabase` resource in your
    stack defines an RDS instance that as of the time of writing, does not include
    native support for AWS Secrets Manager.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to create a CloudFormation custom resource,
    whose job is to query the AWS Secrets Manager service and return the secret value
    associated with a given secret.  Because custom resources can have data properties
    attached to them, you can then reference these properties in other resources,
    providing a simple mechanism to inject your secrets into any CloudFormation resource
    that does not natively support AWS Secrets Manager. If you are wondering about
    the security of such an approach, the CloudFormation custom resource response
    specification ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html))
    includes a property called `NoEcho`, which instructs CloudFormation to not expose
    data properties via the console or in logging information.  By setting this property,
    you can therefore ensure you secrets are not inadvertently exposed by querying
    the CloudFormation API or by reviewing CloudFormation logs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Secrets Manager Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding a Lambda function resource to your
    CloudFormation stack that queries the AWS Secrets Manager service and returns
    a secret value given a target secret name and target key within the key/value
    pairs within the secret value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Secrets Manager CloudFormation Custom Resource Function
  prefs: []
  type: TYPE_NORMAL
- en: The configuring of the preceding example is very similar to the configuration
    you performed back in Chapter 8, when you created the `EcsTaskRunner` custom resource
    function.  Here, you create a `SecretsManager` Lambda function with an associated
    `SecretsManagerRole` IAM role that grants the ability to retrieve and decrypt
    secrets from AWS Secrets Manager in a similar fashion to the `ApplicationTaskRole`
    created earlier, along with a `SecretsManagerLogGroup` resource to collect logs
    from the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: The function code is simpler than the ECS task runner code, and expects a single
    property called `SecretId` to be passed to the custom resource, which specifies
    the ID or name of the secret. The function obtains the secret from the AWS Secrets
    Manager, and then loads the secret key/value pairs as a JSON object into a variable
    called `credentials` using the `json.loads` method.  The function then returns
    the `credentials` variable to CloudFormation, which means each credential can
    be access by other resources in your stack. Notice that you use a `with` statement
    to ensure the response data that is printed by the `cfnresponse.send` method is
    suppressed by setting the `sys.stdout` property to `/dev/null`, given the response
    data includes secret values that you don't want to expose in plaintext. This approach
    does require some care, and you need to restore the `sys.stdout` property to its
    default state (as represented by the `sys.__stdout__` property) at the beginning
    of the `handler` method, as your Lambda function runtime may be cached across
    multiple invocations.
  prefs: []
  type: TYPE_NORMAL
- en: The custom resource function code could be extended to also provision secrets
    into AWS Secrets Manager. For example, you could take as an input the KMS encrypted
    value of a intended secret value or even generate a random secret value, and then
    provision and expose this credential to other resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a secrets custom resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a Lambda function in place for your custom resource, you
    can create the actual custom resource that will provide access to secrets stored
    in AWS Secrets Manager. The following example demonstrates adding a custom resource
    for the **todobackend/credentials** secret that you created earlier in this chapter,
    which is then accessed from your `ApplicationDatabase` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Secrets Manager Custom Resource
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you create a custom resource called `Secrets` which
    references the `SecretsManager` function via the `ServiceToken` property, and
    then passes the name of the credential to retrieve via the `SecretId` property.
    The `MasterUserPassword` property on the existing `ApplicationDatabase` resource
    is then updated to reference the `MYSQL_PASSWORD` key that is accessible via the
    `Secrets` resource, which returns the correct password value stored in the **todobackend/credentials**
    secret.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying secrets to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you are ready to deploy your changes to your CloudFormation
    stack, which you can do using the `aws cloudformation deploy` command we have
    used throughout the past few chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Deploying CloudFormation stack changes
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment will affect a number of resources as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The resources supporting the custom resource will first be created, along with
    changes to the ECS task definitions being applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom resource called `Secrets` will be created, which once created will
    expose the key/value pairs of the **todobackend/credentials** secret to other
    CloudFormation resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ApplicationDatabase` resource will be updated, with the `MasterPassword`
    property updated based upon the value of the `MYSQL_PASSWORD` variable in the **todobackend/credentials**
    secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MigrateTask` custom resource will be updated given the changes to the associated `MigrateTaskDefinition`,
    and run a new task that uses the entrypoint script in the updated todobackend
    image to export each of the key/value pairs in the **todobackend/credentials**
    secret into the environment, which includes the `MYSQL_PASSWORD` variable required
    for accessing the application database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ApplicationService` resource will be updated given the changes to the associated `ApplicationTaskDefinition`,
    and similar to the `MigrateTask` each application instance will now inject the
    environment variables associated with the **todobackend/credentials** secret upon
    startup. The update will trigger your a rolling deployment of the `ApplicationService`,
    which will bring the new version of your application into service, and then drain
    and remove the old version of your application without causing any outages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming the deployment is successful, you should be able to verify your application
    is still working successfully, and that you can list, add and remove todo items.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also verify that your `SecretsManagerFunction` resource is not logging
    the plaintext values of your secrets—the following screenshot shows the log output
    from this function, and you can see does suppress logging of the success response
    that is sent back to CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25145a22-a7df-45d4-bf25-3c5f3a9aa41b.png)Viewing Log Output from
    the Secrets Manager Function'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets management is a challenge for the ephemeral nature of Docker applications,
    where the notion of preconfigured long-running servers with credentials stored
    in a configuration file is no longer an option, and injecting passwords directly
    as externally configured environment variables is considered a bad security practice.
    This requires a secrets management solution where your applications can dynamically
    fetch secrets from a secure credential store, and in this chapter you successfully
    implemented such a solution using the AWS Secrets Manager and KMS services.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to create a KMS key, which encrypts and decrypts confidential
    information, and is used by AWS Secrets Manager to ensure the privacy and confidentiality
    of secrets it stores. You next were introduced to the AWS Secrets Manager and
    learned how to create secrets using both the AWS console and AWS CLI. You learned
    how you can store multiple key/value pairs in your secrets, and were introduced
    to features such as deletion protection, where AWS Secrets Manager allows you
    to restore a previously deleted secret for up to 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: With a credential store in place for your sample application, you learned how
    you can use entrypoint scripts in your containers to dynamically fetch and inject
    secret values at container startup, using a simple bash script in conjunction
    with the AWS CLI to inject one or more secret values as variables into your internal
    container environment. Although this approach is considered less secure than your
    applications fetching secrets directly, it does have the advantage that it can
    be applied to any application that supports environment variables for configuration,
    making it a much more universal solution.
  prefs: []
  type: TYPE_NORMAL
- en: After publishing updated Docker images for your application, you updated your
    ECS task definitions to inject the names of the secrets each of your containers
    should retrieve, and then created a simple custom resource that is able to expose
    your secrets to other types of AWS resources that don't support AWS Secrets Manager
    natively, and don't have mechanisms such as container entrypoint scripts to retrieve
    secrets. You ensured this custom resource was configured such that it does not
    disclose your credentials via logs or other forms of operational events, and updated
    your application database resource to retrieve the database password for the application
    via this custom resource.
  prefs: []
  type: TYPE_NORMAL
- en: With a secrets management solution in place, you have addressed a core security
    concern from previous chapters, and in the next chapter, you will learn how you
    can address another security concern for your applications, which is to be able
    to independently isolate network access and apply network access rules on a per
    container or ECS task definition basis.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/False: The KMS service requires you to supply your own private key information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What feature of KMS allows you to specify a logical name for your key, rather
    than the UUID-based identifier of the key?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to avoid manually configuring the ARN of a KMS key that you use in
    multiple CloudFormation stacks.  Assuming you defined the KMS key in a separate
    CloudFormation stack, what CloudFormation feature can you use to solve this problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/False: When you delete a secret from AWS Secrets Manager you can never
    recover the secret.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tools would you typically use in an entrypoint script to retrieve a secret
    from AWS Secrets Manager and transform the key/value pairs in the secret to be
    suitable for exporting to the container environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You receive an error in a container entrypoint script indicating you do not
    have sufficient permissions to access a secret.  You check the IAM role and confirm
    it has a single permission `secretsmanager:GetSecretValue` allowed for the secret. 
    What other permission do you need to grant to resolve this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which CloudFormation custom resource property should you set when dealing with
    sensitive data that should not be exposed as plaintext values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You receive an error "You must configure a region" in a container entrypoint
    script that accesses AWS resources.  What environment variable should you add
    to your container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about what the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation KMS Key Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation KMS Alias Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-alias.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS KMS Developer Guide: [https://docs.aws.amazon.com/kms/latest/developerguide/overview.html](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI KMS Reference: [https://docs.aws.amazon.com/cli/latest/reference/kms/index.html](https://docs.aws.amazon.com/cli/latest/reference/kms/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Secrets Manager User Guide: [https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI Secrets Manager Reference: [https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html](https://docs.aws.amazon.com/cli/latest/reference/secretsmanager/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Python SDK Secrets Manager Reference: [http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html](http://boto3.readthedocs.io/en/latest/reference/services/secretsmanager.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Exports: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General Discussion on Docker Secrets Management: [https://github.com/moby/moby/issues/13490](https://github.com/moby/moby/issues/13490)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
