- en: Extension Functions and Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, most of the concepts were familiar to Java developers.
    In this chapter, we are introducing a feature that was not known in Java at all--extensions.
    It is one of the best Kotlin features, and lots of Kotlin developers are mentioning
    it as their favorite one. Extensions are making a big improvement in Android development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function type with receiver and function literal with receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin generic extension functions to any object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin domain-specific language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All bigger Java projects have utility classes, such as `StringUtils` , `ListUtils`
    , `AndroidUtils` , and so on. It is so popular because util functions capture
    common patterns and allow them to be tested and used in a simpler way. The problem
    was that Java really poorly supports the creation and usage of such functions,
    because they have to be implemented as static functions of some class. Let''s
    discuss this problem with an example. Every Java Android developer knows well
    the following code used to show `Toast` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is commonly used in Android projects for showing errors or short messages,
    and often it is presented at the beginning of most Android tutorials. Code that
    implements this functionality is verbose, because of how it is using a static
    function that is used like a builder. Probably every Java Android developer at
    least once has forgotten to invoke the `show` method on a returned object, which
    made him check all surrounding conditions to find out why this is not working.
    This all makes this simple functionality a perfect candidate to be packed as an
    util function. But it is really rarely used this way. Why? To understand it, let''s
    first look at how it could be implemented in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When a programmer wants to use the following function, they needs to remember
    that there is such function, in which class it is localized, and what its name
    is. Therefore, its usage is not simpler than previous. It is impossible to implement
    it as a method of `Context` (a superclass of `Activity` ) without changing the
    Android SDK implementation, but in Kotlin, it is possible to create an extension
    function, which acts similarly to an actual method defined inside a class. Here
    is how we can implement `toast` as an extension to `Context` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Context` is not on the argument list, but before the function name. This is
    how we define what type we are extending.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function body, we can use the this keyword to reference the object
    on which the extension function is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only difference in the general structure between an extension function
    and a standard function is that there is a receiver type specified before the
    function name. A less visible change is inside the body--there, we can access
    the receiver object (the object on which an extension is called) by the `this`
    keyword, or directly call its functions or properties. With such a definition,
    the `toast` function acts like a method defined in `Context` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes usage of the `toast` function much easier than implementation of
    the whole toast-displaying code. We also get suggestions from the IDE, that we
    can invoke this function when we are inside `Context` (like inside `Activity`
    ) or on an instance of `Context` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00044.jpg)![](img/Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, `Context` is a receiver type of the `toast` function,
    and the `this` instance is a reference to the receiver object. All functions and
    properties of the receiver object can be accessed explicitly, so we can take the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple use cases where extension functions are useful. Similar
    extension functions can be defined for `View` , `List` , `String` , and other
    classes defined in the Android framework or a third-party library and custom classes
    defined by the developer. Extension functions can be added to any accessible type,
    even to the `Any` object. Here is an extension function that can be called on
    every object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some call examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Supposing that we are invoking this in `MainActivity` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can simply add any method to any class we want. This is a great improvement
    for Android development. With it, we have a way to add missing methods or properties
    to types.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Kotlin extension functions might look magical, they are really simple
    under the hood. A top-level extension function is compiled to a static function
    with a receiver object on the first argument. Let''s look at the already presented
    `toast` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function, after compilation and decompilation to Java, would look similar
    to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin top-level extension functions are compiled to static functions with
    a receiver object on the first parameter. This is why we can still use extensions
    from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, this means that from a JVM bytecode perspective, the method is not really
    added, but during compilation all extension function usages are compiled to static
    function calls. While extension functions are just functions, function modifiers
    can be applied to them the same as they can be also applied to any other function.
    For example, an extension function can be marked as `inline` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with other `inline` functions, the function call will be replaced with an
    actual body during application compilation. We can do with extension functions
    practically everything we can do with other functions. They can be single expression,
    have default arguments, be used by named parameters, and so on. But there are
    also other, less intuitive consequences of such implementation. In the next sections,
    we are going to describe them.
  prefs: []
  type: TYPE_NORMAL
- en: No method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When there is a member function and an extension function with the same name
    and parameters, the member function always wins. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is always true. Even methods from a superclass win with extension functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The point is that the extension function is not allowing to modify the behavior
    of a real object. We can only add extra functionalities. This keeps us secured,
    because we know that no one will change the behavior of objects that we are using,
    which might lead to errors that are hard to track.
  prefs: []
  type: TYPE_NORMAL
- en: Access to receiver elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An extension function is compiled to a static function with a receiver object
    on the first parameter, so we have no extra access privilege. The `private` and
    `protected` elements are not accessible, and elements with Java `default` , Java
    `package` , or Kotlin `internal` modifiers are accessed the same as if we would
    just operate on standard object.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to that, these elements are protected as they should be. Remember that
    extension functions, while being really powerful and useful, are just syntactic
    sugar, and there is no magic there.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions are resolved statically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extension functions are just functions with a receiver as the first parameter,
    so their calls are resolved at compile time by the type on which the function
    is invoked. For example, when there are extension functions for both superclass
    and subclass, then the extension functions that will be chosen during invocation
    depend on the type of property on which we are operating. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we would expect `foo(B)` , while the object is, in fact, of type `B` ,
    but while extensions are resolved statically, it is using an extension function
    for `A` , because the variable is of type `A` and there is no information as to
    what object is there during compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This fact is sometimes problematic, because, when we define an extension function
    to the type we are most often cast to, then we should not implement extension
    functions to its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important limitation, and should be kept in mind, especially during
    public library implementation, because this way, some extension functions can
    block others and cause unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Companion object extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a class has a companion object defined, then you can also define extension
    functions (and properties) for this companion object. To distinguish between an
    extension to a class and an extension to a companion object, there needs to be
    `.Companion` added between the extension type and function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When it is defined, the `foo` method can be used as if it were defined inside
    the `A` companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are calling this extension using class type, not class instance.
    To allow the creation of an extension function for a companion object, there needs
    to be a companion object explicitly defined inside the class. Even an empty one.
    Without it, it is impossible to define an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Operator overloading using extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operator overloading is a big Kotlin feature, but often we need to use Java
    libraries and operators that are not defined there. For example, in RxJava, we
    use the `CompositeDisposable` function to manage subscriptions. This collection
    uses the `add` method to add new elements. This is an example subscription added
    to `CompositeDisposable` *:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard Kotlin way to add a new element to a mutable collection is by
    using the `plusAssign` operator (`+=` ). It is not only more universal, but also
    cleaner, while we can omit brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply it in our example, we can add the following extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can use the `plusAssign` method on `CompositeDisposable` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Where should top-level extension functions be used?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extension functions are most often used when we feel that a class defined by
    other programmers is missing some method. For example, if we think that `View`
    should contain `show` and `hide` methods, usage for which would be easier than
    visibility field setting, then we can just implement it ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to remember the names of classes that hold util functions.
    In the IDE, we just put a dot after the object, and we can search through all
    methods that are provided together with this object extension functions from the
    project and libraries. Invocation looks good, while it looks like an original
    object member. This is the beauty of extension functions, but it is also a danger.
    Right now, there are already tons of Kotlin libraries that are just packs of extension
    functions. When we use lots of extension functions, we can make our Android code
    unlike normal Android code. This has both pros and cons. Here are the pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Code is short and more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code presents more logic instead of Android boilerplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension functions are most often tested, or at least used in multiple places,
    so it is simpler to find out if they are working correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use extension functions, there is a smaller chance that we will make
    a stupid error that will lead to hours of code debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the last two points, we will go back to the `toast` function.
    It is hard to make an error in writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is much easier to make an error in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The biggest problem with strong extension usage in a project is that we are,
    in fact, making our own API. We are naming and implementing functions and we decide
    what arguments should be there. When some developer joins the team, he need to
    learn the entire API, we've created. The Android API has lots of shortcoming,
    but its strength is that it is universal and it is known to all Android developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this mean we should resign from extensions? Absolutely not! This is a
    great feature that is helping us to make code short and clean. The point is that
    we should use them in a smart way:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid multiple extensions that are doing the same thing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short and simple functionality often doesn't need to be an extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep one coding style around the project. Talk to your team and specify some
    standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when you are using public libraries with extensions. Keep them as
    the code that you cannot change and match your extensions to them to keep the
    API clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will first understand what extension properties are, and
    then we will move on to learn where these properties can be used. As we already
    know, properties in Kotlin are defined by their accessors (getter and setter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define also extension property. The only limitation is that this property
    can’t have backing field. The reason for this is that extension can’t store state,
    so there is no good place to store this field. Here is an example of extension
    property definition for `TextView` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As with extension functions, the above implementation will be compiled as an
    accessor function with a receiver on the first parameter. Here is the simplified
    result in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If it were a read-write property, then both setter and getter would be implemented.
    Remember that only properties that don''t need a Java field are allowed to be
    defined as an extension property. For example, this is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00047.jpg)![](img/Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where should extension properties be used?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extension properties can often be used interchangeably with extension functions.
    They are both most often used as top-level utils. Extension properties are used
    when we would like an object to have some property that was not developed natively.
    The decision as to whether we should use an extension function or an extension
    property is nearly the same as the decision as to whether we should use a function
    or property without a backing field inside a class. Just to remind you, according
    to conventions, one should prefer a property over a function when the underlying
    algorithm fulfills the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Does not throw errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has **O** (*1* ) complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is cheap to calculate (or caсhed on the first run)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns the same result over invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a simple problem. We often need to get some services in Android,
    but the code used to get them is complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a service such as `AlarmManager` or `LayoutInflater` , the programmer
    has to remember the following for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the function that is providing it (such as `getSystemService` )
    and what class contains it (such as `Context` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the field that is specifying this service (such as `Context.ALARM_SERVICE`
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the class that the service should be cast to (such as `AlarmManager`
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is complex, and this is the perfect place where we can optimize usage
    thanks to extension properties. We can define extension properties this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And from now on, we can use `preferences` , `inflater` , and `alarmManager`
    as if they are properties of `Context` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These are perfect examples of good read-only extension function usage. Let's
    focus on the `inflater` extension property. It is helping to get elements that
    are often needed, but hard to get without extensions. It is helpful, because the
    programmer just needs to remember that what they need is an inflater and that
    they need `Context` to have it, and he does not need to remember the name of method
    that is providing system services (`getSystemService` ), the name of the key used
    to get the `inflater` property (`ALARM_SERVICE` ), where it is located (in `Context`
    ), and what this service should be cast to (`AlarmManager` ). In other words,
    this extension is saving a lot of work and programmer memory. Also, it is correct
    according to guidelines, because the time of property getter execution is short
    and its complexity is **O** (*1* ), it is not throwing any errors, and it is always
    returning the same `inflater` (in fact, it might be a different instance, but
    from a programmer perspective, its usage is always the same, and this is what
    is important).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen read-only extension properties, but we have not seen read-write
    extension properties. Here is a good example, that is an alternative to the `hide`
    and `show` functions that we saw in the Extension functions section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the visibility of the view element using this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we define it, we can treat is as if it really were a `View` property.
    It is also important that what we are setting is consistent with what we are getting.
    So supposing that there is no other thread which is changing element visibility,
    we can set some property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the getter will always provide the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there is no other logic inside the getter and setter--only a change
    in specific properties. So other conventions we've presented before are satisfied
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Member extension functions and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen top-level extension functions and properties, but it is also possible
    to define them inside a class or object. Extensions defined there are called member
    extensions, and they are most often used for different kinds of problems than
    top-level extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from the simplest use case where member extensions are used. Let''s
    suppose that we need to drop every third element of a list of `String` . Here
    is the extension function that allows us to drop every i^(th) element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with that function is that it should not be extracted as a util
    extension, because of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not prepared for different types of lists (such as a list of `User` ,
    or `Int` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a rarely useful function, so probably it won't be used anywhere else in
    the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is why we would want to keep it as private, and it is a good idea to keep
    it inside the class where we are using it, as an member extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first reason we use member extension functions, to protect the
    accessibility of functions. In this case, it could be done by defining a function
    on the top level, in the same file, and with a private modifier. But member extension
    functions act differently to top-level functions. The function used in the preceding
    code is public, but it can only be called on `List<String>` and only in `UsersItemAdapter`
    . So it can be used only inside the `UsersItemAdapter` class and its subclasses
    or inside an extension function to `UsersItemAdapter` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that to use a member extension function, we need both the object in which
    it is implemented and the object on which this extension functions will be called.
    It is this way because we can use elements of both of these objects. This is important
    information about member extensions: they can use both elements from receiver
    type and from member type without a qualifier. Let''s see how it might be used.
    Here is another example, which is similar to the previous one, but it is using
    the private property `category` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the member extension function `fromSameCategory` , we are operating
    on an extension receiver (`List<User>` ), but we are also using the `category`
    property from `UsersItemAdapter` . We see here that a function defined this way
    needs to be a method and it can be used similarly to other methods. The advantage
    over the standard method is that we can call a function on `List` , so we can
    keep clean stream processing, instead of non-extension method usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common usage is the member extension functions or properties can be
    used like normal methods, but we are using the fact that inside member functions
    we can use receiver properties and methods without naming them, this way we can
    have shorter syntax, and that we are actually calling them on a receiver instead
    of calling them with the same type as an argument. As an example, we can take
    the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can replace it with the following member extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using member extension functions, we can achieve both a simpler call and a simpler
    function body. The biggest problem with this attempt is that it is not clear which
    functions we are using are members of `RecyclerView` , and which are members of
    the `Activity` and `RecyclerView` extensions. This problem will be raised in the
    next pages.
  prefs: []
  type: TYPE_NORMAL
- en: Type of receivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have a member extension function, then it becomes more complicated
    to administer which elements we are calling. Inside a member extension, we have
    implicit access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Member functions and properties, both from this class and superclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiver type functions and properties, both from the receiver type and its
    supertypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-level functions and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So inside the `setUp` extension function, we can use both member and receiver
    methods and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`setText` is the `Button` class method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the `Button` class and `MainActivity` class members alternately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might be tricky--probably most people wouldn't notice if there were an error
    and the `setText` call would be swapped with the `showText` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we can use inside member extension elements from different receivers,
    to allow distinction between them, all kinds of receivers were named. First of
    all, all objects that can be used by the `this` keyword are called **implicit
    receivers** . They''re members can be accessed without a qualifier. Inside `setUp`
    functions, there are two implicit receivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension receiver** : An instance of the class that the extension is defined
    for (`Button` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatch Receiver** : An instance of the class in which the extension is
    declared (`MainActivity` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that while members of both the extension receiver and dispatch receiver
    are implicit receivers in the same body, it is possible to have a situation where
    we use members that have the same signature in both of them. For example, if we
    change the previous class to show text in `textView` instead of showing it in
    the `toast` function, and change the method name to `setText` , then we are going
    to have methods of dispatch and extension receiver with the same signature (one
    defined in the `Button` class, the other defined in the `MainActivity` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`setText` is both the method of the dispatch receiver and the extension receiver.
    Which one will be called?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a result, the `setText` function will be invoked from the **extension receiver**
    , and as a result, a button click will change the text of the clicked button!
    This is because the extension receiver always takes precedence over the dispatch
    receiver. Still, it is possible to use a dispatch receiver in this situation by
    using qualified this syntax (the `this` keyword with label, that is, distinguishing
    which receiver we want to reference):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can solve the problem of distinguishing between the dispatch and
    extension receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Member extension functions and properties under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Member extension functions and properties are compiled the same way as top-level
    extension functions and properties with the only difference being that they are
    inside a class and they are not static. Here is a simple example of an extension
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it is compiled to (after simplification):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that while they are just methods with a receiver as the first parameter,
    we can do with them everything we can with other functions. Access modifiers are
    working the same way, and if we define the member extension function as open,
    then we can override it in its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Generic extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are writing utility functions, often we want them to be generic. The
    most common examples are extensions for collections: `List` , `Map` , and `Set`
    . Here is an example of an extension property for `List` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example defines an extension property for a generic type. This
    kind of extension is used for lots of different problems. As an example, starting
    another `Activity` is a repetitive task that most often needs to be implemented
    in multiple places in the project. The methods provided by the Android IDE for
    `Activity` starting do not make it easy. Here is the code used to start a new
    Activity called `SettingsActivity` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this simple and repetitive task needs a lot of code that is not really
    clear. But we can define extension functions that will make `Intent` creation
    and `Activity` without arguments start much more simply using a generic inline
    extension function with `reified` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start `Activity` by simply using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can create `intent` this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can make this common task easier at low cost. To go further, libraries
    such as **Anko** ( [https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)
    ) provide extension functions that provide a simple way to start an `Activity`
    with additional parameters or flags, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Internal implementation of the library is outside the scope of this book, but
    we can use this extension simply by adding Anko library dependency to our project.
    The point of this example is that nearly all repetitive code can be replaced with
    simpler code using extensions. There are also alternative ways to start an `Activity`
    , such as the `ActivityStarter` library ( [https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)
    ), which is based on parameter injection, and that strongly supports Kotlin. It
    allows classic argument injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as an alternative, it allows lazy injection in Kotlin property delegates
    (which are described in [Chapter 8](text00205.html) , *Delegates* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`Activity` with such arguments can be started using generated static functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example. In Android, we often need to store objects in JSON
    format. For example, when we need to send them to an API or to store them in a
    file. The most popular library used for serializing and deserializing objects
    into JSON is Gson. Let''s look at standard way of using the Gson library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve it in Kotlin thanks to extension functions with an `inline`
    modifier. Here is an example of extension functions that are using GSON to pack
    and unpack objects to `String` in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `globalGson` instance is a global instance of `Gson` . It is common practice,
    while we often define some serializers and deserializers, and it is a simpler
    and more effective way to define them and build an instance of `Gson` once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples are showing what possibilities are generic extension functions giving
    to the developer. They are like the next level of code extraction:'
  prefs: []
  type: TYPE_NORMAL
- en: They are top-level, but also invoked on an object, so they are simple to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are generic, so are universal and might be applied to anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When inline, they allow us to define `reified` type parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is why generic extension functions are commonly used in Kotlin. Also, standard
    library provides lots of generic extensions. In the next section, we will see
    some collection extension functions. This part is important, not only because
    it provides knowledge about generic extension function usage, but also because
    it is ultimately describing how list processing in Kotlin works and how it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Collection processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collection processing is one of the most common tasks in programming. This
    is why one of the first things that developers learn is how to iterate over a
    collection to operate on elements. Young developers asked to print all users from
    a list will most probably use a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we asked them to show only users that are passing in school, then they would
    most probably add an `if` condition inside this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still correct implementation, but the real problem starts when task
    becomes more complex. What if they were asked to print the three best students
    that are passing? It is really complex to implement it in loops, while it is trivial
    to implement it using Kotlin stream processing. Let''s see it on the example.
    Here is example list of students:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s filter out students using an imperative approach known from Java (using
    loops and sorting method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same result in a much simpler way using Kotlin stream processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Take only students who passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort students according to their grade (descending to have students with better
    grade in higher position).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take only first three of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key is that each stream processing function, such as `sortedByDescending`
    , `take` , and `forEach` from the preceding example, is extracting a small functionality
    and the power comes from the composition of them. And the result is much simpler
    and more readable then usage of classic loops.
  prefs: []
  type: TYPE_NORMAL
- en: Stream processing is actually a pretty common language feature. It is known
    in C#, JavaScript, Scala, and many other languages, including Java since version
    8\. Popular reactive programming libraries, such as RxJava, also heavily utilize
    this concept to process data. In this section, we are going to go deeper into
    Kotlin collection processing.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin collection type hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin type hierarchy is really well designed. Standard collections are actually
    collections from a native language (such as Java), which are hidden behind interfaces.
    Creation of them is made by standard top-level functions (`listOf` , `setOf` ,
    `mutableListOf` , and so on), so they can be created and used in common modules
    (modules compiled to more than one platform). Also Kotlin interfaces can act like
    their equivalent interfaces from Java (like `List` , `Set` , and so on), this
    makes Kotlin collections efficient and highly compatible with external libraries.
    At the same time, Kotlin collection interfaces hierarchy, can be used in common
    modules. This hierarchy is simple and it is profitable to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00049.gif)'
  prefs: []
  type: TYPE_IMG
- en: Kotlin collection interfaces hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'The most general interface is `Iterable` . It represents a sequence of elements
    that can be iterated over. Any object that implements `iterable` can be used in
    a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Lots of different types implement an iterable interface: all collections, progressions
    (`1..10` , `''a''..''z''` ), and even `String` . They all allow us to iterate
    over their elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `Collection` interface represents a collection of elements and extends `Iterable`
    . It adds property `size` and the methods `contains` , `containsAll` , and `isEmpty`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Two main interfaces that inherit from `Collection` are `List` and `Set` . The
    difference between them is that `Set` is unordered and does not contain repetitive
    elements (according to the `equals` method). Both `List` and `Set` interfaces
    do not contain any methods that would allow us to mutate the object state. This
    is why, by default, Kotlin collections are treated as immutable. When we have
    an instance of `List` , then it is most often `ArrayList` in Android. `ArrayList`
    is a mutable collection, but while it is hidden behind the interface `List` ,
    it is actually acting like immutable, because it is not exposing any methods that
    would allow us to apply changes (unless it is downcasted).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, collections were mutable, but Kotlin collection interfaces provide
    only immutable behavior by default (not methods that change the state of collections,
    for example, `add` and `removeAt` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'All immutable interfaces (`Collection` , `List` , and so on) have their mutable
    equivalents (`MutableCollection` , `MutableList` , and so on) which inherit from
    corresponding immutable interfaces. Mutable means that the actual object can be
    modified. These are the interfaces that represent mutable collections from standard
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MutableIterable` allows iteration with applying changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutableCollection` ensure methods for adding and removing elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutableList` and `MutableSet` are mutable equivalents of `List` and `Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can fix our previous example and change the collection using the `add`
    and `remove` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Both immutable and mutable interfaces provide only a few methods, but the Kotlin
    standard library provides many useful extensions for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This makes dealing with collections a much easier task than in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin implements collection processing methods using extensions. This approach
    has many advantages; for example, if we want to implement a custom collection
    (such as `List` ), we only need to implement an `iterable` interface containing
    only a few methods. We can still use all the extensions that are provided for
    the `iterable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason is how flexibly these functions can be used when they are extensions
    for interfaces. For example, most of these collection processing functions are
    actually extensions for `Iterable` , which is implemented by many more types than
    `Collection` , for example, by `String` or `Range` . Therefore, it is possible
    to use all extension functions to `Iterable` also on `IntRange` . Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This makes all this extensions really universal. There is also the downside
    of the fact that collection stream processing methods are implemented as extension
    functions. While extensions are resolved statically, it is incorrect to override
    an extension function for a specific type because its behavior will be different
    when it is behind an interface then when it is accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze some extension functions used for collection processing.
  prefs: []
  type: TYPE_NORMAL
- en: The map, filter, flatMap functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already briefly presented `map` , `filter` , and `flatMap` , because
    they are the most basic stream processing functions. The `map` function returns
    a list with elements changed according to the function from the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` function allows only the elements that match the provided predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flatMap` function returns a single list of all elements yielded by the
    transform function, which is invoked on each element of the original collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'It is most often used to flatten list of collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at simplified implementations of these extension functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All this functions are inline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these functions internally use for loop, and return a new list containing
    proper elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most Kotlin standard library extension functions with function type are `inline`
    , because it makes lambda expression usage efficient. As a result, whole collection
    stream processing is actually mostly compiled at runtime to nested loops. As an
    example, here is this simple processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'After compilation and decompilation to Java, it looks like the following (cleaned
    up):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The forEach and onEach functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `forEach` function was already discussed in chapter about functions. It
    is an alternative to a `for` loop, so it performs an action on each element of
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Kotlin 1.1, there is a similar function, `onEach` , that also invokes
    an action on each element. It returns an extension receiver (this list), so we
    can invoke an action on each element in the middle of stream processing. Common
    use cases are logging purposes. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The withIndex and indexed variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the way of element processing depends on its index on the list.
    The most universal way to solve this problem is by using the `withIndex` function,
    which returns a list of values with indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Function `withIndex` is packing each element into `IndexedValue` which is containing
    both the elements and its index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In lambda, `IndexedValue` is destructed into index and value, but while the
    value is unused, there is an underscore placed instead. It might be omitted, but
    this way of code is more readable. This line filters only elements with even index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, there are variants for different stream processing methods that provide
    an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The sum, count, min, max, and sorted functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sum` function counts the sum of all elements in a list. It can be invoked
    on `List<Int>` , `List<Long>` , `List<Short>` , `List<Double>` , `List<Float>`
    , and `List<Byte>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Often we need to sum some properties of elements, such as summing points of
    all users. It might be handled by mapping the list of users to the list of points
    and then counting the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'But we unnecessarily create an intermediate collection by calling the `map`
    function, and it would be more efficient to directly sum points. To do it, we
    can use `sumBy` with an appropriate selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`sumBy` is expecting `Int` to be returned from the selector, and it is returning
    `Int` with the sum of all elements. If values are not `Int` but `Double` then
    we can use `sumByDouble` , which returns `Double` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar functionality is provided by the `count` function, that is used when
    we need to count elements that match a predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count` function used without any predicate returns the size of the collection
    or iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The next important functions are `min` and `max` , which are functions that
    return the minimal and maximal elements in a list. They can be used on a list
    of elements that have natural ordering (implement `Comparable<T>` interface).
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the function `sorted` is used. It returns a sorted list, but it
    needs to be invoked on collections of elements that implement the `Comparable<T>`
    interface. Here is an example of how `sorted` can be used to get a list of strings
    sorted alphanumerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'What if items are not comparable? There are two ways to sort them. The first
    way is to sort according to comparable member. We''ve already seen an example
    when we were sorting students according to their grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we sort students using the comparable `grade` property.
    There, `sortedByDescending` is used, which works like `sortedBy` , with the only
    difference being that the order is descending (from biggest to smallest). The
    selector inside the function can return any value that is comparable to itself.
    Here is an example, where `String` is used to specify order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar functions can be used to find the minimal and maximal element according
    to the selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to specify sorting order is to define a `Comparator` that will
    determine how elements should be compared. Function variants that accept comparators
    should have a `With` suffix. Comparators can be defined by an adapter function
    that converts a lambda to SAM type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin also includes standard library top-level functions (`compareBy` , `compareByDescending`
    ) used to simplify `Comparator` creation. Here is how we can create a comparator
    to sort students alphanumerically by `surname` and `name` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can use property reference instead of lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important function is `groupBy` , which groups elements according to
    the selector. `groupBy` returns `Map` , that is mapping from the chosen key to
    a list of elements that are selected to map to the following key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a more complex example. We need to get a list of the best students
    from each class. Here is how we can get them from the list of students:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Other stream processing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of different stream processing functions and there is no need
    to describe them all here, while Kotlin contains great documentation on its website.
    The names of most of the extension functions are self-explanatory and there is
    no need to really read the documentation to guess what they are doing. In Android
    Studio, we can check the real implementation by pressing *Ctrl* (*command* key
    on mac) and clicking the function whose implementation we want to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important difference in collection processing comes when you are operating
    on mutable collections, because while they can use additional extensions defined
    for mutable types (`MutableIterable` , and `MutableCollection` ), the important
    distinction is that functions that are changing object are formulated in present
    imperative form (for example, `sort` ), while functions that are returning a new
    collection with changed values are most often formulated in the past form of a
    verb (for example, `sorted` ). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` : Function that is sorting a mutable object. It returns `Unit` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted` : Function that is returning a sorted collection. It is not changing
    the collection on which it is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Examples of stream collection processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a few stream processing functions, but it needs some skill
    and creativity to use them for complex use cases. This is why, in this part, we
    are going to discuss some complex stream processing examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that we again need to find the best three students who are passing
    according to their grade. The key difference is that, in this case, the final
    order of students must be the same as it was in the beginning. Note that during
    sorting by grade operation, this order is lost. But we can preserve it if we keep
    together value and index. Thanks to that, we can later sort elements according
    to this preserved index. Here is how to implement this processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Filter to keep only students that are passing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add index to elements to be able to reproduce element order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort students according to their grade
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take only best 10 students
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reproduce order by sorting according to indexes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mapping values with indexes to just values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this implementation is concise and each operation performed on the
    collection is easy to read line by line.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of collection stream processing is that it is easy to manage
    the complexity of this process. We know that the complexity of most operations,
    such as `map` or `filter` , is **O** (*n* ) and the complexity of sorting operations
    is **O** (*n*log(n)* ). The complexity of stream operations is maximal complexity
    of each of the steps, so the complexity of the above processing is **O** (*n*log(n)*
    ) because `sortedBy` is the step with the biggest complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next example, let''s suppose that we have a list containing the results
    of players in different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have some example data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we can find the best player in each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We group results into categories. The return type is `Map<Category>` , and `List<Result>`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are mapping values of the `map` function. Inside, we find the best result
    in this category and we are taking the player who is associated with this result.
    The return of the `mapValues` function is `Map<Category` , `Player?>` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding example shows how complex problems related to collections can
    be easily solved in Kotlin thanks to collection processing functions. After working
    with Kotlin for a while, most of those functions are well known to programmers,
    and then collection processing problems are quite easy to solve. Of course, functions
    as complicated as presented above are rare, but simple, few-step processing is
    quite common in everyday programming.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Sequence` is an interface that is also used to refer to a collection of elements.
    It is an alternative for `Iterable` . For `Sequence` , there are separate implementations
    of most collection processing functions (`map` , `flatMap` , `filter` , `sorted`
    , and so on). The key difference is that all these functions are constructed in
    such a way that, they return sequence, which is packaged over previous sequence.
    Due to this, the following points becomes true:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of sequence does not need to be known in advance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence processing is more efficient, especially for large collections where
    we want to perform several transformations (details will be described later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Android, sequences are used for processing very big collections or for processing
    elements whose size is not known in advance (such as for reading lines of possibly
    long document). There are different ways to create sequences, but the easiest
    is the `asSequence` function called on `Iterable` or by using the `sequenceOf`
    top-level function to make sequence similarly as list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequence size does not need to be known in advance, because values are calculated
    just when they are needed. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The function `generateSequence` is one way for sequence generation. This sequence
    contains the next numbers from 1 to infinity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `map` function packs a sequence into another that takes the value from the
    first sequence and then it calculates the value after transformation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function `take(10)` will also pack a sequence into another one that is finishing
    on the 10th element. Without this line execution, processing time would be infinitive
    while we are operating on an infinite sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the function `toList` is processing each value and it returns the final
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to stress that elements are processed one after another in
    the last step (in terminal operation). Let''s look at another example, where every
    operation is also printing values for logging purposes. Let''s start with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'What would be printed in the console? Absolutely nothing. No values were calculated.
    The reason is that all those intermediate operations are lazy. To retrieve a result,
    we need to use some terminal operation, such as `toList` . Let''s use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will see the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that elements are fully processed one after another. In standard list
    processing, the order of operation would be totally different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This explains why sequences are more efficient than classic collection processing--there
    is no need to create collections in intermediate steps. Values are processed one
    by one on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals with receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as functions have a function type, which allows them to be kept as an
    object, extension functions have their type that allows them to be kept this way.
    It is called function type with receiver. It looks like the simple function type,
    but the receiver type is located before arguments (like in extension definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The introduction of function type with receiver makes full cohesion between
    functions and types, because all functions can be now represented as objects.
    It can be defined using a lambda expression with receiver or by an anonymous function
    with receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a lambda expression with receiver definition, the only difference is that
    we can reference to receiver by `this` , and we can explicitly use receiver elements.
    For lambda expressions, the type must be specified in a parameter, because there
    is no syntax to specify receiver type. Here is `power` defined as a lambda expression
    with receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'An anonymous function also allows us to define the receiver, and its type is
    placed before the function name. In such a function, we can use `this` inside
    the body to refer to the extension receiver object. Note that anonymous extension
    functions are specifying the receiver type, so the property type can be inferred.
    Here is `power` defined as an anonymous extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'A function type with receiver can be used as if it is a method of receiver
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'A function type is most often used as a function parameter. Here is an example,
    where a parameter function is used to configure an element after its creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using a lambda expression as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the lambda expression, we can directly invoke receiver methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kotlin standard library functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kotlin stdlib provide a set of extension functions (`let` , `apply` , `also`
    , `with` , `run` , and `to` ) with generic non-restricted receiver (generic types
    have no restrictions). They are small and handy extensions, and it is very profitable
    to understand them, because they are very useful across all Kotlin projects. One
    of these functions, `let` , was briefly introduced in [Chapter 2](text00035.html)
    *, Laying a Foundation* , where we saw how it can be used as an alternative to
    a nullity check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'All that `let` does is it calls the specified function and returns its result.
    While in the above example it is used together with a safe call operator, it will
    be called only when the property `savedInstanceState` is not null. The `let` function
    is actually just a generic extension function with a parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In stdlib, there are more functions similar to `let` . These functions are
    `apply` , `also` , `with` , and `run` . They are a similar so we are going to
    describe them together. Here are definitions of the rest of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see usage examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Returned object / parameter function type** | **Function literal with receiver**(receiver
    object represented as *this* ) | **Function literal**(receiver object represented
    as *it* ) |'
  prefs: []
  type: TYPE_TB
- en: '| **Receiver object** | `apply` | `also` |'
  prefs: []
  type: TYPE_TB
- en: '| **Result of function literal** | `run` /`with` | `let` |'
  prefs: []
  type: TYPE_TB
- en: While those functions are similar and, in many cases, it is possible to use
    them interchangeably, there are conventions which define which functions are preferred
    for certain use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The let function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `let` function is preferred when we want to use standard functions as if
    they are extension functions in stream processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Like other extensions, it can be combined with a save call operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `let` function is also preferred when we just want to unpack a nullable
    read-write property. In this situation, it is not possible to smartcast this property
    and we need to shadow it, like in this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `name` variable is the shadowing property name, what is necessary if name
    is a read-write property, because smart cast is allowed only on a mutable or local
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace the preceding code with `let` usage and a safe call operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that using Elvis operator, we can easily add a `return` or exception throw
    when `name` is `null` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar way, `let` can be used as a replacement for the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation that is using the `let` function would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `let` function used this way is preferred in method chains that transform
    the receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use simpler syntax by passing a function reference as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Using the apply function for initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to create and initialize an object by calling some methods
    or modifying some properties, such as when we are creating a `Button` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reduce code verbosity by using the `apply` extension function. We can
    call all these methods from the context where `button` is the receiver object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The also function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `also` function is similar to `apply` *,* with the only difference being
    that the parameter function accepts an argument as an parameter rather than as
    an receiver. It is preferred when we want to do some operations on an object,
    which are not initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `also` function is also preferred when we need to do some operation in
    the middle of processing, for example, during object construction using the Builder
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Another situation where `also` is preferred is when we are already in an extension
    function and we don''t want to add another extension receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The run and with function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `run` and `with` functions that are both accepting lambda literal with
    receiver as an argument, and returning its result. The difference between them
    is that `run` is accepting a receiver, while the `with` function is not an extension
    function and it takes the object we are operating in as parameter. Both functions
    can be used as an alternative to the `apply` function, when we are setting up
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The difference between `apply` , `run` , and `with` is that `apply` is returning
    a receiver object, while `run` and `with` are returning the result of function
    literal. Although when we need any of these, we should choose the function that
    is returning it. It is debatable which should be used when we do not need any
    returned value. Most often, it is suggested to use the `run` or `with` function
    than, because `also` is more often used in the situations when returned value
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'About differences between the `run` and `with` functions: the `run` function
    is used instead of the `with` function, when a value is nullable, because then
    we can use a safe call or not-null assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with` function is preferred over run when an expression is short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `run` is preferred over `with` when an expression is long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The to function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Infix functions were introduced in [Chapter 4](text00088.html) , *Classes and
    Objects* , but they can be defined not only as member classes, but also as extension
    functions. It makes it possible to create an infix extension function to any object.
    One of these kinds of extension functions is `to` , which was briefly described
    in [Chapter 2](text00035.html) , *Laying a Foundation* . Now we have the knowledge
    needed to understand its implementation. This is how to is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it possible to place `to` between any two objects and make this
    way `Pair` with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the fact that we can make `infix` extension functions makes us allowed
    to define `infix` functions as an extension to any type. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Domain-specific language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Features such as lambda literal with receiver and member extension functions
    are making it possible to define type-safe builders, that are known from Groovy.
    The most well-known Android example is Gradle configuration, `build.gradle` *,*
    which is currently written in Groovy. These kinds of builders are a good alternative
    to XML, HTML, or configuration files. The advantage of Kotlin usage instead is
    that we can make such configurations fully type-safe and provide a better IDE.
    Such builders are one example of Kotlin **domain-specific language** (**DSL**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular Kotlin DSL pattern in Android is the implementation of optional
    callback classes. It is used to solve a problem with a lack of functional support
    to callback interfaces with multiple methods. Classically, implementation would
    require object-expression usage, like in following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The main problems with such implementation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement all methods present in interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function structure needs to be implemented for each method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to use object expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define the following class, that is keeping callbacks as mutable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks, which are used when any of the overridden functions is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions used to set new callbacks. Their names corresponds to handler function
    names, but they include callback as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each event handler functions are just invoking callback if it exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To simplify usage, we also changed types, `CharSequence` present in the original
    methods was changed to `String` *.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now all we need is an extension function that will simplify callback configuration.
    Its name cannot be the same as any name of `TextView,` but all we need to do is
    a small modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'With such definitions, we can define callbacks we need this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'We use underscore to hide unused parameters, to improve our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now two other callbacks `beforeTextChanged` and `afterTextChanged` are ignored,
    but we can still add other implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'A listener defined this way has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is shorter than object expression implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes default functions implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to hide unused parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While in Android SDK there are multiple listeners with more than one handler,
    DSL implementation of optional callback classes is really popular in Android projects.
    Similar implementations can be also found in libraries, such as the already-mentioned
    Anko.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is DSL, which will be used to define layout structure without
    using XML layout files. We will define a function to add and configure `LinearLayout`
    and `TextView` and use it to define a simple view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define our custom DSL from scratch. Let''s make a simple DSL that
    defines a list of articles. We know that each article should be defined in a different
    category, and that article has its name, URL, and tags. What we would like to
    achieve is the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest object here is the `Post` class. It is holding post properties
    and allows them to be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define a class that will hold the category. It needs to store
    a list of posts and it also needs to contain its name. There must be also a defined
    function that will allow simple post addition. This function needs to contain
    a function parameter in which `Post` is the receiver type. Here is the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need a class that will hold a list of categories and allow simple
    category definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need now is the `definePosts` function, whose definition might be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s all we need. Now we can define object structure by a simple, type-safe
    builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'DSL is a really powerful concept that is more and more used around the Kotlin
    community. It is already possible, thanks to libraries, to use Kotlin DSL to fully
    replace the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android layout files (Anko)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML files (`kotlinx.html` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON files (Kotson)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And lots of other configuration files. Let's look at some example library that
    is defining Kotlin DSL to provide type-safe builders.
  prefs: []
  type: TYPE_NORMAL
- en: Anko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anko is a library that provides a DSL to define Android views without any XML
    layouts. This is pretty similar to examples we''ve already seen, but Anko made
    it possible to fully remove XML layout files from a project. Here is an example
    view written in Anko DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to define much more complex layouts using Anko DSL. These
    views can be placed either on a custom class that serves as a view or even directly
    inside the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about this example, you can visit Anko Wiki at [https://github.com/Kotlin/anko/wiki/Anko-Layouts](https://github.com/Kotlin/anko/wiki/Anko-Layouts)
    .
  prefs: []
  type: TYPE_NORMAL
- en: It is still debatable if DSL layoutdefinition are going to replace XML definitions.
    At the time of writing, it is not so popular to define views this way, because
    of a lack of support from Google, but while Google announced that they are going
    to support Kotlin, so it is possible that this idea will become more popular and
    DSL-based layouts will be more supported and maybe even universal someday.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed Kotlin extension functions and properties, both
    defined top-level and as type member. We''ve seen how Kotlin standard library
    extension functions can be used to simplify collection processing and perform
    various operations. We have also described function type with receiver together
    with function literals with receiver. Also, we''ve seen a few important generic
    functions from standard library, which are using extensions: `let` , `apply` ,
    `also` , `with` , `run` , and `to` . Finally, we''ve seen how DSL can be defined
    in Kotlin, and where it is useful.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, there is going to be presented the next feature that was
    not present in the Java world while it is giving really big possibilities in Kotlin
    development--class and property delegates.
  prefs: []
  type: TYPE_NORMAL
