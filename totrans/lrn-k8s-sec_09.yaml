- en: '*Chapter 7*: Authentication, Authorization, and Admission Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization play a very vital role in securing applications.
    These two terms are often used interchangeably but are very different. Authentication
    validates the identity of a user. Once the identity is validated, authorization
    is used to check whether the user has the privileges to perform the desired action.
    Authentication uses something the user knows to verify their identity; in the
    simplest form, this is a username and password. Once the application verifies
    the user's identity, it checks what resources the user has access to. In most
    cases, this is a variation of an access control list. Access control lists for
    the user are compared with the request attributes to allow or deny an action.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how a request is processed by authentication,
    authorization modules, and admission controllers before it is processed by `kube-apiserver`.
    We'll walk through the details of different modules and admission controllers
    and highlight the recommended security configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We will finally look at **Open Policy Agent** (**OPA**), which is an open source
    tool that can be used to implement authorization across microservices. In Kubernetes,
    we will look at how it can be used as a validating admission controller. Many
    clusters require a more granular level of authorization than what is already provided
    by Kubernetes. With OPA, developers can define custom authorization policies that
    can be updated at runtime. There are several open source tools that leverage OPA,
    such as Istio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a workflow in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to OPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting a workflow in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, the `kube-apiserver` processes all requests to modify the state
    of the cluster. The `kube-apiserver` first verifies the origin of the request.
    It can use one or more authentication modules, including client certificates,
    passwords, or tokens. The request passes serially from one module to the other.
    If the request is not rejected by all the modules, it is tagged as an anonymous
    request. The API server can be configured to allow anonymous requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the origin of the request is verified, it passes through the authorization
    modules to check whether the origin of the request is permitted to perform the
    action. The authorization modules allow the request if a policy permits the user
    to perform the action. Kubernetes supports multiple authorization modules, such
    as **Attribute-Based Access Control** (**ABAC**), **Role-Based Access Control**
    (**RBAC**), and webhooks. Similar to authentication modules, a cluster can use
    multiple authorizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Requesting parsing before processing with the kube-apiserver'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_07_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Requesting parsing before processing with the kube-apiserver
  prefs: []
  type: TYPE_NORMAL
- en: 'After passing through the authorization and authentication modules, admission
    controllers modify or reject the requests. Admission controllers intercept requests
    that create, update, or delete an object in the admission controller. Admission
    controllers fall into two categories: mutating or validating. Mutating admission
    controllers run first; they modify the requests they admit. Validating admission
    controllers run next. These controllers cannot modify objects. If any of the admission
    controllers reject a request, an error is returned to the user and the request
    will not be processed by the API server.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All requests in Kubernetes originate from external users, service accounts,
    or Kubernetes components. If the origin of the request is unknown, it is treated
    as an anonymous request. Depending on the configuration of the components, anonymous
    requests can be allowed or dropped by the authentication modules. In v1.6+, anonymous
    access is allowed to support anonymous and unauthenticated users for the RBAC
    and ABAC authorization modes. It can be explicitly disabled by passing the `--anonymous-auth=false`
    flag to the API server configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes uses one or more of these authentication strategies. Let's discuss
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Client certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using X509 **Certificate Authority** (**CA**) certificates is the most common
    authentication strategy in Kubernetes. It can be enabled by passing `--client-ca-file=file_path`
    to the server. The file passed to the API server has a list of CAs, which creates
    and validates client certificates in the cluster. The `common name` property in
    the certificate is often used as the username for the request and the `organization`
    property is used to identify the user''s groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new certificate, the following steps need to be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a private key. A private key can be generated using `openssl`, `easyrsa`,
    or `cfssl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate a **Certificate Signing Request** (**CSR**). Using the private key
    and a config file similar to the following generates a CSR. This CSR is for the
    `test` user, which will be part of the `dev` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can generate a CSR using `openssl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign the CSR. Create a Kubernetes `CertificateSigningRequest` request using
    the following YAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The certificate-signing request generated earlier is used with the preceding
    YAML specification to generate a new Kubernetes certificate-signing request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this request is created, it needs to be approved by the cluster administrators
    to generate the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Export the CRT. The certificate can be exported using `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at static tokens, which are a popular mode of authentication
    in development and debugging environments but should not be used in production
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Static tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API server uses a static file to read the bearer tokens. This static file
    is passed to the API server using `--token-auth-file=<path>`. The token file is
    a comma-separated file consisting of `secret`, `user`, `uid`, `group1`, and `group2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The token is passed as an HTTP header in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The tokens persist indefinitely, and the API server needs to be restarted to
    update the tokens. This is *not* a recommended authentication strategy. These
    tokens can be easily compromised if the attacker is able to spawn a malicious
    pod in a cluster. Once compromised, the only way to generate a new token is to
    restart the API server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at basic authentication, a variation of static tokens that
    has been used as a method for authentication by web services for many years.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to static tokens, Kubernetes also supports basic authentication. This
    can be enabled by using `basic-auth-file=<path>`. The authentication credentials
    are stored in a CSV file as `password`, `user`, `uid`, `group1`, and `group2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The username and password are passed as an authentication header in the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similar to static tokens, basic authentication passwords cannot be changed without
    restarting the API server. Basic authentication should not be used in production
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bootstrap tokens are an improvisation over the static tokens. Bootstrap tokens
    are the default authentication method used in Kubernetes. They are dynamically
    managed and stored as secrets in `kube-system`. To enable bootstrap tokens, do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `--enable-bootstrap-token-auth` in the API server to enable the bootstrap
    token authenticator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable `tokencleaner` in the controller manager using the `controller` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to token authentication, bootstrap tokens are passed as an HTTP header
    in the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the token is the `TokenId` value and the second part of it
    is the `TokenSecret` value. `TokenController` ensures that expired tokens are
    deleted from the system secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Service account tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The service account authenticator is automatically enabled. It verifies signed
    bearer tokens. The signing key is specified using `--service-account-key-file`.
    If this value is unspecified, the Kube API server''s private key is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Service accounts are created by the `kube-apiserver` and are associated with
    the pods. This is similar to instance profiles in AWS. The default service account
    is associated with a pod if no service account is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a service account test, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The service account has associated secrets, which includes the CA of the API
    server and a signed token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enumerate the details, we can see the certificate and the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will talk about webhook tokens. Some enterprises have a remote authentication
    and authorization server, which is often used across all services. In Kubernetes,
    developers can use webhook tokens to leverage the remote services for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In webhook mode, Kubernetes makes a call to a REST API outside the cluster to
    determine the user's identity. Webhook mode for authentication can be enabled
    by passing `--authorization-webhook-config-file=<path>` to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a webhook configuration. In this, [authn.example.com/authenticate](http://authn.example.com/authenticate)
    is used as the authentication endpoint for the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at another way that a remote service can be used for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kube-apiserver` can be configured to identify users using the `X-Remote` request
    header. You can enable this method by adding the following arguments to the API
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each request has the following headers to identify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The API proxy validates the requests using the CA.
  prefs: []
  type: TYPE_NORMAL
- en: User impersonation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cluster administrators and developers can use user impersonation to debug authentication
    and authorization policies for new users. To use user impersonation, a user must
    be granted impersonation privileges. The API server uses impersonation the following
    headers to impersonate a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Impersonate-User`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Impersonate-Group`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Impersonate-Extra-*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the impersonation headers are received by the API server, the API server
    verifies whether the user is authenticated and has the impersonation privileges.
    If yes, the request is executed as the impersonated user. `kubectl` can use the
    `--as` and `--as-group` flags to impersonate a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once the authentication modules verify the identity of a user, they parse the
    request to check whether the user is allowed to access or modify the request.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization determines whether a request is allowed or denied. Once the origin
    of the request is identified, active authorization modules evaluate the attributes
    of the request against the authorization policies of the user to allow or deny
    a request. Each request passes through the authorization module sequentially and
    if any module provides a decision to allow or deny, it is automatically accepted
    or denied.
  prefs: []
  type: TYPE_NORMAL
- en: Request attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authorization modules parse a set of attributes in a request to determine whether
    the request should be parsed, allowed, or denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: The originator of the request. This is validated during authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: The group that the user belongs to. This is provided in the authentication
    layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API**: The destination of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request verb**: The type of request, which can be `GET`, `CREATE`, `PATCH`,
    `DELETE`, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource**: The ID or name of the resource being accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: The namespace of the resource being accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request path**: If the request is for a non-resource endpoint, the path is
    used to check whether the user is allowed to access the endpoint. This is true
    for the `api` and `healthz` endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at the different authorization modes that use these request
    attributes to determine whether the origin is allowed to initiate the request.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the different authorization modes available in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node authorization mode grants permissions to kubelets to access services, endpoints,
    nodes, pods, secrets, and persistent volumes for a node. The kubelet is identified
    as part of the `system:nodes` group with a username of `system:node:<name>` to
    be authorized by the node authorizer. This mode is enabled by default in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NodeRestriction` admission controller, which we''ll learn about later
    in this chapter, is used in conjunction with the node authorizer to ensure that
    the kubelet can only modify objects on the node that it is running. The API server
    uses the `--authorization-mode=Node` flag to use the node authorization module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Node authorization is used in conjunction with ABAC or RBAC, which we will look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With ABAC, requests are allowed by validating policies against the attributes
    of the request. ABAC authorization mode can be enabled by using `--authorization-policy-file=<path>`
    and `--authorization-mode=ABAC` with the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The policies include a JSON object per line. Each policy consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: The API version for the policy format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kind**: The `Policy` string is used for policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spec**: This includes the user, group, and resource properties, such as `apiGroup`,
    `namespace`, and `nonResourcePath` (such as `/version`, `/apis`, `readonly`) to
    allow requests that don''t modify the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example policy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This policy allows a kubelet to read any pods. ABAC is difficult to configure
    and maintain. It is not recommended that you use ABAC in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With RBAC, access to resources is regulated using roles assigned to users.
    RBAC is enabled by default in many clusters since v1.8\. To enable RBAC, start
    the API server with `--authorization-mode=RBAC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: RBAC uses Role, which is a set of permissions, and RoleBinding, which grants
    permissions to users. Role and RoleBinding are restricted to namespaces. If a
    role needs to span across namespaces, ClusterRole and ClusterRoleBinding can be
    used to grant permissions to users across namespace boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `Role` property that allows a user to create and modify
    pods in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding `RoleBinding` can be used with `Role` to grant permissions
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `RoleBinding` is applied, you can switch the context to see whether it
    worked correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you try to view the deployments, it will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Since roles and role bindings are restricted to the default namespace, accessing
    the pods in a different namespace will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will talk about webhooks, which provide enterprises with the ability
    to use remote servers for authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to webhook mode for authentication, webhook mode for authorization uses
    a remote API server to check user permissions. Webhook mode can be enabled by
    using `--authorization-webhook-config-file=<path>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a sample webhook configuration file that sets [https://authz.remote](https://authz.remote)
    as the remote authorization endpoint for the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once the request is passed by the authentication and authorization modules,
    admission controllers process the request. Let's discuss admission controllers
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Admission controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admission controllers are modules that intercept requests to the API server
    after the request is authenticated and authorized. The controllers validate and
    mutate the request before modifying the state of the objects in the cluster. A
    controller can be both mutating and validating. If any of the controllers reject
    the request, the request is dropped immediately and an error is returned to the
    user so that the request will not be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Admission controllers can be enabled by using the `--enable-admission-plugins`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Default admission controllers can be disabled using the `--disable-admission-plugins`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at some important admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysAdmit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This admission controller allows all the pods to exist in the cluster. This
    controller has been deprecated since 1.13 and should not be used in any cluster.
    With this controller, the cluster behaves as if no controllers exist in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysPullImages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This controller ensures that new pods always force image pull. This is helpful
    to ensure updated images are used by pods. It also ensures that private images
    can only be used by users who have the privileges to access them since users without
    access cannot pull images when a new pod is started. This controller should be
    enabled in your clusters.
  prefs: []
  type: TYPE_NORMAL
- en: EventRateLimit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Denial-of-service attacks are common in infrastructure. Misbehaving objects
    can also cause high consumption of resources, such as the CPU or network, resulting
    in increased cost or low availability. `EventRateLimit` is used to prevent these
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The limit is specified using a config file, which can be specified by adding
    a `--admission-control-config-file` flag to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cluster can have four types of limits: `Namespace`, `Server`, `User` and
    `SourceAndObject`. With each limit, the user can have a maximum limit for the
    **Queries Per Second** (**QPS**), the burst and cache size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This adds the `qps`, `burst`, and `cacheSize` limits to all API servers and
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk about LimitRanger, which prevents the overutilization of
    resources available in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This admission controller observes the incoming request and ensures that it
    does not violate any of the limits specified in the `LimitRange` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `LimitRange` object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With this limit range object, any pod requesting memory of more than 128 Mi
    will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When using LimitRanger, malicious pods cannot consume excess resources.
  prefs: []
  type: TYPE_NORMAL
- en: NodeRestriction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This admission controller restricts the pods and nodes that a kubelet can modify.
    With this admission controller, a kubelet gets a username in the `system:node:<name>`
    format and is only able to modify the node object and pods running on its own
    node.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeClaimResize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This admission controller adds validations for the `PersistentVolumeClaimResize`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: PodSecurityPolicy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This admission controller runs on the creation or modification of pods to determine
    whether the pods should be run based on the security-sensitive configuration of
    the pods. The set of conditions in the policy is checked against the workload
    configuration to verify whether the workload creation request should be allowed.
    A PodSecurityPolicy can check for fields such as `privileged`, `allowHostPaths`,
    `defaultAddCapabilities`, and so on. You'll learn more about PodSecurityPolicy
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SecurityContextDeny
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the recommended admission controller to use if PodSecurityPolicy is
    not enabled. It restricts the settings of security-sensitive fields, which can
    cause privilege escalation, such as running a privileged pod or adding Linux capabilities
    to a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that PodSecurityPolicy is enabled by default in a cluster.
    However, due to the administrative overhead, `SecurityContextDeny` can be used
    until PodSecurityPolicy is configured for the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ServiceAccount` is an identity of the pod. This admission controller implements
    `ServiceAccount`; it should be used if the cluster uses service accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: MutatingAdmissionWebhook and ValidatingAdmissionWebhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to webhook configurations for authentication and authorization, webhooks
    can be used as admission controllers. MutatingAdmissionWebhook modifies the workload's
    specifications. These hooks execute sequentially. ValidatingAdmissionWebhook parses
    the incoming request to verify whether it is correct. Validating hooks execute
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have looked at authentication, authorization, and admission control
    of resources in Kubernetes. Let's look at how developers can implement fine-grained
    access control in their clusters. In the next section, we talk about OPA, an open
    source tool that is used extensively in production clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OPA** is an open source policy engine that allows policy enforcement in Kubernetes.
    Several open source projects, such as Istio, utilize OPA to provide finer-grained
    controls. OPA is an incubating project hosted by **Cloud Native Computing Foundation**
    (**CNCF**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OPA is deployed as a service alongside your other services. To make authorization
    decisions, the microservice makes a call to OPA to decide whether the request
    should be allowed or denied. Authorization decisions are offloaded to OPA, but
    this enforcement needs to be implemented by the service itself. In Kubernetes
    environments, it is often used as a validating webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Open Policy Agent'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_07_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Open Policy Agent
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a policy decision, OPA needs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster information**: The state of the cluster. The objects and resources
    available in the cluster are important for OPA to make a decision about whether
    a request should be allowed or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input query**: The parameters of the request being parsed by the policy agent
    are analyzed by the agent to allow or deny the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policies**: The policy defines the logic that parses cluster information
    and input query to return the decision. Policies for OPA are defined in a custom
    language called Rego.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at an example of how OPA can be leveraged to deny the creation of
    pods with a `busybox` image. You can use the official OPA documentation ([https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/](https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/))
    to install OPA on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the policy that restricts the creation and updating of pods with the
    `busybox` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply this policy, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `configmap` is created, `kube-mgmt` loads these policies out of `configmap`
    in the `opa` container, both `kube-mgmt` and `opa` containers are in the `opa`
    pod. Now, if you try to create a pod with the `busybox` image, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This policy checks the request for the `busybox` image name and denies creation
    of pods with the `busybox` image with an `image not allowed` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the admission controller that we discussed previously, further finer-grained
    admission controllers can be created using OPA in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the importance of authentication and authorization
    in Kubernetes. We discussed the different modules available for authentication
    and authorization and discussed these modules in detail, as well as going through
    detailed examples of how each module is used. When looking at authentication,
    we discussed user impersonation, which can be used by cluster administrators or
    developers to test permissions. Next, we talked about admission controllers, which
    can be used to validate or mutate requests after authentication and authorization.
    We also discussed some admission controllers in detail. Finally, we looked at
    OPA, which can be used in Kubernetes clusters to perform a more fine-grained level
    of authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to devise appropriate authentication and authorization
    strategies for your cluster. You should be able to figure out which admission
    controllers work for your environment. In many cases, you'll need more granular
    controls for authorization, which can be provided by using OPA.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deep dive into securing pods. The chapter
    will cover some of the topics that we covered in this chapter in more detail,
    such as PodSecurityPolicy. Securing pods is essential to securing application
    deployment in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which authorization modules should not be used in a cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can cluster administrators test permissions granted to a new user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which authorization modes are recommended for production clusters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `EventRateLimit` and LimitRange admission
    controllers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you write a Rego policy to deny the creation of ingress with the `test.example`
    endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Admission controllers: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OPA: [https://www.openpolicyagent.org/docs/latest/](https://www.openpolicyagent.org/docs/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes RBAC: [https://rbac.dev/](https://rbac.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'audit2RBAC: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KubiScan: [https://github.com/cyberark/KubiScan](https://github.com/cyberark/KubiScan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
