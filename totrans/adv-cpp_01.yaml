- en: 1\. Anatomy of Portable C++ Software
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 可移植C++软件的解剖学
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Establish the code-build-test process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立代码构建测试流程
- en: Describe the various stages of compilation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述编译的各个阶段
- en: Decipher complicated C++ type systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密复杂的C++类型系统
- en: Configure projects with unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置具有单元测试的项目
- en: Convert source code to object code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码转换为目标代码
- en: Write readable code and debug it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可读的代码并调试它
- en: In this chapter, we will learn to establish the code-build-test model that will
    be used throughout the book, write beautiful code, and perform unit tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习建立贯穿全书使用的代码构建测试模型，编写优美的代码并进行单元测试。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: C++ is one of the oldest and most popular languages that you can use to write
    efficient code. It is both "close to the metal," like C, and has advanced object-oriented
    features, like Java. Being an efficient low-level language makes C++ the language
    of choice for domains in which efficiency is paramount, such as games, simulations,
    and embedded systems. At the same time, being an object-oriented language with
    advanced features such as generics, references, and countless others makes it
    suitable for large projects that are developed and maintained by multiple people.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++是最古老和最流行的语言之一，您可以使用它来编写高效的代码。它既像C一样“接近底层”，又具有高级的面向对象特性，就像Java一样。作为一种高效的低级语言，C++是效率至关重要的领域的首选语言，例如游戏、模拟和嵌入式系统。同时，作为一种具有高级特性的面向对象语言，例如泛型、引用和无数其他特性，使其适用于由多人开发和维护的大型项目。
- en: Almost any programming experience involves organizing your code base and using
    libraries written by others. C++ is no different. Unless your program is simple,
    you will distribute your code into multiple files that you need to organize, and
    you will use various libraries that fulfill tasks, usually in a much more efficient
    and robust way than your code would. C++ projects that do not use any third-party
    libraries are edge cases that do not represent the majority of projects, which
    use many libraries. These projects and their libraries are expected to work in
    different hardware architectures and operating systems. Therefore, it is important
    to spend time on project setup and understand the tools used to manage dependencies
    if you are going to develop anything meaningful with C++.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何编程经验都涉及组织您的代码库并使用他人编写的库。C++也不例外。除非您的程序很简单，否则您将把代码分发到多个文件中，并且需要组织这些文件，您将使用各种库来完成任务，通常比您的代码更有效和更可靠。不使用任何第三方库的C++项目是不代表大多数项目的边缘情况，大多数项目都使用许多库。这些项目及其库预期在不同的硬件架构和操作系统上工作。因此，如果您要使用C++开发任何有意义的东西，花时间进行项目设置并了解用于管理依赖关系的工具是很重要的。
- en: Most modern and popular high-level languages have standard tools to maintain
    projects, build them, and handle their library dependencies. Many of these have
    repositories that host libraries and tools that automatically download and use
    libraries from those repositories. For example, Python has `pip`, which takes
    care of downloading and using appropriate versions of libraries that the programmer
    wants to use. Similarly, JavaScript has `npm`, Java has `maven`, Dart has `pub`,
    and C# has `NuGet`. In most of these languages, you list the name of the library
    and the version that you would like to use, and the tool automatically downloads
    and uses the compatible version of the library. These languages benefit from the
    fact that the programs are built and run in a controlled environment in which
    a certain level of hardware and software requirements are satisfied. C++, on the
    other hand, is expected to work in a variety of contexts with different architectures,
    including very primitive hardware. Hence, C++ programmers are less pampered when
    it comes to building programs and performing dependency management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代和流行的高级语言都有标准工具来维护项目、构建项目并处理其库依赖关系。其中许多都有托管库和工具的存储库，可以自动下载并使用这些库。例如，Python有`pip`，它负责下载和使用程序员想要使用的库的适当版本。同样，JavaScript有`npm`，Java有`maven`，Dart有`pub`，C#有`NuGet`。在这些语言中，您列出要使用的库的名称和版本，工具会自动下载并使用兼容版本的库。这些语言受益于程序在受控环境中构建和运行，其中满足一定级别的硬件和软件要求。另一方面，C++预期在各种上下文中使用，具有不同的架构，包括非常原始的硬件。因此，当涉及构建程序和执行依赖管理时，C++程序员受到的关注较少。
- en: Managing C++ Projects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理C++项目
- en: In the world of C++, we have several tools that help in managing project sources
    and their dependencies. For example, `pkg-config`, `Autotools`, `make`, and `CMake`
    are the most notable ones in the community. Compared to the tools of the other
    high-level languages, these are much more complicated to use. `CMake` has arisen
    among these as the de facto standard for managing C++ projects and their dependencies.
    It is more opinionated compared to `make`, and it is accepted as the direct project
    format for most IDEs (Integrated Development Environments).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++世界中，我们有几种工具可帮助管理项目源代码及其依赖关系。例如，`pkg-config`、`Autotools`、`make`和`CMake`是社区中最值得注意的工具。与其他高级语言的工具相比，这些工具使用起来要复杂得多。`CMake`已成为管理C++项目及其依赖关系的事实标准。与`make`相比，它更具有主观性，并且被接受为大多数集成开发环境（IDE）的直接项目格式。
- en: While `CMake` helps with managing projects and their dependencies, the experience
    is still far from higher-level languages in which you list the libraries and their
    versions that you want to use and everything else is taken care of for you. With
    CMake, you still are responsible for installing libraries properly in your development
    environment, and you are expected to use compatible versions for each library.
    In popular Linux distributions with extensive package managers, you can easily
    install binary versions of most popular libraries. However, sometimes, you may
    have to compile and install the libraries yourself. This is a part of the whole
    C++ developer experience, which you will gather by learning more about the development
    platform of your choice. Here, we will focus more on how to properly set up our
    CMake projects, including understanding and resolving issues related to libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`CMake`有助于管理项目及其依赖关系，但体验仍远远不及高级语言，其中您列出要使用的库及其版本，其他一切都会为您处理。使用CMake，您仍需负责在开发环境中正确安装库，并且您需要使用每个库的兼容版本。在流行的Linux发行版中，有广泛的软件包管理器，您可以轻松安装大多数流行库的二进制版本。然而，有时您可能需要自行编译和安装库。这是C++开发者体验的一部分，您将通过学习更多关于您选择的开发平台的开发平台来了解。在这里，我们将更专注于如何正确设置我们的CMake项目，包括理解和解决与库相关的问题。
- en: The Code-Build-Test-Run Loop
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码构建测试运行循环
- en: In order to base our discussion on a solid foundation, we will immediately start
    with a practical example. We will start with a C++ code base template that you
    can use as a starting point for your own projects. We will see how we can build
    and compile it using CMake on the command line. We will also set up the Eclipse
    IDE for C/C++ developers and import our CMake project. The use of an IDE will
    provide us with facilities that ease the creation of source code and enable us
    to debug our programs line by line to view what exactly happens during the execution
    of our program and correct our mistakes in an informed fashion rather than trial
    and error and superstition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以坚实的基础展开讨论，我们将立即从一个实际示例开始。我们将从一个C++代码基础模板开始，您可以将其用作自己项目的起点。我们将看到如何使用CMake在命令行上构建和编译它。我们还将为C/C++开发人员设置Eclipse
    IDE，并导入我们的CMake项目。使用IDE将为我们提供便利设施，以便轻松创建源代码，并使我们能够逐行调试我们的程序，查看程序执行过程中到底发生了什么，并以明智的方式纠正错误，而不是靠试错和迷信。
- en: Building a CMake Project
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个CMake项目
- en: 'The de facto standard for C++ projects is to use CMake to organize and build
    the project. Here, we will use a basic template project as a starting point. The
    following is the folder structure of a sample template:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++项目的事实标准是使用CMake来组织和构建项目。在这里，我们将使用一个基本的模板项目作为起点。以下是一个示例模板的文件夹结构：
- en: '![Figure 1.1: Folder structure of a sample template'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：示例模板的文件夹结构'
- en: '](img/C14508_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_01.jpg)'
- en: 'Figure 1.1: Folder structure of a sample template'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：示例模板的文件夹结构
- en: In the preceding figure, the `git` version control system. Such ignored files
    include the outputs of the build process, which are created locally and should
    not be shared among computers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，`git`版本控制系统。这些被忽略的文件包括构建过程的输出，这些文件是在本地创建的，不应在计算机之间共享。
- en: The files in the `make` files for different platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不同平台的`make`文件中的文件。
- en: Building a project with CMake is a two-step process. First, we get CMake to
    generate platform-dependent configuration files for a native build system that
    will compile and build the project. Then, we will use the generated files to build
    the project. The platform-dependent build systems that CMake can generate configuration
    files for include `UNIX` `Makefiles`, `Ninja` `build files`, `NMake` `Makefiles`,
    and `MinGW` `Makefiles`. The choice here depends on the platform in use, the availability
    of these tools, and personal preference. `UNIX` `Makefiles` are a de facto standard
    for `Unix` and `Linux`, whereas `NMake` is its `Windows` and `Visual Studio` counterpart.
    `MinGW`, on the other hand, is a `Unix`-like environment in `Windows` in which
    `Makefiles` are also in use. `Ninja` is a modern build system that provides exceptional
    speed compared to other build systems coupled with multi-platform support, which
    we choose to use here. Furthermore, in addition to these command-line build systems,
    we can also generate IDE projects for `Visual Studio`, `XCode`, `Eclipse CDT`,
    and many others, and build our projects inside the IDE. Therefore, `CMake` is
    a meta tool that will create the configuration files for another system that will
    actually build the project. In the next section, we will solve an exercise, wherein
    we will generate `Ninja` `build files` using `CMake`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CMake构建项目是一个两步过程。首先，我们让CMake生成平台相关的配置文件，用于本地构建系统编译和构建项目。然后，我们将使用生成的文件来构建项目。CMake可以为平台生成配置文件的构建系统包括`UNIX`
    `Makefiles`、`Ninja` `build files`、`NMake` `Makefiles`和`MinGW` `Makefiles`。选择取决于所使用的平台、这些工具的可用性和个人偏好。`UNIX`
    `Makefiles`是`Unix`和`Linux`的事实标准，而`NMake`是其`Windows`和`Visual Studio`的对应物。另一方面，`MinGW`是`Windows`中的`Unix`-like环境，也在使用`Makefiles`。`Ninja`是一个现代的构建系统，与其他构建系统相比速度异常快，同时支持多平台，我们选择在这里使用。此外，除了这些命令行构建系统，我们还可以为`Visual
    Studio`、`XCode`、`Eclipse CDT`等生成IDE项目，并在IDE中构建我们的项目。因此，`CMake`是一个元工具，将为另一个实际构建项目的系统创建配置文件。在下一节中，我们将解决一个练习，其中我们将使用`CMake`生成`Ninja`
    `build files`。
- en: 'Exercise 1: Using CMake to Generate Ninja Build Files'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：使用CMake生成Ninja构建文件
- en: In this exercise, we will use `CMake` to generate `Ninja build files`, which
    are used to build C++ projects. We will first download our source code from a
    `git` repository and will use CMake and Ninja to build it. The aim of this exercise
    is to use CMake to generate Ninja build files, build the project, and then run
    them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`CMake`生成`Ninja build files`，用于构建C++项目。我们将首先从`git`存储库下载我们的源代码，然后使用CMake和Ninja来构建它。这个练习的目的是使用CMake生成Ninja构建文件，构建项目，然后运行它们。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The link to the GitHub repository can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal window, type the following command to download the `CxxTemplate`
    repository from GitHub onto your local system:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the previous command is similar to the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Checking out the sample project from GitHub'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Checking out the sample project from GitHub'
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now you have the source code in the `CxxTemplate` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate into the `CxxTemplate` folder by typing the following command in the
    terminal:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you can list all the files in the project by typing the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generate our Ninja build file using the `cmake` command in the `CxxTemplate`
    folder. To do that, write the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Generating the Ninja build file'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Generating the Ninja build file'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's explain parts of the preceding command. With `-Bbuild`, we are telling
    CMake to use the `build` folder to generate build artifacts. Since this folder
    does not exist, CMake will create it. With `–H.`, we are telling CMake to use
    the current folder as the source. By using a separate `build` folder, we will
    keep our source files clean and all the build artifacts will live in the `build`
    folder, which is ignored by Git thanks to our `.gitignore` file. With `–GNinja`,
    we are telling CMake to use the Ninja build system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to list the project files and to check the files
    that were created inside the `build` folder:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will show the following output in the terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Files in the build folder'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: Files in the build folder'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It's clear that the preceding files will be present inside the build folder.
    **build.ninja** and **rules.ninja** in the preceding output are the Ninja build
    files that can actually build our project in this platform.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using CMake, we did not have to write the Ninja build files and avoided committing
    to the Unix platform. Instead, we have a meta-build system that can generate low-level
    build files for other platforms such as UNIX/Linux, MinGW, and Nmake.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go into the `build` folder and build our project by typing the following
    commands in the terminal:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see a final output like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Building with ninja'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: Building with ninja'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type `ls` in the `CxxTemplate` executable or not:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous command yields the following output in the terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Files in the build folder after running ninja'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.6: Files in the build folder after running ninja'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding figure, you can see that the `CxxTemplate` executable is generated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, type the following command to run the `CxxTemplate` executable:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command in the terminal will provide the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14508_01_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Running the executable'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following line from the `src/CxxTemplate.cpp` file is responsible for writing
    the previous output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you have successfully built a CMake project in Linux. Ninja and CMake work
    quite well together. You have to run CMake only once and Ninja will detect whether
    CMake should be called again and will call it for you. For example, even if you
    add new source files to your `CMakeLists.txt` file, you only need to type the
    `ninja` command in the terminal, and it will run CMake automatically for you to
    update the Ninja build files. Now that you have learned about building a CMake
    project in Linux, in the next section, we will look at how to import a CMake project
    into Eclipse CDT.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Importing a CMake Project into Eclipse CDT
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Ninja build file is useful for building our project in Linux. However, a CMake
    project is portable and can be used with other build systems and IDEs as well.
    Many IDEs accept CMake as their configuration file and provide a seamless experience
    as you modify and build your project. In this section, we will discuss how to
    import a CMake project into Eclipse CDT, which is a popular cross-platform C/C++
    IDE.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ninja构建文件对于在Linux中构建我们的项目非常有用。但是，CMake项目是可移植的，并且也可以与其他构建系统和IDE一起使用。许多IDE接受CMake作为其配置文件，并在您修改和构建项目时提供无缝体验。在本节中，我们将讨论如何将CMake项目导入Eclipse
    CDT，这是一款流行的跨平台C/C++ IDE。
- en: There are multiple ways of using Eclipse CDT with CMake. The default one that
    CMake provides is the one-way generation of the IDE project. Here, you create
    the IDE project once, and any modifications you make to your IDE project will
    not change back the original CMake project. This is useful if you manage your
    project as a CMake project and do one-time builds with Eclipse CDT. However, it's
    not ideal if you want to do your development in Eclipse CDT.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse CDT与CMake有多种方法。CMake提供的默认方法是单向生成IDE项目。在这里，您只需创建一次IDE项目，对IDE项目进行的任何修改都不会改变原始的CMake项目。如果您将项目作为CMake项目进行管理，并且只在Eclipse
    CDT中进行一次性构建，则这很有用。但是，如果您想在Eclipse CDT中进行开发，则不是理想的方法。
- en: Another way of using CMake with Eclipse CDT is to use the custom `cmake4eclipse`
    plugin. When using this plugin, you do not abandon your `CMakeLists.txt` file
    and make a one-way switch to Eclipse CDT's own project manager. Instead, you keep
    managing your project through the `CMakeLists.txt` file, which continues to be
    the main configuration file of your project. Eclipse CDT actively works with your
    `CMakeLists.txt` file to build your project. You can add or remove source files
    and make other changes in your `CMakeLists.txt`, and the `cmake4eclipse` plugin
    applies those changes to the Eclipse CDT project at every build. You will have
    a nice IDE experience while keeping your CMake project current. The benefit of
    this approach is that you can always quit using Eclipse CDT and use your `CMakeLists.txt`
    file to switch to another build system (such as Ninja) later. We will use this
    second approach in the following exercise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse CDT与CMake的另一种方法是使用自定义的`cmake4eclipse`插件。使用此插件时，您不会放弃您的`CMakeLists.txt`文件并单向切换到Eclipse
    CDT的项目管理器。相反，您将继续通过`CMakeLists.txt`文件管理项目，该文件将继续是项目的主要配置文件。Eclipse CDT会积极与您的`CMakeLists.txt`文件合作构建项目。您可以在`CMakeLists.txt`中添加或删除源文件并进行其他更改，`cmake4eclipse`插件会在每次构建时将这些更改应用于Eclipse
    CDT项目。您将拥有良好的IDE体验，同时保持您的CMake项目处于最新状态。这种方法的好处是您始终可以停止使用Eclipse CDT，并使用您的`CMakeLists.txt`文件切换到另一个构建系统（如Ninja）。我们将在以下练习中使用这种第二种方法。
- en: 'Exercise 2: Importing the CMake File into Eclipse CDT'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：将CMake文件导入Eclipse CDT
- en: 'In the last exercise, you developed a CMake project and you would like to start
    using Eclipse CDT IDE to edit and build that project. In this exercise, we will
    import our CMake project into the Eclipse CDT IDE using the `cmake4eclipse` plugin.
    Perform the following steps to complete the exercise:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您开发了一个CMake项目，并希望开始使用Eclipse CDT IDE来编辑和构建该项目。在本练习中，我们将使用`cmake4eclipse`插件将我们的CMake项目导入Eclipse
    CDT IDE。执行以下步骤完成练习：
- en: Open Eclipse CDT.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT。
- en: 'Create a new C++ project in the location of our current project (the folder
    that contains the `CMakeLists.txt` file and the **src** folder). Go to **File**
    | **New** | **Project**. A **New Project** dialog box appears like the one in
    the following screenshot:![Figure 1.8: New Project dialog box'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目的位置（包含`CMakeLists.txt`文件和**src**文件夹的文件夹）中创建一个新的C++项目。转到**文件** | **新建**
    | **项目**。将出现一个类似以下截图的**新建项目**对话框：![图1.8：新建项目对话框
- en: '](img/C14508_01_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_08.jpg)'
- en: 'Figure 1.8: New Project dialog box'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.8：新建项目对话框
- en: 'Select the **C++ Project** option and click on the **Next** button. A **C++
    Project** dialog box appears like the one in the following screenshot:![Figure
    1.9: C++ Project dialog box'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**C++项目**选项，然后点击**下一步**按钮。将出现一个类似以下截图的**C++项目**对话框：![图1.9：C++项目对话框
- en: '](img/C14508_01_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_09.jpg)'
- en: 'Figure 1.9: C++ Project dialog box'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：C++项目对话框
- en: Accept everything, including switching to the C/C++ perspective, and click **Finish**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一切，包括切换到C/C++视角，然后点击**完成**。
- en: 'Click on the **Restore** button at the top-left corner to view the newly created
    project:![Figure 1.10: The Restore button'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的**还原**按钮查看新创建的项目：![图1.10：还原按钮
- en: '](img/C14508_01_10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_10.jpg)'
- en: 'Figure 1.10: The Restore button'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.10：还原按钮
- en: 'Click on the **CxxTemplate** project. Go to **Project** | **Properties**, then
    select **Tool Chain Editor** under **C/C++ Build** from the left pane and set
    **Current builder** to **CMake Builder (portable)**. Then, click on the **Apply
    and Close** button:![Figure 1.11: Project properties'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**CxxTemplate**项目。转到**项目** | **属性**，然后在左侧窗格下选择**C/C++构建**下的**工具链编辑器**，将**当前构建器**设置为**CMake
    Builder (portable)**。然后，点击**应用并关闭**按钮：![图1.11：项目属性
- en: '](img/C14508_01_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_11.jpg)'
- en: 'Figure 1.11: Project properties'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.11：项目属性
- en: 'Then, choose the **Project** | **Build All** menu item to build the project:![Figure
    1.12: Building the project'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**项目** | **构建全部**菜单项来构建项目：![图1.12：构建项目
- en: '](img/C14508_01_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_12.jpg)'
- en: 'Figure 1.12: Building the project'
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.12：构建项目
- en: 'In the following `make all` that actually builds our project:![Figure 1.13:
    The build output'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的`make all`中实际构建我们的项目：![图1.13：构建输出
- en: '](img/C14508_01_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_13.jpg)'
- en: 'Figure 1.13: The build output'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.13：构建输出
- en: 'If you did not get any errors in the previous steps, you can run the project
    using the menu item **Run** | **Run**. If you are given some options, choose **Local
    C/C++ Application** and **CxxTemplate** as the executable:![Figure 1.14: Running
    a project'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在之前的步骤中没有出现任何错误，您可以使用菜单项**运行** | **运行**来运行项目。如果给出了一些选项，请选择**本地C/C++应用程序**和**CxxTemplate**作为可执行文件：![图1.14：运行项目
- en: '](img/C14508_01_14.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_14.jpg)'
- en: 'Figure 1.14: Running a project'
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.14：运行项目
- en: 'When it runs, you will see the output of the program in the **Console** pane
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.15: Output of the project'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_15.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: Output of the project'
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built and run a CMake project using Eclipse CDT. In the
    next exercise, we will introduce a frequent change to our projects by adding new
    source files with new classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Adding New Source Files to CMake and Eclipse CDT'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop significantly bigger C++ projects, you will tend to add new
    source files to it as the project grows to meet the set expectations. In this
    exercise, we will add a new `.cpp` and `.h` file pair to our project and see how
    CMake and Eclipse CDT work together with these changes. We will add these files
    inside the project using the new class wizard, but you can also create them with
    any other text editor. Perform the following steps to add new source files to
    CMake and Eclipse CDT:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the project that we have been using until now. In the **Project
    Explorer** pane on the left, expand the root entry, **CxxTemplate**, and you will
    see the files and folders of our project. Right-click the **src** folder and select
    **New** | **Class** from the pop-up menu:![Figure 1.16: Creating a new class'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_16.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Creating a new class'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the dialog box that opened, type **ANewClass** for the class name. When you
    click on the **Finish** button, you will see the **ANewClass.cpp** and **ANewClass.h**
    files generated under the **src** folder.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s write some code into the `ANewClass` class and access it from the
    `ANewClass.cpp` and change the beginning of the file to match the following, and
    then save the file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will see that Eclipse warns us with a `ANewClass.h` file as well. Such warnings
    are made possible by analyzers in IDEs and are quite useful as they help you fix
    your code as you are typing, without running the compiler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ANewClass.h` file, add the following code, and save the file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see that the error in the `.cpp` file went away. If it did not go
    away, it may be because you may have forgotten to save one of the files. You should
    make it a habit to press *Ctrl + S* to save the current file, or *Shift + Ctrl
    + S* to save all the files that you edited.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this class from our other class, `CxxTemplate.cpp`. Open that
    file, perform the following modifications, and save the file. Here, we are first
    importing header files and in the constructor of `CxxApplication`, we are printing
    text to the console. Then, we are creating a new instance of `ANewClass` and calling
    its `run` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The complete code of this file can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to build the project by clicking on the `CMakeLists.txt` file, make the
    following modification, and save the file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try to build the project again. This time you should not see any errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project using the **Run** | **Run** menu option. You should see the
    following output in the terminal:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18: Program output'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_18.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.18: Program output'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You modified a CMake project, added new files to it, and ran it fine. Note that
    we created the files in the `src` folder and let the `CMakeLists.txt` file know
    about the CPP file. If you do not use Eclipse, you can simply continue with the
    usual CMake build commands and your program will run successfully. So far, we
    have checked out the sample code from GitHub and built it both with plain CMake
    and with the Eclipse IDE. We also added a new class to the CMake project and rebuilt
    it in Eclipse IDE. Now you know how to build and modify CMake projects. In the
    next section, we will perform an activity of adding a new source-header file pair
    to the project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Adding a New Source-Header File Pair to the Project'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop C++ projects, you add new source files to it as the project
    grows. You may want to add new source files for various reasons. For example,
    let''s say you are developing an accounting application in which you calculate
    interest rates in many places of your project, and you want to create a function
    in a separate file so that you can reuse it throughout your project. To keep things
    simple, here we will create a simple summation function instead. In this activity,
    we will add a new source-header file pair to the project. Perform the following
    steps to complete the activity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发C++项目时，随着项目的增长，您会向其中添加新的源文件。您可能出于各种原因想要添加新的源文件。例如，假设您正在开发一个会计应用程序，在其中需要在多个地方计算利率，并且您希望创建一个单独的文件中的函数，以便在整个项目中重用它。为了保持简单，在这里我们将创建一个简单的求和函数。在这个活动中，我们将向项目添加一个新的源文件和头文件对。执行以下步骤完成该活动：
- en: Open the project that we created in the earlier exercise in the Eclipse IDE.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse IDE中打开我们在之前练习中创建的项目。
- en: Add the `SumFunc.cpp` and `SumFunc.h` file pair to the project.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SumFunc.cpp`和`SumFunc.h`文件对添加到项目中。
- en: Create a simple function named `sum` that returns the sum of two integers.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sum`的简单函数，它返回两个整数的和。
- en: Call the function from the `CxxTemplate` class constructor.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CxxTemplate`类构造函数中调用该函数。
- en: Build and run the project in Eclipse.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中构建并运行项目。
- en: 'The expected output should be similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出应该类似于以下内容：
- en: '![Figure 1.19: Final output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.19：最终输出'
- en: '](img/C14508_01_19.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_19.jpg)'
- en: 'Figure 1.19: Final output'
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.19：最终输出
- en: Note
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 620.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第620页找到。
- en: In the following section, we will talk about how to write unit tests for our
    projects. It is common to divide projects into many classes and functions that
    work together to achieve the desired goal. You must manage the behavior of these
    classes and functions with unit tests to ensure that they behave in expected ways.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论如何为我们的项目编写单元测试。将项目分成许多类和函数，并让它们一起工作以实现期望的目标是很常见的。您必须使用单元测试来管理这些类和函数的行为，以确保它们以预期的方式运行。
- en: Unit Testing
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are an important part of programming in general. Basically, unit
    tests are little programs that use our classes in various scenarios with expected
    results, live in a parallel file hierarchy in our project, and do not end up in
    the actual executable but are executed separately by us during development to
    ensure that our code is behaving in expected ways. We should write unit tests
    for our C++ programs to ensure that they behave as they are supposed to after
    each change.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在编程中是一个重要的部分。基本上，单元测试是使用我们的类在各种场景下进行测试的小程序，预期结果是在我们的项目中的一个并行文件层次结构中，不会最终出现在实际的可执行文件中，而是在开发过程中由我们单独执行，以确保我们的代码以预期的方式运行。我们应该为我们的C++程序编写单元测试，以确保它们在每次更改后都能按照预期的方式运行。
- en: Preparing for the Unit Tests
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为单元测试做准备
- en: There are several C++ test frameworks that we can use with CMake. We will use
    **Google Test**, which has several benefits over other options. In the next exercise,
    we will prepare our project for unit testing with Google Test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个C++测试框架可以与CMake一起使用。我们将使用**Google Test**，它比其他选项有几个优点。在下一个练习中，我们将准备我们的项目以便使用Google
    Test进行单元测试。
- en: 'Exercise 4: Preparing Our Project for Unit Testing'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：为单元测试准备我们的项目
- en: 'We have installed Google Test but our project is not set up to use Google Test
    for unit testing. In addition to the installation, there are settings that need
    to be carried out in our CMake project to have Google Test unit tests. Follow
    these steps to implement this exercise:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了Google Test，但我们的项目还没有设置好以使用Google Test进行单元测试。除了安装之外，在我们的CMake项目中还需要进行一些设置才能进行Google
    Test单元测试。按照以下步骤执行此练习：
- en: Open Eclipse CDT and select the CxxTemplate project that we have been using.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT，并选择我们一直在使用的CxxTemplate项目。
- en: Create a new folder named **tests** as we will perform all our tests there.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**tests**的新文件夹，因为我们将在那里执行所有的测试。
- en: 'Edit our base `CMakeLists.txt` file to allow tests in the `GTest` package that
    brings `GoogleTest` capability to CMake. We will add our new lines just after
    that:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑我们的基本`CMakeLists.txt`文件，以允许在`GTest`包中进行测试，该包为CMake带来了`GoogleTest`功能。我们将在此之后添加我们的新行：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is all we need to add to our main `CMakeLists.txt` file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要添加到我们主要的`CMakeLists.txt`文件中的所有内容。
- en: Create another `CMakeLists.txt` file inside our `add_subdirectory(tests)` line
    that we had in our main `CMakeLists.txt` file. This `tests/CMakeLists.txt` file
    will manage the test sources.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们主要的`CMakeLists.txt`文件中的`add_subdirectory(tests)`行内创建另一个`CMakeLists.txt`文件。这个`tests/CMakeLists.txt`文件将管理测试源代码。
- en: 'Add the following code in the `tests/CMakeLists.txt` file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/CMakeLists.txt`文件中添加以下代码：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's dissect this code line by line. The first line brings in the Google Test
    capability. The second line creates the `tests` executable, which will include
    all our test source files. In this case, we only have one `CanTest.cpp` file,
    which will just verify that the testing works. After that, we link the `GTest`
    library to the `tests` executable. The last line identifies all individual tests
    in the `tests` executable and adds them to `CMake` as a test. This way, various
    test tools will be able to tell us which individual tests failed and which ones
    passed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析这段代码。第一行引入了Google Test功能。第二行创建了`tests`可执行文件，其中将包括所有我们的测试源文件。在这种情况下，我们只有一个`CanTest.cpp`文件，它将验证测试是否有效。之后，我们将`GTest`库链接到`tests`可执行文件。最后一行标识了`tests`可执行文件中的所有单独测试，并将它们添加到`CMake`作为一个测试。这样，各种测试工具将能够告诉我们哪些单独的测试失败了，哪些通过了。
- en: 'Create a `tests/CanTest.cpp` file. Add this code to simply verify that tests
    are running, without actually testing anything in our actual project:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tests/CanTest.cpp`文件。添加这段代码来简单验证测试是否运行，而不实际测试我们实际项目中的任何内容：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `TEST_F` line is an individual test. Now, `EXPECT_EQ(0, 0)` is testing whether
    zero is equal to zero, which will always succeed if we can actually run the test.
    We will later add the results of our own classes here to be tested against various
    values. Now we have the necessary setup for Google Test in our project. Next,
    we will build and run these tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Building, Running, and Writing Unit Tests
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we will discuss how to build, run, and write unit tests. The example that
    we have so far is a simple dummy test that is ready to be built and run. Later,
    we will add tests that make more sense and view the output of passing and failing
    tests. In the following exercise, we will build, run, and write unit tests for
    the project that we created in the previous exercise.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Building and Running Tests'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, you have created a project with `GoogleTest` set up, but you did not
    build or run the tests we created. In this exercise, we will build and run the
    tests that we created. Since we added our `tests` folder using `add_subdirectory`,
    building the project will automatically build the tests. Running the tests will
    require some more effort. Perform the following steps to complete the exercise:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Open our CMake project in Eclipse CDT.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build the tests, simply build the project just like you did before. Here
    is the output of building the project one more time from Eclipse after a full
    build using **Project** | **Build All**:![Figure 1.20: Build operation and its
    output'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_20.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: Build operation and its output'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you do not see this output, your console may be in the wrong view. You can
    correct it as shown in the following figures:![Figure 1.21: Viewing the correct
    console output'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_21.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: Viewing the correct console output'
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.22: Viewing the correct console output'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_22.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: Viewing the correct console output'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, our project now has two executable targets. They both live in
    the `build` folder, as with any other build artifact. Their locations are `build/Debug/CxxTemplate`
    and `build/Debug/tests/tests`. Since they are executables, we can simply run them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'We ran `CxxTemplate` before and will not see any extra output now. Run the
    other executable by typing the following command in the terminal while we are
    in our project folder:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code generates the following output in the terminal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Running the tests executable'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_23.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: Running the tests executable'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is the simple output of our `tests` executable. If you want to see whether
    the tests have passed, you can simply run this. However, testing is so much more
    than that.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways you can run your tests is by using the `ctest` command. Write
    the following commands in the terminal while you are in the project folder. We
    go to the folder where the `tests` executable resides, run `ctest` there, and
    come back:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is the output that you will see:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24: Running ctest'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.24: Running ctest'
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ctest` command can run your `tests` executable with a number of options,
    including the ability to submit test results automatically to online dashboards.
    Here, we will simply run the `ctest` command; its further features are left as
    an exercise for the interested reader. You can type `ctest --help` or visit the
    online documentation to discover `ctest` further at [https://cmake.org/cmake/help/latest/manual/ctest.1.html#](https://cmake.org/cmake/help/latest/manual/ctest.1.html#).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Another way to run the tests is to run them inside Eclipse, in a nice graphical
    report format. For this, we will create a run configuration that is test-aware.
    In Eclipse, click on **Run** | **Run Configurations…**, right-click **C/C++ Unit**
    on the left, and select **New Configuration**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the name from **CxxTemplate Debug** to **CxxTemplate Tests** as follows:![Figure
    1.25: Changing the name of the run configuration'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称从**CxxTemplate Debug**更改为**CxxTemplate Tests**如下所示：![图1.25：更改运行配置的名称
- en: '](img/C14508_01_25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_25.jpg)'
- en: 'Figure 1.25: Changing the name of the run configuration'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.25：更改运行配置的名称
- en: 'Under **C/C++ Application**, select the **Search Project** option:![Figure
    1.26: Run Configurations'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**C/C++ Application**下，选择**Search Project**选项：![图1.26：运行配置
- en: '](img/C14508_01_26.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_26.jpg)'
- en: 'Figure 1.26: Run Configurations'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.26：运行配置
- en: 'Choose **tests** in the new dialog:![Figure 1.27: Creating the test run configuration
    and selecting the tests executable'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新对话框中选择**tests**：![图1.27：创建测试运行配置并选择测试可执行文件
- en: '](img/C14508_01_27.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_27.jpg)'
- en: 'Figure 1.27: Creating the test run configuration and selecting the tests executable'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.27：创建测试运行配置并选择测试可执行文件
- en: 'Next, go to the **C/C++ Testing** tab and select **Google Tests Runner** in
    the dropdown. Click on **Apply** at the bottom of the dialog and click on the
    **Run** option for the test that we have to run for the first time:![Figure 1.28:
    Run Configurations'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**C/C++ Testing**选项卡，并在下拉菜单中选择**Google Tests Runner**。点击对话框底部的**Apply**，然后点击第一次运行的测试的**Run**选项：![图1.28：运行配置
- en: '](img/C14508_01_28.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_28.jpg)'
- en: 'Figure 1.28: Run Configurations'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.28：运行配置
- en: 'In the upcoming runs, you can either click the dropdown next to the play button
    in the toolbar, or choose **Run** | **Run History** to choose **CxxTemplate Tests**:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将进行的运行中，您可以单击工具栏中播放按钮旁边的下拉菜单，或选择**Run** | **Run History**来选择**CxxTemplate
    Tests**：
- en: '![Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.29：完成运行配置设置并选择要运行的配置'
- en: '](img/C14508_01_29.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_29.jpg)'
- en: 'Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.29：完成运行配置设置并选择要运行的配置
- en: 'The result will be similar to the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下截图：
- en: '![Figure 1.30: Run results of the unit test'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.30：单元测试的运行结果'
- en: '](img/C14508_01_30.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_30.jpg)'
- en: 'Figure 1.30: Run results of the unit test'
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.30：单元测试的运行结果
- en: This is a nice report that contains entries for all tests—only one for now.
    You may prefer this if you do not want to leave the IDE. Furthermore, when you
    have many tests, this interface can help you filter them effectively. Now you
    have built and run tests that were written using Google Test. You ran them in
    a couple of different ways, including directly executing the test, using `ctest`,
    and using Eclipse CDT. In the next section, we will solve an exercise wherein
    we will actually test the functionality of our code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的报告，包含了所有测试的条目，现在只有一个。如果您不想离开IDE，您可能会更喜欢这个。此外，当您有许多测试时，此界面可以帮助您有效地对其进行过滤。现在，您已经构建并运行了使用Google
    Test编写的测试。您以几种不同的方式运行了它们，包括直接执行测试，使用`ctest`和使用Eclipse CDT。在下一节中，我们将解决一个练习，其中我们将实际测试我们代码的功能。
- en: 'Exercise 6: Testing the Functionality of Code'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：测试代码功能
- en: 'You have run simple tests but now you want to write meaningful tests that are
    testing functionality. In the initial activity, we created `SumFunc.cpp`, which
    had the `sum` function. Now, in this exercise, we will write a test for that file.
    In this test, we will use the `sum` function to add two numbers and verify that
    the result is correct. Let''s recall the contents of the following files with
    the `sum` function from before:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经运行了简单的测试，但现在您想编写有意义的测试来测试功能。在初始活动中，我们创建了`SumFunc.cpp`，其中包含`sum`函数。现在，在这个练习中，我们将为该文件编写一个测试。在这个测试中，我们将使用`sum`函数来添加两个数字，并验证结果是否正确。让我们回顾一下之前包含`sum`函数的以下文件的内容：
- en: '`src/SumFunc.h`:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/SumFunc.h`：'
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`src/SumFunc.cpp`:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/SumFunc.cpp`：'
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Relevant lines of `CMakeLists.txt`:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`的相关行：'
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, let''s recall our `CantTest.cpp` file, which has the `main()` function
    of our unit tests:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们回顾一下我们的`CantTest.cpp`文件，它包含了我们单元测试的`main()`函数：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: Open our CMake project in Eclipse CDT.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse CDT中打开我们的CMake项目。
- en: 'Add a new test source file (`tests/SumFuncTest.cpp`) with the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的测试源文件（`tests/SumFuncTest.cpp`），内容如下：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this does not have a `main()` function since `CanTest.cpp` has one
    and these will be linked together. Secondly, note that this includes `SumFunc.h`,
    which is in the `sum(3, 4)` inside the test. This is how we use our project code
    in tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里没有`main()`函数，因为`CanTest.cpp`有一个，它们将被链接在一起。其次，请注意，这包括`SumFunc.h`，它在测试中使用了`sum(3,
    4)`。这是我们在测试中使用项目代码的方式。
- en: 'Make the following change in the `tests/CMakeLists.txt` file to build the test:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/CMakeLists.txt`文件中进行以下更改以构建测试：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we added both the test (`SumFuncTest.cpp`) and the code that it tests
    (`../src/SumFunc.cpp`) to the executable, as our test code is using the code from
    the actual project.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将测试（`SumFuncTest.cpp`）和它测试的代码（`../src/SumFunc.cpp`）都添加到可执行文件中，因为我们的测试代码正在使用实际项目中的代码。
- en: 'Build the project and run the test as before. You should see the following
    report:![Figure 1.31: Output after running the test'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并像以前一样运行测试。您应该看到以下报告：![图1.31：运行测试后的输出
- en: '](img/C14508_01_31.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_31.jpg)'
- en: 'Figure 1.31: Output after running the test'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.31：运行测试后的输出
- en: We can add such tests to our project and all of them will appear on the screen
    as shown in the preceeding screenshot.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这样的测试添加到我们的项目中，所有这些测试都将显示在屏幕上，就像前面的截图所示的那样。
- en: 'Now, let''s add one more test that will actually fail. In the `tests/SumFuncTest.cpp`
    file, make the following change:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个实际失败的测试。在`tests/SumFuncTest.cpp`文件中，进行以下更改：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this test assumes that the absolute values of the inputs are summed
    up, which is incorrect. The result of this call is `0` but is expected to be `6`
    in this example. This is the only change that we have to make in our project to
    add this test.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此测试假定输入的绝对值被求和，这是不正确的。这次调用的结果是`0`，但在这个例子中预期是`6`。这是我们在项目中必须做的唯一更改，以添加这个测试。
- en: 'Now, build the project and run the test. You should see this report:![Figure
    1.32: The build report'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_32.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.32: The build report'
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see in the preceding figure, the first two tests passed and the
    last test failed. When we see this output, there are two options: either our project
    code is wrong, or the test is wrong. In this case, our test is wrong. This is
    because our `6` is equal to `sum(3, -3)`. This is because we assumed that our
    function sums up the absolute values of the integers provided. However, this is
    not the case. Our function simply adds the given numbers, whether they are positive
    or negative. Therefore, this test had a faulty assumption and failed.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the test and fix it. Change the test so that we expect the sum
    of `-3` and `3` to be `0`. Rename the test to reflect what this test actually
    does:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run it now and observe in the report that all the tests pass:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.33: Test execution is successful'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_33.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.33: Test execution is successful'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, we have set up Google Test with CMake both in our system and project.
    We also wrote, built, and ran unit tests with Google Test, both in the terminal
    and in Eclipse. Ideally, you should write unit tests for every class and cover
    every possible usage. You should also run the tests after each major change and
    make sure you do not break existing code. In the next section, we will perform
    an activity of adding a new class and its test.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Adding a New Class and Its Test'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop a C++ project, you add new source files to it as the project
    grows. You also write tests for them to ensure that they are working properly.
    In this activity, we will add a new class that simulates `1D` linear motion. The
    class will have double fields for `position` and `velocity`. It will also have
    a `advanceTimeBy()` method, which receives a double `dt` parameter, which modifies
    `position` based on the value of `velocity`. Use `EXPECT_DOUBLE_EQ` instead of
    `EXPECT_EQ` for double values. In this activity, we will add a new class and its
    test to the project. Follow these steps to perform this activity:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Open the project that we have created in the Eclipse IDE.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `LinearMotion1D.cpp` and `LinearMotion1D.h` file pair to the project
    that contains the `LinearMotion1D` class. In this class, create two double fields:
    `position` and `velocity`. Also, create an `advanceTimeBy(double dt)` function
    that modifies `position`.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for this in the `tests/LinearMotion1DTest.cpp` file. Write two tests
    that represent motion in two different directions.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run it in the Eclipse IDE.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the tests have passed.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final test results should look similar to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.34: Final test results'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_34.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.34: Final test results'
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 622.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Adding new classes and their tests is a very common task in C++ development.
    We create classes for various reasons. Sometimes, we have a nice software design
    plan and we create the classes that it calls for. Other times, when a class becomes
    too large and monolithic, we separate some of its responsibility to another class
    in a meaningful way. Having this task be practical is important to prevent dragging
    your feet and ending up with huge monolithic classes. In the following section,
    we discuss what happens during the compilation and linking stages. This will give
    us a better perspective of what is happening under the hood of C++ programs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Compilation, Linking, and Object File Contents
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main reasons for using C++ is efficiency. C++ gives us control over
    memory management, which is why understanding how objects are laid out in memory
    is important. Furthermore, C++ source files and libraries are compiled to object
    files for the target hardware and linked together. Often, C++ programmers have
    to deal with linker problems, which is why understanding the steps of the compilation
    and being able to investigate object files is important. On the other hand, large
    projects are developed and maintained by teams over a long period of time, which
    is why creating clean and understandable code is important. As with any other
    software, bugs arise in C++ projects and need to be identified, analyzed, and
    resolved carefully by observing the program behavior. Therefore, learning how
    to debug C++ code is also important. In the next section, we will learn how to
    create code that is efficient, plays well with other code, and is maintainable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Compilation and Linking Steps
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A C++ project is created as a set of source code files and project configuration
    files that organize the sources and library dependencies. In the compilation step,
    these sources are first converted to object files. In the linking step, these
    object files are linked together to form the executable that is the ultimate output
    of the project. The libraries that the project uses are also linked at this step.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming exercises, we will use our existing project to observe the compilation
    and linking stages. Then, we will manually recreate them to view the process in
    more detail.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Identifying Build Steps'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have been building your projects without investigating the details of the
    build actions. In this exercise, we will investigate the details of our project''s
    build steps. Perform the following to complete the exercise:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `build` folder wherein our `Makefile` file resides by typing
    the following command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Clean the project and run the build in `VERBOSE` mode using the following command:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get a detailed output of the build process in the terminal, which
    may look a bit crowded:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.35: The build process part 1'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_35.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.35: The build process part 1'
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.36: The build process part 2'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_36.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.36: The build process part 2'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.37: The full build output'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_37.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.37: The full build output'
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are some of the lines from this output. The following lines are the important
    ones related to the compilation and linkage of the main executable:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `c++` command here is just a symbolic link to the `g++` compiler. To see
    that it''s actually a chain of symbolic links, type the following command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will see the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_38.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Therefore, we will use `c++` and `g++` interchangeably throughout our discussion.
    In the build output that we quoted earlier, the first four lines are compiling
    each `.cpp` source file and creating the corresponding `.o` object file. The last
    line is linking together these object files to create the `CxxTemplate` executable.
    The following figure visually presents this process:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.39: Execution stages of a C++ project'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_39.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.39: Execution stages of a C++ project'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As the previous figure shows, the CPP files that are added to CMake as a part
    of a target, along with the header files that they included, are compiled to object
    files, which are later linked together to create the target executable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this process even further, let''s carry out the compilation steps
    ourselves. In the terminal, go to the project folder and create a new folder named
    `mybuild` using the following commands:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, run the following commands to compile the CPP source files to object
    files:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Go into the `mybuild` directory and see what''s there using the following command:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We see the following output as expected. These are our object files:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.40: Compiled object files'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_40.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.40: Compiled object files'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the next step, link the object files together to form our executable. Type
    the following command:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s see our executable among the list of files here by typing the following
    command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows the new `CxxTemplate` file in the following figure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.41: Linked executable file'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_41.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.41: Linked executable file'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, run our executable by typing the following command:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And see the output that we had before:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.42: Executable file output'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_42.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.42: Executable file output'
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have examined the details of the build process and have recreated
    them yourself, in the next section, let's explore the linking process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The Linking Step
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, let''s look at a connection between two source files and how
    they end up in the same executable. Look at the **sum** function in the following
    figure:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.43: The linking process'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_43.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.43: The linking process'
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The **sum** function's body is defined in **SumFunc.cpp**. It has a forward
    declaration in **SumFunc.h**. This way, the source files that want to use the
    **sum** function can know about its signature. Once they know its signature, they
    can call it and trust that the actual function definition will be there during
    runtime, without actually having any interaction with **SumFunc.cpp** where the
    function is defined.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: After compilation, **CxxTemplate.cpp**, which calls the **sum** function, carries
    that call into its object file. Still, it does not know where the function definition
    is. The object file of **SumFunc.cpp** has that definition, but it has nothing
    to do with **CxxTemplate.o**, yet.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: During the linking step, the linker matches the call in **CxxTemplate.o** with
    the definition in **SumFunc.o**. The call works fine in the executable as a result.
    Had the linker not found the definition of the **sum** function, it would have
    given a linker error.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The linker finds the `symbol could not be resolved` error.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'This took us through the two stages of the build process: `compilation` and
    `linking`. Notice that we used rather simpler commands compared to that of CMake,
    when we compiled our sources manually. Feel free to type `man g++` to see all
    the options there. Later, we discussed linking and how symbols are resolved. We
    also talked about possible issues with the linking step. In the next section,
    we will learn about object files.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Diving Deeper: Viewing Object Files'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the linking step to work without errors, we need to have all our symbol
    references match our symbol definitions. Most of the time, we can analyze how
    things will be resolved just by looking at the source files. Sometimes, in complex
    situations, we may have a difficult time understanding why a symbol is not being
    resolved. In such situations, looking at the contents of object files to investigate
    references and definitions can be useful to resolve the problem. Besides linker
    errors, understanding object file contents and how linking works in general is
    useful for a C++ programmer. Knowing what is happening under the hood may help
    programmers understand the whole process in a better way.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: When our source code is compiled to object files, our statements and expressions
    are converted to assembly code, which is the low-level language that the CPU understands.
    Each instruction in assembly contains an operation, followed by operators, which
    are registers of the CPU. There are instructions to load data to and from registers
    and operate on values in registers. The `objdump` command in Linux helps us view
    the contents of these object files.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will utilize Compiler Explorer, a nice online tool that is easier to use,
    where you can write code on the window to the left, and on the right, you can
    see the compiled assembly code. Here is the link to the Compiler Explorer: [https://godbolt.org](https://godbolt.org).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Exploring Compiled Code'
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use Compiler Explorer to compile some simple C++
    code in which we define and call a function. We will investigate the compiled
    assembly code to understand how exactly names are resolved and calls are made.
    This will give us a better understanding of what happens under the hood and how
    our code works in the executable format. Perform the following steps to complete
    the exercise:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in `call sum(int, int)` line does what you expect: it
    calls the preceding `sum` function and places the arguments in some registers.
    The important point here is that the functions are identified by their names and
    the types of their parameters in order. The linker looks for the appropriate function
    with this signature. Note that the return value is not a part of the signature.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `_Z`, the number tells us how long the function name is, so that
    the following letters are correctly interpreted. After the function name, we have
    `v` for no parameters and `i` for an `int` parameter. You can change these function
    signatures to view other possible types.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s look at how classes are compiled. Add the following code into **Compiler
    Explorer** under the existing code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the compiled version of these added lines:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.46: The compiled version'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_46.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.46: The compiled version'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may be surprised that there is no class definition in the compiled code.
    The methods are similar to global functions, but with a twist: their mangled names
    contain the class name and they receive the object instance as a parameter. Creating
    an instance simply allocates space for the fields of the class.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: During the linker phase, these mangled function names are used to match callers
    with callees. For callers that cannot find a callee, we get linker errors. Most
    linker errors can be resolved by carefully checking sources. However, in some
    cases, viewing the object file contents with `objdump` can help get to the bottom
    of the problem.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Debugging C++ Code
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different levels of problems that you can come across while developing
    a C++ project:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: First, you may receive compiler errors. These can happen because of a mistake
    you made in syntax, or a wrong choice for a type, and so on. The compiler is the
    first hoop you have to jump through, and it catches some mistakes you may have
    made.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second hoop is the linker. There, a typical mistake is to use something
    that is declared, but not actually defined. This happens often when you use the
    wrong header file for a library—the header file advertises a certain signature
    that does not exist in any of the source files or libraries. Once you also jump
    through the linker hoop, your program is ready to execute.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the next hoop to jump through is to avoid any runtime errors. Your code
    may have compiled and linked properly, but it may be doing things that do not
    work, such as dereferencing a null pointer or dividing by zero.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find and fix runtime errors, you have to interact with and monitor the running
    application in some way. An often-used technique is to add `print` statements
    to the code and monitor the logs that it generates, hoping to correlate the application
    behavior with the logs to pinpoint the region in code that has the problem. While
    this works for some cases, sometimes you need to take a closer look at the execution.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: A debugger is a better tool to fight runtime errors. A debugger can let you
    run code line by line, continue running and pause on the lines that you want,
    investigate the values of memory, and pause on errors, among other things. This
    lets you watch what exactly is going on with memory as your program is running
    and identify the line of code that results in the unwanted behavior.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`gdb` is the canonical command-line debugger that can debug C++ programs. However,
    it may be difficult to use as debugging is inherently a visual task—you want to
    be able to look at lines of code, values of variables, and the output of the program
    at the same time. Luckily, Eclipse CDT includes a visual debugger that is easy
    to use.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Debugging with Eclipse CDT'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have been simply running your projects and viewing the output. Now you
    want to learn how to debug your code in detail. In this exercise, we will explore
    Eclipse CDT''s debugging capabilities. Perform the following steps to complete
    the exercise:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Open the CMake project in Eclipse CDT.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that we have an existing run configuration, click **Run** | **Run
    Configurations**. There, you should see a **CxxTemplate** entry under **C/C++
    Application**.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we ran our project before, it should be there. If not, please go back
    and create it again.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Close the dialog box to continue.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start the debugger, find the toolbar entry that looks like an insect (bug)
    and click on the dropdown next to it. Select `main()` function, which is shown
    with the green highlight and the arrow in the center code view. On the left, we
    see the running threads, of which there is only one. On the right, we see the
    variables that are accessible in this context. On the bottom, we see the **gdb**
    output that Eclipse uses behind the scenes to actually debug the executable. Now,
    there is not much to be debugged with our main function.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `libc-start.c` library, which is the caller of the `main` function. You
    can close it and switch to your source files when done. When you do not see the
    red stop button anymore, you know that the program execution is over.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit our `main` function by adding the following code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The post-increment operator mixed with the occasional `do-while` loop can be
    a head-scratcher for some. This is because we try to execute the algorithm in
    our heads. However, our debugger is perfectly able to run it step by step and
    show us what exactly happens during execution.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Start debugging after adding the preceding code. Click on the dropdown next
    to the **Debug** button in the toolbar and select **CxxTemplate**. Press *F6*
    a couple of times to step over in the code. It will show us how the variables
    change as well as the line of code that will be executed next:![Figure 1.48: Stepping
    over the code'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_48.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.48: Stepping over the code'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Seeing the variables change after the execution of each line of code makes
    the algorithm much clearer to understand. As you press *F6*, note that the following
    are the values after each execution of the `t += i++;` line:![Figure 1.49: Variable
    states through time'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_49.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.49: Variable states through time'
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding output clearly explains how the values are changing and why `6`
    is printed at the end.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore other features of the debugger. While the variable view is useful,
    you can also hover over any variable and browse its value:![Figure 1.50: View
    option of the debugger'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_50.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.50: View option of the debugger'
  id: totrans-388
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Furthermore, the **Expression** view helps you calculate things that are otherwise
    not clear from the values that you browse.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Expression** on the right-hand side and click on the **Add** button:![Figure
    1.51: Adding an expression'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_51.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.51: Adding an expression'
  id: totrans-392
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type **t+i** and hit *Enter*. Now you see the total in the list of expressions:![Figure
    1.52: Expression view with a new expression'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_52.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.52: Expression view with a new expression'
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can press the red square in the toolbar or select **Run** | **Terminate**
    to stop debugging at any time. Another feature is breakpoints, which tell the
    debugger to pause whenever it goes to a line marked with a breakpoint. So far,
    we have been stepping through our code line by line, which may be very time-consuming
    in a large project. Instead, you usually want to continue the execution until
    it arrives at the code that you are interested in.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of going line by line, add a breakpoint in the line that does
    the printing. For this, double-click on the area to the left of the line number
    of this line. In the following figure, the dot represents a breakpoint:![Figure
    1.53: Working with breakpoints'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_53.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.53: Workin with breakpoints'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now start the debugger. As usual, it will start paused. Now select **Run**
    | **Resume** or click on the toolbar button. It will run the three executions
    of the loop and pause at our breakpoint. This way, we saved time by stepping through
    code that we are not investigating:![Figure 1.54: Working with the debugger'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_54.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.54: Working with the debugger'
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While we have been dealing with the loop that we added, we ignored the line
    that creates an `app` object. The **Step Over** command was skipping this line.
    However, we also have the option to go into the constructor call that is in this
    line. For that, we will use **Run** | **Step Into** or the corresponding toolbar
    button.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stop the debugger and start it again. Click on **Step Over** to go to the line
    where the application is created:![Figure 1.55: Working with the debugger – the
    Step Over option'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_55.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.55: Working with the debugger – the Step Over option'
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The highlighted is the next line that would be executed if we step over again.
    Instead, press the Step Into button. This will take us into the constructor call:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.56: Working with the debugger – the Step Into option'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_56.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.56: Working with the debugger – the Step Into option'
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a handy feature for diving deeper into the function instead of simply
    stepping over it. Also, notice the call stack in the left debug view. You can
    always click on the lower entries to go and view the callers' contexts again.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to the Eclipse CDT debugger, which uses GDB under
    the hood to give you a visual debugging experience. You may find debugging useful
    when trying to understand runtime errors better and correcting the mistakes that
    caused them.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Writing Readable Code
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While visual debuggers are quite useful to identify and eliminate runtime errors
    or unintended program behavior, it is a better idea to write code that is less
    likely to have problems to begin with. One way to do that is to strive to write
    code that is easier to read and to understand. Then, finding problems in code
    becomes more like identifying contradictions between English sentences and less
    like solving cryptic puzzles. When you are writing code in a way that is understandable,
    your mistakes will often be apparent as you are making them and will be easier
    to spot when you come back to solve problems that slipped through.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: After some unenjoyable maintenance experiences, you realize that the primary
    purpose of the programs that you write is not to make the computer do what you
    want to, but to tell the reader what the computer will do when the program runs.
    This usually means that you need to do more typing, which IDEs can help with.
    This may also mean that you sometimes write code that is not the most optimal
    in terms of execution time or memory used. If this goes against what you have
    learned, consider that you may be trading a minuscule amount of efficiency for
    the risk of being incorrect. With the vast processing power and memory at our
    disposal, you may be making your code unnecessarily cryptic and possibly buggy
    in the vain quest for efficiency. In the next sections, we will list some rules
    of thumb that may help you write code that is more readable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Indentation and Formatting
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ code, as in many other programming languages, is composed of program blocks.
    A function has a set of statements that form its body as a block. A loop's block
    statements will execute in iterations. An `if` statement's block executes if the
    given condition is true and the corresponding `else` statement's block executes
    otherwise.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Curly braces, or lack thereof for single-statement blocks, inform the computer,
    whereas indentation in the form of white space informs the human reader about
    the block structure. The lack of indentation, or misleading indentation, can make
    it very difficult for the reader to understand the structure of the code. Therefore,
    we should strive to keep our code well-indented. Consider the following two code
    blocks:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'While they are identical in terms of execution, it is much clearer in the second
    one that `firstFunction()` is executed only if `result` is `2`. Now consider the
    following code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is simply misleading. If the reader is not careful, they might easily assume
    that `secondFunction()` is executed only if `result` is `2`. However, this code
    is identical to the two previous examples in terms of execution.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like correcting indentation is slowing you down, you can use your
    editor's formatting facilities to help you. In Eclipse, you can select a block
    of code and use **Source** | **Correct Indentation** to fix the indentation of
    that selection, or use **Source** | **Format** to also fix other formatting issues
    with code.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Beyond indentation, other formatting rules such as placing the curly brace at
    the correct line, inserting spaces around binary operators, and inserting a space
    after each comma are also very important formatting rules that you should abide
    by to keep your code well-formatted and easy to read.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In Eclipse, you can set formatting rules per-workspace in **Window** | **Preferences**
    | **C/C++** | **Code Style** | **Formatter** or per-project in **Project** | **Properties**
    | **C/C++ General** | **Formatter**. You can either select one of the industry-standard
    styles such as K&R or GNU, or you can modify them and create your own. This becomes
    especially important when you use **Source** | **Format** to format your code.
    For example, if you choose to use spaces for indentation but Eclipse's formatting
    rules are set to tabs, your code would become a mixture of tabs and spaces.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Use Meaningful Names as Identifiers
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our code, we use identifiers to name many items—variables, functions, class
    names, types, and so on. For the computer, these identifiers are merely a sequence
    of characters to distinguish them from one another. However, for the reader, they're
    much more. The identifier should completely and unambiguously describe the item
    that it represents. At the same time, it should not be overly long. Furthermore,
    it should abide by the style standards that are in use.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While this is a perfectly valid piece of C++ code, it is quite difficult to
    read. Let's list the problems with it. First of all, let's look at the style problems
    of the identifiers. The `studentsFile` class name starts with a lowercase letter,
    which should have been uppercase instead. The `File` variable should have started
    with a lowercase letter. The `Count_Names` variable should have started with a
    lowercase letter and should not have had an underscore in it. The `CheckNextElement`
    method should have started with a lowercase letter. While these may seem arbitrary
    rules, being consistent in naming carries extra information about the name—when
    you see a word that starts with an uppercase letter, you immediately understand
    that it must be a class name. Furthermore, it is simply a distraction to have
    names that do not obey the standard in use.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look beyond the style and inspect the names themselves. The first
    problematic name is the `runFileCheck` function. A method is an action that returns
    a value: its name should both clearly explain what it does as well as what it
    returns. "Check" is an overused word that is too vague for most situations. Yes,
    we checked it, it''s there—what should we do with it then? In this case, it seems
    we actually read the file and create a `File` object. In that case, `runFileCheck`
    should have been `readFile` instead. This clearly explains the action being taken,
    and the return value is what you would expect. If you wanted to be more specific
    about the return value, `readAsFile` could be another alternative. Similarly,
    the `check` method is vague and should be `exists` instead. The `CheckNextElement`
    method is also vague and should be `nextElementExists` instead.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Another overused vague word is `flag`, which is often used for Boolean variables.
    The name suggests an on/off situation but gives no clue as to what its value would
    mean. In this case, its `true` value means that the file exists, and the `false`
    value means that the file does not exist. The trick for naming Boolean variables
    is to devise a question or statement that is correct when the value of the variable
    is `true`. In this example, `fileExists` and `doesFileExist` are two good choices.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Our next misnamed variable is `Count_Names`, or `countNames` with its correct
    capitalization. This is a bad name for an integer because the name does not suggest
    a number—it suggests an action that results in a number. Instead, an identifier
    such as `numNames` or `nameCount` would clearly communicate what the number inside
    means.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Algorithms Clear and Simple
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we read code, the steps that are taken and the flow should make sense.
    Things that are done indirectly—byproducts of functions, multiple actions being
    done together in the name of efficiency, and so on—are things that make it difficult
    to understand your code for the reader. For example, let''s look at the following
    code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we have an array that we are processing in a loop. At first glance, it
    is not very clear what exactly the loop is doing. The variable names are helping
    us understand what is going on, but we must run the algorithm in our heads to
    be sure that what's being advertised by those names is really happening here.
    There are three different operations that are taking place in this loop. Firstly,
    we are finding the sum of all the elements. Secondly, we are finding the minimum
    element in the array. Thirdly, we are taking the absolute value of each element
    after these operations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this alternative version:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now everything is much clearer. The first loop finds the sum of the inputs,
    the second loop finds the minimum element, and the third loop finds the absolute
    value of each element. Although it's much clearer and more understandable, you
    may feel like you are doing three loops, and therefore wasting CPU resources.
    The drive to create more efficient code may compel you to merge these loops. Note
    that the efficiency gains you have here would be minuscule; your program's time
    complexity would still be O(n).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: While creating code, readability and efficiency are two constraints that can
    often be in competition. If you want to develop readable and maintainable code,
    you should always prioritize readability. Then, you should strive to develop code
    that is also efficient. Otherwise, code that has low readability risks being difficult
    to maintain, or worse, risks having bugs that are difficult to identify and fix.
    Your program's high efficiency would be irrelevant when it is producing incorrect
    results or when the cost of adding new features to it becomes too high.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Making Code Readable'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are style and indentation problems in the following code. Spaces are
    used inconsistently, and the indentation is incorrect. Also, the decision on single-statement
    `if` blocks having curly braces or not is inconsistent. The following piece of
    code has problems in terms of indentation, formatting, naming, and clarity:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s fix these problems and make it compatible with a common C++ code style.
    Perform the following steps to complete this exercise:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse CDT.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `a`, whose length is `Len`. Better names for these would be `input`
    and `inputLength`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make that first change and rename `a` to `input`. If you are using Eclipse,
    you can select `Len` and rename it to `inputLength`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The updated code will look like the following. Note that we do not need the
    comment anymore since parameter names are self-explanatory:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have a couple of other variables defined before the loop. Let's try to understand
    them. It seems all it does with `S` is to add each element to it. Therefore, `S`
    must be `sum`. `M`, on the other hand, seems to be the minimum element—let's name
    it `smallest`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Lim_value` seems to be a threshold, where we simply want to know whether it
    has been crossed. Let''s rename it `topThreshold`. The `flag` variable is set
    to true if this threshold is crossed. Let''s rename it to `isTopThresholdCrossed`.
    Here is the state of the code after these changes with **Refactor** | **Rename**:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s see how we can make this code simpler and easier to understand.
    The preceding code is doing these things: calculating the sum of the input elements,
    finding the smallest one, determining whether the top threshold was crossed, and
    multiplying each element by two.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all of these are done in the same loop, the algorithm is not very clear
    now. Fix that and have four separate loops:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now the code is much clearer. While it's very easy to understand what each block
    is doing, we also added comments to make it even more clear. In this section,
    we gained a better understanding of how our code is converted to executables.
    Then, we discussed ways of identifying and resolving possible errors with our
    code. We finalized this with a discussion about how to write readable code that
    is less likely to have problems. In the next section, we will solve an activity
    wherein we will be making code more readable.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Making Code More Readable'
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have code that is unreadable and contains bugs, either because you
    wrote it in a hurry, or you received it from someone else. You want to change
    the code to eliminate its bugs and to make it more readable. We have a piece of
    code that needs to be improved. Improve it step by step and resolve the issues
    using a debugger. Perform the following steps to implement this activity:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Below you will find the source for `SpeedCalculator` class. Add these two files
    to your project.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of this class in your `main()` function and call its `run()`
    method.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the style and naming problems in the code.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify the code to make it more understandable.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and observe the problem at runtime.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the debugger to fix the problem.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the code for **SpeedCalculator.cpp** and **SpeedCalculator.h** that
    you will add to your project. You will modify them as a part of this activity:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 626.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create C++ projects that are portable and
    maintainable. We first learned how to create CMake projects and how to import
    them to Eclipse CDT, giving us the choice to use the command line or an IDE. The
    rest of the chapter focused on eliminating various problems in our projects. First,
    we learned how to add unit tests to a project and how to use them to ensure that
    our code works as intended. We continued this with a discussion about the compilation
    and linking steps that our code goes through and observed the contents of object
    files to gain a better understanding of executable files. Then, we learned how
    to debug our code visually in the IDE to eliminate runtime errors. We finished
    this discussion with a number of rules of thumb that help create readable, understandable,
    and maintainable code. These methods will come in handy on your C++ journey. In
    the next chapter, we will learn more about C++'s type system and templates.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
