- en: 1\. Anatomy of Portable C++ Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish the code-build-test process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the various stages of compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decipher complicated C++ type systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure projects with unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert source code to object code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write readable code and debug it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn to establish the code-build-test model that will
    be used throughout the book, write beautiful code, and perform unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is one of the oldest and most popular languages that you can use to write
    efficient code. It is both "close to the metal," like C, and has advanced object-oriented
    features, like Java. Being an efficient low-level language makes C++ the language
    of choice for domains in which efficiency is paramount, such as games, simulations,
    and embedded systems. At the same time, being an object-oriented language with
    advanced features such as generics, references, and countless others makes it
    suitable for large projects that are developed and maintained by multiple people.
  prefs: []
  type: TYPE_NORMAL
- en: Almost any programming experience involves organizing your code base and using
    libraries written by others. C++ is no different. Unless your program is simple,
    you will distribute your code into multiple files that you need to organize, and
    you will use various libraries that fulfill tasks, usually in a much more efficient
    and robust way than your code would. C++ projects that do not use any third-party
    libraries are edge cases that do not represent the majority of projects, which
    use many libraries. These projects and their libraries are expected to work in
    different hardware architectures and operating systems. Therefore, it is important
    to spend time on project setup and understand the tools used to manage dependencies
    if you are going to develop anything meaningful with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern and popular high-level languages have standard tools to maintain
    projects, build them, and handle their library dependencies. Many of these have
    repositories that host libraries and tools that automatically download and use
    libraries from those repositories. For example, Python has `pip`, which takes
    care of downloading and using appropriate versions of libraries that the programmer
    wants to use. Similarly, JavaScript has `npm`, Java has `maven`, Dart has `pub`,
    and C# has `NuGet`. In most of these languages, you list the name of the library
    and the version that you would like to use, and the tool automatically downloads
    and uses the compatible version of the library. These languages benefit from the
    fact that the programs are built and run in a controlled environment in which
    a certain level of hardware and software requirements are satisfied. C++, on the
    other hand, is expected to work in a variety of contexts with different architectures,
    including very primitive hardware. Hence, C++ programmers are less pampered when
    it comes to building programs and performing dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Managing C++ Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of C++, we have several tools that help in managing project sources
    and their dependencies. For example, `pkg-config`, `Autotools`, `make`, and `CMake`
    are the most notable ones in the community. Compared to the tools of the other
    high-level languages, these are much more complicated to use. `CMake` has arisen
    among these as the de facto standard for managing C++ projects and their dependencies.
    It is more opinionated compared to `make`, and it is accepted as the direct project
    format for most IDEs (Integrated Development Environments).
  prefs: []
  type: TYPE_NORMAL
- en: While `CMake` helps with managing projects and their dependencies, the experience
    is still far from higher-level languages in which you list the libraries and their
    versions that you want to use and everything else is taken care of for you. With
    CMake, you still are responsible for installing libraries properly in your development
    environment, and you are expected to use compatible versions for each library.
    In popular Linux distributions with extensive package managers, you can easily
    install binary versions of most popular libraries. However, sometimes, you may
    have to compile and install the libraries yourself. This is a part of the whole
    C++ developer experience, which you will gather by learning more about the development
    platform of your choice. Here, we will focus more on how to properly set up our
    CMake projects, including understanding and resolving issues related to libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Code-Build-Test-Run Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to base our discussion on a solid foundation, we will immediately start
    with a practical example. We will start with a C++ code base template that you
    can use as a starting point for your own projects. We will see how we can build
    and compile it using CMake on the command line. We will also set up the Eclipse
    IDE for C/C++ developers and import our CMake project. The use of an IDE will
    provide us with facilities that ease the creation of source code and enable us
    to debug our programs line by line to view what exactly happens during the execution
    of our program and correct our mistakes in an informed fashion rather than trial
    and error and superstition.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CMake Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The de facto standard for C++ projects is to use CMake to organize and build
    the project. Here, we will use a basic template project as a starting point. The
    following is the folder structure of a sample template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Folder structure of a sample template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Folder structure of a sample template'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding figure, the `git` version control system. Such ignored files
    include the outputs of the build process, which are created locally and should
    not be shared among computers.
  prefs: []
  type: TYPE_NORMAL
- en: The files in the `make` files for different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Building a project with CMake is a two-step process. First, we get CMake to
    generate platform-dependent configuration files for a native build system that
    will compile and build the project. Then, we will use the generated files to build
    the project. The platform-dependent build systems that CMake can generate configuration
    files for include `UNIX` `Makefiles`, `Ninja` `build files`, `NMake` `Makefiles`,
    and `MinGW` `Makefiles`. The choice here depends on the platform in use, the availability
    of these tools, and personal preference. `UNIX` `Makefiles` are a de facto standard
    for `Unix` and `Linux`, whereas `NMake` is its `Windows` and `Visual Studio` counterpart.
    `MinGW`, on the other hand, is a `Unix`-like environment in `Windows` in which
    `Makefiles` are also in use. `Ninja` is a modern build system that provides exceptional
    speed compared to other build systems coupled with multi-platform support, which
    we choose to use here. Furthermore, in addition to these command-line build systems,
    we can also generate IDE projects for `Visual Studio`, `XCode`, `Eclipse CDT`,
    and many others, and build our projects inside the IDE. Therefore, `CMake` is
    a meta tool that will create the configuration files for another system that will
    actually build the project. In the next section, we will solve an exercise, wherein
    we will generate `Ninja` `build files` using `CMake`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Using CMake to Generate Ninja Build Files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will use `CMake` to generate `Ninja build files`, which
    are used to build C++ projects. We will first download our source code from a
    `git` repository and will use CMake and Ninja to build it. The aim of this exercise
    is to use CMake to generate Ninja build files, build the project, and then run
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The link to the GitHub repository can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal window, type the following command to download the `CxxTemplate`
    repository from GitHub onto your local system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Checking out the sample project from GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Checking out the sample project from GitHub'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now you have the source code in the `CxxTemplate` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate into the `CxxTemplate` folder by typing the following command in the
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can list all the files in the project by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate our Ninja build file using the `cmake` command in the `CxxTemplate`
    folder. To do that, write the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Generating the Ninja build file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Generating the Ninja build file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's explain parts of the preceding command. With `-Bbuild`, we are telling
    CMake to use the `build` folder to generate build artifacts. Since this folder
    does not exist, CMake will create it. With `–H.`, we are telling CMake to use
    the current folder as the source. By using a separate `build` folder, we will
    keep our source files clean and all the build artifacts will live in the `build`
    folder, which is ignored by Git thanks to our `.gitignore` file. With `–GNinja`,
    we are telling CMake to use the Ninja build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to list the project files and to check the files
    that were created inside the `build` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will show the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Files in the build folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: Files in the build folder'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It's clear that the preceding files will be present inside the build folder.
    **build.ninja** and **rules.ninja** in the preceding output are the Ninja build
    files that can actually build our project in this platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using CMake, we did not have to write the Ninja build files and avoided committing
    to the Unix platform. Instead, we have a meta-build system that can generate low-level
    build files for other platforms such as UNIX/Linux, MinGW, and Nmake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go into the `build` folder and build our project by typing the following
    commands in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a final output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Building with ninja'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: Building with ninja'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type `ls` in the `CxxTemplate` executable or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command yields the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Files in the build folder after running ninja'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.6: Files in the build folder after running ninja'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding figure, you can see that the `CxxTemplate` executable is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, type the following command to run the `CxxTemplate` executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command in the terminal will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14508_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Running the executable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following line from the `src/CxxTemplate.cpp` file is responsible for writing
    the previous output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now you have successfully built a CMake project in Linux. Ninja and CMake work
    quite well together. You have to run CMake only once and Ninja will detect whether
    CMake should be called again and will call it for you. For example, even if you
    add new source files to your `CMakeLists.txt` file, you only need to type the
    `ninja` command in the terminal, and it will run CMake automatically for you to
    update the Ninja build files. Now that you have learned about building a CMake
    project in Linux, in the next section, we will look at how to import a CMake project
    into Eclipse CDT.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a CMake Project into Eclipse CDT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Ninja build file is useful for building our project in Linux. However, a CMake
    project is portable and can be used with other build systems and IDEs as well.
    Many IDEs accept CMake as their configuration file and provide a seamless experience
    as you modify and build your project. In this section, we will discuss how to
    import a CMake project into Eclipse CDT, which is a popular cross-platform C/C++
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways of using Eclipse CDT with CMake. The default one that
    CMake provides is the one-way generation of the IDE project. Here, you create
    the IDE project once, and any modifications you make to your IDE project will
    not change back the original CMake project. This is useful if you manage your
    project as a CMake project and do one-time builds with Eclipse CDT. However, it's
    not ideal if you want to do your development in Eclipse CDT.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of using CMake with Eclipse CDT is to use the custom `cmake4eclipse`
    plugin. When using this plugin, you do not abandon your `CMakeLists.txt` file
    and make a one-way switch to Eclipse CDT's own project manager. Instead, you keep
    managing your project through the `CMakeLists.txt` file, which continues to be
    the main configuration file of your project. Eclipse CDT actively works with your
    `CMakeLists.txt` file to build your project. You can add or remove source files
    and make other changes in your `CMakeLists.txt`, and the `cmake4eclipse` plugin
    applies those changes to the Eclipse CDT project at every build. You will have
    a nice IDE experience while keeping your CMake project current. The benefit of
    this approach is that you can always quit using Eclipse CDT and use your `CMakeLists.txt`
    file to switch to another build system (such as Ninja) later. We will use this
    second approach in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Importing the CMake File into Eclipse CDT'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last exercise, you developed a CMake project and you would like to start
    using Eclipse CDT IDE to edit and build that project. In this exercise, we will
    import our CMake project into the Eclipse CDT IDE using the `cmake4eclipse` plugin.
    Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse CDT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C++ project in the location of our current project (the folder
    that contains the `CMakeLists.txt` file and the **src** folder). Go to **File**
    | **New** | **Project**. A **New Project** dialog box appears like the one in
    the following screenshot:![Figure 1.8: New Project dialog box'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: New Project dialog box'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Select the **C++ Project** option and click on the **Next** button. A **C++
    Project** dialog box appears like the one in the following screenshot:![Figure
    1.9: C++ Project dialog box'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9: C++ Project dialog box'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Accept everything, including switching to the C/C++ perspective, and click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Restore** button at the top-left corner to view the newly created
    project:![Figure 1.10: The Restore button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: The Restore button'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on the **CxxTemplate** project. Go to **Project** | **Properties**, then
    select **Tool Chain Editor** under **C/C++ Build** from the left pane and set
    **Current builder** to **CMake Builder (portable)**. Then, click on the **Apply
    and Close** button:![Figure 1.11: Project properties'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.11: Project properties'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, choose the **Project** | **Build All** menu item to build the project:![Figure
    1.12: Building the project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12: Building the project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the following `make all` that actually builds our project:![Figure 1.13:
    The build output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.13: The build output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you did not get any errors in the previous steps, you can run the project
    using the menu item **Run** | **Run**. If you are given some options, choose **Local
    C/C++ Application** and **CxxTemplate** as the executable:![Figure 1.14: Running
    a project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14: Running a project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When it runs, you will see the output of the program in the **Console** pane
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.15: Output of the project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: Output of the project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built and run a CMake project using Eclipse CDT. In the
    next exercise, we will introduce a frequent change to our projects by adding new
    source files with new classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Adding New Source Files to CMake and Eclipse CDT'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop significantly bigger C++ projects, you will tend to add new
    source files to it as the project grows to meet the set expectations. In this
    exercise, we will add a new `.cpp` and `.h` file pair to our project and see how
    CMake and Eclipse CDT work together with these changes. We will add these files
    inside the project using the new class wizard, but you can also create them with
    any other text editor. Perform the following steps to add new source files to
    CMake and Eclipse CDT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the project that we have been using until now. In the **Project
    Explorer** pane on the left, expand the root entry, **CxxTemplate**, and you will
    see the files and folders of our project. Right-click the **src** folder and select
    **New** | **Class** from the pop-up menu:![Figure 1.16: Creating a new class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Creating a new class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the dialog box that opened, type **ANewClass** for the class name. When you
    click on the **Finish** button, you will see the **ANewClass.cpp** and **ANewClass.h**
    files generated under the **src** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s write some code into the `ANewClass` class and access it from the
    `ANewClass.cpp` and change the beginning of the file to match the following, and
    then save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will see that Eclipse warns us with a `ANewClass.h` file as well. Such warnings
    are made possible by analyzers in IDEs and are quite useful as they help you fix
    your code as you are typing, without running the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ANewClass.h` file, add the following code, and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the error in the `.cpp` file went away. If it did not go
    away, it may be because you may have forgotten to save one of the files. You should
    make it a habit to press *Ctrl + S* to save the current file, or *Shift + Ctrl
    + S* to save all the files that you edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this class from our other class, `CxxTemplate.cpp`. Open that
    file, perform the following modifications, and save the file. Here, we are first
    importing header files and in the constructor of `CxxApplication`, we are printing
    text to the console. Then, we are creating a new instance of `ANewClass` and calling
    its `run` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The complete code of this file can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to build the project by clicking on the `CMakeLists.txt` file, make the
    following modification, and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try to build the project again. This time you should not see any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project using the **Run** | **Run** menu option. You should see the
    following output in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.18: Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You modified a CMake project, added new files to it, and ran it fine. Note that
    we created the files in the `src` folder and let the `CMakeLists.txt` file know
    about the CPP file. If you do not use Eclipse, you can simply continue with the
    usual CMake build commands and your program will run successfully. So far, we
    have checked out the sample code from GitHub and built it both with plain CMake
    and with the Eclipse IDE. We also added a new class to the CMake project and rebuilt
    it in Eclipse IDE. Now you know how to build and modify CMake projects. In the
    next section, we will perform an activity of adding a new source-header file pair
    to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Adding a New Source-Header File Pair to the Project'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop C++ projects, you add new source files to it as the project
    grows. You may want to add new source files for various reasons. For example,
    let''s say you are developing an accounting application in which you calculate
    interest rates in many places of your project, and you want to create a function
    in a separate file so that you can reuse it throughout your project. To keep things
    simple, here we will create a simple summation function instead. In this activity,
    we will add a new source-header file pair to the project. Perform the following
    steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project that we created in the earlier exercise in the Eclipse IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SumFunc.cpp` and `SumFunc.h` file pair to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple function named `sum` that returns the sum of two integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the function from the `CxxTemplate` class constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the project in Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: Final output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: Final output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 620.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will talk about how to write unit tests for our
    projects. It is common to divide projects into many classes and functions that
    work together to achieve the desired goal. You must manage the behavior of these
    classes and functions with unit tests to ensure that they behave in expected ways.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are an important part of programming in general. Basically, unit
    tests are little programs that use our classes in various scenarios with expected
    results, live in a parallel file hierarchy in our project, and do not end up in
    the actual executable but are executed separately by us during development to
    ensure that our code is behaving in expected ways. We should write unit tests
    for our C++ programs to ensure that they behave as they are supposed to after
    each change.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for the Unit Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several C++ test frameworks that we can use with CMake. We will use
    **Google Test**, which has several benefits over other options. In the next exercise,
    we will prepare our project for unit testing with Google Test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Preparing Our Project for Unit Testing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have installed Google Test but our project is not set up to use Google Test
    for unit testing. In addition to the installation, there are settings that need
    to be carried out in our CMake project to have Google Test unit tests. Follow
    these steps to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse CDT and select the CxxTemplate project that we have been using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named **tests** as we will perform all our tests there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit our base `CMakeLists.txt` file to allow tests in the `GTest` package that
    brings `GoogleTest` capability to CMake. We will add our new lines just after
    that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to add to our main `CMakeLists.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Create another `CMakeLists.txt` file inside our `add_subdirectory(tests)` line
    that we had in our main `CMakeLists.txt` file. This `tests/CMakeLists.txt` file
    will manage the test sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `tests/CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's dissect this code line by line. The first line brings in the Google Test
    capability. The second line creates the `tests` executable, which will include
    all our test source files. In this case, we only have one `CanTest.cpp` file,
    which will just verify that the testing works. After that, we link the `GTest`
    library to the `tests` executable. The last line identifies all individual tests
    in the `tests` executable and adds them to `CMake` as a test. This way, various
    test tools will be able to tell us which individual tests failed and which ones
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `tests/CanTest.cpp` file. Add this code to simply verify that tests
    are running, without actually testing anything in our actual project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `TEST_F` line is an individual test. Now, `EXPECT_EQ(0, 0)` is testing whether
    zero is equal to zero, which will always succeed if we can actually run the test.
    We will later add the results of our own classes here to be tested against various
    values. Now we have the necessary setup for Google Test in our project. Next,
    we will build and run these tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building, Running, and Writing Unit Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we will discuss how to build, run, and write unit tests. The example that
    we have so far is a simple dummy test that is ready to be built and run. Later,
    we will add tests that make more sense and view the output of passing and failing
    tests. In the following exercise, we will build, run, and write unit tests for
    the project that we created in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Building and Running Tests'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, you have created a project with `GoogleTest` set up, but you did not
    build or run the tests we created. In this exercise, we will build and run the
    tests that we created. Since we added our `tests` folder using `add_subdirectory`,
    building the project will automatically build the tests. Running the tests will
    require some more effort. Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our CMake project in Eclipse CDT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build the tests, simply build the project just like you did before. Here
    is the output of building the project one more time from Eclipse after a full
    build using **Project** | **Build All**:![Figure 1.20: Build operation and its
    output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: Build operation and its output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you do not see this output, your console may be in the wrong view. You can
    correct it as shown in the following figures:![Figure 1.21: Viewing the correct
    console output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: Viewing the correct console output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.22: Viewing the correct console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: Viewing the correct console output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, our project now has two executable targets. They both live in
    the `build` folder, as with any other build artifact. Their locations are `build/Debug/CxxTemplate`
    and `build/Debug/tests/tests`. Since they are executables, we can simply run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We ran `CxxTemplate` before and will not see any extra output now. Run the
    other executable by typing the following command in the terminal while we are
    in our project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following output in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Running the tests executable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: Running the tests executable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is the simple output of our `tests` executable. If you want to see whether
    the tests have passed, you can simply run this. However, testing is so much more
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways you can run your tests is by using the `ctest` command. Write
    the following commands in the terminal while you are in the project folder. We
    go to the folder where the `tests` executable resides, run `ctest` there, and
    come back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output that you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24: Running ctest'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.24: Running ctest'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ctest` command can run your `tests` executable with a number of options,
    including the ability to submit test results automatically to online dashboards.
    Here, we will simply run the `ctest` command; its further features are left as
    an exercise for the interested reader. You can type `ctest --help` or visit the
    online documentation to discover `ctest` further at [https://cmake.org/cmake/help/latest/manual/ctest.1.html#](https://cmake.org/cmake/help/latest/manual/ctest.1.html#).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to run the tests is to run them inside Eclipse, in a nice graphical
    report format. For this, we will create a run configuration that is test-aware.
    In Eclipse, click on **Run** | **Run Configurations…**, right-click **C/C++ Unit**
    on the left, and select **New Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the name from **CxxTemplate Debug** to **CxxTemplate Tests** as follows:![Figure
    1.25: Changing the name of the run configuration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.25: Changing the name of the run configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Under **C/C++ Application**, select the **Search Project** option:![Figure
    1.26: Run Configurations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.26: Run Configurations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Choose **tests** in the new dialog:![Figure 1.27: Creating the test run configuration
    and selecting the tests executable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.27: Creating the test run configuration and selecting the tests executable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, go to the **C/C++ Testing** tab and select **Google Tests Runner** in
    the dropdown. Click on **Apply** at the bottom of the dialog and click on the
    **Run** option for the test that we have to run for the first time:![Figure 1.28:
    Run Configurations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.28: Run Configurations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the upcoming runs, you can either click the dropdown next to the play button
    in the toolbar, or choose **Run** | **Run History** to choose **CxxTemplate Tests**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The result will be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.30: Run results of the unit test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.30: Run results of the unit test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a nice report that contains entries for all tests—only one for now.
    You may prefer this if you do not want to leave the IDE. Furthermore, when you
    have many tests, this interface can help you filter them effectively. Now you
    have built and run tests that were written using Google Test. You ran them in
    a couple of different ways, including directly executing the test, using `ctest`,
    and using Eclipse CDT. In the next section, we will solve an exercise wherein
    we will actually test the functionality of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Testing the Functionality of Code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have run simple tests but now you want to write meaningful tests that are
    testing functionality. In the initial activity, we created `SumFunc.cpp`, which
    had the `sum` function. Now, in this exercise, we will write a test for that file.
    In this test, we will use the `sum` function to add two numbers and verify that
    the result is correct. Let''s recall the contents of the following files with
    the `sum` function from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/SumFunc.h`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`src/SumFunc.cpp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Relevant lines of `CMakeLists.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s recall our `CantTest.cpp` file, which has the `main()` function
    of our unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our CMake project in Eclipse CDT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new test source file (`tests/SumFuncTest.cpp`) with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this does not have a `main()` function since `CanTest.cpp` has one
    and these will be linked together. Secondly, note that this includes `SumFunc.h`,
    which is in the `sum(3, 4)` inside the test. This is how we use our project code
    in tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following change in the `tests/CMakeLists.txt` file to build the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added both the test (`SumFuncTest.cpp`) and the code that it tests
    (`../src/SumFunc.cpp`) to the executable, as our test code is using the code from
    the actual project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and run the test as before. You should see the following
    report:![Figure 1.31: Output after running the test'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.31: Output after running the test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can add such tests to our project and all of them will appear on the screen
    as shown in the preceeding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add one more test that will actually fail. In the `tests/SumFuncTest.cpp`
    file, make the following change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that this test assumes that the absolute values of the inputs are summed
    up, which is incorrect. The result of this call is `0` but is expected to be `6`
    in this example. This is the only change that we have to make in our project to
    add this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build the project and run the test. You should see this report:![Figure
    1.32: The build report'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.32: The build report'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see in the preceding figure, the first two tests passed and the
    last test failed. When we see this output, there are two options: either our project
    code is wrong, or the test is wrong. In this case, our test is wrong. This is
    because our `6` is equal to `sum(3, -3)`. This is because we assumed that our
    function sums up the absolute values of the integers provided. However, this is
    not the case. Our function simply adds the given numbers, whether they are positive
    or negative. Therefore, this test had a faulty assumption and failed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the test and fix it. Change the test so that we expect the sum
    of `-3` and `3` to be `0`. Rename the test to reflect what this test actually
    does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it now and observe in the report that all the tests pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.33: Test execution is successful'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.33: Test execution is successful'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, we have set up Google Test with CMake both in our system and project.
    We also wrote, built, and ran unit tests with Google Test, both in the terminal
    and in Eclipse. Ideally, you should write unit tests for every class and cover
    every possible usage. You should also run the tests after each major change and
    make sure you do not break existing code. In the next section, we will perform
    an activity of adding a new class and its test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Adding a New Class and Its Test'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you develop a C++ project, you add new source files to it as the project
    grows. You also write tests for them to ensure that they are working properly.
    In this activity, we will add a new class that simulates `1D` linear motion. The
    class will have double fields for `position` and `velocity`. It will also have
    a `advanceTimeBy()` method, which receives a double `dt` parameter, which modifies
    `position` based on the value of `velocity`. Use `EXPECT_DOUBLE_EQ` instead of
    `EXPECT_EQ` for double values. In this activity, we will add a new class and its
    test to the project. Follow these steps to perform this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project that we have created in the Eclipse IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `LinearMotion1D.cpp` and `LinearMotion1D.h` file pair to the project
    that contains the `LinearMotion1D` class. In this class, create two double fields:
    `position` and `velocity`. Also, create an `advanceTimeBy(double dt)` function
    that modifies `position`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for this in the `tests/LinearMotion1DTest.cpp` file. Write two tests
    that represent motion in two different directions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run it in the Eclipse IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the tests have passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final test results should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.34: Final test results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.34: Final test results'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 622.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new classes and their tests is a very common task in C++ development.
    We create classes for various reasons. Sometimes, we have a nice software design
    plan and we create the classes that it calls for. Other times, when a class becomes
    too large and monolithic, we separate some of its responsibility to another class
    in a meaningful way. Having this task be practical is important to prevent dragging
    your feet and ending up with huge monolithic classes. In the following section,
    we discuss what happens during the compilation and linking stages. This will give
    us a better perspective of what is happening under the hood of C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Compilation, Linking, and Object File Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main reasons for using C++ is efficiency. C++ gives us control over
    memory management, which is why understanding how objects are laid out in memory
    is important. Furthermore, C++ source files and libraries are compiled to object
    files for the target hardware and linked together. Often, C++ programmers have
    to deal with linker problems, which is why understanding the steps of the compilation
    and being able to investigate object files is important. On the other hand, large
    projects are developed and maintained by teams over a long period of time, which
    is why creating clean and understandable code is important. As with any other
    software, bugs arise in C++ projects and need to be identified, analyzed, and
    resolved carefully by observing the program behavior. Therefore, learning how
    to debug C++ code is also important. In the next section, we will learn how to
    create code that is efficient, plays well with other code, and is maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation and Linking Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A C++ project is created as a set of source code files and project configuration
    files that organize the sources and library dependencies. In the compilation step,
    these sources are first converted to object files. In the linking step, these
    object files are linked together to form the executable that is the ultimate output
    of the project. The libraries that the project uses are also linked at this step.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming exercises, we will use our existing project to observe the compilation
    and linking stages. Then, we will manually recreate them to view the process in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Identifying Build Steps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have been building your projects without investigating the details of the
    build actions. In this exercise, we will investigate the details of our project''s
    build steps. Perform the following to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `build` folder wherein our `Makefile` file resides by typing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Clean the project and run the build in `VERBOSE` mode using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a detailed output of the build process in the terminal, which
    may look a bit crowded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.35: The build process part 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.35: The build process part 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.36: The build process part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.36: The build process part 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 1.37: The full build output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.37: The full build output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are some of the lines from this output. The following lines are the important
    ones related to the compilation and linkage of the main executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `c++` command here is just a symbolic link to the `g++` compiler. To see
    that it''s actually a chain of symbolic links, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Therefore, we will use `c++` and `g++` interchangeably throughout our discussion.
    In the build output that we quoted earlier, the first four lines are compiling
    each `.cpp` source file and creating the corresponding `.o` object file. The last
    line is linking together these object files to create the `CxxTemplate` executable.
    The following figure visually presents this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.39: Execution stages of a C++ project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.39: Execution stages of a C++ project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As the previous figure shows, the CPP files that are added to CMake as a part
    of a target, along with the header files that they included, are compiled to object
    files, which are later linked together to create the target executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this process even further, let''s carry out the compilation steps
    ourselves. In the terminal, go to the project folder and create a new folder named
    `mybuild` using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following commands to compile the CPP source files to object
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Go into the `mybuild` directory and see what''s there using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the following output as expected. These are our object files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.40: Compiled object files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.40: Compiled object files'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the next step, link the object files together to form our executable. Type
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see our executable among the list of files here by typing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the new `CxxTemplate` file in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.41: Linked executable file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.41: Linked executable file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, run our executable by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And see the output that we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.42: Executable file output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.42: Executable file output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have examined the details of the build process and have recreated
    them yourself, in the next section, let's explore the linking process.
  prefs: []
  type: TYPE_NORMAL
- en: The Linking Step
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, let''s look at a connection between two source files and how
    they end up in the same executable. Look at the **sum** function in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.43: The linking process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.43: The linking process'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The **sum** function's body is defined in **SumFunc.cpp**. It has a forward
    declaration in **SumFunc.h**. This way, the source files that want to use the
    **sum** function can know about its signature. Once they know its signature, they
    can call it and trust that the actual function definition will be there during
    runtime, without actually having any interaction with **SumFunc.cpp** where the
    function is defined.
  prefs: []
  type: TYPE_NORMAL
- en: After compilation, **CxxTemplate.cpp**, which calls the **sum** function, carries
    that call into its object file. Still, it does not know where the function definition
    is. The object file of **SumFunc.cpp** has that definition, but it has nothing
    to do with **CxxTemplate.o**, yet.
  prefs: []
  type: TYPE_NORMAL
- en: During the linking step, the linker matches the call in **CxxTemplate.o** with
    the definition in **SumFunc.o**. The call works fine in the executable as a result.
    Had the linker not found the definition of the **sum** function, it would have
    given a linker error.
  prefs: []
  type: TYPE_NORMAL
- en: The linker finds the `symbol could not be resolved` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This took us through the two stages of the build process: `compilation` and
    `linking`. Notice that we used rather simpler commands compared to that of CMake,
    when we compiled our sources manually. Feel free to type `man g++` to see all
    the options there. Later, we discussed linking and how symbols are resolved. We
    also talked about possible issues with the linking step. In the next section,
    we will learn about object files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Diving Deeper: Viewing Object Files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the linking step to work without errors, we need to have all our symbol
    references match our symbol definitions. Most of the time, we can analyze how
    things will be resolved just by looking at the source files. Sometimes, in complex
    situations, we may have a difficult time understanding why a symbol is not being
    resolved. In such situations, looking at the contents of object files to investigate
    references and definitions can be useful to resolve the problem. Besides linker
    errors, understanding object file contents and how linking works in general is
    useful for a C++ programmer. Knowing what is happening under the hood may help
    programmers understand the whole process in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: When our source code is compiled to object files, our statements and expressions
    are converted to assembly code, which is the low-level language that the CPU understands.
    Each instruction in assembly contains an operation, followed by operators, which
    are registers of the CPU. There are instructions to load data to and from registers
    and operate on values in registers. The `objdump` command in Linux helps us view
    the contents of these object files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will utilize Compiler Explorer, a nice online tool that is easier to use,
    where you can write code on the window to the left, and on the right, you can
    see the compiled assembly code. Here is the link to the Compiler Explorer: [https://godbolt.org](https://godbolt.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Exploring Compiled Code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use Compiler Explorer to compile some simple C++
    code in which we define and call a function. We will investigate the compiled
    assembly code to understand how exactly names are resolved and calls are made.
    This will give us a better understanding of what happens under the hood and how
    our code works in the executable format. Perform the following steps to complete
    the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in `call sum(int, int)` line does what you expect: it
    calls the preceding `sum` function and places the arguments in some registers.
    The important point here is that the functions are identified by their names and
    the types of their parameters in order. The linker looks for the appropriate function
    with this signature. Note that the return value is not a part of the signature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `_Z`, the number tells us how long the function name is, so that
    the following letters are correctly interpreted. After the function name, we have
    `v` for no parameters and `i` for an `int` parameter. You can change these function
    signatures to view other possible types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s look at how classes are compiled. Add the following code into **Compiler
    Explorer** under the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the compiled version of these added lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.46: The compiled version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.46: The compiled version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may be surprised that there is no class definition in the compiled code.
    The methods are similar to global functions, but with a twist: their mangled names
    contain the class name and they receive the object instance as a parameter. Creating
    an instance simply allocates space for the fields of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: During the linker phase, these mangled function names are used to match callers
    with callees. For callers that cannot find a callee, we get linker errors. Most
    linker errors can be resolved by carefully checking sources. However, in some
    cases, viewing the object file contents with `objdump` can help get to the bottom
    of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging C++ Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different levels of problems that you can come across while developing
    a C++ project:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you may receive compiler errors. These can happen because of a mistake
    you made in syntax, or a wrong choice for a type, and so on. The compiler is the
    first hoop you have to jump through, and it catches some mistakes you may have
    made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second hoop is the linker. There, a typical mistake is to use something
    that is declared, but not actually defined. This happens often when you use the
    wrong header file for a library—the header file advertises a certain signature
    that does not exist in any of the source files or libraries. Once you also jump
    through the linker hoop, your program is ready to execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the next hoop to jump through is to avoid any runtime errors. Your code
    may have compiled and linked properly, but it may be doing things that do not
    work, such as dereferencing a null pointer or dividing by zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find and fix runtime errors, you have to interact with and monitor the running
    application in some way. An often-used technique is to add `print` statements
    to the code and monitor the logs that it generates, hoping to correlate the application
    behavior with the logs to pinpoint the region in code that has the problem. While
    this works for some cases, sometimes you need to take a closer look at the execution.
  prefs: []
  type: TYPE_NORMAL
- en: A debugger is a better tool to fight runtime errors. A debugger can let you
    run code line by line, continue running and pause on the lines that you want,
    investigate the values of memory, and pause on errors, among other things. This
    lets you watch what exactly is going on with memory as your program is running
    and identify the line of code that results in the unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '`gdb` is the canonical command-line debugger that can debug C++ programs. However,
    it may be difficult to use as debugging is inherently a visual task—you want to
    be able to look at lines of code, values of variables, and the output of the program
    at the same time. Luckily, Eclipse CDT includes a visual debugger that is easy
    to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Debugging with Eclipse CDT'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have been simply running your projects and viewing the output. Now you
    want to learn how to debug your code in detail. In this exercise, we will explore
    Eclipse CDT''s debugging capabilities. Perform the following steps to complete
    the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CMake project in Eclipse CDT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that we have an existing run configuration, click **Run** | **Run
    Configurations**. There, you should see a **CxxTemplate** entry under **C/C++
    Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we ran our project before, it should be there. If not, please go back
    and create it again.
  prefs: []
  type: TYPE_NORMAL
- en: Close the dialog box to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start the debugger, find the toolbar entry that looks like an insect (bug)
    and click on the dropdown next to it. Select `main()` function, which is shown
    with the green highlight and the arrow in the center code view. On the left, we
    see the running threads, of which there is only one. On the right, we see the
    variables that are accessible in this context. On the bottom, we see the **gdb**
    output that Eclipse uses behind the scenes to actually debug the executable. Now,
    there is not much to be debugged with our main function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `libc-start.c` library, which is the caller of the `main` function. You
    can close it and switch to your source files when done. When you do not see the
    red stop button anymore, you know that the program execution is over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit our `main` function by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The post-increment operator mixed with the occasional `do-while` loop can be
    a head-scratcher for some. This is because we try to execute the algorithm in
    our heads. However, our debugger is perfectly able to run it step by step and
    show us what exactly happens during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start debugging after adding the preceding code. Click on the dropdown next
    to the **Debug** button in the toolbar and select **CxxTemplate**. Press *F6*
    a couple of times to step over in the code. It will show us how the variables
    change as well as the line of code that will be executed next:![Figure 1.48: Stepping
    over the code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.48: Stepping over the code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Seeing the variables change after the execution of each line of code makes
    the algorithm much clearer to understand. As you press *F6*, note that the following
    are the values after each execution of the `t += i++;` line:![Figure 1.49: Variable
    states through time'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.49: Variable states through time'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding output clearly explains how the values are changing and why `6`
    is printed at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore other features of the debugger. While the variable view is useful,
    you can also hover over any variable and browse its value:![Figure 1.50: View
    option of the debugger'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.50: View option of the debugger'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Furthermore, the **Expression** view helps you calculate things that are otherwise
    not clear from the values that you browse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Expression** on the right-hand side and click on the **Add** button:![Figure
    1.51: Adding an expression'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.51: Adding an expression'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type **t+i** and hit *Enter*. Now you see the total in the list of expressions:![Figure
    1.52: Expression view with a new expression'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.52: Expression view with a new expression'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can press the red square in the toolbar or select **Run** | **Terminate**
    to stop debugging at any time. Another feature is breakpoints, which tell the
    debugger to pause whenever it goes to a line marked with a breakpoint. So far,
    we have been stepping through our code line by line, which may be very time-consuming
    in a large project. Instead, you usually want to continue the execution until
    it arrives at the code that you are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of going line by line, add a breakpoint in the line that does
    the printing. For this, double-click on the area to the left of the line number
    of this line. In the following figure, the dot represents a breakpoint:![Figure
    1.53: Working with breakpoints'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.53: Workin with breakpoints'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now start the debugger. As usual, it will start paused. Now select **Run**
    | **Resume** or click on the toolbar button. It will run the three executions
    of the loop and pause at our breakpoint. This way, we saved time by stepping through
    code that we are not investigating:![Figure 1.54: Working with the debugger'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.54: Working with the debugger'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While we have been dealing with the loop that we added, we ignored the line
    that creates an `app` object. The **Step Over** command was skipping this line.
    However, we also have the option to go into the constructor call that is in this
    line. For that, we will use **Run** | **Step Into** or the corresponding toolbar
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stop the debugger and start it again. Click on **Step Over** to go to the line
    where the application is created:![Figure 1.55: Working with the debugger – the
    Step Over option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14508_01_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.55: Working with the debugger – the Step Over option'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The highlighted is the next line that would be executed if we step over again.
    Instead, press the Step Into button. This will take us into the constructor call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.56: Working with the debugger – the Step Into option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14508_01_56.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.56: Working with the debugger – the Step Into option'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a handy feature for diving deeper into the function instead of simply
    stepping over it. Also, notice the call stack in the left debug view. You can
    always click on the lower entries to go and view the callers' contexts again.
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to the Eclipse CDT debugger, which uses GDB under
    the hood to give you a visual debugging experience. You may find debugging useful
    when trying to understand runtime errors better and correcting the mistakes that
    caused them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Readable Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While visual debuggers are quite useful to identify and eliminate runtime errors
    or unintended program behavior, it is a better idea to write code that is less
    likely to have problems to begin with. One way to do that is to strive to write
    code that is easier to read and to understand. Then, finding problems in code
    becomes more like identifying contradictions between English sentences and less
    like solving cryptic puzzles. When you are writing code in a way that is understandable,
    your mistakes will often be apparent as you are making them and will be easier
    to spot when you come back to solve problems that slipped through.
  prefs: []
  type: TYPE_NORMAL
- en: After some unenjoyable maintenance experiences, you realize that the primary
    purpose of the programs that you write is not to make the computer do what you
    want to, but to tell the reader what the computer will do when the program runs.
    This usually means that you need to do more typing, which IDEs can help with.
    This may also mean that you sometimes write code that is not the most optimal
    in terms of execution time or memory used. If this goes against what you have
    learned, consider that you may be trading a minuscule amount of efficiency for
    the risk of being incorrect. With the vast processing power and memory at our
    disposal, you may be making your code unnecessarily cryptic and possibly buggy
    in the vain quest for efficiency. In the next sections, we will list some rules
    of thumb that may help you write code that is more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation and Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ code, as in many other programming languages, is composed of program blocks.
    A function has a set of statements that form its body as a block. A loop's block
    statements will execute in iterations. An `if` statement's block executes if the
    given condition is true and the corresponding `else` statement's block executes
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Curly braces, or lack thereof for single-statement blocks, inform the computer,
    whereas indentation in the form of white space informs the human reader about
    the block structure. The lack of indentation, or misleading indentation, can make
    it very difficult for the reader to understand the structure of the code. Therefore,
    we should strive to keep our code well-indented. Consider the following two code
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'While they are identical in terms of execution, it is much clearer in the second
    one that `firstFunction()` is executed only if `result` is `2`. Now consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is simply misleading. If the reader is not careful, they might easily assume
    that `secondFunction()` is executed only if `result` is `2`. However, this code
    is identical to the two previous examples in terms of execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like correcting indentation is slowing you down, you can use your
    editor's formatting facilities to help you. In Eclipse, you can select a block
    of code and use **Source** | **Correct Indentation** to fix the indentation of
    that selection, or use **Source** | **Format** to also fix other formatting issues
    with code.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond indentation, other formatting rules such as placing the curly brace at
    the correct line, inserting spaces around binary operators, and inserting a space
    after each comma are also very important formatting rules that you should abide
    by to keep your code well-formatted and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: In Eclipse, you can set formatting rules per-workspace in **Window** | **Preferences**
    | **C/C++** | **Code Style** | **Formatter** or per-project in **Project** | **Properties**
    | **C/C++ General** | **Formatter**. You can either select one of the industry-standard
    styles such as K&R or GNU, or you can modify them and create your own. This becomes
    especially important when you use **Source** | **Format** to format your code.
    For example, if you choose to use spaces for indentation but Eclipse's formatting
    rules are set to tabs, your code would become a mixture of tabs and spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Use Meaningful Names as Identifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our code, we use identifiers to name many items—variables, functions, class
    names, types, and so on. For the computer, these identifiers are merely a sequence
    of characters to distinguish them from one another. However, for the reader, they're
    much more. The identifier should completely and unambiguously describe the item
    that it represents. At the same time, it should not be overly long. Furthermore,
    it should abide by the style standards that are in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While this is a perfectly valid piece of C++ code, it is quite difficult to
    read. Let's list the problems with it. First of all, let's look at the style problems
    of the identifiers. The `studentsFile` class name starts with a lowercase letter,
    which should have been uppercase instead. The `File` variable should have started
    with a lowercase letter. The `Count_Names` variable should have started with a
    lowercase letter and should not have had an underscore in it. The `CheckNextElement`
    method should have started with a lowercase letter. While these may seem arbitrary
    rules, being consistent in naming carries extra information about the name—when
    you see a word that starts with an uppercase letter, you immediately understand
    that it must be a class name. Furthermore, it is simply a distraction to have
    names that do not obey the standard in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look beyond the style and inspect the names themselves. The first
    problematic name is the `runFileCheck` function. A method is an action that returns
    a value: its name should both clearly explain what it does as well as what it
    returns. "Check" is an overused word that is too vague for most situations. Yes,
    we checked it, it''s there—what should we do with it then? In this case, it seems
    we actually read the file and create a `File` object. In that case, `runFileCheck`
    should have been `readFile` instead. This clearly explains the action being taken,
    and the return value is what you would expect. If you wanted to be more specific
    about the return value, `readAsFile` could be another alternative. Similarly,
    the `check` method is vague and should be `exists` instead. The `CheckNextElement`
    method is also vague and should be `nextElementExists` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Another overused vague word is `flag`, which is often used for Boolean variables.
    The name suggests an on/off situation but gives no clue as to what its value would
    mean. In this case, its `true` value means that the file exists, and the `false`
    value means that the file does not exist. The trick for naming Boolean variables
    is to devise a question or statement that is correct when the value of the variable
    is `true`. In this example, `fileExists` and `doesFileExist` are two good choices.
  prefs: []
  type: TYPE_NORMAL
- en: Our next misnamed variable is `Count_Names`, or `countNames` with its correct
    capitalization. This is a bad name for an integer because the name does not suggest
    a number—it suggests an action that results in a number. Instead, an identifier
    such as `numNames` or `nameCount` would clearly communicate what the number inside
    means.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Algorithms Clear and Simple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we read code, the steps that are taken and the flow should make sense.
    Things that are done indirectly—byproducts of functions, multiple actions being
    done together in the name of efficiency, and so on—are things that make it difficult
    to understand your code for the reader. For example, let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an array that we are processing in a loop. At first glance, it
    is not very clear what exactly the loop is doing. The variable names are helping
    us understand what is going on, but we must run the algorithm in our heads to
    be sure that what's being advertised by those names is really happening here.
    There are three different operations that are taking place in this loop. Firstly,
    we are finding the sum of all the elements. Secondly, we are finding the minimum
    element in the array. Thirdly, we are taking the absolute value of each element
    after these operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this alternative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now everything is much clearer. The first loop finds the sum of the inputs,
    the second loop finds the minimum element, and the third loop finds the absolute
    value of each element. Although it's much clearer and more understandable, you
    may feel like you are doing three loops, and therefore wasting CPU resources.
    The drive to create more efficient code may compel you to merge these loops. Note
    that the efficiency gains you have here would be minuscule; your program's time
    complexity would still be O(n).
  prefs: []
  type: TYPE_NORMAL
- en: While creating code, readability and efficiency are two constraints that can
    often be in competition. If you want to develop readable and maintainable code,
    you should always prioritize readability. Then, you should strive to develop code
    that is also efficient. Otherwise, code that has low readability risks being difficult
    to maintain, or worse, risks having bugs that are difficult to identify and fix.
    Your program's high efficiency would be irrelevant when it is producing incorrect
    results or when the cost of adding new features to it becomes too high.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Making Code Readable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are style and indentation problems in the following code. Spaces are
    used inconsistently, and the indentation is incorrect. Also, the decision on single-statement
    `if` blocks having curly braces or not is inconsistent. The following piece of
    code has problems in terms of indentation, formatting, naming, and clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fix these problems and make it compatible with a common C++ code style.
    Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse CDT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `a`, whose length is `Len`. Better names for these would be `input`
    and `inputLength`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's make that first change and rename `a` to `input`. If you are using Eclipse,
    you can select `Len` and rename it to `inputLength`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The updated code will look like the following. Note that we do not need the
    comment anymore since parameter names are self-explanatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have a couple of other variables defined before the loop. Let's try to understand
    them. It seems all it does with `S` is to add each element to it. Therefore, `S`
    must be `sum`. `M`, on the other hand, seems to be the minimum element—let's name
    it `smallest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Lim_value` seems to be a threshold, where we simply want to know whether it
    has been crossed. Let''s rename it `topThreshold`. The `flag` variable is set
    to true if this threshold is crossed. Let''s rename it to `isTopThresholdCrossed`.
    Here is the state of the code after these changes with **Refactor** | **Rename**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how we can make this code simpler and easier to understand.
    The preceding code is doing these things: calculating the sum of the input elements,
    finding the smallest one, determining whether the top threshold was crossed, and
    multiplying each element by two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all of these are done in the same loop, the algorithm is not very clear
    now. Fix that and have four separate loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now the code is much clearer. While it's very easy to understand what each block
    is doing, we also added comments to make it even more clear. In this section,
    we gained a better understanding of how our code is converted to executables.
    Then, we discussed ways of identifying and resolving possible errors with our
    code. We finalized this with a discussion about how to write readable code that
    is less likely to have problems. In the next section, we will solve an activity
    wherein we will be making code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Making Code More Readable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have code that is unreadable and contains bugs, either because you
    wrote it in a hurry, or you received it from someone else. You want to change
    the code to eliminate its bugs and to make it more readable. We have a piece of
    code that needs to be improved. Improve it step by step and resolve the issues
    using a debugger. Perform the following steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Below you will find the source for `SpeedCalculator` class. Add these two files
    to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of this class in your `main()` function and call its `run()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the style and naming problems in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify the code to make it more understandable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and observe the problem at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the debugger to fix the problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the code for **SpeedCalculator.cpp** and **SpeedCalculator.h** that
    you will add to your project. You will modify them as a part of this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 626.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create C++ projects that are portable and
    maintainable. We first learned how to create CMake projects and how to import
    them to Eclipse CDT, giving us the choice to use the command line or an IDE. The
    rest of the chapter focused on eliminating various problems in our projects. First,
    we learned how to add unit tests to a project and how to use them to ensure that
    our code works as intended. We continued this with a discussion about the compilation
    and linking steps that our code goes through and observed the contents of object
    files to gain a better understanding of executable files. Then, we learned how
    to debug our code visually in the IDE to eliminate runtime errors. We finished
    this discussion with a number of rules of thumb that help create readable, understandable,
    and maintainable code. These methods will come in handy on your C++ journey. In
    the next chapter, we will learn more about C++'s type system and templates.
  prefs: []
  type: TYPE_NORMAL
